[
    {
        "title": "Find All People With Secret",
        "question_content": "You are given an integer n indicating there are n people numbered from 0 to n - 1. You are also given a 0-indexed 2D integer array meetings where meetings[i] = [xi, yi, timei] indicates that person xi and person yi have a meeting at timei. A person may attend multiple meetings at the same time. Finally, you are given an integer firstPerson.\nPerson 0 has a secret and initially shares the secret with a person firstPerson at time 0. This secret is then shared every time a meeting takes place with a person that has the secret. More formally, for every meeting, if a person xi has the secret at timei, then they will share the secret with person yi, and vice versa.\nThe secrets are shared instantaneously. That is, a person may receive the secret and share it with people in other meetings within the same time frame.\nReturn a list of all the people that have the secret after all the meetings have taken place. You may return the answer in any order.\n&nbsp;\nExample 1:\n\nInput: n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1\nOutput: [0,1,2,3,5]\nExplanation:\nAt time 0, person 0 shares the secret with person 1.\nAt time 5, person 1 shares the secret with person 2.\nAt time 8, person 2 shares the secret with person 3.\nAt time 10, person 1 shares the secret with person 5.​​​​\nThus, people 0, 1, 2, 3, and 5 know the secret after all the meetings.\n\nExample 2:\n\nInput: n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3\nOutput: [0,1,3]\nExplanation:\nAt time 0, person 0 shares the secret with person 3.\nAt time 2, neither person 1 nor person 2 know the secret.\nAt time 3, person 3 shares the secret with person 0 and person 1.\nThus, people 0, 1, and 3 know the secret after all the meetings.\n\nExample 3:\n\nInput: n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1\nOutput: [0,1,2,3,4]\nExplanation:\nAt time 0, person 0 shares the secret with person 1.\nAt time 1, person 1 shares the secret with person 2, and person 2 shares the secret with person 3.\nNote that person 2 can share the secret at the same time as receiving it.\nAt time 2, person 3 shares the secret with person 4.\nThus, people 0, 1, 2, 3, and 4 know the secret after all the meetings.\n\n&nbsp;\nConstraints:\n\n\t2 <= n <= 105\n\t1 <= meetings.length <= 105\n\tmeetings[i].length == 3\n\t0 <= xi, yi <= n - 1\n\txi != yi\n\t1 <= timei <= 105\n\t1 <= firstPerson <= n - 1",
        "solutions": [
            {
                "id": 1599815,
                "title": "c-union-find",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1. Union Find\\n\\nSort `meetings` in ascending order of meeting time.\\n\\nVisit the meetings happening at the same time together.\\n\\nWe can connect the two persons in the same meeting using a UnionFind.\\n\\nTricky point here: After traversing this batch of meetings, we reset the persons who don\\'t know the secret by checking if he/she is connected to person 0. With UnionFind, reseting means setting `id[x] = x`.\\n\\nIn the end, we add all the persons who are connected to person 0 into the answer array.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/find-all-people-with-secret/\\n// Author: github.com/lzl124631x\\n// Time: O(MlogM + (M + N) * logN) where `M` is the length of `meetings`\\n//        Can be reduced to `O(MlogM + (M + N) * alpha(N))`\\n// Space: O(M + N). Can be reduced to O(N) if we make `ppl` an `unordered_set`.\\nclass UnionFind {\\n    vector<int> id;\\npublic:\\n    UnionFind(int n) : id(n) {\\n        iota(begin(id), end(id), 0);\\n    }\\n    void connect(int a, int b) {\\n        id[find(b)] = find(a);\\n    }\\n    int find(int a) {\\n        return id[a] == a ? a : (id[a] = find(id[a]));\\n    }\\n    bool connected(int a, int b) {\\n        return find(a) == find(b);\\n    }\\n    void reset(int a) { id[a] = a; }\\n};\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& A, int firstPerson) {\\n        sort(begin(A), end(A), [](auto &a, auto &b) { return a[2] < b[2]; }); // Sort the meetings in ascending order of meeting time\\n        UnionFind uf(n);\\n        uf.connect(0, firstPerson); // Connect person 0 with the first person\\n        vector<int> ppl;\\n        for (int i = 0, M = A.size(); i < M; ) {\\n            ppl.clear();\\n            int time = A[i][2];\\n            for (; i < M && A[i][2] == time; ++i) { // For all the meetings happening at the same time\\n                uf.connect(A[i][0], A[i][1]); // Connect the two persons\\n                ppl.push_back(A[i][0]); // Add both persons into the pool\\n                ppl.push_back(A[i][1]);\\n            }\\n            for (int n : ppl) { // For each person in the pool, check if he/she\\'s connected with person 0.\\n                if (!uf.connected(0, n)) uf.reset(n); // If not, this person doesn\\'t have secret, reset it.\\n            }\\n        }\\n        vector<int> ans;\\n        for (int i = 0; i < n; ++i) {\\n            if (uf.connected(0, i)) ans.push_back(i); // Push all the persons who are connected with person 0 into answer array\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Complexity Analysis**:\\n\\nSorting takes `O(MlogM)` time.\\n\\nEach meeting is visited and pushed into/popped out of `ppl` only once. For each visit, the `connect`/`connected` takes amortized `O(logN)` time. So, traversing all the meetings takes `O(MlogN)` time. Note that if we do union-by-rank, the time complexity can be reduced to `O(M * alpha(N))` where `alpha(N)` is the inverse function of Ackermann function, and is even more efficient than `logN`. But in LeetCode, the difference is negligible, so I usually just use path compression for simplicity. It\\'s definitly worth mentioning this knowledge during your interview though.\\n\\nLastly, traversing all the persons and checking connection with person 0 takes amortized `O(NlogN)` time.\\n\\nSo, overall the **time complexity** is amortized `O(MlogM + (M + N) * logN)`, which can be reduced to `O(MlogM + (M + N) * alpha(N))` with union-by-rank.\\n\\nAs for space complexity, the Union Find takes `O(N)` space. The `ppl` array takes `O(M)` space in the worst case, but it can be reduced to `O(N)` if we use `unordered_set`. I use `vector<int>` because `unordered_set<int>` has extra overhead which at times consumes more time/space than `vector<int>` in LeetCode.\\n\\nSo, overall the **(extra) space complexity** is `O(M + N)` which can be reduced to `O(N)`.\\n",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/find-all-people-with-secret/\\n// Author: github.com/lzl124631x\\n// Time: O(MlogM + (M + N) * logN) where `M` is the length of `meetings`\\n//        Can be reduced to `O(MlogM + (M + N) * alpha(N))`\\n// Space: O(M + N). Can be reduced to O(N) if we make `ppl` an `unordered_set`.\\nclass UnionFind {\\n    vector<int> id;\\npublic:\\n    UnionFind(int n) : id(n) {\\n        iota(begin(id), end(id), 0);\\n    }\\n    void connect(int a, int b) {\\n        id[find(b)] = find(a);\\n    }\\n    int find(int a) {\\n        return id[a] == a ? a : (id[a] = find(id[a]));\\n    }\\n    bool connected(int a, int b) {\\n        return find(a) == find(b);\\n    }\\n    void reset(int a) { id[a] = a; }\\n};\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& A, int firstPerson) {\\n        sort(begin(A), end(A), [](auto &a, auto &b) { return a[2] < b[2]; }); // Sort the meetings in ascending order of meeting time\\n        UnionFind uf(n);\\n        uf.connect(0, firstPerson); // Connect person 0 with the first person\\n        vector<int> ppl;\\n        for (int i = 0, M = A.size(); i < M; ) {\\n            ppl.clear();\\n            int time = A[i][2];\\n            for (; i < M && A[i][2] == time; ++i) { // For all the meetings happening at the same time\\n                uf.connect(A[i][0], A[i][1]); // Connect the two persons\\n                ppl.push_back(A[i][0]); // Add both persons into the pool\\n                ppl.push_back(A[i][1]);\\n            }\\n            for (int n : ppl) { // For each person in the pool, check if he/she\\'s connected with person 0.\\n                if (!uf.connected(0, n)) uf.reset(n); // If not, this person doesn\\'t have secret, reset it.\\n            }\\n        }\\n        vector<int> ans;\\n        for (int i = 0; i < n; ++i) {\\n            if (uf.connected(0, i)) ans.push_back(i); // Push all the persons who are connected with person 0 into answer array\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599972,
                "title": "c-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) { \\n\\t\\t// create the graph betwen the persons\\n        vector<vector<pair<int,int>>> graph(n);\\n        for(int i = 0; i < meetings.size(); ++i){\\n            graph[meetings[i][0]].push_back({meetings[i][1],meetings[i][2]});\\n            graph[meetings[i][1]].push_back({meetings[i][0],meetings[i][2]});\\n        }\\n\\n\\t\\t// using min heap , using time as the sort order key.   \\n        priority_queue<pair<int,int> , vector<pair<int,int> > , greater<pair<int,int>> > q;\\n\\t\\t\\n\\t\\t// Add both 0 and firstPerson in the queue as they know the secret initially at time 0 \\n        q.push({0, firstPerson});\\n        q.push({0, 0});\\n\\t\\t//  vector to store res  \\n        vector<int> res;\\n\\t\\t\\n\\t\\t// marking the persons as visited if they have met and shared the secret to all possible persons they could \\n        vector<bool> visited(n,false);\\n        \\n        while(!q.empty()){\\n            pair<int,int> curr = q.top();\\n            q.pop();\\n            \\n            int person = curr.second;\\n            int time = curr.first;\\n\\t\\t\\t\\n\\t\\t\\t// person had already shared the secret with others\\n            if(visited[person]) {\\n                continue;\\n            }\\n            visited[person] = true;\\n\\t\\t\\t\\n\\t\\t\\t//iterate all the meetings of this person and add the potential new persons he can share secret with \\n            for(pair<int,int> neigh : graph[person]){\\n                if(!visited[neigh.first] && time <= neigh.second){\\n                    q.push({neigh.second,neigh.first});\\n                }\\n            }\\n        }\\n        \\n\\t\\t// all visited persons know the secret\\n        for(int i = 0; i < n ; ++i ){\\n            if(visited[i]){\\n                res.push_back(i);        \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) { \\n\\t\\t// create the graph betwen the persons\\n        vector<vector<pair<int,int>>> graph(n);\\n        for(int i = 0; i < meetings.size(); ++i){\\n            graph[meetings[i][0]].push_back({meetings[i][1],meetings[i][2]});\\n            graph[meetings[i][1]].push_back({meetings[i][0],meetings[i][2]});\\n        }\\n\\n\\t\\t// using min heap , using time as the sort order key.   \\n        priority_queue<pair<int,int> , vector<pair<int,int> > , greater<pair<int,int>> > q;\\n\\t\\t\\n\\t\\t// Add both 0 and firstPerson in the queue as they know the secret initially at time 0 \\n        q.push({0, firstPerson});\\n        q.push({0, 0});\\n\\t\\t//  vector to store res  \\n        vector<int> res;\\n\\t\\t\\n\\t\\t// marking the persons as visited if they have met and shared the secret to all possible persons they could \\n        vector<bool> visited(n,false);\\n        \\n        while(!q.empty()){\\n            pair<int,int> curr = q.top();\\n            q.pop();\\n            \\n            int person = curr.second;\\n            int time = curr.first;\\n\\t\\t\\t\\n\\t\\t\\t// person had already shared the secret with others\\n            if(visited[person]) {\\n                continue;\\n            }\\n            visited[person] = true;\\n\\t\\t\\t\\n\\t\\t\\t//iterate all the meetings of this person and add the potential new persons he can share secret with \\n            for(pair<int,int> neigh : graph[person]){\\n                if(!visited[neigh.first] && time <= neigh.second){\\n                    q.push({neigh.second,neigh.first});\\n                }\\n            }\\n        }\\n        \\n\\t\\t// all visited persons know the secret\\n        for(int i = 0; i < n ; ++i ){\\n            if(visited[i]){\\n                res.push_back(i);        \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599887,
                "title": "c-simple-solution-w-explanation-sort-by-time-disjoin-set-union",
                "content": "\\u2714\\uFE0F ***Solution***\\n\\nInitially, person `0` and person `firstPerson` know the secret.\\nAfter that, at each meeting the person who knows the secret share it with the other.\\nOne person can attend multiple meetings.\\n\\nWe need to iterate over meetings in sorted order of time so that we know all the persons who know the secret before next meeting at a time `t` begins.\\n\\nHere, `curSecrets` denote set of people who know the secret before the current meeting at time `t` started.\\nAll people who met with a person in `curSecrets` set will know the secret. On top of that, these people will also share the secret with other people whom they meet. \\nThus, the people form disjoin sets after meeting with each other.\\nThis is why we maintain a DSU to know the group of people who are directly or indirectly connected with people knowing secret.\\n\\nOnce we union all the people who met at a time `t`, then we again iterate over all people involved in that meet. All those people whose parents in DSU are the same as parents of people knowing secrets initially (members of `curSecrets`) are the ones who got to know the secret after the set of meetings at time `t`. So we add these people in list of people knowing the secret (denoted by `secrets`). Finally after all we meetings are over, we return this list.\\n\\n**C++**\\n```cpp\\n// standard DSU template with slight modifications in par & sz\\nclass DSU {\\npublic:\\n    unordered_map<int, int> par, sz;            // par denotes representative of a component, sz denotes size\\n    void init(vector<pair<int, int>>& meets) {\\n        par.clear(); sz.clear();\\n\\t\\t// initially all person are set as their own parents and size of each component = 1\\n        for(auto& [i, j] : meets) par[i] = i, par[j] = j, sz[i] = sz[j] = 1;\\n    }\\n    int find(int x) {                          // find parent of a given member x\\n        return par[x] == x ? x : par[x] = find(par[x]);\\n    }\\n    void Union(int x, int y) {                 // unions two component by size\\n        int xp = find(x), yp = find(y);\\n        if(xp == yp) return;\\n        if(sz[xp] > sz[yp]) par[yp] = par[xp], sz[xp] += sz[yp];\\n        else par[xp] = par[yp], sz[yp] += sz[xp];\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& M, int F) {\\n        map<int, vector<pair<int, int>>> mp;             // {time: [meetingPair]}\\n        unordered_set<int> secrets{0, F}, curSecrets, pars;\\n        DSU d;\\n        for(auto& m : M) \\n            mp[m[2]].emplace_back(m[0], m[1]);\\n        \\n        for(auto& [t, meets] : mp) {\\n            curSecrets.clear();\\n            d.init(meets);\\n            for(auto& [i, j] : meets) {\\n                d.Union(i, j);                                  // two people meeting together are unioned into single group\\n                if(secrets.count(i)) curSecrets.insert(i);      // curSecret is filled with people knowing secret before time t\\n                if(secrets.count(j)) curSecrets.insert(j);\\n            }\\n            if(!size(curSecrets)) continue;\\n            pars.clear();\\n            for(auto person : curSecrets) \\n\\t\\t\\t\\tpars.insert(d.find(person));                    // get parents in DSU of all person who initially knew secret\\n\\t\\t\\t\\n\\t\\t\\t// if parent of a new person equals parent of person who knew secret, then add it to global set of people who know secret\\n            for(auto& [i, j] : meets) {\\n                if(pars.count(d.find(i))) secrets.insert(i);   \\n                if(pars.count(d.find(j))) secrets.insert(j);\\n            }\\n        }\\n        \\n        return vector<int>{ begin(secrets), end(secrets) };\\n    }\\n};\\n```\\n\\n***Time Complexity :*** `O(MlogM)`, where `M` is the number of meetings\\n***Space Complexity :*** `O(M)`",
                "solutionTags": [],
                "code": "```cpp\\n// standard DSU template with slight modifications in par & sz\\nclass DSU {\\npublic:\\n    unordered_map<int, int> par, sz;            // par denotes representative of a component, sz denotes size\\n    void init(vector<pair<int, int>>& meets) {\\n        par.clear(); sz.clear();\\n\\t\\t// initially all person are set as their own parents and size of each component = 1\\n        for(auto& [i, j] : meets) par[i] = i, par[j] = j, sz[i] = sz[j] = 1;\\n    }\\n    int find(int x) {                          // find parent of a given member x\\n        return par[x] == x ? x : par[x] = find(par[x]);\\n    }\\n    void Union(int x, int y) {                 // unions two component by size\\n        int xp = find(x), yp = find(y);\\n        if(xp == yp) return;\\n        if(sz[xp] > sz[yp]) par[yp] = par[xp], sz[xp] += sz[yp];\\n        else par[xp] = par[yp], sz[yp] += sz[xp];\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& M, int F) {\\n        map<int, vector<pair<int, int>>> mp;             // {time: [meetingPair]}\\n        unordered_set<int> secrets{0, F}, curSecrets, pars;\\n        DSU d;\\n        for(auto& m : M) \\n            mp[m[2]].emplace_back(m[0], m[1]);\\n        \\n        for(auto& [t, meets] : mp) {\\n            curSecrets.clear();\\n            d.init(meets);\\n            for(auto& [i, j] : meets) {\\n                d.Union(i, j);                                  // two people meeting together are unioned into single group\\n                if(secrets.count(i)) curSecrets.insert(i);      // curSecret is filled with people knowing secret before time t\\n                if(secrets.count(j)) curSecrets.insert(j);\\n            }\\n            if(!size(curSecrets)) continue;\\n            pars.clear();\\n            for(auto person : curSecrets) \\n\\t\\t\\t\\tpars.insert(d.find(person));                    // get parents in DSU of all person who initially knew secret\\n\\t\\t\\t\\n\\t\\t\\t// if parent of a new person equals parent of person who knew secret, then add it to global set of people who know secret\\n            for(auto& [i, j] : meets) {\\n                if(pars.count(d.find(i))) secrets.insert(i);   \\n                if(pars.count(d.find(j))) secrets.insert(j);\\n            }\\n        }\\n        \\n        return vector<int>{ begin(secrets), end(secrets) };\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599942,
                "title": "java-union-find-with-reset-2-solutions",
                "content": "**\\u25CF Idea**\\n\\nIntuition 1.\\nPairs=connections=graph. If we want to propagate the value of some property to connected nodes usually it means we have to use a union find ds since it\\'s more efficient than going through all connected nodes each time and update. (When propagating on a range we usually use Segment Tree).\\n\\nIntuition 2.\\nIf someone from current time knows the secret, the next times these people can tell the secret to others. \\nAlso if someone from current time knows the secret, people who they contacted previously can\\'t know the secret.\\nWe reset the connections of people who talked to each other but don\\'t know the secret - these connections shouldn\\'t affect future meetings.\\n\\n**\\u25CF Solutions**\\n\\n**\\u25CB Solution 1**\\n\\nClean solution with treemap.\\n```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n\\t\\n\\t\\t// create <time, index> map\\n        Map<Integer, List<Integer>> timeToIndexes = new TreeMap<>();\\n        int m = meetings.length;\\n        for (int i = 0; i < m; i++) {\\n            timeToIndexes.putIfAbsent(meetings[i][2], new ArrayList<>());\\n            timeToIndexes.get(meetings[i][2]).add(i);\\n        }\\n\\t\\t\\n        UF uf = new UF(n);\\n\\t\\t// base\\n        uf.union(0, firstPerson);\\n\\t\\t\\n\\t\\t// for every time we have a pool of people that talk to each other\\n\\t\\t// if someone knows a secret proir to this meeting - all pool will too\\n\\t\\t// if not - reset unions from this pool\\n        for (int time : timeToIndexes.keySet()) {\\n            Set<Integer> pool = new HashSet<>();\\n\\t\\t\\t\\n            for (int ind : timeToIndexes.get(time)) {\\n                int[] currentMeeting = meetings[ind];\\n                uf.union(currentMeeting[0], currentMeeting[1]);\\n                pool.add(currentMeeting[0]);\\n                pool.add(currentMeeting[1]);\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// meeting that took place now should\\'t affect future\\n\\t\\t\\t// meetings if people don\\'t know the secret\\n            for (int i : pool) if (!uf.connected(0, i)) uf.reset(i);\\n        }\\n\\t\\t\\n\\t\\t// if the person is conneted to 0 - they know a secret\\n        List<Integer> ans = new ArrayList<>();\\n        for (int i = 0; i < n; i++) if (uf.connected(i,0)) ans.add(i);\\n        return ans;\\n    }\\n    \\n\\t// regular union find\\n    private static class UF {\\n        int[] parent, rank;\\n\\t\\t\\n        public UF(int n) {\\n            parent = new int[n];\\n            rank = new int[n];\\n            for (int i = 0; i < n; i++) parent[i] = i;\\n        }\\n        \\n        public void union(int p, int q) {\\n            int rootP = find(p);\\n            int rootQ = find(q);\\n\\n            if (rootP == rootQ)\\n                return;\\n\\n            if (rank[rootP] < rank[rootQ]) {\\n                parent[rootP] = rootQ;\\n            } else {\\n                parent[rootQ] = rootP;\\n                rank[rootP]++;\\n            }\\n        }\\n        \\n        public int find(int p) {\\n            while (parent[p] != p) {\\n                p = parent[parent[p]];\\n            }\\n            return p;\\n        }\\n        \\n        public boolean connected(int p, int q) {\\n            return find(p) == find(q);\\n        }\\n        \\n        public void reset(int p) {\\n            parent[p] = p;\\n            rank[p] = 0;\\n        }\\n    }\\n}\\n```\\n\\n**\\u25CB Solution 2**\\n\\nSort array by time instead of using treemap. Then process iteratively.\\n\\n```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n\\t\\n        Arrays.sort(meetings, ((a,b)->a[2]-b[2]));\\n        \\n        UF uf = new UF(n);\\n        uf.union(0, firstPerson); // base\\n\\t\\t\\n\\t\\t// for every time we have a pool of people that talk to each other\\n\\t\\t// if someone knows a secret proir to this meeting - all pool will too\\n\\t\\t// if not - reset unions from this pool\\n        int i = 0;\\n        while (i < meetings.length) {\\n            int curTime = meetings[i][2];\\n            Set<Integer> pool = new HashSet<>();\\n            \\n            while (i < meetings.length && curTime == meetings[i][2]) {\\n                int[] currentMeeting = meetings[i];\\n                uf.union(currentMeeting[0], currentMeeting[1]);\\n                pool.add(currentMeeting[0]);\\n                pool.add(currentMeeting[1]);\\n                i++;\\n            }\\n            \\t\\t\\t\\n\\t\\t\\t// meeting that took place now should\\'t affect future\\n\\t\\t\\t// meetings if people don\\'t know the secret\\n            for (int j : pool) if (!uf.connected(0, j)) uf.reset(j);\\n        }\\n\\t\\t\\n\\t\\t// if the person is conneted to 0 - they know a secret\\n        List<Integer> ans = new ArrayList<>();\\n        for (int j = 0; j < n; j++) if (uf.connected(j,0)) ans.add(j);\\n        return ans;\\n    }\\n    \\n\\t// regular union find\\n    private static class UF {\\n        int[] parent, rank;\\n\\t\\t\\n        public UF(int n) {\\n            parent = new int[n];\\n            rank = new int[n];\\n            for (int i = 0; i < n; i++) parent[i] = i;\\n        }\\n        \\n        public void union(int p, int q) {\\n            int rootP = find(p);\\n            int rootQ = find(q);\\n\\n            if (rootP == rootQ)\\n                return;\\n\\n            if (rank[rootP] < rank[rootQ]) {\\n                parent[rootP] = rootQ;\\n            } else {\\n                parent[rootQ] = rootP;\\n                rank[rootP]++;\\n            }\\n        }\\n        \\n        public int find(int p) {\\n            while (parent[p] != p) {\\n                p = parent[parent[p]];\\n            }\\n            return p;\\n        }\\n        \\n        public boolean connected(int p, int q) {\\n            return find(p) == find(q);\\n        }\\n        \\n        public void reset(int p) {\\n            parent[p] = p;\\n            rank[p] = 0;\\n        }\\n    }\\n}\\n```\\n\\n**\\u25CF Stats**\\n\\nTime complexity `O(m*log(m))`, where m is number of meetings\\nSpace - `O(m)`\\n\\n",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n\\t\\n\\t\\t// create <time, index> map\\n        Map<Integer, List<Integer>> timeToIndexes = new TreeMap<>();\\n        int m = meetings.length;\\n        for (int i = 0; i < m; i++) {\\n            timeToIndexes.putIfAbsent(meetings[i][2], new ArrayList<>());\\n            timeToIndexes.get(meetings[i][2]).add(i);\\n        }\\n\\t\\t\\n        UF uf = new UF(n);\\n\\t\\t// base\\n        uf.union(0, firstPerson);\\n\\t\\t\\n\\t\\t// for every time we have a pool of people that talk to each other\\n\\t\\t// if someone knows a secret proir to this meeting - all pool will too\\n\\t\\t// if not - reset unions from this pool\\n        for (int time : timeToIndexes.keySet()) {\\n            Set<Integer> pool = new HashSet<>();\\n\\t\\t\\t\\n            for (int ind : timeToIndexes.get(time)) {\\n                int[] currentMeeting = meetings[ind];\\n                uf.union(currentMeeting[0], currentMeeting[1]);\\n                pool.add(currentMeeting[0]);\\n                pool.add(currentMeeting[1]);\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// meeting that took place now should\\'t affect future\\n\\t\\t\\t// meetings if people don\\'t know the secret\\n            for (int i : pool) if (!uf.connected(0, i)) uf.reset(i);\\n        }\\n\\t\\t\\n\\t\\t// if the person is conneted to 0 - they know a secret\\n        List<Integer> ans = new ArrayList<>();\\n        for (int i = 0; i < n; i++) if (uf.connected(i,0)) ans.add(i);\\n        return ans;\\n    }\\n    \\n\\t// regular union find\\n    private static class UF {\\n        int[] parent, rank;\\n\\t\\t\\n        public UF(int n) {\\n            parent = new int[n];\\n            rank = new int[n];\\n            for (int i = 0; i < n; i++) parent[i] = i;\\n        }\\n        \\n        public void union(int p, int q) {\\n            int rootP = find(p);\\n            int rootQ = find(q);\\n\\n            if (rootP == rootQ)\\n                return;\\n\\n            if (rank[rootP] < rank[rootQ]) {\\n                parent[rootP] = rootQ;\\n            } else {\\n                parent[rootQ] = rootP;\\n                rank[rootP]++;\\n            }\\n        }\\n        \\n        public int find(int p) {\\n            while (parent[p] != p) {\\n                p = parent[parent[p]];\\n            }\\n            return p;\\n        }\\n        \\n        public boolean connected(int p, int q) {\\n            return find(p) == find(q);\\n        }\\n        \\n        public void reset(int p) {\\n            parent[p] = p;\\n            rank[p] = 0;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n\\t\\n        Arrays.sort(meetings, ((a,b)->a[2]-b[2]));\\n        \\n        UF uf = new UF(n);\\n        uf.union(0, firstPerson); // base\\n\\t\\t\\n\\t\\t// for every time we have a pool of people that talk to each other\\n\\t\\t// if someone knows a secret proir to this meeting - all pool will too\\n\\t\\t// if not - reset unions from this pool\\n        int i = 0;\\n        while (i < meetings.length) {\\n            int curTime = meetings[i][2];\\n            Set<Integer> pool = new HashSet<>();\\n            \\n            while (i < meetings.length && curTime == meetings[i][2]) {\\n                int[] currentMeeting = meetings[i];\\n                uf.union(currentMeeting[0], currentMeeting[1]);\\n                pool.add(currentMeeting[0]);\\n                pool.add(currentMeeting[1]);\\n                i++;\\n            }\\n            \\t\\t\\t\\n\\t\\t\\t// meeting that took place now should\\'t affect future\\n\\t\\t\\t// meetings if people don\\'t know the secret\\n            for (int j : pool) if (!uf.connected(0, j)) uf.reset(j);\\n        }\\n\\t\\t\\n\\t\\t// if the person is conneted to 0 - they know a secret\\n        List<Integer> ans = new ArrayList<>();\\n        for (int j = 0; j < n; j++) if (uf.connected(j,0)) ans.add(j);\\n        return ans;\\n    }\\n    \\n\\t// regular union find\\n    private static class UF {\\n        int[] parent, rank;\\n\\t\\t\\n        public UF(int n) {\\n            parent = new int[n];\\n            rank = new int[n];\\n            for (int i = 0; i < n; i++) parent[i] = i;\\n        }\\n        \\n        public void union(int p, int q) {\\n            int rootP = find(p);\\n            int rootQ = find(q);\\n\\n            if (rootP == rootQ)\\n                return;\\n\\n            if (rank[rootP] < rank[rootQ]) {\\n                parent[rootP] = rootQ;\\n            } else {\\n                parent[rootQ] = rootP;\\n                rank[rootP]++;\\n            }\\n        }\\n        \\n        public int find(int p) {\\n            while (parent[p] != p) {\\n                p = parent[parent[p]];\\n            }\\n            return p;\\n        }\\n        \\n        public boolean connected(int p, int q) {\\n            return find(p) == find(q);\\n        }\\n        \\n        public void reset(int p) {\\n            parent[p] = p;\\n            rank[p] = 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599870,
                "title": "python3-bfs-or-dfs-by-group",
                "content": "Pleaes check out this [commit](https://github.com/gaosanyong/leetcode/commit/b3dd8d234940d5e4afc6a22cc8fc1f4a2e69dd3d) for solutions of weekly 269.\\n\\n```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        can = {0, firstPerson}\\n        for _, grp in groupby(sorted(meetings, key=lambda x: x[2]), key=lambda x: x[2]): \\n            queue = set()\\n            graph = defaultdict(list)\\n            for x, y, _ in grp: \\n                graph[x].append(y)\\n                graph[y].append(x)\\n                if x in can: queue.add(x)\\n                if y in can: queue.add(y)\\n                    \\n            queue = deque(queue)\\n            while queue: \\n                x = queue.popleft()\\n                for y in graph[x]: \\n                    if y not in can: \\n                        can.add(y)\\n                        queue.append(y)\\n        return can\\n```\\n\\nor \\n```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        can = {0, firstPerson}\\n        for _, grp in groupby(sorted(meetings, key=lambda x: x[2]), key=lambda x: x[2]): \\n            stack = set()\\n            graph = defaultdict(list)\\n            for x, y, _ in grp: \\n                graph[x].append(y)\\n                graph[y].append(x)\\n                if x in can: stack.add(x)\\n                if y in can: stack.add(y)\\n                    \\n            stack = list(stack)\\n            while stack: \\n                x = stack.pop()\\n                for y in graph[x]: \\n                    if y not in can: \\n                        can.add(y)\\n                        stack.append(y)\\n        return can\\n```\\n\\nAdding union-find implementation inspired by @lzl124631x\\'s post.\\n```\\nclass UnionFind:\\n\\n\\tdef __init__(self, n: int):\\n\\t\\tself.parent = list(range(n))\\n\\t\\tself.rank = [1] * n\\n\\n\\tdef find(self, p: int) -> int:\\n\\t\\t\"\"\"Find with path compression\"\"\"\\n\\t\\tif p != self.parent[p]:\\n\\t\\t\\tself.parent[p] = self.find(self.parent[p])\\n\\t\\treturn self.parent[p]\\n\\n\\tdef union(self, p: int, q: int) -> bool:\\n\\t\\t\"\"\"Union with rank\"\"\"\\n\\t\\tprt, qrt = self.find(p), self.find(q)\\n\\t\\tif prt == qrt: return False\\n\\t\\tif self.rank[prt] > self.rank[qrt]: prt, qrt = qrt, prt \\n\\t\\tself.parent[prt] = qrt\\n\\t\\tself.rank[qrt] += self.rank[prt]\\n\\t\\treturn True\\n\\n\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        uf = UnionFind(n)\\n        uf.union(0, firstPerson)\\n        for _, grp in groupby(sorted(meetings, key=lambda x: x[2]), key=lambda x: x[2]): \\n            seen = set()\\n            for x, y, _ in grp: \\n                seen.add(x)\\n                seen.add(y)\\n                uf.union(x, y)\\n            for x in seen: \\n                if uf.find(x) != uf.find(0): uf.parent[x] = x # reset \\n        return [x for x in range(n) if uf.find(x) == uf.find(0)]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        can = {0, firstPerson}\\n        for _, grp in groupby(sorted(meetings, key=lambda x: x[2]), key=lambda x: x[2]): \\n            queue = set()\\n            graph = defaultdict(list)\\n            for x, y, _ in grp: \\n                graph[x].append(y)\\n                graph[y].append(x)\\n                if x in can: queue.add(x)\\n                if y in can: queue.add(y)\\n                    \\n            queue = deque(queue)\\n            while queue: \\n                x = queue.popleft()\\n                for y in graph[x]: \\n                    if y not in can: \\n                        can.add(y)\\n                        queue.append(y)\\n        return can\\n```\n```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        can = {0, firstPerson}\\n        for _, grp in groupby(sorted(meetings, key=lambda x: x[2]), key=lambda x: x[2]): \\n            stack = set()\\n            graph = defaultdict(list)\\n            for x, y, _ in grp: \\n                graph[x].append(y)\\n                graph[y].append(x)\\n                if x in can: stack.add(x)\\n                if y in can: stack.add(y)\\n                    \\n            stack = list(stack)\\n            while stack: \\n                x = stack.pop()\\n                for y in graph[x]: \\n                    if y not in can: \\n                        can.add(y)\\n                        stack.append(y)\\n        return can\\n```\n```\\nclass UnionFind:\\n\\n\\tdef __init__(self, n: int):\\n\\t\\tself.parent = list(range(n))\\n\\t\\tself.rank = [1] * n\\n\\n\\tdef find(self, p: int) -> int:\\n\\t\\t\"\"\"Find with path compression\"\"\"\\n\\t\\tif p != self.parent[p]:\\n\\t\\t\\tself.parent[p] = self.find(self.parent[p])\\n\\t\\treturn self.parent[p]\\n\\n\\tdef union(self, p: int, q: int) -> bool:\\n\\t\\t\"\"\"Union with rank\"\"\"\\n\\t\\tprt, qrt = self.find(p), self.find(q)\\n\\t\\tif prt == qrt: return False\\n\\t\\tif self.rank[prt] > self.rank[qrt]: prt, qrt = qrt, prt \\n\\t\\tself.parent[prt] = qrt\\n\\t\\tself.rank[qrt] += self.rank[prt]\\n\\t\\treturn True\\n\\n\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        uf = UnionFind(n)\\n        uf.union(0, firstPerson)\\n        for _, grp in groupby(sorted(meetings, key=lambda x: x[2]), key=lambda x: x[2]): \\n            seen = set()\\n            for x, y, _ in grp: \\n                seen.add(x)\\n                seen.add(y)\\n                uf.union(x, y)\\n            for x in seen: \\n                if uf.find(x) != uf.find(0): uf.parent[x] = x # reset \\n        return [x for x in range(n) if uf.find(x) == uf.find(0)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599808,
                "title": "python-sort-dsu-detailed-explanation",
                "content": "**Key Observation:**\\nAt every timestamp, the connections between people will form several disjoint sets.\\n\\nFor example,\\n```\\nmeetings = [[0, 1, 1], [1, 2, 1], [3, 4, 1], [1, 5, 1],\\n            [1, 5, 2], [2, 6, 2]]\\n```\\nwill form the groups like below:\\n```\\ntime = 1, groups = [{0, 1, 2, 5}, {3, 4}]\\ntime = 2, groups = [{1, 5}, {2, 6}]\\n```\\n\\nSo we collect the connections and sorted them with its timestamp as key.\\n```python\\ntime2meets = defaultdict(list)\\nfor x, y, t in meetings:\\n    time2meets[t].append((x, y))\\ntime2meets = sorted(time2meets.items())\\n```\\n\\n---\\n**Update as time goes on:**\\n\\nLet ```curr_know``` represents the set of people who have known the secret now.\\nThen at every timestamp, all of the members of a certain group may know the secret if there exists a member who is already in ```curr_know```.\\n\\n```python\\ncurr_know = set([0, firstPerson])\\n\\nfor time, meets in time2meets:\\n    # construct groups at this timestamp\\n    uf = UnionFind()\\n    for x, y in meets:\\n        uf.union(x, y)\\n\\n    # finding the group members\\n    groups = defaultdict(set)\\n    for idx in uf.parents:\\n        groups[uf.find_parent(idx)].add(idx)\\n        \\n    # if a member of group is in curr_know, \\n    # update curr_know with all the members of this group \\n    for group in groups.values():\\n        if group & curr_know:\\n            curr_know.update(group)\\n```\\n---\\n**Complexity Analysis:**\\n\\nLet `N` be the number of peoples, `M` be the number of meetings.\\n\\n* **Time Complexity:**\\n    * Sorting the timestamp of meetings takes at most `O(M log M)` time (or if you use bucket sort it will take `O(T)` where `T = 10 ** 5`  ).\\n    * Merging all meetings takes `O(M)` times:\\n        * Suppose there are `K` people attending a meeting at a certain timestamp:\\n            * The union part takes `O(K)` times if we implement DSU with path compression and union by rank.\\n            * Finding the group members takes `O(K)` times.\\n            * Updating the group members takes `O(K)` times.\\n        * Since `sum(K) = M * 2`, this part takes `O(M)` times.\\n    * Total time complexity is `O(M log M)`, irrelevant to `N` if we use hash table to maintain `parents` and `ranks` in DSU.\\n\\n* **Space Complexity: `O(M + N)`**\\n\\n---\\n\\n**Complete code:**\\n```python\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        \\n        class UnionFind:\\n            def __init__(self):\\n                self.parents = {}\\n                self.ranks = {}\\n                \\n            def insert(self, x):\\n                if x not in self.parents:\\n                    self.parents[x] = x\\n                    self.ranks[x] = 0\\n                \\n            def find_parent(self, x):\\n                if self.parents[x] != x:\\n                    self.parents[x] = self.find_parent(self.parents[x])\\n                return self.parents[x]\\n            \\n            def union(self, x, y):\\n                self.insert(x)\\n                self.insert(y)\\n                x, y = self.find_parent(x), self.find_parent(y)\\n                if x == y:\\n                    return \\n                if self.ranks[x] > self.ranks[y]:\\n                    self.parents[y] = x\\n                else:\\n                    self.parents[x] = y\\n                    if self.ranks[x] == self.ranks[y]:\\n                        self.ranks[y] += 1\\n            \\n        time2meets = defaultdict(list)\\n        for x, y, t in meetings:\\n            time2meets[t].append((x, y))\\n        time2meets = sorted(time2meets.items())\\n \\n        curr_know = set([0, firstPerson])\\n\\n        for time, meets in time2meets:\\n            uf = UnionFind()\\n            for x, y in meets:\\n                uf.union(x, y)\\n            \\n            groups = defaultdict(set)\\n            for idx in uf.parents:\\n                groups[uf.find_parent(idx)].add(idx)\\n            \\n            for group in groups.values():\\n                if group & curr_know:\\n                    curr_know.update(group)\\n\\n        return list(curr_know)\\n```\\n        \\n",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nmeetings = [[0, 1, 1], [1, 2, 1], [3, 4, 1], [1, 5, 1],\\n            [1, 5, 2], [2, 6, 2]]\\n```\n```\\ntime = 1, groups = [{0, 1, 2, 5}, {3, 4}]\\ntime = 2, groups = [{1, 5}, {2, 6}]\\n```\n```python\\ntime2meets = defaultdict(list)\\nfor x, y, t in meetings:\\n    time2meets[t].append((x, y))\\ntime2meets = sorted(time2meets.items())\\n```\n```curr_know```\n```curr_know```\n```python\\ncurr_know = set([0, firstPerson])\\n\\nfor time, meets in time2meets:\\n    # construct groups at this timestamp\\n    uf = UnionFind()\\n    for x, y in meets:\\n        uf.union(x, y)\\n\\n    # finding the group members\\n    groups = defaultdict(set)\\n    for idx in uf.parents:\\n        groups[uf.find_parent(idx)].add(idx)\\n        \\n    # if a member of group is in curr_know, \\n    # update curr_know with all the members of this group \\n    for group in groups.values():\\n        if group & curr_know:\\n            curr_know.update(group)\\n```\n```python\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        \\n        class UnionFind:\\n            def __init__(self):\\n                self.parents = {}\\n                self.ranks = {}\\n                \\n            def insert(self, x):\\n                if x not in self.parents:\\n                    self.parents[x] = x\\n                    self.ranks[x] = 0\\n                \\n            def find_parent(self, x):\\n                if self.parents[x] != x:\\n                    self.parents[x] = self.find_parent(self.parents[x])\\n                return self.parents[x]\\n            \\n            def union(self, x, y):\\n                self.insert(x)\\n                self.insert(y)\\n                x, y = self.find_parent(x), self.find_parent(y)\\n                if x == y:\\n                    return \\n                if self.ranks[x] > self.ranks[y]:\\n                    self.parents[y] = x\\n                else:\\n                    self.parents[x] = y\\n                    if self.ranks[x] == self.ranks[y]:\\n                        self.ranks[y] += 1\\n            \\n        time2meets = defaultdict(list)\\n        for x, y, t in meetings:\\n            time2meets[t].append((x, y))\\n        time2meets = sorted(time2meets.items())\\n \\n        curr_know = set([0, firstPerson])\\n\\n        for time, meets in time2meets:\\n            uf = UnionFind()\\n            for x, y in meets:\\n                uf.union(x, y)\\n            \\n            groups = defaultdict(set)\\n            for idx in uf.parents:\\n                groups[uf.find_parent(idx)].add(idx)\\n            \\n            for group in groups.values():\\n                if group & curr_know:\\n                    curr_know.update(group)\\n\\n        return list(curr_know)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601135,
                "title": "python-union-find-with-explain",
                "content": "We use Union-Find to group people. For people who know the secret, we group them with the number 0 people. (roots[n] == 0 or find(n) == 0 means the person n knows the secrete)\\n\\nFlow:\\n1. Sort the meetings by time\\n\\n2.  Aggregate the meetings with the same time, union the attending people into groups. If any person in a group knows the secrete, other people will know the secrete too. After union, we need to reset the group that people do not get the secrete.\\n\\n3.  Return the result\\n\\nTricks:\\n1.  roots[n] == 0 or find(n) == 0, means person n knows the secrete\\n2.  When doing union, the first piority is to set the root as 0 (mark as known secrete).\\n\\n```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        roots = [i for i in range(n)]\\n        \\n        # if roots[n] == 0 or find(n) == 0, means person n knows the secrete\\n        roots[firstPerson] = 0\\n        \\n        def find(x):\\n            if roots[x] == x:\\n                return x\\n            roots[x] = find(roots[x])\\n            return roots[x]\\n        \\n        def union(x, y):\\n            rootX = find(x)\\n            rootY = find(y)\\n            if rootX != rootY:\\n                # x or y knows the secrete, make both as known secrete\\n                if rootX == 0 or rootY == 0:\\n                    roots[rootY] = roots[rootX] = 0\\n                # Neither x nor y  knows the secrete, just union them into the same group\\n                else:\\n                    roots[rootY] = rootX\\n        \\n        meetings.sort(key=lambda m:m[2])\\n        N = len(meetings)\\n        i = 0\\n        while i < N:\\n            # aggregate meetings at the same time\\n            sameTimeMeetings = [meetings[i]]\\n            while i < N-1 and meetings[i+1][2] == meetings[i][2]:\\n                i = i+1\\n                sameTimeMeetings.append(meetings[i])\\n                continue\\n            \\n            # union people in the same time meetings into groups\\n            for x,y,time in sameTimeMeetings:\\n                union(x, y)\\n                \\n            # reset the union groups that people do not know the secrete from meetings\\n            for x,y,time in sameTimeMeetings:\\n                rootX = find(x)\\n                # Since x and y are unioned into same group, if x does not know the secret, y does not know either\\n                if rootX != 0:\\n                    roots[x] = x\\n                    roots[y] = y\\n                            \\n            i+=1\\n\\n        return [i for i in range(n) if find(i) == 0]\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        roots = [i for i in range(n)]\\n        \\n        # if roots[n] == 0 or find(n) == 0, means person n knows the secrete\\n        roots[firstPerson] = 0\\n        \\n        def find(x):\\n            if roots[x] == x:\\n                return x\\n            roots[x] = find(roots[x])\\n            return roots[x]\\n        \\n        def union(x, y):\\n            rootX = find(x)\\n            rootY = find(y)\\n            if rootX != rootY:\\n                # x or y knows the secrete, make both as known secrete\\n                if rootX == 0 or rootY == 0:\\n                    roots[rootY] = roots[rootX] = 0\\n                # Neither x nor y  knows the secrete, just union them into the same group\\n                else:\\n                    roots[rootY] = rootX\\n        \\n        meetings.sort(key=lambda m:m[2])\\n        N = len(meetings)\\n        i = 0\\n        while i < N:\\n            # aggregate meetings at the same time\\n            sameTimeMeetings = [meetings[i]]\\n            while i < N-1 and meetings[i+1][2] == meetings[i][2]:\\n                i = i+1\\n                sameTimeMeetings.append(meetings[i])\\n                continue\\n            \\n            # union people in the same time meetings into groups\\n            for x,y,time in sameTimeMeetings:\\n                union(x, y)\\n                \\n            # reset the union groups that people do not know the secrete from meetings\\n            for x,y,time in sameTimeMeetings:\\n                rootX = find(x)\\n                # Since x and y are unioned into same group, if x does not know the secret, y does not know either\\n                if rootX != 0:\\n                    roots[x] = x\\n                    roots[y] = y\\n                            \\n            i+=1\\n\\n        return [i for i in range(n) if find(i) == 0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1741105,
                "title": "python-visual-explanation-bfs-commented-complexity-analysis",
                "content": "![image](https://assets.leetcode.com/users/images/c3b7b814-ed3c-4db3-8bf3-99b421d8a993_1643868909.3015747.png)\\n\\n**Time Complexity Analysis** - I am scared to talk about time complexity for this problem..\\nLet **M** - number of total meetings, **T** - number of distinct time of meetings, **n** - number of people\\nFirst of all, the sort of the meeting is O(M * log(M))\\nThen iteration over the sorted meetings to build an array is O(M)\\nThen iteration over the sorted array is O(T) where T can be M at worst\\n\\t    - inside the iteration, building the graph is about ~O(M / T) assuming total number of meetings divide by number of distinct time is the number of iteration we need to\\n  \\t    - then pre-enqueing the people knows secret can be O(n) at worst\\n\\t    - BFS iteration is visiting every edges which is number of meetings for the time which I assume to be ~O(M/T)\\nOverall, I would say O(M  log(M)) + O(M) + O(T * 2M/T * n) => **O(M * (log(M) + n))** for the time complexity. Please correct me if I am wrong. \\n\\n**Space complexity** will be O(M + n) overall. M for sorted array, and n for the queue\\n\\n```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        # person 0, and firstPerson already knows the secret\\n        knowsSecret = set([0, firstPerson])\\n        \\n        # after sort the meeting by time, the same time meeting will be grouped together\\n        # so we can relie on people that knows secret before that time from \"knowsSecret\"\\n        sortedMeetings = []\\n        meetings.sort(key=lambda x:x[2]) # O(M*log(M))\\n        \\n        # tracking every meeting times to decide if current meeting has same time as previous meeting\\n        seenTime = set()\\n        \\n        # building the sortedMeetings as explained above\\n        for meeting in meetings: # O(M)\\n            if meeting[2] not in seenTime:\\n                seenTime.add(meeting[2])\\n                sortedMeetings.append([])\\n            sortedMeetings[-1].append((meeting[0], meeting[1]))\\n\\n        # we then now will build graph for each meeting time, and traverse(BFS) the graph from\\n        # people that already knows the secret to find more people who knows secret\\n        for meetingGroup in sortedMeetings: #O(T)\\n            # q needs to be set then push to queue, because of duplicate values we find from meetings\\n            # otherwise it will reach the TLE\\n            pplKnowSecret = set()\\n            graph = defaultdict(list)\\n            \\n            # building bidirectional graph, and make sure to build our queue as well if we find\\n            # a person who knows secret\\n            for p1, p2 in meetingGroup: # ~O(M/T)\\n                graph[p1].append(p2)\\n                graph[p2].append(p1)\\n                if p1 in knowsSecret:\\n                    pplKnowSecret.add(p1)\\n                if p2 in knowsSecret:\\n                    pplKnowSecret.add(p2)\\n                    \\n            # adding people that already knows the secret to start off our graph traversal \\n            queue = deque((pplKnowSecret)) # O(n)\\n        \\n            while queue: # ~O(M/T)\\n                curr = queue.popleft()\\n                #any1 we find from our queue knows secret, so record it\\n                knowsSecret.add(curr)\\n                for neigh in graph[curr]:\\n                    if neigh not in knowsSecret:\\n                        knowsSecret.add(neigh)\\n                        queue.append(neigh)\\n\\n        return list(knowsSecret)\\n```\\n**Please correct me if I am wrong !\\nPlease UPVOTE if you find this solution helpful !\\nHappy algo!**",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        # person 0, and firstPerson already knows the secret\\n        knowsSecret = set([0, firstPerson])\\n        \\n        # after sort the meeting by time, the same time meeting will be grouped together\\n        # so we can relie on people that knows secret before that time from \"knowsSecret\"\\n        sortedMeetings = []\\n        meetings.sort(key=lambda x:x[2]) # O(M*log(M))\\n        \\n        # tracking every meeting times to decide if current meeting has same time as previous meeting\\n        seenTime = set()\\n        \\n        # building the sortedMeetings as explained above\\n        for meeting in meetings: # O(M)\\n            if meeting[2] not in seenTime:\\n                seenTime.add(meeting[2])\\n                sortedMeetings.append([])\\n            sortedMeetings[-1].append((meeting[0], meeting[1]))\\n\\n        # we then now will build graph for each meeting time, and traverse(BFS) the graph from\\n        # people that already knows the secret to find more people who knows secret\\n        for meetingGroup in sortedMeetings: #O(T)\\n            # q needs to be set then push to queue, because of duplicate values we find from meetings\\n            # otherwise it will reach the TLE\\n            pplKnowSecret = set()\\n            graph = defaultdict(list)\\n            \\n            # building bidirectional graph, and make sure to build our queue as well if we find\\n            # a person who knows secret\\n            for p1, p2 in meetingGroup: # ~O(M/T)\\n                graph[p1].append(p2)\\n                graph[p2].append(p1)\\n                if p1 in knowsSecret:\\n                    pplKnowSecret.add(p1)\\n                if p2 in knowsSecret:\\n                    pplKnowSecret.add(p2)\\n                    \\n            # adding people that already knows the secret to start off our graph traversal \\n            queue = deque((pplKnowSecret)) # O(n)\\n        \\n            while queue: # ~O(M/T)\\n                curr = queue.popleft()\\n                #any1 we find from our queue knows secret, so record it\\n                knowsSecret.add(curr)\\n                for neigh in graph[curr]:\\n                    if neigh not in knowsSecret:\\n                        knowsSecret.add(neigh)\\n                        queue.append(neigh)\\n\\n        return list(knowsSecret)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599828,
                "title": "java-intuitive-solution",
                "content": "```java\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        List<Integer> ans = new ArrayList<>();\\n        Set<Integer> added = new HashSet<>();\\n        \\n        PriorityQueue<int[]> known = new PriorityQueue<>((p0, p1) -> p0[1] - p1[1]);\\n        known.offer(new int[]{0, 0});\\n        known.offer(new int[]{firstPerson, 0});\\n        \\n        Map<Integer, List<int[]>> map = new HashMap<>();\\n        for (int[] meeting : meetings) {\\n            map.putIfAbsent(meeting[0], new ArrayList<>());\\n            map.putIfAbsent(meeting[1], new ArrayList<>());\\n            \\n            map.get(meeting[0]).add(new int[]{meeting[1], meeting[2]});\\n            map.get(meeting[1]).add(new int[]{meeting[0], meeting[2]});\\n        }\\n        \\n        while (!known.isEmpty()) {\\n            int[] p = known.poll();\\n            \\n            if (!added.contains(p[0])) {\\n                added.add(p[0]);\\n                ans.add(p[0]);\\n            }\\n            \\n            if (!map.containsKey(p[0])) continue;\\n            \\n            List<int[]> meetAndTime = map.get(p[0]);\\n            for (int[] m : meetAndTime) {\\n                if (m[1] < p[1]) continue;\\n                \\n                known.offer(new int[]{m[0], m[1]});\\n            }\\n            \\n            map.remove(p[0]);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        List<Integer> ans = new ArrayList<>();\\n        Set<Integer> added = new HashSet<>();\\n        \\n        PriorityQueue<int[]> known = new PriorityQueue<>((p0, p1) -> p0[1] - p1[1]);\\n        known.offer(new int[]{0, 0});\\n        known.offer(new int[]{firstPerson, 0});\\n        \\n        Map<Integer, List<int[]>> map = new HashMap<>();\\n        for (int[] meeting : meetings) {\\n            map.putIfAbsent(meeting[0], new ArrayList<>());\\n            map.putIfAbsent(meeting[1], new ArrayList<>());\\n            \\n            map.get(meeting[0]).add(new int[]{meeting[1], meeting[2]});\\n            map.get(meeting[1]).add(new int[]{meeting[0], meeting[2]});\\n        }\\n        \\n        while (!known.isEmpty()) {\\n            int[] p = known.poll();\\n            \\n            if (!added.contains(p[0])) {\\n                added.add(p[0]);\\n                ans.add(p[0]);\\n            }\\n            \\n            if (!map.containsKey(p[0])) continue;\\n            \\n            List<int[]> meetAndTime = map.get(p[0]);\\n            for (int[] m : meetAndTime) {\\n                if (m[1] < p[1]) continue;\\n                \\n                known.offer(new int[]{m[0], m[1]});\\n            }\\n            \\n            map.remove(p[0]);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600119,
                "title": "java-clean-2-solutions-bfs-and-unionfind",
                "content": "solution 1 union find, we need to reset the parent to itself if after the meeting both player can not have secrets\\nsolution 2 bfs we need to ignore the otherTime if nextMeeting has happened before the secret is here.\\n\\n```\\nclass Solution {\\n   // Union Find 144ms\\n   public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        DSU dsu = new DSU(n);\\n        dsu.union(0, firstPerson);\\n        TreeMap<Integer, List<Integer>> sameTimeMeeting = new TreeMap<>();\\n        int N = meetings.length;\\n        for (int i = 0; i < N; i++)\\n            sameTimeMeeting.computeIfAbsent(meetings[i][2], x -> new ArrayList<>()).add(i);\\n        for (int time : sameTimeMeeting.keySet()) {\\n            Set<Integer> pool = new HashSet<>();\\n            for (int id : sameTimeMeeting.get(time)) {\\n                int a = meetings[id][0];\\n                int b = meetings[id][1];\\n                dsu.union(a, b);\\n                pool.add(a);\\n                pool.add(b);\\n            }\\n            for (int i : pool) if (dsu.find(0) != dsu.find(i)) dsu.reset(i);\\n        }\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < n; i++)\\n            if (dsu.find(i) == dsu.find(0)) res.add(i);\\n        return res;\\n    }\\n    \\n   //BFS 164ms\\n   public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n       Map<Integer, Map<Integer, List<Integer>>> graph = new HashMap<>(); //<a, <time, <b,c,d>>>\\n       for (int[] meeting : meetings) {\\n           int a = meeting[0], b = meeting[1], time = meeting[2];\\n           graph.putIfAbsent(a, new HashMap());\\n           graph.putIfAbsent(b, new HashMap()); \\n           graph.get(a).computeIfAbsent(time, x -> new ArrayList<>()).add(b);\\n           graph.get(b).computeIfAbsent(time, x -> new ArrayList<>()).add(a);\\n       }\\n       Set<Integer> visited = new HashSet<>();\\n       List<Integer> res = new ArrayList<>();\\n       PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n       pq.offer(new int[]{0, 0});\\n       pq.offer(new int[]{firstPerson, 0});\\n       while (!pq.isEmpty()) {\\n           int[] cur = pq.poll();\\n           int curPerson = cur[0], curTime = cur[1];\\n           if (visited.add(curPerson)) res.add(curPerson);\\n           else continue;\\n           for (int otherTime : graph.getOrDefault(curPerson, new HashMap<>()).keySet()) {\\n               if (otherTime < curTime) continue;\\n               for (int nextPerson : graph.getOrDefault(curPerson, new HashMap<>()).get(otherTime))\\n                   pq.offer(new int[]{nextPerson, otherTime});\\n           }\\n       }\\n       return res;\\n   }\\n}\\nclass DSU {\\n    int[] parent;\\n    public DSU(int N) {\\n        parent = new int[N];\\n        for (int i = 0; i < N; i++) parent[i] = i;\\n    }\\n    public int find(int x) {\\n        if (parent[x] != x) parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n    public void union(int x, int y) {\\n        parent[find(x)] = find(y);  \\n    }\\n    public void reset(int x) {\\n        parent[x] = x;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n   // Union Find 144ms\\n   public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        DSU dsu = new DSU(n);\\n        dsu.union(0, firstPerson);\\n        TreeMap<Integer, List<Integer>> sameTimeMeeting = new TreeMap<>();\\n        int N = meetings.length;\\n        for (int i = 0; i < N; i++)\\n            sameTimeMeeting.computeIfAbsent(meetings[i][2], x -> new ArrayList<>()).add(i);\\n        for (int time : sameTimeMeeting.keySet()) {\\n            Set<Integer> pool = new HashSet<>();\\n            for (int id : sameTimeMeeting.get(time)) {\\n                int a = meetings[id][0];\\n                int b = meetings[id][1];\\n                dsu.union(a, b);\\n                pool.add(a);\\n                pool.add(b);\\n            }\\n            for (int i : pool) if (dsu.find(0) != dsu.find(i)) dsu.reset(i);\\n        }\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < n; i++)\\n            if (dsu.find(i) == dsu.find(0)) res.add(i);\\n        return res;\\n    }\\n    \\n   //BFS 164ms\\n   public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n       Map<Integer, Map<Integer, List<Integer>>> graph = new HashMap<>(); //<a, <time, <b,c,d>>>\\n       for (int[] meeting : meetings) {\\n           int a = meeting[0], b = meeting[1], time = meeting[2];\\n           graph.putIfAbsent(a, new HashMap());\\n           graph.putIfAbsent(b, new HashMap()); \\n           graph.get(a).computeIfAbsent(time, x -> new ArrayList<>()).add(b);\\n           graph.get(b).computeIfAbsent(time, x -> new ArrayList<>()).add(a);\\n       }\\n       Set<Integer> visited = new HashSet<>();\\n       List<Integer> res = new ArrayList<>();\\n       PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n       pq.offer(new int[]{0, 0});\\n       pq.offer(new int[]{firstPerson, 0});\\n       while (!pq.isEmpty()) {\\n           int[] cur = pq.poll();\\n           int curPerson = cur[0], curTime = cur[1];\\n           if (visited.add(curPerson)) res.add(curPerson);\\n           else continue;\\n           for (int otherTime : graph.getOrDefault(curPerson, new HashMap<>()).keySet()) {\\n               if (otherTime < curTime) continue;\\n               for (int nextPerson : graph.getOrDefault(curPerson, new HashMap<>()).get(otherTime))\\n                   pq.offer(new int[]{nextPerson, otherTime});\\n           }\\n       }\\n       return res;\\n   }\\n}\\nclass DSU {\\n    int[] parent;\\n    public DSU(int N) {\\n        parent = new int[N];\\n        for (int i = 0; i < N; i++) parent[i] = i;\\n    }\\n    public int find(int x) {\\n        if (parent[x] != x) parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n    public void union(int x, int y) {\\n        parent[find(x)] = find(y);  \\n    }\\n    public void reset(int x) {\\n        parent[x] = x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600419,
                "title": "really-the-simplest-answer-i-came-through-bfs-or-dfs",
                "content": "## IDEA :\\n* Firstly group all the meetings with the key as time on which meeting is happening.\\n\\n* So one by one go through all the groups (timing by increasing order) and add all the persons to whom secrets got get shared.\\n* Here `sh` denotes the persons having secret with them.\\n* Going through each group find the persons with whom secrets got shared and add them in `sh` .\\n* At last return the `sh` as a list.\\n\\n**Implementation :**\\n\\n## BFS :\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        \\n        meetings.sort(key=lambda x:x[2])\\n        groups = itertools.groupby(meetings,key = lambda x:x[2])\\n        \\n        sh = {0,firstPerson}\\n        for key,grp in groups:\\n            seen = set()\\n            graph = defaultdict(list)\\n            for a,b,t in grp:\\n                graph[a].append(b)\\n                graph[b].append(a)\\n                if a in sh:\\n                    seen.add(a)\\n                if b in sh:\\n                    seen.add(b)\\n            \\n            queue = deque(seen)\\n            while queue:\\n                node = queue.popleft()\\n                for neig in graph[node]:\\n                    if neig not in sh:\\n                        sh.add(neig)\\n                        queue.append(neig)\\n            \\n        return list(sh)\\n\\n## DFS :\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n\\n\\t\\t\\tmeetings.sort(key=lambda x:x[2])\\n\\t\\t\\tgroups = itertools.groupby(meetings,key = lambda x:x[2])\\n\\n\\t\\t\\tsh = {0,firstPerson}\\n\\t\\t\\tfor key,grp in groups:\\n\\t\\t\\t\\tseen = set()\\n\\t\\t\\t\\tgraph = defaultdict(list)\\n\\t\\t\\t\\tfor a,b,t in grp:\\n\\t\\t\\t\\t\\tgraph[a].append(b)\\n\\t\\t\\t\\t\\tgraph[b].append(a)\\n\\t\\t\\t\\t\\tif a in sh:\\n\\t\\t\\t\\t\\t\\tseen.add(a)\\n\\t\\t\\t\\t\\tif b in sh:\\n\\t\\t\\t\\t\\t\\tseen.add(b)\\n\\n\\t\\t\\t\\tst = list(seen)[::]\\n\\t\\t\\t\\twhile st:\\n\\t\\t\\t\\t\\tnode = st.pop()\\n\\t\\t\\t\\t\\tfor neig in graph[node]:\\n\\t\\t\\t\\t\\t\\tif neig not in sh:\\n\\t\\t\\t\\t\\t\\t\\tsh.add(neig)\\n\\t\\t\\t\\t\\t\\t\\tst.append(neig)\\n\\n\\t\\t\\treturn list(sh)\\n\\n**Thanks & Upvote if you got any help !!\\uD83E\\uDD1E**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "class Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        \\n        meetings.sort(key=lambda x:x[2])\\n        groups = itertools.groupby(meetings,key = lambda x:x[2])\\n        \\n        sh = {0,firstPerson}",
                "codeTag": "Java"
            },
            {
                "id": 1601768,
                "title": "union-find-with-disconnects",
                "content": "Our disjoint set `ds` tracks the group of people who know the secret.\\n\\nWe sort meetings by time. Then, going left-to-right, we join two people who meet at the time `t`. After all meetings at time `t` conclude, some people could be in the same group as person `0` (who started spreading the secret). Those folks learned the secret during meetings at time `t`.\\n\\nHowever, other people who met could be in a different group than person `0`. Those people did not learn the secret. We disconnect those individuals from a group, as if they have never met.\\n\\n**C++**\\n```cpp\\nint find(vector<int> &ds, int i) {\\n    return ds[i] < 0 ? i : ds[i] = find(ds, ds[i]);\\n}\\nvector<int> findAllPeople(int n, vector<vector<int>>& meets, int firstPerson) {\\n    vector<int> ds(n, -1), res;\\n    ds[firstPerson] = 0;\\n    sort(begin(meets), end(meets), [](const auto &m1, const auto &m2){ return m1[2] < m2[2]; });\\n    for (int i = 0, j =  0; i < meets.size(); ++i) {\\n        if (meets[i][2] != meets[j][2]) {\\n            for (int k = j; k < i; ++k) {\\n                if (find(ds, meets[k][0]) != 0)\\n                    ds[meets[k][0]] = -1;\\n                if (find(ds, meets[k][1]) != 0)\\n                    ds[meets[k][1]] = -1;\\n            }\\n            j = i;\\n        }\\n        int p1 = find(ds, meets[i][0]), p2 = find(ds, meets[i][1]);\\n        if (p1 != p2)\\n            ds[max(p1, p2)] = min(p1, p2);\\n    }\\n    for (int i = 0; i < n; ++i)\\n        if (find(ds, i) == 0)\\n            res.push_back(i);\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint find(vector<int> &ds, int i) {\\n    return ds[i] < 0 ? i : ds[i] = find(ds, ds[i]);\\n}\\nvector<int> findAllPeople(int n, vector<vector<int>>& meets, int firstPerson) {\\n    vector<int> ds(n, -1), res;\\n    ds[firstPerson] = 0;\\n    sort(begin(meets), end(meets), [](const auto &m1, const auto &m2){ return m1[2] < m2[2]; });\\n    for (int i = 0, j =  0; i < meets.size(); ++i) {\\n        if (meets[i][2] != meets[j][2]) {\\n            for (int k = j; k < i; ++k) {\\n                if (find(ds, meets[k][0]) != 0)\\n                    ds[meets[k][0]] = -1;\\n                if (find(ds, meets[k][1]) != 0)\\n                    ds[meets[k][1]] = -1;\\n            }\\n            j = i;\\n        }\\n        int p1 = find(ds, meets[i][0]), p2 = find(ds, meets[i][1]);\\n        if (p1 != p2)\\n            ds[max(p1, p2)] = min(p1, p2);\\n    }\\n    for (int i = 0; i < n; ++i)\\n        if (find(ds, i) == 0)\\n            res.push_back(i);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1599997,
                "title": "python-bfs",
                "content": "```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        g = defaultdict(dict)\\n        for p1, p2, t in meetings:\\n            g[t][p1] = g[t].get(p1, [])\\n            g[t][p1].append(p2)\\n            g[t][p2] = g[t].get(p2, [])\\n            g[t][p2].append(p1)\\n        known = {0, firstPerson}\\n        for t in sorted(g.keys()):\\n            seen = set()\\n            for p in g[t]:\\n                if p in known and p not in seen:\\n                    q = deque([p])\\n                    seen.add(p)\\n                    while q:\\n                        cur = q.popleft()\\n                        for nxt in g[t][cur]:\\n                            if nxt not in seen:\\n                                q.append(nxt)\\n                                seen.add(nxt)\\n                                known.add(nxt)\\n        return known\\n```\\nEdited to make it more concise. \\n__________________________\\nInterestingly, for this part\\n```\\n            g[t][p1] = g[t].get(p1, [])\\n            g[t][p1].append(p2)\\n            g[t][p2] = g[t].get(p2, [])\\n            g[t][p2].append(p1)\\n```\\nIf we write it as below, we would get TLE\\n```\\n            g[t][p1] = g[t].get(p1, [])+[p2]\\n            g[t][p2] = g[t].get(p2, [])+[p1]\\n```\\nThe main reason is that `g[t].get(p1, [])+[p2]` creates a new array whereas `g[t][p1].append(p2)` simply adds `p2` to the original array",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        g = defaultdict(dict)\\n        for p1, p2, t in meetings:\\n            g[t][p1] = g[t].get(p1, [])\\n            g[t][p1].append(p2)\\n            g[t][p2] = g[t].get(p2, [])\\n            g[t][p2].append(p1)\\n        known = {0, firstPerson}\\n        for t in sorted(g.keys()):\\n            seen = set()\\n            for p in g[t]:\\n                if p in known and p not in seen:\\n                    q = deque([p])\\n                    seen.add(p)\\n                    while q:\\n                        cur = q.popleft()\\n                        for nxt in g[t][cur]:\\n                            if nxt not in seen:\\n                                q.append(nxt)\\n                                seen.add(nxt)\\n                                known.add(nxt)\\n        return known\\n```\n```\\n            g[t][p1] = g[t].get(p1, [])\\n            g[t][p1].append(p2)\\n            g[t][p2] = g[t].get(p2, [])\\n            g[t][p2].append(p1)\\n```\n```\\n            g[t][p1] = g[t].get(p1, [])+[p2]\\n            g[t][p2] = g[t].get(p2, [])+[p1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599995,
                "title": "c-tle-with-bfs-dfs-ac-with-dsu",
                "content": "At first I tried this problem with bfs/dfs. But got TLE.\\nMy solution was:\\n```cpp\\nclass Solution {\\n    static const int mx = 1e5 + 2;\\n    vector<pair<int, int>> T[mx];\\n    vector<int> g[mx];\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        vector<int> mark(n, 0);\\n        for (int i = 0, sz = meetings.size(); i < sz; i++) {\\n            int tmm = meetings[i][2];\\n            int x = meetings[i][0];\\n            int y = meetings[i][1];\\n            T[tmm].push_back({x, y});\\n        }\\n        mark[0] = 1;\\n        mark[firstPerson] = 1;\\n        for (int i = 1; i < mx; i++) {\\n            stack<int> q;\\n            for (int j = 0, sz = T[i].size(); j < sz; j++) {\\n                int x = T[i][j].first;\\n                int y = T[i][j].second;\\n                g[x].push_back(y);\\n                g[y].push_back(x);\\n                if (mark[x] == 1) {\\n                    q.push(x);\\n                    mark[x] = 2;\\n                }\\n                if (mark[y] == 1) {\\n                    q.push(y);\\n                    mark[y] = 2;\\n                }\\n            }\\n            while (!q.empty()) {\\n                int u = q.top();\\n                mark[u] = 1;\\n                q.pop();\\n                for (auto v : g[u]) {\\n                    if (mark[v] == 0) {\\n                        q.push(v);\\n                        mark[v] = 1;\\n                    }\\n                }\\n            }\\n            for (int j = 0, sz = T[i].size(); j < sz; j++) {\\n                int x = T[i][j].first;\\n                int y = T[i][j].second;\\n                if (!g[x].empty())g[x].clear();\\n                if (!g[y].empty())g[y].clear();\\n            }\\n        }\\n        vector<int> ans;\\n        for (int i = 0; i < n; i++)if (mark[i])ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nThen I Got AC with DSU:\\n```cpp\\nclass Solution {\\n\\tstatic const int mx = 1e5 + 2;\\n\\tvector<pair<int, int>> T[mx];\\n\\tint p[mx];\\n\\tint find(int u) { return p[u] = u == p[u] ? u : find(p[u]); }\\n\\tvoid merge(int u, int v) { p[find(u)] = find(v); }\\npublic:\\n\\tvector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n\\t\\tfor (int i = 0; i < n; i++)p[i] = i;\\n\\t\\tfor (auto &x : meetings) T[x[2]].push_back({x[0], x[1]});\\n\\t\\tmerge(0, firstPerson);\\n\\t\\tfor (int i = 1; i < mx; i++) {\\n\\t\\t\\tfor (auto &[x, y] : T[i])merge(x, y);\\n\\t\\t\\tfor (auto &[x, y] : T[i]) {\\n\\t\\t\\t\\tif (find(x) != find(0)) {\\n\\t\\t\\t\\t\\tp[x] = x;\\n\\t\\t\\t\\t\\tp[y] = y;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvector<int> ans;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (find(i) == find(0)) {\\n\\t\\t\\t\\tans.push_back(i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\\n\\n\\nI wondered why I got TLE with the first one, is that only STL? Thanks in Advance.",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\n    static const int mx = 1e5 + 2;\\n    vector<pair<int, int>> T[mx];\\n    vector<int> g[mx];\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        vector<int> mark(n, 0);\\n        for (int i = 0, sz = meetings.size(); i < sz; i++) {\\n            int tmm = meetings[i][2];\\n            int x = meetings[i][0];\\n            int y = meetings[i][1];\\n            T[tmm].push_back({x, y});\\n        }\\n        mark[0] = 1;\\n        mark[firstPerson] = 1;\\n        for (int i = 1; i < mx; i++) {\\n            stack<int> q;\\n            for (int j = 0, sz = T[i].size(); j < sz; j++) {\\n                int x = T[i][j].first;\\n                int y = T[i][j].second;\\n                g[x].push_back(y);\\n                g[y].push_back(x);\\n                if (mark[x] == 1) {\\n                    q.push(x);\\n                    mark[x] = 2;\\n                }\\n                if (mark[y] == 1) {\\n                    q.push(y);\\n                    mark[y] = 2;\\n                }\\n            }\\n            while (!q.empty()) {\\n                int u = q.top();\\n                mark[u] = 1;\\n                q.pop();\\n                for (auto v : g[u]) {\\n                    if (mark[v] == 0) {\\n                        q.push(v);\\n                        mark[v] = 1;\\n                    }\\n                }\\n            }\\n            for (int j = 0, sz = T[i].size(); j < sz; j++) {\\n                int x = T[i][j].first;\\n                int y = T[i][j].second;\\n                if (!g[x].empty())g[x].clear();\\n                if (!g[y].empty())g[y].clear();\\n            }\\n        }\\n        vector<int> ans;\\n        for (int i = 0; i < n; i++)if (mark[i])ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\n\\tstatic const int mx = 1e5 + 2;\\n\\tvector<pair<int, int>> T[mx];\\n\\tint p[mx];\\n\\tint find(int u) { return p[u] = u == p[u] ? u : find(p[u]); }\\n\\tvoid merge(int u, int v) { p[find(u)] = find(v); }\\npublic:\\n\\tvector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n\\t\\tfor (int i = 0; i < n; i++)p[i] = i;\\n\\t\\tfor (auto &x : meetings) T[x[2]].push_back({x[0], x[1]});\\n\\t\\tmerge(0, firstPerson);\\n\\t\\tfor (int i = 1; i < mx; i++) {\\n\\t\\t\\tfor (auto &[x, y] : T[i])merge(x, y);\\n\\t\\t\\tfor (auto &[x, y] : T[i]) {\\n\\t\\t\\t\\tif (find(x) != find(0)) {\\n\\t\\t\\t\\t\\tp[x] = x;\\n\\t\\t\\t\\t\\tp[y] = y;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvector<int> ans;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (find(i) == find(0)) {\\n\\t\\t\\t\\tans.push_back(i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601900,
                "title": "java-priority-queue",
                "content": "1. Write in a lookup table for every pair of people [U,V] what\\'s the list of all their meeting times\\n2. Traverse all people in the order in which they get notified (learn the secret), by putting them in a priority queue ordered by secretLearnTime a.k.a. firstMeetingWithSomeoneWhoKnowsSecretTime.\\n3. Start by putting 0 and firstPerson in the queue.\\n4. When we process a person U (poll them from the queue) we add them to the answer and record the time they were notified. \\n5. Next, we go through all people V which U met, skipping people who already know the secret.\\n6. We find the first meeting time with V after U was notified. (Earlier meetings don\\'t matter, since back then U was clueluess and could not share a secret with V)\\n7. We put this first meeting time on the priority queue for person V. Eventually it may be trumped by an earlier meeting time with another notified person. Either way by the time we pull V out of the priority queue we know what would be the first time for him to get notified and can ignore lower priority times we will pull later out.\\n8. We are done with U and can go to the next person on the priority queue.\\n\\n\\n\\n```\\nclass Solution {\\n    //[[u,v] = meeting times list]\\n    Map<Integer, Map<Integer, List<Integer>>> g = new HashMap<>();\\n         \\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        int[] notified = new int[n]; Arrays.fill(notified, - 1);\\n        for (int i = 0; i < n; i++) g.put(i, new HashMap<>());\\n        for (int[] m : meetings) getMeetingTimes(m[0], m[1]).add(m[2]);\\n        \\n        List<Integer> res = new ArrayList<>();\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> a[1] - b[1]);\\n        pq.offer(new int[]{0,0});\\n        pq.offer(new int[]{firstPerson,0});\\n        while(!pq.isEmpty()) {\\n            int[] cur = pq.poll();           \\n            int u = cur[0];\\n            if (notified[u] > -1) continue; //already visited\\n            notified[u] = cur[1];\\n            res.add(u);\\n            for (Map.Entry<Integer,List<Integer>> entry : g.get(u).entrySet()) {\\n                int v = entry.getKey();\\n                if (notified[v] > -1) continue; // already visited\\n                Collections.sort(entry.getValue());\\n                for (int time : entry.getValue()) {\\n                    //get first time u and v met after person u learned the secret\\n                    if (time >= notified[u]) {\\n                        pq.offer(new int[]{v,time});\\n                        break;\\n                    }\\n                }\\n            }\\n            g.remove(u); //u was fully processed\\n        }\\n        return res;\\n    }\\n    \\n    List<Integer> getMeetingTimes(int u, int v) {\\n        List<Integer> times = g.get(u).get(v);\\n        if (times == null) {\\n            times = new ArrayList<>();\\n            g.get(u).put(v, times);\\n            g.get(v).put(u, times);\\n        }\\n        return times;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    //[[u,v] = meeting times list]\\n    Map<Integer, Map<Integer, List<Integer>>> g = new HashMap<>();\\n         \\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        int[] notified = new int[n]; Arrays.fill(notified, - 1);\\n        for (int i = 0; i < n; i++) g.put(i, new HashMap<>());\\n        for (int[] m : meetings) getMeetingTimes(m[0], m[1]).add(m[2]);\\n        \\n        List<Integer> res = new ArrayList<>();\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> a[1] - b[1]);\\n        pq.offer(new int[]{0,0});\\n        pq.offer(new int[]{firstPerson,0});\\n        while(!pq.isEmpty()) {\\n            int[] cur = pq.poll();           \\n            int u = cur[0];\\n            if (notified[u] > -1) continue; //already visited\\n            notified[u] = cur[1];\\n            res.add(u);\\n            for (Map.Entry<Integer,List<Integer>> entry : g.get(u).entrySet()) {\\n                int v = entry.getKey();\\n                if (notified[v] > -1) continue; // already visited\\n                Collections.sort(entry.getValue());\\n                for (int time : entry.getValue()) {\\n                    //get first time u and v met after person u learned the secret\\n                    if (time >= notified[u]) {\\n                        pq.offer(new int[]{v,time});\\n                        break;\\n                    }\\n                }\\n            }\\n            g.remove(u); //u was fully processed\\n        }\\n        return res;\\n    }\\n    \\n    List<Integer> getMeetingTimes(int u, int v) {\\n        List<Integer> times = g.get(u).get(v);\\n        if (times == null) {\\n            times = new ArrayList<>();\\n            g.get(u).put(v, times);\\n            g.get(v).put(u, times);\\n        }\\n        return times;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599925,
                "title": "c-multisource-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n\\n    // Function used to sort the array in the non-decreasing time stamp.\\n    static bool cmp(vector<int> &v1, vector<int> &v2){\\n        return v1[2]<v2[2];\\n    }\\n    vector<int> findAllPeople(int n, vector<vector<int>>& arr, int f) {\\n        //  Vector that holds whether a particular persons knows the secret or not.\\n        //  1 -> Not known, 0 -> known.\\n        vector<int> parent(n, 1);\\n\\n        sort(arr.begin(),arr.end(),cmp);\\n\\t\\t\\n\\t\\t// 0th and firstperson already knows the secret.\\n        parent[0]=0;\\n        parent[f]=0;\\n\\n        for(int i=0;i<arr.size();i++){\\n            ll j=i;\\n\\n\\t\\t\\t// Used to build the graph.\\n            map<int,vector<int>> mp;\\n\\n            queue<int> q;\\n            set<int> ss;\\n\\n\\t\\t\\t//  Loop till the current time stamp.\\n            while(j<arr.size() && arr[i][2]==arr[j][2]){\\n                int xx = parent[arr[j][0]];\\n                int yy = parent[arr[j][1]];\\n                if(xx==0){\\n                    if(ss.find(arr[j][0])==ss.end()){\\n                        q.push(arr[j][0]);\\n                        ss.insert(arr[j][0]);\\n                    }\\n                }\\n                if(yy==0){\\n                    if(ss.find(arr[j][1])==ss.end()){\\n                        q.push(arr[j][1]);\\n                        ss.insert(arr[j][1]);\\n                    }\\n                }\\n                mp[arr[j][0]].push_back(arr[j][1]);\\n                mp[arr[j][1]].push_back(arr[j][0]);\\n                j++;\\n            }\\n            \\n\\t\\t\\t// Check who knows the secret in the current time stamp.\\n            while(!q.empty()){\\n                int p =q.front();\\n                q.pop();\\n                parent[p]=0;\\n                for(auto x:mp[p]){\\n                    if(ss.find(x)==ss.end()){\\n                        ss.insert(x);\\n                        q.push(x);\\n                    }\\n                }\\n            }\\n            i = j-1;\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<n;i++){\\n            if(parent[i]==0)ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n\\n    // Function used to sort the array in the non-decreasing time stamp.\\n    static bool cmp(vector<int> &v1, vector<int> &v2){\\n        return v1[2]<v2[2];\\n    }\\n    vector<int> findAllPeople(int n, vector<vector<int>>& arr, int f) {\\n        //  Vector that holds whether a particular persons knows the secret or not.\\n        //  1 -> Not known, 0 -> known.\\n        vector<int> parent(n, 1);\\n\\n        sort(arr.begin(),arr.end(),cmp);\\n\\t\\t\\n\\t\\t// 0th and firstperson already knows the secret.\\n        parent[0]=0;\\n        parent[f]=0;\\n\\n        for(int i=0;i<arr.size();i++){\\n            ll j=i;\\n\\n\\t\\t\\t// Used to build the graph.\\n            map<int,vector<int>> mp;\\n\\n            queue<int> q;\\n            set<int> ss;\\n\\n\\t\\t\\t//  Loop till the current time stamp.\\n            while(j<arr.size() && arr[i][2]==arr[j][2]){\\n                int xx = parent[arr[j][0]];\\n                int yy = parent[arr[j][1]];\\n                if(xx==0){\\n                    if(ss.find(arr[j][0])==ss.end()){\\n                        q.push(arr[j][0]);\\n                        ss.insert(arr[j][0]);\\n                    }\\n                }\\n                if(yy==0){\\n                    if(ss.find(arr[j][1])==ss.end()){\\n                        q.push(arr[j][1]);\\n                        ss.insert(arr[j][1]);\\n                    }\\n                }\\n                mp[arr[j][0]].push_back(arr[j][1]);\\n                mp[arr[j][1]].push_back(arr[j][0]);\\n                j++;\\n            }\\n            \\n\\t\\t\\t// Check who knows the secret in the current time stamp.\\n            while(!q.empty()){\\n                int p =q.front();\\n                q.pop();\\n                parent[p]=0;\\n                for(auto x:mp[p]){\\n                    if(ss.find(x)==ss.end()){\\n                        ss.insert(x);\\n                        q.push(x);\\n                    }\\n                }\\n            }\\n            i = j-1;\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<n;i++){\\n            if(parent[i]==0)ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2239352,
                "title": "c-code-for-beginners-reference-for-future-me",
                "content": "## Approach 1- DFS \\n![image](https://assets.leetcode.com/users/images/8025d243-3282-4102-b623-4b85f8ad5e75_1656995475.138587.png)\\n\\nWe see at same timeframe, what connections can be made. The idea is that, at a particular time frame, we will make out a graph of how many people are connected to each other in this time frame. Now we already maintained a set of people who already know the secret, we will perform DFS from each person who knows the secret in the graph we just created. If the friend already knows the secret, do not perform DFS from him, since as he knows already he have told the secret to his frnds already. Finally, we will insert all person from the set to the vector and return.\\n**CODE**-\\n```\\nclass Solution {\\npublic:\\n    void dfs(list<int>* adj, int node, unordered_set<int> &knowsSecret){\\n        for(auto nei: adj[node]){\\n            if(knowsSecret.find(nei)!=knowsSecret.end()){\\n                continue;\\n            }\\n            knowsSecret.insert(nei);\\n            dfs(adj,nei,knowsSecret);\\n        }\\n    }\\n    \\n    static bool cmp(vector<int> &M1, vector<int> &M2){\\n        return M1[2]<M2[2];\\n    }\\n    \\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        sort(meetings.begin(),meetings.end(),cmp);\\n        unordered_set<int> s;\\n        s.insert(0);\\n        s.insert(firstPerson);\\n        int i=0;\\n        while(i<meetings.size()){\\n            int time=meetings[i][2];\\n            list<int> adj[n];\\n            while(i<meetings.size() && time==meetings[i][2]){\\n                adj[meetings[i][0]].push_back(meetings[i][1]);\\n                adj[meetings[i][1]].push_back(meetings[i][0]);\\n                i++;\\n            }\\n            unordered_set<int> tmp=s;\\n            for(auto person: tmp){\\n                dfs(adj,person,s);\\n            }\\n        }\\n        vector<int> res;\\n        for(int i=0;i<n;i++){\\n            if(s.find(i)!=s.end()){\\n                res.push_back(i);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n## Approach 2- BFS\\n![image](https://assets.leetcode.com/users/images/c6f8e77b-d325-4cad-a492-48e695f9e4af_1656995482.5846555.png)\\n\\nUsing priority_queue. Similar to DFS, except, instead of making a graph for same time frame each time, we use priority queue to pull the minimum time currently in the office for the secret. This guy will tell the secret to his neighbors, on the condition, that the currTime must be lower or equal to the meeting time, he is going to tell the secret in and the neighbor should not already know the secret . Cuz until the currTime is past the meeting Time, the secret can be told to his neighbor. So we push the time and neighbor in the heap.\\n**CODE**- \\n```\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        vector<int> res;\\n        list<pair<int,int>> adj[n];\\n        for(int i=0;i<meetings.size();i++){\\n            adj[meetings[i][0]].push_back({meetings[i][1],meetings[i][2]});\\n            adj[meetings[i][1]].push_back({meetings[i][0],meetings[i][2]});\\n        }\\n        \\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        pq.push({0,0});\\n        pq.push({0,firstPerson});\\n        vector<bool> KnowsSecret(n,false);\\n        \\n        while(!pq.empty()){\\n            int size=pq.size();\\n            while(size--){\\n                int currTime=pq.top().first;\\n                int personSecret=pq.top().second;\\n                pq.pop();\\n                if(KnowsSecret[personSecret]==true){\\n                    continue;\\n                }\\n                KnowsSecret[personSecret]=true;\\n                for(auto nei: adj[personSecret]){\\n                    if(KnowsSecret[nei.first]==false && currTime<=nei.second){\\n                        pq.push({nei.second,nei.first});\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(KnowsSecret[i]==true){\\n                res.push_back(i);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n## Approach 3- Disjoint Sets \\n![image](https://assets.leetcode.com/users/images/60047f2a-53de-4259-bfff-800007816131_1656995490.7390268.png)\\n\\nTo find the connection between 0 and node quickly. We know, 0 is the one who told the secret to firstPerson, and then the chain started, so every person who finally will know the secret, must know 0 guy as well, cuz he was the one who started all this. So, the procedure is quite similar to DFS, except, we use find union to know, whether the guy in my set, knows 0 or not. If he does not know 0, this was a mistake, and we revert him back to unknown person, by resetting his parentvalue to original value again, which was changed due to union function. Finally, we check for each guy whether they know 0 or not, using find function, and if they know him , he must know the secret.\\n**CODE**-\\n```\\nclass DisjointSets{\\nprivate:\\n    int* parent;\\n    int* dense;\\npublic: \\n    DisjointSets(int n){\\n        parent=new int[n];\\n        dense=new int[n];\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n            dense[i]=0;\\n        }\\n    }\\n    \\n    int find(int node){\\n        if(parent[node]==node){\\n            return node;\\n        }\\n        return parent[node]=find(parent[node]);\\n    }\\n    \\n    void loadBalancer(int node1, int node2){  \\n\\t/* Imagine node1 is a treeRoot having 200 children, and node2 is a treeRoot\\n\\t   having 10000 children. Would it be efficient to join 1000 children tree \\n\\t   to 200 and making 800 connections, or, would it be easy to make 200 \\n\\t   connections by joining node1 tree to node2 */\\n        if(dense[node1]>dense[node2]){\\n            parent[node2]=node1;\\n        }\\n        else{\\n            parent[node1]=node2;\\n        }\\n        if(dense[node1]==dense[node2]){ // if both tree are of same size, then we need to make one more dense, either increase node1 by 1 or node2 by 1\\n            dense[node1]++;\\n        }\\n    }\\n    \\n    void Union(int node1, int node2){\\n        int P_node1=find(node1);\\n        int P_node2=find(node2);    \\n        loadBalancer(P_node1,P_node2);\\n    }\\n    \\n    bool connected(int node1, int node2) {\\n        return find(node1)==find(node2);\\n    }\\n    \\n    void reset(int node){ \\n        parent[node]=node;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> &M1, vector<int> &M2){\\n        return M1[2]<M2[2];\\n    }\\n    \\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        sort(meetings.begin(),meetings.end(),cmp);\\n        DisjointSets ds(n);\\n        \\n        ds.Union(0,firstPerson);\\n        \\n        for(int i=0;i<meetings.size();){\\n            unordered_set<int> PersonInTimeWindow;\\n            int time=meetings[i][2];\\n            while(i<meetings.size() && time==meetings[i][2]){\\n                PersonInTimeWindow.insert(meetings[i][0]);\\n                PersonInTimeWindow.insert(meetings[i][1]);\\n                ds.Union(meetings[i][1],meetings[i][0]);\\n                i++;\\n            }\\n            for(int person: PersonInTimeWindow){ \\n                if(ds.connected(0,person)==false){  // each person in this time frame, if they know the secret, will be connected to the progenitor, i.e. , 0, so if this person, is not connected, he does not know the secret and hence reset him\\n                    ds.reset(person); // If not, this person doesn\\'t have secret, reset it.\\n                }\\n            }\\n        }\\n        vector<int> res;\\n        for(int person=0;person<n;person++){\\n            if(ds.connected(0,person)){\\n                res.push_back(person); // Push all the persons who are connected with person 0 into answer array     \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(list<int>* adj, int node, unordered_set<int> &knowsSecret){\\n        for(auto nei: adj[node]){\\n            if(knowsSecret.find(nei)!=knowsSecret.end()){\\n                continue;\\n            }\\n            knowsSecret.insert(nei);\\n            dfs(adj,nei,knowsSecret);\\n        }\\n    }\\n    \\n    static bool cmp(vector<int> &M1, vector<int> &M2){\\n        return M1[2]<M2[2];\\n    }\\n    \\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        sort(meetings.begin(),meetings.end(),cmp);\\n        unordered_set<int> s;\\n        s.insert(0);\\n        s.insert(firstPerson);\\n        int i=0;\\n        while(i<meetings.size()){\\n            int time=meetings[i][2];\\n            list<int> adj[n];\\n            while(i<meetings.size() && time==meetings[i][2]){\\n                adj[meetings[i][0]].push_back(meetings[i][1]);\\n                adj[meetings[i][1]].push_back(meetings[i][0]);\\n                i++;\\n            }\\n            unordered_set<int> tmp=s;\\n            for(auto person: tmp){\\n                dfs(adj,person,s);\\n            }\\n        }\\n        vector<int> res;\\n        for(int i=0;i<n;i++){\\n            if(s.find(i)!=s.end()){\\n                res.push_back(i);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        vector<int> res;\\n        list<pair<int,int>> adj[n];\\n        for(int i=0;i<meetings.size();i++){\\n            adj[meetings[i][0]].push_back({meetings[i][1],meetings[i][2]});\\n            adj[meetings[i][1]].push_back({meetings[i][0],meetings[i][2]});\\n        }\\n        \\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        pq.push({0,0});\\n        pq.push({0,firstPerson});\\n        vector<bool> KnowsSecret(n,false);\\n        \\n        while(!pq.empty()){\\n            int size=pq.size();\\n            while(size--){\\n                int currTime=pq.top().first;\\n                int personSecret=pq.top().second;\\n                pq.pop();\\n                if(KnowsSecret[personSecret]==true){\\n                    continue;\\n                }\\n                KnowsSecret[personSecret]=true;\\n                for(auto nei: adj[personSecret]){\\n                    if(KnowsSecret[nei.first]==false && currTime<=nei.second){\\n                        pq.push({nei.second,nei.first});\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(KnowsSecret[i]==true){\\n                res.push_back(i);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass DisjointSets{\\nprivate:\\n    int* parent;\\n    int* dense;\\npublic: \\n    DisjointSets(int n){\\n        parent=new int[n];\\n        dense=new int[n];\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n            dense[i]=0;\\n        }\\n    }\\n    \\n    int find(int node){\\n        if(parent[node]==node){\\n            return node;\\n        }\\n        return parent[node]=find(parent[node]);\\n    }\\n    \\n    void loadBalancer(int node1, int node2){  \\n\\t/* Imagine node1 is a treeRoot having 200 children, and node2 is a treeRoot\\n\\t   having 10000 children. Would it be efficient to join 1000 children tree \\n\\t   to 200 and making 800 connections, or, would it be easy to make 200 \\n\\t   connections by joining node1 tree to node2 */\\n        if(dense[node1]>dense[node2]){\\n            parent[node2]=node1;\\n        }\\n        else{\\n            parent[node1]=node2;\\n        }\\n        if(dense[node1]==dense[node2]){ // if both tree are of same size, then we need to make one more dense, either increase node1 by 1 or node2 by 1\\n            dense[node1]++;\\n        }\\n    }\\n    \\n    void Union(int node1, int node2){\\n        int P_node1=find(node1);\\n        int P_node2=find(node2);    \\n        loadBalancer(P_node1,P_node2);\\n    }\\n    \\n    bool connected(int node1, int node2) {\\n        return find(node1)==find(node2);\\n    }\\n    \\n    void reset(int node){ \\n        parent[node]=node;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> &M1, vector<int> &M2){\\n        return M1[2]<M2[2];\\n    }\\n    \\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        sort(meetings.begin(),meetings.end(),cmp);\\n        DisjointSets ds(n);\\n        \\n        ds.Union(0,firstPerson);\\n        \\n        for(int i=0;i<meetings.size();){\\n            unordered_set<int> PersonInTimeWindow;\\n            int time=meetings[i][2];\\n            while(i<meetings.size() && time==meetings[i][2]){\\n                PersonInTimeWindow.insert(meetings[i][0]);\\n                PersonInTimeWindow.insert(meetings[i][1]);\\n                ds.Union(meetings[i][1],meetings[i][0]);\\n                i++;\\n            }\\n            for(int person: PersonInTimeWindow){ \\n                if(ds.connected(0,person)==false){  // each person in this time frame, if they know the secret, will be connected to the progenitor, i.e. , 0, so if this person, is not connected, he does not know the secret and hence reset him\\n                    ds.reset(person); // If not, this person doesn\\'t have secret, reset it.\\n                }\\n            }\\n        }\\n        vector<int> res;\\n        for(int person=0;person<n;person++){\\n            if(ds.connected(0,person)){\\n                res.push_back(person); // Push all the persons who are connected with person 0 into answer array     \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890519,
                "title": "java-clear-union-find-solution-beats-93-light-explanation",
                "content": "Please upvote if you find it useful! Or leave comments or suggestions below!\\nI will try my best to answer them! Thank you so much for being supportive!\\n\\n```\\nclass Solution {\\n    class UnionFind {\\n        private int[] parent;\\n        \\n        UnionFind(int n) {\\n            parent = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                parent[i] = i;\\n            }\\n        }\\n        \\n        public void union(int node1, int node2) {\\n            node1 = find(node1);\\n            node2 = find(node2);\\n            if (node1 == node2) return;\\n            parent[node2] = node1;\\n        }\\n        \\n        public boolean isConnected(int node1, int node2) {\\n            return find(node1) == find(node2);\\n        }\\n        \\n        public void disunion(int node1, int node2) {\\n            parent[node1] = node1;\\n            parent[node2] = node2;\\n        }\\n        \\n        private int find(int node) {\\n            if (parent[node] == node) return node;\\n            return parent[node] = find(parent[node]);\\n        }\\n    }\\n    \\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        // first sort meetings by their start time\\n        Arrays.sort(meetings, (arr1, arr2)->Integer.compare(arr1[2], arr2[2]));\\n        UnionFind uf = new UnionFind(n);\\n        uf.union(0, firstPerson);\\n        \\n        int i = 0;\\n        while (i < meetings.length) {\\n            int j = i;\\n            \\n            // first time visit all meetings with the same time\\n            // union two person together\\n            while (j < meetings.length && meetings[j][2] == meetings[i][2]) {\\n                uf.union(meetings[j][0], meetings[j][1]);\\n                j++;\\n            }\\n            \\n            // second time visit all meetings with the same time\\n            // if any one of the person is not connected to 0\\n            // both person did not have the secret at this time\\n            // then disunion them \\n            while (i < j) {\\n                if (!uf.isConnected(0, meetings[i][0])) {\\n                    uf.disunion(meetings[i][0], meetings[i][1]);\\n                }\\n                i++;\\n            }\\n        }\\n        \\n        List<Integer> ret = new ArrayList<>();\\n        \\n        for (int k = 0; k < n; k++) {\\n            if (uf.isConnected(0, k)) {\\n                ret.add(k);\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class UnionFind {\\n        private int[] parent;\\n        \\n        UnionFind(int n) {\\n            parent = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                parent[i] = i;\\n            }\\n        }\\n        \\n        public void union(int node1, int node2) {\\n            node1 = find(node1);\\n            node2 = find(node2);\\n            if (node1 == node2) return;\\n            parent[node2] = node1;\\n        }\\n        \\n        public boolean isConnected(int node1, int node2) {\\n            return find(node1) == find(node2);\\n        }\\n        \\n        public void disunion(int node1, int node2) {\\n            parent[node1] = node1;\\n            parent[node2] = node2;\\n        }\\n        \\n        private int find(int node) {\\n            if (parent[node] == node) return node;\\n            return parent[node] = find(parent[node]);\\n        }\\n    }\\n    \\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        // first sort meetings by their start time\\n        Arrays.sort(meetings, (arr1, arr2)->Integer.compare(arr1[2], arr2[2]));\\n        UnionFind uf = new UnionFind(n);\\n        uf.union(0, firstPerson);\\n        \\n        int i = 0;\\n        while (i < meetings.length) {\\n            int j = i;\\n            \\n            // first time visit all meetings with the same time\\n            // union two person together\\n            while (j < meetings.length && meetings[j][2] == meetings[i][2]) {\\n                uf.union(meetings[j][0], meetings[j][1]);\\n                j++;\\n            }\\n            \\n            // second time visit all meetings with the same time\\n            // if any one of the person is not connected to 0\\n            // both person did not have the secret at this time\\n            // then disunion them \\n            while (i < j) {\\n                if (!uf.isConnected(0, meetings[i][0])) {\\n                    uf.disunion(meetings[i][0], meetings[i][1]);\\n                }\\n                i++;\\n            }\\n        }\\n        \\n        List<Integer> ret = new ArrayList<>();\\n        \\n        for (int k = 0; k < n; k++) {\\n            if (uf.isConnected(0, k)) {\\n                ret.add(k);\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600097,
                "title": "c-using-hash-map-with-brief-explanation",
                "content": "Build a map using time as key, people pair  array as value, and traverse the map, add the fit results to an unordered set, but need to consider front to back and back to front to cover all cases. Then output the unordered set members to a vector.\\n```\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        vector<int> res;\\n        set<int> ust;\\n        ust.insert(0);\\n        ust.insert(firstPerson);\\n        map<int,vector<pair<int,int>>> mp;\\n        for (auto &m : meetings) {\\n            mp[m[2]].push_back({m[0],m[1]});\\n        }\\n        for (auto &m : mp) {\\n            for (auto &v : m.second) { //front to back\\n                if (ust.count(v.first)) {\\n                    ust.insert(v.second);\\n                }\\n                if (ust.count(v.second)) {\\n                    ust.insert(v.first);\\n                }\\n            }\\n            for (auto it = m.second.rbegin(); it != m.second.rend(); ++it) { //back to front\\n                if (ust.count((*it).first)) {\\n                    ust.insert((*it).second);\\n                }\\n                if (ust.count((*it).second)) {\\n                    ust.insert((*it).first);\\n                }\\n            }\\n        }\\n        for (auto it = ust.begin(); it != ust.end(); ++it)\\n            res.push_back(*it);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        vector<int> res;\\n        set<int> ust;\\n        ust.insert(0);\\n        ust.insert(firstPerson);\\n        map<int,vector<pair<int,int>>> mp;\\n        for (auto &m : meetings) {\\n            mp[m[2]].push_back({m[0],m[1]});\\n        }\\n        for (auto &m : mp) {\\n            for (auto &v : m.second) { //front to back\\n                if (ust.count(v.first)) {\\n                    ust.insert(v.second);\\n                }\\n                if (ust.count(v.second)) {\\n                    ust.insert(v.first);\\n                }\\n            }\\n            for (auto it = m.second.rbegin(); it != m.second.rend(); ++it) { //back to front\\n                if (ust.count((*it).first)) {\\n                    ust.insert((*it).second);\\n                }\\n                if (ust.count((*it).second)) {\\n                    ust.insert((*it).first);\\n                }\\n            }\\n        }\\n        for (auto it = ust.begin(); it != ust.end(); ++it)\\n            res.push_back(*it);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599926,
                "title": "c-2092-find-all-people-with-secret",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        vector<bool> can(n); \\n        can[0] = can[firstPerson] = true; \\n        \\n        map<int, vector<pair<int, int>>> mp; \\n        for (auto& meeting : meetings) \\n            mp[meeting[2]].emplace_back(meeting[0], meeting[1]); \\n        \\n        for (auto& [k, v] : mp) {\\n            unordered_map<int, vector<int>> graph; \\n            unordered_set<int> st; \\n            for (auto& [x, y] : v) {\\n                graph[x].push_back(y); \\n                graph[y].push_back(x); \\n                if (can[x]) st.insert(x); \\n                if (can[y]) st.insert(y); \\n            }\\n            \\n            queue<int> q; \\n            for (auto& x : st) q.push(x); \\n            \\n            while (q.size()) {\\n                auto x = q.front(); q.pop(); \\n                for (auto& y : graph[x]) \\n                    if (!can[y]) {\\n                        can[y] = true; \\n                        q.push(y); \\n                    }\\n            }\\n        }\\n        \\n        vector<int> ans; \\n        for (int i = 0; i < n; ++i) \\n            if (can[i]) ans.push_back(i); \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        vector<bool> can(n); \\n        can[0] = can[firstPerson] = true; \\n        \\n        map<int, vector<pair<int, int>>> mp; \\n        for (auto& meeting : meetings) \\n            mp[meeting[2]].emplace_back(meeting[0], meeting[1]); \\n        \\n        for (auto& [k, v] : mp) {\\n            unordered_map<int, vector<int>> graph; \\n            unordered_set<int> st; \\n            for (auto& [x, y] : v) {\\n                graph[x].push_back(y); \\n                graph[y].push_back(x); \\n                if (can[x]) st.insert(x); \\n                if (can[y]) st.insert(y); \\n            }\\n            \\n            queue<int> q; \\n            for (auto& x : st) q.push(x); \\n            \\n            while (q.size()) {\\n                auto x = q.front(); q.pop(); \\n                for (auto& y : graph[x]) \\n                    if (!can[y]) {\\n                        can[y] = true; \\n                        q.push(y); \\n                    }\\n            }\\n        }\\n        \\n        vector<int> ans; \\n        for (int i = 0; i < n; ++i) \\n            if (can[i]) ans.push_back(i); \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599900,
                "title": "java-tle-on-sort-bfs-passes-41-42-cases",
                "content": "Hi everyone, could someone please tell me why my code does a TLE on the last test case? passes 41/42 cases\\n\\nthis is my code, it is just sort by timestamp, then bfs every interval of same times to add whichever ones contain people with secret\\n\\nEdit: after looking at what others did, i wonder if union find is what the problem wants you to use?\\n\\n```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        Arrays.sort(meetings, (a,b) -> a[2]-b[2]);\\n        Set<Integer> set = new HashSet<>();//people who know the secret\\n     //   for(int[] meeting : meetings) System.out.println(Arrays.toString(meeting));\\n        set.add(firstPerson);\\n        set.add(0);\\n        int time = 0;\\n        Map<Integer, List<Integer>> currMap = new HashMap<>();\\n        boolean flag = false;\\n        for(int[] meeting: meetings){\\n            if(meeting[2] != time){//currtime is greater than previous meetings, need to add pool to set if flag, restart process to curernt time\\n                if(flag){\\n                    //set.addAll(curr);//bfs(curr, 0, firstPerson));//bfs\\n                   // System.out.println(currMap);\\n                    add(currMap, set);\\n                    flag = false;\\n                }\\n                currMap.clear();\\n                time = meeting[2];\\n            }\\n            currMap.putIfAbsent(meeting[0], new ArrayList<>());\\n            currMap.putIfAbsent(meeting[1], new ArrayList<>());\\n            currMap.get(meeting[0]).add(meeting[1]);\\n            currMap.get(meeting[1]).add(meeting[0]);\\n            if(set.contains(meeting[0]) || set.contains(meeting[1])) flag = true;\\n        }\\n        if(flag) add(currMap, set);//set.addAll(curr);//bfs(curr, 0, firstPerson));//adds at last\\n        return new ArrayList<>(set);\\n    }\\n    public void add(Map<Integer, List<Integer>> map, Set<Integer> secret){\\n        Set<Integer> visited = new HashSet<>(secret);\\n        Queue<Integer> q = new LinkedList<>(secret);\\n        while(!q.isEmpty()){\\n            int curr = q.poll();\\n           //System.out.println(curr + \" \" + visited);\\n            if(!map.containsKey(curr)) continue;\\n            for(int i : map.get(curr)){\\n                if(!visited.add(i)) continue;\\n                secret.add(i);\\n                q.offer(i);\\n            }\\n        }\\n    }\\n}\\n```\\nThanks in advance!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        Arrays.sort(meetings, (a,b) -> a[2]-b[2]);\\n        Set<Integer> set = new HashSet<>();//people who know the secret\\n     //   for(int[] meeting : meetings) System.out.println(Arrays.toString(meeting));\\n        set.add(firstPerson);\\n        set.add(0);\\n        int time = 0;\\n        Map<Integer, List<Integer>> currMap = new HashMap<>();\\n        boolean flag = false;\\n        for(int[] meeting: meetings){\\n            if(meeting[2] != time){//currtime is greater than previous meetings, need to add pool to set if flag, restart process to curernt time\\n                if(flag){\\n                    //set.addAll(curr);//bfs(curr, 0, firstPerson));//bfs\\n                   // System.out.println(currMap);\\n                    add(currMap, set);\\n                    flag = false;\\n                }\\n                currMap.clear();\\n                time = meeting[2];\\n            }\\n            currMap.putIfAbsent(meeting[0], new ArrayList<>());\\n            currMap.putIfAbsent(meeting[1], new ArrayList<>());\\n            currMap.get(meeting[0]).add(meeting[1]);\\n            currMap.get(meeting[1]).add(meeting[0]);\\n            if(set.contains(meeting[0]) || set.contains(meeting[1])) flag = true;\\n        }\\n        if(flag) add(currMap, set);//set.addAll(curr);//bfs(curr, 0, firstPerson));//adds at last\\n        return new ArrayList<>(set);\\n    }\\n    public void add(Map<Integer, List<Integer>> map, Set<Integer> secret){\\n        Set<Integer> visited = new HashSet<>(secret);\\n        Queue<Integer> q = new LinkedList<>(secret);\\n        while(!q.isEmpty()){\\n            int curr = q.poll();\\n           //System.out.println(curr + \" \" + visited);\\n            if(!map.containsKey(curr)) continue;\\n            for(int i : map.get(curr)){\\n                if(!visited.add(i)) continue;\\n                secret.add(i);\\n                q.offer(i);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683401,
                "title": "with-pictures-easy-to-understand-union-find-approach",
                "content": "**Intuition**\\n\\nThe key to this problem is observing that:\\n1. We need to keep track of all people who know the secret (i.e., this is the disjoint set containing person `0`); and\\n2. When we have people meeting at the same time, we will connect the people who meet each other. \\n\\t* However, this can result in disjoint sets of size greater than 1 of people who don\\'t know the secret.\\n\\t*  Therefore, before we move on to process the next point in time, we need to make sure that we have **only one** disjoint set of size greater than 1 -- that is the people who know the secret.\\n\\t*  This will help us avoiding to connect wrong people unintentionally in the future.\\n\\nProcedure `unset_nodes` will unset all nodes that are not connected to node `0` (i.e., people who don\\'t know the secret). It will ensure that we leave a particular time with **only one** disjoint set of size greater than 1 -- the people who know the secret.\\n\\n![image](https://assets.leetcode.com/users/images/5ccf690a-8e4c-44f3-b1ed-dcd6cc0fe813_1665354085.6317115.png)\\n\\n**Algorithm**\\nFirst, we implement the algorithm to unset all people who don\\'t know the secret as follows:\\n```python\\ndef unset_nodes(self, uf: UnionFind, nodes: Set[int]) -> None:\\n\\tfor p in nodes:\\n\\t\\tif uf.is_connected(0, p):\\n\\t\\t\\tcontinue\\n\\t\\t# This person does not know the secret, so disconnect\\n\\t\\t# this person from any other people. Note that we will\\n\\t\\t# NOT mess up the ranks of nodes, because we unset every\\n\\t\\t# person who is not knowing the secret. At the end of the\\n\\t\\t# operation, there will only be one \"connected component\".\\n\\t\\tuf.root[p], uf.rank[p] = p, 1\\n```\\n\\nThen, the main algorithm that utilized union find, as follows:\\n**NOTE:** `UnionFind` is just a standard implementation of union find with ranks and path compression. You can learn more about this in the LeetCode official Union Find card.\\n```python\\ndef findAllPeople(self, n: int, meetings: List[List[int]], first: int) -> List[int]:\\n\\t# Initialize union find and connect people who initially know the secret;\\n\\t# Since person 0 will tell the secret to person `first`, this will be a set\\n\\t# of two people: 0 and `first`.\\n\\tuf = UnionFind(n)\\n\\tuf.union(0, first)\\n\\n\\t# Process meeting sorted by time in ascending order; this is very intuitive.\\n\\tmeetings.sort(key=lambda meeting: meeting[2])\\n\\n\\t# `prev_time` allows us to tell whether we are moving on to a new time period;\\n\\t# `processed` allows us to record the nodes that we have processed for this\\n\\t# point in time.\\n\\tprev_time, processed = None, set()\\n\\n\\t# Reads: person `x` meets person `y` at time `time`.\\n\\tfor x, y, time in meetings:\\n\\t\\t# When we enter into a new point in time, we keep **only** the\\n\\t\\t# people knowing the secret connected. This means all people (nodes)\\n\\t\\t# not knowing the secret must be disconnected.\\n\\t\\tif prev_time != time:\\n\\t\\t\\tprev_time = time\\n\\t\\t\\t# `unset_nodes` finds all people in `processed` that is not knowing\\n\\t\\t\\t# the secret; i.e., not connected with node 0.\\n\\t\\t\\tself.unset_nodes(uf, processed)\\n\\t\\t\\tprocessed = set()\\n\\n\\t\\t# Marks that person `x` meets with person `y`, and we \"processed\" person\\n\\t\\t#  `x` and `y`.\\n\\t\\tuf.union(x, y)\\n\\t\\tprocessed.update([x, y])\\n\\n\\t# Find all people who are knows the secret.\\n\\tres = []\\n\\tfor i in range(n):\\n\\t\\tif uf.is_connected(0, i):\\n\\t\\t\\tres.append(i)\\n\\treturn res\\n```\\n\\n**Please...**\\n\\nPlease **upvote** this post if you find it helpful. It motivates me to create more helpful content for the community.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find",
                    "Graph"
                ],
                "code": "```python\\ndef unset_nodes(self, uf: UnionFind, nodes: Set[int]) -> None:\\n\\tfor p in nodes:\\n\\t\\tif uf.is_connected(0, p):\\n\\t\\t\\tcontinue\\n\\t\\t# This person does not know the secret, so disconnect\\n\\t\\t# this person from any other people. Note that we will\\n\\t\\t# NOT mess up the ranks of nodes, because we unset every\\n\\t\\t# person who is not knowing the secret. At the end of the\\n\\t\\t# operation, there will only be one \"connected component\".\\n\\t\\tuf.root[p], uf.rank[p] = p, 1\\n```\n```python\\ndef findAllPeople(self, n: int, meetings: List[List[int]], first: int) -> List[int]:\\n\\t# Initialize union find and connect people who initially know the secret;\\n\\t# Since person 0 will tell the secret to person `first`, this will be a set\\n\\t# of two people: 0 and `first`.\\n\\tuf = UnionFind(n)\\n\\tuf.union(0, first)\\n\\n\\t# Process meeting sorted by time in ascending order; this is very intuitive.\\n\\tmeetings.sort(key=lambda meeting: meeting[2])\\n\\n\\t# `prev_time` allows us to tell whether we are moving on to a new time period;\\n\\t# `processed` allows us to record the nodes that we have processed for this\\n\\t# point in time.\\n\\tprev_time, processed = None, set()\\n\\n\\t# Reads: person `x` meets person `y` at time `time`.\\n\\tfor x, y, time in meetings:\\n\\t\\t# When we enter into a new point in time, we keep **only** the\\n\\t\\t# people knowing the secret connected. This means all people (nodes)\\n\\t\\t# not knowing the secret must be disconnected.\\n\\t\\tif prev_time != time:\\n\\t\\t\\tprev_time = time\\n\\t\\t\\t# `unset_nodes` finds all people in `processed` that is not knowing\\n\\t\\t\\t# the secret; i.e., not connected with node 0.\\n\\t\\t\\tself.unset_nodes(uf, processed)\\n\\t\\t\\tprocessed = set()\\n\\n\\t\\t# Marks that person `x` meets with person `y`, and we \"processed\" person\\n\\t\\t#  `x` and `y`.\\n\\t\\tuf.union(x, y)\\n\\t\\tprocessed.update([x, y])\\n\\n\\t# Find all people who are knows the secret.\\n\\tres = []\\n\\tfor i in range(n):\\n\\t\\tif uf.is_connected(0, i):\\n\\t\\t\\tres.append(i)\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2497184,
                "title": "python-bfs-for-different-time",
                "content": "```\\ndef findAllPeople(self, n: int, meetings: List[List[int]], p1: int) -> List[int]:\\n\\tcans = {0, p1}\\n\\tmp = defaultdict(list)\\n\\tfor x, y, t in meetings:\\n\\t\\tmp[t].append([x, y])\\n\\tfor t in sorted(mp):\\n\\t\\tq = set()\\n\\t\\tg = defaultdict(list)\\n\\t\\tfor x, y in mp[t]:\\n\\t\\t\\tg[x].append(y)\\n\\t\\t\\tg[y].append(x)\\n\\t\\t\\tif x in cans:\\n\\t\\t\\t\\tq.add(x)\\n\\t\\t\\tif y in cans:\\n\\t\\t\\t\\tq.add(y)\\n\\n\\t\\tq = deque(q)\\n\\t\\twhile(q):\\n\\t\\t\\tm = q.popleft()\\n\\t\\t\\tfor k in g[m]:\\n\\t\\t\\t\\tif k not in cans:\\n\\t\\t\\t\\t\\tq.append(k)\\n\\t\\t\\t\\t\\tcans.add(k)\\n\\treturn list(cans)\\n```",
                "solutionTags": [],
                "code": "```\\ndef findAllPeople(self, n: int, meetings: List[List[int]], p1: int) -> List[int]:\\n\\tcans = {0, p1}\\n\\tmp = defaultdict(list)\\n\\tfor x, y, t in meetings:\\n\\t\\tmp[t].append([x, y])\\n\\tfor t in sorted(mp):\\n\\t\\tq = set()\\n\\t\\tg = defaultdict(list)\\n\\t\\tfor x, y in mp[t]:\\n\\t\\t\\tg[x].append(y)\\n\\t\\t\\tg[y].append(x)\\n\\t\\t\\tif x in cans:\\n\\t\\t\\t\\tq.add(x)\\n\\t\\t\\tif y in cans:\\n\\t\\t\\t\\tq.add(y)\\n\\n\\t\\tq = deque(q)\\n\\t\\twhile(q):\\n\\t\\t\\tm = q.popleft()\\n\\t\\t\\tfor k in g[m]:\\n\\t\\t\\t\\tif k not in cans:\\n\\t\\t\\t\\t\\tq.append(k)\\n\\t\\t\\t\\t\\tcans.add(k)\\n\\treturn list(cans)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2438569,
                "title": "c-o-n-solution-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        bool has[n];\\n        int mit[n],ma=0;\\n        memset(has,0,sizeof(has));\\n        memset(mit,0x3f,sizeof(mit));\\n        mit[0]=mit[firstPerson]=0;\\n        vector<int> rt;\\n        vector<pair<int,int>> e[n];\\n        for(int i=0;i<meetings.size();++i){\\n            int x=meetings[i][0],y=meetings[i][1],t=meetings[i][2];\\n            ma=max(ma,t);\\n            if(y&&y!=firstPerson)e[x].push_back({y,t});\\n            if(x&&x!=firstPerson)e[y].push_back({x,t});\\n        }\\n        vector <int> pq[ma+1];\\n        pq[0].push_back(0);\\n        pq[0].push_back(firstPerson);\\n        for(int it=0;it<=ma;++it){\\n            for(int i=0;i<pq[it].size();++i){\\n                int v=pq[it][i];\\n                if(has[v])continue;\\n                has[v]=1;\\n                rt.push_back(v);\\n                for(int j=0;j<e[v].size();++j){\\n                    int g=e[v][j].first,gt=e[v][j].second;\\n                    if(has[g]==0&&gt>=it&&mit[g]>gt){\\n                        mit[g]=gt;\\n                        pq[gt].push_back(g);\\n                    }\\n                }\\n            }\\n        }\\n        return rt;\\n    }\\n};\\n```\\n1.We can go through all the people who already have secrets in chronological order and expand them.\\n2.For someone who has already been expanded ( has[i] = 1 ), it doesn\\'t make sense to expand them again at a later point in time.\\n3.Use an array \"mit\" to record the earliest time the person was told the secret. If someone else will tell him the secret at a later time, it doesn\\'t need to be dealt with.\\n4.In the process of traversing all times , I will only expand each point at most once (O(n)), and the total number of expansions <=meetings.size() * 2 (O(2n)) -> total time complexity = O(n)#.\\n5.But actually using priority_queue to find next time will be faster O(nlg(n)). -> (588 ms, faster than 100.00%).",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        bool has[n];\\n        int mit[n],ma=0;\\n        memset(has,0,sizeof(has));\\n        memset(mit,0x3f,sizeof(mit));\\n        mit[0]=mit[firstPerson]=0;\\n        vector<int> rt;\\n        vector<pair<int,int>> e[n];\\n        for(int i=0;i<meetings.size();++i){\\n            int x=meetings[i][0],y=meetings[i][1],t=meetings[i][2];\\n            ma=max(ma,t);\\n            if(y&&y!=firstPerson)e[x].push_back({y,t});\\n            if(x&&x!=firstPerson)e[y].push_back({x,t});\\n        }\\n        vector <int> pq[ma+1];\\n        pq[0].push_back(0);\\n        pq[0].push_back(firstPerson);\\n        for(int it=0;it<=ma;++it){\\n            for(int i=0;i<pq[it].size();++i){\\n                int v=pq[it][i];\\n                if(has[v])continue;\\n                has[v]=1;\\n                rt.push_back(v);\\n                for(int j=0;j<e[v].size();++j){\\n                    int g=e[v][j].first,gt=e[v][j].second;\\n                    if(has[g]==0&&gt>=it&&mit[g]>gt){\\n                        mit[g]=gt;\\n                        pq[gt].push_back(g);\\n                    }\\n                }\\n            }\\n        }\\n        return rt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961976,
                "title": "c-union-find",
                "content": "**Idea:**\\nWe sort the meeting to find out the sequence of visits. \\nAt every time step (not every meeting), we optimistically merge people and joind them in out Union Find data structure.\\nAt the end of a time step, we look into every single individual in the meeting. If eigther of person in a meeting was connected to person_0, it means that he/she knows the secret, otherwise, we set the parents of those people to themselves. This union find ONLY keeps the track of people who know the secret and the rest of people are intentionally avoided to form a set.  \\n\\n```\\nstruct UnionFind\\n{\\n    vector<int> parents;\\n    vector<bool> knows;\\n    UnionFind(const int& n): parents(vector<int>(n)), knows(vector<bool>(n,false))\\n    {\\n        for(int i=0; i<n; i++)\\n            parents[i] = i;\\n        knows[0] = true;\\n    }\\n    int find(int p)\\n    {\\n        if (parents[p] == p)\\n            return p;\\n        else\\n            return find(parents[p]);\\n    }\\n    void merge(int p1, int p2)\\n    {\\n        int pr1 = find(p1);\\n        int pr2 = find(p2);\\n        if (pr1 != pr2)\\n        {\\n            parents[pr1] = min(pr1,pr2);\\n            parents[pr2] = min(pr1,pr2);\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        auto comp = [](const vector<int>& m1, const vector<int>& m2)\\n        {\\n            return m1[2]<m2[2];\\n        };\\n        sort(meetings.begin(), meetings.end(), comp);\\n        \\n        UnionFind uf(n);\\n        uf.merge(0, firstPerson);\\n        uf.knows[firstPerson] = true;\\n        \\n        for(int i=0; i<meetings.size(); i++)\\n        {\\n            int time = meetings[i][2];\\n            int index = i;\\n            while (i<meetings.size() && meetings[i][2] == time)\\n            {\\n                uf.merge(meetings[i][0], meetings[i][1]);\\n                i++;\\n            }\\n            while (index < i)\\n            {\\n                int par1 = uf.find(meetings[index][0]);\\n                int par2 = uf.find(meetings[index][1]);\\n                if (par1 != 0  && par2 != 0)\\n                {\\n                    uf.parents[meetings[index][0]] = meetings[index][0];\\n                    uf.parents[meetings[index][1]] = meetings[index][1];\\n                }\\n                index++;\\n            }\\n            i--;\\n        }\\n        \\n        vector<int> res;\\n        for(int i=0; i<n; i++)\\n            if (uf.find(i) == 0)\\n                res.push_back(i);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nstruct UnionFind\\n{\\n    vector<int> parents;\\n    vector<bool> knows;\\n    UnionFind(const int& n): parents(vector<int>(n)), knows(vector<bool>(n,false))\\n    {\\n        for(int i=0; i<n; i++)\\n            parents[i] = i;\\n        knows[0] = true;\\n    }\\n    int find(int p)\\n    {\\n        if (parents[p] == p)\\n            return p;\\n        else\\n            return find(parents[p]);\\n    }\\n    void merge(int p1, int p2)\\n    {\\n        int pr1 = find(p1);\\n        int pr2 = find(p2);\\n        if (pr1 != pr2)\\n        {\\n            parents[pr1] = min(pr1,pr2);\\n            parents[pr2] = min(pr1,pr2);\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        auto comp = [](const vector<int>& m1, const vector<int>& m2)\\n        {\\n            return m1[2]<m2[2];\\n        };\\n        sort(meetings.begin(), meetings.end(), comp);\\n        \\n        UnionFind uf(n);\\n        uf.merge(0, firstPerson);\\n        uf.knows[firstPerson] = true;\\n        \\n        for(int i=0; i<meetings.size(); i++)\\n        {\\n            int time = meetings[i][2];\\n            int index = i;\\n            while (i<meetings.size() && meetings[i][2] == time)\\n            {\\n                uf.merge(meetings[i][0], meetings[i][1]);\\n                i++;\\n            }\\n            while (index < i)\\n            {\\n                int par1 = uf.find(meetings[index][0]);\\n                int par2 = uf.find(meetings[index][1]);\\n                if (par1 != 0  && par2 != 0)\\n                {\\n                    uf.parents[meetings[index][0]] = meetings[index][0];\\n                    uf.parents[meetings[index][1]] = meetings[index][1];\\n                }\\n                index++;\\n            }\\n            i--;\\n        }\\n        \\n        vector<int> res;\\n        for(int i=0; i<n; i++)\\n            if (uf.find(i) == 0)\\n                res.push_back(i);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701410,
                "title": "python-priority-queue",
                "content": "```\\nimport heapq\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        adj = collections.defaultdict(list)\\n        for u, v, time in meetings:\\n            adj[u].append([time, v])\\n            adj[v].append([time, u])\\n        s = [(0, firstPerson),(0,0)]\\n        secret = set([firstPerson, 0])\\n        visited = set()\\n        while s:\\n            t, u = heapq.heappop(s)\\n            if u in visited:\\n                continue\\n            visited.add(u)\\n            for t2, v in adj[u]:\\n                if t2 >= t and v not in visited:\\n                    secret.add(v)\\n                    heapq.heappush(s,(t2, v))\\n            if len(visited) == n:\\n                break\\n        return list(secret)\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        adj = collections.defaultdict(list)\\n        for u, v, time in meetings:\\n            adj[u].append([time, v])\\n            adj[v].append([time, u])\\n        s = [(0, firstPerson),(0,0)]\\n        secret = set([firstPerson, 0])\\n        visited = set()\\n        while s:\\n            t, u = heapq.heappop(s)\\n            if u in visited:\\n                continue\\n            visited.add(u)\\n            for t2, v in adj[u]:\\n                if t2 >= t and v not in visited:\\n                    secret.add(v)\\n                    heapq.heappush(s,(t2, v))\\n            if len(visited) == n:\\n                break\\n        return list(secret)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1655216,
                "title": "javascript-2092-find-all-people-with-secret",
                "content": "---\\n\\n- **Solution 1**\\n  - Sort by time\\n  - For each time, use union find to group people\\n  - In the end, find all who are grouped under 0\\n  - NOTES:\\n    - Instead of sort, we can use pq\\n      - see https://leetcode.com/problems/find-all-people-with-secret/discuss/1600133/javascript-graph-bfs-with-pq-684ms\\n    - `while (mergeHappend) {` can be avoided if we can sequence the connections for above\\n    - The implementation of Union find (`WeightedDisjointSet`) is not provided below\\n      - Built using:\\n        - https://en.wikipedia.org/wiki/Disjoint-set_data_structure\\n        - https://www.hackerearth.com/practice/notes/disjoint-set-union-union-find/\\n      - Some union find JS implementations:\\n        - https://leetcode.com/problems/find-all-people-with-secret/discuss/1599819/JavaScript-BFS%2BGraphUnionFind-(2-Solutions)\\n        - https://leetcode.com/problems/find-all-people-with-secret/discuss/1601063/Typescript-union-find\\n- See **Solution2** - a full solution & a fast one\\n  - Core of this solution is written by\\n  - **[@cntsmf](https://leetcode-cn.com/u/cntsmf/)**\\n\\n---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n**Solution1**\\n\\n```\\nvar findAllPeople = function (n, meetings, firstPerson) {\\n  let set = new WeightedDisjointSet({ n });\\n  set.union(0, firstPerson);\\n\\n  meetings.sort((a, b) => a[2] - b[2]); // sort by time\\n\\n  let i, j;\\n  for (i = 0; i < meetings.length; ) {\\n    let time = meetings[i][2];\\n\\n    let mergeHappend = true;\\n    while (mergeHappend) {\\n      mergeHappend = false;\\n      for (j = i; j < meetings.length && meetings[j][2] === time; j++) {\\n        let [x, y] = meetings[j];\\n        if (\\n          set.find(x) !== set.find(y) && //\\n          (set.find(x) === 0 || set.find(y) === 0) &&\\n          1\\n        ) {\\n          set.union(x, y);\\n          set.union(y, x);\\n          mergeHappend = true;\\n        }\\n      } // for\\n    } // while\\n\\n    i = j;\\n  } // for\\n\\n  let ans = [];\\n  for (i = 0; i < n; i++) {\\n    if (set.find(i) === 0) {\\n      ans.push(i);\\n    }\\n  }\\n  return ans;\\n};\\n```\\n\\n---\\n\\n**Solution2** - a full solution & a fast one\\n\\n```\\nvar findAllPeople = function (n, meetings, firstPerson) {\\n    const parent = new Array(n).fill(0).map((_, i) => i);\\n    const find = (e) => (parent[e] === e ? e : (parent[e] = find(parent[e])));\\n    const reset = (e) => (parent[e] = e);\\n\\n    meetings.sort((a, b) => a[2] - b[2]);\\n\\n    parent[firstPerson] = 0;\\n    for (let i = 0, j = 0; j < meetings.length; j++) {\\n        if (j + 1 < meetings.length && meetings[j + 1][2] === meetings[j][2]) continue;\\n\\n        const set = new Set();\\n        for (let k = i; k <= j; k++) {\\n            const [x, y] = meetings[k];\\n            set.add(x);\\n            set.add(y);\\n            if (!find(x)) parent[find(y)] = find(x);\\n            else parent[find(x)] = find(y);\\n        }\\n        set.forEach((e) => find(e) && reset(e));\\n        i = j + 1;\\n    }\\n    return new Array(n)\\n        .fill(0)\\n        .map((_, i) => i)\\n        .filter((e) => !find(e));\\n};\\n```\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findAllPeople = function (n, meetings, firstPerson) {\\n  let set = new WeightedDisjointSet({ n });\\n  set.union(0, firstPerson);\\n\\n  meetings.sort((a, b) => a[2] - b[2]); // sort by time\\n\\n  let i, j;\\n  for (i = 0; i < meetings.length; ) {\\n    let time = meetings[i][2];\\n\\n    let mergeHappend = true;\\n    while (mergeHappend) {\\n      mergeHappend = false;\\n      for (j = i; j < meetings.length && meetings[j][2] === time; j++) {\\n        let [x, y] = meetings[j];\\n        if (\\n          set.find(x) !== set.find(y) && //\\n          (set.find(x) === 0 || set.find(y) === 0) &&\\n          1\\n        ) {\\n          set.union(x, y);\\n          set.union(y, x);\\n          mergeHappend = true;\\n        }\\n      } // for\\n    } // while\\n\\n    i = j;\\n  } // for\\n\\n  let ans = [];\\n  for (i = 0; i < n; i++) {\\n    if (set.find(i) === 0) {\\n      ans.push(i);\\n    }\\n  }\\n  return ans;\\n};\\n```\n```\\nvar findAllPeople = function (n, meetings, firstPerson) {\\n    const parent = new Array(n).fill(0).map((_, i) => i);\\n    const find = (e) => (parent[e] === e ? e : (parent[e] = find(parent[e])));\\n    const reset = (e) => (parent[e] = e);\\n\\n    meetings.sort((a, b) => a[2] - b[2]);\\n\\n    parent[firstPerson] = 0;\\n    for (let i = 0, j = 0; j < meetings.length; j++) {\\n        if (j + 1 < meetings.length && meetings[j + 1][2] === meetings[j][2]) continue;\\n\\n        const set = new Set();\\n        for (let k = i; k <= j; k++) {\\n            const [x, y] = meetings[k];\\n            set.add(x);\\n            set.add(y);\\n            if (!find(x)) parent[find(y)] = find(x);\\n            else parent[find(x)] = find(y);\\n        }\\n        set.forEach((e) => find(e) && reset(e));\\n        i = j + 1;\\n    }\\n    return new Array(n)\\n        .fill(0)\\n        .map((_, i) => i)\\n        .filter((e) => !find(e));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1610611,
                "title": "c-easy-and-intutive-solution",
                "content": "This is the most intutive approach that one might think - we observe that if there are three meetings at the same time all these meeting must be considered at the same time (that\\'s why BFS is also a possible solution) .\\n\\nLet\\'s understand this with an example- {1,2,8},{3,4,8},{1,4,8} here if we traverse just once we will see - \\n1. ***1*** tells ***2***\\n2. ***3*** and ***4*** both don\\'t know the secret\\n3. ***1*** tells ***4***\\n\\nbut here we miss the constraint which says that all the meetings take place at the same time and thus we have missed the 4th scenario-\\n\\n4. ***4*** tells ***3***\\n\\ndue to this i have traversed all the elements form end to begin.\\n\\n\\n```\\nvector<int> findAllPeople(int n, vector<vector<int>>& meets, int first) {\\n\\n        //map store the meeting pairs in ascending order of time of meeting\\n\\t\\t//vector is used so that all the pairs with same time meet simultaniously\\n        map<int,vector<pair<int,int>>> mp; \\n\\t\\t\\n        for(auto it  :meets){\\n            mp[it[2]].push_back({it[0],it[1]});\\n        }\\n        vector<int> ans;\\n        vector<int> vis(n,false);\\n        vis[0] = true;\\n        vis[first] = true;\\n        \\n        for(auto &m : mp){\\n\\t\\t// forward loop at any time\\n            for(auto &v : m.second){\\n                if(vis[v.first] || vis[v.second]){\\n                    vis[v.first]=true;\\n                    vis[v.second]=true;\\n                }\\n            }\\n\\t\\t//backward loop at any time\\n            for(auto v = m.second.rbegin();v != m.second.rend();v++){\\n                if(vis[(*v).first] || vis[(*v).second]){\\n                    vis[(*v).first]=true;\\n                    vis[(*v).second]=true;\\n                }\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//this 3rd loop can be avoided by using stl:set instead of visited array\\n            for(auto &v : m.second){\\n                if(vis[v.first] || vis[v.second]){\\n                    vis[v.first]=true;\\n                    vis[v.second]=true;\\n                }\\n            }\\n        }\\n        //all elements with visited true know the secret\\n        for(int i=0;i<n;i++){\\n            if(vis[i]) ans.push_back(i);\\n        }\\n        return ans;\\n\\n    }\\n\\t```\\n\\t\\n\\tPlease upvote if you like the explaination  :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> findAllPeople(int n, vector<vector<int>>& meets, int first) {\\n\\n        //map store the meeting pairs in ascending order of time of meeting\\n\\t\\t//vector is used so that all the pairs with same time meet simultaniously\\n        map<int,vector<pair<int,int>>> mp; \\n\\t\\t\\n        for(auto it  :meets){\\n            mp[it[2]].push_back({it[0],it[1]});\\n        }\\n        vector<int> ans;\\n        vector<int> vis(n,false);\\n        vis[0] = true;\\n        vis[first] = true;\\n        \\n        for(auto &m : mp){\\n\\t\\t// forward loop at any time\\n            for(auto &v : m.second){\\n                if(vis[v.first] || vis[v.second]){\\n                    vis[v.first]=true;\\n                    vis[v.second]=true;\\n                }\\n            }\\n\\t\\t//backward loop at any time\\n            for(auto v = m.second.rbegin();v != m.second.rend();v++){\\n                if(vis[(*v).first] || vis[(*v).second]){\\n                    vis[(*v).first]=true;\\n                    vis[(*v).second]=true;\\n                }\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//this 3rd loop can be avoided by using stl:set instead of visited array\\n            for(auto &v : m.second){\\n                if(vis[v.first] || vis[v.second]){\\n                    vis[v.first]=true;\\n                    vis[v.second]=true;\\n                }\\n            }\\n        }\\n        //all elements with visited true know the secret\\n        for(int i=0;i<n;i++){\\n            if(vis[i]) ans.push_back(i);\\n        }\\n        return ans;\\n\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1605980,
                "title": "c-bfs-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        \\n        int nn=meetings.size();\\n        vector<pair<int,int>>ve[n+1];\\n        int i,j;\\n        \\n        for(i=0;i<nn;i++)\\n        {\\n            ve[meetings[i][0]].push_back({meetings[i][1],meetings[i][2]});\\n            ve[meetings[i][1]].push_back({meetings[i][0],meetings[i][2]});\\n            \\n            \\n        }\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        \\n        vector<int>vis(n,0);\\n        \\n        pq.push({0,0});\\n        pq.push({0,firstPerson});\\n        \\n        while(!pq.empty())\\n        {\\n            int person=pq.top().second;\\n            int time=pq.top().first;\\n            pq.pop();\\n            if(vis[person])\\n                continue;\\n            vis[person]=1;\\n            \\n            for(auto it:ve[person])\\n            {\\n                if(!vis[it.first] and it.second>=time)\\n                {\\n                    pq.push({it.second,it.first});\\n                }\\n            }\\n        }\\n        vector<int>ans;\\n        for(i=0;i<n;i++)\\n        {\\n            if(vis[i])\\n                ans.push_back(i);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n**Pls upvote if you found helpful**",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        \\n        int nn=meetings.size();\\n        vector<pair<int,int>>ve[n+1];\\n        int i,j;\\n        \\n        for(i=0;i<nn;i++)\\n        {\\n            ve[meetings[i][0]].push_back({meetings[i][1],meetings[i][2]});\\n            ve[meetings[i][1]].push_back({meetings[i][0],meetings[i][2]});\\n            \\n            \\n        }\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        \\n        vector<int>vis(n,0);\\n        \\n        pq.push({0,0});\\n        pq.push({0,firstPerson});\\n        \\n        while(!pq.empty())\\n        {\\n            int person=pq.top().second;\\n            int time=pq.top().first;\\n            pq.pop();\\n            if(vis[person])\\n                continue;\\n            vis[person]=1;\\n            \\n            for(auto it:ve[person])\\n            {\\n                if(!vis[it.first] and it.second>=time)\\n                {\\n                    pq.push({it.second,it.first});\\n                }\\n            }\\n        }\\n        vector<int>ans;\\n        for(i=0;i<n;i++)\\n        {\\n            if(vis[i])\\n                ans.push_back(i);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602715,
                "title": "c-priorityqueue-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    struct compare{\\n        bool operator()(pair<int,int> &a, pair<int,int> &b){\\n            return a.second > b.second;         \\n        }\\n    };\\n    \\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        vector<vector<pair<int,int>>> graph(n);\\n        for(auto &g : meetings){\\n            int u=g[0],v=g[1],t=g[2];\\n            graph[u].push_back({v,t});\\n            graph[v].push_back({u,t});\\n        }\\n    \\n        vector<bool> vis(n,false);\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, compare> q;\\n        q.push({firstPerson,0});\\n        q.push({0,0});\\n\\t\\t\\n        while(!q.empty()){\\n            auto [p,t] = q.top(); q.pop();\\n\\t\\t\\t\\n            if(vis[p]) continue;\\n            vis[p]=true;\\n\\t\\t\\t\\n            for(auto [newP, newT] : graph[p]){\\n                if(newT>=t && !vis[newP]){\\n                    q.push({newP,newT});\\n                }\\n            }\\n        }\\n        \\n        vector<int> res;\\n        for(int i=0; i<n; ++i){\\n           if(vis[i]) res.push_back(i);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct compare{\\n        bool operator()(pair<int,int> &a, pair<int,int> &b){\\n            return a.second > b.second;         \\n        }\\n    };\\n    \\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        vector<vector<pair<int,int>>> graph(n);\\n        for(auto &g : meetings){\\n            int u=g[0],v=g[1],t=g[2];\\n            graph[u].push_back({v,t});\\n            graph[v].push_back({u,t});\\n        }\\n    \\n        vector<bool> vis(n,false);\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, compare> q;\\n        q.push({firstPerson,0});\\n        q.push({0,0});\\n\\t\\t\\n        while(!q.empty()){\\n            auto [p,t] = q.top(); q.pop();\\n\\t\\t\\t\\n            if(vis[p]) continue;\\n            vis[p]=true;\\n\\t\\t\\t\\n            for(auto [newP, newT] : graph[p]){\\n                if(newT>=t && !vis[newP]){\\n                    q.push({newP,newT});\\n                }\\n            }\\n        }\\n        \\n        vector<int> res;\\n        for(int i=0; i<n; ++i){\\n           if(vis[i]) res.push_back(i);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599949,
                "title": "java-dfs-graph",
                "content": "```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        int m = meetings.length;\\n        \\n        boolean[] secretKnown = new boolean[n];\\n        int t = 1;\\n        int i = 0;\\n        secretKnown[0] = true;\\n        secretKnown[firstPerson] = true;\\n        Arrays.sort(meetings, (a,b)->a[2]-b[2]);//Sort the inp according thier time\\n        while(t<100000 && i<m){\\n            HashMap<Integer, List<Integer>> graph = new HashMap<Integer, List<Integer>>();\\n            \\n            while(i<m && meetings[i][2] <= t){//Create a graph less than curr t time\\n                \\n                if(!graph.containsKey(meetings[i][0]))\\n                    graph.put(meetings[i][0], new ArrayList<Integer>());\\n                \\n                \\n                if(!graph.containsKey(meetings[i][1]))\\n                    graph.put(meetings[i][1], new ArrayList<Integer>());\\n                \\n                graph.get(meetings[i][0]).add(meetings[i][1]);\\n                graph.get(meetings[i][1]).add(meetings[i][0]);\\n                i++;\\n            }\\n            boolean[] vis = new boolean[n];\\n            for(int next: graph.keySet())\\n                dfs(graph, secretKnown, next, vis);//Do dfs on connected graph components and update secretKnown accordingly\\n            \\n            t++;\\n            \\n        }\\n        List<Integer> res = new ArrayList<>();\\n        \\n        for(i=0;i<n;i++)\\n            if(secretKnown[i])\\n                res.add(i);\\n        \\n        return res;\\n    }\\n    \\n    public void dfs(HashMap<Integer, List<Integer>> g, boolean[] sec, int curr, boolean[] vis){\\n        if(!sec[curr])\\n            return;\\n        if(vis[curr])\\n            return;\\n        vis[curr] = true;\\n        for(int next: g.get(curr))\\n        {\\n            sec[next] = true;\\n            if(!vis[next])\\n                dfs(g, sec, next, vis);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        int m = meetings.length;\\n        \\n        boolean[] secretKnown = new boolean[n];\\n        int t = 1;\\n        int i = 0;\\n        secretKnown[0] = true;\\n        secretKnown[firstPerson] = true;\\n        Arrays.sort(meetings, (a,b)->a[2]-b[2]);//Sort the inp according thier time\\n        while(t<100000 && i<m){\\n            HashMap<Integer, List<Integer>> graph = new HashMap<Integer, List<Integer>>();\\n            \\n            while(i<m && meetings[i][2] <= t){//Create a graph less than curr t time\\n                \\n                if(!graph.containsKey(meetings[i][0]))\\n                    graph.put(meetings[i][0], new ArrayList<Integer>());\\n                \\n                \\n                if(!graph.containsKey(meetings[i][1]))\\n                    graph.put(meetings[i][1], new ArrayList<Integer>());\\n                \\n                graph.get(meetings[i][0]).add(meetings[i][1]);\\n                graph.get(meetings[i][1]).add(meetings[i][0]);\\n                i++;\\n            }\\n            boolean[] vis = new boolean[n];\\n            for(int next: graph.keySet())\\n                dfs(graph, secretKnown, next, vis);//Do dfs on connected graph components and update secretKnown accordingly\\n            \\n            t++;\\n            \\n        }\\n        List<Integer> res = new ArrayList<>();\\n        \\n        for(i=0;i<n;i++)\\n            if(secretKnown[i])\\n                res.add(i);\\n        \\n        return res;\\n    }\\n    \\n    public void dfs(HashMap<Integer, List<Integer>> g, boolean[] sec, int curr, boolean[] vis){\\n        if(!sec[curr])\\n            return;\\n        if(vis[curr])\\n            return;\\n        vis[curr] = true;\\n        for(int next: g.get(curr))\\n        {\\n            sec[next] = true;\\n            if(!vis[next])\\n                dfs(g, sec, next, vis);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599798,
                "title": "python-pure-dfs-no-tle-no-uf-dsu",
                "content": "Sort the timestamps.\\n\\nSince the news spreads instantly, start with the people who know the secret then DFS per timestamp to spread the news. \\n\\n```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        #Base Cases\\n        know = [False for _ in range(n)]\\n        know[firstPerson] = True\\n        know[0] = True\\n        \\n        #Construct adjacency list per timestamp.\\n        peopleAtTimeStamp = defaultdict(set)\\n        adjList = defaultdict(lambda: defaultdict(list))\\n        \\n        for source, target, time in meetings:\\n            peopleAtTimeStamp[time].update({target, source})\\n            adjList[time][source].append(target)\\n            adjList[time][target].append(source)\\n            \\n        sortedTimes = sorted(set([meeting[2] for meeting in meetings]))\\n        \\n        #DFS for each unique time\\n        for time in sortedTimes:\\n            \\n            #Start the DFS only with people who know\\n            stack = [person for person in peopleAtTimeStamp[time] if know[person]]\\n            while stack:\\n                curr = stack.pop()\\n                for nei in adjList[time][curr]:\\n                    if not know[nei]:\\n                        stack.append(nei)\\n                        know[nei] = True\\n                \\n        return [index for index, value in enumerate(know) if value]\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        #Base Cases\\n        know = [False for _ in range(n)]\\n        know[firstPerson] = True\\n        know[0] = True\\n        \\n        #Construct adjacency list per timestamp.\\n        peopleAtTimeStamp = defaultdict(set)\\n        adjList = defaultdict(lambda: defaultdict(list))\\n        \\n        for source, target, time in meetings:\\n            peopleAtTimeStamp[time].update({target, source})\\n            adjList[time][source].append(target)\\n            adjList[time][target].append(source)\\n            \\n        sortedTimes = sorted(set([meeting[2] for meeting in meetings]))\\n        \\n        #DFS for each unique time\\n        for time in sortedTimes:\\n            \\n            #Start the DFS only with people who know\\n            stack = [person for person in peopleAtTimeStamp[time] if know[person]]\\n            while stack:\\n                curr = stack.pop()\\n                for nei in adjList[time][curr]:\\n                    if not know[nei]:\\n                        stack.append(nei)\\n                        know[nei] = True\\n                \\n        return [index for index, value in enumerate(know) if value]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2026617,
                "title": "bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n        Qustion:\\n        1. There are N people\\n        2. Person 0 has a secret\\n        3. He shares it with firstPerson at time 0\\n        4. There are M meetings [x, y, T], x and y at time T\\n        5. Meeting secret are shared instantly, meaning a person can receieve and share the secrate at the same time\\n        6. Share the the list of people who knows the secret after all the meeting.\\n        \\n        Approach:\\n        1. We can sort the meetings according to time.\\n        2. We can keep a meetingByTime of secret knowers and add to the set if new secret is passed to new persons.        \\n    */\\n    #define inf 0x3f3f3f3f\\n    struct graph {\\n        int y, t;\\n        graph () {}\\n        graph (int _y, int _t) {\\n            y = _y, t = _t;\\n        }\\n        \\n        bool operator <(const graph &cmp) const {\\n            return t > cmp.t;\\n        }\\n    };\\n    \\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        vector <bool> vis(n, 0);\\n        vector <vector<graph>> G(n);\\n        for (vector <int> &cur: meetings) {\\n            int x = cur[0];\\n            int y = cur[1];\\n            int t = cur[2];\\n            G[x].push_back(graph(y, t));\\n            G[y].push_back(graph(x, t));\\n        }\\n        \\n        for (int i = 0; i < n; i++) sort(G[i].begin(), G[i].end(), [&](graph &x, graph &y) -> bool {\\n            return x.t > y.t;\\n        });\\n        \\n        // for (int i = 0; i < n; i++) {\\n        //     for (graph y: G[i]) {\\n        //         cout << y.t << \\' \\';\\n        //     } cout << \"\\\\n\";\\n        // }\\n                \\n        vector <int> result;\\n        priority_queue <graph> Q;\\n        Q.push(graph(0, 0));\\n        Q.push(graph(firstPerson, 0));\\n        \\n        while(!Q.empty()) {\\n            graph cur = Q.top(); Q.pop();\\n            int x = cur.y;\\n            int t = cur.t;\\n            \\n            if(vis[x]) continue;\\n            \\n            vis[x] = true;\\n            for (int i = 0; i < G[x].size(); i++) {\\n                graph &nxt = G[x][i];\\n                if (vis[nxt.y]) continue;\\n                if (t > nxt.t) break;\\n                \\n                Q.push(graph(nxt.y, nxt.t));\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++) if (vis[i]) result.push_back(i);\\n\\n        return result;\\n    }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n        Qustion:\\n        1. There are N people\\n        2. Person 0 has a secret\\n        3. He shares it with firstPerson at time 0\\n        4. There are M meetings [x, y, T], x and y at time T\\n        5. Meeting secret are shared instantly, meaning a person can receieve and share the secrate at the same time\\n        6. Share the the list of people who knows the secret after all the meeting.\\n        \\n        Approach:\\n        1. We can sort the meetings according to time.\\n        2. We can keep a meetingByTime of secret knowers and add to the set if new secret is passed to new persons.        \\n    */\\n    #define inf 0x3f3f3f3f\\n    struct graph {\\n        int y, t;\\n        graph () {}\\n        graph (int _y, int _t) {\\n            y = _y, t = _t;\\n        }\\n        \\n        bool operator <(const graph &cmp) const {\\n            return t > cmp.t;\\n        }\\n    };\\n    \\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        vector <bool> vis(n, 0);\\n        vector <vector<graph>> G(n);\\n        for (vector <int> &cur: meetings) {\\n            int x = cur[0];\\n            int y = cur[1];\\n            int t = cur[2];\\n            G[x].push_back(graph(y, t));\\n            G[y].push_back(graph(x, t));\\n        }\\n        \\n        for (int i = 0; i < n; i++) sort(G[i].begin(), G[i].end(), [&](graph &x, graph &y) -> bool {\\n            return x.t > y.t;\\n        });\\n        \\n        // for (int i = 0; i < n; i++) {\\n        //     for (graph y: G[i]) {\\n        //         cout << y.t << \\' \\';\\n        //     } cout << \"\\\\n\";\\n        // }\\n                \\n        vector <int> result;\\n        priority_queue <graph> Q;\\n        Q.push(graph(0, 0));\\n        Q.push(graph(firstPerson, 0));\\n        \\n        while(!Q.empty()) {\\n            graph cur = Q.top(); Q.pop();\\n            int x = cur.y;\\n            int t = cur.t;\\n            \\n            if(vis[x]) continue;\\n            \\n            vis[x] = true;\\n            for (int i = 0; i < G[x].size(); i++) {\\n                graph &nxt = G[x][i];\\n                if (vis[nxt.y]) continue;\\n                if (t > nxt.t) break;\\n                \\n                Q.push(graph(nxt.y, nxt.t));\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++) if (vis[i]) result.push_back(i);\\n\\n        return result;\\n    }\\n\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2015745,
                "title": "easy-bfs-java-solution-with-description",
                "content": "Here we are given 3 set of information person1 with person2 link and its timing for meeting\\nNow we can assume it as graph with persons as nodes and rest array elements as edge, but here edges are not single node, but its special kind of node which holds two information 1st one contain the second person as node and second one contain the timing of two nodes meeting, so here the question is to print all such nodes which are linked to each other and also timing of their meeting is equal to or greater than the firstNode meeting, so in order to have timing in order we need priority queue , which will contain the node information in sorted order ,and then we will pick each node one by one after we pick firstpersion node and we will have visited set which will hold the nodes value when visited, then after we will return the visited set as answer\\n\\'\\'\\'\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        Map<Integer,List<int[]>> graph = new HashMap<>();\\n        for(int[] m : meetings){\\n            graph.computeIfAbsent(m[0],k->new ArrayList<int[]>()).add(new int[]{m[1],m[2]});\\n            graph.computeIfAbsent(m[1],k->new ArrayList<int[]>()).add(new int[]{m[0],m[2]});\\n        }\\n        \\n        HashSet<Integer> visited = new HashSet<>();\\n        PriorityQueue<int[]> queue = new PriorityQueue<>((a,b)->a[1]-b[1]);\\n        queue.add(new int[]{0,0});\\n        queue.add(new int[]{firstPerson,0});\\n     \\n        while(!queue.isEmpty()){\\n            int[] arr = queue.poll();\\n            int time = arr[1];\\n            if(visited.contains(arr[0])) continue;\\n            visited.add(arr[0]);\\n            if(graph.containsKey(arr[0])){\\n                for(int[] child : graph.get(arr[0])){\\n                    if(child[1]>=time){\\n                        queue.add(child);\\n                    }\\n\\n                }\\n            }\\n        }\\n        return new ArrayList<>(visited);\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        Map<Integer,List<int[]>> graph = new HashMap<>();\\n        for(int[] m : meetings){\\n            graph.computeIfAbsent(m[0],k->new ArrayList<int[]>()).add(new int[]{m[1],m[2]}",
                "codeTag": "Java"
            },
            {
                "id": 1776480,
                "title": "c-simple-dijkstra-w-exlanation",
                "content": "The question says find the people who knows the secret after all meetings are completed. Then there is a problem of not knowing when a particular person will know a secret. By some path a person might get know it at ```T=5```, so he broadcasts it in all meetings after ```T=5``` and skips all meetings before this point. But, what if through some other path he gets to know it at ```T=3```. The meetings we skipped earlier because we thought he didn\\'t know the secret at ```T=3``` becomes relevant now. \\n\\nSo, now I\\'ll find the solution to another question. What is the earliest time a person gets to know the secret? Because once we know the earliet time a person gets to know the secret, then we have to look only at the meetings after this. The answer to this question is Shortest Path Algorithms with path length being time when a person gets to know the secret. Once we calculate this, then every node which has a distance less than infinity has been traversed by the secret. \\n\\n```\\nstruct compare\\n{\\n\\tbool operator()(pair<int,int>& u,pair<int,int>& v)\\n\\t{\\n\\t\\treturn u.second>v.second;\\n\\t}\\n};\\nvector<int> dijkstra(int n,vector<vector<pair<int,int>>>& adj,int s)\\n{\\n\\tvector<int> d(n,INT_MAX);\\n\\tpriority_queue<pair<int,int>,vector<pair<int,int>>,compare> q;\\n\\tq.push(make_pair(s,0));\\n\\tif(s)\\n\\t\\tq.push(make_pair(0,0));\\n\\twhile(!q.empty())\\n\\t{\\n\\t\\tauto [u,time]=q.top();\\n\\t\\tq.pop();\\n\\t\\tif(d[u]<time)\\n\\t\\t\\tcontinue;\\n\\t\\td[u]=time;\\n\\t\\tfor(auto [v,newTime]:adj[u])\\n\\t\\t\\tif(d[v]>newTime&&newTime>=d[u])\\n\\t\\t\\t\\tq.push(make_pair(v,newTime));\\n\\t}\\n\\treturn d;\\n}\\nvector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) \\n{\\n\\tvector<vector<pair<int,int>>> adj(n); \\n\\tfor(auto& x:meetings)\\n\\t{\\n\\t\\tadj[x[0]].push_back(make_pair(x[1],x[2]));\\n\\t\\tadj[x[1]].push_back(make_pair(x[0],x[2]));\\n\\t}\\n\\tvector<int> temp=dijkstra(n,adj,firstPerson);\\n\\tvector<int> ret;\\n\\tfor(int i=0;i<temp.size();++i)\\n\\t\\tif(temp[i]<INT_MAX)\\n\\t\\t\\tret.push_back(i);\\n\\treturn ret;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```T=5```\n```T=5```\n```T=3```\n```T=3```\n```\\nstruct compare\\n{\\n\\tbool operator()(pair<int,int>& u,pair<int,int>& v)\\n\\t{\\n\\t\\treturn u.second>v.second;\\n\\t}\\n};\\nvector<int> dijkstra(int n,vector<vector<pair<int,int>>>& adj,int s)\\n{\\n\\tvector<int> d(n,INT_MAX);\\n\\tpriority_queue<pair<int,int>,vector<pair<int,int>>,compare> q;\\n\\tq.push(make_pair(s,0));\\n\\tif(s)\\n\\t\\tq.push(make_pair(0,0));\\n\\twhile(!q.empty())\\n\\t{\\n\\t\\tauto [u,time]=q.top();\\n\\t\\tq.pop();\\n\\t\\tif(d[u]<time)\\n\\t\\t\\tcontinue;\\n\\t\\td[u]=time;\\n\\t\\tfor(auto [v,newTime]:adj[u])\\n\\t\\t\\tif(d[v]>newTime&&newTime>=d[u])\\n\\t\\t\\t\\tq.push(make_pair(v,newTime));\\n\\t}\\n\\treturn d;\\n}\\nvector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) \\n{\\n\\tvector<vector<pair<int,int>>> adj(n); \\n\\tfor(auto& x:meetings)\\n\\t{\\n\\t\\tadj[x[0]].push_back(make_pair(x[1],x[2]));\\n\\t\\tadj[x[1]].push_back(make_pair(x[0],x[2]));\\n\\t}\\n\\tvector<int> temp=dijkstra(n,adj,firstPerson);\\n\\tvector<int> ret;\\n\\tfor(int i=0;i<temp.size();++i)\\n\\t\\tif(temp[i]<INT_MAX)\\n\\t\\t\\tret.push_back(i);\\n\\treturn ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1757281,
                "title": "java-union-find-with-explanation",
                "content": "```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        // 1. build treeMap for time vs meeting, so it\\'s ordered by the time\\n        TreeMap<Integer, List<int[]>> timeMeeting = buildTimeMeeting(meetings);\\n        UnionFind uf = new UnionFind(n);\\n        uf.union(0, firstPerson);\\n        Set<Integer> res = new HashSet<>();\\n        res.add(0);\\n        res.add(firstPerson);\\n        \\n        for (int time: timeMeeting.keySet()) {\\n            // 2. for the meeting at the same time, union the person in each meeting\\n            for (int[] m : timeMeeting.get(time)) {\\n                uf.union(m[0], m[1]);\\n            } \\n            // 3. for the person who attended meeting at the same time, \\n            // if one of the person in the meeting has the same father as person 0, add those two person into result\\n            // if not, remove their union, because their union at this time, will not contribute to the results if one of them know the secret after this meeting\\n            for (int[] m : timeMeeting.get(time)) {\\n               if (uf.find(m[0]) == uf.find(0) || uf.find(m[1]) == uf.find(0)) {\\n                    res.add(m[0]);\\n                    res.add(m[1]);\\n                    \\n               } else {\\n                    uf.reset(m[0]);\\n                    uf.reset(m[1]);\\n               }\\n            }\\n        }\\n        return new ArrayList<>(res);    \\n    }\\n    private TreeMap<Integer, List<int[]>> buildTimeMeeting(int[][] meetings) {\\n        TreeMap<Integer, List<int[]>> timeMeeting = new TreeMap<>();\\n        for (int[] m : meetings) {\\n            timeMeeting.putIfAbsent(m[2], new ArrayList<>());\\n            timeMeeting.get(m[2]).add(m); \\n        }\\n        return timeMeeting;\\n    }\\n    public class UnionFind {\\n        private int[] father;\\n        UnionFind(int n) {\\n            father = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                father[i] = i;\\n            }\\n        }\\n        private int find(int i) {\\n            if (father[i] != i) {\\n                father[i] = find(father[i]);\\n            }\\n            return father[i];\\n        }\\n        private void union(int i, int j) {\\n            int fatherI = find(i);\\n            int fatherJ = find(j);\\n            if (fatherI != fatherJ) {\\n                father[fatherI] = fatherJ;\\n            }\\n        }\\n        private void reset(int i) {\\n            father[i] = i;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        // 1. build treeMap for time vs meeting, so it\\'s ordered by the time\\n        TreeMap<Integer, List<int[]>> timeMeeting = buildTimeMeeting(meetings);\\n        UnionFind uf = new UnionFind(n);\\n        uf.union(0, firstPerson);\\n        Set<Integer> res = new HashSet<>();\\n        res.add(0);\\n        res.add(firstPerson);\\n        \\n        for (int time: timeMeeting.keySet()) {\\n            // 2. for the meeting at the same time, union the person in each meeting\\n            for (int[] m : timeMeeting.get(time)) {\\n                uf.union(m[0], m[1]);\\n            } \\n            // 3. for the person who attended meeting at the same time, \\n            // if one of the person in the meeting has the same father as person 0, add those two person into result\\n            // if not, remove their union, because their union at this time, will not contribute to the results if one of them know the secret after this meeting\\n            for (int[] m : timeMeeting.get(time)) {\\n               if (uf.find(m[0]) == uf.find(0) || uf.find(m[1]) == uf.find(0)) {\\n                    res.add(m[0]);\\n                    res.add(m[1]);\\n                    \\n               } else {\\n                    uf.reset(m[0]);\\n                    uf.reset(m[1]);\\n               }\\n            }\\n        }\\n        return new ArrayList<>(res);    \\n    }\\n    private TreeMap<Integer, List<int[]>> buildTimeMeeting(int[][] meetings) {\\n        TreeMap<Integer, List<int[]>> timeMeeting = new TreeMap<>();\\n        for (int[] m : meetings) {\\n            timeMeeting.putIfAbsent(m[2], new ArrayList<>());\\n            timeMeeting.get(m[2]).add(m); \\n        }\\n        return timeMeeting;\\n    }\\n    public class UnionFind {\\n        private int[] father;\\n        UnionFind(int n) {\\n            father = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                father[i] = i;\\n            }\\n        }\\n        private int find(int i) {\\n            if (father[i] != i) {\\n                father[i] = find(father[i]);\\n            }\\n            return father[i];\\n        }\\n        private void union(int i, int j) {\\n            int fatherI = find(i);\\n            int fatherJ = find(j);\\n            if (fatherI != fatherJ) {\\n                father[fatherI] = fatherJ;\\n            }\\n        }\\n        private void reset(int i) {\\n            father[i] = i;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1751045,
                "title": "clean-java-bfs-and-note-how-to-determine-if-it-s-visited",
                "content": "There\\'s tricky point that when shall we add the person to visited and when shall we continue if it contains\\nNote that there could be the cases that same person with different timestamps. So you shouldn\\'t do visited.add() inside the for loop when exploring the next person, because you may miss the person with an earlier time. For example, person 1 with time 10 and person 1 with time 3\\n```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        Map<Integer, List<int[]>> map = new HashMap<>();\\n        for (int[] meeting : meetings) {\\n            if (!map.containsKey(meeting[0])) map.put(meeting[0], new ArrayList<>());\\n            if (!map.containsKey(meeting[1])) map.put(meeting[1], new ArrayList<>());\\n            map.get(meeting[0]).add(new int[] {meeting[1], meeting[2]});\\n            map.get(meeting[1]).add(new int[] {meeting[0], meeting[2]});\\n        }\\n        Set<Integer> visited = new HashSet<>();\\n        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> a[1] - b[1]); //person, time when know\\n        queue.offer(new int[] {0, 0});\\n        queue.offer(new int[] {firstPerson, 0});\\n        while (!queue.isEmpty()) {\\n            int[] p = queue.poll();\\n            visited.add(p[0]); //note add here instead of inside the for loop, because if we add the next node with late time the same person with earlier time can\\'t be added\\n            if (!map.containsKey(p[0])) continue;\\n            for (int[] m : map.get(p[0])) {\\n                if (m[1] < p[1] || visited.contains(m[0])) continue;\\n                queue.offer(new int[]{m[0], m[1]});\\n            }\\n            map.remove(p[0]); //in case visit again\\n        }\\n        return new ArrayList<>(visited);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        Map<Integer, List<int[]>> map = new HashMap<>();\\n        for (int[] meeting : meetings) {\\n            if (!map.containsKey(meeting[0])) map.put(meeting[0], new ArrayList<>());\\n            if (!map.containsKey(meeting[1])) map.put(meeting[1], new ArrayList<>());\\n            map.get(meeting[0]).add(new int[] {meeting[1], meeting[2]}",
                "codeTag": "Java"
            },
            {
                "id": 1718344,
                "title": "a-graspable-bfs-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        Map<Integer, List<int[]>> graph = new HashMap<>();\\n        for(int[] meeting: meetings){\\n            int from = meeting[0];\\n            int to = meeting[1];\\n            int time = meeting[2];\\n            \\n            if(!graph.containsKey(from)){\\n                graph.put(from, new ArrayList<>());\\n            }\\n            \\n            graph.get(from).add(new int[] {to, time});\\n            \\n            if(!graph.containsKey(to)){\\n                graph.put(to, new ArrayList<>());\\n            }\\n            \\n            graph.get(to).add(new int[] {from, time});\\n        }\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (a[1] - b[1]));\\n        pq.offer(new int[] {0, 0});\\n        pq.offer(new int[] {firstPerson, 0});\\n        \\n        boolean[] visited = new boolean[n]; // to indicate that the secret is known\\n        \\n        while(!pq.isEmpty()){\\n            int[] curr = pq.poll();\\n            if(visited[curr[0]]){\\n                continue;\\n            }\\n            \\n            visited[curr[0]] = true;\\n            for(int[] neighbor: graph.getOrDefault(curr[0], new ArrayList<>())){\\n                if(!visited[neighbor[0]]){\\n\\n                    /*\\n\\t\\t\\t\\t\\t neighbor can know the secret iff he \\n                     is scheduled to meet curr at or after a time \\n\\t\\t\\t\\t\\t from when curr himself knows the secret \\n\\t\\t\\t\\t\\t*/\\n\\n                    if(neighbor[1] >= curr[1]){ \\n                        pq.offer(new int[] {neighbor[0], neighbor[1]});\\n                    } \\n                }\\n            }\\n        }\\n        \\n        List<Integer> res = new ArrayList<>();\\n        for(int i=0; i<visited.length; i++){\\n            if(visited[i]){\\n                res.add(i);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        Map<Integer, List<int[]>> graph = new HashMap<>();\\n        for(int[] meeting: meetings){\\n            int from = meeting[0];\\n            int to = meeting[1];\\n            int time = meeting[2];\\n            \\n            if(!graph.containsKey(from)){\\n                graph.put(from, new ArrayList<>());\\n            }\\n            \\n            graph.get(from).add(new int[] {to, time});\\n            \\n            if(!graph.containsKey(to)){\\n                graph.put(to, new ArrayList<>());\\n            }\\n            \\n            graph.get(to).add(new int[] {from, time});\\n        }\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (a[1] - b[1]));\\n        pq.offer(new int[] {0, 0});\\n        pq.offer(new int[] {firstPerson, 0});\\n        \\n        boolean[] visited = new boolean[n]; // to indicate that the secret is known\\n        \\n        while(!pq.isEmpty()){\\n            int[] curr = pq.poll();\\n            if(visited[curr[0]]){\\n                continue;\\n            }\\n            \\n            visited[curr[0]] = true;\\n            for(int[] neighbor: graph.getOrDefault(curr[0], new ArrayList<>())){\\n                if(!visited[neighbor[0]]){\\n\\n                    /*\\n\\t\\t\\t\\t\\t neighbor can know the secret iff he \\n                     is scheduled to meet curr at or after a time \\n\\t\\t\\t\\t\\t from when curr himself knows the secret \\n\\t\\t\\t\\t\\t*/\\n\\n                    if(neighbor[1] >= curr[1]){ \\n                        pq.offer(new int[] {neighbor[0], neighbor[1]});\\n                    } \\n                }\\n            }\\n        }\\n        \\n        List<Integer> res = new ArrayList<>();\\n        for(int i=0; i<visited.length; i++){\\n            if(visited[i]){\\n                res.add(i);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1684584,
                "title": "union-find-based-solution",
                "content": "Posting solution with comments. I hope it helps you all. \\n\\n```\\n\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        Set<Integer> answerSet = new HashSet<>();\\n\\n        // Data Structure to group all meetings at the same time. Keeps time sorted in increasing order.\\n        Map<Integer, List<int[]>> map = new TreeMap<>();\\n        \\n        for (var meeting : meetings) {\\n            List<int[]> list = map.getOrDefault(meeting[2], new ArrayList<>());\\n            list.add(meeting);\\n            map.put(meeting[2], list);\\n        }\\n        \\n        // Final Nodes.\\n        answerSet.add(0);\\n        answerSet.add(firstPerson);\\n        \\n        // This maintains sets that are connected. Essentially keeps nodes which know secret in one parent.\\n        // At the time, nodes that are deemed to not know secret are reset and kept not connected to any other node. This helps to ensure that any node that gets to know the node in future should not mark nodes it has met before as knowing secret. \\n        UnionFind unionFind = new UnionFind(n);\\n        unionFind.union(0, firstPerson);\\n        \\n        for (var entry : map.entrySet()) {\\n            \\n            List<int[]> list = entry.getValue();\\n            \\n            Set<Integer> temp = new HashSet<>();\\n            Set<Integer> temp2 = new HashSet<>();\\n            \\n            for (int[] meeting : list) {\\n                \\n                unionFind.union(meeting[0], meeting[1]);\\n                \\n                temp2.add(meeting[0]);\\n                temp2.add(meeting[1]);\\n            }\\n            \\n            int parent = unionFind.find(0);\\n            \\n            \\n            for (var node : temp2) {\\n                if (parent == (unionFind.find(node))) {\\n                    answerSet.add(node);\\n                } else {\\n//                    This helps to ensure that any node that gets to know the node in future should not mark nodes it has met before as knowing secret.\\n                    unionFind.parent[node] = node;\\n                }\\n            }\\n        }\\n        \\n        return new ArrayList<>(answerSet);\\n    }\\n    \\n    class UnionFind {\\n        int[] parent;\\n        int[] size;\\n        UnionFind(int n) {\\n            parent = new int[n];\\n            size = new int[n];\\n            for (int i = 0; i < n; ++i) {\\n                parent[i] = i;\\n                size[i] = 0;\\n            }\\n        }\\n        \\n        int find(int u) {\\n            if (parent[u] == u) {\\n                return u;\\n            }\\n            \\n            return find(parent[u]);\\n        }\\n        \\n        void union(int u, int v) {\\n            int p_u = find(u);\\n            int p_v = find(v);\\n            \\n            if (p_u != p_v) {\\n                if (size[p_u] < size[p_v]) {\\n                    parent[p_u] = p_v;\\n                    size[p_v] += size[p_u];\\n                } else {\\n                    parent[p_v] = parent[p_u];\\n                    size[p_u] += size[p_v];\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        Set<Integer> answerSet = new HashSet<>();\\n\\n        // Data Structure to group all meetings at the same time. Keeps time sorted in increasing order.\\n        Map<Integer, List<int[]>> map = new TreeMap<>();\\n        \\n        for (var meeting : meetings) {\\n            List<int[]> list = map.getOrDefault(meeting[2], new ArrayList<>());\\n            list.add(meeting);\\n            map.put(meeting[2], list);\\n        }\\n        \\n        // Final Nodes.\\n        answerSet.add(0);\\n        answerSet.add(firstPerson);\\n        \\n        // This maintains sets that are connected. Essentially keeps nodes which know secret in one parent.\\n        // At the time, nodes that are deemed to not know secret are reset and kept not connected to any other node. This helps to ensure that any node that gets to know the node in future should not mark nodes it has met before as knowing secret. \\n        UnionFind unionFind = new UnionFind(n);\\n        unionFind.union(0, firstPerson);\\n        \\n        for (var entry : map.entrySet()) {\\n            \\n            List<int[]> list = entry.getValue();\\n            \\n            Set<Integer> temp = new HashSet<>();\\n            Set<Integer> temp2 = new HashSet<>();\\n            \\n            for (int[] meeting : list) {\\n                \\n                unionFind.union(meeting[0], meeting[1]);\\n                \\n                temp2.add(meeting[0]);\\n                temp2.add(meeting[1]);\\n            }\\n            \\n            int parent = unionFind.find(0);\\n            \\n            \\n            for (var node : temp2) {\\n                if (parent == (unionFind.find(node))) {\\n                    answerSet.add(node);\\n                } else {\\n//                    This helps to ensure that any node that gets to know the node in future should not mark nodes it has met before as knowing secret.\\n                    unionFind.parent[node] = node;\\n                }\\n            }\\n        }\\n        \\n        return new ArrayList<>(answerSet);\\n    }\\n    \\n    class UnionFind {\\n        int[] parent;\\n        int[] size;\\n        UnionFind(int n) {\\n            parent = new int[n];\\n            size = new int[n];\\n            for (int i = 0; i < n; ++i) {\\n                parent[i] = i;\\n                size[i] = 0;\\n            }\\n        }\\n        \\n        int find(int u) {\\n            if (parent[u] == u) {\\n                return u;\\n            }\\n            \\n            return find(parent[u]);\\n        }\\n        \\n        void union(int u, int v) {\\n            int p_u = find(u);\\n            int p_v = find(v);\\n            \\n            if (p_u != p_v) {\\n                if (size[p_u] < size[p_v]) {\\n                    parent[p_u] = p_v;\\n                    size[p_v] += size[p_u];\\n                } else {\\n                    parent[p_v] = parent[p_u];\\n                    size[p_u] += size[p_v];\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1627782,
                "title": "python-heap-t-o-nlogn-detailed-explanation-example-walk-through",
                "content": "1. All the listeners from one teller is represented as neighbors in the graph.\\nFor example 6  [[1,2,5],[2,3,8],[1,5,10]]  1\\ngraph[1] is [(5, 2), (10, 5)]\\nThat means person 1 tells person 5 at time 2, person 1 tells person 10 at time 5.\\n\\n2. Why do I use heap? Why don\\'t I use normal queue?\\nI first tried using normal queue but I have to sort q by timestamp for each iteration in the while loop, that is because when adding listeners from the graph, the timepoint is not in order. I will put the queue method as method 3 for reference. \\n\\n3. I used knowing_time and listening_time since they are easier to understand. News will only get passed if the knowing time is before the listening time. \\n\\n4. heappush(q,(time,teller)) because heap is a priority queue on the first element. That means, heap sort things ascendingly starting from minimum. (you can append negative value to make it into max heap)\\n\\n5.  if teller in res: continue; that is because if we\\'ve seen the teller, we\\'ve added all the neighbors of graph[teller] to the queue already. So we use continue to skip the rest of code and go to next queue pop\\n\\n6. I think this question did not express that part clearly, I deduced it from this example. \\n[0,1,4,5] is expected from  11  [[5,1,4],[0,4,18]]  1\\nThis means for each [k,v,t], if k does not know the news, v knows the news, v can tell k the news as well. So all the \"teller\", \"listener\" in my code can be interpreted interchangeably. \\n\\n        #T(n)=O(nlogn)\\n\\t\\t#S(n)=O(V+E+n)=O(n) because we have n nodes in graph, and big O ignore constant -> O(3n)=O(n) \\n\\t\\tgraph = defaultdict(list)\\n\\t\\t#this graph keeps track all the people the teller tells\\n\\t\\t#k,v are two people. timestamp is their meeting time\\n        for k,v,timestamp in meetings:\\n            graph[k].append((v,timestamp))\\n            graph[v].append((k,timestamp))\\n\\t\\t#use set because it handles duplicates well \\n        notified=set()\\n        q = []\\n        heapify(q)\\n\\t\\t#add person 0 and first person to q\\n        heappush(q,(0,0))\\n        heappush(q,(0,firstPerson))\\n        while q:\\n            knowing_time,teller = heappop(q)\\n            if teller in notified:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tnotified.add(teller)\\n\\t\\t\\t#look at everybody that the teller tells\\n\\t\\t\\tfor listener,listening_time in graph[teller]:\\n\\t\\t\\t\\t#if listening time is before they meet, the teller has nothing to tell\\n\\t\\t\\t\\tif listening_time>=knowing_time:\\n\\t\\t\\t\\t\\theappush(q,(listening_time,listener))\\n        return list(notified)\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n**BFS Method **\\nbfs method: cannot handle instantaneous meetings well\\npython bfs O(nlogn) passes all basic test cases; fail at n=7336\\nMy second method pass all test cases except this one, I suspect that it fails because it cannot handle instantaneous meetings well. \\n\\n![image](https://assets.leetcode.com/users/images/74edeb24-ea36-4d30-ba5f-180545527fb0_1639433367.7328198.png)\\n\\nNote:\\nI was not sure why [0,1,4,5] is expected from\\n11\\n[[5,1,4],[0,4,18]]\\n1\\nBut since this is the case, I deduced that it means for each [k,v,t], if k does not know the news, v knows the news, v can tell k the news as well. \\n\\n1.first sort the meetings by timepoint\\n2.I need to find the first eligible element to put in my queue, so I loop through the meetings. I set a stop variable so as soon as it finds a eligible first element, the loop will stop. Worst case senario is that the eligible first element is the last one in meetings, that means loop through everything in meetings -> O(n)\\n3.I store the two people (k,v) and the time they met (timestamp). If one of k,v knows the news, that person can tell the one that does not know the news.\\n4.I used a keep variable that controls my while loop. If we found an eligible next element (ie. timestamp) we stop the while loop by setting keep to False\\n\\n        \\n\\t\\t\\n\\t\\tmeetings.sort(key=lambda x:x[2])\\n        q=deque()\\n        res={0,firstPerson}\\n        stop=False\\n        \\n        for i in meetings:\\n            if 0 in (i[0],i[1]) or firstPerson in (i[0],i[1]):\\n                q.append(i)\\n                stop=True\\n            if stop==True:break\\n        while q:\\n            k,v,timestamp=q.popleft()\\n            if k in res and v not in res:\\n                res.add(v)\\n            if v in res and k not in res:\\n                res.add(k)\\n            keep=True\\n            while meetings and keep:\\n                cur=meetings.pop(0) # takes care of the timestamp\\n                if cur[2]>=timestamp:\\n                    q.append(cur)\\n                    keep=False\\n        return list(res)\\n\\n\\t\\t\\n\\t\\t\\nMethod 3:\\nUsing queue: Time Limit Exceed\\n\\n\\t\\t        meetings.sort(key=lambda x:x[2])\\n        graph = defaultdict(list)\\n        for k,v,timestamp in meetings:\\n            graph[k].append((timestamp,v))\\n            graph[v].append((timestamp,k))\\n        res=set()\\n        q = []\\n        q.append((0,0))\\n        q.append((0,firstPerson))\\n        while q:\\n\\t\\t\\t#sort because when we add from neighbors of tellers in the graph, the timestamp got mixed up.\\n            q=sorted(q,key=lambda x:x[0])\\n            meeting_time,teller = q.pop(0)\\n            if teller not in res:\\n                res.add(teller)\\n                for listening_time,listener in graph[teller]:\\n                    if listening_time>=meeting_time:\\n                        q.append((listening_time,listener))\\n        return list(res)\\n\\t\\t\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "1. All the listeners from one teller is represented as neighbors in the graph.\\nFor example 6  [[1,2,5],[2,3,8],[1,5,10]]  1\\ngraph[1] is [(5, 2), (10, 5)]\\nThat means person 1 tells person 5 at time 2, person 1 tells person 10 at time 5.\\n\\n2. Why do I use heap? Why don\\'t I use normal queue?\\nI first tried using normal queue but I have to sort q by timestamp for each iteration in the while loop, that is because when adding listeners from the graph, the timepoint is not in order. I will put the queue method as method 3 for reference. \\n\\n3. I used knowing_time and listening_time since they are easier to understand. News will only get passed if the knowing time is before the listening time. \\n\\n4. heappush(q,(time,teller)) because heap is a priority queue on the first element. That means, heap sort things ascendingly starting from minimum. (you can append negative value to make it into max heap)\\n\\n5.  if teller in res: continue; that is because if we\\'ve seen the teller, we\\'ve added all the neighbors of graph[teller] to the queue already. So we use continue to skip the rest of code and go to next queue pop\\n\\n6. I think this question did not express that part clearly, I deduced it from this example. \\n[0,1,4,5] is expected from  11  [[5,1,4],[0,4,18]]  1\\nThis means for each [k,v,t], if k does not know the news, v knows the news, v can tell k the news as well. So all the \"teller\", \"listener\" in my code can be interpreted interchangeably. \\n\\n        #T(n)=O(nlogn)\\n\\t\\t#S(n)=O(V+E+n)=O(n) because we have n nodes in graph, and big O ignore constant -> O(3n)=O(n) \\n\\t\\tgraph = defaultdict(list)\\n\\t\\t#this graph keeps track all the people the teller tells\\n\\t\\t#k,v are two people. timestamp is their meeting time\\n        for k,v,timestamp in meetings:\\n            graph[k].append((v,timestamp))\\n            graph[v].append((k,timestamp))\\n\\t\\t#use set because it handles duplicates well \\n        notified=set()\\n        q = []\\n        heapify(q)\\n\\t\\t#add person 0 and first person to q\\n        heappush(q,(0,0))\\n        heappush(q,(0,firstPerson))\\n        while q:\\n            knowing_time,teller = heappop(q)\\n            if teller in notified:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tnotified.add(teller)\\n\\t\\t\\t#look at everybody that the teller tells\\n\\t\\t\\tfor listener,listening_time in graph[teller]:\\n\\t\\t\\t\\t#if listening time is before they meet, the teller has nothing to tell\\n\\t\\t\\t\\tif listening_time>=knowing_time:\\n\\t\\t\\t\\t\\theappush(q,(listening_time,listener))\\n        return list(notified)\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n**BFS Method **\\nbfs method: cannot handle instantaneous meetings well\\npython bfs O(nlogn) passes all basic test cases; fail at n=7336\\nMy second method pass all test cases except this one, I suspect that it fails because it cannot handle instantaneous meetings well. \\n\\n![image](https://assets.leetcode.com/users/images/74edeb24-ea36-4d30-ba5f-180545527fb0_1639433367.7328198.png)\\n\\nNote:\\nI was not sure why [0,1,4,5] is expected from\\n11\\n[[5,1,4],[0,4,18]]\\n1\\nBut since this is the case, I deduced that it means for each [k,v,t], if k does not know the news, v knows the news, v can tell k the news as well. \\n\\n1.first sort the meetings by timepoint\\n2.I need to find the first eligible element to put in my queue, so I loop through the meetings. I set a stop variable so as soon as it finds a eligible first element, the loop will stop. Worst case senario is that the eligible first element is the last one in meetings, that means loop through everything in meetings -> O(n)\\n3.I store the two people (k,v) and the time they met (timestamp). If one of k,v knows the news, that person can tell the one that does not know the news.\\n4.I used a keep variable that controls my while loop. If we found an eligible next element (ie. timestamp) we stop the while loop by setting keep to False\\n\\n        \\n\\t\\t\\n\\t\\tmeetings.sort(key=lambda x:x[2])\\n        q=deque()\\n        res={0,firstPerson}\\n        stop=False\\n        \\n        for i in meetings:\\n            if 0 in (i[0],i[1]) or firstPerson in (i[0],i[1]):\\n                q.append(i)\\n                stop=True\\n            if stop==True:break\\n        while q:\\n            k,v,timestamp=q.popleft()\\n            if k in res and v not in res:\\n                res.add(v)\\n            if v in res and k not in res:\\n                res.add(k)\\n            keep=True\\n            while meetings and keep:\\n                cur=meetings.pop(0) # takes care of the timestamp\\n                if cur[2]>=timestamp:\\n                    q.append(cur)\\n                    keep=False\\n        return list(res)\\n\\n\\t\\t\\n\\t\\t\\nMethod 3:\\nUsing queue: Time Limit Exceed\\n\\n\\t\\t        meetings.sort(key=lambda x:x[2])\\n        graph = defaultdict(list)\\n        for k,v,timestamp in meetings:\\n            graph[k].append((timestamp,v))\\n            graph[v].append((timestamp,k))\\n        res=set()\\n        q = []\\n        q.append((0,0))\\n        q.append((0,firstPerson))\\n        while q:\\n\\t\\t\\t#sort because when we add from neighbors of tellers in the graph, the timestamp got mixed up.\\n            q=sorted(q,key=lambda x:x[0])\\n            meeting_time,teller = q.pop(0)\\n            if teller not in res:\\n                res.add(teller)\\n                for listening_time,listener in graph[teller]:\\n                    if listening_time>=meeting_time:\\n                        q.append((listening_time,listener))\\n        return list(res)\\n\\t\\t\\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1614301,
                "title": "union-find-swift",
                "content": "```\\nclass Solution {\\n    var par: [Int] = []\\n    \\n    func findAllPeople(_ n: Int, _ m: [[Int]], _ firstPerson: Int) -> [Int] {\\n        par = Array(repeating: 0, count: n)\\n        for i in 0..<n {\\n            par[i] = i\\n        }\\n        let meetings = m.sorted() {\\n            $0[2] < $1[2]\\n        }\\n        union(x: 0, y: firstPerson)\\n        var time = 0\\n        var persons = [Int]()\\n        for meeting in meetings {\\n            if time != meeting[2] {\\n                clear(persons: persons)\\n                persons.removeAll()\\n                time = meeting[2]\\n            }\\n            union(x: meeting[0], y: meeting[1])\\n            persons.append(meeting[0])\\n            persons.append(meeting[1])\\n        }\\n        var res = [Int]()\\n        for i in 0..<n {\\n            if getParent(x: i) == 0 {\\n                res.append(i)\\n            }\\n        }\\n        return res\\n    }\\n    \\n    func clear(persons: [Int]) {\\n        for person in persons {\\n            if getParent(x: person) != 0 {\\n                par[person] = person\\n            }\\n        }\\n    }\\n    \\n    func union(x: Int, y: Int) {\\n        let parX = getParent(x: x)\\n        let parY = getParent(x: y)\\n        if parX != parY {\\n            if parX == 0 {\\n                par[parY] = parX\\n            } else {\\n                par[parX] = parY\\n            }\\n        }\\n    }\\n    \\n    func getParent(x: Int) -> Int {\\n        if par[x] != x {\\n            par[x] = getParent(x: par[x])\\n        }\\n        return par[x]\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    var par: [Int] = []\\n    \\n    func findAllPeople(_ n: Int, _ m: [[Int]], _ firstPerson: Int) -> [Int] {\\n        par = Array(repeating: 0, count: n)\\n        for i in 0..<n {\\n            par[i] = i\\n        }\\n        let meetings = m.sorted() {\\n            $0[2] < $1[2]\\n        }\\n        union(x: 0, y: firstPerson)\\n        var time = 0\\n        var persons = [Int]()\\n        for meeting in meetings {\\n            if time != meeting[2] {\\n                clear(persons: persons)\\n                persons.removeAll()\\n                time = meeting[2]\\n            }\\n            union(x: meeting[0], y: meeting[1])\\n            persons.append(meeting[0])\\n            persons.append(meeting[1])\\n        }\\n        var res = [Int]()\\n        for i in 0..<n {\\n            if getParent(x: i) == 0 {\\n                res.append(i)\\n            }\\n        }\\n        return res\\n    }\\n    \\n    func clear(persons: [Int]) {\\n        for person in persons {\\n            if getParent(x: person) != 0 {\\n                par[person] = person\\n            }\\n        }\\n    }\\n    \\n    func union(x: Int, y: Int) {\\n        let parX = getParent(x: x)\\n        let parY = getParent(x: y)\\n        if parX != parY {\\n            if parX == 0 {\\n                par[parY] = parX\\n            } else {\\n                par[parX] = parY\\n            }\\n        }\\n    }\\n    \\n    func getParent(x: Int) -> Int {\\n        if par[x] != x {\\n            par[x] = getParent(x: par[x])\\n        }\\n        return par[x]\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1608099,
                "title": "c-solution-passing-42-testcases-please-tell-what-s-wrong",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    static bool compare(vector<int> &a,vector<int> &b){\\n        return a[2]<b[2];\\n    }\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        sort(meetings.begin(),meetings.end(),(compare));\\n        vector<int> v;\\n        unordered_map<int,int> mp;\\n        mp[0] = 1;\\n        mp[firstPerson] = 1;\\n        for(int i=0; i<meetings.size(); i++){\\n            if(mp[meetings[i][0]] == 1 || mp[meetings[i][1]] == 1){\\n                mp[meetings[i][0]] = 1;\\n                mp[meetings[i][1]] = 1;\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            if(mp[i] == 1){\\n                v.push_back(i);\\n            }\\n        }\\n        return v;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1601051,
                "title": "python-by-bfs-set-w-hint",
                "content": "**Hint**:\\n\\nThink of **BFS**, **graph**, and **set**.\\n\\n---\\n\\n**Abstract trasfrom model**:\\n\\n**Person** <-> **Nodes**\\n\\nperson_a talk to person_b **in the same meeting** <-> person_a share **one common edge** with person_b in **talk network**\\n\\nPerson who has secret so far<-> **secret holder**\\n\\nPerson who has secret and share it with another person <-> **secret spreading nodes**\\n\\n\\n---\\n\\n```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n\\n        \\n        def bfs_spread_secret(secret_holder, talk_network, secret_spreading_nodes):\\n            \\n            # keep spreading secret by BFS if we still have secret spreading nodes\\n            while secret_spreading_nodes:\\n                \\n                # pop and get one secret spreader\\n                cur_secret_spreader = secret_spreading_nodes.pop()\\n\\n                # scan each person who talked to current secret spreader\\n                for another_person in talk_network[cur_secret_spreader]:\\n                    \\n                    if another_person not in secret_holder:\\n                        \\n                        # update secret holder and spreading nodes\\n                        secret_holder.add(another_person)\\n                        secret_spreading_nodes.add(another_person)\\n                            \\n            return        \\n        \\n        # -------------------------------------------------------------------\\n        \\n        # secret source given by description\\n        SECRET_SOURCE = 0\\n        \\n        # initialization for secret holder\\n        secret_holder = set([SECRET_SOURCE, firstPerson])\\n        \\n        \\n        # keep meetings sorting on time stamp with ascending order\\n        meetings.sort(key=lambda m:m[2])\\n        \\n        # record of timestamp for BFS\\n        prev_time = -1\\n        \\n        ## dictionary:\\n        # key: person index\\n        # value: a set of index to those people who talk to specific person\\n        talk_network = defaultdict(set)\\n        \\n        ## set:\\n        # a set of index of those people who become secret spreader after meeting with secret holder\\n        secret_spreading_nodes = set()\\n        \\n        \\n        # scan person pair in each meeting\\n        for person_a, person_b, time in meetings:\\n            \\n            \\n            # keep updating talk network until reaching next time stamp\\n            if time != prev_time:\\n                \\n                bfs_spread_secret(secret_holder, talk_network, secret_spreading_nodes)\\n                \\n                # clear talk network and secret spreading nodes for next time stamp\\n                talk_network.clear()\\n                secret_spreading_nodes.clear()\\n            \\n            \\n            # update talk network in each meeting\\n            talk_network[person_a].add(person_b)\\n            talk_network[person_b].add(person_a)\\n            \\n            # update secret spreading nodes from secret holder in each meeting\\n            if person_a in secret_holder:\\n                secret_spreading_nodes.add(person_a)\\n\\n            if person_b in secret_holder:\\n                secret_spreading_nodes.add(person_b)\\n                        \\n                \\n            # update time stamp\\n            prev_time = time\\n        \\n        \\n        # final BFS update\\n        bfs_spread_secret(secret_holder, talk_network, secret_spreading_nodes)\\n        \\n\\n        # unpack secret_holder from python set to python list\\n        return [*secret_holder]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Graph",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n\\n        \\n        def bfs_spread_secret(secret_holder, talk_network, secret_spreading_nodes):\\n            \\n            # keep spreading secret by BFS if we still have secret spreading nodes\\n            while secret_spreading_nodes:\\n                \\n                # pop and get one secret spreader\\n                cur_secret_spreader = secret_spreading_nodes.pop()\\n\\n                # scan each person who talked to current secret spreader\\n                for another_person in talk_network[cur_secret_spreader]:\\n                    \\n                    if another_person not in secret_holder:\\n                        \\n                        # update secret holder and spreading nodes\\n                        secret_holder.add(another_person)\\n                        secret_spreading_nodes.add(another_person)\\n                            \\n            return        \\n        \\n        # -------------------------------------------------------------------\\n        \\n        # secret source given by description\\n        SECRET_SOURCE = 0\\n        \\n        # initialization for secret holder\\n        secret_holder = set([SECRET_SOURCE, firstPerson])\\n        \\n        \\n        # keep meetings sorting on time stamp with ascending order\\n        meetings.sort(key=lambda m:m[2])\\n        \\n        # record of timestamp for BFS\\n        prev_time = -1\\n        \\n        ## dictionary:\\n        # key: person index\\n        # value: a set of index to those people who talk to specific person\\n        talk_network = defaultdict(set)\\n        \\n        ## set:\\n        # a set of index of those people who become secret spreader after meeting with secret holder\\n        secret_spreading_nodes = set()\\n        \\n        \\n        # scan person pair in each meeting\\n        for person_a, person_b, time in meetings:\\n            \\n            \\n            # keep updating talk network until reaching next time stamp\\n            if time != prev_time:\\n                \\n                bfs_spread_secret(secret_holder, talk_network, secret_spreading_nodes)\\n                \\n                # clear talk network and secret spreading nodes for next time stamp\\n                talk_network.clear()\\n                secret_spreading_nodes.clear()\\n            \\n            \\n            # update talk network in each meeting\\n            talk_network[person_a].add(person_b)\\n            talk_network[person_b].add(person_a)\\n            \\n            # update secret spreading nodes from secret holder in each meeting\\n            if person_a in secret_holder:\\n                secret_spreading_nodes.add(person_a)\\n\\n            if person_b in secret_holder:\\n                secret_spreading_nodes.add(person_b)\\n                        \\n                \\n            # update time stamp\\n            prev_time = time\\n        \\n        \\n        # final BFS update\\n        bfs_spread_secret(secret_holder, talk_network, secret_spreading_nodes)\\n        \\n\\n        # unpack secret_holder from python set to python list\\n        return [*secret_holder]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600202,
                "title": "java-hashmap-and-queue",
                "content": "1. Define an array times[] to store the time to know the secret.\\n2. Use a map to store the meeting info: Map<Integer, int[]>. e.g.\\n      person1 ==> {person2, meeting}\\n\\t  person2 ==> {person1, meeting}\\n3. Initially, add the person 0 and firstPerson to the queue.\\n4. For each person in the queue, get all associated meetings. if the meeting time is valid, add the associated persons to the queue.\\n5. Once the queue is empty, list persons whose time were changed in the times[] array.\\n```\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        int[] times = new int[n];\\n        Arrays.fill(times, Integer.MAX_VALUE);\\n        Map<Integer, Set<int[]>> map = new HashMap<>();\\n        for (int[] meeting : meetings) {\\n        \\tSet<int[]> set = map.getOrDefault(meeting[0], new HashSet<int[]>());\\n        \\tset.add(new int[] {meeting[1], meeting[2]});\\n        \\tmap.put(meeting[0], set);\\n        \\tset = map.getOrDefault(meeting[1], new HashSet<int[]>());\\n        \\tset.add(new int[] {meeting[0], meeting[2]});\\n        \\tmap.put(meeting[1], set);\\n        }\\n        Deque<Integer> q = new ArrayDeque<>();\\n        q.offer(0);\\n        q.offer(firstPerson);\\n        times[0] = times[firstPerson] = 0;\\n        while (!q.isEmpty()) {\\n        \\tint person = q.poll();\\n        \\tSet<int[]> set = map.getOrDefault(person, new HashSet<int[]>());\\n        \\tfor (int[] p : set) {\\n        \\t\\t/*Meeting time validation (failure conditions):\\n        \\t\\t(a) times[person] > p[1]\\n        \\t\\t\\t times[person]: the time that \"person\" knows the secret;\\n        \\t\\t\\t p[0] and p[1]: \"person\" and \"p[0]\" has the meeting at \"p[1]\"\\n        \\t\\t\\t This condition means: \"person\" knows the secret after the meeting time \"p[1]\" with the person \"p[0]\"\\n        \\t\\t(b) times[p[0]] <= p[1]\\n        \\t\\t\\t times[p[0]]: the time that \"p[0]\" knows the secret;\\n        \\t\\t\\t p[0] and p[1]: \"person\" and \"p[0]\" has the meeting at \"p[1]\"\\n        \\t\\t\\t This condition means: \"p[0]\" knows the secret before the meeting time \"p[1]\", in other words, \"p[0]\" has already been \\'visited\\'.\\n\\t\\t\\t\\t\\t Test case: ..., [0, 3, 8], [1, 3, 10], [2, 3, 5], ...\\n\\t\\t\\t\\t\\t [0, 3, 8]: The first time Person \"3\" knows the secret at 8. \"3\" goes into the queue.\\n\\t\\t\\t\\t\\t [1, 3, 10]: Person \"3\" already knows the secret at 10. skip.\\n\\t\\t\\t\\t\\t [2, 3, 5]: Person \"3\" has not yet known the secret at 5. \"3\" goes into the queue.\\n\\t\\t\\t\\t*/\\n        \\t\\tif (times[person] > p[1] || times[p[0]] <= p[1])\\n        \\t\\t\\tcontinue;\\n    \\t\\t\\ttimes[p[0]] = p[1];\\n    \\t\\t\\tq.offer(p[0]);\\n        \\t}\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        for (int i = 0; i < n; i++)\\n        \\tif (times[i] != Integer.MAX_VALUE)\\n        \\t\\tans.add(i);\\n        return ans;\\n    }\\n```\\nMinor changes to make the code more concise:\\n```\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        int[] times = new int[n];\\n        Arrays.fill(times, Integer.MAX_VALUE);\\n        Map<Integer, Set<int[]>> map = new HashMap<>();\\n        Set<Integer> notified = new HashSet<>();\\n        for (int[] meeting : meetings) {\\n        \\tmap.computeIfAbsent(meeting[0], x -> new HashSet<int[]>()).add(new int[] {meeting[1], meeting[2]});\\n        \\tmap.computeIfAbsent(meeting[1], x -> new HashSet<int[]>()).add(new int[] {meeting[0], meeting[2]});\\n        }\\n        Deque<Integer> q = new ArrayDeque<>();\\n        q.offer(0);\\n        q.offer(firstPerson);\\n        times[0] = times[firstPerson] = 0;\\n        while (!q.isEmpty()) {\\n        \\tint person = q.poll();\\n        \\tnotified.add(person);\\n        \\tfor (int[] p : map.getOrDefault(person, new HashSet<int[]>())) {\\n        \\t\\tif (times[person] > p[1] || times[p[0]] <= p[1])\\n        \\t\\t\\tcontinue;\\n    \\t\\t\\ttimes[p[0]] = p[1];\\n    \\t\\t\\tq.offer(p[0]);\\n        \\t}\\n        }\\n        return new ArrayList<Integer>(notified);\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        int[] times = new int[n];\\n        Arrays.fill(times, Integer.MAX_VALUE);\\n        Map<Integer, Set<int[]>> map = new HashMap<>();\\n        for (int[] meeting : meetings) {\\n        \\tSet<int[]> set = map.getOrDefault(meeting[0], new HashSet<int[]>());\\n        \\tset.add(new int[] {meeting[1], meeting[2]});\\n        \\tmap.put(meeting[0], set);\\n        \\tset = map.getOrDefault(meeting[1], new HashSet<int[]>());\\n        \\tset.add(new int[] {meeting[0], meeting[2]});\\n        \\tmap.put(meeting[1], set);\\n        }\\n        Deque<Integer> q = new ArrayDeque<>();\\n        q.offer(0);\\n        q.offer(firstPerson);\\n        times[0] = times[firstPerson] = 0;\\n        while (!q.isEmpty()) {\\n        \\tint person = q.poll();\\n        \\tSet<int[]> set = map.getOrDefault(person, new HashSet<int[]>());\\n        \\tfor (int[] p : set) {\\n        \\t\\t/*Meeting time validation (failure conditions):\\n        \\t\\t(a) times[person] > p[1]\\n        \\t\\t\\t times[person]: the time that \"person\" knows the secret;\\n        \\t\\t\\t p[0] and p[1]: \"person\" and \"p[0]\" has the meeting at \"p[1]\"\\n        \\t\\t\\t This condition means: \"person\" knows the secret after the meeting time \"p[1]\" with the person \"p[0]\"\\n        \\t\\t(b) times[p[0]] <= p[1]\\n        \\t\\t\\t times[p[0]]: the time that \"p[0]\" knows the secret;\\n        \\t\\t\\t p[0] and p[1]: \"person\" and \"p[0]\" has the meeting at \"p[1]\"\\n        \\t\\t\\t This condition means: \"p[0]\" knows the secret before the meeting time \"p[1]\", in other words, \"p[0]\" has already been \\'visited\\'.\\n\\t\\t\\t\\t\\t Test case: ..., [0, 3, 8], [1, 3, 10], [2, 3, 5], ...\\n\\t\\t\\t\\t\\t [0, 3, 8]: The first time Person \"3\" knows the secret at 8. \"3\" goes into the queue.\\n\\t\\t\\t\\t\\t [1, 3, 10]: Person \"3\" already knows the secret at 10. skip.\\n\\t\\t\\t\\t\\t [2, 3, 5]: Person \"3\" has not yet known the secret at 5. \"3\" goes into the queue.\\n\\t\\t\\t\\t*/\\n        \\t\\tif (times[person] > p[1] || times[p[0]] <= p[1])\\n        \\t\\t\\tcontinue;\\n    \\t\\t\\ttimes[p[0]] = p[1];\\n    \\t\\t\\tq.offer(p[0]);\\n        \\t}\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        for (int i = 0; i < n; i++)\\n        \\tif (times[i] != Integer.MAX_VALUE)\\n        \\t\\tans.add(i);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1600067,
                "title": "c-union-find",
                "content": "Little trick for current implementaion of Union Find:\\ninitialize rank for 0 person equal to n, so he will always be a head of newly formed graph.\\nFor each unique time connect people using Union Find. \\nIf person \"parent\" is equal to 0, so he knows a secret, else restore \"parent\" value to the person index.\\n```\\npublic class Solution\\n{\\n    public IList<int> FindAllPeople(int n, int[][] meetings, int firstPerson)\\n    {\\n        var map = new SortedDictionary<int, List<int[]>>();\\n        foreach(var meet in meetings)\\n        {\\n            var time = meet[2];\\n            if(map.ContainsKey(time) == false)\\n            {\\n                map.Add(time, new List<int[]>());\\n            }\\n            map[time].Add(new int[]{meet[0], meet[1]});\\n        }\\n        var res = new HashSet<int>(){0, firstPerson};\\n        \\n        var uf = new UnionFind(n);\\n        uf.Union(0, firstPerson);\\n        \\n        foreach(var kvp in map)\\n        {\\n            var level = new HashSet<int>();\\n            foreach(var pair in kvp.Value)\\n            {\\n                level.Add(pair[0]);\\n                level.Add(pair[1]);\\n                uf.Union(pair[0], pair[1]);\\n            }\\n            foreach(var p in level)\\n            {\\n                if(uf.Find(p) == 0) res.Add(p);\\n                else uf.RestoreParents(p);\\n            }\\n        }\\n        return res.ToList();\\n    }\\n    public class UnionFind\\n    {\\n        private int[] _parents;\\n        private int[] _rank;\\n        \\n        public UnionFind(int n)\\n        {\\n            _parents = new int[n];\\n            _rank = new int[n];\\n            for(int i = 0; i < n; i++)\\n            {\\n                _parents[i] = i;\\n                _rank[i] = 1;\\n            }\\n            _rank[0] = n;\\n        }\\n        public void Union(int x, int y)\\n        {\\n            int xHead = Find(x);\\n            int yHead = Find(y);\\n            if(xHead != yHead)\\n            {\\n                int xRank = _rank[xHead];\\n                int yRank = _rank[yHead];\\n                if(xRank > yRank) _parents[yHead] = xHead;\\n                else if(xRank < yRank) _parents[xHead] = yHead;\\n                else\\n                {\\n                    _parents[yHead] = xHead;\\n                    _rank[xHead]++;\\n                }\\n            }\\n        }\\n        public int Find(int x)\\n        {\\n            if(_parents[x] == x) return x;\\n            return _parents[x] = Find(_parents[x]);\\n        }\\n        private bool IsConnected(int x, int y)\\n        {\\n            return Find(x) == Find(y);\\n        }\\n        public void RestoreParents(int x)\\n        {\\n            _parents[x] = x;\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public IList<int> FindAllPeople(int n, int[][] meetings, int firstPerson)\\n    {\\n        var map = new SortedDictionary<int, List<int[]>>();\\n        foreach(var meet in meetings)\\n        {\\n            var time = meet[2];\\n            if(map.ContainsKey(time) == false)\\n            {\\n                map.Add(time, new List<int[]>());\\n            }\\n            map[time].Add(new int[]{meet[0], meet[1]});\\n        }\\n        var res = new HashSet<int>(){0, firstPerson};\\n        \\n        var uf = new UnionFind(n);\\n        uf.Union(0, firstPerson);\\n        \\n        foreach(var kvp in map)\\n        {\\n            var level = new HashSet<int>();\\n            foreach(var pair in kvp.Value)\\n            {\\n                level.Add(pair[0]);\\n                level.Add(pair[1]);\\n                uf.Union(pair[0], pair[1]);\\n            }\\n            foreach(var p in level)\\n            {\\n                if(uf.Find(p) == 0) res.Add(p);\\n                else uf.RestoreParents(p);\\n            }\\n        }\\n        return res.ToList();\\n    }\\n    public class UnionFind\\n    {\\n        private int[] _parents;\\n        private int[] _rank;\\n        \\n        public UnionFind(int n)\\n        {\\n            _parents = new int[n];\\n            _rank = new int[n];\\n            for(int i = 0; i < n; i++)\\n            {\\n                _parents[i] = i;\\n                _rank[i] = 1;\\n            }\\n            _rank[0] = n;\\n        }\\n        public void Union(int x, int y)\\n        {\\n            int xHead = Find(x);\\n            int yHead = Find(y);\\n            if(xHead != yHead)\\n            {\\n                int xRank = _rank[xHead];\\n                int yRank = _rank[yHead];\\n                if(xRank > yRank) _parents[yHead] = xHead;\\n                else if(xRank < yRank) _parents[xHead] = yHead;\\n                else\\n                {\\n                    _parents[yHead] = xHead;\\n                    _rank[xHead]++;\\n                }\\n            }\\n        }\\n        public int Find(int x)\\n        {\\n            if(_parents[x] == x) return x;\\n            return _parents[x] = Find(_parents[x]);\\n        }\\n        private bool IsConnected(int x, int y)\\n        {\\n            return Find(x) == Find(y);\\n        }\\n        public void RestoreParents(int x)\\n        {\\n            _parents[x] = x;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599993,
                "title": "java-tle-with-priority-queue",
                "content": "Need help in this code to remove TLE\\nUsing Priority with Comparator sort-\\n1.Storing  values with less time period first \\n2.If time period is same then sort according to the values x or y which are previousily  stored in that array\\n3.Then used priority queue to get a result\\n```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n       \\n        List<Integer> res =  new ArrayList();\\n        res.add(0);\\n        res.add(firstPerson);\\n        PriorityQueue<int[]> pq=  new PriorityQueue((a,b)->(((int[])a)[2]!=((int[])b)[2]||res.contains(((int[])a)[0])||res.contains(((int[])a)[1]))?((int[])a)[2]-((int[])b)[2]:((int[])b)[2]-((int[])a)[2]);\\n           for(int[]  meeting: meetings) pq.add(meeting);\\n        while(!pq.isEmpty()){\\n            int[]  meeting= pq.poll();\\n            if(res.contains(meeting[0])||res.contains(meeting[1])){\\n                if(!res.contains(meeting[0]))  res.add(meeting[0]);\\n                 if(!res.contains(meeting[1]))  res.add(meeting[1]);\\n            }\\n        }\\n        return res;\\n        \\n    }\\n   \\n}\\n```\\n*Plz dont down motivate without reason",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n       \\n        List<Integer> res =  new ArrayList();\\n        res.add(0);\\n        res.add(firstPerson);\\n        PriorityQueue<int[]> pq=  new PriorityQueue((a,b)->(((int[])a)[2]!=((int[])b)[2]||res.contains(((int[])a)[0])||res.contains(((int[])a)[1]))?((int[])a)[2]-((int[])b)[2]:((int[])b)[2]-((int[])a)[2]);\\n           for(int[]  meeting: meetings) pq.add(meeting);\\n        while(!pq.isEmpty()){\\n            int[]  meeting= pq.poll();\\n            if(res.contains(meeting[0])||res.contains(meeting[1])){\\n                if(!res.contains(meeting[0]))  res.add(meeting[0]);\\n                 if(!res.contains(meeting[1]))  res.add(meeting[1]);\\n            }\\n        }\\n        return res;\\n        \\n    }\\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599967,
                "title": "java-union-find",
                "content": "```\\nclass Solution {\\n    int[] parents;\\n    \\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        Arrays.sort(meetings, (a, b) -> a[2] - b[2]);\\n        parents = new int[n];\\n        for (int i = 0; i < n; i++) parents[i] = i;\\n        union(0, firstPerson);\\n        Set<Integer> visited = new HashSet<>();\\n        visited.add(0);\\n        visited.add(firstPerson);\\n        \\n        for (int i = 0; i < meetings.length; i++) {\\n            int time = meetings[i][2];\\n            int x = i;\\n            while (x < meetings.length && meetings[x][2] == time) {\\n                union(meetings[x][0], meetings[x][1]);   \\n                x++;\\n            }\\n            \\n            while (i < meetings.length && meetings[i][2] == time) {\\n                if (isConnect(0, meetings[i][0]) || isConnect(0, meetings[i][1])) {\\n                    visited.add(meetings[i][0]);\\n                    visited.add(meetings[i][1]);\\n                } else {\\n                    reset(meetings[i][0]);\\n                    reset(meetings[i][1]);\\n                }\\n                i++;\\n            }\\n            i--;\\n\\n        }\\n        return visited.stream().collect(Collectors.toList());\\n    }\\n    \\n    void union(int a, int b) {\\n        int pa = find(a);\\n        int pb = find(b);\\n        if (pa != pb) {\\n            parents[pa] = pb;\\n        }\\n    }\\n    \\n    int find(int a) {\\n        if (parents[a] != a) {\\n            parents[a] = find(parents[a]);\\n        }\\n        return parents[a];\\n    }\\n    \\n    boolean isConnect(int a, int b) {\\n        return find(a) == find(b);\\n    }\\n    \\n    void reset(int a) {\\n        parents[a] = a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[] parents;\\n    \\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        Arrays.sort(meetings, (a, b) -> a[2] - b[2]);\\n        parents = new int[n];\\n        for (int i = 0; i < n; i++) parents[i] = i;\\n        union(0, firstPerson);\\n        Set<Integer> visited = new HashSet<>();\\n        visited.add(0);\\n        visited.add(firstPerson);\\n        \\n        for (int i = 0; i < meetings.length; i++) {\\n            int time = meetings[i][2];\\n            int x = i;\\n            while (x < meetings.length && meetings[x][2] == time) {\\n                union(meetings[x][0], meetings[x][1]);   \\n                x++;\\n            }\\n            \\n            while (i < meetings.length && meetings[i][2] == time) {\\n                if (isConnect(0, meetings[i][0]) || isConnect(0, meetings[i][1])) {\\n                    visited.add(meetings[i][0]);\\n                    visited.add(meetings[i][1]);\\n                } else {\\n                    reset(meetings[i][0]);\\n                    reset(meetings[i][1]);\\n                }\\n                i++;\\n            }\\n            i--;\\n\\n        }\\n        return visited.stream().collect(Collectors.toList());\\n    }\\n    \\n    void union(int a, int b) {\\n        int pa = find(a);\\n        int pb = find(b);\\n        if (pa != pb) {\\n            parents[pa] = pb;\\n        }\\n    }\\n    \\n    int find(int a) {\\n        if (parents[a] != a) {\\n            parents[a] = find(parents[a]);\\n        }\\n        return parents[a];\\n    }\\n    \\n    boolean isConnect(int a, int b) {\\n        return find(a) == find(b);\\n    }\\n    \\n    void reset(int a) {\\n        parents[a] = a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682819,
                "title": "union-find-disjoint-set-beats-50-java-easy-solution",
                "content": "# Code\\n```\\nclass DisjointSet {\\n    int[] root;\\n    Long[] rank;\\n    DisjointSet(int size, Set<Integer> secretKeepers) {\\n        root = new int[size];\\n        rank = new Long[size];\\n        for (int i = 0; i < size; i++) {\\n            root[i] = i;\\n            rank[i] = secretKeepers.contains(i) ? Integer.MAX_VALUE : 1L;\\n        }\\n    }\\n\\n    public int find(int vertex) {\\n        if(root[vertex] == vertex) return vertex;\\n        return root[vertex] = find(root[vertex]);\\n    }\\n\\n    public void union(int vertex1, int vertex2) {\\n        int root1 = find(vertex1);\\n        int root2 = find(vertex2);\\n        if(root1 != root2) {\\n            if(rank[root1] > rank[root2]) {\\n                root[root2] = root1;\\n            } else if (rank[root2] > rank[root1]) {\\n                root[root1] = root2;\\n            } else {\\n                root[root2] = root1;\\n                rank[root1]++;\\n            }\\n        }\\n    }\\n\\n    public Set<Integer> getAllSecretKeepers(Set<Integer> secretKeepers, Set<Integer> visited) {\\n        for (int vertex: visited) {\\n            if(secretKeepers.contains(find(vertex)))\\n                secretKeepers.add(vertex);\\n            else \\n                root[vertex] = vertex;\\n        }\\n        return secretKeepers;\\n    }\\n}\\n\\nclass Solution {\\n    private int maxTime = Integer.MIN_VALUE;\\n    private int minTime = Integer.MAX_VALUE;\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        Set<Integer> secretKeepers = new HashSet<>(List.of(0, firstPerson));\\n        Map<Integer, List<Integer[]>> timeToMeetings = getTimeToMeetings(meetings);\\n        DisjointSet disjointSet = new DisjointSet(n, secretKeepers);\\n        for (int time = minTime; time <= maxTime; time++) {\\n            if(!timeToMeetings.containsKey(time)) continue;\\n            Set<Integer> visited = new HashSet<>();\\n            for (Integer[] meeting: timeToMeetings.get(time)) {\\n                int person1 = meeting[0], person2 = meeting[1];\\n                disjointSet.union(person1, person2);\\n                visited.add(person1);\\n                visited.add(person2);\\n            }\\n            secretKeepers = disjointSet.getAllSecretKeepers(secretKeepers, visited);\\n        }\\n        return new ArrayList<>(secretKeepers);\\n    }\\n\\n    private Map<Integer, List<Integer[]>> getTimeToMeetings(int[][] meetings) {\\n        Map<Integer, List<Integer[]>> timeToMeetings = new HashMap<>();\\n        for (int[] meeting: meetings) {\\n            maxTime = Math.max(maxTime, meeting[2]);\\n            minTime = Math.min(minTime, meeting[2]);\\n            timeToMeetings.computeIfAbsent(meeting[2], e-> new ArrayList<>()).add(new Integer[]{meeting[0], meeting[1]});\\n        }\\n        return timeToMeetings;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find",
                    "Sorting"
                ],
                "code": "```\\nclass DisjointSet {\\n    int[] root;\\n    Long[] rank;\\n    DisjointSet(int size, Set<Integer> secretKeepers) {\\n        root = new int[size];\\n        rank = new Long[size];\\n        for (int i = 0; i < size; i++) {\\n            root[i] = i;\\n            rank[i] = secretKeepers.contains(i) ? Integer.MAX_VALUE : 1L;\\n        }\\n    }\\n\\n    public int find(int vertex) {\\n        if(root[vertex] == vertex) return vertex;\\n        return root[vertex] = find(root[vertex]);\\n    }\\n\\n    public void union(int vertex1, int vertex2) {\\n        int root1 = find(vertex1);\\n        int root2 = find(vertex2);\\n        if(root1 != root2) {\\n            if(rank[root1] > rank[root2]) {\\n                root[root2] = root1;\\n            } else if (rank[root2] > rank[root1]) {\\n                root[root1] = root2;\\n            } else {\\n                root[root2] = root1;\\n                rank[root1]++;\\n            }\\n        }\\n    }\\n\\n    public Set<Integer> getAllSecretKeepers(Set<Integer> secretKeepers, Set<Integer> visited) {\\n        for (int vertex: visited) {\\n            if(secretKeepers.contains(find(vertex)))\\n                secretKeepers.add(vertex);\\n            else \\n                root[vertex] = vertex;\\n        }\\n        return secretKeepers;\\n    }\\n}\\n\\nclass Solution {\\n    private int maxTime = Integer.MIN_VALUE;\\n    private int minTime = Integer.MAX_VALUE;\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        Set<Integer> secretKeepers = new HashSet<>(List.of(0, firstPerson));\\n        Map<Integer, List<Integer[]>> timeToMeetings = getTimeToMeetings(meetings);\\n        DisjointSet disjointSet = new DisjointSet(n, secretKeepers);\\n        for (int time = minTime; time <= maxTime; time++) {\\n            if(!timeToMeetings.containsKey(time)) continue;\\n            Set<Integer> visited = new HashSet<>();\\n            for (Integer[] meeting: timeToMeetings.get(time)) {\\n                int person1 = meeting[0], person2 = meeting[1];\\n                disjointSet.union(person1, person2);\\n                visited.add(person1);\\n                visited.add(person2);\\n            }\\n            secretKeepers = disjointSet.getAllSecretKeepers(secretKeepers, visited);\\n        }\\n        return new ArrayList<>(secretKeepers);\\n    }\\n\\n    private Map<Integer, List<Integer[]>> getTimeToMeetings(int[][] meetings) {\\n        Map<Integer, List<Integer[]>> timeToMeetings = new HashMap<>();\\n        for (int[] meeting: meetings) {\\n            maxTime = Math.max(maxTime, meeting[2]);\\n            minTime = Math.min(minTime, meeting[2]);\\n            timeToMeetings.computeIfAbsent(meeting[2], e-> new ArrayList<>()).add(new Integer[]{meeting[0], meeting[1]});\\n        }\\n        return timeToMeetings;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544260,
                "title": "greedy-minheap-binary-search",
                "content": "```\\n// Approach: Greedy + Priority_queue (Min Heap) + Binary Search\\n// If a person `x` knows the truth at time `t`, he will spread the truth with its upcoming meetings time with t, t + 1, t + 2... till the end.\\n// TC: O((N * log N) + M * logM)\\n// SC: O(M + N)\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        // Storing in set, so that we can apply binary search on first field.\\n        // {node -> {{time, node1}, {time2, node2}, ....}}\\n        \\n        set<pair<int, int>> adj[n];\\n        for(auto &meet: meetings){ // TC: O(M * logM)\\n            adj[meet[0]].insert({meet[2], meet[1]});\\n            adj[meet[1]].insert({meet[2], meet[0]});\\n        }\\n        \\n        // {current_time, current_person}\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> minHeap;\\n        \\n        vector<bool> vis(n, false);\\n        vis[0] = true;\\n        \\n        vector<int> ans = { 0 }; // 0 knows the secret.\\n        \\n        // 0 person will tell secret to its neighbors and firstperson.\\n        for(auto it: adj[0]) minHeap.push({it.first, it.second});\\n        \\n        minHeap.push({0, firstPerson});\\n        \\n        // TC: O(NlogN)\\n        while(minHeap.size()){\\n            auto node = minHeap.top();\\n            minHeap.pop();\\n            \\n            // If person is visited, then it already spread the secret to its neighbors\\n            if(vis[node.second]) continue;\\n            \\n            ans.emplace_back(node.second);\\n            vis[node.second] = true;\\n            \\n            // Since we are storing first field as time, so let\\'s do binary search and reach at current time or greater time and expose the secret with neighbors in future.\\n            auto it = adj[node.second].lower_bound({node.first, 0});\\n            \\n            while(it != adj[node.second].end()){\\n                if(!vis[it->second]) minHeap.push({it->first, it->second});\\n                it++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n// Approach: Greedy + Priority_queue (Min Heap) + Binary Search\\n// If a person `x` knows the truth at time `t`, he will spread the truth with its upcoming meetings time with t, t + 1, t + 2... till the end.\\n// TC: O((N * log N) + M * logM)\\n// SC: O(M + N)\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        // Storing in set, so that we can apply binary search on first field.\\n        // {node -> {{time, node1}, {time2, node2}, ....}}\\n        \\n        set<pair<int, int>> adj[n];\\n        for(auto &meet: meetings){ // TC: O(M * logM)\\n            adj[meet[0]].insert({meet[2], meet[1]});\\n            adj[meet[1]].insert({meet[2], meet[0]});\\n        }\\n        \\n        // {current_time, current_person}\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> minHeap;\\n        \\n        vector<bool> vis(n, false);\\n        vis[0] = true;\\n        \\n        vector<int> ans = { 0 }; // 0 knows the secret.\\n        \\n        // 0 person will tell secret to its neighbors and firstperson.\\n        for(auto it: adj[0]) minHeap.push({it.first, it.second});\\n        \\n        minHeap.push({0, firstPerson});\\n        \\n        // TC: O(NlogN)\\n        while(minHeap.size()){\\n            auto node = minHeap.top();\\n            minHeap.pop();\\n            \\n            // If person is visited, then it already spread the secret to its neighbors\\n            if(vis[node.second]) continue;\\n            \\n            ans.emplace_back(node.second);\\n            vis[node.second] = true;\\n            \\n            // Since we are storing first field as time, so let\\'s do binary search and reach at current time or greater time and expose the secret with neighbors in future.\\n            auto it = adj[node.second].lower_bound({node.first, 0});\\n            \\n            while(it != adj[node.second].end()){\\n                if(!vis[it->second]) minHeap.push({it->first, it->second});\\n                it++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507768,
                "title": "java-union-find",
                "content": "# Intuition\\nEstablishes connections between people who attend the same meetings.\\n\\nThen, by checking if a person belongs to the same group as the firstPerson, it determines whether they know the secret or not.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSort the meetings array based on the meeting time in ascending order. This step ensures that meetings with the same time are grouped together.\\n\\nCreate a graph data structure to represent the relationships between the people who attend the meetings. Each meeting group with the same time is represented as a list of indices of the meetings in the meetings array. This graph will help in identifying the groups of people who attend meetings together.\\n\\nInitialize a disjoint set data structure (union-find) to keep track of the groups of people who know the secret. Initially, each person is in their own group.\\n\\nUnion the first person (given by the firstPerson parameter) with the group of people who know the secret (represented by the group with index 0). This step ensures that the first person is part of the group of people who know the secret.\\n\\nIterate over each meeting group in the graph. For each group, create a HashSet to keep track of the people attending the meetings.\\n\\nPerform union operations on the people who attend the same meeting, indicating that they belong to the same group. This step ensures that the groups are connected based on their attendance at meetings.\\n\\nReset the group for the people who do not know the secret. For each person in the HashSet, if they are not in the same group as the firstPerson, reset their group. This step ensures that people who do not know the secret are not included in the final result.\\n\\nFinally, iterate over all the people and add those who belong to the same group as the firstPerson to the result list. These are the people who know the secret based on their connections through meetings.\\n\\nReturn the list of people who know the secret.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:  **O(M log M + N)**\\n\\n  M is the number of meetings.\\n  N is the number of people.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  **O(M + N)**\\n\\n  M is the number of meetings.\\n  N is the number of people.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n\\n        // get index of meetings with same time together \\n        Arrays.sort(meetings , (a,b)->Integer.compare(a[2],b[2]));\\n        ArrayList<ArrayList<Integer>> graph = new ArrayList<>();\\n        ArrayList<Integer> l = new ArrayList<>();\\n        int i=0;\\n        int lastTime = meetings[i][2];\\n        while(i<meetings.length){\\n            if(meetings[i][2]==lastTime){\\n                l.add(i);\\n                i++;\\n            }\\n            else{\\n                ArrayList<Integer> r = new ArrayList<>();\\n                r.addAll(l);\\n                graph.add(r);\\n                l.clear();\\n                lastTime=meetings[i][2];\\n            }\\n        }\\n        graph.add(l);\\n\\n        // DISJOINT SET\\n        djs(n);\\n        union(0,firstPerson);\\n        for(int j=0 ;j<graph.size() ; j++){\\n            HashSet<Integer> set = new HashSet<>();\\n\\n            // union both person meeting at a time\\n            for(int e : graph.get(j)){\\n                int x = meetings[e][0];\\n                int y = meetings[e][1];\\n                union(x,y);\\n                set.add(x);\\n                set.add(y);\\n            }\\n            // reset person not knowing secret at a time\\n            for(int e: set){\\n                if(find(0)!=find(e)) reset(e);\\n            }\\n        }\\n\\n        // return person who know secret\\n        List<Integer> list = new ArrayList<>();\\n        for(int j=0 ;j<n ; j++){\\n            if(find(0)==find(j)) list.add(j);\\n        }\\n        return list;\\n        \\n    }\\n    \\n    // union find\\n    int[] parent = new int [100000];\\n    void djs(int n){\\n        for(int i=0 ; i<n ; i++){\\n            parent[i] = i;\\n        }\\n    }\\n    int find(int node){\\n        if(parent[node] == node){\\n            return node;\\n        }\\n        return parent[node] = find(parent[node]);\\n    }\\n    boolean union(int u ,int v){\\n        u = find(u);\\n        v = find(v);\\n        if(u!=v){\\n            parent[u] = v;\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    // reset function\\n    void reset(int node){\\n        parent[node] = node;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n\\n        // get index of meetings with same time together \\n        Arrays.sort(meetings , (a,b)->Integer.compare(a[2],b[2]));\\n        ArrayList<ArrayList<Integer>> graph = new ArrayList<>();\\n        ArrayList<Integer> l = new ArrayList<>();\\n        int i=0;\\n        int lastTime = meetings[i][2];\\n        while(i<meetings.length){\\n            if(meetings[i][2]==lastTime){\\n                l.add(i);\\n                i++;\\n            }\\n            else{\\n                ArrayList<Integer> r = new ArrayList<>();\\n                r.addAll(l);\\n                graph.add(r);\\n                l.clear();\\n                lastTime=meetings[i][2];\\n            }\\n        }\\n        graph.add(l);\\n\\n        // DISJOINT SET\\n        djs(n);\\n        union(0,firstPerson);\\n        for(int j=0 ;j<graph.size() ; j++){\\n            HashSet<Integer> set = new HashSet<>();\\n\\n            // union both person meeting at a time\\n            for(int e : graph.get(j)){\\n                int x = meetings[e][0];\\n                int y = meetings[e][1];\\n                union(x,y);\\n                set.add(x);\\n                set.add(y);\\n            }\\n            // reset person not knowing secret at a time\\n            for(int e: set){\\n                if(find(0)!=find(e)) reset(e);\\n            }\\n        }\\n\\n        // return person who know secret\\n        List<Integer> list = new ArrayList<>();\\n        for(int j=0 ;j<n ; j++){\\n            if(find(0)==find(j)) list.add(j);\\n        }\\n        return list;\\n        \\n    }\\n    \\n    // union find\\n    int[] parent = new int [100000];\\n    void djs(int n){\\n        for(int i=0 ; i<n ; i++){\\n            parent[i] = i;\\n        }\\n    }\\n    int find(int node){\\n        if(parent[node] == node){\\n            return node;\\n        }\\n        return parent[node] = find(parent[node]);\\n    }\\n    boolean union(int u ,int v){\\n        u = find(u);\\n        v = find(v);\\n        if(u!=v){\\n            parent[u] = v;\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    // reset function\\n    void reset(int node){\\n        parent[node] = node;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2379913,
                "title": "c-solution-dijkstra-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    using pii=pair<int,int>;\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        vector<vector<pii>> graph(n);\\n        for(auto &e:meetings){\\n            int u=e[0],v=e[1],w=e[2];\\n            graph[u].push_back({v,w});\\n            graph[v].push_back({u,w});\\n        }\\n        vector<bool> visited(n);\\n        priority_queue<pii,vector<pii>,greater<>> pq;\\n        pq.push({0,0});\\n        pq.push({0,firstPerson});\\n        while(pq.size()){\\n            auto [t,u]=pq.top();\\n            pq.pop();\\n            if(visited[u])\\n                continue;\\n            visited[u]=1;\\n            for(auto [v,w]:graph[u]){\\n                if(!visited[v] and t<=w)\\n                    pq.push({w,v});\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<n;i++){\\n            if(visited[i])\\n                ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    using pii=pair<int,int>;\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        vector<vector<pii>> graph(n);\\n        for(auto &e:meetings){\\n            int u=e[0],v=e[1],w=e[2];\\n            graph[u].push_back({v,w});\\n            graph[v].push_back({u,w});\\n        }\\n        vector<bool> visited(n);\\n        priority_queue<pii,vector<pii>,greater<>> pq;\\n        pq.push({0,0});\\n        pq.push({0,firstPerson});\\n        while(pq.size()){\\n            auto [t,u]=pq.top();\\n            pq.pop();\\n            if(visited[u])\\n                continue;\\n            visited[u]=1;\\n            for(auto [v,w]:graph[u]){\\n                if(!visited[v] and t<=w)\\n                    pq.push({w,v});\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<n;i++){\\n            if(visited[i])\\n                ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375675,
                "title": "simple-dijkstra-s-algo",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n\\t\\t\\tvector<int> inDegree(n, 0);\\n\\t\\t\\tvector<vector<pair<int,int>>> adj(n);\\n\\n\\t\\t\\tfor(int i = 0; i < meetings.size(); i++) {\\n\\t\\t\\t\\tadj[meetings[i][0]].push_back({meetings[i][1], meetings[i][2]});\\n\\t\\t\\t\\tadj[meetings[i][1]].push_back({meetings[i][0], meetings[i][2]});\\n\\t\\t\\t}\\n\\n\\t\\t\\tvector<bool> visited(n, false);\\n\\t\\t\\tpriority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> q;\\n\\t\\t\\tq.push({0,firstPerson});\\n\\t\\t\\tq.push({0,0});\\n\\t\\t\\tvector<int> dis(n, INT_MAX);\\n\\t\\t\\tdis[firstPerson] = 0;\\n\\t\\t\\tdis[0] = 0;\\n\\n\\t\\t\\tvector<int> ans;\\n\\t\\t\\twhile(q.size() > 0) {\\n\\t\\t\\t\\tint t = q.top().first;\\n\\t\\t\\t\\tint u = q.top().second;\\n\\t\\t\\t\\tq.pop();\\n\\n\\t\\t\\t\\tif(t > dis[u])\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\tvisited[u] = true;\\n\\t\\t\\t\\tans.push_back(u);\\n\\t\\t\\t\\tfor(auto k : adj[u]) {\\n\\t\\t\\t\\t\\tint v = k.first;\\n\\t\\t\\t\\t\\tint timestamp = k.second;\\n\\t\\t\\t\\t\\tif(t <= timestamp && visited[v] == false && timestamp < dis[v]) {\\n\\t\\t\\t\\t\\t\\tq.push({timestamp,v});\\n\\t\\t\\t\\t\\t\\tdis[v] = timestamp;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n\\t\\t\\tvector<int> inDegree(n, 0);\\n\\t\\t\\tvector<vector<pair<int,int>>> adj(n);\\n\\n\\t\\t\\tfor(int i = 0; i < meetings.size(); i++) {\\n\\t\\t\\t\\tadj[meetings[i][0]].push_back({meetings[i][1], meetings[i][2]}",
                "codeTag": "Java"
            },
            {
                "id": 2363409,
                "title": "clean-union-find-700ms-99-fast",
                "content": "```\\nclass dsu {\\n public:\\n  vector<int> p;\\n  int n;\\n \\n  dsu(int _n) : n(_n) {\\n    p.resize(n);\\n    iota(p.begin(), p.end(), 0);\\n  }\\n \\n  inline int get(int x) {\\n    return (x == p[x] ? x : (p[x] = get(p[x])));\\n  }\\n \\n  inline bool unite(int x, int y) {\\n    x = get(x);\\n    y = get(y);\\n    if (x != y) {\\n        if(x<y)\\n            p[y]=x;\\n        else\\n            p[x]=y;\\n      return true;\\n    }\\n    return false;\\n  }\\n};\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        int len=meetings.size();\\n        map<int,vector<pair<int,int>>> full;\\n        for(int x=0;x<len;x++){\\n            full[meetings[x][2]].push_back({meetings[x][0],meetings[x][1]});\\n        }\\n        dsu *u=new dsu(n);\\n        u->unite(0,firstPerson);\\n        for(auto &v:full){\\n            for(auto &[one,two]:v.second){\\n                u->unite(one,two);\\n            }\\n            for(auto &[one,two]:v.second){\\n                if(u->get(one)!=0)\\n                    u->p[one]=one;\\n                if(u->get(two)!=0)\\n                    u->p[two]=two;\\n            }\\n        }\\n        vector<int> res;\\n        for(int x=0;x<n;x++){\\n            if(u->get(x)==0)\\n                res.push_back(x);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass dsu {\\n public:\\n  vector<int> p;\\n  int n;\\n \\n  dsu(int _n) : n(_n) {\\n    p.resize(n);\\n    iota(p.begin(), p.end(), 0);\\n  }\\n \\n  inline int get(int x) {\\n    return (x == p[x] ? x : (p[x] = get(p[x])));\\n  }\\n \\n  inline bool unite(int x, int y) {\\n    x = get(x);\\n    y = get(y);\\n    if (x != y) {\\n        if(x<y)\\n            p[y]=x;\\n        else\\n            p[x]=y;\\n      return true;\\n    }\\n    return false;\\n  }\\n};\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        int len=meetings.size();\\n        map<int,vector<pair<int,int>>> full;\\n        for(int x=0;x<len;x++){\\n            full[meetings[x][2]].push_back({meetings[x][0],meetings[x][1]});\\n        }\\n        dsu *u=new dsu(n);\\n        u->unite(0,firstPerson);\\n        for(auto &v:full){\\n            for(auto &[one,two]:v.second){\\n                u->unite(one,two);\\n            }\\n            for(auto &[one,two]:v.second){\\n                if(u->get(one)!=0)\\n                    u->p[one]=one;\\n                if(u->get(two)!=0)\\n                    u->p[two]=two;\\n            }\\n        }\\n        vector<int> res;\\n        for(int x=0;x<n;x++){\\n            if(u->get(x)==0)\\n                res.push_back(x);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2165615,
                "title": "python-sorting-and-bfs-with-explanation",
                "content": "1. First sort by time since we will go from present to future time \\n2. Start with base set called *hasSecret* where 0th person and *firstPerson* are present since they both know the secret\\n3.  For each time duration basically a graph is created for all persons involved and their interconnectedness. At each time the person\\'s involved who knows the secret will be added to the *secretSource* set and also pushed to bfs queue\\n4.  As the queue starts running, persons associated with secret source persons and not knowing the secret already will be processed i.e. pushed to *hasSecret* and added back to the queue to continue passing the message\\n\\n\\n\\n```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        meetAtTime = collections.defaultdict(list)\\n        for p1, p2, t in meetings:\\n            meetAtTime[t].append((p1, p2))\\n        \\n        hasSecret = set([0, firstPerson])\\n        \\n        for t in sorted(meetAtTime.keys()):\\n            meets = meetAtTime[t]\\n            \\n            graph = collections.defaultdict(list)\\n            \\n            secretSource = set()\\n            \\n            for p1, p2 in meets:\\n                \\n                graph[p1].append(p2)\\n                graph[p2].append(p1)\\n                \\n                if p1 in hasSecret:\\n                    secretSource.add(p1)\\n                if p2 in hasSecret:\\n                    secretSource.add(p2)\\n            \\n            q = collections.deque(secretSource)\\n                \\n            while q:\\n                person = q.popleft()\\n                \\n                for partner in graph[person]:\\n                    if partner not in hasSecret:\\n                        hasSecret.add(partner)\\n                        q.append(partner)\\n        \\n        return hasSecret\\n```\\n\\nTime Complexity: O(NlogN) dominated by sorting ( bfs overall time: O(N) )\\n\\nSpace Complexity: O(N) for hashmaps and sets",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Graph",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        meetAtTime = collections.defaultdict(list)\\n        for p1, p2, t in meetings:\\n            meetAtTime[t].append((p1, p2))\\n        \\n        hasSecret = set([0, firstPerson])\\n        \\n        for t in sorted(meetAtTime.keys()):\\n            meets = meetAtTime[t]\\n            \\n            graph = collections.defaultdict(list)\\n            \\n            secretSource = set()\\n            \\n            for p1, p2 in meets:\\n                \\n                graph[p1].append(p2)\\n                graph[p2].append(p1)\\n                \\n                if p1 in hasSecret:\\n                    secretSource.add(p1)\\n                if p2 in hasSecret:\\n                    secretSource.add(p2)\\n            \\n            q = collections.deque(secretSource)\\n                \\n            while q:\\n                person = q.popleft()\\n                \\n                for partner in graph[person]:\\n                    if partner not in hasSecret:\\n                        hasSecret.add(partner)\\n                        q.append(partner)\\n        \\n        return hasSecret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2144143,
                "title": "python-dfs",
                "content": "```\\nclass Solution:\\n    def findAllPeople(self, n: int, y: List[List[int]], firstPerson: int) -> List[int]:\\n        def f(i,c):\\n            v.add(i)\\n            secret.add(i)\\n            for j in x[i,c]:\\n                if j not in v:\\n                    f(j,c)\\n        x=defaultdict(set)\\n        time=defaultdict(set)\\n        for a,b,c in y:\\n            x[a,c].add(b)\\n            x[b,c].add(a)\\n            time[c].add(a)\\n            time[c].add(b)\\n        secret={0,firstPerson}\\n        for ti in sorted(time.keys()):\\n            v=set()\\n            for a in time[ti]:\\n                if a in secret:\\n                    f(a,ti)\\n        return secret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findAllPeople(self, n: int, y: List[List[int]], firstPerson: int) -> List[int]:\\n        def f(i,c):\\n            v.add(i)\\n            secret.add(i)\\n            for j in x[i,c]:\\n                if j not in v:\\n                    f(j,c)\\n        x=defaultdict(set)\\n        time=defaultdict(set)\\n        for a,b,c in y:\\n            x[a,c].add(b)\\n            x[b,c].add(a)\\n            time[c].add(a)\\n            time[c].add(b)\\n        secret={0,firstPerson}\\n        for ti in sorted(time.keys()):\\n            v=set()\\n            for a in time[ti]:\\n                if a in secret:\\n                    f(a,ti)\\n        return secret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2104507,
                "title": "java-bfs-with-priorityqueue",
                "content": "The idea is that the meetings that are not part of the secrets share member or before the secrete propagate are not important.\\n```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n\\t\\t// create adjacency list\\n        List<int[]>[] graph = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList();\\n        }\\n\\t\\t// like other graph problem you need to track which node is visited\\n\\t\\t// in this case the time of the node is visited is important, we need to track the earliest time a node is visited\\n        int[] know = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            know[i] = Integer.MAX_VALUE;\\n        }\\n        for (int[] e : meetings) {\\n            graph[e[0]].add(new int[]{e[1], e[2]});\\n            graph[e[1]].add(new int[]{e[0], e[2]});\\n        }\\n\\t\\t// priority queue make sure the earlier meeting process first so we can ignore the secrete propagation after the member was already visited\\n        PriorityQueue<int[]> pq = new PriorityQueue(new Comparator<int[]>(){\\n            public int compare(int[] a, int[] b) {\\n                return a[1] - b[1];\\n            }\\n        });\\n\\t\\t// both 0 and firstPerson will be the start of the secrete propagation\\n        pq.add(new int[]{firstPerson, 0});\\n        pq.add(new int[]{0, 0});\\n        while(!pq.isEmpty()) {\\n            int[] cur = pq.poll();\\n\\t\\t\\t// if the secrete aleady reached current person\\n            if(know[cur[0]] <= cur[1]) continue;\\n            know[cur[0]] = cur[1];\\n            for (int[] next : graph[cur[0]]) {\\n\\t\\t\\t\\t// only propagate when the neighbor knows the screte later\\n                if (know[cur[0]] <= next[1]) {\\n                    pq.add(next);\\n                }\\n            }\\n        }\\n        List<Integer> res = new ArrayList();\\n        for (int i = 0; i < n; i++) {\\n            if (know[i] != Integer.MAX_VALUE) {\\n                res.add(i);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n\\t\\t// create adjacency list\\n        List<int[]>[] graph = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList();\\n        }\\n\\t\\t// like other graph problem you need to track which node is visited\\n\\t\\t// in this case the time of the node is visited is important, we need to track the earliest time a node is visited\\n        int[] know = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            know[i] = Integer.MAX_VALUE;\\n        }\\n        for (int[] e : meetings) {\\n            graph[e[0]].add(new int[]{e[1], e[2]});\\n            graph[e[1]].add(new int[]{e[0], e[2]});\\n        }\\n\\t\\t// priority queue make sure the earlier meeting process first so we can ignore the secrete propagation after the member was already visited\\n        PriorityQueue<int[]> pq = new PriorityQueue(new Comparator<int[]>(){\\n            public int compare(int[] a, int[] b) {\\n                return a[1] - b[1];\\n            }\\n        });\\n\\t\\t// both 0 and firstPerson will be the start of the secrete propagation\\n        pq.add(new int[]{firstPerson, 0});\\n        pq.add(new int[]{0, 0});\\n        while(!pq.isEmpty()) {\\n            int[] cur = pq.poll();\\n\\t\\t\\t// if the secrete aleady reached current person\\n            if(know[cur[0]] <= cur[1]) continue;\\n            know[cur[0]] = cur[1];\\n            for (int[] next : graph[cur[0]]) {\\n\\t\\t\\t\\t// only propagate when the neighbor knows the screte later\\n                if (know[cur[0]] <= next[1]) {\\n                    pq.add(next);\\n                }\\n            }\\n        }\\n        List<Integer> res = new ArrayList();\\n        for (int i = 0; i < n; i++) {\\n            if (know[i] != Integer.MAX_VALUE) {\\n                res.add(i);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2071068,
                "title": "python-graph-bfs",
                "content": "\\tclass Solution:\\n\\t\\tdef findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n\\t\\t\\tres = {0, firstPerson}\\n\\t\\t\\tgraph = collections.defaultdict(collections.defaultdict)\\n\\t\\t\\tfor x, y, t in meetings:\\n\\t\\t\\t\\tgraph[t][x] = graph[t].get(x, set())\\n\\t\\t\\t\\tgraph[t][x].add(y)\\n\\t\\t\\t\\tgraph[t][y] = graph[t].get(y, set())\\n\\t\\t\\t\\tgraph[t][y].add(x)\\n\\t\\t\\tfor time in sorted(graph.keys()):\\n\\t\\t\\t\\tqueue = collections.deque([people for people in graph[time] if people in res])\\n\\t\\t\\t\\tseen = set()\\n\\t\\t\\t\\twhile queue:\\n\\t\\t\\t\\t\\tpeople = queue.popleft()\\n\\t\\t\\t\\t\\tfor share in graph[time][people]:\\n\\t\\t\\t\\t\\t\\tif share not in seen:\\n\\t\\t\\t\\t\\t\\t\\tqueue.append(share)\\n\\t\\t\\t\\t\\t\\t\\tres.add(share)\\n\\t\\t\\t\\t\\t\\t\\tseen.add(people)\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n\\t\\t\\tres = {0, firstPerson}",
                "codeTag": "Java"
            },
            {
                "id": 2070915,
                "title": "c-union-find-clean-code-easy-to-understand",
                "content": "```cpp\\nclass UnionFind {\\n    vector<int> par;\\n    public:\\n    UnionFind(int n) {\\n        par.resize(n, 0);\\n        for (int i = 0; i < n; i++) par[i] = i;\\n    }\\n    \\n    void connect(int a, int b) {\\n        int parA = find(a);\\n        int parB = find(b);\\n        par[parA] = parB;\\n    }\\n    \\n    int find(int a) {\\n        if (par[a] == a)\\n            return a;\\n        \\n        return par[a] = find(par[a]);\\n    }\\n    \\n    bool isConnected(int a, int b) {\\n        int para = find(a);\\n        int parb = find(b);\\n        return para == parb;   \\n    }\\n    \\n    void reset(int a) {\\n        par[a] = a;\\n    }\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> &a, vector<int> &b) {\\n        return a[2] < b[2];\\n    }\\n    \\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        map<int, vector<pair<int, int>>> meetingsMap;\\n        \\n        for (auto vec : meetings) {\\n            int x = vec[0];\\n            int y = vec[1];\\n            int time = vec[2];\\n            meetingsMap[time].push_back({x, y});\\n        }\\n        \\n        UnionFind* uf = new UnionFind(n);\\n        \\n        uf -> connect(firstPerson, 0);\\n        \\n        set<int> people;\\n        for (auto [time, meetingArray] : meetingsMap) {\\n            \\n            people.clear();\\n            for (auto [person1, person2] : meetingArray) {\\n                uf -> connect(person1, person2);\\n                people.insert(person1);\\n                people.insert(person2);\\n            }\\n            \\n            for (int person : people) {\\n                if (!uf -> isConnected(person, 0))\\n                    uf -> reset(person);\\n            }\\n        }\\n        \\n        vector<int> res;\\n        for (int i = 0; i < n; i++) {\\n            if (uf -> isConnected(i, 0))\\n                res.push_back(i);\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```cpp\\nclass UnionFind {\\n    vector<int> par;\\n    public:\\n    UnionFind(int n) {\\n        par.resize(n, 0);\\n        for (int i = 0; i < n; i++) par[i] = i;\\n    }\\n    \\n    void connect(int a, int b) {\\n        int parA = find(a);\\n        int parB = find(b);\\n        par[parA] = parB;\\n    }\\n    \\n    int find(int a) {\\n        if (par[a] == a)\\n            return a;\\n        \\n        return par[a] = find(par[a]);\\n    }\\n    \\n    bool isConnected(int a, int b) {\\n        int para = find(a);\\n        int parb = find(b);\\n        return para == parb;   \\n    }\\n    \\n    void reset(int a) {\\n        par[a] = a;\\n    }\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> &a, vector<int> &b) {\\n        return a[2] < b[2];\\n    }\\n    \\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        map<int, vector<pair<int, int>>> meetingsMap;\\n        \\n        for (auto vec : meetings) {\\n            int x = vec[0];\\n            int y = vec[1];\\n            int time = vec[2];\\n            meetingsMap[time].push_back({x, y});\\n        }\\n        \\n        UnionFind* uf = new UnionFind(n);\\n        \\n        uf -> connect(firstPerson, 0);\\n        \\n        set<int> people;\\n        for (auto [time, meetingArray] : meetingsMap) {\\n            \\n            people.clear();\\n            for (auto [person1, person2] : meetingArray) {\\n                uf -> connect(person1, person2);\\n                people.insert(person1);\\n                people.insert(person2);\\n            }\\n            \\n            for (int person : people) {\\n                if (!uf -> isConnected(person, 0))\\n                    uf -> reset(person);\\n            }\\n        }\\n        \\n        vector<int> res;\\n        for (int i = 0; i < n; i++) {\\n            if (uf -> isConnected(i, 0))\\n                res.push_back(i);\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038056,
                "title": "python-union-find",
                "content": "##use Union-Find to check if two person at a time are connected\\n\\n\\t\\t# Time O(mlogm), Spaces O(m+n)\\n\\t\\t# first take all person x,y with same meeting time and sort by time\\n\\t\\tmeet_time = defaultdict(list)\\n\\t\\tfor x,y,t in meetings:\\n\\t\\t\\tmeet_time[t].append((x,y))\\n\\n\\t\\tmeet_time = sorted(meet_time.items())\\n\\n\\t\\tdef find(x):\\n\\t\\t\\tif self.parents[x] != x:\\n\\t\\t\\t\\tself.parents[x] = find(self.parents[x])\\n\\t\\t\\treturn self.parents[x]\\n\\n\\t\\tdef union(x,y):\\n\\t\\t\\t# insert if not in parents\\n\\t\\t\\tif x not in self.parents:\\n\\t\\t\\t\\tself.parents[x] = x\\n\\t\\t\\tif y not in self.parents:\\n\\t\\t\\t\\tself.parents[y] = y\\n\\n\\t\\t\\tparent_x, parent_y = find(x), find(y)\\n\\t\\t\\tif parent_x == parent_y:\\n\\t\\t\\t\\treturn\\n\\t\\t\\tself.parents[parent_x] = parent_y\\n\\n\\t\\t# persons currently with secrets, will update later\\n\\t\\tperson_with_secret = set([0, firstPerson])\\n\\n\\t\\tfor time, persons in meet_time:\\n\\t\\t\\tself.parents = {}\\n\\t\\t\\tfor x,y in persons:\\n\\t\\t\\t\\tunion(x,y) #get parents\\n\\n\\t\\t\\tgroups = defaultdict(set) # group persons that are connected within the current time\\n\\n\\t\\t\\t# get persons connected with same parent\\n\\t\\t\\tfor parent in self.parents:\\n\\t\\t\\t\\tgroups[find(parent)].add(parent)\\n\\n\\t\\t\\tfor grp in groups.values():\\n\\t\\t\\t\\t# if one person in a group is found in\\n\\t\\t\\t\\t# persons_with_secret set add the entire group to the set\\n\\t\\t\\t\\tif grp.intersection(person_with_secret):\\n\\t\\t\\t\\t\\tperson_with_secret.update(grp)\\n\\n\\t\\treturn list(person_with_secret)",
                "solutionTags": [],
                "code": "##use Union-Find to check if two person at a time are connected\\n\\n\\t\\t# Time O(mlogm), Spaces O(m+n)\\n\\t\\t# first take all person x,y with same meeting time and sort by time\\n\\t\\tmeet_time = defaultdict(list)\\n\\t\\tfor x,y,t in meetings:\\n\\t\\t\\tmeet_time[t].append((x,y))\\n\\n\\t\\tmeet_time = sorted(meet_time.items())\\n\\n\\t\\tdef find(x):\\n\\t\\t\\tif self.parents[x] != x:\\n\\t\\t\\t\\tself.parents[x] = find(self.parents[x])\\n\\t\\t\\treturn self.parents[x]\\n\\n\\t\\tdef union(x,y):\\n\\t\\t\\t# insert if not in parents\\n\\t\\t\\tif x not in self.parents:\\n\\t\\t\\t\\tself.parents[x] = x\\n\\t\\t\\tif y not in self.parents:\\n\\t\\t\\t\\tself.parents[y] = y\\n\\n\\t\\t\\tparent_x, parent_y = find(x), find(y)\\n\\t\\t\\tif parent_x == parent_y:\\n\\t\\t\\t\\treturn\\n\\t\\t\\tself.parents[parent_x] = parent_y\\n\\n\\t\\t# persons currently with secrets, will update later\\n\\t\\tperson_with_secret = set([0, firstPerson])\\n\\n\\t\\tfor time, persons in meet_time:\\n\\t\\t\\tself.parents = {}\\n\\t\\t\\tfor x,y in persons:\\n\\t\\t\\t\\tunion(x,y) #get parents\\n\\n\\t\\t\\tgroups = defaultdict(set) # group persons that are connected within the current time\\n\\n\\t\\t\\t# get persons connected with same parent\\n\\t\\t\\tfor parent in self.parents:\\n\\t\\t\\t\\tgroups[find(parent)].add(parent)\\n\\n\\t\\t\\tfor grp in groups.values():\\n\\t\\t\\t\\t# if one person in a group is found in\\n\\t\\t\\t\\t# persons_with_secret set add the entire group to the set\\n\\t\\t\\t\\tif grp.intersection(person_with_secret):\\n\\t\\t\\t\\t\\tperson_with_secret.update(grp)\\n\\n\\t\\treturn list(person_with_secret)",
                "codeTag": "Python3"
            },
            {
                "id": 1964523,
                "title": "union-find-in-python",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def getParent(self, parent, x):\\n        if parent[x] == x:\\n            return x\\n        parent[x] = self.getParent(parent, parent[x])\\n        return parent[x]\\n    \\n    def connect(self, parent, a, b):\\n        parent[self.getParent(parent, a)] = self.getParent(parent, b)\\n        \\n    def isConnected(self, parent, a, b):\\n        return self.getParent(parent, a) == self.getParent(parent, b)\\n    \\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        parent = list(range(n))\\n        meets = defaultdict(list)\\n        for a, b, t in meetings:\\n            meets[t].append((a, b))\\n        self.connect(parent, 0, firstPerson)\\n        people = set()\\n        for t in sorted(meets.keys()):\\n            people.clear()\\n            for a, b in meets[t]:\\n                self.connect(parent, a, b)\\n                people.update({a, b})\\n            for p in people:\\n                if not self.isConnected(parent, p, 0):\\n                    parent[p] = p\\n        return [i for i in range(n) if self.isConnected(parent, i, 0)]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def getParent(self, parent, x):\\n        if parent[x] == x:\\n            return x\\n        parent[x] = self.getParent(parent, parent[x])\\n        return parent[x]\\n    \\n    def connect(self, parent, a, b):\\n        parent[self.getParent(parent, a)] = self.getParent(parent, b)\\n        \\n    def isConnected(self, parent, a, b):\\n        return self.getParent(parent, a) == self.getParent(parent, b)\\n    \\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        parent = list(range(n))\\n        meets = defaultdict(list)\\n        for a, b, t in meetings:\\n            meets[t].append((a, b))\\n        self.connect(parent, 0, firstPerson)\\n        people = set()\\n        for t in sorted(meets.keys()):\\n            people.clear()\\n            for a, b in meets[t]:\\n                self.connect(parent, a, b)\\n                people.update({a, b})\\n            for p in people:\\n                if not self.isConnected(parent, p, 0):\\n                    parent[p] = p\\n        return [i for i in range(n) if self.isConnected(parent, i, 0)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1719215,
                "title": "details-of-several-easy-to-understand-python-solutions",
                "content": "#      DFS/BFS\\n## Solution 1\\n\\t \\nInitiate a secret group. Sort the meetings with the time. Traverse the meetings with a while loop, record who everyone meets at each moment in a map. Pause and investigate the persons who meet at the moment. Resume the loop afterwards.\\n\\nThe investigation of the meeting persons at each moment can be solved in the way similar to those for problems 128, 130 and 200 etc.  Here is a solution with BFS/DFS:\\n* Pop a person from the map, and find all the directly / indirectly related persons, i.e. the whole group which the person belongs to.  There are two ways to realize this and the current solution chose the 2) way: 1) Define a function and recursively find the directly related persons. 2) Maintain an extra data structure \"seeds\".  Pop the persons directly related to each seed from the map, and add new persons to \"seeds\".  Of course, add new persons in the group as well.\\n* Check if this group intersects with the secret group.  If yes, merge it into the secret group.\\n* While the map is not empty, pop another a person as the initial seed of another group ...\\n\\n```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        meetings.sort(key=lambda t: t[2])\\n        secret = {0, firstPerson}             # the initial secret group\\n\\n        i = 0\\n        while i < len(meetings):\\n            end = meetings[i][2]\\n            mp = defaultdict(set)              # a map of meeting persons at the moment\\n            while i < len(meetings) and meetings[i][2] == end:\\n                a, b, _ = meetings[i]\\n                mp[a].add(b)\\n                mp[b].add(a)\\n                i += 1\\n\\n            while mp:                          # people may meet in different groups at the moment\\n                seed = next(iter(mp))          # consider any remaining one as the first seed of a group\\n                seeds, group = {seed}, {seed}  # initiate the group which the seed belongs to\\n                while seeds:\\n                    meets = mp.pop(seeds.pop()) - group   # consider a seed and who else the seed meets\\n                    seeds |= meets                        # add new persons to the seed only!\\n                    group |= meets                        # add them into the group of course\\n\\n                if group & secret:             # if anyone in this group knows the secret\\n                    secret |= group            # add the whole group into the secret group\\n                    if len(secret) == n:       # quick exit if possible\\n                        return list(secret)\\n\\n        return list(secret)\\n```\\n\\t\\t\\n## Solution 2\\n\\nCan be considered as a variant of solution 1.  Traverse the list of meetings.  Record meetings under the time in a Hash map.  Then traverse the sorted keys and retrieve the meetings at each moment.\\n\\n```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        secret = {0, firstPerson}             # the initial secret group\\n        moments = defaultdict(set)\\n        for a, b, t in meetings:\\n            moments[t].add((a, b))\\n\\n        for t in sorted(moments):\\n            mp = defaultdict(set)              # a map of meeting persons at the moment\\n            for a, b in moments[t]:\\n                mp[a].add(b)\\n                mp[b].add(a)\\n\\n            while mp:                          # people may meet in different groups at the moment\\n                seed = next(iter(mp))          # consider any remaining one as the first seed of a group\\n                seeds, group = {seed}, {seed}  # initiate the group which the seed belongs to\\n                while seeds:\\n                    meets = mp.pop(seeds.pop()) - group   # consider a seed and who else the seed meets\\n                    seeds |= meets                        # add new persons to the seed only!\\n                    group |= meets                        # add them into the group of course\\n\\n                if group & secret:             # if anyone in this group knows the secret\\n                    secret |= group            # add the whole group into the secret group\\n                    if len(secret) == n:       # quick exit if possible\\n                        return list(secret)\\n\\n        return list(secret)\\n```\\n\\n# Union find\\nInitiate a secret group.  Traverse the list of meetings.  Record meetings under the time in a Hash map.  Then traverse the sorted keys and retrieve the meetings at each moment. For each moment, use the union find algorithm to process the meetings.\\n*      (Re-)Initiate a map, \"father\".  Forgive me for its name.\\n*      Go through each meeting.  If a participant is new, add her/him into the map.  Merge both participants\\' groups.\\n*      At the end, group all the participants in the map, based on their \"fathers\".\\n*      If a group intersects with the secret group, merge the former into the latter.\\n\\n```\\nclass Solution:\\n\\n    def find(self, x: int):\\n        if self.father[x] == x:\\n            return x\\n        else:\\n            self.father[x] = self.find(self.father[x])\\n            return self.father[x]\\n\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        meetings.sort(key=lambda t: t[2])\\n        secret = {0, firstPerson}             # the initial secret group\\n\\n        i = 0\\n        while i < len(meetings):\\n            end = meetings[i][2]\\n            self.father = {}                   # initiate a map at each moment\\n            while i < len(meetings) and meetings[i][2] == end:\\n                a, b, _ = meetings[i]\\n                if a not in self.father:           # add new participant into the map\\n                    self.father[a] = a\\n                if b not in self.father:\\n                    self.father[b] = b\\n                a = self.find(a)                   # merge(), no need to be defined as a method\\n                b = self.find(b)\\n                self.father[b] = a\\n                i += 1\\n\\n            groups = defaultdict(set)              # group(), no need to be defined as a method.\\n            for x in self.father:\\n                groups[self.find(x)].add(x)\\n            for group in groups.values():          # for each group\\n                if group & secret:                 # someone knows the secret\\n                    secret |= group                # the whole group now knows the secret\\n        return list(secret)\\n```\\n\\n# Union find II. One union\\nIn all the previous solutions, grouping is started over for each batch (at the same time) of meetings. This is because those groups in which no one knows the secret must be dismissed for later investigations.\\nWhat if we dismiss the no-secret groups with extra options? Then we can use the same union from the beginning to the end. After each sub-loop, we reset all non-zero parents to the items themselves. It will be too time-consuming to simply iterate the whole union. We need to memorize which items have been assigned so that we could check only their parents. \\n\\n```\\nclass Solution:\\n\\n\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        meetings.sort(key=lambda t: t[2])\\n        union = [i for i in range(n)]\\n        union[firstPerson] = 0\\n\\n        def find(x: int):\\n            if union[x] == x:\\n                return x\\n            else:\\n                union[x] = find(union[x])\\n                return union[x]\\n\\n        i = 0\\n        while i < len(meetings):\\n            end = meetings[i][2]\\n            snapshot = set()\\n            while i < len(meetings) and meetings[i][2] == end:\\n                a, b, _ = meetings[i]\\n                snapshot |= {a, b}\\n                a = find(a)             # union, no need to be defined as a method\\n                b = find(b)\\n                if a > b:\\n                    union[a] = b\\n                else:\\n                    union[b] = a\\n                i += 1\\n\\n            for x in snapshot:\\n                if find(x):\\n                    union[x] = x\\n\\n        return [x for x in range(n) if not find(x)]\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        meetings.sort(key=lambda t: t[2])\\n        secret = {0, firstPerson}             # the initial secret group\\n\\n        i = 0\\n        while i < len(meetings):\\n            end = meetings[i][2]\\n            mp = defaultdict(set)              # a map of meeting persons at the moment\\n            while i < len(meetings) and meetings[i][2] == end:\\n                a, b, _ = meetings[i]\\n                mp[a].add(b)\\n                mp[b].add(a)\\n                i += 1\\n\\n            while mp:                          # people may meet in different groups at the moment\\n                seed = next(iter(mp))          # consider any remaining one as the first seed of a group\\n                seeds, group = {seed}, {seed}  # initiate the group which the seed belongs to\\n                while seeds:\\n                    meets = mp.pop(seeds.pop()) - group   # consider a seed and who else the seed meets\\n                    seeds |= meets                        # add new persons to the seed only!\\n                    group |= meets                        # add them into the group of course\\n\\n                if group & secret:             # if anyone in this group knows the secret\\n                    secret |= group            # add the whole group into the secret group\\n                    if len(secret) == n:       # quick exit if possible\\n                        return list(secret)\\n\\n        return list(secret)\\n```\n```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        secret = {0, firstPerson}             # the initial secret group\\n        moments = defaultdict(set)\\n        for a, b, t in meetings:\\n            moments[t].add((a, b))\\n\\n        for t in sorted(moments):\\n            mp = defaultdict(set)              # a map of meeting persons at the moment\\n            for a, b in moments[t]:\\n                mp[a].add(b)\\n                mp[b].add(a)\\n\\n            while mp:                          # people may meet in different groups at the moment\\n                seed = next(iter(mp))          # consider any remaining one as the first seed of a group\\n                seeds, group = {seed}, {seed}  # initiate the group which the seed belongs to\\n                while seeds:\\n                    meets = mp.pop(seeds.pop()) - group   # consider a seed and who else the seed meets\\n                    seeds |= meets                        # add new persons to the seed only!\\n                    group |= meets                        # add them into the group of course\\n\\n                if group & secret:             # if anyone in this group knows the secret\\n                    secret |= group            # add the whole group into the secret group\\n                    if len(secret) == n:       # quick exit if possible\\n                        return list(secret)\\n\\n        return list(secret)\\n```\n```\\nclass Solution:\\n\\n    def find(self, x: int):\\n        if self.father[x] == x:\\n            return x\\n        else:\\n            self.father[x] = self.find(self.father[x])\\n            return self.father[x]\\n\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        meetings.sort(key=lambda t: t[2])\\n        secret = {0, firstPerson}             # the initial secret group\\n\\n        i = 0\\n        while i < len(meetings):\\n            end = meetings[i][2]\\n            self.father = {}                   # initiate a map at each moment\\n            while i < len(meetings) and meetings[i][2] == end:\\n                a, b, _ = meetings[i]\\n                if a not in self.father:           # add new participant into the map\\n                    self.father[a] = a\\n                if b not in self.father:\\n                    self.father[b] = b\\n                a = self.find(a)                   # merge(), no need to be defined as a method\\n                b = self.find(b)\\n                self.father[b] = a\\n                i += 1\\n\\n            groups = defaultdict(set)              # group(), no need to be defined as a method.\\n            for x in self.father:\\n                groups[self.find(x)].add(x)\\n            for group in groups.values():          # for each group\\n                if group & secret:                 # someone knows the secret\\n                    secret |= group                # the whole group now knows the secret\\n        return list(secret)\\n```\n```\\nclass Solution:\\n\\n\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        meetings.sort(key=lambda t: t[2])\\n        union = [i for i in range(n)]\\n        union[firstPerson] = 0\\n\\n        def find(x: int):\\n            if union[x] == x:\\n                return x\\n            else:\\n                union[x] = find(union[x])\\n                return union[x]\\n\\n        i = 0\\n        while i < len(meetings):\\n            end = meetings[i][2]\\n            snapshot = set()\\n            while i < len(meetings) and meetings[i][2] == end:\\n                a, b, _ = meetings[i]\\n                snapshot |= {a, b}\\n                a = find(a)             # union, no need to be defined as a method\\n                b = find(b)\\n                if a > b:\\n                    union[a] = b\\n                else:\\n                    union[b] = a\\n                i += 1\\n\\n            for x in snapshot:\\n                if find(x):\\n                    union[x] = x\\n\\n        return [x for x in range(n) if not find(x)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665273,
                "title": "java-bfs-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        Set<Integer> known = new HashSet<>();\\n        known.add(0);\\n        known.add(firstPerson);\\n        \\n        Queue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n        for (int[] meeting : meetings) {\\n            pq.offer(meeting);\\n        }\\n        \\n        while (!pq.isEmpty()) {\\n            int[] cur = pq.poll();\\n            List<int[]> list = new ArrayList<>();\\n            list.add(cur);\\n            while (!pq.isEmpty() && pq.peek()[2] == cur[2]) {\\n                list.add(pq.poll());\\n            }\\n            int size = 0;\\n            while (known.size() > size) {\\n                size = known.size();\\n                for (int[] meeting : list) {\\n                    if (known.contains(meeting[0]) || known.contains(meeting[1])) {\\n                        known.add(meeting[0]);\\n                        known.add(meeting[1]);\\n                    }\\n                }\\n            }\\n        }\\n        return new ArrayList<>(known);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        Set<Integer> known = new HashSet<>();\\n        known.add(0);\\n        known.add(firstPerson);\\n        \\n        Queue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n        for (int[] meeting : meetings) {\\n            pq.offer(meeting);\\n        }\\n        \\n        while (!pq.isEmpty()) {\\n            int[] cur = pq.poll();\\n            List<int[]> list = new ArrayList<>();\\n            list.add(cur);\\n            while (!pq.isEmpty() && pq.peek()[2] == cur[2]) {\\n                list.add(pq.poll());\\n            }\\n            int size = 0;\\n            while (known.size() > size) {\\n                size = known.size();\\n                for (int[] meeting : list) {\\n                    if (known.contains(meeting[0]) || known.contains(meeting[1])) {\\n                        known.add(meeting[0]);\\n                        known.add(meeting[1]);\\n                    }\\n                }\\n            }\\n        }\\n        return new ArrayList<>(known);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1651690,
                "title": "c-simple-searches-at-each-unique-time",
                "content": "```\\n\\nstruct N {\\n    int id;\\n    bool secret;\\n    //time -> people to meet\\n    map<int, set<shared_ptr<N>>> neighbours;\\n};\\n\\nclass Solution {\\npublic:\\n    \\n    void expand(shared_ptr<N> node, int time){\\n        \\n        assert(node->secret==true);\\n        \\n        vector<shared_ptr<N>> nodes_to_expand;\\n        \\n        for(auto neighbour: node->neighbours[time]){\\n            if(!neighbour->secret){\\n                nodes_to_expand.push_back(neighbour);\\n            }\\n        }\\n        \\n        for(auto i: nodes_to_expand){\\n            i->secret = true;\\n        }\\n        \\n        node->neighbours.erase(time);\\n        \\n        for(auto i: nodes_to_expand){\\n            expand(i, time);\\n        }\\n    }\\n    \\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        \\n        vector<shared_ptr<N>> nodes;\\n        for(int i=0;i<n;++i){\\n            nodes.push_back(make_shared<N>(N{.id=i, .secret=false, .neighbours={}}));\\n        }\\n        \\n        nodes[0]->secret = true;\\n        nodes[firstPerson]->secret = true;\\n        \\n        map<int, set<shared_ptr<N>>> time_to_nodes_map;\\n        \\n        for(auto &i:meetings){\\n            int x = i[0];\\n            int y = i[1];\\n            int t = i[2];\\n            nodes[x]->neighbours[t].insert(nodes[y]);\\n            nodes[y]->neighbours[t].insert(nodes[x]);\\n            \\n            time_to_nodes_map[t].insert(nodes[x]);\\n            time_to_nodes_map[t].insert(nodes[y]);\\n        }\\n        \\n        for(auto &[t, nodes]: time_to_nodes_map){\\n            for(auto node: nodes){\\n                if(node->secret){\\n                    expand(node,t);\\n                }\\n            }\\n        }\\n        \\n        vector<int> ret;\\n        \\n        for(auto i: nodes){\\n            if(i->secret){\\n                ret.push_back(i->id);\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nstruct N {\\n    int id;\\n    bool secret;\\n    //time -> people to meet\\n    map<int, set<shared_ptr<N>>> neighbours;\\n};\\n\\nclass Solution {\\npublic:\\n    \\n    void expand(shared_ptr<N> node, int time){\\n        \\n        assert(node->secret==true);\\n        \\n        vector<shared_ptr<N>> nodes_to_expand;\\n        \\n        for(auto neighbour: node->neighbours[time]){\\n            if(!neighbour->secret){\\n                nodes_to_expand.push_back(neighbour);\\n            }\\n        }\\n        \\n        for(auto i: nodes_to_expand){\\n            i->secret = true;\\n        }\\n        \\n        node->neighbours.erase(time);\\n        \\n        for(auto i: nodes_to_expand){\\n            expand(i, time);\\n        }\\n    }\\n    \\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        \\n        vector<shared_ptr<N>> nodes;\\n        for(int i=0;i<n;++i){\\n            nodes.push_back(make_shared<N>(N{.id=i, .secret=false, .neighbours={}}));\\n        }\\n        \\n        nodes[0]->secret = true;\\n        nodes[firstPerson]->secret = true;\\n        \\n        map<int, set<shared_ptr<N>>> time_to_nodes_map;\\n        \\n        for(auto &i:meetings){\\n            int x = i[0];\\n            int y = i[1];\\n            int t = i[2];\\n            nodes[x]->neighbours[t].insert(nodes[y]);\\n            nodes[y]->neighbours[t].insert(nodes[x]);\\n            \\n            time_to_nodes_map[t].insert(nodes[x]);\\n            time_to_nodes_map[t].insert(nodes[y]);\\n        }\\n        \\n        for(auto &[t, nodes]: time_to_nodes_map){\\n            for(auto node: nodes){\\n                if(node->secret){\\n                    expand(node,t);\\n                }\\n            }\\n        }\\n        \\n        vector<int> ret;\\n        \\n        for(auto i: nodes){\\n            if(i->secret){\\n                ret.push_back(i->id);\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630798,
                "title": "union-find-without-grouping-or-bfs",
                "content": "For each person, we create an array [timestamp, meet]: \\u201Ctimestamp\\u201D records the most recent meeting a person joined before hearing the secret, and \\u201Cmeet\\u201D records whom a person met most recently before hearing the secret. \\n\\nIf person i and j meet at time t, we union i and j via the \\u201Cmeet\\u201D parameter. Bui if i and j do not hear the secret at time t, when they join another meeting later, say t+1, we will break the union between i and j by reseting the record to [t+1,i] for person i, and to [t+1,j] for person j\\n\\n\\n```\\n def findAllPeople(self, n: int, meetings: List[List[int]], first: int) -> List[int]:\\n\\t\\t\\tmeetings=sorted(meetings+[[0,first,0]], key=lambda x: x[2])\\n\\n\\t\\t\\tfirst = 0\\n\\n\\t\\t\\tdp=[[0,i] for i in range(n+1)]   #[timestamp, meet]\\n\\n\\t\\t\\tdef find(x):\\n\\t\\t\\t\\tif dp[x][1]!=x:\\n\\t\\t\\t\\t\\tif dp[x][0]>=dp[dp[x][1]][0]: #check if the person who x unions at time t joins another meeting without x later\\n\\t\\t\\t\\t\\t\\tdp[x][1]=find(dp[x][1])\\n\\t\\t\\t\\treturn dp[x][1]\\n\\n\\n\\t\\t\\tfor i,j,k in meetings:  \\n\\t\\t\\t\\t#no need to reset the records for person i,j if they already know the secret or meet someone else at time k\\n\\t\\t\\t\\tif dp[i][0]<k and find(i)!=first:\\n\\t\\t\\t\\t\\t dp[i]=[k,i]\\n\\t\\t\\t\\tif dp[j][0]<k and find(j)!=first:\\n\\t\\t\\t\\t\\t dp[j]=[k,j]\\n\\n\\t\\t\\t\\t#union person i,j\\n\\t\\t\\t\\tif find(i)==first:\\n\\t\\t\\t\\t\\tdp[find(j)][1]=first\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tdp[find(i)][1]=find(j)\\n\\n\\n\\t\\t\\treturn [i for i in range(n+1) if find(i)==first]\\n\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\n def findAllPeople(self, n: int, meetings: List[List[int]], first: int) -> List[int]:\\n\\t\\t\\tmeetings=sorted(meetings+[[0,first,0]], key=lambda x: x[2])\\n\\n\\t\\t\\tfirst = 0\\n\\n\\t\\t\\tdp=[[0,i] for i in range(n+1)]   #[timestamp, meet]\\n\\n\\t\\t\\tdef find(x):\\n\\t\\t\\t\\tif dp[x][1]!=x:\\n\\t\\t\\t\\t\\tif dp[x][0]>=dp[dp[x][1]][0]: #check if the person who x unions at time t joins another meeting without x later\\n\\t\\t\\t\\t\\t\\tdp[x][1]=find(dp[x][1])\\n\\t\\t\\t\\treturn dp[x][1]\\n\\n\\n\\t\\t\\tfor i,j,k in meetings:  \\n\\t\\t\\t\\t#no need to reset the records for person i,j if they already know the secret or meet someone else at time k\\n\\t\\t\\t\\tif dp[i][0]<k and find(i)!=first:\\n\\t\\t\\t\\t\\t dp[i]=[k,i]\\n\\t\\t\\t\\tif dp[j][0]<k and find(j)!=first:\\n\\t\\t\\t\\t\\t dp[j]=[k,j]\\n\\n\\t\\t\\t\\t#union person i,j\\n\\t\\t\\t\\tif find(i)==first:\\n\\t\\t\\t\\t\\tdp[find(j)][1]=first\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tdp[find(i)][1]=find(j)\\n\\n\\n\\t\\t\\treturn [i for i in range(n+1) if find(i)==first]\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1629973,
                "title": "c-dsu",
                "content": "```\\nclass Solution {\\npublic:\\n    bool static cmp(vector<int>&a,vector<int>&b)\\n    {\\n        return a[2]<b[2];\\n    }\\n    //DSU start\\n    vector<int>parent;\\n    int find(int x)\\n    {\\n        if(x!=parent[x])\\n            parent[x]=find(parent[x]);\\n        return parent[x];\\n    }\\n    void Union(int x,int y)\\n    {\\n        parent[y]=x;\\n    }\\n    //DSU end\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meets, int first) \\n    {\\n        parent.resize(n);\\n        for(int i=0;i<n;i++)\\n            parent[i]=i;\\n        \\n        sort(meets.begin(),meets.end(),cmp);\\n        Union(0,first);\\n        int m=meets.size();\\n        vector<int>v;\\n        for(int i=0;i<m;)\\n        {\\n            int time=meets[i][2];\\n            v.clear();\\n            for(;i<m && meets[i][2]==time;i++)\\n            {\\n                v.push_back(meets[i][0]);\\n                v.push_back(meets[i][1]);\\n                int px=find(meets[i][0]),py=find(meets[i][1]);\\n                Union(px,py);   //Add all edges to graph\\n            }\\n            for(auto x:v)   //check for validity\\n            {\\n                int px=find(x),p0=find(0);\\n                if(px!=p0)   // If not valid then remove\\n                    parent[x]=x;\\n            }\\n        }\\n        vector<int>res{0};\\n        for(int i=1;i<n;i++)\\n        {\\n            int px=find(i),p0=find(0);\\n            if(px==p0)\\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool static cmp(vector<int>&a,vector<int>&b)\\n    {\\n        return a[2]<b[2];\\n    }\\n    //DSU start\\n    vector<int>parent;\\n    int find(int x)\\n    {\\n        if(x!=parent[x])\\n            parent[x]=find(parent[x]);\\n        return parent[x];\\n    }\\n    void Union(int x,int y)\\n    {\\n        parent[y]=x;\\n    }\\n    //DSU end\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meets, int first) \\n    {\\n        parent.resize(n);\\n        for(int i=0;i<n;i++)\\n            parent[i]=i;\\n        \\n        sort(meets.begin(),meets.end(),cmp);\\n        Union(0,first);\\n        int m=meets.size();\\n        vector<int>v;\\n        for(int i=0;i<m;)\\n        {\\n            int time=meets[i][2];\\n            v.clear();\\n            for(;i<m && meets[i][2]==time;i++)\\n            {\\n                v.push_back(meets[i][0]);\\n                v.push_back(meets[i][1]);\\n                int px=find(meets[i][0]),py=find(meets[i][1]);\\n                Union(px,py);   //Add all edges to graph\\n            }\\n            for(auto x:v)   //check for validity\\n            {\\n                int px=find(x),p0=find(0);\\n                if(px!=p0)   // If not valid then remove\\n                    parent[x]=x;\\n            }\\n        }\\n        vector<int>res{0};\\n        for(int i=1;i<n;i++)\\n        {\\n            int px=find(i),p0=find(0);\\n            if(px==p0)\\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1613064,
                "title": "97-c-bfs-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr);\\n        \\n        vector<vector<pair<int,int>>> graph(n);\\n        \\n        for(auto it:meetings)\\n        {  // undirected graph\\n            // on basis of: \\n            // which person meeting whom at which time\\n            graph[it[0]].push_back({it[1],it [2]});\\n            graph[it[1]].push_back({it[0],it [2]});\\n        }\\n        \\n        \\n        // here SHARING secrets is totally depend on time.\\n        // PRIORITY IS: Time\\n        \\n        // 1- > time\\n        // 2 -> persons \\n        // result -> which people can meet at sametime\\n        // creating MIN-HEAP\\n        priority_queue<pair<int,int>, vector<pair<int,int>> , greater<pair<int,int>> > q;\\n        \\n        // inserting person 0 and firstPerson -> as both meet at time 0\\n        q.push({0, firstPerson});\\n        q.push({0,0});\\n        \\n        vector<bool> visited(n,false);\\n        \\n        while(!q.empty())\\n        {\\n            pair<int,int> curr= q.top();\\n            q.pop();\\n            \\n            int time = curr.first;\\n            int person = curr.second;\\n            \\n            \\n            if(visited[person]) continue ;\\n            \\n            visited[person]=1;\\n        \\n            for(pair<int,int> aj: graph[person]) \\n            {\\n             \\n                if(!visited[aj.first] and aj.second >= time)\\n                {\\n                    // as queue is based on TIME priority\\n                    q.push({aj.second, aj.first});\\n                }\\n            }\\n               \\n        }\\n        \\n        \\n        vector<int> knowssec;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(visited[i]) knowssec.push_back(i);\\n        }\\n        \\n        return knowssec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr);\\n        \\n        vector<vector<pair<int,int>>> graph(n);\\n        \\n        for(auto it:meetings)\\n        {  // undirected graph\\n            // on basis of: \\n            // which person meeting whom at which time\\n            graph[it[0]].push_back({it[1],it [2]});\\n            graph[it[1]].push_back({it[0],it [2]});\\n        }\\n        \\n        \\n        // here SHARING secrets is totally depend on time.\\n        // PRIORITY IS: Time\\n        \\n        // 1- > time\\n        // 2 -> persons \\n        // result -> which people can meet at sametime\\n        // creating MIN-HEAP\\n        priority_queue<pair<int,int>, vector<pair<int,int>> , greater<pair<int,int>> > q;\\n        \\n        // inserting person 0 and firstPerson -> as both meet at time 0\\n        q.push({0, firstPerson});\\n        q.push({0,0});\\n        \\n        vector<bool> visited(n,false);\\n        \\n        while(!q.empty())\\n        {\\n            pair<int,int> curr= q.top();\\n            q.pop();\\n            \\n            int time = curr.first;\\n            int person = curr.second;\\n            \\n            \\n            if(visited[person]) continue ;\\n            \\n            visited[person]=1;\\n        \\n            for(pair<int,int> aj: graph[person]) \\n            {\\n             \\n                if(!visited[aj.first] and aj.second >= time)\\n                {\\n                    // as queue is based on TIME priority\\n                    q.push({aj.second, aj.first});\\n                }\\n            }\\n               \\n        }\\n        \\n        \\n        vector<int> knowssec;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(visited[i]) knowssec.push_back(i);\\n        }\\n        \\n        return knowssec;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1606605,
                "title": "why-only-using-dfs-not-working-here",
                "content": "1. Why Only using DFS not working hrere?\\n2. how priority_queue or sorting helping?\\n\\n\\t\\t\\tclass Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tvoid dfs(vector<vector<pair<int, int>>> &graph, int src, vector<int>&vis, int t){\\n\\n\\t\\t\\t\\t\\tvis[src] = 1;\\n\\n\\t\\t\\t\\t\\tfor(pair<int, int>nei : graph[src]){\\n\\t\\t\\t\\t\\t\\tif(vis[nei.first])\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\tif(t <= nei.second)\\n\\t\\t\\t\\t\\t\\t\\tdfs(graph, nei.first, vis, nei.second);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n\\n\\t\\t\\t\\t\\tvector<vector<pair<int, int>>> graph(n);\\n\\n\\t\\t\\t\\t\\tgraph[0].push_back({firstPerson, 0});\\n\\n\\t\\t\\t\\t\\tint m = meetings.size();\\n\\t\\t\\t\\t\\tfor(int i = 0; i < m; i++){\\n\\t\\t\\t\\t\\t\\tgraph[meetings[i][0]].push_back({meetings[i][1], meetings[i][2]});\\n\\t\\t\\t\\t\\t\\tgraph[meetings[i][1]].push_back({meetings[i][0], meetings[i][2]});\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tvector<int> vis(n, 0);\\n\\n\\t\\t\\t\\t\\tdfs(graph, 0, vis, 0);\\n\\n\\t\\t\\t\\t\\tvector<int> res;\\n\\t\\t\\t\\t\\tfor(int i = 0; i < n; i++){\\n\\t\\t\\t\\t\\t\\tif(vis[i])\\n\\t\\t\\t\\t\\t\\t\\tres.push_back(i);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn res;\\n\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tvoid dfs(vector<vector<pair<int, int>>> &graph, int src, vector<int>&vis, int t){\\n\\n\\t\\t\\t\\t\\tvis[src] = 1;\\n\\n\\t\\t\\t\\t\\tfor(pair<int, int>nei : graph[src]){\\n\\t\\t\\t\\t\\t\\tif(vis[nei.first])\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\tif(t <= nei.second)\\n\\t\\t\\t\\t\\t\\t\\tdfs(graph, nei.first, vis, nei.second);\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1606417,
                "title": "simple-python-dfs-solution",
                "content": "It\\'s another version of DFS search.\\nI don\\'t think it\\'s a hard problem but a bit more complicated medium problem.\\n\\n```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        \\n        visited = set([0, firstPerson])\\n        meetings.sort(key = lambda x: x[2])\\n        \\n        mapping = {}\\n        for x, y, time in meetings:\\n            if time not in mapping:\\n                mapping[time] = defaultdict(list)\\n            mapping[time][x].append(y)\\n            mapping[time][y].append(x)\\n        \\n        def dfs(m, x):\\n            visited.add(x)\\n            for key in m[x]:\\n                if key not in visited:\\n                    dfs(m, key)\\n        \\n        for time in mapping:\\n            m = mapping[time]\\n            for key in m:\\n                if key in visited:\\n                    dfs(m, key)\\n            \\n        return list(visited)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        \\n        visited = set([0, firstPerson])\\n        meetings.sort(key = lambda x: x[2])\\n        \\n        mapping = {}\\n        for x, y, time in meetings:\\n            if time not in mapping:\\n                mapping[time] = defaultdict(list)\\n            mapping[time][x].append(y)\\n            mapping[time][y].append(x)\\n        \\n        def dfs(m, x):\\n            visited.add(x)\\n            for key in m[x]:\\n                if key not in visited:\\n                    dfs(m, key)\\n        \\n        for time in mapping:\\n            m = mapping[time]\\n            for key in m:\\n                if key in visited:\\n                    dfs(m, key)\\n            \\n        return list(visited)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1605880,
                "title": "python-solution-based-on-connected-components",
                "content": "At each \"time\", some meetings will take place, we can represent those as undirected graph, where vertice is a person and edge mean meeting takes place.\\n\\nSo for each connected component in this graph, if one person knows the secret everyone will know the secret, thats my approach !\\n\\n```python\\nclass Solution(object):\\n    def findAllPeople(self, n, meetings, firstPerson):\\n        \"\"\"\\n        :type n: int\\n        :type meetings: List[List[int]]\\n        :type firstPerson: int\\n        :rtype: List[int]\\n        \"\"\"\\n        times = dict()\\n        known = set([firstPerson,0])\\n        \\n        for x,y,time in meetings:\\n            ad = times.setdefault(time, dict())\\n            ad.setdefault(x, []).append(y)\\n            ad.setdefault(y, []).append(x)\\n\\n        def DFS(node, graph, visited, comp):\\n            visited[node] = True \\n            comp.add(node)\\n            for child in graph[node]:\\n                if not visited[child]:\\n                    comp.add(child)\\n                    DFS(child, graph, visited, comp)\\n            \\n        for time in sorted(times.keys()):\\n            graph = times[time]\\n\\n            visited = dict(zip(graph.keys(), [False]*len(graph.keys())))\\n            it = iter(graph.keys())\\n            components = []\\n\\n            for node in it:\\n                if visited[node]:\\n                    continue\\n                c = set()\\n                DFS(node, graph, visited, c)\\n                components.append(c)\\n\\n            for c in components:\\n                if len(known.intersection(c)) > 0:\\n                    known.update(c)\\n\\n        return known\\n\\t```\\n\\t\\n\\t",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution(object):\\n    def findAllPeople(self, n, meetings, firstPerson):\\n        \"\"\"\\n        :type n: int\\n        :type meetings: List[List[int]]\\n        :type firstPerson: int\\n        :rtype: List[int]\\n        \"\"\"\\n        times = dict()\\n        known = set([firstPerson,0])\\n        \\n        for x,y,time in meetings:\\n            ad = times.setdefault(time, dict())\\n            ad.setdefault(x, []).append(y)\\n            ad.setdefault(y, []).append(x)\\n\\n        def DFS(node, graph, visited, comp):\\n            visited[node] = True \\n            comp.add(node)\\n            for child in graph[node]:\\n                if not visited[child]:\\n                    comp.add(child)\\n                    DFS(child, graph, visited, comp)\\n            \\n        for time in sorted(times.keys()):\\n            graph = times[time]\\n\\n            visited = dict(zip(graph.keys(), [False]*len(graph.keys())))\\n            it = iter(graph.keys())\\n            components = []\\n\\n            for node in it:\\n                if visited[node]:\\n                    continue\\n                c = set()\\n                DFS(node, graph, visited, c)\\n                components.append(c)\\n\\n            for c in components:\\n                if len(known.intersection(c)) > 0:\\n                    known.update(c)\\n\\n        return known\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1603514,
                "title": "java-dijkstra-disjoint-set-bfs",
                "content": "Dijkstra\\'s:\\n\\n```\\n   public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        List<int[]>[] graph = new List[n];\\n        for (int i = 0; i < n; i++) graph[i] = new ArrayList<>();\\n        for (int[] e : meetings) {\\n            graph[e[0]].add(new int[]{e[1], e[2]});\\n            graph[e[1]].add(new int[]{e[0], e[2]});\\n        }\\n\\n        List<Integer> ans = new ArrayList<>();\\n        int[] time = new int[n];\\n        Arrays.fill(time, Integer.MAX_VALUE);\\n        time[0] = 0;\\n        time[firstPerson] = 0;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->(a[0] - b[0])); //sort by time\\n        pq.add(new int[]{0, 0});  // time, person\\n        pq.add(new int[]{0, firstPerson});\\n        while (!pq.isEmpty()) {\\n            int[] top = pq.poll();\\n            int curr_time = top[0], ppl = top[1];\\n            if (curr_time > time[ppl]) continue; //already known the secret at earlier time\\n            ans.add(ppl);\\n            for (int[] nei : graph[ppl]) {\\n                int psn = nei[0], tm = nei[1];\\n                //if meeting time with psn(person) is >= time when ppl came to knnow secret AND\\n\\t\\t\\t\\t//time ppl is telling secret to psn<time when secret known to psn (int_max value when unknown)\\n                if(tm >= curr_time && tm < time[psn]){ \\n                    time[psn] = tm;\\n                    pq.add(new int[]{tm, psn});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\nUnionFind:\\n```\\npublic List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        Arrays.sort(meetings, (a,b)->a[2]-b[2]);\\n        UnionFind uf = new UnionFind(n);\\n        uf.union(0, firstPerson);\\n        \\n        int len = meetings.length, i=0;\\n        while(i<len){\\n            int currtime = meetings[i][2];\\n            Set<Integer> pool = new HashSet<>();\\n            while(i<len && currtime == meetings[i][2]){\\n                int[] m = meetings[i];\\n                uf.union(m[0], m[1]);\\n                pool.add(m[0]);\\n                pool.add(m[1]);\\n                i++;\\n            }\\n            for(int ele : pool){\\n                if(uf.find(ele) != uf.parent[0]) uf.reset(ele);\\n            }\\n        }\\n        List<Integer> al = new ArrayList<>();\\n        for(int j=0; j<n; j++){\\n            if(uf.parent[j]==uf.parent[0]) al.add(j);\\n        }\\n        return al;\\n    }\\n}\\npublic class UnionFind{\\n    int[] parent;\\n    int[] size;\\n    public UnionFind(int sz){\\n        this.parent = new int[sz];\\n        this.size = new int[sz]; \\n        for(int i=0; i<sz; i++){\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    public int find(int x){  // with Path Compression\\n        if(parent[x]==x) return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n    public void union(int x, int y){  // by size\\n        int rootx = find(x);\\n        int rooty = find(y);\\n        if (rootx != rooty) {\\n            if(size[rootx]>=size[rooty]){\\n                parent[rooty] = rootx;\\n                size[rootx]+=size[rooty];\\n            }\\n            else{\\n                parent[rootx] = rooty;\\n                size[rooty]+=size[rootx];\\n            }\\n        }\\n    }\\n    public void reset(int p) {\\n        parent[p] = p;\\n        size[p] = 1;\\n    }\\n}\\n```\\n\\nBFS:\\n```\\n   public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        List<int[]>[] graph = new List[n];\\n        for (int i = 0; i < n; i++) graph[i] = new ArrayList<>();\\n        for (int[] e : meetings) {\\n            graph[e[0]].add(new int[]{e[1], e[2]});\\n            graph[e[1]].add(new int[]{e[0], e[2]});\\n        }\\n        // BFS\\n        List<Integer> ans = new ArrayList<>();\\n        boolean[] vis = new boolean[n];\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->(a[0] - b[0]));\\n        pq.add(new int[]{0,0});\\n        pq.add(new int[]{0,firstPerson});\\n        while(!pq.isEmpty()){\\n            int[] top = pq.poll();\\n            int curr_time = top[0], ppl = top[1];\\n            if(vis[ppl]) continue;\\n            vis[ppl] = true;\\n            ans.add(ppl);\\n            for (int[] nei : graph[ppl]) {\\n                int psn = nei[0], tm = nei[1];\\n                if(tm >= curr_time && !vis[psn])\\n                    pq.add(new int[]{tm, psn});\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```\\n   public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        List<int[]>[] graph = new List[n];\\n        for (int i = 0; i < n; i++) graph[i] = new ArrayList<>();\\n        for (int[] e : meetings) {\\n            graph[e[0]].add(new int[]{e[1], e[2]});\\n            graph[e[1]].add(new int[]{e[0], e[2]});\\n        }\\n\\n        List<Integer> ans = new ArrayList<>();\\n        int[] time = new int[n];\\n        Arrays.fill(time, Integer.MAX_VALUE);\\n        time[0] = 0;\\n        time[firstPerson] = 0;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->(a[0] - b[0])); //sort by time\\n        pq.add(new int[]{0, 0});  // time, person\\n        pq.add(new int[]{0, firstPerson});\\n        while (!pq.isEmpty()) {\\n            int[] top = pq.poll();\\n            int curr_time = top[0], ppl = top[1];\\n            if (curr_time > time[ppl]) continue; //already known the secret at earlier time\\n            ans.add(ppl);\\n            for (int[] nei : graph[ppl]) {\\n                int psn = nei[0], tm = nei[1];\\n                //if meeting time with psn(person) is >= time when ppl came to knnow secret AND\\n\\t\\t\\t\\t//time ppl is telling secret to psn<time when secret known to psn (int_max value when unknown)\\n                if(tm >= curr_time && tm < time[psn]){ \\n                    time[psn] = tm;\\n                    pq.add(new int[]{tm, psn});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```\\npublic List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        Arrays.sort(meetings, (a,b)->a[2]-b[2]);\\n        UnionFind uf = new UnionFind(n);\\n        uf.union(0, firstPerson);\\n        \\n        int len = meetings.length, i=0;\\n        while(i<len){\\n            int currtime = meetings[i][2];\\n            Set<Integer> pool = new HashSet<>();\\n            while(i<len && currtime == meetings[i][2]){\\n                int[] m = meetings[i];\\n                uf.union(m[0], m[1]);\\n                pool.add(m[0]);\\n                pool.add(m[1]);\\n                i++;\\n            }\\n            for(int ele : pool){\\n                if(uf.find(ele) != uf.parent[0]) uf.reset(ele);\\n            }\\n        }\\n        List<Integer> al = new ArrayList<>();\\n        for(int j=0; j<n; j++){\\n            if(uf.parent[j]==uf.parent[0]) al.add(j);\\n        }\\n        return al;\\n    }\\n}\\npublic class UnionFind{\\n    int[] parent;\\n    int[] size;\\n    public UnionFind(int sz){\\n        this.parent = new int[sz];\\n        this.size = new int[sz]; \\n        for(int i=0; i<sz; i++){\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    public int find(int x){  // with Path Compression\\n        if(parent[x]==x) return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n    public void union(int x, int y){  // by size\\n        int rootx = find(x);\\n        int rooty = find(y);\\n        if (rootx != rooty) {\\n            if(size[rootx]>=size[rooty]){\\n                parent[rooty] = rootx;\\n                size[rootx]+=size[rooty];\\n            }\\n            else{\\n                parent[rootx] = rooty;\\n                size[rooty]+=size[rootx];\\n            }\\n        }\\n    }\\n    public void reset(int p) {\\n        parent[p] = p;\\n        size[p] = 1;\\n    }\\n}\\n```\n```\\n   public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        List<int[]>[] graph = new List[n];\\n        for (int i = 0; i < n; i++) graph[i] = new ArrayList<>();\\n        for (int[] e : meetings) {\\n            graph[e[0]].add(new int[]{e[1], e[2]});\\n            graph[e[1]].add(new int[]{e[0], e[2]});\\n        }\\n        // BFS\\n        List<Integer> ans = new ArrayList<>();\\n        boolean[] vis = new boolean[n];\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->(a[0] - b[0]));\\n        pq.add(new int[]{0,0});\\n        pq.add(new int[]{0,firstPerson});\\n        while(!pq.isEmpty()){\\n            int[] top = pq.poll();\\n            int curr_time = top[0], ppl = top[1];\\n            if(vis[ppl]) continue;\\n            vis[ppl] = true;\\n            ans.add(ppl);\\n            for (int[] nei : graph[ppl]) {\\n                int psn = nei[0], tm = nei[1];\\n                if(tm >= curr_time && !vis[psn])\\n                    pq.add(new int[]{tm, psn});\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601767,
                "title": "java-priorityqueue",
                "content": "```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        \\n        // p\\'s meeting schedule: unprocessedMeetings[p] with elements int[] {time, target}\\n        List<int[]>[] unprocessedMeetings = (List<int[]>[]) new List[n];\\n        Arrays.setAll(unprocessedMeetings, k -> new ArrayList<>());\\n        \\n        unprocessedMeetings[0].add(new int[] {0, firstPerson});\\n        unprocessedMeetings[firstPerson].add(new int[] {0, 0});\\n        for (int[] meeting : meetings) {\\n            unprocessedMeetings[meeting[0]].add(new int[] {meeting[2], meeting[1]});\\n            unprocessedMeetings[meeting[1]].add(new int[] {meeting[2], meeting[0]});\\n        }\\n        \\n        // PriorityQueue for int[] {t, p}: at time t, p is going to know the secrect\\n        PriorityQueue<int[]> goingToKnow = new PriorityQueue<>(Comparator.comparingInt(m -> m[0]));\\n        goingToKnow.offer(new int[] {0, 0});\\n        \\n        List<Integer> knows = new ArrayList<>();\\n        while(!goingToKnow.isEmpty()) {\\n            int[] g = goingToKnow.poll();\\n            \\n            int person = g[1];\\n            if (unprocessedMeetings[person].isEmpty())\\n                continue;\\n            \\n            knows.add(person);\\n            \\n            // the earliest time that person knows the secret\\n            int time = g[0];\\n            \\n            for (int[] meeting : unprocessedMeetings[person])\\n                if (meeting[0] >= time)\\n                    goingToKnow.offer(meeting);\\n            \\n            unprocessedMeetings[person].clear();\\n        }\\n        \\n        return knows;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        \\n        // p\\'s meeting schedule: unprocessedMeetings[p] with elements int[] {time, target}\\n        List<int[]>[] unprocessedMeetings = (List<int[]>[]) new List[n];\\n        Arrays.setAll(unprocessedMeetings, k -> new ArrayList<>());\\n        \\n        unprocessedMeetings[0].add(new int[] {0, firstPerson});\\n        unprocessedMeetings[firstPerson].add(new int[] {0, 0});\\n        for (int[] meeting : meetings) {\\n            unprocessedMeetings[meeting[0]].add(new int[] {meeting[2], meeting[1]});\\n            unprocessedMeetings[meeting[1]].add(new int[] {meeting[2], meeting[0]});\\n        }\\n        \\n        // PriorityQueue for int[] {t, p}: at time t, p is going to know the secrect\\n        PriorityQueue<int[]> goingToKnow = new PriorityQueue<>(Comparator.comparingInt(m -> m[0]));\\n        goingToKnow.offer(new int[] {0, 0});\\n        \\n        List<Integer> knows = new ArrayList<>();\\n        while(!goingToKnow.isEmpty()) {\\n            int[] g = goingToKnow.poll();\\n            \\n            int person = g[1];\\n            if (unprocessedMeetings[person].isEmpty())\\n                continue;\\n            \\n            knows.add(person);\\n            \\n            // the earliest time that person knows the secret\\n            int time = g[0];\\n            \\n            for (int[] meeting : unprocessedMeetings[person])\\n                if (meeting[0] >= time)\\n                    goingToKnow.offer(meeting);\\n            \\n            unprocessedMeetings[person].clear();\\n        }\\n        \\n        return knows;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601583,
                "title": "priority-queue-and-bfs",
                "content": "```\\n// user id, time\\nusing UT = pair<int, int>;\\n\\n// time, uid\\nusing TU = pair<int, int>;\\n\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        vector<vector<UT>> g(n);\\n        for (auto& m : meetings) {\\n            int u1 = m[0], u2 = m[1], t = m[2];\\n            g[u1].emplace_back(u2, t);\\n            g[u2].emplace_back(u1, t);\\n        }\\n        unordered_set<int> propagated;\\n        priority_queue<TU, vector<TU>, greater<>> pq;\\n        pq.emplace(0, 0);\\n        pq.emplace(0, firstPerson);\\n        unordered_set<int> ans;\\n        while (!pq.empty()) {\\n            auto [time, u] = pq.top(); pq.pop();\\n            ans.emplace(u);\\n            if (!propagated.count(u)) {\\n                propagated.emplace(u);\\n                for (auto [nid, ntime] : g[u]) {\\n                    if (time <= ntime) {\\n                        pq.emplace(ntime, nid);\\n                    }\\n                }\\n            }\\n        }\\n        return {begin(ans), end(ans)};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// user id, time\\nusing UT = pair<int, int>;\\n\\n// time, uid\\nusing TU = pair<int, int>;\\n\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        vector<vector<UT>> g(n);\\n        for (auto& m : meetings) {\\n            int u1 = m[0], u2 = m[1], t = m[2];\\n            g[u1].emplace_back(u2, t);\\n            g[u2].emplace_back(u1, t);\\n        }\\n        unordered_set<int> propagated;\\n        priority_queue<TU, vector<TU>, greater<>> pq;\\n        pq.emplace(0, 0);\\n        pq.emplace(0, firstPerson);\\n        unordered_set<int> ans;\\n        while (!pq.empty()) {\\n            auto [time, u] = pq.top(); pq.pop();\\n            ans.emplace(u);\\n            if (!propagated.count(u)) {\\n                propagated.emplace(u);\\n                for (auto [nid, ntime] : g[u]) {\\n                    if (time <= ntime) {\\n                        pq.emplace(ntime, nid);\\n                    }\\n                }\\n            }\\n        }\\n        return {begin(ans), end(ans)};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601447,
                "title": "java-union-find-partial-reset-of-union-find-on-time-change",
                "content": "```\\nclass Solution {\\n    static int P1= 0, P2= 1, TIME= 2;\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        int k= meetings.length;\\n        Arrays.sort(meetings, (a,b)->a[TIME]-b[TIME]);\\n\\n        int[] uf= new int[n];\\n        for(int i=0; i<n; i++) uf[i]= i;\\n        uf[firstPerson]= 0;\\n        int[] list= new int[2*k]; // list of people meeting at current time (can have dupes, doesn\\'t matter)\\n        for(int i=0, j=0, m; i<k; i=j){   // m: size of list\\n            m=0;\\n            int[] mi= meetings[i], mj= meetings[j];\\n            for(; j<k && mi[TIME]==mj[TIME]; j++, mj= j<k ? meetings[j]:null){\\n                list[m++]= mj[P1];\\n                list[m++]= mj[P2];\\n            }\\n            for(; i<j; i++, mi= i<k ? meetings[i]:null){\\n                union(uf, mi[P1], mi[P2]);\\n            }\\n            // reset union find for people who didn\\'t get the secret at this time\\n            for(int midx=0; midx<m; midx++)\\n                if(find(uf, list[midx])!=0) uf[list[midx]]= list[midx];\\n        }\\n        List<Integer> ans= new ArrayList<>();\\n        for(int i=0; i<n; i++)\\n            if(find(uf, i)==0) ans.add(i);\\n        return ans;\\n    }\\n    \\n    void union(int[] uf, int a, int b){\\n        int ufa= find(uf, a), ufb= find(uf, b);\\n        if(ufa<ufb) uf[ufb]= ufa;\\n        else if(ufb<ufa) uf[ufa]= ufb;\\n    }    \\n    \\n    int find(int[] uf, int a){\\n        while(a!=uf[a]) a= uf[a]= uf[uf[a]];\\n        return a;\\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    static int P1= 0, P2= 1, TIME= 2;\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        int k= meetings.length;\\n        Arrays.sort(meetings, (a,b)->a[TIME]-b[TIME]);\\n\\n        int[] uf= new int[n];\\n        for(int i=0; i<n; i++) uf[i]= i;\\n        uf[firstPerson]= 0;\\n        int[] list= new int[2*k]; // list of people meeting at current time (can have dupes, doesn\\'t matter)\\n        for(int i=0, j=0, m; i<k; i=j){   // m: size of list\\n            m=0;\\n            int[] mi= meetings[i], mj= meetings[j];\\n            for(; j<k && mi[TIME]==mj[TIME]; j++, mj= j<k ? meetings[j]:null){\\n                list[m++]= mj[P1];\\n                list[m++]= mj[P2];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1601346,
                "title": "graph-bfs-heap",
                "content": "# Graph + BFS + heap\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        meetings.sort(key=lambda x: x[2])\\n        ans = set([0, firstPerson])\\n        G=[[] for _ in range(n)]\\n        G[0].append((0,firstPerson))\\n        for i,j,t in meetings:\\n            G[i].append((t,j))\\n            G[j].append((t,i))\\n        visit = [False]*(n)\\n        dq = [(0,0)]\\n        heapq.heapify(dq)\\n        while dq:\\n            t,sman = heapq.heappop(dq)\\n            if visit[sman]!=True:\\n                visit[sman] = True\\n                for i in G[sman]:\\n                    if i[0]>=t:\\n                        heapq.heappush(dq,i)\\n                        ans.add(i[1])\\n        return list(ans)              \\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "# Graph + BFS + heap\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        meetings.sort(key=lambda x: x[2])\\n        ans = set([0, firstPerson])\\n        G=[[] for _ in range(n)]\\n        G[0].append((0,firstPerson))\\n        for i,j,t in meetings:\\n            G[i].append((t,j))\\n            G[j].append((t,i))\\n        visit = [False]*(n)\\n        dq = [(0,0)]\\n        heapq.heapify(dq)\\n        while dq:\\n            t,sman = heapq.heappop(dq)\\n            if visit[sman]!=True:\\n                visit[sman] = True\\n                for i in G[sman]:\\n                    if i[0]>=t:\\n                        heapq.heappush(dq,i)\\n                        ans.add(i[1])\\n        return list(ans)              \\n",
                "codeTag": "Python3"
            },
            {
                "id": 1601148,
                "title": "golang-clean-dsu-solution-with-explanation",
                "content": "```\\ntype DSU struct {\\n    parent []int\\n}\\n\\nfunc (d DSU) find(x int) int {\\n    if d.parent[x] != x {\\n        d.parent[x] = d.find(d.parent[x])\\n    }\\n    return d.parent[x]\\n}\\n\\nfunc (d DSU) union(x, y int) {\\n    d.parent[d.find(x)] = d.find(y)\\n}\\n\\nfunc newDSU(n int) DSU {\\n    p := make([]int, n)\\n    for i := range p {\\n        p[i] = i\\n    }\\n    return DSU{parent: p}\\n}\\n\\nfunc findAllPeople(n int, meetings [][]int, firstPerson int) []int {\\n    // sort meetings by time\\n    sort.Slice(meetings, func(i, j int) bool {return meetings[i][2] < meetings[j][2]})\\n    // init a disjoint set union with `n` elements and make 0 refer to firstPerson\\n    dsu := newDSU(n)\\n    dsu.union(0, firstPerson)\\n    \\n    // `cur` record the current time of the meeting \\n    cur := meetings[0][2]\\n    \\n    // `cache` record all person that have meeting in the same time\\n    cache := make(map[int]int)\\n    \\n    for i:=0; i<len(meetings); i++ {\\n        // reset `cur` and `cache` when meeting time changed\\n        if meetings[i][2] != cur {\\n            cur = meetings[i][2]\\n            \\n            // reset `dsu` elements; people attend the meeting in the same time may not be shared the secret\\n            for k, _ := range cache {\\n                if dsu.find(k) != firstPerson {\\n                    dsu.parent[k] = k\\n                }\\n            }\\n            cache = make(map[int]int)\\n        }\\n        cache[meetings[i][0]] = 0\\n        cache[meetings[i][1]] = 0\\n        // if a person in the meeting know the secret then union another person with this one\\n        if dsu.find(meetings[i][0]) == firstPerson {\\n            dsu.union(meetings[i][1], meetings[i][0])\\n        }else {\\n            dsu.union(meetings[i][0], meetings[i][1])\\n        }\\n\\n    }\\n    var res []int\\n    for i:=0; i<n; i++ {\\n        if dsu.find(i) == firstPerson{\\n            res = append(res, i)\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype DSU struct {\\n    parent []int\\n}\\n\\nfunc (d DSU) find(x int) int {\\n    if d.parent[x] != x {\\n        d.parent[x] = d.find(d.parent[x])\\n    }\\n    return d.parent[x]\\n}\\n\\nfunc (d DSU) union(x, y int) {\\n    d.parent[d.find(x)] = d.find(y)\\n}\\n\\nfunc newDSU(n int) DSU {\\n    p := make([]int, n)\\n    for i := range p {\\n        p[i] = i\\n    }\\n    return DSU{parent: p}\\n}\\n\\nfunc findAllPeople(n int, meetings [][]int, firstPerson int) []int {\\n    // sort meetings by time\\n    sort.Slice(meetings, func(i, j int) bool {return meetings[i][2] < meetings[j][2]})\\n    // init a disjoint set union with `n` elements and make 0 refer to firstPerson\\n    dsu := newDSU(n)\\n    dsu.union(0, firstPerson)\\n    \\n    // `cur` record the current time of the meeting \\n    cur := meetings[0][2]\\n    \\n    // `cache` record all person that have meeting in the same time\\n    cache := make(map[int]int)\\n    \\n    for i:=0; i<len(meetings); i++ {\\n        // reset `cur` and `cache` when meeting time changed\\n        if meetings[i][2] != cur {\\n            cur = meetings[i][2]\\n            \\n            // reset `dsu` elements; people attend the meeting in the same time may not be shared the secret\\n            for k, _ := range cache {\\n                if dsu.find(k) != firstPerson {\\n                    dsu.parent[k] = k\\n                }\\n            }\\n            cache = make(map[int]int)\\n        }\\n        cache[meetings[i][0]] = 0\\n        cache[meetings[i][1]] = 0\\n        // if a person in the meeting know the secret then union another person with this one\\n        if dsu.find(meetings[i][0]) == firstPerson {\\n            dsu.union(meetings[i][1], meetings[i][0])\\n        }else {\\n            dsu.union(meetings[i][0], meetings[i][1])\\n        }\\n\\n    }\\n    var res []int\\n    for i:=0; i<n; i++ {\\n        if dsu.find(i) == firstPerson{\\n            res = append(res, i)\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1600528,
                "title": "python3-bfs-priority-queue",
                "content": "```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        res = []\\n        seen = set()\\n        graph = collections.defaultdict(list)\\n        for a, b, t in meetings:\\n            graph[a].append((b, t))\\n            graph[b].append((a, t))\\n        \\n        q = [(0,0), (0,firstPerson)]\\n        heapq.heapify(q)\\n       \\n        while q:\\n            time, node = heapq.heappop(q)\\n            if node not in seen:\\n                res.append(node)\\n                seen.add(node)\\n                for nei, t in graph[node]:\\n                    if t>= time and nei not in seen:\\n                        heapq.heappush(q, (t, nei))\\n        return res\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        res = []\\n        seen = set()\\n        graph = collections.defaultdict(list)\\n        for a, b, t in meetings:\\n            graph[a].append((b, t))\\n            graph[b].append((a, t))\\n        \\n        q = [(0,0), (0,firstPerson)]\\n        heapq.heapify(q)\\n       \\n        while q:\\n            time, node = heapq.heappop(q)\\n            if node not in seen:\\n                res.append(node)\\n                seen.add(node)\\n                for nei, t in graph[node]:\\n                    if t>= time and nei not in seen:\\n                        heapq.heappush(q, (t, nei))\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600359,
                "title": "union-find-a-go-solution",
                "content": "I\\'m learning Golang recently, so just post this to practise the language. Hope it would help to someone new to Golang.\\n\\n```go\\ntype UF struct {\\n    n int\\n    p []int\\n}\\n\\nfunc (uf UF) init() {\\n    for i := 0; i < len(uf.p); i++ {\\n        uf.p[i] = i\\n    }\\n}\\nfunc (uf UF) union(x, y int) {\\n    px := uf.find(x)\\n    py := uf.find(y)\\n    \\n    if px != py {\\n        uf.p[px] = py\\n    }\\n}\\n\\nfunc (uf UF) find(x int) int {\\n    tx := x\\n    for x != uf.p[x] {\\n        x = uf.p[x]\\n    }\\n    \\n    for tx != x {\\n        tmp := uf.p[tx]\\n        uf.p[tx] = x\\n        tx = tmp\\n    }\\n    return x\\n}\\n\\nfunc (uf UF) unset(x int) {\\n    uf.p[x] = x\\n}\\n\\ntype ByThird [][]int\\n\\nfunc (s ByThird) Len() int {\\n\\treturn len(s)\\n}\\nfunc (s ByThird) Swap(i, j int) {\\n\\ts[i], s[j] = s[j], s[i]\\n}\\nfunc (s ByThird) Less(i, j int) bool {\\n\\treturn s[i][2] < s[j][2]\\n}\\n\\nfunc findAllPeople(n int, meetings [][]int, firstPerson int) []int {\\n    \\n    uf := UF{n, make([]int, n)}\\n    uf.init()\\n    uf.union(0, firstPerson)    \\n    \\n    sort.Sort(ByThird(meetings))\\n    \\n    i := 0\\n    \\n    for i < len(meetings) {\\n        time := meetings[i][2]\\n        line := []int{}\\n        for i < len(meetings) && meetings[i][2] == time {\\n            line = append(line, meetings[i][0])\\n            line = append(line, meetings[i][1])\\n            uf.union(meetings[i][0], meetings[i][1])\\n            i += 1\\n        }\\n        root := uf.find(0)\\n        for _, e := range line {\\n            if uf.find(e) != root {\\n                uf.unset(e)\\n            }\\n        }\\n    }\\n    root := uf.find(0)\\n    res := []int{}\\n    for i := 0; i < n; i++ {\\n        if uf.find(i) == root {\\n            res = append(res, i)\\n        }\\n    } \\n    return res\\n}\\n```\\n\\nA  concise version:\\n\\n```go\\ntype UF struct {\\n    n int\\n    p []int\\n}\\n\\nfunc (uf UF) init() {\\n    for i := 0; i < len(uf.p); i++ {\\n        uf.p[i] = i\\n    }\\n}\\nfunc (uf UF) union(x, y int) {\\n    px := uf.find(x)\\n    py := uf.find(y)\\n    \\n    if px != py {\\n        uf.p[px] = py\\n    }\\n}\\n\\nfunc (uf UF) find(x int) int {\\n    tx := x\\n    for x != uf.p[x] {\\n        x = uf.p[x]\\n    }\\n    \\n    for tx != x {\\n        tmp := uf.p[tx]\\n        uf.p[tx] = x\\n        tx = tmp\\n    }\\n    return x\\n}\\n\\nfunc (uf UF) unset(x int) {\\n    uf.p[x] = x\\n}\\n\\nfunc findAllPeople(n int, meetings [][]int, firstPerson int) []int {\\n    uf := UF{n, make([]int, n)}\\n    uf.init()\\n    uf.union(0, firstPerson)    \\n    \\n    sort.Slice(meetings, func (i, j int) bool {\\n        return meetings[i][2] < meetings[j][2]\\n    })\\n    \\n    i := 0\\n    \\n    for i < len(meetings) {\\n        time := meetings[i][2]\\n        line := make(map[int]bool)\\n        for i < len(meetings) && meetings[i][2] == time {\\n            line[meetings[i][0]] = true\\n            line[meetings[i][1]] = true\\n            uf.union(meetings[i][0], meetings[i][1])\\n            i += 1\\n        }\\n        root := uf.find(0)\\n        for k, _ := range line {\\n            if uf.find(k) != root {\\n                uf.unset(k)\\n            }\\n        }\\n    }\\n    root := uf.find(0)\\n    res := []int{}\\n    for i := 0; i < n; i++ {\\n        if uf.find(i) == root {\\n            res = append(res, i)\\n        }\\n    } \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```go\\ntype UF struct {\\n    n int\\n    p []int\\n}\\n\\nfunc (uf UF) init() {\\n    for i := 0; i < len(uf.p); i++ {\\n        uf.p[i] = i\\n    }\\n}\\nfunc (uf UF) union(x, y int) {\\n    px := uf.find(x)\\n    py := uf.find(y)\\n    \\n    if px != py {\\n        uf.p[px] = py\\n    }\\n}\\n\\nfunc (uf UF) find(x int) int {\\n    tx := x\\n    for x != uf.p[x] {\\n        x = uf.p[x]\\n    }\\n    \\n    for tx != x {\\n        tmp := uf.p[tx]\\n        uf.p[tx] = x\\n        tx = tmp\\n    }\\n    return x\\n}\\n\\nfunc (uf UF) unset(x int) {\\n    uf.p[x] = x\\n}\\n\\ntype ByThird [][]int\\n\\nfunc (s ByThird) Len() int {\\n\\treturn len(s)\\n}\\nfunc (s ByThird) Swap(i, j int) {\\n\\ts[i], s[j] = s[j], s[i]\\n}\\nfunc (s ByThird) Less(i, j int) bool {\\n\\treturn s[i][2] < s[j][2]\\n}\\n\\nfunc findAllPeople(n int, meetings [][]int, firstPerson int) []int {\\n    \\n    uf := UF{n, make([]int, n)}\\n    uf.init()\\n    uf.union(0, firstPerson)    \\n    \\n    sort.Sort(ByThird(meetings))\\n    \\n    i := 0\\n    \\n    for i < len(meetings) {\\n        time := meetings[i][2]\\n        line := []int{}\\n        for i < len(meetings) && meetings[i][2] == time {\\n            line = append(line, meetings[i][0])\\n            line = append(line, meetings[i][1])\\n            uf.union(meetings[i][0], meetings[i][1])\\n            i += 1\\n        }\\n        root := uf.find(0)\\n        for _, e := range line {\\n            if uf.find(e) != root {\\n                uf.unset(e)\\n            }\\n        }\\n    }\\n    root := uf.find(0)\\n    res := []int{}\\n    for i := 0; i < n; i++ {\\n        if uf.find(i) == root {\\n            res = append(res, i)\\n        }\\n    } \\n    return res\\n}\\n```\n```go\\ntype UF struct {\\n    n int\\n    p []int\\n}\\n\\nfunc (uf UF) init() {\\n    for i := 0; i < len(uf.p); i++ {\\n        uf.p[i] = i\\n    }\\n}\\nfunc (uf UF) union(x, y int) {\\n    px := uf.find(x)\\n    py := uf.find(y)\\n    \\n    if px != py {\\n        uf.p[px] = py\\n    }\\n}\\n\\nfunc (uf UF) find(x int) int {\\n    tx := x\\n    for x != uf.p[x] {\\n        x = uf.p[x]\\n    }\\n    \\n    for tx != x {\\n        tmp := uf.p[tx]\\n        uf.p[tx] = x\\n        tx = tmp\\n    }\\n    return x\\n}\\n\\nfunc (uf UF) unset(x int) {\\n    uf.p[x] = x\\n}\\n\\nfunc findAllPeople(n int, meetings [][]int, firstPerson int) []int {\\n    uf := UF{n, make([]int, n)}\\n    uf.init()\\n    uf.union(0, firstPerson)    \\n    \\n    sort.Slice(meetings, func (i, j int) bool {\\n        return meetings[i][2] < meetings[j][2]\\n    })\\n    \\n    i := 0\\n    \\n    for i < len(meetings) {\\n        time := meetings[i][2]\\n        line := make(map[int]bool)\\n        for i < len(meetings) && meetings[i][2] == time {\\n            line[meetings[i][0]] = true\\n            line[meetings[i][1]] = true\\n            uf.union(meetings[i][0], meetings[i][1])\\n            i += 1\\n        }\\n        root := uf.find(0)\\n        for k, _ := range line {\\n            if uf.find(k) != root {\\n                uf.unset(k)\\n            }\\n        }\\n    }\\n    root := uf.find(0)\\n    res := []int{}\\n    for i := 0; i < n; i++ {\\n        if uf.find(i) == root {\\n            res = append(res, i)\\n        }\\n    } \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1600088,
                "title": "java-sort-and-dfs",
                "content": "```\\npublic List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n\\t\\tSet<Integer> set = new HashSet<>();\\n\\t\\tset.add(0);\\n\\t\\tset.add(firstPerson);\\n\\t\\t// sort by time\\n\\t\\tArrays.sort(meetings, Comparator.comparingInt(a -> a[2]));\\n\\n\\t\\tfor (int i = 0; i < meetings.length; ) {\\n\\t\\t\\tif (set.size() == n) return new ArrayList<>(set);\\n\\t\\t\\t// get graph\\n\\t\\t\\tHashMap<Integer, List<Integer>> map = new HashMap<>();\\n\\t\\t\\tint j = i;\\n\\t\\t\\twhile (j < meetings.length && meetings[j][2] == meetings[i][2]) {\\n\\t\\t\\t\\tint[] m = meetings[j];\\n\\t\\t\\t\\tmap.putIfAbsent(m[0], new ArrayList<>());\\n\\t\\t\\t\\tmap.putIfAbsent(m[1], new ArrayList<>());\\n\\t\\t\\t\\tmap.get(m[0]).add(m[1]);\\n\\t\\t\\t\\tmap.get(m[1]).add(m[0]);\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// get start node\\n\\t\\t\\tSet<Integer> tmp = new HashSet<>(map.keySet());\\n\\t\\t\\ttmp.retainAll(set);\\n\\t\\t\\tfor (Integer start : tmp) {\\n\\t\\t\\t\\tdfs(start, map, set);\\n\\t\\t\\t}\\n\\t\\t\\ti = j;\\n\\t\\t}\\n\\n\\t\\treturn new ArrayList<>(set);\\n\\t}\\n\\n\\tprivate void dfs(Integer start, HashMap<Integer, List<Integer>> map, Set<Integer> set) {\\n\\t\\tList<Integer> path = map.get(start);\\n\\t\\tfor (int i = 0; i < path.size(); i++) {\\n\\t\\t\\t// continue if visited\\n\\t\\t\\tif (set.contains(path.get(i))) continue;\\n\\t\\t\\tset.add(path.get(i));\\n\\t\\t\\tdfs(path.get(i), map, set);\\n\\t\\t}\\n\\t}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Sorting"
                ],
                "code": "```\\npublic List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n\\t\\tSet<Integer> set = new HashSet<>();\\n\\t\\tset.add(0);\\n\\t\\tset.add(firstPerson);\\n\\t\\t// sort by time\\n\\t\\tArrays.sort(meetings, Comparator.comparingInt(a -> a[2]));\\n\\n\\t\\tfor (int i = 0; i < meetings.length; ) {\\n\\t\\t\\tif (set.size() == n) return new ArrayList<>(set);\\n\\t\\t\\t// get graph\\n\\t\\t\\tHashMap<Integer, List<Integer>> map = new HashMap<>();\\n\\t\\t\\tint j = i;\\n\\t\\t\\twhile (j < meetings.length && meetings[j][2] == meetings[i][2]) {\\n\\t\\t\\t\\tint[] m = meetings[j];\\n\\t\\t\\t\\tmap.putIfAbsent(m[0], new ArrayList<>());\\n\\t\\t\\t\\tmap.putIfAbsent(m[1], new ArrayList<>());\\n\\t\\t\\t\\tmap.get(m[0]).add(m[1]);\\n\\t\\t\\t\\tmap.get(m[1]).add(m[0]);\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// get start node\\n\\t\\t\\tSet<Integer> tmp = new HashSet<>(map.keySet());\\n\\t\\t\\ttmp.retainAll(set);\\n\\t\\t\\tfor (Integer start : tmp) {\\n\\t\\t\\t\\tdfs(start, map, set);\\n\\t\\t\\t}\\n\\t\\t\\ti = j;\\n\\t\\t}\\n\\n\\t\\treturn new ArrayList<>(set);\\n\\t}\\n\\n\\tprivate void dfs(Integer start, HashMap<Integer, List<Integer>> map, Set<Integer> set) {\\n\\t\\tList<Integer> path = map.get(start);\\n\\t\\tfor (int i = 0; i < path.size(); i++) {\\n\\t\\t\\t// continue if visited\\n\\t\\t\\tif (set.contains(path.get(i))) continue;\\n\\t\\t\\tset.add(path.get(i));\\n\\t\\t\\tdfs(path.get(i), map, set);\\n\\t\\t}\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1600072,
                "title": "python-union-find-shortish",
                "content": "```py\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        uf = [i for i in range(n)]\\n        uf[firstPerson] = 0\\n        def find(v):\\n            if uf[v] != v:\\n                uf[v] = find(uf[v])\\n            return uf[v]\\n        \\n        secrets = set([0, firstPerson])\\n        \\n        def getSecretsPeople(meetT: list[list[int]]):\\n            \\'\\'\\'call this function in sequence for each subset of meetings with same time\\'\\'\\'\\n            for p1, p2, time in meetT:\\n                a = find(p1)\\n                b = find(p2)\\n                if a == 0 or b == 0:\\n                    uf[a] = uf[b] = 0\\n                else:\\n                    uf[a] = uf[b]\\n            for p1, p2, time in meetT:\\n                if find(p1) == 0 or find(p2) == 0:\\n                    secrets.add(p1)\\n                    secrets.add(p2)\\n                else:\\n                    uf[p2] = p2\\n                    uf[p1] = p1\\n\\n        meetings.sort(key = lambda x: x[2])\\n        timeGroups = groupby(meetings, lambda x: x[2])\\n        for key, group in timeGroups:\\n            getSecretsPeople(list(group))\\n    \\n        return list(secrets)\\n```",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        uf = [i for i in range(n)]\\n        uf[firstPerson] = 0\\n        def find(v):\\n            if uf[v] != v:\\n                uf[v] = find(uf[v])\\n            return uf[v]\\n        \\n        secrets = set([0, firstPerson])\\n        \\n        def getSecretsPeople(meetT: list[list[int]]):\\n            \\'\\'\\'call this function in sequence for each subset of meetings with same time\\'\\'\\'\\n            for p1, p2, time in meetT:\\n                a = find(p1)\\n                b = find(p2)\\n                if a == 0 or b == 0:\\n                    uf[a] = uf[b] = 0\\n                else:\\n                    uf[a] = uf[b]\\n            for p1, p2, time in meetT:\\n                if find(p1) == 0 or find(p2) == 0:\\n                    secrets.add(p1)\\n                    secrets.add(p2)\\n                else:\\n                    uf[p2] = p2\\n                    uf[p1] = p1\\n\\n        meetings.sort(key = lambda x: x[2])\\n        timeGroups = groupby(meetings, lambda x: x[2])\\n        for key, group in timeGroups:\\n            getSecretsPeople(list(group))\\n    \\n        return list(secrets)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600022,
                "title": "c-union-find-with-explanation",
                "content": "Step 1:\\nAt first, all people belong to their own group, `p[i] = i`.\\nSince person 0 is the root, we can make group 0 as the \"known group\".\\nThen, the `firstPerson` knows the secret, we union 0 and `firstPerson`, i.e. `p[firstPerson] = 0`.\\n\\nStep 2: \\nSort all meetings with time ascendingly, and scan them one by one.\\nGroup all pairs of people have meeting at the same time `t`, and check if any of them belong to the \"known group\":\\n- If so, then all of these people belong to the \"known group\"\\n- If not, they belong to their original group;\\n\\nStep 3:\\nFor all people from `0` to `n - 1`, check their group, if belongs to group 0, then s/he knew the secret.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> p;\\n    int find(int x) {\\n        if(x != p[x]) p[x] = find(p[x]);\\n        return p[x];\\n    }\\n    vector<int> findAllPeople(int n, vector<vector<int>>& A, int x) {\\n        sort(A.begin(), A.end(), \\n            [](const vector<int>& a, const vector<int>& b) {\\n                return a[2] < b[2];\\n            });\\n        p.resize(n);\\n        for (int i = 0; i < n; i++) p[i] = i;\\n        \\n        int i = 0;\\n        p[x] = 0; // connect (0, x)\\n        // since person 0 is the known person\\n        // we make group 0, i.e. find(i) == 0, to be the \"known group\";\\n        while(i < A.size()) {\\n            int t = A[i][2];\\n            unordered_set<int> seen;\\n            // find the group of people at time t\\n            while(i < A.size() && A[i][2] == t) {\\n                int px = find(A[i][0]);\\n                int py = find(A[i][1]);\\n                \\n                \\n                // always make the larger group id points to the smaller group id\\n                // so the group-0 can always be the known group;\\n                if (px != py) p[max(px, py)] = min(px, py);\\n                seen.insert(A[i][0]), seen.insert(A[i][1]);\\n                i++;\\n            }\\n            // important:\\n            // if none of these people belongs to group 0\\n            // none of them known the secrets, \\n            // put them in their original group, i.e. p[k] = k\\n            for (int j: seen) {\\n                if (find(j)) p[j] = j;\\n            }\\n        }\\n        \\n        // find all person belongs to group 0\\n        vector<int> res;\\n        for (int j = 0; j < n; j++)\\n            if (!find(j)) res.push_back(j);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> p;\\n    int find(int x) {\\n        if(x != p[x]) p[x] = find(p[x]);\\n        return p[x];\\n    }\\n    vector<int> findAllPeople(int n, vector<vector<int>>& A, int x) {\\n        sort(A.begin(), A.end(), \\n            [](const vector<int>& a, const vector<int>& b) {\\n                return a[2] < b[2];\\n            });\\n        p.resize(n);\\n        for (int i = 0; i < n; i++) p[i] = i;\\n        \\n        int i = 0;\\n        p[x] = 0; // connect (0, x)\\n        // since person 0 is the known person\\n        // we make group 0, i.e. find(i) == 0, to be the \"known group\";\\n        while(i < A.size()) {\\n            int t = A[i][2];\\n            unordered_set<int> seen;\\n            // find the group of people at time t\\n            while(i < A.size() && A[i][2] == t) {\\n                int px = find(A[i][0]);\\n                int py = find(A[i][1]);\\n                \\n                \\n                // always make the larger group id points to the smaller group id\\n                // so the group-0 can always be the known group;\\n                if (px != py) p[max(px, py)] = min(px, py);\\n                seen.insert(A[i][0]), seen.insert(A[i][1]);\\n                i++;\\n            }\\n            // important:\\n            // if none of these people belongs to group 0\\n            // none of them known the secrets, \\n            // put them in their original group, i.e. p[k] = k\\n            for (int j: seen) {\\n                if (find(j)) p[j] = j;\\n            }\\n        }\\n        \\n        // find all person belongs to group 0\\n        vector<int> res;\\n        for (int j = 0; j < n; j++)\\n            if (!find(j)) res.push_back(j);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600008,
                "title": "easy-to-understand-well-written-dsu-solution",
                "content": "```\\nclass Solution {\\n    int parent[100005];\\n    int vis[100005];\\npublic:\\n    int find(int v) {\\n        if (v == parent[v]) return v;\\n        return parent[v] = find(parent[v]);\\n    }\\n\\n    vector<int> findAllPeople(int n, vector<vector<int>>& a, int f) {\\n        memset(vis, 0, sizeof(vis));\\n        vis[0] = vis[f] = 1;\\n        for(int i = 0; i <= n; i++)  parent[i] = i;\\n        map<int, vector<array<int, 2> > > edge;\\n        for(auto i : a) {\\n            edge[i[2]].push_back({i[0], i[1]});\\n        }\\n        \\n        for(auto [c, d] : edge) {\\n            for(auto e : d) {\\n                int a = find(e[0]), b = find(e[1]);\\n                parent[a] = b;\\n                vis[b] |= vis[a];\\n            }\\n            for(auto e : d) {\\n                if(vis[find(e[0])]) vis[e[0]] = 1;\\n                if(vis[find(e[1])]) vis[e[1]] = 1;\\n            }\\n            for(auto e : d) {\\n                parent[e[0]] = e[0];\\n                parent[e[1]] = e[1];\\n            }\\n        }        \\n        vector<int> ans;\\n        for(int i = 0; i < n; i++) if(vis[i]) ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    int parent[100005];\\n    int vis[100005];\\npublic:\\n    int find(int v) {\\n        if (v == parent[v]) return v;\\n        return parent[v] = find(parent[v]);\\n    }\\n\\n    vector<int> findAllPeople(int n, vector<vector<int>>& a, int f) {\\n        memset(vis, 0, sizeof(vis));\\n        vis[0] = vis[f] = 1;\\n        for(int i = 0; i <= n; i++)  parent[i] = i;\\n        map<int, vector<array<int, 2> > > edge;\\n        for(auto i : a) {\\n            edge[i[2]].push_back({i[0], i[1]});\\n        }\\n        \\n        for(auto [c, d] : edge) {\\n            for(auto e : d) {\\n                int a = find(e[0]), b = find(e[1]);\\n                parent[a] = b;\\n                vis[b] |= vis[a];\\n            }\\n            for(auto e : d) {\\n                if(vis[find(e[0])]) vis[e[0]] = 1;\\n                if(vis[find(e[1])]) vis[e[1]] = 1;\\n            }\\n            for(auto e : d) {\\n                parent[e[0]] = e[0];\\n                parent[e[1]] = e[1];\\n            }\\n        }        \\n        vector<int> ans;\\n        for(int i = 0; i < n; i++) if(vis[i]) ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599940,
                "title": "solved-why-does-dijkstra-tle-ed",
                "content": "I am not able to understand why does my dijkstra solution TLE-ed. The complexity of dijkstra is O(ElogV) => O(MlogN)\\n\\n```\\nfrom heapq import heapify, heappush, heappop\\n\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        secret = [-1 for _ in range(n)]\\n        secret[0] = 0\\n        secret[firstPerson] = 0\\n        graph = [[] for _ in range(n)]\\n        for x, y, t in meetings:\\n            graph[x].append((y, t))\\n            graph[y].append((x, t))\\n            \\n        q = [(0, 0), (0, firstPerson)]\\n        heapify(q)\\n        while len(q) > 0:\\n            _, x = heappop(q)\\n            for y, t in graph[x]:\\n                if secret[x] <= t and (secret[y] == -1 or secret[y] > t):\\n                    secret[y] = t\\n                    heappush(q, (t, y))\\n        return [i for i in range(n) if secret[i] != -1]\\n```\\n\\n**UPDATE**\\nThe algorithm written above is **not** O(ElogV), because if I add a person P with current best time as T and then after sometime found that the best time for that person P is T - x (where x > 0) then I am not removing it from heap, which results in relaxing the edges of this person multiple times.\\n\\nThe fix is to check whether the top person in heap has some better time, if it has then just dont process the person.\\n\\nIn short:\\n```\\n while len(q) > 0:\\n\\tst, x = heappop(q)\\n\\tif st > secret[x]: #// <-- this is the fix\\n\\t\\tcontinue\\n\\t...\\n```\\n\\nFixed code (AC):\\n```\\nfrom heapq import heapify, heappush, heappop\\n\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        secret = [-1 for _ in range(n)]\\n        secret[0] = 0\\n        secret[firstPerson] = 0\\n        graph = [[] for _ in range(n)]\\n        for x, y, t in meetings:\\n            graph[x].append((y, t))\\n            graph[y].append((x, t))\\n            \\n        q = [(0, 0), (0, firstPerson)]\\n        heapify(q)\\n        while len(q) > 0:\\n            st, x = heappop(q)\\n            if st > secret[x]:\\n                continue\\n            for y, t in graph[x]:\\n                if secret[x] <= t and (secret[y] == -1 or secret[y] > t):\\n                    secret[y] = t\\n                    heappush(q, (t, y))\\n        return [i for i in range(n) if secret[i] != -1]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom heapq import heapify, heappush, heappop\\n\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        secret = [-1 for _ in range(n)]\\n        secret[0] = 0\\n        secret[firstPerson] = 0\\n        graph = [[] for _ in range(n)]\\n        for x, y, t in meetings:\\n            graph[x].append((y, t))\\n            graph[y].append((x, t))\\n            \\n        q = [(0, 0), (0, firstPerson)]\\n        heapify(q)\\n        while len(q) > 0:\\n            _, x = heappop(q)\\n            for y, t in graph[x]:\\n                if secret[x] <= t and (secret[y] == -1 or secret[y] > t):\\n                    secret[y] = t\\n                    heappush(q, (t, y))\\n        return [i for i in range(n) if secret[i] != -1]\\n```\n```\\n while len(q) > 0:\\n\\tst, x = heappop(q)\\n\\tif st > secret[x]: #// <-- this is the fix\\n\\t\\tcontinue\\n\\t...\\n```\n```\\nfrom heapq import heapify, heappush, heappop\\n\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        secret = [-1 for _ in range(n)]\\n        secret[0] = 0\\n        secret[firstPerson] = 0\\n        graph = [[] for _ in range(n)]\\n        for x, y, t in meetings:\\n            graph[x].append((y, t))\\n            graph[y].append((x, t))\\n            \\n        q = [(0, 0), (0, firstPerson)]\\n        heapify(q)\\n        while len(q) > 0:\\n            st, x = heappop(q)\\n            if st > secret[x]:\\n                continue\\n            for y, t in graph[x]:\\n                if secret[x] <= t and (secret[y] == -1 or secret[y] > t):\\n                    secret[y] = t\\n                    heappush(q, (t, y))\\n        return [i for i in range(n) if secret[i] != -1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599896,
                "title": "python-union-find-explained-2400ms",
                "content": "This solution takes advantage of the union find algorithm. Since all the meeting times are denoted by a specific integer, we store all these meetings in a dictionary with time as a key. We start by doing a union between person 0 and firstPerson. We then iterate through each time period and do a union find on all the relationships in that time period. To optimize time, we also keep track of every person we observed in a meeting during that time period in `intermediate_seen`. After processing all the meetings in that time period, we check to see if the parent is 0 or not for every person in `intermediate_seen`. If the parent is not 0 (which means secret hasn\\'t been shared), then we reset the parent back to itself (undoing the union find so it doesn\\'t mess up subsequent calculations). After processing all time periods, the persons who received the secret will have parent 0. \\n\\n\\n```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        from collections import defaultdict\\n        time_store = defaultdict(list)\\n        parents = [i for i in range(n)]\\n        for x,y,t in meetings:\\n            time_store[t].append((x,y))\\n        def find(x):\\n            if parents[x] != x:\\n                parents[x] = find(parents[x])\\n            return parents[x]\\n        def union(x,y):\\n            px,py = find(x),find(y)\\n            if px == 0:\\n                px,py=py,px\\n            parents[px] = py\\n        \\n        union(0,firstPerson)\\n        for time in sorted(time_store.keys()):\\n            intermediate_seen = set()\\n            for x,y in time_store[time]:\\n                union(x,y)\\n                intermediate_seen.add(x)\\n                intermediate_seen.add(y)\\n            \\n            for val in intermediate_seen:\\n                find(val)\\n                if parents[val] != 0:\\n                    parents[val] = val    \\n        return [i for i in range(len(parents)) if find(i) == 0]",
                "solutionTags": [],
                "code": "This solution takes advantage of the union find algorithm. Since all the meeting times are denoted by a specific integer, we store all these meetings in a dictionary with time as a key. We start by doing a union between person 0 and firstPerson. We then iterate through each time period and do a union find on all the relationships in that time period. To optimize time, we also keep track of every person we observed in a meeting during that time period in `intermediate_seen`. After processing all the meetings in that time period, we check to see if the parent is 0 or not for every person in `intermediate_seen`. If the parent is not 0 (which means secret hasn\\'t been shared), then we reset the parent back to itself (undoing the union find so it doesn\\'t mess up subsequent calculations). After processing all time periods, the persons who received the secret will have parent 0. \\n\\n\\n```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        from collections import defaultdict\\n        time_store = defaultdict(list)\\n        parents = [i for i in range(n)]\\n        for x,y,t in meetings:\\n            time_store[t].append((x,y))\\n        def find(x):\\n            if parents[x] != x:\\n                parents[x] = find(parents[x])\\n            return parents[x]\\n        def union(x,y):\\n            px,py = find(x),find(y)\\n            if px == 0:\\n                px,py=py,px\\n            parents[px] = py\\n        \\n        union(0,firstPerson)\\n        for time in sorted(time_store.keys()):\\n            intermediate_seen = set()\\n            for x,y in time_store[time]:\\n                union(x,y)\\n                intermediate_seen.add(x)\\n                intermediate_seen.add(y)\\n            \\n            for val in intermediate_seen:\\n                find(val)\\n                if parents[val] != 0:\\n                    parents[val] = val    \\n        return [i for i in range(len(parents)) if find(i) == 0]",
                "codeTag": "Java"
            },
            {
                "id": 1599837,
                "title": "python-typical-dsu-with-little-tricks",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        p, find, union = make_dsu(n)\\n        union(0, firstPerson) # t = 0\\n        \\n        g = defaultdict(list) # group meetings by time frames\\n        for x, y, t in meetings:\\n            g[t].append((x, y))\\n        \\n        for t, pairs in sorted(g.items(), key=lambda e: e[0]): # iterate groups by time (ASC)\\n            seen = set()\\n            for a, b in pairs:\\n                union(a, b)\\n                seen |= {a, b}\\n            # for any person appears in the current time frame:\\n            #   remove all its relations if it is not in the same disjoint set with `0` as of the current time frame\\n            for a in seen:\\n                if find(a) != find(0):\\n                    p[a] = a\\n        return [i for i in range(n) if find(i) == find(0)]\\n\\ndef make_dsu(n):\\n    p = [i for i in range(n)]\\n    def find(x):\\n        if p[x] != x:\\n            p[x] = find(p[x])\\n        return p[x]\\n    def union(x, y):\\n        px = find(x)\\n        py = find(y)\\n        if px != py:\\n            p[px] = py\\n    return p, find, union\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        p, find, union = make_dsu(n)\\n        union(0, firstPerson) # t = 0\\n        \\n        g = defaultdict(list) # group meetings by time frames\\n        for x, y, t in meetings:\\n            g[t].append((x, y))\\n        \\n        for t, pairs in sorted(g.items(), key=lambda e: e[0]): # iterate groups by time (ASC)\\n            seen = set()\\n            for a, b in pairs:\\n                union(a, b)\\n                seen |= {a, b}\\n            # for any person appears in the current time frame:\\n            #   remove all its relations if it is not in the same disjoint set with `0` as of the current time frame\\n            for a in seen:\\n                if find(a) != find(0):\\n                    p[a] = a\\n        return [i for i in range(n) if find(i) == find(0)]\\n\\ndef make_dsu(n):\\n    p = [i for i in range(n)]\\n    def find(x):\\n        if p[x] != x:\\n            p[x] = find(p[x])\\n        return p[x]\\n    def union(x, y):\\n        px = find(x)\\n        py = find(y)\\n        if px != py:\\n            p[px] = py\\n    return p, find, union\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599832,
                "title": "python-dfs",
                "content": "```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        meetings.sort(key=lambda meeting:meeting[2])\\n        st = set()\\n        st.add(0)\\n        st.add(firstPerson)\\n        n = len(meetings)\\n        i = 0\\n        \\n        def dfs(node, parent, localgraph):\\n            nonlocal st\\n            if node in st:\\n                return\\n            for nb in localgraph[node]:\\n                if nb not in st and nb!=parent:\\n                    dfs(nb, node, localgraph)\\n            st = st | localgraph[node]\\n        \\n        while i<n:\\n            meet = meetings[i]\\n            notseen = set()\\n            localgraph = defaultdict(set)\\n            localgraph[meet[0]].add(meet[1])\\n            localgraph[meet[1]].add(meet[0])\\n            if meet[0] in st or meet[1] in st:\\n                st.add(meet[0])\\n                st.add(meet[1])\\n            else:\\n                notseen.add(meet[0])\\n                notseen.add(meet[1])\\n            \\n            j = i + 1\\n            while j<n and meetings[j][2]==meet[2]:\\n                meet2 = meetings[j]\\n                localgraph[meet2[0]].add(meet2[1])\\n                localgraph[meet2[1]].add(meet2[0])\\n                if meet2[0] in st or meet2[1] in st:\\n                    if meet2[0] in st:\\n                        if meet2[1] in notseen:\\n                            dfs(meet2[1], -1, localgraph)\\n                    elif meet2[1] in st:\\n                        if meet2[0] in notseen:\\n                            dfs(meet2[0], -1, localgraph)\\n                    st.add(meet2[0])\\n                    st.add(meet2[1])\\n                else:\\n                    notseen.add(meet2[0])\\n                    notseen.add(meet2[1])\\n                j += 1\\n            i = j\\n        return list(st)     \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        meetings.sort(key=lambda meeting:meeting[2])\\n        st = set()\\n        st.add(0)\\n        st.add(firstPerson)\\n        n = len(meetings)\\n        i = 0\\n        \\n        def dfs(node, parent, localgraph):\\n            nonlocal st\\n            if node in st:\\n                return\\n            for nb in localgraph[node]:\\n                if nb not in st and nb!=parent:\\n                    dfs(nb, node, localgraph)\\n            st = st | localgraph[node]\\n        \\n        while i<n:\\n            meet = meetings[i]\\n            notseen = set()\\n            localgraph = defaultdict(set)\\n            localgraph[meet[0]].add(meet[1])\\n            localgraph[meet[1]].add(meet[0])\\n            if meet[0] in st or meet[1] in st:\\n                st.add(meet[0])\\n                st.add(meet[1])\\n            else:\\n                notseen.add(meet[0])\\n                notseen.add(meet[1])\\n            \\n            j = i + 1\\n            while j<n and meetings[j][2]==meet[2]:\\n                meet2 = meetings[j]\\n                localgraph[meet2[0]].add(meet2[1])\\n                localgraph[meet2[1]].add(meet2[0])\\n                if meet2[0] in st or meet2[1] in st:\\n                    if meet2[0] in st:\\n                        if meet2[1] in notseen:\\n                            dfs(meet2[1], -1, localgraph)\\n                    elif meet2[1] in st:\\n                        if meet2[0] in notseen:\\n                            dfs(meet2[0], -1, localgraph)\\n                    st.add(meet2[0])\\n                    st.add(meet2[1])\\n                else:\\n                    notseen.add(meet2[0])\\n                    notseen.add(meet2[1])\\n                j += 1\\n            i = j\\n        return list(st)     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599827,
                "title": "java-solution-using-priority-queue",
                "content": "The main idea to realise here is that two persons can have meeting more than 1 time.\\nOne person in the meeting might not have secret first time but might have it second or third or fourth time.\\nSo we need to take track of the minimum time when a person gets the secret and greedily give the secret to all other meeting attendees after he got the secret for the very first time.\\nWe can use PriorityQueue of int[] to keep track of person with time to receive the secret the first time.\\nThen we keep pulling out the lastest/top of queue and add all the other persons to the queue who have a meeting with top person after the top person receive secret.\\n\\nSame person might end up in the PriorityQueue multiple time.\\nTo avoid adding other attendees more than once to the PriorityQueue, we can clear the graph after adding all attendees for the first time\\n\\nIf it helps, You can also visualize it as a wighted undirected graph and try to apply Dijkstra.\\nFor this you need to convert undirected graph to directed graph by adding 2 directed node with same weight.\\nFinal cost of reaching a node in this would be first time the person has a meeting with some one with secret.\\n\\n```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        // graph[i] hash will have all the meeting attendees with incresing time of meeting\\n        HashMap<Integer, TreeSet<Integer>>[] graph = buildGraph(n, meetings);\\n        \\n        // PriorityQueue to keep track of latest person to receive secret after person 0 and firstPerson\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(new Comparator<int[]>(){\\n            public int compare(int[] a, int[] b) {\\n                return Integer.compare(a[1], b[1]);\\n            }\\n        });\\n\\n        // add everyone who has a meeting with person 0 to priority queue\\n        for(int key : graph[0].keySet()) {\\n            pq.offer(new int[]{key, graph[0].get(key).first()});\\n        }\\n        graph[0].clear();\\n        \\n        // add everyone who has a meeting with firstPerson to priority queue\\n        for(int key : graph[firstPerson].keySet()) {\\n            pq.offer(new int[]{key, graph[firstPerson].get(key).first()});\\n        }\\n        graph[firstPerson].clear();\\n\\n        Set<Integer> secrets =  new HashSet<>();\\n        secrets.add(0);\\n        secrets.add(firstPerson);\\n        \\n        while(!pq.isEmpty()) {\\n            int[] a = pq.poll();\\n            \\n            secrets.add(a[0]);\\n            for(int key : graph[a[0]].keySet()) {\\n                for(int time : graph[a[0]].get(key)) {\\n                    if (time >= a[1]) {\\n                        pq.offer(new int[]{key, time});\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            // clear the graph so that we don\\'t add the persons attneding meeting with same person again to priority queue\\n            graph[a[0]].clear();\\n        }\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        for(int num : secrets) {\\n            ans.add(num);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private HashMap<Integer, TreeSet<Integer>>[] buildGraph(int n, int[][] meetings) {\\n        HashMap<Integer, TreeSet<Integer>>[] graph = new HashMap[n];\\n        for(int i = 0; i < n; i++) {\\n            graph[i] = new HashMap<Integer, TreeSet<Integer>>();\\n        }\\n        \\n        for(int[] meeting : meetings) {\\n            if (!graph[meeting[0]].containsKey(meeting[1])) {\\n                graph[meeting[0]].put(meeting[1], new TreeSet<Integer>());\\n            }\\n            graph[meeting[0]].get(meeting[1]).add(meeting[2]);\\n            \\n            if (!graph[meeting[1]].containsKey(meeting[0])) {\\n                graph[meeting[1]].put(meeting[0], new TreeSet<Integer>());\\n            }\\n            graph[meeting[1]].get(meeting[0]).add(meeting[2]);\\n        }\\n        \\n        return graph;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        // graph[i] hash will have all the meeting attendees with incresing time of meeting\\n        HashMap<Integer, TreeSet<Integer>>[] graph = buildGraph(n, meetings);\\n        \\n        // PriorityQueue to keep track of latest person to receive secret after person 0 and firstPerson\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(new Comparator<int[]>(){\\n            public int compare(int[] a, int[] b) {\\n                return Integer.compare(a[1], b[1]);\\n            }\\n        });\\n\\n        // add everyone who has a meeting with person 0 to priority queue\\n        for(int key : graph[0].keySet()) {\\n            pq.offer(new int[]{key, graph[0].get(key).first()});\\n        }\\n        graph[0].clear();\\n        \\n        // add everyone who has a meeting with firstPerson to priority queue\\n        for(int key : graph[firstPerson].keySet()) {\\n            pq.offer(new int[]{key, graph[firstPerson].get(key).first()});\\n        }\\n        graph[firstPerson].clear();\\n\\n        Set<Integer> secrets =  new HashSet<>();\\n        secrets.add(0);\\n        secrets.add(firstPerson);\\n        \\n        while(!pq.isEmpty()) {\\n            int[] a = pq.poll();\\n            \\n            secrets.add(a[0]);\\n            for(int key : graph[a[0]].keySet()) {\\n                for(int time : graph[a[0]].get(key)) {\\n                    if (time >= a[1]) {\\n                        pq.offer(new int[]{key, time});\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            // clear the graph so that we don\\'t add the persons attneding meeting with same person again to priority queue\\n            graph[a[0]].clear();\\n        }\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        for(int num : secrets) {\\n            ans.add(num);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private HashMap<Integer, TreeSet<Integer>>[] buildGraph(int n, int[][] meetings) {\\n        HashMap<Integer, TreeSet<Integer>>[] graph = new HashMap[n];\\n        for(int i = 0; i < n; i++) {\\n            graph[i] = new HashMap<Integer, TreeSet<Integer>>();\\n        }\\n        \\n        for(int[] meeting : meetings) {\\n            if (!graph[meeting[0]].containsKey(meeting[1])) {\\n                graph[meeting[0]].put(meeting[1], new TreeSet<Integer>());\\n            }\\n            graph[meeting[0]].get(meeting[1]).add(meeting[2]);\\n            \\n            if (!graph[meeting[1]].containsKey(meeting[0])) {\\n                graph[meeting[1]].put(meeting[0], new TreeSet<Integer>());\\n            }\\n            graph[meeting[1]].get(meeting[0]).add(meeting[2]);\\n        }\\n        \\n        return graph;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599819,
                "title": "javascript-bfs-graph-unionfind-2-solutions",
                "content": "```javascript\\nvar findAllPeople = function(n, meetings, firstPerson) {\\n    const timeToMeeting = mapSortedTimeToMeetings(meetings);\\n    \\n    const peopleThatCurrentlyHaveSecret = new Set([0, firstPerson]);\\n    for (const peopleInMeetings of timeToMeeting.values()) {\\n        const personToMeetingsWithPeople = \\n            mapPeopleToPeopleTheyAreHavingMeetingsWith(peopleInMeetings);\\n        let peopleInMeetingsWithSecret = \\n            findPeopleThatHaveTheSecret(peopleInMeetings, peopleThatCurrentlyHaveSecret);\\n        \\n        // BFS algorithm\\n        while (peopleInMeetingsWithSecret.size > 0) {\\n            const nextPeopleInMeetingsWithSecret = new Set();\\n            for (const attendee of peopleInMeetingsWithSecret) {\\n                for (const personInMeetingWithAttendee of personToMeetingsWithPeople[attendee]) {\\n\\n                    // only add new people that have the secret otherwise there will be an\\n                    // infinite loop\\n                    if (!peopleThatCurrentlyHaveSecret.has(personInMeetingWithAttendee)) {\\n                        nextPeopleInMeetingsWithSecret.add(personInMeetingWithAttendee);\\n                        peopleThatCurrentlyHaveSecret.add(personInMeetingWithAttendee);\\n                    }\\n                }\\n            }\\n            peopleInMeetingsWithSecret = nextPeopleInMeetingsWithSecret;\\n        }\\n    }\\n    return [...peopleThatCurrentlyHaveSecret];\\n};\\n\\n// groups all the meetings by time\\n// keys (time) is sorted in ascending order\\nfunction mapSortedTimeToMeetings(meetings) {\\n    meetings.sort((a, b) => a[2] - b[2]);\\n\\n    const timeToMeeting = new Map();\\n    for (const [person1, person2, time] of meetings) {\\n        if (!timeToMeeting.has(time)) {\\n            timeToMeeting.set(time, []);\\n        }\\n        timeToMeeting.get(time).push([person1, person2]);\\n    }\\n    return timeToMeeting;\\n}\\n\\n// creates an adjacency list of people and people they are having meetings with\\nfunction mapPeopleToPeopleTheyAreHavingMeetingsWith(peopleInMeetings) {\\n    const personToMeetingsWithPeople = {};\\n    for (const [person1, person2] of peopleInMeetings) {\\n        if (!personToMeetingsWithPeople[person1]) {\\n            personToMeetingsWithPeople[person1] = [];\\n        }\\n        if (!personToMeetingsWithPeople[person2]) {\\n            personToMeetingsWithPeople[person2] = [];\\n        }\\n        personToMeetingsWithPeople[person1].push(person2);\\n        personToMeetingsWithPeople[person2].push(person1);\\n    }\\n    return personToMeetingsWithPeople;\\n}\\n\\n// finds all the people that are in meetings that have the secret\\n// set data structue is used so that people are not duplicated\\nfunction findPeopleThatHaveTheSecret(peopleInMeetings, peopleThatCurrentlyHaveSecret) {\\n    const peopleInMeetingsWithSecret = new Set();\\n    for (const peopleInMeeting of peopleInMeetings) {\\n        for (const person of peopleInMeeting) {\\n            if (peopleThatCurrentlyHaveSecret.has(person)) {\\n                peopleInMeetingsWithSecret.add(person);\\n            }\\n        }\\n    }\\n    return peopleInMeetingsWithSecret;\\n}\\n```\\n\\n```javascript\\n/**\\n * @param {number} n\\n * @param {number[][]} meetings\\n * @param {number} firstPerson\\n * @return {number[]}\\n */\\nvar findAllPeople = function(n, meetings, firstPerson) {\\n    const unionFind = [...(new Array(n)).keys()]\\n    const find = (x) => unionFind[x] = unionFind[x] === x ? x : find(unionFind[x]);\\n    const union = (x, y) => {\\n        const rootOfX = find(x);\\n        const rootOfY = find(y);\\n        if (rootOfX === 0) {\\n            unionFind[rootOfY] = rootOfX;\\n        } else {\\n            unionFind[rootOfX] = rootOfY;\\n        }\\n    }\\n    const reset = (x) => unionFind[x] = x;\\n    \\n    union(0, firstPerson);\\n    const timeToMeetings = mapSortedTimeToMeetings(meetings);\\n    \\n    for (const meetingsWithPeople of timeToMeetings.values()) {\\n        const peopleInMeetings = new Set();\\n        for (const [person1, person2] of meetingsWithPeople) {\\n            union(person1, person2);\\n            peopleInMeetings.add(person1);\\n            peopleInMeetings.add(person2);\\n        }\\n        for (const personInMeeting of peopleInMeetings) {\\n            if (find(personInMeeting) !== 0) {\\n                reset(personInMeeting);\\n            }\\n        }\\n    }\\n    return [...(new Array(n)).keys()].filter((person) => find(person) === 0);\\n};\\n\\n// groups all the meetings by time\\n// keys (time) is sorted in ascending order\\nfunction mapSortedTimeToMeetings(meetings) {\\n    meetings.sort((a, b) => a[2] - b[2]);\\n\\n    const timeToMeeting = new Map();\\n    for (const [person1, person2, time] of meetings) {\\n        if (!timeToMeeting.has(time)) {\\n            timeToMeeting.set(time, []);\\n        }\\n        timeToMeeting.get(time).push([person1, person2]);\\n    }\\n    return timeToMeeting;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```javascript\\nvar findAllPeople = function(n, meetings, firstPerson) {\\n    const timeToMeeting = mapSortedTimeToMeetings(meetings);\\n    \\n    const peopleThatCurrentlyHaveSecret = new Set([0, firstPerson]);\\n    for (const peopleInMeetings of timeToMeeting.values()) {\\n        const personToMeetingsWithPeople = \\n            mapPeopleToPeopleTheyAreHavingMeetingsWith(peopleInMeetings);\\n        let peopleInMeetingsWithSecret = \\n            findPeopleThatHaveTheSecret(peopleInMeetings, peopleThatCurrentlyHaveSecret);\\n        \\n        // BFS algorithm\\n        while (peopleInMeetingsWithSecret.size > 0) {\\n            const nextPeopleInMeetingsWithSecret = new Set();\\n            for (const attendee of peopleInMeetingsWithSecret) {\\n                for (const personInMeetingWithAttendee of personToMeetingsWithPeople[attendee]) {\\n\\n                    // only add new people that have the secret otherwise there will be an\\n                    // infinite loop\\n                    if (!peopleThatCurrentlyHaveSecret.has(personInMeetingWithAttendee)) {\\n                        nextPeopleInMeetingsWithSecret.add(personInMeetingWithAttendee);\\n                        peopleThatCurrentlyHaveSecret.add(personInMeetingWithAttendee);\\n                    }\\n                }\\n            }\\n            peopleInMeetingsWithSecret = nextPeopleInMeetingsWithSecret;\\n        }\\n    }\\n    return [...peopleThatCurrentlyHaveSecret];\\n};\\n\\n// groups all the meetings by time\\n// keys (time) is sorted in ascending order\\nfunction mapSortedTimeToMeetings(meetings) {\\n    meetings.sort((a, b) => a[2] - b[2]);\\n\\n    const timeToMeeting = new Map();\\n    for (const [person1, person2, time] of meetings) {\\n        if (!timeToMeeting.has(time)) {\\n            timeToMeeting.set(time, []);\\n        }\\n        timeToMeeting.get(time).push([person1, person2]);\\n    }\\n    return timeToMeeting;\\n}\\n\\n// creates an adjacency list of people and people they are having meetings with\\nfunction mapPeopleToPeopleTheyAreHavingMeetingsWith(peopleInMeetings) {\\n    const personToMeetingsWithPeople = {};\\n    for (const [person1, person2] of peopleInMeetings) {\\n        if (!personToMeetingsWithPeople[person1]) {\\n            personToMeetingsWithPeople[person1] = [];\\n        }\\n        if (!personToMeetingsWithPeople[person2]) {\\n            personToMeetingsWithPeople[person2] = [];\\n        }\\n        personToMeetingsWithPeople[person1].push(person2);\\n        personToMeetingsWithPeople[person2].push(person1);\\n    }\\n    return personToMeetingsWithPeople;\\n}\\n\\n// finds all the people that are in meetings that have the secret\\n// set data structue is used so that people are not duplicated\\nfunction findPeopleThatHaveTheSecret(peopleInMeetings, peopleThatCurrentlyHaveSecret) {\\n    const peopleInMeetingsWithSecret = new Set();\\n    for (const peopleInMeeting of peopleInMeetings) {\\n        for (const person of peopleInMeeting) {\\n            if (peopleThatCurrentlyHaveSecret.has(person)) {\\n                peopleInMeetingsWithSecret.add(person);\\n            }\\n        }\\n    }\\n    return peopleInMeetingsWithSecret;\\n}\\n```\n```javascript\\n/**\\n * @param {number} n\\n * @param {number[][]} meetings\\n * @param {number} firstPerson\\n * @return {number[]}\\n */\\nvar findAllPeople = function(n, meetings, firstPerson) {\\n    const unionFind = [...(new Array(n)).keys()]\\n    const find = (x) => unionFind[x] = unionFind[x] === x ? x : find(unionFind[x]);\\n    const union = (x, y) => {\\n        const rootOfX = find(x);\\n        const rootOfY = find(y);\\n        if (rootOfX === 0) {\\n            unionFind[rootOfY] = rootOfX;\\n        } else {\\n            unionFind[rootOfX] = rootOfY;\\n        }\\n    }\\n    const reset = (x) => unionFind[x] = x;\\n    \\n    union(0, firstPerson);\\n    const timeToMeetings = mapSortedTimeToMeetings(meetings);\\n    \\n    for (const meetingsWithPeople of timeToMeetings.values()) {\\n        const peopleInMeetings = new Set();\\n        for (const [person1, person2] of meetingsWithPeople) {\\n            union(person1, person2);\\n            peopleInMeetings.add(person1);\\n            peopleInMeetings.add(person2);\\n        }\\n        for (const personInMeeting of peopleInMeetings) {\\n            if (find(personInMeeting) !== 0) {\\n                reset(personInMeeting);\\n            }\\n        }\\n    }\\n    return [...(new Array(n)).keys()].filter((person) => find(person) === 0);\\n};\\n\\n// groups all the meetings by time\\n// keys (time) is sorted in ascending order\\nfunction mapSortedTimeToMeetings(meetings) {\\n    meetings.sort((a, b) => a[2] - b[2]);\\n\\n    const timeToMeeting = new Map();\\n    for (const [person1, person2, time] of meetings) {\\n        if (!timeToMeeting.has(time)) {\\n            timeToMeeting.set(time, []);\\n        }\\n        timeToMeeting.get(time).push([person1, person2]);\\n    }\\n    return timeToMeeting;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3935467,
                "title": "python-union-find-solution-beat-100-detailed-explain-with-code",
                "content": "# Intuition\\nAt its core, the problem deals with grouping people who meet each other. Union-Find is an excellent tool for dynamically creating and managing these groups. However, a unique twist in this problem is the simultaneous nature of the meetings. When people meet at the same time, they form independent groups. But if any member in a group knows the secret, the entire group gets to know about it. This simultaneous grouping also introduces potential redundancy in group formations, making the reset mechanism pivotal. Without resetting, our algorithm may mistakenly assume that certain people know the secret when, in fact, they don\\'t.\\n\\n# Approach\\n### Initialization:\\n- Initialize a roots array where each person initially forms their own group.\\n- Assign the person with the initial secret to a special group (using index 0).\\n### Union-Find Operations:\\n- find: Determine which set an individual belongs to.\\n- union: Merge sets of two individuals. If one knows the secret, the whole set knows it post-union.\\n### Meeting Processing:\\n- Sort the meetings by time.\\n- For each time-slot, apply union operations for people meeting at that time.\\nReset groups post-meeting to disband unions not involving the secret.\\n### Output Generation:\\n- Return all individuals belonging to the \\'secret-knowing\\' group.\\nComplexity\\n# Time complexity:\\n- The sorting of meetings dominates: O(mlogm), where m is the number of meetings.\\n- Space complexity:\\nStoring the \\'roots\\' and processing meetings: O(n+m), where n is the number of people and m is the number of meetings.\\n\\n# Code\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def findAllPeople(self, n, meetings, firstPerson):\\n        roots = [i for i in range(n)]\\n        \\n        # if roots[n] == 0 or find(n) == 0, means person n knows the secret\\n        roots[firstPerson] = 0\\n        \\n        def find(x):\\n            if roots[x] == x:\\n                return x\\n            roots[x] = find(roots[x])\\n            return roots[x]\\n        \\n        def union(x, y):\\n            rootX = find(x)\\n            rootY = find(y)\\n            if rootX != rootY:\\n                # original: parent[parent_a] = parent_b\\n                # below are new\\n                # x or y knows the secret, make both as known secret\\n                if rootX == 0 or rootY == 0:\\n                    roots[rootY] = roots[rootX] = 0\\n                # Neither x nor y  knows the secret, just union them into the same group\\n                else:\\n                    roots[rootY] = rootX\\n        \\n        # Preprocess meetings into a dictionary\\n        meetingMap = defaultdict(list)\\n        for x, y, time in meetings:\\n            meetingMap[time].append((x, y))\\n        \\n        # Now, iterate over meetings grouped by their timestamps\\n        for time in sorted(meetingMap.keys()):\\n            sameTimeMeetings = meetingMap[time]\\n            \\n            # union people in the same time meetings into groups\\n            for x, y in sameTimeMeetings:\\n                union(x, y)\\n                \\n            # reset the union groups that people do not know the secret from meetings case when unnecessary group happens\\n            for x, y in sameTimeMeetings:\\n                rootX = find(x)\\n                # Since x and y are unioned into the same group, if x does not know the secret, y does not know either\\n                if rootX != 0:\\n                    roots[x] = x\\n                    roots[y] = y\\n\\n        return [i for i in range(n) if find(i) == 0]\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def findAllPeople(self, n, meetings, firstPerson):\\n        roots = [i for i in range(n)]\\n        \\n        # if roots[n] == 0 or find(n) == 0, means person n knows the secret\\n        roots[firstPerson] = 0\\n        \\n        def find(x):\\n            if roots[x] == x:\\n                return x\\n            roots[x] = find(roots[x])\\n            return roots[x]\\n        \\n        def union(x, y):\\n            rootX = find(x)\\n            rootY = find(y)\\n            if rootX != rootY:\\n                # original: parent[parent_a] = parent_b\\n                # below are new\\n                # x or y knows the secret, make both as known secret\\n                if rootX == 0 or rootY == 0:\\n                    roots[rootY] = roots[rootX] = 0\\n                # Neither x nor y  knows the secret, just union them into the same group\\n                else:\\n                    roots[rootY] = rootX\\n        \\n        # Preprocess meetings into a dictionary\\n        meetingMap = defaultdict(list)\\n        for x, y, time in meetings:\\n            meetingMap[time].append((x, y))\\n        \\n        # Now, iterate over meetings grouped by their timestamps\\n        for time in sorted(meetingMap.keys()):\\n            sameTimeMeetings = meetingMap[time]\\n            \\n            # union people in the same time meetings into groups\\n            for x, y in sameTimeMeetings:\\n                union(x, y)\\n                \\n            # reset the union groups that people do not know the secret from meetings case when unnecessary group happens\\n            for x, y in sameTimeMeetings:\\n                rootX = find(x)\\n                # Since x and y are unioned into the same group, if x does not know the secret, y does not know either\\n                if rootX != 0:\\n                    roots[x] = x\\n                    roots[y] = y\\n\\n        return [i for i in range(n) if find(i) == 0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895968,
                "title": "optimal-solution-by-dsu-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n     int par[100001];\\n    int findd(int a)\\n    {\\n        if(a==par[a])\\n            return a;\\n        return par[a]=findd(par[a]);\\n    }\\n    void unionn(int a,int b)\\n    {\\n        int x=findd(a);\\n        int y=findd(b);\\n        if(x==0)\\n            par[y]=x;\\n        else\\n            par[x]=y;\\n    }\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n       \\n        for(int i=0;i<n;i++)\\n            par[i]=i;\\n        unionn(0,firstPerson);\\n        map<int,vector<pair<int,int>>>m;\\n        for(auto &it:meetings)\\n        {\\n            m[it[2]].push_back({it[0],it[1]});\\n        }\\n        for(auto &it:m)\\n        {\\n            for(auto &yo:it.second)\\n            {\\n                unionn(yo.first,yo.second);\\n            }\\n            for(auto &yo:it.second)\\n            {\\n                int x=findd(yo.first);\\n                int y=findd(yo.second);\\n                if(x!=0&&y!=0)\\n                {\\n                    par[yo.first]=yo.first;\\n                    par[yo.second]=yo.second;\\n                }\\n                else\\n                {\\n                    par[x]=x;\\n                    par[y]=y;\\n                }\\n            }\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=findd(i);\\n            if(!x)\\n                ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     int par[100001];\\n    int findd(int a)\\n    {\\n        if(a==par[a])\\n            return a;\\n        return par[a]=findd(par[a]);\\n    }\\n    void unionn(int a,int b)\\n    {\\n        int x=findd(a);\\n        int y=findd(b);\\n        if(x==0)\\n            par[y]=x;\\n        else\\n            par[x]=y;\\n    }\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n       \\n        for(int i=0;i<n;i++)\\n            par[i]=i;\\n        unionn(0,firstPerson);\\n        map<int,vector<pair<int,int>>>m;\\n        for(auto &it:meetings)\\n        {\\n            m[it[2]].push_back({it[0],it[1]});\\n        }\\n        for(auto &it:m)\\n        {\\n            for(auto &yo:it.second)\\n            {\\n                unionn(yo.first,yo.second);\\n            }\\n            for(auto &yo:it.second)\\n            {\\n                int x=findd(yo.first);\\n                int y=findd(yo.second);\\n                if(x!=0&&y!=0)\\n                {\\n                    par[yo.first]=yo.first;\\n                    par[yo.second]=yo.second;\\n                }\\n                else\\n                {\\n                    par[x]=x;\\n                    par[y]=y;\\n                }\\n            }\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=findd(i);\\n            if(!x)\\n                ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880062,
                "title": "java-union-find-with-reset-clean",
                "content": "# Code\\n```\\nclass Solution {\\n    class DSU {\\n        public int[] roots;\\n        DSU(int n) {\\n            roots = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                roots[i] = i;\\n            }\\n        }\\n\\n        public void reset(int a) {\\n            roots[a] = a;\\n        }\\n\\n        public int find(int a) {\\n            if (roots[a] == a) {\\n                return a;\\n            }\\n            roots[a] = find(roots[a]);\\n            return roots[a];\\n        }\\n\\n        public void union(int a, int b) {\\n            int rootA = find(a);\\n            int rootB = find(b);\\n            if (rootA == rootB) {\\n                return;\\n            }\\n            roots[rootB] = rootA;\\n        }\\n\\n        public boolean isConnected(int a, int b) {\\n            return (find(a) == find(b));\\n        }\\n    }\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        List<Integer> res = new ArrayList<>();\\n\\n        DSU dsu = new DSU(n);\\n        dsu.union(0, firstPerson);\\n\\n        Arrays.sort(meetings, (int[] v1, int[] v2) -> Integer.compare(v1[2], v2[2]));\\n\\n        int i = 0;\\n        while (i < meetings.length) {\\n            int start = i;\\n            while (i < meetings.length && meetings[start][2] == meetings[i][2]) {\\n                dsu.union(meetings[i][0], meetings[i][1]);\\n                i++;\\n            }\\n            while (start < i) {\\n                if ( ! dsu.isConnected(0, meetings[start][0])) {\\n                    dsu.reset(meetings[start][0]);\\n                    dsu.reset(meetings[start][1]);\\n                }\\n                start++;\\n            }\\n        }\\n\\n        for (int j = 0; j < n; j++) {\\n            if (dsu.isConnected(0, j)) {\\n                res.add(j);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class DSU {\\n        public int[] roots;\\n        DSU(int n) {\\n            roots = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                roots[i] = i;\\n            }\\n        }\\n\\n        public void reset(int a) {\\n            roots[a] = a;\\n        }\\n\\n        public int find(int a) {\\n            if (roots[a] == a) {\\n                return a;\\n            }\\n            roots[a] = find(roots[a]);\\n            return roots[a];\\n        }\\n\\n        public void union(int a, int b) {\\n            int rootA = find(a);\\n            int rootB = find(b);\\n            if (rootA == rootB) {\\n                return;\\n            }\\n            roots[rootB] = rootA;\\n        }\\n\\n        public boolean isConnected(int a, int b) {\\n            return (find(a) == find(b));\\n        }\\n    }\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        List<Integer> res = new ArrayList<>();\\n\\n        DSU dsu = new DSU(n);\\n        dsu.union(0, firstPerson);\\n\\n        Arrays.sort(meetings, (int[] v1, int[] v2) -> Integer.compare(v1[2], v2[2]));\\n\\n        int i = 0;\\n        while (i < meetings.length) {\\n            int start = i;\\n            while (i < meetings.length && meetings[start][2] == meetings[i][2]) {\\n                dsu.union(meetings[i][0], meetings[i][1]);\\n                i++;\\n            }\\n            while (start < i) {\\n                if ( ! dsu.isConnected(0, meetings[start][0])) {\\n                    dsu.reset(meetings[start][0]);\\n                    dsu.reset(meetings[start][1]);\\n                }\\n                start++;\\n            }\\n        }\\n\\n        for (int j = 0; j < n; j++) {\\n            if (dsu.isConnected(0, j)) {\\n                res.add(j);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852630,
                "title": "c-solution-using-priority-queue",
                "content": "# Complexity\\n- Time complexity:\\n$$O(Elogn)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        set<int>res;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>pq;\\n\\n        pq.push({0, 0});\\n        pq.push({0, firstPerson});\\n\\n        vector<pair<int, int>>adj[n];\\n        for(int i=0;i<meetings.size();i++){\\n            int x = meetings[i][0];\\n            int y = meetings[i][1];\\n            int time = meetings[i][2];\\n\\n            adj[x].push_back({y, time});\\n            adj[y].push_back({x, time});\\n        }\\n\\n        vector<int>timeOfInfo(n, INT_MAX);\\n        timeOfInfo[0] = 0;\\n        timeOfInfo[firstPerson] = 0;\\n\\n        while(!pq.empty()){\\n            auto temp = pq.top();\\n            pq.pop();\\n\\n            int time = temp.first;\\n            int node = temp.second;\\n\\n            res.insert(node);\\n\\n            for(auto it: adj[node]){\\n                if(it.second >= time && timeOfInfo[it.first] > it.second){\\n                    pq.push({it.second, it.first});\\n                    timeOfInfo[it.first] = it.second;\\n                }\\n            }\\n        }\\n\\n        vector<int>ans(res.begin(), res.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        set<int>res;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>pq;\\n\\n        pq.push({0, 0});\\n        pq.push({0, firstPerson});\\n\\n        vector<pair<int, int>>adj[n];\\n        for(int i=0;i<meetings.size();i++){\\n            int x = meetings[i][0];\\n            int y = meetings[i][1];\\n            int time = meetings[i][2];\\n\\n            adj[x].push_back({y, time});\\n            adj[y].push_back({x, time});\\n        }\\n\\n        vector<int>timeOfInfo(n, INT_MAX);\\n        timeOfInfo[0] = 0;\\n        timeOfInfo[firstPerson] = 0;\\n\\n        while(!pq.empty()){\\n            auto temp = pq.top();\\n            pq.pop();\\n\\n            int time = temp.first;\\n            int node = temp.second;\\n\\n            res.insert(node);\\n\\n            for(auto it: adj[node]){\\n                if(it.second >= time && timeOfInfo[it.first] > it.second){\\n                    pq.push({it.second, it.first});\\n                    timeOfInfo[it.first] = it.second;\\n                }\\n            }\\n        }\\n\\n        vector<int>ans(res.begin(), res.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831350,
                "title": "rust-disjoint-set-binary-search",
                "content": "# Approach\\n\\nFor each timestamp, use **Disjoint Set** to keep track of people who knew the secret, and the people they shared the secrets to.\\n\\nWe can use sorting + binary search to group meetings with the same timestamp. Or a hashmap, that works too.\\n\\n# Code\\n```\\n#[derive(Debug, Clone)]\\npub struct DisjointSet {\\n    parents: Vec<Option<usize>>,\\n    count: usize,\\n}\\n\\nimpl DisjointSet {\\n    pub fn new(n: usize) -> Self {\\n        let parents = vec![None; n];\\n\\n        Self { parents, count: 0 }\\n    }\\n\\n    pub fn init(&mut self, e: usize) {\\n        if e >= self.parents.len() {\\n            return;\\n        }\\n        if self.parents[e].is_some() {\\n            return;\\n        } // already initialized\\n\\n        self.parents[e] = Some(e);\\n        self.count += 1; // new representative\\n    }\\n\\n    pub fn find(&mut self, e: usize) -> Option<usize> {\\n        if e >= self.parents.len() {\\n            return None;\\n        }\\n\\n        let parent = self.parents[e]?; // uninitialized\\n        if parent == e {\\n            return Some(e);\\n        } // self-representative\\n\\n        let ret = self.find(parent)?;\\n        self.parents[e] = Some(ret); // path compression\\n\\n        Some(ret)\\n    }\\n\\n    pub fn link(&mut self, e0: usize, e1: usize) {\\n        if let Some(p0) = self.find(e0) {\\n            if let Some(p1) = self.find(e1) {\\n                if p0 == p1 {\\n                    return;\\n                } // already linked\\n\\n                // p1 is no longer a representative\\n                self.parents[p1] = Some(p0);\\n                self.count -= 1;\\n            }\\n        }\\n    }\\n\\n    pub fn len(&self) -> usize {\\n        self.count\\n    }\\n}\\n\\npub fn canonicalize(meetings: Vec<Vec<i32>>) -> Vec<Vec<(usize, usize)>> {\\n    let meetings = meetings.into_iter()\\n        .map(|v| (v[0] as usize, v[1] as usize, v[2] as u32))\\n        .collect::<Vec<_>>();\\n    \\n    let mut ts_map = meetings.iter()\\n        .map(|v| v.2)\\n        .collect::<Vec<_>>();\\n    ts_map.sort_unstable();\\n    ts_map.dedup();\\n\\n    let n = ts_map.len();\\n    let mut ret = vec![vec![]; n];\\n    \\n    for (v0, v1, ts) in meetings {\\n        let ptr = ts_map.binary_search(&ts).unwrap();\\n        ret[ptr].push((v0.min(v1), v0.max(v1)));\\n    }\\n    \\n    for v in &mut ret {\\n        v.sort_unstable();\\n        v.dedup(); // why not\\n    }\\n\\n    ret\\n}\\n\\nimpl Solution {\\n    pub fn find_all_people(\\n        n: i32,\\n        meetings: Vec<Vec<i32>>,\\n        first_person: i32\\n    ) -> Vec<i32> {\\n        let n = n as usize;\\n\\n        let graph_vec = canonicalize(meetings);\\n        // println!(\"graph_vec: {:?}\", graph_vec);\\n\\n        let mut visited = vec![false; n];\\n        visited[usize::MIN] = true;\\n        visited[first_person as usize] = true; // they knew\\n\\n        for graph in graph_vec {\\n            let mut vertices_map = vec![];\\n            for &(v0, v1) in &graph {\\n                vertices_map.push(v0);\\n                vertices_map.push(v1);\\n            }\\n            vertices_map.push(usize::MIN); // person 0 is watching\\n            vertices_map.sort_unstable();\\n            vertices_map.dedup();\\n\\n            let mut set = DisjointSet::new(vertices_map.len());\\n            for i in 0..vertices_map.len() {\\n                set.init(i);\\n            }\\n\\n            for (i, &v) in vertices_map.iter().enumerate() {\\n                if !visited[v] { continue; }                \\n                set.link(0, i); // link them with patient zero\\n            }\\n\\n            for (v0, v1) in graph {\\n                let ptr_0 = vertices_map.binary_search(&v0).unwrap();\\n                let ptr_1 = vertices_map.binary_search(&v1).unwrap();\\n                set.link(ptr_0, ptr_1);\\n            }\\n\\n            let zero_id = set.find(usize::MIN).unwrap();\\n            for (i, &v) in vertices_map.iter().enumerate() {\\n                if visited[v] { continue; }\\n                \\n                if let Some(id) = set.find(i) {\\n                    if id == zero_id {\\n                        visited[v] = true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        visited.into_iter()\\n            .enumerate()\\n            .filter(|&(_, e)| e)\\n            .map(|(i, _)| i as i32)\\n            .collect::<Vec<_>>()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Binary Search",
                    "Union Find"
                ],
                "code": "```\\n#[derive(Debug, Clone)]\\npub struct DisjointSet {\\n    parents: Vec<Option<usize>>,\\n    count: usize,\\n}\\n\\nimpl DisjointSet {\\n    pub fn new(n: usize) -> Self {\\n        let parents = vec![None; n];\\n\\n        Self { parents, count: 0 }\\n    }\\n\\n    pub fn init(&mut self, e: usize) {\\n        if e >= self.parents.len() {\\n            return;\\n        }\\n        if self.parents[e].is_some() {\\n            return;\\n        } // already initialized\\n\\n        self.parents[e] = Some(e);\\n        self.count += 1; // new representative\\n    }\\n\\n    pub fn find(&mut self, e: usize) -> Option<usize> {\\n        if e >= self.parents.len() {\\n            return None;\\n        }\\n\\n        let parent = self.parents[e]?; // uninitialized\\n        if parent == e {\\n            return Some(e);\\n        } // self-representative\\n\\n        let ret = self.find(parent)?;\\n        self.parents[e] = Some(ret); // path compression\\n\\n        Some(ret)\\n    }\\n\\n    pub fn link(&mut self, e0: usize, e1: usize) {\\n        if let Some(p0) = self.find(e0) {\\n            if let Some(p1) = self.find(e1) {\\n                if p0 == p1 {\\n                    return;\\n                } // already linked\\n\\n                // p1 is no longer a representative\\n                self.parents[p1] = Some(p0);\\n                self.count -= 1;\\n            }\\n        }\\n    }\\n\\n    pub fn len(&self) -> usize {\\n        self.count\\n    }\\n}\\n\\npub fn canonicalize(meetings: Vec<Vec<i32>>) -> Vec<Vec<(usize, usize)>> {\\n    let meetings = meetings.into_iter()\\n        .map(|v| (v[0] as usize, v[1] as usize, v[2] as u32))\\n        .collect::<Vec<_>>();\\n    \\n    let mut ts_map = meetings.iter()\\n        .map(|v| v.2)\\n        .collect::<Vec<_>>();\\n    ts_map.sort_unstable();\\n    ts_map.dedup();\\n\\n    let n = ts_map.len();\\n    let mut ret = vec![vec![]; n];\\n    \\n    for (v0, v1, ts) in meetings {\\n        let ptr = ts_map.binary_search(&ts).unwrap();\\n        ret[ptr].push((v0.min(v1), v0.max(v1)));\\n    }\\n    \\n    for v in &mut ret {\\n        v.sort_unstable();\\n        v.dedup(); // why not\\n    }\\n\\n    ret\\n}\\n\\nimpl Solution {\\n    pub fn find_all_people(\\n        n: i32,\\n        meetings: Vec<Vec<i32>>,\\n        first_person: i32\\n    ) -> Vec<i32> {\\n        let n = n as usize;\\n\\n        let graph_vec = canonicalize(meetings);\\n        // println!(\"graph_vec: {:?}\", graph_vec);\\n\\n        let mut visited = vec![false; n];\\n        visited[usize::MIN] = true;\\n        visited[first_person as usize] = true; // they knew\\n\\n        for graph in graph_vec {\\n            let mut vertices_map = vec![];\\n            for &(v0, v1) in &graph {\\n                vertices_map.push(v0);\\n                vertices_map.push(v1);\\n            }\\n            vertices_map.push(usize::MIN); // person 0 is watching\\n            vertices_map.sort_unstable();\\n            vertices_map.dedup();\\n\\n            let mut set = DisjointSet::new(vertices_map.len());\\n            for i in 0..vertices_map.len() {\\n                set.init(i);\\n            }\\n\\n            for (i, &v) in vertices_map.iter().enumerate() {\\n                if !visited[v] { continue; }                \\n                set.link(0, i); // link them with patient zero\\n            }\\n\\n            for (v0, v1) in graph {\\n                let ptr_0 = vertices_map.binary_search(&v0).unwrap();\\n                let ptr_1 = vertices_map.binary_search(&v1).unwrap();\\n                set.link(ptr_0, ptr_1);\\n            }\\n\\n            let zero_id = set.find(usize::MIN).unwrap();\\n            for (i, &v) in vertices_map.iter().enumerate() {\\n                if visited[v] { continue; }\\n                \\n                if let Some(id) = set.find(i) {\\n                    if id == zero_id {\\n                        visited[v] = true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        visited.into_iter()\\n            .enumerate()\\n            .filter(|&(_, e)| e)\\n            .map(|(i, _)| i as i32)\\n            .collect::<Vec<_>>()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3785078,
                "title": "unionfind-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass UnionFind {\\n   unordered_map<int, int> parent;\\n   public:\\n   UnionFind(){\\n       \\n   }\\n\\n   int find(int x){\\n       if(parent.find(x) == parent.end()){\\n           parent[x] = x;\\n           return x;\\n       }\\n       int root = x;\\n       while(parent[root] != root)\\n       root = parent[root];\\n\\n       while(x != root){\\n         int temp = parent[x];\\n         parent[x] = root;\\n         x = temp;\\n       }\\n\\n       return x;\\n   }\\n\\n   void union_(int x, int y){\\n       int xSet = find(x);\\n       int ySet = find(y);\\n\\n       if(xSet == ySet) return;\\n\\n       if(xSet < ySet) parent[ySet] = xSet;\\n       else{\\n           parent[xSet] = ySet;\\n       }\\n   }\\n};\\nclass Solution {\\npublic:\\n   struct{\\n    bool operator()(vector<int>& a , vector<int>& b){\\n        return a[2] < b[2];\\n    }\\n   }comp;\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        \\n        int m = meetings.size();\\n\\n        vector<bool> hasSecret(n, false);\\n        hasSecret[0] =  true;\\n        hasSecret[firstPerson] = true;\\n\\n        vector<int> res;\\n        res.push_back(0);\\n        res.push_back(firstPerson);\\n\\n        sort(meetings.begin(), meetings.end(), comp);\\n        \\n        int i=0;\\n        // UnionFind obj1;\\n        // obj1.union_(0, firstPerson);\\n        while(i < m){\\n            UnionFind obj2;\\n            int currTime = meetings[i][2];\\n            unordered_set<int> currNodes;\\n            while(i < m && meetings[i][2] == currTime){\\n              obj2.union_(min(meetings[i][0], meetings[i][1]), max(meetings[i][0], meetings[i][1]));\\n            //   if(hasSecret[meetings[i][0]] || hasSecret[meetings[i][1]])\\n            //    obj1.union_(0, meetings[i][0]);\\n              if(hasSecret[meetings[i][0]] || hasSecret[meetings[i][1]])\\n              obj2.union_(0, meetings[i][0]);\\n              currNodes.insert(meetings[i][0]);\\n              currNodes.insert(meetings[i][1]);\\n              i++;\\n            }\\n\\n            // vector<int> temp(res.begin(), res.end());\\n            // for(auto person : temp){\\n                for(auto node : currNodes){\\n                    if(hasSecret[node]) continue;\\n                    int root = obj2.find(node);\\n                    if(root == 0){\\n                      res.push_back(node);\\n                      hasSecret[node] = true;\\n                    }\\n                }\\n            //}\\n\\n        }\\n       return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass UnionFind {\\n   unordered_map<int, int> parent;\\n   public:\\n   UnionFind(){\\n       \\n   }\\n\\n   int find(int x){\\n       if(parent.find(x) == parent.end()){\\n           parent[x] = x;\\n           return x;\\n       }\\n       int root = x;\\n       while(parent[root] != root)\\n       root = parent[root];\\n\\n       while(x != root){\\n         int temp = parent[x];\\n         parent[x] = root;\\n         x = temp;\\n       }\\n\\n       return x;\\n   }\\n\\n   void union_(int x, int y){\\n       int xSet = find(x);\\n       int ySet = find(y);\\n\\n       if(xSet == ySet) return;\\n\\n       if(xSet < ySet) parent[ySet] = xSet;\\n       else{\\n           parent[xSet] = ySet;\\n       }\\n   }\\n};\\nclass Solution {\\npublic:\\n   struct{\\n    bool operator()(vector<int>& a , vector<int>& b){\\n        return a[2] < b[2];\\n    }\\n   }comp;\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        \\n        int m = meetings.size();\\n\\n        vector<bool> hasSecret(n, false);\\n        hasSecret[0] =  true;\\n        hasSecret[firstPerson] = true;\\n\\n        vector<int> res;\\n        res.push_back(0);\\n        res.push_back(firstPerson);\\n\\n        sort(meetings.begin(), meetings.end(), comp);\\n        \\n        int i=0;\\n        // UnionFind obj1;\\n        // obj1.union_(0, firstPerson);\\n        while(i < m){\\n            UnionFind obj2;\\n            int currTime = meetings[i][2];\\n            unordered_set<int> currNodes;\\n            while(i < m && meetings[i][2] == currTime){\\n              obj2.union_(min(meetings[i][0], meetings[i][1]), max(meetings[i][0], meetings[i][1]));\\n            //   if(hasSecret[meetings[i][0]] || hasSecret[meetings[i][1]])\\n            //    obj1.union_(0, meetings[i][0]);\\n              if(hasSecret[meetings[i][0]] || hasSecret[meetings[i][1]])\\n              obj2.union_(0, meetings[i][0]);\\n              currNodes.insert(meetings[i][0]);\\n              currNodes.insert(meetings[i][1]);\\n              i++;\\n            }\\n\\n            // vector<int> temp(res.begin(), res.end());\\n            // for(auto person : temp){\\n                for(auto node : currNodes){\\n                    if(hasSecret[node]) continue;\\n                    int root = obj2.find(node);\\n                    if(root == 0){\\n                      res.push_back(node);\\n                      hasSecret[node] = true;\\n                    }\\n                }\\n            //}\\n\\n        }\\n       return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770466,
                "title": "using-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n      \\n vector<int> findAllPeople(int n, vector<vector<int>>& m, int f) {\\n        vector<pair<int,pair<int,int>>>ans;\\n        \\n        for(auto it:m){\\n            ans.push_back({it[2],{it[0],it[1]}});\\n        }\\n        sort(ans.begin(),ans.end());\\n        int i=0;\\n        unordered_set<int>st;\\n        st.insert(0);\\n        st.insert(f);\\n        \\n         while(i<ans.size()){\\n            int val=ans[i].first;\\n            \\n             map<int,vector<int>>f;\\n             queue<int>q;\\n            while(i<ans.size()&&ans[i].first==val){\\n                int a=ans[i].second.first;\\n                int b=ans[i].second.second;\\n                f[a].push_back(b);\\n                f[b].push_back(a);\\n                if(st.find(a)!=st.end()&&st.find(b)==st.end()){\\n                    st.insert(b);\\n                    q.push(b);\\n                }\\n\\n                 if(st.find(b)!=st.end()&&st.find(a)==st.end()){\\n                    st.insert(a);\\n                    q.push(a);\\n                }\\n                i+=1;\\n                    \\n            }\\n\\n            while(q.size()){\\n                int val1=q.front();\\n                q.pop();\\n                for(auto it:f[val1]){\\n                    if(st.find(it)==st.end()){\\n                          q.push(it);\\n                          st.insert(it);\\n                    }\\n                }\\n                \\n            }\\n\\n        }\\n\\n\\n\\n        vector<int>final;\\n        for(auto it:st) final.push_back(it);\\n        \\n\\n         return final;\\n\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n      \\n vector<int> findAllPeople(int n, vector<vector<int>>& m, int f) {\\n        vector<pair<int,pair<int,int>>>ans;\\n        \\n        for(auto it:m){\\n            ans.push_back({it[2],{it[0],it[1]}});\\n        }\\n        sort(ans.begin(),ans.end());\\n        int i=0;\\n        unordered_set<int>st;\\n        st.insert(0);\\n        st.insert(f);\\n        \\n         while(i<ans.size()){\\n            int val=ans[i].first;\\n            \\n             map<int,vector<int>>f;\\n             queue<int>q;\\n            while(i<ans.size()&&ans[i].first==val){\\n                int a=ans[i].second.first;\\n                int b=ans[i].second.second;\\n                f[a].push_back(b);\\n                f[b].push_back(a);\\n                if(st.find(a)!=st.end()&&st.find(b)==st.end()){\\n                    st.insert(b);\\n                    q.push(b);\\n                }\\n\\n                 if(st.find(b)!=st.end()&&st.find(a)==st.end()){\\n                    st.insert(a);\\n                    q.push(a);\\n                }\\n                i+=1;\\n                    \\n            }\\n\\n            while(q.size()){\\n                int val1=q.front();\\n                q.pop();\\n                for(auto it:f[val1]){\\n                    if(st.find(it)==st.end()){\\n                          q.push(it);\\n                          st.insert(it);\\n                    }\\n                }\\n                \\n            }\\n\\n        }\\n\\n\\n\\n        vector<int>final;\\n        for(auto it:st) final.push_back(it);\\n        \\n\\n         return final;\\n\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760544,
                "title": "simple-djikstra-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n\\n        vector<int>vis(n,0);\\n        vector<vector<pair<int,int>>>adj(n);\\n        meetings.push_back({0,firstPerson,0});\\n        for(auto it:meetings)\\n        {\\n            adj[it[0]].push_back({it[1],it[2]});\\n            adj[it[1]].push_back({it[0],it[2]});\\n        }\\n\\n        \\n        set<pair<int,int>>s;\\n        vis[0]=1;\\n        for(auto it:adj[0])\\n        {\\n            s.insert({it.second,it.first});\\n        }\\n\\n        while(!s.empty())\\n        {\\n            auto it=*s.begin();\\n            s.erase(s.begin());\\n            int person=it.second;\\n            int time=it.first;\\n            if(vis[person])continue;\\n            vis[person]=1;\\n            for(auto it:adj[person])\\n            {\\n                int neigh=it.first;\\n                int t=it.second;\\n                if(!vis[neigh] && time<=t )\\n                {\\n                    s.insert({t,neigh});\\n                }\\n            }\\n        }\\n\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(vis[i])ans.push_back(i);\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n\\n        vector<int>vis(n,0);\\n        vector<vector<pair<int,int>>>adj(n);\\n        meetings.push_back({0,firstPerson,0});\\n        for(auto it:meetings)\\n        {\\n            adj[it[0]].push_back({it[1],it[2]});\\n            adj[it[1]].push_back({it[0],it[2]});\\n        }\\n\\n        \\n        set<pair<int,int>>s;\\n        vis[0]=1;\\n        for(auto it:adj[0])\\n        {\\n            s.insert({it.second,it.first});\\n        }\\n\\n        while(!s.empty())\\n        {\\n            auto it=*s.begin();\\n            s.erase(s.begin());\\n            int person=it.second;\\n            int time=it.first;\\n            if(vis[person])continue;\\n            vis[person]=1;\\n            for(auto it:adj[person])\\n            {\\n                int neigh=it.first;\\n                int t=it.second;\\n                if(!vis[neigh] && time<=t )\\n                {\\n                    s.insert({t,neigh});\\n                }\\n            }\\n        }\\n\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(vis[i])ans.push_back(i);\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760290,
                "title": "modified-dijsktra-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        \\n              vector<vector<pair<int,int>>> adj(n);\\n                for (auto x : meetings)\\n                {\\n                    adj[x[0]].push_back({x[2],x[1]});\\n                    adj[x[1]].push_back({x[2],x[0]});\\n                    \\n                }\\n\\n   \\n            \\nset<pair<int,int> > q;\\n                q.insert({0,0});\\n                q.insert({0,firstPerson});\\n                vector<int> dis(n,INT_MAX);\\n                dis[0] = 1;\\n                dis[firstPerson] = 1;\\n                while(!q.empty())\\n                {\\n                    int x =(*q.begin()).second;\\n                    int t =(*q.begin()).first;\\n                    q.erase({t,x});\\n\\n                    for (auto it : adj[x])\\n                    {\\n                        int y = it.second;\\n                        int meett = it.first;\\n                       \\n                       \\n                        if(dis[y]> meett && t <= meett)\\n                        {  \\n                            q.erase({dis[y],y});\\n                            dis[y] = meett;\\n                            q.insert({meett,y});\\n                        }\\n                    }\\n                }\\n\\n                vector<int> ans;\\n                for (int i = 0; i < n; i++)\\n                {\\n                    if(dis[i]!=INT_MAX)\\n                    ans.push_back(i);\\n                }\\n\\n                return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        \\n              vector<vector<pair<int,int>>> adj(n);\\n                for (auto x : meetings)\\n                {\\n                    adj[x[0]].push_back({x[2],x[1]});\\n                    adj[x[1]].push_back({x[2],x[0]});\\n                    \\n                }\\n\\n   \\n            \\nset<pair<int,int> > q;\\n                q.insert({0,0});\\n                q.insert({0,firstPerson});\\n                vector<int> dis(n,INT_MAX);\\n                dis[0] = 1;\\n                dis[firstPerson] = 1;\\n                while(!q.empty())\\n                {\\n                    int x =(*q.begin()).second;\\n                    int t =(*q.begin()).first;\\n                    q.erase({t,x});\\n\\n                    for (auto it : adj[x])\\n                    {\\n                        int y = it.second;\\n                        int meett = it.first;\\n                       \\n                       \\n                        if(dis[y]> meett && t <= meett)\\n                        {  \\n                            q.erase({dis[y],y});\\n                            dis[y] = meett;\\n                            q.insert({meett,y});\\n                        }\\n                    }\\n                }\\n\\n                vector<int> ans;\\n                for (int i = 0; i < n; i++)\\n                {\\n                    if(dis[i]!=INT_MAX)\\n                    ans.push_back(i);\\n                }\\n\\n                return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750478,
                "title": "c-t-o-n-2-s-o-max-m-n-m-length-of-meetings-descriptive",
                "content": "# Approach\\nCreate a graph with Key a person and Value as list of meetings they had with others in the format {meetingWith, meetTime}\\n\\nInitialize 1st time ppl knew secret for each person as int.MaxValue and update it to 0 for firstPerson which got to know the secret from person at index o (lets all this array \\'SecretKnowTime\\')\\n\\nNow Initialize the queue with the people who know the secret at time t0 i.e. 0th and firstPerson\\n\\nNow while Dequeuing the person p1 from the Q\\ngo thru all meetings done by p1 (if any)\\n\\nwhile going thru meetings check if it was held at time i.e. after they knew secret than skip to next meeting\\nalso skip if the p2 who is meeting p1 knew the secret from schedule meeting time.\\n\\nwe only add p2 to queue if current meeting is when they got to know the secret for the very first time.\\nalso reduce/update the time in SecretKnowTime array for p2.\\n\\n# Complexity\\n- Time complexity:\\nTime O(n^2)\\n\\n- Space complexity:\\nSpace O(Max(m,n)), m = length of meetings\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<int> FindAllPeople(int n, int[][] meetings, int firstPerson) {\\n        int[] SecretKnowTime = Enumerable.Repeat(int.MaxValue,n).ToArray();\\n        SecretKnowTime[0] = SecretKnowTime[firstPerson] = 0;    // set time when first 2 person know the secret\\n        Dictionary<int,List<int[]>> meetSchedule = new Dictionary<int,List<int[]>>();\\n        foreach(var meet in meetings)                           // O(m), m = no of meetings\\n        {\\n            var p1= meet[0];\\n            var p2= meet[1];\\n            var time= meet[2];\\n            // update Graph for P1\\n            if(!meetSchedule.ContainsKey(p1))\\n                meetSchedule[p1] = new List<int[]>() { new int[] {p2,time}};\\n            else\\n                meetSchedule[p1].Add(new int[] {p2,time});\\n            // update Graph for P2\\n            if(!meetSchedule.ContainsKey(p2))\\n                meetSchedule[p2] = new List<int[]>() { new int[] {p1,time}};\\n            else\\n                meetSchedule[p2].Add(new int[] {p1,time});\\n        }\\n\\n        Queue<int> q = new Queue<int>();\\n        q.Enqueue(0);\\n        q.Enqueue(firstPerson);\\n        while(q.Count>0)\\n        {\\n            var currPerson = q.Dequeue();\\n            if(!meetSchedule.ContainsKey(currPerson)) continue; // no meetings present for a given person\\n            foreach(var meet in meetSchedule[currPerson])\\n            {\\n                // P1 meeting with P2 happened before P1 knew Secret or P2 knew secret before his meeting with P1\\n                if(SecretKnowTime[currPerson] > meet[1] || SecretKnowTime[meet[0]] <= meet[1])\\n                    continue;\\n                else\\n                {\\n                    q.Enqueue(meet[0]);\\n                    SecretKnowTime[meet[0]] = meet[1];  // update the secret known time for P2 to earlier duration\\n                }\\n            }\\n        }\\n\\n        List<int> knowSecret = new List<int>();\\n        for(int i=0;i<n;i++)                        // O(n)\\n            if(SecretKnowTime[i]!=int.MaxValue)\\n                knowSecret.Add(i);\\n        return knowSecret.ToList();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Graph",
                    "Queue"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<int> FindAllPeople(int n, int[][] meetings, int firstPerson) {\\n        int[] SecretKnowTime = Enumerable.Repeat(int.MaxValue,n).ToArray();\\n        SecretKnowTime[0] = SecretKnowTime[firstPerson] = 0;    // set time when first 2 person know the secret\\n        Dictionary<int,List<int[]>> meetSchedule = new Dictionary<int,List<int[]>>();\\n        foreach(var meet in meetings)                           // O(m), m = no of meetings\\n        {\\n            var p1= meet[0];\\n            var p2= meet[1];\\n            var time= meet[2];\\n            // update Graph for P1\\n            if(!meetSchedule.ContainsKey(p1))\\n                meetSchedule[p1] = new List<int[]>() { new int[] {p2,time}};\\n            else\\n                meetSchedule[p1].Add(new int[] {p2,time});\\n            // update Graph for P2\\n            if(!meetSchedule.ContainsKey(p2))\\n                meetSchedule[p2] = new List<int[]>() { new int[] {p1,time}};\\n            else\\n                meetSchedule[p2].Add(new int[] {p1,time});\\n        }\\n\\n        Queue<int> q = new Queue<int>();\\n        q.Enqueue(0);\\n        q.Enqueue(firstPerson);\\n        while(q.Count>0)\\n        {\\n            var currPerson = q.Dequeue();\\n            if(!meetSchedule.ContainsKey(currPerson)) continue; // no meetings present for a given person\\n            foreach(var meet in meetSchedule[currPerson])\\n            {\\n                // P1 meeting with P2 happened before P1 knew Secret or P2 knew secret before his meeting with P1\\n                if(SecretKnowTime[currPerson] > meet[1] || SecretKnowTime[meet[0]] <= meet[1])\\n                    continue;\\n                else\\n                {\\n                    q.Enqueue(meet[0]);\\n                    SecretKnowTime[meet[0]] = meet[1];  // update the secret known time for P2 to earlier duration\\n                }\\n            }\\n        }\\n\\n        List<int> knowSecret = new List<int>();\\n        for(int i=0;i<n;i++)                        // O(n)\\n            if(SecretKnowTime[i]!=int.MaxValue)\\n                knowSecret.Add(i);\\n        return knowSecret.ToList();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727226,
                "title": "c-union-find-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> parent,rank;\\n    vector<array<int,2>> time[100001];\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        parent.resize(n,0);\\n        rank.resize(n,0);\\n        vector<int> ans;\\n        for(int i=0; i<n; i++) parent[i] = i;\\n        for(int i=0; i<meetings.size(); i++) time[meetings[i][2]].push_back({meetings[i][0],meetings[i][1]});\\n        connect(0,firstPerson);\\n        for(int i=0; i<100001; i++) {\\n            vector<int> ps;\\n            for(int j=0; j<time[i].size(); j++) {\\n                 connect(time[i][j][0],time[i][j][1]);\\n                 ps.push_back(time[i][j][0]);\\n                 ps.push_back(time[i][j][1]);\\n            }\\n            for(int p : ps) {\\n                 if(!connected(0,p)) parent[p] = p;\\n            } \\n        }\\n        for(int i=0; i<n; i++) {\\n            if(connected(i,0)) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n    int find(int par) {\\n        if(par == parent[par]) return par;\\n        else return find(parent[par]);\\n    }\\n    bool connected(int a,int b) {\\n        return find(a) == find(b);\\n    } \\n    void connect(int a,int b) {\\n        a = find(a);\\n        b = find(b);\\n        if(a == b) return;\\n        if(rank[a] < rank[b]) {\\n            parent[a] = b;\\n        }else if(rank[b] < rank[a]) {\\n            parent[b] = a;\\n        }else {\\n            rank[a]++;\\n            parent[b] = a;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> parent,rank;\\n    vector<array<int,2>> time[100001];\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        parent.resize(n,0);\\n        rank.resize(n,0);\\n        vector<int> ans;\\n        for(int i=0; i<n; i++) parent[i] = i;\\n        for(int i=0; i<meetings.size(); i++) time[meetings[i][2]].push_back({meetings[i][0],meetings[i][1]});\\n        connect(0,firstPerson);\\n        for(int i=0; i<100001; i++) {\\n            vector<int> ps;\\n            for(int j=0; j<time[i].size(); j++) {\\n                 connect(time[i][j][0],time[i][j][1]);\\n                 ps.push_back(time[i][j][0]);\\n                 ps.push_back(time[i][j][1]);\\n            }\\n            for(int p : ps) {\\n                 if(!connected(0,p)) parent[p] = p;\\n            } \\n        }\\n        for(int i=0; i<n; i++) {\\n            if(connected(i,0)) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n    int find(int par) {\\n        if(par == parent[par]) return par;\\n        else return find(parent[par]);\\n    }\\n    bool connected(int a,int b) {\\n        return find(a) == find(b);\\n    } \\n    void connect(int a,int b) {\\n        a = find(a);\\n        b = find(b);\\n        if(a == b) return;\\n        if(rank[a] < rank[b]) {\\n            parent[a] = b;\\n        }else if(rank[b] < rank[a]) {\\n            parent[b] = a;\\n        }else {\\n            rank[a]++;\\n            parent[b] = a;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688987,
                "title": "simple-c-solution-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        vector<int>time(n,1e9);\\n        time[0]=0;\\n        time[firstPerson]=0;\\n        vector<pair<int,int>>sides[n];\\n        for(int i=0;i<meetings.size();i++){\\n            sides[meetings[i][0]].push_back({meetings[i][1],meetings[i][2]});\\n            sides[meetings[i][1]].push_back({meetings[i][0],meetings[i][2]});\\n        }\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        pq.push({0,0});\\n        pq.push({0,firstPerson});\\n        while(pq.size()!=0){\\n            auto it=pq.top();\\n            int parent=it.second;\\n            int parent_time=it.first;\\n            pq.pop();\\n            for(int i=0;i<sides[parent].size();i++){\\n                int child=sides[parent][i].first;\\n                int child_time=sides[parent][i].second;\\n                if(child_time>=parent_time){\\n                    if(child_time<time[child]){\\n                        pq.push({child_time,child});\\n                        time[child]=child_time;\\n                    }\\n                }\\n            }\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<time.size();i++){\\n            if(time[i]!=1e9)ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        vector<int>time(n,1e9);\\n        time[0]=0;\\n        time[firstPerson]=0;\\n        vector<pair<int,int>>sides[n];\\n        for(int i=0;i<meetings.size();i++){\\n            sides[meetings[i][0]].push_back({meetings[i][1],meetings[i][2]});\\n            sides[meetings[i][1]].push_back({meetings[i][0],meetings[i][2]});\\n        }\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        pq.push({0,0});\\n        pq.push({0,firstPerson});\\n        while(pq.size()!=0){\\n            auto it=pq.top();\\n            int parent=it.second;\\n            int parent_time=it.first;\\n            pq.pop();\\n            for(int i=0;i<sides[parent].size();i++){\\n                int child=sides[parent][i].first;\\n                int child_time=sides[parent][i].second;\\n                if(child_time>=parent_time){\\n                    if(child_time<time[child]){\\n                        pq.push({child_time,child});\\n                        time[child]=child_time;\\n                    }\\n                }\\n            }\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<time.size();i++){\\n            if(time[i]!=1e9)ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659746,
                "title": "simple-bfs-only",
                "content": "# Intuition\\nsimple BFS \\n\\n<!-- # Approach\\nDescribe your approach to solving the problem.\\n\\n# Complexity\\n- Time complexity:\\nAdd your time complexity here, e.g. $$O(n)$$\\n\\n- Space complexity:\\nAdd your space complexity here, e.g. $$O(n)$$ \\n-->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        vector<int>mint(n, INT_MAX);\\n        mint[0] = 0;\\n        mint[firstPerson] = 0;\\n        vector<pair<int, int>>adj[n]; // {v, time}\\n        for (auto v : meetings) {\\n            adj[v[0]].push_back({v[1], v[2]});\\n            adj[v[1]].push_back({v[0], v[2]});\\n        }\\n        queue<int>q;\\n        q.push(0);\\n        q.push(firstPerson);\\n        int node;\\n        while (!q.empty()) {\\n            node = q.front();\\n            q.pop();\\n            for (auto p : adj[node]) {\\n                if (mint[p.first] > p.second && p.second >= mint[node]) {\\n                    mint[p.first] = p.second;\\n                    q.push(p.first);\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        for (int i = 0; i < n; i++) if (mint[i] != INT_MAX) ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        vector<int>mint(n, INT_MAX);\\n        mint[0] = 0;\\n        mint[firstPerson] = 0;\\n        vector<pair<int, int>>adj[n]; // {v, time}\\n        for (auto v : meetings) {\\n            adj[v[0]].push_back({v[1], v[2]});\\n            adj[v[1]].push_back({v[0], v[2]});\\n        }\\n        queue<int>q;\\n        q.push(0);\\n        q.push(firstPerson);\\n        int node;\\n        while (!q.empty()) {\\n            node = q.front();\\n            q.pop();\\n            for (auto p : adj[node]) {\\n                if (mint[p.first] > p.second && p.second >= mint[node]) {\\n                    mint[p.first] = p.second;\\n                    q.push(p.first);\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        for (int i = 0; i < n; i++) if (mint[i] != INT_MAX) ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636329,
                "title": "c-union-find-easy-solution",
                "content": "# Approach\\n- Connect 0 with first person initially.\\n- Then sort the meetings array in increasing order of time.\\n- Then connect the persons who meet at the same time.\\n- After connection, check if they are indirectly connected to 0 or not because if not then they haven\\'t got the news yet and since time is increasing, if they do not meet again, they will not get the news hence we reset their parent values back to their initial values (i.e. parent[i] = i).\\n- Finally check which persons are connected to 0, they will come in the final answer array.\\n\\n\\n# Code\\n```\\nbool comp(vector<int>& a,vector<int>& b)\\n{\\n    return a[2]<b[2];\\n}\\nclass Solution {\\npublic:\\n    vector<int> parent,rank;\\n    int findPar(int x)\\n    {\\n        if(x==parent[x])\\n        return x;\\n        return parent[x] = findPar(parent[x]);\\n    }\\n    void Union(int x,int y)\\n    {\\n        int u = findPar(x);\\n        int v = findPar(y);\\n        if(u==v)\\n        return;\\n        if(rank[u]>=rank[v])\\n        {\\n            parent[v] = u;\\n            rank[u]++;\\n        }\\n        else\\n        {\\n            parent[u] = v;\\n            rank[v]++;\\n        }\\n    }\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meet, int f) {\\n        parent.resize(n);\\n        rank.resize(n,1);\\n        for(int i=0;i<n;i++)\\n        parent[i] = i;\\n        Union(0,f);\\n        sort(meet.begin(),meet.end(),comp);\\n        vector<int> tmp;\\n        for(int i=0;i<meet.size();)\\n        {\\n            int tim = meet[i][2];\\n            tmp.clear();\\n            for(;i<meet.size() && meet[i][2]==tim;i++)\\n            {\\n                Union(meet[i][0],meet[i][1]);\\n                tmp.push_back(meet[i][0]);\\n                tmp.push_back(meet[i][1]);\\n            }\\n            for(auto &j:tmp)\\n            {\\n                if(findPar(j)!=findPar(0))\\n                parent[j] = j;\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(findPar(i)==findPar(0))\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nbool comp(vector<int>& a,vector<int>& b)\\n{\\n    return a[2]<b[2];\\n}\\nclass Solution {\\npublic:\\n    vector<int> parent,rank;\\n    int findPar(int x)\\n    {\\n        if(x==parent[x])\\n        return x;\\n        return parent[x] = findPar(parent[x]);\\n    }\\n    void Union(int x,int y)\\n    {\\n        int u = findPar(x);\\n        int v = findPar(y);\\n        if(u==v)\\n        return;\\n        if(rank[u]>=rank[v])\\n        {\\n            parent[v] = u;\\n            rank[u]++;\\n        }\\n        else\\n        {\\n            parent[u] = v;\\n            rank[v]++;\\n        }\\n    }\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meet, int f) {\\n        parent.resize(n);\\n        rank.resize(n,1);\\n        for(int i=0;i<n;i++)\\n        parent[i] = i;\\n        Union(0,f);\\n        sort(meet.begin(),meet.end(),comp);\\n        vector<int> tmp;\\n        for(int i=0;i<meet.size();)\\n        {\\n            int tim = meet[i][2];\\n            tmp.clear();\\n            for(;i<meet.size() && meet[i][2]==tim;i++)\\n            {\\n                Union(meet[i][0],meet[i][1]);\\n                tmp.push_back(meet[i][0]);\\n                tmp.push_back(meet[i][1]);\\n            }\\n            for(auto &j:tmp)\\n            {\\n                if(findPar(j)!=findPar(0))\\n                parent[j] = j;\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(findPar(i)==findPar(0))\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606125,
                "title": "creating-mst-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust See the code you will understand its just i am creating a minimum spanning tree; you can optimize it more i know, but got Ac so why optimise? :) \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int fir) {\\n        \\n        vector<int>ans;\\n        set<int>mst;\\n        vector<int>mint(n+1,1e8);\\n        mint[0] = 0;\\n        mint[fir] = 0;\\n        mst.insert(0);\\n        vector<vector<pair<int,int>>>adj(n+1);\\n        for(auto k:meetings){\\n            int u = k[0];\\n            int v = k[1];\\n            int t = k[2];\\n            adj[u].push_back({v,t});\\n            adj[v].push_back({u,t});\\n            }\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        pq.push({0,fir});\\n        pq.push({0,0});\\n\\n        while(!pq.empty()){\\n            auto it = pq.top();\\n            pq.pop();\\n            int node = it.second;\\n            int minti = it.first;\\n            mst.insert(node);\\n            for(auto ch:adj[node])\\n            {\\n               if(mst.find(ch.first)!=mst.end())continue;\\n               else {\\n                   if(mint[ch.first]<=ch.second)continue;\\n                   if(ch.second >= minti)\\n                   {\\n                       pq.push({ch.second,ch.first});\\n                       mint[ch.first] = ch.second;\\n                   }\\n               }\\n\\n            }\\n        }\\n\\n        for(auto j:mst)ans.push_back(j);\\nreturn ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int fir) {\\n        \\n        vector<int>ans;\\n        set<int>mst;\\n        vector<int>mint(n+1,1e8);\\n        mint[0] = 0;\\n        mint[fir] = 0;\\n        mst.insert(0);\\n        vector<vector<pair<int,int>>>adj(n+1);\\n        for(auto k:meetings){\\n            int u = k[0];\\n            int v = k[1];\\n            int t = k[2];\\n            adj[u].push_back({v,t});\\n            adj[v].push_back({u,t});\\n            }\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        pq.push({0,fir});\\n        pq.push({0,0});\\n\\n        while(!pq.empty()){\\n            auto it = pq.top();\\n            pq.pop();\\n            int node = it.second;\\n            int minti = it.first;\\n            mst.insert(node);\\n            for(auto ch:adj[node])\\n            {\\n               if(mst.find(ch.first)!=mst.end())continue;\\n               else {\\n                   if(mint[ch.first]<=ch.second)continue;\\n                   if(ch.second >= minti)\\n                   {\\n                       pq.push({ch.second,ch.first});\\n                       mint[ch.first] = ch.second;\\n                   }\\n               }\\n\\n            }\\n        }\\n\\n        for(auto j:mst)ans.push_back(j);\\nreturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574311,
                "title": "simple-dijkstra-with-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI Solved it using Dijsktra. Just check if a parent node with a secret recieves secret before or after the meeting time of any of it\\'s children. If it\\'s before, then it can pass on the secret to the childrens, else not.\\nKey thing to keep in mind is don\\'t push a node for processing if it doesn\\'t have a secret as there is no point in processing it anymore.\\nAbove observation gets handled on it\\'s own in the relaxation part which is nice\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        \\n        vector<bool> vis(n + 1, false);\\n        priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int,int> > > pq;\\n\\n        vector<vector<pair<int, int> > > graph(n + 1);\\n\\n        for(auto e : meetings){\\n            graph[e[0]].push_back({e[1], e[2]});\\n            graph[e[1]].push_back({e[0], e[2]});\\n        }\\n\\n        pq.push({0, 0});\\n        pq.push({0, firstPerson});\\n        // vis[0] = true;\\n        // vis[firstPerson] = true;\\n\\n        vector<int> dis(n + 1, INT_MAX);\\n        dis[0] = 0;\\n        dis[firstPerson] = 0;\\n\\n        while(!pq.empty()){\\n\\n            auto curr = pq.top();\\n            pq.pop();\\n\\n            int u = curr.second;\\n            int time_recieved = curr.first;\\n\\n            if(vis[u])continue;\\n            vis[u] = true;\\n\\n            for(auto node : graph[u]){\\n\\n                int v = node.first;\\n                int meeting_time = node.second;\\n\\n                if(time_recieved <= meeting_time){\\n                    dis[v] = meeting_time;\\n                    pq.push({meeting_time, v});\\n                }\\n            }\\n        }\\n\\n        vector<int> ans;\\n\\n        for(int i = 0; i < n; i++){\\n            if(dis[i] != INT_MAX)ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        \\n        vector<bool> vis(n + 1, false);\\n        priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int,int> > > pq;\\n\\n        vector<vector<pair<int, int> > > graph(n + 1);\\n\\n        for(auto e : meetings){\\n            graph[e[0]].push_back({e[1], e[2]});\\n            graph[e[1]].push_back({e[0], e[2]});\\n        }\\n\\n        pq.push({0, 0});\\n        pq.push({0, firstPerson});\\n        // vis[0] = true;\\n        // vis[firstPerson] = true;\\n\\n        vector<int> dis(n + 1, INT_MAX);\\n        dis[0] = 0;\\n        dis[firstPerson] = 0;\\n\\n        while(!pq.empty()){\\n\\n            auto curr = pq.top();\\n            pq.pop();\\n\\n            int u = curr.second;\\n            int time_recieved = curr.first;\\n\\n            if(vis[u])continue;\\n            vis[u] = true;\\n\\n            for(auto node : graph[u]){\\n\\n                int v = node.first;\\n                int meeting_time = node.second;\\n\\n                if(time_recieved <= meeting_time){\\n                    dis[v] = meeting_time;\\n                    pq.push({meeting_time, v});\\n                }\\n            }\\n        }\\n\\n        vector<int> ans;\\n\\n        for(int i = 0; i < n; i++){\\n            if(dis[i] != INT_MAX)ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537033,
                "title": "c-bfs",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        map<int,vector<pair<int,int>>>mp;\\n        for(auto i : meetings)\\n        {\\n            mp[i[1]].push_back({i[0],i[2]});\\n            mp[i[0]].push_back({i[1],i[2]});\\n        }\\n        vector<int>vis(n,0);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>q;\\n        q.push({0,firstPerson});\\n        q.push({0,0});\\n        while(q.size())\\n        {\\n            int node=q.top().second;\\n            int time=q.top().first;\\n            q.pop();\\n            if(vis[node])continue;\\n            vis[node]=true;\\n            for(auto i : mp[node])\\n            {\\n                int nextNode=i.first;\\n                int nextTime=i.second;\\n                if(!vis[nextNode] and time <= nextTime )\\n                {\\n                    q.push({nextTime,nextNode});\\n                }\\n            }\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(vis[i])ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        map<int,vector<pair<int,int>>>mp;\\n        for(auto i : meetings)\\n        {\\n            mp[i[1]].push_back({i[0],i[2]});\\n            mp[i[0]].push_back({i[1],i[2]});\\n        }\\n        vector<int>vis(n,0);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>q;\\n        q.push({0,firstPerson});\\n        q.push({0,0});\\n        while(q.size())\\n        {\\n            int node=q.top().second;\\n            int time=q.top().first;\\n            q.pop();\\n            if(vis[node])continue;\\n            vis[node]=true;\\n            for(auto i : mp[node])\\n            {\\n                int nextNode=i.first;\\n                int nextTime=i.second;\\n                if(!vis[nextNode] and time <= nextTime )\\n                {\\n                    q.push({nextTime,nextNode});\\n                }\\n            }\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(vis[i])ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3536777,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n + n_meetings * log(n_timestamps))\\n * Space Complexity: O(n + n_meetings)\\n * where `n_meetings` is the length of the vector `meetings`\\n *       `n_timestamps` is the number of the different timestamps at which one meeting happens\\n */\\nclass Solution {\\n private:\\n  class DisjointSet {\\n   public:\\n    DisjointSet(const int n) : parents_(n), ranks_(n) {\\n      iota(parents_.begin(), parents_.end(), 0);\\n    }\\n    \\n    int find(const int i) {\\n      if (i == parents_[i]) {\\n        return i;\\n      }\\n      parents_[i] = find(parents_[i]);\\n      return parents_[i];\\n    }\\n    \\n    bool do_union(const int i, const int j) {\\n      const int parent_i = find(i);\\n      const int parent_j = find(j);\\n      if (parent_i == parent_j) {\\n        return false;\\n      }\\n      \\n      if (ranks_[parent_i] < ranks_[parent_j]) {\\n        parents_[parent_i] = parent_j;\\n      } else if (ranks_[parent_i] > ranks_[parent_j]) {\\n        parents_[parent_j] = parent_i;\\n      } else {\\n        parents_[parent_i] = parent_j;\\n        ++ranks_[parent_j];\\n      }\\n      return true;\\n    }\\n    \\n    void reset(const int i) {\\n      parents_[i] = i;\\n      ranks_[i] = 0;\\n    }\\n    \\n   private:\\n    vector<int> parents_;\\n    vector<int> ranks_;\\n  };\\n  \\n public:\\n  vector<int> findAllPeople(const int n,\\n                            const vector<vector<int>> &meetings,\\n                            const int firstPerson) {\\n    constexpr int source_person = 0;\\n    constexpr int person1_i = 0;\\n    constexpr int person2_i = 1;\\n    constexpr int time_i = 2;\\n    map<int, vector<pair<int, int>>> time_to_meetings({\\n      {\\n        0,\\n        vector<pair<int, int>>{make_pair(source_person, firstPerson)}\\n      }\\n    });\\n    for (const vector<int> &meeting : meetings) {\\n      const int person1 = meeting[person1_i];\\n      const int person2 = meeting[person2_i];\\n      const int time = meeting[time_i];\\n      time_to_meetings[time].emplace_back(person1, person2);\\n    }\\n    \\n    DisjointSet ds(n);\\n    for (const auto &[_, meetings] : time_to_meetings) {\\n      for (const auto [person1, person2] : meetings) {\\n        ds.do_union(person1, person2);\\n      }\\n      for (const auto [person1, person2] : meetings) {\\n        if (ds.find(person1) != ds.find(source_person)) {\\n          ds.reset(person1);\\n          ds.reset(person2);\\n        }\\n      }\\n    }\\n    \\n    vector<int> ret;\\n    for (int person = 0; person < n; ++person) {\\n      if (ds.find(source_person) == ds.find(person)) {\\n        ret.emplace_back(person);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n + n_meetings * log(n_timestamps))\\n * Space Complexity: O(n + n_meetings)\\n * where `n_meetings` is the length of the vector `meetings`\\n *       `n_timestamps` is the number of the different timestamps at which one meeting happens\\n */\\nclass Solution {\\n private:\\n  class DisjointSet {\\n   public:\\n    DisjointSet(const int n) : parents_(n), ranks_(n) {\\n      iota(parents_.begin(), parents_.end(), 0);\\n    }\\n    \\n    int find(const int i) {\\n      if (i == parents_[i]) {\\n        return i;\\n      }\\n      parents_[i] = find(parents_[i]);\\n      return parents_[i];\\n    }\\n    \\n    bool do_union(const int i, const int j) {\\n      const int parent_i = find(i);\\n      const int parent_j = find(j);\\n      if (parent_i == parent_j) {\\n        return false;\\n      }\\n      \\n      if (ranks_[parent_i] < ranks_[parent_j]) {\\n        parents_[parent_i] = parent_j;\\n      } else if (ranks_[parent_i] > ranks_[parent_j]) {\\n        parents_[parent_j] = parent_i;\\n      } else {\\n        parents_[parent_i] = parent_j;\\n        ++ranks_[parent_j];\\n      }\\n      return true;\\n    }\\n    \\n    void reset(const int i) {\\n      parents_[i] = i;\\n      ranks_[i] = 0;\\n    }\\n    \\n   private:\\n    vector<int> parents_;\\n    vector<int> ranks_;\\n  };\\n  \\n public:\\n  vector<int> findAllPeople(const int n,\\n                            const vector<vector<int>> &meetings,\\n                            const int firstPerson) {\\n    constexpr int source_person = 0;\\n    constexpr int person1_i = 0;\\n    constexpr int person2_i = 1;\\n    constexpr int time_i = 2;\\n    map<int, vector<pair<int, int>>> time_to_meetings({\\n      {\\n        0,\\n        vector<pair<int, int>>{make_pair(source_person, firstPerson)}\\n      }\\n    });\\n    for (const vector<int> &meeting : meetings) {\\n      const int person1 = meeting[person1_i];\\n      const int person2 = meeting[person2_i];\\n      const int time = meeting[time_i];\\n      time_to_meetings[time].emplace_back(person1, person2);\\n    }\\n    \\n    DisjointSet ds(n);\\n    for (const auto &[_, meetings] : time_to_meetings) {\\n      for (const auto [person1, person2] : meetings) {\\n        ds.do_union(person1, person2);\\n      }\\n      for (const auto [person1, person2] : meetings) {\\n        if (ds.find(person1) != ds.find(source_person)) {\\n          ds.reset(person1);\\n          ds.reset(person2);\\n        }\\n      }\\n    }\\n    \\n    vector<int> ret;\\n    for (int person = 0; person < n; ++person) {\\n      if (ds.find(source_person) == ds.find(person)) {\\n        ret.emplace_back(person);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511001,
                "title": "easy-bfs-solution-runtime-67-ms-beats-80-34",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] arr, int f) {\\n        \\n\\n        TreeSet< Integer > set = new TreeSet<>();\\n        ArrayList< Edge > [] list = new ArrayList[n];\\n        \\n        for(int i = 0; i < n; i++) list[i] = new ArrayList<>();\\n\\n        for(int[] a : arr){\\n            int v = a[0], u = a[1], weight = a[2];\\n            list[v].add(new Edge(u,weight));\\n            list[u].add(new Edge(v,weight));\\n        }\\n        boolean[] view = new boolean[n];\\n\\n        view[0] = true;\\n        view[f] = true;\\n        set.add(0);\\n        set.add(f);\\n        int[] dp = new int[n];\\n        dp[0] = 0;\\n        dp[f] = 1;\\n\\n        Queue< Integer > queue = new LinkedList<>();\\n        queue.add(0);\\n        queue.add(f);\\n\\n        while(!queue.isEmpty()){\\n\\n            int u = queue.remove();\\n\\n            for(Edge e : list[u]){\\n                \\n                if(dp[u] > e.weight) continue;\\n\\n                if(!view[e.v]){\\n                    set.add(e.v);\\n                    dp[e.v] = e.weight;\\n                    view[e.v] = true;\\n                    queue.add(e.v);                    \\n                }\\n                else if(dp[e.v] > e.weight){\\n                    dp[e.v] = e.weight;\\n                    queue.remove(e.v);\\n                    queue.add(e.v);\\n                }\\n            }\\n        }\\n\\n\\n        return new ArrayList<>(set);\\n    }\\n}\\nclass Edge{\\n    int v;\\n    int weight;\\n    public Edge(int v, int weight){\\n        this.v = v;\\n        this.weight = weight;\\n    }\\n    public String toString(){\\n        return v + \" : \"+ weight;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] arr, int f) {\\n        \\n\\n        TreeSet< Integer > set = new TreeSet<>();\\n        ArrayList< Edge > [] list = new ArrayList[n];\\n        \\n        for(int i = 0; i < n; i++) list[i] = new ArrayList<>();\\n\\n        for(int[] a : arr){\\n            int v = a[0], u = a[1], weight = a[2];\\n            list[v].add(new Edge(u,weight));\\n            list[u].add(new Edge(v,weight));\\n        }\\n        boolean[] view = new boolean[n];\\n\\n        view[0] = true;\\n        view[f] = true;\\n        set.add(0);\\n        set.add(f);\\n        int[] dp = new int[n];\\n        dp[0] = 0;\\n        dp[f] = 1;\\n\\n        Queue< Integer > queue = new LinkedList<>();\\n        queue.add(0);\\n        queue.add(f);\\n\\n        while(!queue.isEmpty()){\\n\\n            int u = queue.remove();\\n\\n            for(Edge e : list[u]){\\n                \\n                if(dp[u] > e.weight) continue;\\n\\n                if(!view[e.v]){\\n                    set.add(e.v);\\n                    dp[e.v] = e.weight;\\n                    view[e.v] = true;\\n                    queue.add(e.v);                    \\n                }\\n                else if(dp[e.v] > e.weight){\\n                    dp[e.v] = e.weight;\\n                    queue.remove(e.v);\\n                    queue.add(e.v);\\n                }\\n            }\\n        }\\n\\n\\n        return new ArrayList<>(set);\\n    }\\n}\\nclass Edge{\\n    int v;\\n    int weight;\\n    public Edge(int v, int weight){\\n        this.v = v;\\n        this.weight = weight;\\n    }\\n    public String toString(){\\n        return v + \" : \"+ weight;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498054,
                "title": "php-solution-union-find",
                "content": "# Complexity\\n- Time complexity: $$O((m+n)*log(n)$$, where $$m$$ is the number of `meetings`\\n- Space complexity: $$O(m + m)$$\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $n\\n     * @param Integer[][] $meetings\\n     * @param Integer $firstPerson\\n     * @return Integer[]\\n     */\\n    function findAllPeople(int $n, array $meetings, int $firstPerson): array {\\n        usort($meetings, fn(array $a, array $b) => $a[2] - $b[2]);\\n        $uf = new UnionFind($n);\\n        $uf->connect(0, $firstPerson);\\n        $m = count($meetings);\\n        for ($i = 0; $i < $m;) {\\n            $ppl = [];\\n            $time = $meetings[$i][2];\\n            for (;$i < $m and $meetings[$i][2] == $time; $i++) {\\n                $uf->connect($meetings[$i][0], $meetings[$i][1]);\\n                $ppl[] = $meetings[$i][0];\\n                $ppl[] = $meetings[$i][1];\\n            }\\n            foreach ($ppl as $p) {\\n                if (!$uf->connected(0, $p)) {\\n                    $uf->reset($p);\\n                }\\n            }\\n        }\\n\\n        $result = [];\\n        for ($i = 0; $i < $n; $i++) {\\n            if ($uf->connected(0, $i)) {\\n                $result[] = $i;\\n            }\\n        }\\n\\n        return $result;\\n    }\\n}\\n\\nclass UnionFind {\\n    private array $id;\\n    public function __construct(int $n)\\n    {\\n        $this->id = [];\\n        for($i = 0; $i < $n; $i++){\\n            $this->id[] = $i;\\n        }\\n    }\\n\\n    public function connect(int $a, int $b): void\\n    {\\n        $this->id[$this->find($b)] = $this->find($a);\\n    }\\n\\n    public function find(int $a): int {\\n        if ($this->id[$a] == $a) {\\n            return $a;\\n        } else {\\n            $this->id[$a] = $this->find($this->id[$a]);\\n            return $this->id[$a];\\n        }\\n    }\\n\\n    public function connected(int $a, int $b): bool {\\n        return $this->find($a) == $this->find($b);\\n    }\\n\\n    public function reset(int $a): void\\n    {\\n        $this->id[$a] = $a;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "PHP",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $n\\n     * @param Integer[][] $meetings\\n     * @param Integer $firstPerson\\n     * @return Integer[]\\n     */\\n    function findAllPeople(int $n, array $meetings, int $firstPerson): array {\\n        usort($meetings, fn(array $a, array $b) => $a[2] - $b[2]);\\n        $uf = new UnionFind($n);\\n        $uf->connect(0, $firstPerson);\\n        $m = count($meetings);\\n        for ($i = 0; $i < $m;) {\\n            $ppl = [];\\n            $time = $meetings[$i][2];\\n            for (;$i < $m and $meetings[$i][2] == $time; $i++) {\\n                $uf->connect($meetings[$i][0], $meetings[$i][1]);\\n                $ppl[] = $meetings[$i][0];\\n                $ppl[] = $meetings[$i][1];\\n            }\\n            foreach ($ppl as $p) {\\n                if (!$uf->connected(0, $p)) {\\n                    $uf->reset($p);\\n                }\\n            }\\n        }\\n\\n        $result = [];\\n        for ($i = 0; $i < $n; $i++) {\\n            if ($uf->connected(0, $i)) {\\n                $result[] = $i;\\n            }\\n        }\\n\\n        return $result;\\n    }\\n}\\n\\nclass UnionFind {\\n    private array $id;\\n    public function __construct(int $n)\\n    {\\n        $this->id = [];\\n        for($i = 0; $i < $n; $i++){\\n            $this->id[] = $i;\\n        }\\n    }\\n\\n    public function connect(int $a, int $b): void\\n    {\\n        $this->id[$this->find($b)] = $this->find($a);\\n    }\\n\\n    public function find(int $a): int {\\n        if ($this->id[$a] == $a) {\\n            return $a;\\n        } else {\\n            $this->id[$a] = $this->find($this->id[$a]);\\n            return $this->id[$a];\\n        }\\n    }\\n\\n    public function connected(int $a, int $b): bool {\\n        return $this->find($a) == $this->find($b);\\n    }\\n\\n    public function reset(int $a): void\\n    {\\n        $this->id[$a] = $a;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344956,
                "title": "go-union-find-with-reset-o-m-ln-m-n-o-m-n",
                "content": "This solution idea:\\nhttps://leetcode.com/problems/find-all-people-with-secret/solutions/1599815/c-union-find/?orderBy=hot\\n```\\nfunc findAllPeople(n int, meetings [][]int, firstPerson int) (res []int) {\\n\\tsort.Slice(meetings, func(i, j int) bool { return meetings[i][2] < meetings[j][2] })\\n\\tp := make([]int, n)\\n\\tfor i := range p {\\n\\t\\tp[i] = i\\n\\t}\\n\\tp[firstPerson] = 0\\n\\tfor i, m, reset := 0, len(meetings), make([]int, 0); i < m; {\\n\\t\\tfor t := meetings[i][2]; i < m && meetings[i][2] == t; i++ {\\n\\t\\t\\tunite(meetings[i][0], meetings[i][1], p)\\n\\t\\t\\treset = append(reset, meetings[i][0], meetings[i][1])\\n\\t\\t}\\n\\t\\tfor _, j := range reset {\\n\\t\\t\\tif find(j, p) != find(0, p) {\\n\\t\\t\\t\\tp[j] = j\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treset = nil\\n\\t}\\n\\tfor i := range p {\\n\\t\\tif find(i, p) == find(0, p) {\\n\\t\\t\\tres = append(res, i)\\n\\t\\t}\\n\\t}\\n\\treturn\\n}\\n\\nfunc find(x int, p []int) int {\\n\\tif p[x] != x {\\n\\t\\tp[x] = find(p[x], p)\\n\\t}\\n\\treturn p[x]\\n}\\n\\nfunc unite(x int, y int, p []int) {\\n\\tx, y = find(x, p), find(y, p)\\n\\tif x != y {\\n\\t\\tif rand.Intn(2) == 0 {\\n\\t\\t\\tx, y = y, x\\n\\t\\t}\\n\\t\\tp[x] = y\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Union Find"
                ],
                "code": "```\\nfunc findAllPeople(n int, meetings [][]int, firstPerson int) (res []int) {\\n\\tsort.Slice(meetings, func(i, j int) bool { return meetings[i][2] < meetings[j][2] })\\n\\tp := make([]int, n)\\n\\tfor i := range p {\\n\\t\\tp[i] = i\\n\\t}\\n\\tp[firstPerson] = 0\\n\\tfor i, m, reset := 0, len(meetings), make([]int, 0); i < m; {\\n\\t\\tfor t := meetings[i][2]; i < m && meetings[i][2] == t; i++ {\\n\\t\\t\\tunite(meetings[i][0], meetings[i][1], p)\\n\\t\\t\\treset = append(reset, meetings[i][0], meetings[i][1])\\n\\t\\t}\\n\\t\\tfor _, j := range reset {\\n\\t\\t\\tif find(j, p) != find(0, p) {\\n\\t\\t\\t\\tp[j] = j\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treset = nil\\n\\t}\\n\\tfor i := range p {\\n\\t\\tif find(i, p) == find(0, p) {\\n\\t\\t\\tres = append(res, i)\\n\\t\\t}\\n\\t}\\n\\treturn\\n}\\n\\nfunc find(x int, p []int) int {\\n\\tif p[x] != x {\\n\\t\\tp[x] = find(p[x], p)\\n\\t}\\n\\treturn p[x]\\n}\\n\\nfunc unite(x int, y int, p []int) {\\n\\tx, y = find(x, p), find(y, p)\\n\\tif x != y {\\n\\t\\tif rand.Intn(2) == 0 {\\n\\t\\t\\tx, y = y, x\\n\\t\\t}\\n\\t\\tp[x] = y\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3331732,
                "title": "sort-bfs-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nbfs is better for dfs, dfs is good for research but not good for implication in industry, as stack overflow.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsort the time according to time frame, prepare a meeting dict to store all meetings at a certain time. then check the meeting according to time and find all nodes using bfs\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        meetings.sort(key = lambda x: x[2])\\n        meeting_dict = defaultdict(list)\\n\\n        for person1, person2, time in meetings:\\n          meeting_dict[time].append([person1, person2])\\n\\n        has_secret = {0, firstPerson}\\n        for time, meetings in meeting_dict.items():\\n          graph = defaultdict(list)\\n          seen = set()\\n          for person1, person2 in meetings:\\n            graph[person1].append(person2)\\n            graph[person2].append(person1)\\n\\n            if person1 in has_secret:\\n              seen.add(person1)\\n            if person2 in has_secret:\\n              seen.add(person2)\\n          queue = deque(seen)\\n          while queue:\\n            person = queue.popleft()\\n            for nei in graph[person]:\\n              if nei not in has_secret:\\n                has_secret.add(nei)\\n                queue.append(nei)\\n        return has_secret\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        meetings.sort(key = lambda x: x[2])\\n        meeting_dict = defaultdict(list)\\n\\n        for person1, person2, time in meetings:\\n          meeting_dict[time].append([person1, person2])\\n\\n        has_secret = {0, firstPerson}\\n        for time, meetings in meeting_dict.items():\\n          graph = defaultdict(list)\\n          seen = set()\\n          for person1, person2 in meetings:\\n            graph[person1].append(person2)\\n            graph[person2].append(person1)\\n\\n            if person1 in has_secret:\\n              seen.add(person1)\\n            if person2 in has_secret:\\n              seen.add(person2)\\n          queue = deque(seen)\\n          while queue:\\n            person = queue.popleft()\\n            for nei in graph[person]:\\n              if nei not in has_secret:\\n                has_secret.add(nei)\\n                queue.append(nei)\\n        return has_secret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327995,
                "title": "bfs",
                "content": "```ruby\\ndef find_all_people n, a, f\\n    r, t = [false] * n, {}\\n    r[0] = r[f] = true\\n    a.each do | x, y, z |\\n        m = t[z] ||= Hash.new { _1[_2] = [] }\\n        m[x] << y\\n        m[y] << x\\n    end\\n    t.sort_by(&:first).each do | _, m |\\n        (q = m.each_key.filter { r[_1] }).each do\\n            m[_1].each do | x |\\n                next if r[x]\\n                r[x] = true\\n                q << x\\n            end\\n        end\\n    end\\n    n.times.filter { r[_1] }\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef find_all_people n, a, f\\n    r, t = [false] * n, {}\\n    r[0] = r[f] = true\\n    a.each do | x, y, z |\\n        m = t[z] ||= Hash.new { _1[_2] = [] }\\n        m[x] << y\\n        m[y] << x\\n    end\\n    t.sort_by(&:first).each do | _, m |\\n        (q = m.each_key.filter { r[_1] }).each do\\n            m[_1].each do | x |\\n                next if r[x]\\n                r[x] = true\\n                q << x\\n            end\\n        end\\n    end\\n    n.times.filter { r[_1] }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3251077,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn find_all_people(n: i32, meetings: Vec<Vec<i32>>, first_person: i32) -> Vec<i32> {\\n        let mut know_secret = vec![false; n as usize];\\n\\n        know_secret[0] = true;\\n        know_secret[first_person as usize] = true;\\n\\n        let mut meetings = meetings;\\n        meetings.sort_unstable_by_key(|x| x[2]);\\n\\n        let mut left = 0;\\n        while left < meetings.len() {\\n            let time = meetings[left][2];\\n            let mut secret_shared = true;\\n            let mut right = left;\\n            while secret_shared {\\n                secret_shared = false;\\n                right = left;\\n                while right < meetings.len() && meetings[right][2] == time {\\n                    let x = meetings[right][0] as usize;\\n                    let y = meetings[right][1] as usize;\\n                    if know_secret[x] && !know_secret[y] || !know_secret[x] && know_secret[y] {\\n                        secret_shared = true;\\n                        know_secret[x] = true;\\n                        know_secret[y] = true;\\n                    }\\n                    right += 1;\\n                }\\n            }\\n            left = right;\\n        }\\n        know_secret\\n            .into_iter()\\n            .enumerate()\\n            .filter(|x| x.1)\\n            .map(|x| x.0 as i32)\\n            .collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_all_people(n: i32, meetings: Vec<Vec<i32>>, first_person: i32) -> Vec<i32> {\\n        let mut know_secret = vec![false; n as usize];\\n\\n        know_secret[0] = true;\\n        know_secret[first_person as usize] = true;\\n\\n        let mut meetings = meetings;\\n        meetings.sort_unstable_by_key(|x| x[2]);\\n\\n        let mut left = 0;\\n        while left < meetings.len() {\\n            let time = meetings[left][2];\\n            let mut secret_shared = true;\\n            let mut right = left;\\n            while secret_shared {\\n                secret_shared = false;\\n                right = left;\\n                while right < meetings.len() && meetings[right][2] == time {\\n                    let x = meetings[right][0] as usize;\\n                    let y = meetings[right][1] as usize;\\n                    if know_secret[x] && !know_secret[y] || !know_secret[x] && know_secret[y] {\\n                        secret_shared = true;\\n                        know_secret[x] = true;\\n                        know_secret[y] = true;\\n                    }\\n                    right += 1;\\n                }\\n            }\\n            left = right;\\n        }\\n        know_secret\\n            .into_iter()\\n            .enumerate()\\n            .filter(|x| x.1)\\n            .map(|x| x.0 as i32)\\n            .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3228560,
                "title": "dijkstra-solution",
                "content": "<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBetter solution\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(NLOGN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        dp=[float(\"inf\")]*n\\n        g=defaultdict(list)\\n        for x,y,time in meetings:\\n            g[x].append((y,time))\\n            g[y].append((x,time))\\n        # print(\"g \",g[17])\\n        q=[(0,firstPerson),(0,0)]\\n        dp[0]=0\\n        dp[firstPerson]=0\\n        ans=[0,firstPerson]\\n        while q:\\n            t,nd=heapq.heappop(q)\\n            for y,tm in g[nd]:\\n                if tm>=t and dp[y]>t:\\n                    heapq.heappush(q,(tm,y))\\n                    dp[y]=tm\\n                    ans.append(y)\\n        # print(dp)\\n        return list(set(ans))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        dp=[float(\"inf\")]*n\\n        g=defaultdict(list)\\n        for x,y,time in meetings:\\n            g[x].append((y,time))\\n            g[y].append((x,time))\\n        # print(\"g \",g[17])\\n        q=[(0,firstPerson),(0,0)]\\n        dp[0]=0\\n        dp[firstPerson]=0\\n        ans=[0,firstPerson]\\n        while q:\\n            t,nd=heapq.heappop(q)\\n            for y,tm in g[nd]:\\n                if tm>=t and dp[y]>t:\\n                    heapq.heappush(q,(tm,y))\\n                    dp[y]=tm\\n                    ans.append(y)\\n        # print(dp)\\n        return list(set(ans))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3121288,
                "title": "java-uf",
                "content": "```\\nclass Solution {\\n    class DSU{\\n        int[] parent;\\n\\n        DSU(int size){\\n            parent = new int[size];\\n            for (int i = 0; i < parent.length; i++)\\n                parent[i] = i;\\n        }\\n\\n        int find(int x){\\n            if(parent[x] == x)\\n                return x;\\n            return parent[x] = find(parent[x]);\\n        }\\n\\n        void union(int x, int y){\\n            parent[find(x)] = find(y);\\n        }\\n    }\\n\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        DSU dsu = new DSU(n);\\n        dsu.union(0, firstPerson);\\n        Arrays.sort(meetings, (a,b) -> {\\n            if(a[2] != b[2])\\n                return Integer.compare(a[2], b[2]);\\n            else{\\n                int count1 = 0, count2 = 0;\\n                int x1 = a[0], y1 = a[1];\\n                int x2 = b[0] ,y2 = b[1];\\n                if(dsu.find(x1) == dsu.find(0))\\n                    count1++;\\n                if(dsu.find(y1) == dsu.find(0))\\n                    count1++;\\n\\n                if(dsu.find(x2) == dsu.find(0))\\n                    count2++;\\n                if(dsu.find(y2) == dsu.find(0)) \\n                    count2++;\\n                return Integer.compare(count2, count1);\\n            }\\n        });\\n        for (int[] meeting: meetings){\\n            int x = meeting[0];\\n            int y = meeting[1];\\n            if((dsu.find(x) == dsu.find(0)) || (dsu.find(y) == dsu.find(0)))\\n                dsu.union(x,y);\\n        }\\n        int par = dsu.find(0);\\n        List<Integer> ans = new ArrayList<>();\\n        for (int i = 0; i < dsu.parent.length; i++){\\n            if(dsu.find(i) == par)\\n                ans.add(i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class DSU{\\n        int[] parent;\\n\\n        DSU(int size){\\n            parent = new int[size];\\n            for (int i = 0; i < parent.length; i++)\\n                parent[i] = i;\\n        }\\n\\n        int find(int x){\\n            if(parent[x] == x)\\n                return x;\\n            return parent[x] = find(parent[x]);\\n        }\\n\\n        void union(int x, int y){\\n            parent[find(x)] = find(y);\\n        }\\n    }\\n\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        DSU dsu = new DSU(n);\\n        dsu.union(0, firstPerson);\\n        Arrays.sort(meetings, (a,b) -> {\\n            if(a[2] != b[2])\\n                return Integer.compare(a[2], b[2]);\\n            else{\\n                int count1 = 0, count2 = 0;\\n                int x1 = a[0], y1 = a[1];\\n                int x2 = b[0] ,y2 = b[1];\\n                if(dsu.find(x1) == dsu.find(0))\\n                    count1++;\\n                if(dsu.find(y1) == dsu.find(0))\\n                    count1++;\\n\\n                if(dsu.find(x2) == dsu.find(0))\\n                    count2++;\\n                if(dsu.find(y2) == dsu.find(0)) \\n                    count2++;\\n                return Integer.compare(count2, count1);\\n            }\\n        });\\n        for (int[] meeting: meetings){\\n            int x = meeting[0];\\n            int y = meeting[1];\\n            if((dsu.find(x) == dsu.find(0)) || (dsu.find(y) == dsu.find(0)))\\n                dsu.union(x,y);\\n        }\\n        int par = dsu.find(0);\\n        List<Integer> ans = new ArrayList<>();\\n        for (int i = 0; i < dsu.parent.length; i++){\\n            if(dsu.find(i) == par)\\n                ans.add(i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108224,
                "title": "union-find-with-reset",
                "content": "`secret_group` tracks the group of people who know the secret.\\n\\nWe sort meetings by time. Then, going left-to-right, we join two people who meet at the time t. After all meetings at time t conclude, some people could be in the same group as person 0 (who started spreading the secret). Those folks learned the secret during meetings at time t.\\n\\nHowever, other people who met could be in a different group than person 0. Those people did not learn the secret. We disconnect those individuals from a group, as if they have never met.\\n```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        parent = [i for i in range(n)]\\n        secret_group = {0, firstPerson}\\n        parent[firstPerson] = 0\\n\\n        def find(a):\\n            while parent[a] != a:\\n                a = parent[a]\\n            return a\\n\\n        def union(a, b):\\n            par_a = find(a)\\n            par_b = find(b)\\n            if par_a < par_b:\\n                parent[par_b] = par_a\\n            else:\\n                parent[par_a] = par_b\\n\\n        meetings.sort(key=lambda x: x[2])\\n        meeting_groups = []\\n\\n        last_time = meetings[0][2]\\n        group = [[meetings[0][0], meetings[0][1]]]\\n\\n        for meet in meetings[1:]:\\n            if meet[2] == last_time:\\n                group.append([meet[0], meet[1]])\\n            else:\\n                meeting_groups.append(group)\\n                group = [[meet[0], meet[1]]]\\n                last_time = meet[2]\\n        meeting_groups.append(group)\\n\\n        for group in meeting_groups:\\n            for meet in group:\\n                union(meet[0], meet[1])\\n\\n            for meet in group:\\n                if find(meet[0]) != 0:\\n                    parent[meet[0]] = meet[0]\\n                    parent[meet[1]] = meet[1]\\n                else:\\n                    secret_group.add(meet[0])\\n                    secret_group.add(meet[1])\\n        return secret_group\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        parent = [i for i in range(n)]\\n        secret_group = {0, firstPerson}\\n        parent[firstPerson] = 0\\n\\n        def find(a):\\n            while parent[a] != a:\\n                a = parent[a]\\n            return a\\n\\n        def union(a, b):\\n            par_a = find(a)\\n            par_b = find(b)\\n            if par_a < par_b:\\n                parent[par_b] = par_a\\n            else:\\n                parent[par_a] = par_b\\n\\n        meetings.sort(key=lambda x: x[2])\\n        meeting_groups = []\\n\\n        last_time = meetings[0][2]\\n        group = [[meetings[0][0], meetings[0][1]]]\\n\\n        for meet in meetings[1:]:\\n            if meet[2] == last_time:\\n                group.append([meet[0], meet[1]])\\n            else:\\n                meeting_groups.append(group)\\n                group = [[meet[0], meet[1]]]\\n                last_time = meet[2]\\n        meeting_groups.append(group)\\n\\n        for group in meeting_groups:\\n            for meet in group:\\n                union(meet[0], meet[1])\\n\\n            for meet in group:\\n                if find(meet[0]) != 0:\\n                    parent[meet[0]] = meet[0]\\n                    parent[meet[1]] = meet[1]\\n                else:\\n                    secret_group.add(meet[0])\\n                    secret_group.add(meet[1])\\n        return secret_group\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076589,
                "title": "golang-priority-queue-bfs",
                "content": "```go\\ntype PriorityQueue [][2]int // pair<person, secretObtainedAt>\\n\\nfunc (pq PriorityQueue) Len() int           { return len(pq) }\\nfunc (pq PriorityQueue) Less(i, j int) bool { return pq[i][1] < pq[j][1] }\\nfunc (pq PriorityQueue) Swap(i, j int) { pq[i], pq[j] = pq[j], pq[i] }\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n  item := x.([2]int)\\n  *pq = append(*pq, item)\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n  old := *pq\\n  n := len(old)\\n  item := old[n-1]\\n  *pq = old[:n-1]\\n  return item\\n}\\n\\nfunc (pq PriorityQueue) Top() interface{} {\\n  return pq[0]\\n}\\n\\nfunc findAllPeople(n int, meetings [][]int, firstPerson int) []int {\\n  secretObtained := make([]int, n)\\n  for i := 0; i < len(secretObtained); i++ {\\n    secretObtained[i] = math.MaxInt32 // Initially set to a higher value\\n  }\\n  // We\\'re going to use a priority queue to store the list of people who have obtained the secret so far\\n  // along with the time they obtained at.\\n  var pq PriorityQueue\\n  // Process the meetings so that we can easily look up the meeting about a person\\n  adjacencyList := make([][][2]int, n)\\n  for _, meeting := range meetings {\\n    adjacencyList[meeting[0]] = append(adjacencyList[meeting[0]], [2]int{meeting[1], meeting[2]})\\n    adjacencyList[meeting[1]] = append(adjacencyList[meeting[1]], [2]int{meeting[0], meeting[2]})\\n  }\\n  heap.Push(&pq, [2]int{0, 0})\\n  heap.Push(&pq, [2]int{firstPerson, 0})\\n  for pq.Len() > 0 {\\n    top := heap.Pop(&pq).([2]int)\\n    if secretObtained[top[0]] < math.MaxInt32 {\\n      // We\\'ve already handled this person\\n      continue\\n    }\\n    secretObtained[top[0]] = top[1]\\n    // This person knows the secret. Let\\'s handle his meetings now\\n    for _, meeting := range adjacencyList[top[0]] {\\n      if meeting[1] >= top[1] { // meeting occurs after the person gets the secret\\n        if secretObtained[meeting[0]] == math.MaxInt32 {\\n          // The person he\\'s meeting with doesn\\'t know the secret yet\\n          heap.Push(&pq, [2]int{meeting[0], meeting[1]})\\n        }\\n      }\\n    }\\n  }\\n  var res []int\\n  for i := 0; i < len(secretObtained); i++ {\\n    if secretObtained[i] != math.MaxInt32 {\\n      res = append(res, i)\\n    }\\n  }\\n  return res\\n}\\n\\nfunc min(a, b int) int {\\n  if a < b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```go\\ntype PriorityQueue [][2]int // pair<person, secretObtainedAt>\\n\\nfunc (pq PriorityQueue) Len() int           { return len(pq) }\\nfunc (pq PriorityQueue) Less(i, j int) bool { return pq[i][1] < pq[j][1] }\\nfunc (pq PriorityQueue) Swap(i, j int) { pq[i], pq[j] = pq[j], pq[i] }\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n  item := x.([2]int)\\n  *pq = append(*pq, item)\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n  old := *pq\\n  n := len(old)\\n  item := old[n-1]\\n  *pq = old[:n-1]\\n  return item\\n}\\n\\nfunc (pq PriorityQueue) Top() interface{} {\\n  return pq[0]\\n}\\n\\nfunc findAllPeople(n int, meetings [][]int, firstPerson int) []int {\\n  secretObtained := make([]int, n)\\n  for i := 0; i < len(secretObtained); i++ {\\n    secretObtained[i] = math.MaxInt32 // Initially set to a higher value\\n  }\\n  // We\\'re going to use a priority queue to store the list of people who have obtained the secret so far\\n  // along with the time they obtained at.\\n  var pq PriorityQueue\\n  // Process the meetings so that we can easily look up the meeting about a person\\n  adjacencyList := make([][][2]int, n)\\n  for _, meeting := range meetings {\\n    adjacencyList[meeting[0]] = append(adjacencyList[meeting[0]], [2]int{meeting[1], meeting[2]})\\n    adjacencyList[meeting[1]] = append(adjacencyList[meeting[1]], [2]int{meeting[0], meeting[2]})\\n  }\\n  heap.Push(&pq, [2]int{0, 0})\\n  heap.Push(&pq, [2]int{firstPerson, 0})\\n  for pq.Len() > 0 {\\n    top := heap.Pop(&pq).([2]int)\\n    if secretObtained[top[0]] < math.MaxInt32 {\\n      // We\\'ve already handled this person\\n      continue\\n    }\\n    secretObtained[top[0]] = top[1]\\n    // This person knows the secret. Let\\'s handle his meetings now\\n    for _, meeting := range adjacencyList[top[0]] {\\n      if meeting[1] >= top[1] { // meeting occurs after the person gets the secret\\n        if secretObtained[meeting[0]] == math.MaxInt32 {\\n          // The person he\\'s meeting with doesn\\'t know the secret yet\\n          heap.Push(&pq, [2]int{meeting[0], meeting[1]})\\n        }\\n      }\\n    }\\n  }\\n  var res []int\\n  for i := 0; i < len(secretObtained); i++ {\\n    if secretObtained[i] != math.MaxInt32 {\\n      res = append(res, i)\\n    }\\n  }\\n  return res\\n}\\n\\nfunc min(a, b int) int {\\n  if a < b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2929422,
                "title": "c-sorting-bfs-intuitive-approach",
                "content": "**Divide** the entire graph into **components** based on the **time** of the meetings, otherwise simple dfs/bfs can lead to a flurry of explicit problems.\\n\\nFor every component, update the nodes that can be visited, based on the nodes already visited.\\n\\nPlease upvote if you find the solution good.\\n***Thank You!!***\\n```\\nclass Solution {\\npublic:\\n    vector<int> res; vector<bool> vis;\\n    static bool compt(vector<int>& a, vector<int>& b) {\\n        return a[2] < b[2];\\n    }\\n    void func(int n, vector<vector<int>>& temp) {\\n        unordered_map<int, vector<int>> adj;\\n        for(vector<int>& edge : temp) {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        queue<int> q;\\n        for(auto &p : adj) {\\n            if(vis[p.first]) {\\n                q.push(p.first);\\n            }\\n        }\\n        while(q.size()) {\\n            int curr = q.front(); q.pop();\\n            for(int& child : adj[curr]) {\\n                if(vis[child]) continue;\\n                vis[child] = 1;\\n                q.push(child);\\n            }\\n        }\\n    }\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        sort(meetings.begin(), meetings.end(), compt);\\n        vector<vector<int>> temp;\\n        vis = vector<bool> (n); vis[0] = 1, vis[firstPerson] = 1;\\n        int left = 0, right = 0, m = meetings.size();\\n        while(right < m) {\\n            if(meetings[left][2] - meetings[right][2]) {\\n                func(n, temp);\\n                temp.clear(); left = right;\\n            }\\n            temp.push_back(meetings[right]);\\n            right++;\\n        }\\n        func(n, temp);\\n        for(int i=0;i<n;i++) {\\n            if(vis[i]) res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> res; vector<bool> vis;\\n    static bool compt(vector<int>& a, vector<int>& b) {\\n        return a[2] < b[2];\\n    }\\n    void func(int n, vector<vector<int>>& temp) {\\n        unordered_map<int, vector<int>> adj;\\n        for(vector<int>& edge : temp) {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        queue<int> q;\\n        for(auto &p : adj) {\\n            if(vis[p.first]) {\\n                q.push(p.first);\\n            }\\n        }\\n        while(q.size()) {\\n            int curr = q.front(); q.pop();\\n            for(int& child : adj[curr]) {\\n                if(vis[child]) continue;\\n                vis[child] = 1;\\n                q.push(child);\\n            }\\n        }\\n    }\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        sort(meetings.begin(), meetings.end(), compt);\\n        vector<vector<int>> temp;\\n        vis = vector<bool> (n); vis[0] = 1, vis[firstPerson] = 1;\\n        int left = 0, right = 0, m = meetings.size();\\n        while(right < m) {\\n            if(meetings[left][2] - meetings[right][2]) {\\n                func(n, temp);\\n                temp.clear(); left = right;\\n            }\\n            temp.push_back(meetings[right]);\\n            right++;\\n        }\\n        func(n, temp);\\n        for(int i=0;i<n;i++) {\\n            if(vis[i]) res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2915333,
                "title": "python-3-fast-94-easy-to-understand-with-comments",
                "content": "![image.png](https://assets.leetcode.com/users/images/dbaf0def-0070-4012-abca-718bc138afcc_1671125799.3973007.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n\\n        knw_st  = set([0, firstPerson])\\n        dct_frm = defaultdict(list)\\n        hpf     = []\\n\\n        for psn_1, psn_2, time in meetings:\\n            dct_frm[psn_1].append((time, psn_2))   # psn_1 tell secret to psn_2 in time of the meeting\\n            dct_frm[psn_2].append((time, psn_1))   # psn_2 tell secret to psn_1 in time of the meeting\\n\\n        if 0 in dct_frm:             hpf.extend(dct_frm[0])             # start from 0-person    \\n        if firstPerson in dct_frm:   hpf.extend(dct_frm[firstPerson])   # start from firstPerson  \\n        heapify(hpf)\\n        \\n        while hpf:  # in heap will be only people who know secret\\n                    # heap will return first (in time) spread of the secret \\n                    # from person who already know the secret\\n            time, psn = heappop(hpf)\\n            \\n            if psn in knw_st:   continue   # person already know secret --> skip\\n            knw_st.add(psn)                # person doesn\\'t know secret --> add to set\\n            \\n            # add to heap people who have meetings with current person \\n            for (v_time, v_psn) in dct_frm[psn]: \\n                if v_psn in knw_st:   continue   # person already know secret --> skip\\n                if v_time < time:     continue   # time of the next meeting before current time --> skip\\n                heappush(hpf, (v_time, v_psn))\\n        \\n        return list(knw_st)\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n\\n        knw_st  = set([0, firstPerson])\\n        dct_frm = defaultdict(list)\\n        hpf     = []\\n\\n        for psn_1, psn_2, time in meetings:\\n            dct_frm[psn_1].append((time, psn_2))   # psn_1 tell secret to psn_2 in time of the meeting\\n            dct_frm[psn_2].append((time, psn_1))   # psn_2 tell secret to psn_1 in time of the meeting\\n\\n        if 0 in dct_frm:             hpf.extend(dct_frm[0])             # start from 0-person    \\n        if firstPerson in dct_frm:   hpf.extend(dct_frm[firstPerson])   # start from firstPerson  \\n        heapify(hpf)\\n        \\n        while hpf:  # in heap will be only people who know secret\\n                    # heap will return first (in time) spread of the secret \\n                    # from person who already know the secret\\n            time, psn = heappop(hpf)\\n            \\n            if psn in knw_st:   continue   # person already know secret --> skip\\n            knw_st.add(psn)                # person doesn\\'t know secret --> add to set\\n            \\n            # add to heap people who have meetings with current person \\n            for (v_time, v_psn) in dct_frm[psn]: \\n                if v_psn in knw_st:   continue   # person already know secret --> skip\\n                if v_time < time:     continue   # time of the next meeting before current time --> skip\\n                heappush(hpf, (v_time, v_psn))\\n        \\n        return list(knw_st)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2914349,
                "title": "java-beats-98-of-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe only tricky part of the problem is that sharing the secret happens instantaneously. This means that if two people meet at time t they are connected in the graph and that a person that knows the secret will broadcast it to the whole connected component. \\n\\nSo the problem becomes easy once we build the graph and broadcast the secret using a standard DFS algorithm.\\n\\nAt time t + 1 we repeat graph building and DFS.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGraph representation determines complexity: if we used an array n for adjacency list at each time t, in the worst case it would take n*m time. By using a sparse representation instead with hashing the time and memory will be optimized to m \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n + m)$$ every meeting is processed at most once\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n + m)$$ n for keeping track who knows the secret and m to store the graph of meetings\\n# Code\\n```\\nclass Solution {\\n\\n\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        secret = new boolean[n];\\n        secret[0] = true;\\n        secret[firstPerson] = true;\\n        Arrays.sort((Object[]) meetings, (i, j) -> Integer.compare(((int[]) i)[2], ((int[]) j)[2]));\\n        List<int[]> ms = Arrays.asList(meetings);\\n        int j = 0;\\n        for (int i = 1; i < meetings.length; ++i) {\\n            if (meetings[i][2] != meetings[j][2]) {\\n                solve(ms.subList(j, i));\\n                j = i;\\n            }\\n        }\\n        solve(ms.subList(j, meetings.length));\\n        List<Integer> ans = new ArrayList<>();\\n        for (int i = 0; i < n; ++i) {\\n            if (secret[i]) {\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    boolean[] secret;\\n    Map<Integer, List<Integer>> G;\\n    Set<Integer> seen;\\n\\n    private void solve(List<int[]> meetings) {\\n        G = new HashMap<>();\\n        seen = new HashSet<>();\\n        for (int[] m : meetings) {\\n            G.computeIfAbsent(m[0], u -> new ArrayList<>()).add(m[1]);\\n            G.computeIfAbsent(m[1], u -> new ArrayList<>()).add(m[0]);\\n        }\\n        for (int[] m : meetings) {\\n            if (secret[m[0]] || secret[m[1]]) { \\n                dfs(m[0]);\\n            }\\n        }\\n    }\\n\\n    private void dfs(int p) {\\n        if (!seen.add(p)) {\\n            return;\\n        }\\n        secret[p] = true;\\n        for (int o : G.get(p)) {\\n            dfs(o);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        secret = new boolean[n];\\n        secret[0] = true;\\n        secret[firstPerson] = true;\\n        Arrays.sort((Object[]) meetings, (i, j) -> Integer.compare(((int[]) i)[2], ((int[]) j)[2]));\\n        List<int[]> ms = Arrays.asList(meetings);\\n        int j = 0;\\n        for (int i = 1; i < meetings.length; ++i) {\\n            if (meetings[i][2] != meetings[j][2]) {\\n                solve(ms.subList(j, i));\\n                j = i;\\n            }\\n        }\\n        solve(ms.subList(j, meetings.length));\\n        List<Integer> ans = new ArrayList<>();\\n        for (int i = 0; i < n; ++i) {\\n            if (secret[i]) {\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    boolean[] secret;\\n    Map<Integer, List<Integer>> G;\\n    Set<Integer> seen;\\n\\n    private void solve(List<int[]> meetings) {\\n        G = new HashMap<>();\\n        seen = new HashSet<>();\\n        for (int[] m : meetings) {\\n            G.computeIfAbsent(m[0], u -> new ArrayList<>()).add(m[1]);\\n            G.computeIfAbsent(m[1], u -> new ArrayList<>()).add(m[0]);\\n        }\\n        for (int[] m : meetings) {\\n            if (secret[m[0]] || secret[m[1]]) { \\n                dfs(m[0]);\\n            }\\n        }\\n    }\\n\\n    private void dfs(int p) {\\n        if (!seen.add(p)) {\\n            return;\\n        }\\n        secret[p] = true;\\n        for (int o : G.get(p)) {\\n            dfs(o);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834491,
                "title": "python-graph-dfs",
                "content": "# Intuition\\nFor each meeting time we create `graph` where nodes are people with connection to other people if they intersected in different meetings.\\n\\n# Approach\\nGoing from people with secret which present on each meeting point through all other people and mark them as `visited`. Then updating set of people with secret with `visited` set.\\n\\n# Complexity\\n- Time complexity:\\nO(2N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        meetMap = {}\\n\\n        for a, b, t in meetings:\\n            if not t in meetMap:\\n                meetMap[t] = defaultdict(set)\\n            \\n            meetMap[t][a].add(b)\\n            meetMap[t][b].add(a)\\n\\n        withSecret = set([0, firstPerson])\\n\\n        def dfs(graph, node, visited):\\n            if node in visited:\\n                return\\n            visited.add(node)\\n\\n            for v in graph[node]:\\n                if v in visited:\\n                    continue\\n                dfs(graph, v, visited)\\n\\n        for t in sorted(meetMap.keys()):\\n            graph = meetMap[t]\\n            \\n            visited = set()\\n            for p in set(graph.keys()).intersection(withSecret):\\n                if p in visited:\\n                    continue\\n                \\n                dfs(graph, p, visited)\\n\\n            withSecret.update(visited)\\n\\n\\n        return list(withSecret)\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        meetMap = {}\\n\\n        for a, b, t in meetings:\\n            if not t in meetMap:\\n                meetMap[t] = defaultdict(set)\\n            \\n            meetMap[t][a].add(b)\\n            meetMap[t][b].add(a)\\n\\n        withSecret = set([0, firstPerson])\\n\\n        def dfs(graph, node, visited):\\n            if node in visited:\\n                return\\n            visited.add(node)\\n\\n            for v in graph[node]:\\n                if v in visited:\\n                    continue\\n                dfs(graph, v, visited)\\n\\n        for t in sorted(meetMap.keys()):\\n            graph = meetMap[t]\\n            \\n            visited = set()\\n            for p in set(graph.keys()).intersection(withSecret):\\n                if p in visited:\\n                    continue\\n                \\n                dfs(graph, p, visited)\\n\\n            withSecret.update(visited)\\n\\n\\n        return list(withSecret)\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2825282,
                "title": "c-bfs-priority-queue-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        unordered_map<int, set<pair<int, int> > > graph;\\n        vector<int> minTime(n + 1, 1e9);\\n        priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>> > pq;\\n        minTime[0] = 0;\\n        minTime[firstPerson] = 0;\\n        pq.push({ 0, 0 });\\n        pq.push({ 0, firstPerson });\\n        for(int i = 0; i < meetings.size(); i++) {\\n            graph[meetings[i][0]].insert({ meetings[i][2], meetings[i][1] });\\n            graph[meetings[i][1]].insert({ meetings[i][2], meetings[i][0] });\\n        }\\n        while(!pq.empty()) {\\n            pair<int, int> cur = pq.top();\\n            pq.pop();\\n            int node = cur.second, time = cur.first;\\n            auto startIt = graph[node].lower_bound({ time, 0 });\\n            for(auto it = startIt; it != graph[node].end(); it++) {\\n                int nextNode = it->second;\\n                if(it->first < minTime[nextNode]) {\\n                    minTime[nextNode] = it->first;\\n                    pq.push({ it->first, nextNode });\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i = 0; i < n; i++) {\\n            if(minTime[i] != 1e9) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Heap (Priority Queue)",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        unordered_map<int, set<pair<int, int> > > graph;\\n        vector<int> minTime(n + 1, 1e9);\\n        priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>> > pq;\\n        minTime[0] = 0;\\n        minTime[firstPerson] = 0;\\n        pq.push({ 0, 0 });\\n        pq.push({ 0, firstPerson });\\n        for(int i = 0; i < meetings.size(); i++) {\\n            graph[meetings[i][0]].insert({ meetings[i][2], meetings[i][1] });\\n            graph[meetings[i][1]].insert({ meetings[i][2], meetings[i][0] });\\n        }\\n        while(!pq.empty()) {\\n            pair<int, int> cur = pq.top();\\n            pq.pop();\\n            int node = cur.second, time = cur.first;\\n            auto startIt = graph[node].lower_bound({ time, 0 });\\n            for(auto it = startIt; it != graph[node].end(); it++) {\\n                int nextNode = it->second;\\n                if(it->first < minTime[nextNode]) {\\n                    minTime[nextNode] = it->first;\\n                    pq.push({ it->first, nextNode });\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i = 0; i < n; i++) {\\n            if(minTime[i] != 1e9) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811123,
                "title": "java-union-find",
                "content": "```\\nclass Solution {\\n    \\n    class uf {\\n        int[] parent = null;\\n        int[] depth = null;\\n        public uf(int n) {\\n            parent = new int[n];\\n            for(int i=0;i<parent.length;i++){\\n                parent[i] = i;\\n            }\\n        }\\n        \\n        public void union(int a, int b) {\\n            int ap = getParent(a);\\n            int bp = getParent(b);\\n            if(ap > bp) {\\n                parent[ap] = bp;\\n            } else {\\n                parent[bp] = ap;\\n            }\\n        }\\n        \\n        public int getParent(int a) {\\n            while(parent[a] != a) {\\n                a = parent[a];\\n            }\\n            return a;\\n        }\\n        \\n        public boolean find(int a, int b){\\n            int ap = getParent(a);\\n            int bp = getParent(b);\\n            return ap==bp;\\n        }\\n    }\\n    \\n    \\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        //we can use union find with path compression, we will have a map in time series\\n        // for each time,  we will iterate over the edges  and see of the any of the person knows thesecret then we can increase the count else we can pass\\n        uf unionfind = new uf(n);\\n        unionfind.union(0, firstPerson);\\n        List<Integer> ans = new LinkedList();\\n        HashSet<Integer> result = new HashSet();\\n        ans.add(0);\\n        ans.add(firstPerson);\\n        result.add(0);\\n        result.add(firstPerson);\\n        int[] prev = null;\\n        Arrays.sort(meetings, (int[] a, int[] b)->{if(a[2] != b[2]){return Integer.compare(a[2], b[2]);} else {return Integer.compare(a[0], b[0]);}});\\n        for(int i=0;i<meetings.length;i++){\\n            int timestamp = meetings[i][2];\\n            int j = i;\\n            HashSet<int[]> set = new HashSet();\\n\\t\\t\\t//this is a tricky part initially i thought sorting with timestamp would take care of this but by getting the testcases failed realized we will need this as well\\n            while(j<meetings.length && timestamp == meetings[j][2]) {\\n                set.add(meetings[j]);\\n                j++;\\n            }\\n            for(int[] x: set){\\n                unionfind.union(x[0], x[1]);\\n            }\\n            for(int[] x: set){\\n                if(!unionfind.find(x[1], 0)) {\\n                    unionfind.parent[x[1]] = x[1];\\n                } else {\\n                    if(!result.contains(x[1])) {\\n                        result.add(x[1]);\\n                        ans.add(x[1]);\\n                    }   \\n                }\\n                if(!unionfind.find(x[0], 0)) {\\n                    unionfind.parent[x[0]] = x[0];    \\n                } else {\\n                    if(!result.contains(x[0])) {\\n                        result.add(x[0]);\\n                        ans.add(x[0]);\\n                    }\\n                }\\n            }\\n            i=j-1;\\n        }\\n        //Collections.sort(ans);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    class uf {\\n        int[] parent = null;\\n        int[] depth = null;\\n        public uf(int n) {\\n            parent = new int[n];\\n            for(int i=0;i<parent.length;i++){\\n                parent[i] = i;\\n            }\\n        }\\n        \\n        public void union(int a, int b) {\\n            int ap = getParent(a);\\n            int bp = getParent(b);\\n            if(ap > bp) {\\n                parent[ap] = bp;\\n            } else {\\n                parent[bp] = ap;\\n            }\\n        }\\n        \\n        public int getParent(int a) {\\n            while(parent[a] != a) {\\n                a = parent[a];\\n            }\\n            return a;\\n        }\\n        \\n        public boolean find(int a, int b){\\n            int ap = getParent(a);\\n            int bp = getParent(b);\\n            return ap==bp;\\n        }\\n    }\\n    \\n    \\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        //we can use union find with path compression, we will have a map in time series\\n        // for each time,  we will iterate over the edges  and see of the any of the person knows thesecret then we can increase the count else we can pass\\n        uf unionfind = new uf(n);\\n        unionfind.union(0, firstPerson);\\n        List<Integer> ans = new LinkedList();\\n        HashSet<Integer> result = new HashSet();\\n        ans.add(0);\\n        ans.add(firstPerson);\\n        result.add(0);\\n        result.add(firstPerson);\\n        int[] prev = null;\\n        Arrays.sort(meetings, (int[] a, int[] b)->{if(a[2] != b[2]){return Integer.compare(a[2], b[2]);} else {return Integer.compare(a[0], b[0]);}});\\n        for(int i=0;i<meetings.length;i++){\\n            int timestamp = meetings[i][2];\\n            int j = i;\\n            HashSet<int[]> set = new HashSet();\\n\\t\\t\\t//this is a tricky part initially i thought sorting with timestamp would take care of this but by getting the testcases failed realized we will need this as well\\n            while(j<meetings.length && timestamp == meetings[j][2]) {\\n                set.add(meetings[j]);\\n                j++;\\n            }\\n            for(int[] x: set){\\n                unionfind.union(x[0], x[1]);\\n            }\\n            for(int[] x: set){\\n                if(!unionfind.find(x[1], 0)) {\\n                    unionfind.parent[x[1]] = x[1];\\n                } else {\\n                    if(!result.contains(x[1])) {\\n                        result.add(x[1]);\\n                        ans.add(x[1]);\\n                    }   \\n                }\\n                if(!unionfind.find(x[0], 0)) {\\n                    unionfind.parent[x[0]] = x[0];    \\n                } else {\\n                    if(!result.contains(x[0])) {\\n                        result.add(x[0]);\\n                        ans.add(x[0]);\\n                    }\\n                }\\n            }\\n            i=j-1;\\n        }\\n        //Collections.sort(ans);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780443,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n         \\n        vector<vector<pair<int,int>>> graph(n);\\n        \\n        vector<int> ans;\\n        \\n        for(auto &x: meetings)\\n        {\\n            graph[x[0]].push_back({x[1],x[2]});\\n            graph[x[1]].push_back({x[0],x[2]});\\n        }\\n        \\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        \\n    pq.push({0,0});\\n    pq.push({0,firstPerson});\\n        \\n    vector<bool> visited(n,false);\\n        \\n        vector<int> res;\\n        \\n    while(!pq.empty())\\n    {\\n        auto cur = pq.top();\\n        \\n        pq.pop();\\n        \\n        int time = cur.first;\\n        int person = cur.second;\\n        \\n         if(visited[person]) {\\n                continue;\\n            }\\n        \\n        \\n        visited[person] = true;\\n        \\n        for(auto &x: graph[person])\\n        {\\n           if(!visited[x.first] && x.second >= time) \\n           {\\n              pq.push({x.second,x.first});\\n           }\\n        }\\n        \\n    }\\n        \\n            for(int i = 0; i < n ; ++i )\\n            {\\n            if(visited[i]){\\n                res.push_back(i);        \\n            }\\n            }\\n        return res;\\n         \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n         \\n        vector<vector<pair<int,int>>> graph(n);\\n        \\n        vector<int> ans;\\n        \\n        for(auto &x: meetings)\\n        {\\n            graph[x[0]].push_back({x[1],x[2]}",
                "codeTag": "Java"
            },
            {
                "id": 2726926,
                "title": "union-find-java",
                "content": "```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        UnionFind uf = new UnionFind(n);\\n        \\n        Arrays.sort(meetings, (a, b) -> a[2] - b[2]);\\n        \\n        uf.union(0, firstPerson);\\n        \\n        for(int i = 0 , j = 0; i < meetings.length; i++){\\n            if(meetings[i][2] != meetings[j][2]){\\n                for(int k = j ; k < i ; k++){\\n                    if(!uf.isConnected(0, meetings[k][0]))\\n                        uf.set(meetings[k][0]);\\n                    if(!uf.isConnected(0, meetings[k][1]))\\n                        uf.set(meetings[k][1]);\\n                    \\n                }\\n                j = i ;\\n            }\\n             uf.union(meetings[i][0], meetings[i][1]);\\n        }\\n        \\n        return uf.count();\\n    }\\n}\\n\\nclass UnionFind{\\n    private int[] root;\\n    private int[] rank;\\n    \\n    UnionFind(int n){\\n        root = new int[n];\\n        rank = new int[n];\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            root[i] = i ;\\n        }\\n    }\\n    \\n    public int find(int x){\\n        if(x != root[x])\\n            return root[x] = find(root[x]);\\n        return root[x];\\n    }\\n    \\n    public void set(int x){\\n        root[x] = x;\\n    }\\n    \\n    public void union(int x, int y){\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        \\n        if(rootX == rootY)\\n            return;\\n        \\n        if(rank[rootX] < rank[rootY]){\\n            root[rootX] = rootY;\\n        }\\n        else if(rank[rootX] > rank[rootY]){\\n            root[rootY] = rootX;\\n        }\\n        else{\\n            root[rootY] = rootX;\\n            rank[rootX] += 1;\\n        }\\n    }\\n    \\n    public List<Integer> count(){    \\n        List<Integer> ans = new ArrayList<>();    \\n        for(int i = 0 ; i < root.length ; i++){\\n            if(isConnected(0, i))\\n                ans.add(i);\\n                \\n        } \\n        return ans;\\n    }\\n    \\n    public boolean isConnected(int x, int y){\\n        return find(x) == find(y);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        UnionFind uf = new UnionFind(n);\\n        \\n        Arrays.sort(meetings, (a, b) -> a[2] - b[2]);\\n        \\n        uf.union(0, firstPerson);\\n        \\n        for(int i = 0 , j = 0; i < meetings.length; i++){\\n            if(meetings[i][2] != meetings[j][2]){\\n                for(int k = j ; k < i ; k++){\\n                    if(!uf.isConnected(0, meetings[k][0]))\\n                        uf.set(meetings[k][0]);\\n                    if(!uf.isConnected(0, meetings[k][1]))\\n                        uf.set(meetings[k][1]);\\n                    \\n                }\\n                j = i ;\\n            }\\n             uf.union(meetings[i][0], meetings[i][1]);\\n        }\\n        \\n        return uf.count();\\n    }\\n}\\n\\nclass UnionFind{\\n    private int[] root;\\n    private int[] rank;\\n    \\n    UnionFind(int n){\\n        root = new int[n];\\n        rank = new int[n];\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            root[i] = i ;\\n        }\\n    }\\n    \\n    public int find(int x){\\n        if(x != root[x])\\n            return root[x] = find(root[x]);\\n        return root[x];\\n    }\\n    \\n    public void set(int x){\\n        root[x] = x;\\n    }\\n    \\n    public void union(int x, int y){\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        \\n        if(rootX == rootY)\\n            return;\\n        \\n        if(rank[rootX] < rank[rootY]){\\n            root[rootX] = rootY;\\n        }\\n        else if(rank[rootX] > rank[rootY]){\\n            root[rootY] = rootX;\\n        }\\n        else{\\n            root[rootY] = rootX;\\n            rank[rootX] += 1;\\n        }\\n    }\\n    \\n    public List<Integer> count(){    \\n        List<Integer> ans = new ArrayList<>();    \\n        for(int i = 0 ; i < root.length ; i++){\\n            if(isConnected(0, i))\\n                ans.add(i);\\n                \\n        } \\n        return ans;\\n    }\\n    \\n    public boolean isConnected(int x, int y){\\n        return find(x) == find(y);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2718319,
                "title": "plain-dijkstra-c-graph",
                "content": "Ultimately we have to make **time of knowing** the secret of all possible persons as **minimum** as possible so that they can tells the secrets to others as well.\\n\\nThis can be easily done by assuming the **meetings** **relation** as **graph** and apply **Dijkstra algorithm** on the basis of time of knowing the secret.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> dijkstra(vector<vector<pair<int,int>>> &graph, int firstPerson){\\n        int n = graph.size();\\n        vector<int> time(n, INT_MAX);\\n        time[0] = 0;\\n        time[firstPerson] = 0;\\n        \\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> heap;     // time, node\\n        heap.push({0,0});\\n        heap.push({0, firstPerson});       \\n        \\n        while(!heap.empty()){\\n            auto [curTime, curNode] = heap.top();\\n            heap.pop();\\n            \\n            for(auto next: graph[curNode]){\\n                auto [nextNode, nextTime] = next;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// if curNode already knows secret and its earlier before meeting time (nextTime)\\n\\t\\t\\t\\t// as well as nextTime is smaller than the current time of knowing the secret for nextNode:\\n                if(nextTime < time[nextNode] and nextTime >= curTime){\\n                    time[nextNode] = nextTime;\\n                    heap.push({time[nextNode], nextNode});\\n                }\\n            }\\n        }\\n        \\n        return time;\\n    }\\n    \\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        \\n        //build graph:\\n        vector<vector<pair<int,int>>> graph(n);\\n        for(auto x: meetings){\\n            int n1 = x[0];\\n            int n2 = x[1];\\n            int t = x[2];\\n            \\n            graph[n1].push_back({n2, t});\\n            graph[n2].push_back({n1, t});\\n        }\\n        \\n        //dijkstra\\n        vector<int> time = dijkstra(graph, firstPerson);        \\n        vector<int> ans;\\n        for(int i=0;i<n;i++){\\n            if(time[i] != INT_MAX) ans.push_back(i);   //whosoever knows secret i.e. t > 0.\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n//O(NlogN) + O(meetings.size())\\n```",
                "solutionTags": [
                    "C",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> dijkstra(vector<vector<pair<int,int>>> &graph, int firstPerson){\\n        int n = graph.size();\\n        vector<int> time(n, INT_MAX);\\n        time[0] = 0;\\n        time[firstPerson] = 0;\\n        \\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> heap;     // time, node\\n        heap.push({0,0});\\n        heap.push({0, firstPerson});       \\n        \\n        while(!heap.empty()){\\n            auto [curTime, curNode] = heap.top();\\n            heap.pop();\\n            \\n            for(auto next: graph[curNode]){\\n                auto [nextNode, nextTime] = next;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// if curNode already knows secret and its earlier before meeting time (nextTime)\\n\\t\\t\\t\\t// as well as nextTime is smaller than the current time of knowing the secret for nextNode:\\n                if(nextTime < time[nextNode] and nextTime >= curTime){\\n                    time[nextNode] = nextTime;\\n                    heap.push({time[nextNode], nextNode});\\n                }\\n            }\\n        }\\n        \\n        return time;\\n    }\\n    \\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        \\n        //build graph:\\n        vector<vector<pair<int,int>>> graph(n);\\n        for(auto x: meetings){\\n            int n1 = x[0];\\n            int n2 = x[1];\\n            int t = x[2];\\n            \\n            graph[n1].push_back({n2, t});\\n            graph[n2].push_back({n1, t});\\n        }\\n        \\n        //dijkstra\\n        vector<int> time = dijkstra(graph, firstPerson);        \\n        vector<int> ans;\\n        for(int i=0;i<n;i++){\\n            if(time[i] != INT_MAX) ans.push_back(i);   //whosoever knows secret i.e. t > 0.\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n//O(NlogN) + O(meetings.size())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2697274,
                "title": "python-2-solution-time-slice-dfs-union-find",
                "content": "1.DFS\\n```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        secrets = {0, firstPerson}\\n        graph, tp = [dict() for _ in range(n)], dict()\\n        for x, y, t in meetings:\\n            if t not in tp: tp[t] = set()\\n            tp[t].add(x)\\n            tp[t].add(y)\\n            if t not in graph[x]: graph[x][t] = []\\n            graph[x][t].append(y)\\n            if t not in graph[y]: graph[y][t] = []\\n            graph[y][t].append(x)\\n        def dfs(v, t, visited):\\n            visited.add(v)\\n            secrets.add(v)\\n            if t not in graph[v]: return\\n            for u in graph[v][t]:\\n                if u not in visited: dfs(u, t, visited)\\n        for t, p in sorted(tp.items()):\\n            visited = set()\\n            for v in secrets & p:\\n                if v not in visited: dfs(v, t, visited)\\n        return list(secrets)\\n```\\n2.Union Find\\n```\\nclass Uni:\\n    def __init__(self, n):\\n        self.rep = list(range(n))\\n    \\n    def find(self, x):\\n        if self.rep[x] != x: self.rep[x] = self.find(self.rep[x])\\n        return self.rep[x]\\n    \\n    def merge(self, x, y):\\n        x, y = self.find(x), self.find(y)\\n        if x != y: self.rep[max(x, y)] = self.rep[min(x, y)]\\n\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        time_meetings, tp = dict(), dict()\\n        for x, y, t in meetings:\\n            if t not in tp: tp[t] = set()\\n            tp[t].add(x)\\n            tp[t].add(y)\\n            if t not in time_meetings: time_meetings[t] = []\\n            time_meetings[t].append((x, y))\\n        uni = Uni(n)\\n        secrets = {0, firstPerson}\\n        uni.merge(0, firstPerson)\\n        for t, meetings in sorted(time_meetings.items()):\\n            for x, y in meetings: uni.merge(x, y)\\n            for v in tp[t] - secrets:\\n                if uni.find(v): uni.rep[v] = v\\n                else: secrets.add(v)\\n        return list(secrets)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        secrets = {0, firstPerson}\\n        graph, tp = [dict() for _ in range(n)], dict()\\n        for x, y, t in meetings:\\n            if t not in tp: tp[t] = set()\\n            tp[t].add(x)\\n            tp[t].add(y)\\n            if t not in graph[x]: graph[x][t] = []\\n            graph[x][t].append(y)\\n            if t not in graph[y]: graph[y][t] = []\\n            graph[y][t].append(x)\\n        def dfs(v, t, visited):\\n            visited.add(v)\\n            secrets.add(v)\\n            if t not in graph[v]: return\\n            for u in graph[v][t]:\\n                if u not in visited: dfs(u, t, visited)\\n        for t, p in sorted(tp.items()):\\n            visited = set()\\n            for v in secrets & p:\\n                if v not in visited: dfs(v, t, visited)\\n        return list(secrets)\\n```\n```\\nclass Uni:\\n    def __init__(self, n):\\n        self.rep = list(range(n))\\n    \\n    def find(self, x):\\n        if self.rep[x] != x: self.rep[x] = self.find(self.rep[x])\\n        return self.rep[x]\\n    \\n    def merge(self, x, y):\\n        x, y = self.find(x), self.find(y)\\n        if x != y: self.rep[max(x, y)] = self.rep[min(x, y)]\\n\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        time_meetings, tp = dict(), dict()\\n        for x, y, t in meetings:\\n            if t not in tp: tp[t] = set()\\n            tp[t].add(x)\\n            tp[t].add(y)\\n            if t not in time_meetings: time_meetings[t] = []\\n            time_meetings[t].append((x, y))\\n        uni = Uni(n)\\n        secrets = {0, firstPerson}\\n        uni.merge(0, firstPerson)\\n        for t, meetings in sorted(time_meetings.items()):\\n            for x, y in meetings: uni.merge(x, y)\\n            for v in tp[t] - secrets:\\n                if uni.find(v): uni.rep[v] = v\\n                else: secrets.add(v)\\n        return list(secrets)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2667237,
                "title": "python-simple-union-find",
                "content": "\\n    def findAllPeople(self, n, meetings, firstPerson):\\n        dict1 = defaultdict(int)\\n        \\n        def find(x):\\n            if x not in dict1:\\n                return x\\n            else:\\n                if x != dict1[x]:\\n                    dict1[x] = find(dict1[x])\\n                return dict1[x]\\n        \\n        def union(x,y):\\n            xx, yy = find(x), find(y)\\n            \\n            if xx > yy:\\n                xx, yy = yy, xx\\n                \\n            dict1[yy] = xx\\n            \\n        groups = defaultdict(list)\\n        \\n        for u, v, t in meetings:\\n            groups[t].append((u, v))\\n            \\n        union(0,firstPerson)\\n        \\n        for t in sorted(groups):\\n            group = groups[t]\\n            for u, v in group:\\n                union(u,v)\\n                \\n            for u, v in group:\\n                if find(u) and find(v):\\n                    dict1[u] = u\\n                    dict1[v] = v\\n                    \\n        return [i for i in range(n) if find(i) == 0]",
                "solutionTags": [],
                "code": "\\n    def findAllPeople(self, n, meetings, firstPerson):\\n        dict1 = defaultdict(int)\\n        \\n        def find(x):\\n            if x not in dict1:\\n                return x\\n            else:\\n                if x != dict1[x]:\\n                    dict1[x] = find(dict1[x])\\n                return dict1[x]\\n        \\n        def union(x,y):\\n            xx, yy = find(x), find(y)\\n            \\n            if xx > yy:\\n                xx, yy = yy, xx\\n                \\n            dict1[yy] = xx\\n            \\n        groups = defaultdict(list)\\n        \\n        for u, v, t in meetings:\\n            groups[t].append((u, v))\\n            \\n        union(0,firstPerson)\\n        \\n        for t in sorted(groups):\\n            group = groups[t]\\n            for u, v in group:\\n                union(u,v)\\n                \\n            for u, v in group:\\n                if find(u) and find(v):\\n                    dict1[u] = u\\n                    dict1[v] = v\\n                    \\n        return [i for i in range(n) if find(i) == 0]",
                "codeTag": "Python3"
            },
            {
                "id": 2621915,
                "title": "python-simple-bfs-1999ms-faster-than-100",
                "content": "```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        graph, timer, queue = defaultdict(list), defaultdict(int), deque()\\n        for meeting in meetings:\\n            graph[meeting[0]].append(meeting)\\n            graph[meeting[1]].append(meeting)\\n        queue.append(0); queue.append(firstPerson)\\n        timer[0], timer[firstPerson] = 0, 0\\n        while queue:\\n            currentPerson = queue.popleft()\\n            for meeting in graph[currentPerson]:\\n                person = meeting[1] if currentPerson == meeting[0] else meeting[0]\\n                if timer[currentPerson] > meeting[2]:\\n                    continue\\n                if person in timer and meeting[2] < timer[person]:\\n                    timer[person] = meeting[2]\\n                    queue.append(person)\\n                elif person not in timer:\\n                    timer[person] = meeting[2]\\n                    queue.append(person)\\n        return list(timer.keys())\\n                    \\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        graph, timer, queue = defaultdict(list), defaultdict(int), deque()\\n        for meeting in meetings:\\n            graph[meeting[0]].append(meeting)\\n            graph[meeting[1]].append(meeting)\\n        queue.append(0); queue.append(firstPerson)\\n        timer[0], timer[firstPerson] = 0, 0\\n        while queue:\\n            currentPerson = queue.popleft()\\n            for meeting in graph[currentPerson]:\\n                person = meeting[1] if currentPerson == meeting[0] else meeting[0]\\n                if timer[currentPerson] > meeting[2]:\\n                    continue\\n                if person in timer and meeting[2] < timer[person]:\\n                    timer[person] = meeting[2]\\n                    queue.append(person)\\n                elif person not in timer:\\n                    timer[person] = meeting[2]\\n                    queue.append(person)\\n        return list(timer.keys())\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2619849,
                "title": "python3-dfs-defaultdict-sorting",
                "content": "It is first understandable that the secrets get shared in a chronological order roughly speaking. However, we encounter some issues where there are multiple meetings at the same time. Therefore, we want to segregate all pairs of people (all 2 - person meetings) by time. We do this with the defaultdict ```pairs_by_time```.\\n\\nWe keep track of the people who share the secrets in our variable ```self.b**ches``` as people who share secrets are gossipers hence effectively characterless b**ches.\\n\\nAt each time, we can construct an adjacency list for all the people a person will share their secret to. We also keep track of every person in that time and iterate over all of them and share the secret as far as possible (dfs). We do some work by keeping an ```all_visited``` variable. If a person is in ```all_visited``` already they already know the secret and hence every person who could have known the secret from that person will already know it. So there is no point in doing a dfs again at this point because of wasted computation.\\n\\n\\n\\n```\\nfrom collections import defaultdict\\nfrom typing import List, DefaultDict\\n\\nclass Solution:\\n    def dfs(self, adj: DefaultDict[int, List[int]], person: int):\\n        self.visited.add(person)\\n        for adj_person in adj[person]:\\n            if adj_person not in self.visited:\\n                self.dfs(adj, adj_person)\\n                \\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        meetings.sort(key = itemgetter(2))\\n        \\n        pairs_by_time = defaultdict(list)\\n        all_times = set()\\n        for p1, p2, time in meetings:\\n            pairs_by_time[time].append((p1, p2))\\n            all_times.add(time)\\n        \\n        all_times = list(all_times)\\n        all_times.sort()\\n        \\n        self.bitches = set([0, firstPerson])\\n        \\n        for time in all_times:\\n            people_at_time = []\\n            adj = defaultdict(list)\\n            \\n            for p1, p2 in pairs_by_time[time]:\\n                adj[p1].append(p2)\\n                adj[p2].append(p1)\\n                people_at_time.append(p1)\\n                people_at_time.append(p2)\\n            \\n            all_visited = set()\\n            for person in people_at_time:\\n                if person in all_visited:\\n                    continue\\n                if person in self.bitches:\\n                    self.visited = set()\\n                    self.dfs(adj, person)\\n                    for bitch in self.visited:\\n                        self.bitches.add(bitch)\\n                        all_visited.add(bitch)\\n                    \\n\\n        return list(self.bitches)\\n        \\n        \\n",
                "solutionTags": [],
                "code": "```pairs_by_time```\n```self.b**ches```\n```all_visited```\n```all_visited```",
                "codeTag": "Unknown"
            },
            {
                "id": 2615687,
                "title": "c-bfs-solution-without-priority-queue-82-06-fastest",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        unordered_map<int, vector<vector<int>> > mp;\\n        unordered_map<int,int> timer;\\n        for(auto& meeting : meetings){\\n            mp[meeting[0]].push_back(meeting);\\n            mp[meeting[1]].push_back(meeting);\\n        }\\n        queue<int > que;\\n        que.push(0);\\n        que.push(firstPerson);\\n        timer[0] = 0;\\n        timer[firstPerson] = 0;\\n        while(!que.empty()){\\n            auto current = que.front();\\n            que.pop();\\n            for(auto& meeting: mp[current]){\\n                int person = meeting[0] == current ? meeting[1] : meeting[0];\\n                if(timer[current] > meeting[2])continue;\\n                if(timer.count(person) && meeting[2] < timer[person]){\\n                    timer[person] = meeting[2];\\n                    que.push(person);\\n                } else if(!timer.count(person)){\\n                    timer[person] = meeting[2];\\n                    que.push(person);\\n                }\\n            }\\n        }\\n        vector<int> res;\\n        for(auto& p: timer)res.push_back(p.first);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        unordered_map<int, vector<vector<int>> > mp;\\n        unordered_map<int,int> timer;\\n        for(auto& meeting : meetings){\\n            mp[meeting[0]].push_back(meeting);\\n            mp[meeting[1]].push_back(meeting);\\n        }\\n        queue<int > que;\\n        que.push(0);\\n        que.push(firstPerson);\\n        timer[0] = 0;\\n        timer[firstPerson] = 0;\\n        while(!que.empty()){\\n            auto current = que.front();\\n            que.pop();\\n            for(auto& meeting: mp[current]){\\n                int person = meeting[0] == current ? meeting[1] : meeting[0];\\n                if(timer[current] > meeting[2])continue;\\n                if(timer.count(person) && meeting[2] < timer[person]){\\n                    timer[person] = meeting[2];\\n                    que.push(person);\\n                } else if(!timer.count(person)){\\n                    timer[person] = meeting[2];\\n                    que.push(person);\\n                }\\n            }\\n        }\\n        vector<int> res;\\n        for(auto& p: timer)res.push_back(p.first);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2615220,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef pair<int,int> p;\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstP) \\n    {\\n        vector<int> ans;\\n        vector<bool> vis(n, false); \\n        vector<vector<p>> adj(n);   \\n        priority_queue<p, vector<p>, greater<p>> q;    \\n        int time, person;\\n        \\n        q.push({0,0}), q.push({0, firstP});   //because 0 and firstP know the secret at time =0\\n        \\n        for(auto i: meetings)  \\n        {\\n            adj[i[0]].push_back({i[2], i[1]});  // person - time of meeting, other person with whom meeting\\n            adj[i[1]].push_back({i[2], i[0]});\\n        }\\n        \\n        while(!q.empty()) \\n        {\\n            time = q.top().first;\\n            person = q.top().second;\\n            q.pop();\\n            \\n            if(vis[person])     \\n                continue; \\n            \\n            vis[person] = true;     \\n            ans.push_back(person);  //visited persons know the secret, jo jo jante ja rhe they will come in answer\\n            for(auto nbr: adj[person])\\n                if(vis[nbr.second] == false and nbr.first >= time)  \\n                    q.push(nbr);\\n        }\\n        return ans;\\n    }\\n};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef pair<int,int> p;\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstP) \\n    {\\n        vector<int> ans;\\n        vector<bool> vis(n, false); \\n        vector<vector<p>> adj(n);   \\n        priority_queue<p, vector<p>, greater<p>> q;    \\n        int time, person;\\n        \\n        q.push({0,0}), q.push({0, firstP});   //because 0 and firstP know the secret at time =0\\n        \\n        for(auto i: meetings)  \\n        {\\n            adj[i[0]].push_back({i[2], i[1]});  // person - time of meeting, other person with whom meeting\\n            adj[i[1]].push_back({i[2], i[0]});\\n        }\\n        \\n        while(!q.empty()) \\n        {\\n            time = q.top().first;\\n            person = q.top().second;\\n            q.pop();\\n            \\n            if(vis[person])     \\n                continue; \\n            \\n            vis[person] = true;     \\n            ans.push_back(person);  //visited persons know the secret, jo jo jante ja rhe they will come in answer\\n            for(auto nbr: adj[person])\\n                if(vis[nbr.second] == false and nbr.first >= time)  \\n                    q.push(nbr);\\n        }\\n        return ans;\\n    }\\n};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2561666,
                "title": "easy-c-bfs-solution-using-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        vector<vector<pair<int,int>>> g(n);\\n        vector<bool> vis(n,false);\\n        for(auto& i:meetings){\\n            g[i[0]].push_back({i[1],i[2]});\\n            g[i[1]].push_back({i[0],i[2]});\\n        }\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        pq.push({0,0});\\n        pq.push({0,firstPerson});\\n        while(!pq.empty()){\\n            auto [t,m]=pq.top();\\n            pq.pop();\\n            if(vis[m])continue;\\n            vis[m]=true;\\n            for(auto& it:g[m]){\\n                if(vis[it.first])continue;\\n                if(it.second>=t){\\n                    pq.push({it.second,it.first});\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<n;i++){\\n            if(vis[i])ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        vector<vector<pair<int,int>>> g(n);\\n        vector<bool> vis(n,false);\\n        for(auto& i:meetings){\\n            g[i[0]].push_back({i[1],i[2]});\\n            g[i[1]].push_back({i[0],i[2]});\\n        }\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        pq.push({0,0});\\n        pq.push({0,firstPerson});\\n        while(!pq.empty()){\\n            auto [t,m]=pq.top();\\n            pq.pop();\\n            if(vis[m])continue;\\n            vis[m]=true;\\n            for(auto& it:g[m]){\\n                if(vis[it.first])continue;\\n                if(it.second>=t){\\n                    pq.push({it.second,it.first});\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<n;i++){\\n            if(vis[i])ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2551159,
                "title": "dijkstra-python-easy-to-understand",
                "content": "The intuition is to visit people in the order of receiving secret, and when telling secret you can\\'t tell secret to a person with a meeting time earlier than your receiving secret time.\\nTo visit people in the order of receiving secret, a straightforward way is to reduce to Dijkstra algorithm where it visits vertices in increasing distance order. A tiny modification is to add a neighbor only if the edge\\'s weight is larger than current distance.\\nTime Complexity : `O((m+n)logn))` where `m` is number of meetings and ` n` is number of people.\\n```\\n def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        edges = defaultdict(list)\\n        for src, dst, time in meetings:\\n            edges[src].append((dst, time))\\n            edges[dst].append((src, time))\\n        earlist = defaultdict(lambda : float(\\'inf\\'))\\n        pq = [(0, firstPerson), (0, 0)]\\n        while pq:\\n            curr_time, curr = heapq.heappop(pq)\\n            if curr_time > earlist[curr]:\\n                continue\\n            earlist[curr] = curr_time\\n            for neighbor, time in edges[curr]:\\n                if time >= curr_time and time < earlist[neighbor]:\\n                    earlist[neighbor] = time\\n                    heapq.heappush(pq, (time, neighbor))\\n        return earlist.keys()\\n```",
                "solutionTags": [],
                "code": "```\\n def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        edges = defaultdict(list)\\n        for src, dst, time in meetings:\\n            edges[src].append((dst, time))\\n            edges[dst].append((src, time))\\n        earlist = defaultdict(lambda : float(\\'inf\\'))\\n        pq = [(0, firstPerson), (0, 0)]\\n        while pq:\\n            curr_time, curr = heapq.heappop(pq)\\n            if curr_time > earlist[curr]:\\n                continue\\n            earlist[curr] = curr_time\\n            for neighbor, time in edges[curr]:\\n                if time >= curr_time and time < earlist[neighbor]:\\n                    earlist[neighbor] = time\\n                    heapq.heappush(pq, (time, neighbor))\\n        return earlist.keys()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2544312,
                "title": "c-dijkstra-explained-in-detail",
                "content": "```\\n//Question Link->https://leetcode.com/problems/find-all-people-with-secret/\\n//Question Name->Find All People With Secret\\n//Question Category->Greedy\\n//Question Difficulty->Medium-hard(if you carck the question)\\n//Author->Rohit Kumar\\n\\n//Approach -> so first of all only 2 person knows the secret 0 and firstperson \\n//now how can other person know the sceret the must meet 0 or firstperson right\\n//so when a person meet 0 or firstperson he will know the secret\\n//the time when he meet 0 or firstperson is the time when he share the secret there\\n//if he meet before this time he will not know the secret\\n//so what is the approach as we know dijkstra is the best approach to find the shortest path\\n//so we know 0 and firstperson will know the secret at time=0 then we will update all there connection \\n// that you will get sceret from 0 at this time you will know the secret\\n//know we simply take the person which have known the secret at lowest time because may be there is a way he can\\n//send the secret to other person in less time eg-> if 0 have meeting with 1 at=4 and 0 have meeting with 2 at=5\\n// and 1 have meeting with 2 at=4 so 1 can send the secret to 2 in less time and then 2 can send the secret to other person in less time\\n//what if person meet before the time when he know the secret then no one know the secret so we will not update the connection\\n\\n\\n//please upvote the solution if you like it\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        \\n        vector<int> first(n,1e9);\\n        //we know that 0 and firstperson will know the secret at time=0\\n        first[firstPerson]=0;\\n        first[0]=0;\\n\\n        //it will store the time when a person will know the secret \\n        priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >pq;\\n\\n        vector<vector<pair<int,int> > >graph(n);\\n        for(int i=0;i<meetings.size();i++){\\n            int u=meetings[i][0],v=meetings[i][1],time=meetings[i][2];\\n            graph[u].push_back({v,time});\\n            graph[v].push_back({u,time});\\n            \\n        }\\n        //we push 0 and firstperson because the know secret at time =0;\\n        pq.push({0,0});\\n        pq.push({0,firstPerson});\\n\\n        while(pq.size()){\\n            pair<int,int> top=pq.top();\\n            pq.pop();\\n            //we take the lowest time person and update all the connection\\n            int current_time=top.first,node=top.second;\\n            if(first[node]<current_time){\\n\\t\\t\\t\\t//if we already visited this node in less time then all the connection are already know the screat at less time\\n                continue;\\n            }\\n            for(pair<int,int> a:graph[node]){\\n                if(a.second>=current_time&&first[a.first]>a.second){\\n                    first[a.first]=a.second;\\n                    pq.push({a.second,a.first});\\n                }\\n            }\\n        }\\n\\n        vector<int> ans;\\n        for(int i=0;i<n;i++){\\n            if(first[i]!=1e9){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//Question Link->https://leetcode.com/problems/find-all-people-with-secret/\\n//Question Name->Find All People With Secret\\n//Question Category->Greedy\\n//Question Difficulty->Medium-hard(if you carck the question)\\n//Author->Rohit Kumar\\n\\n//Approach -> so first of all only 2 person knows the secret 0 and firstperson \\n//now how can other person know the sceret the must meet 0 or firstperson right\\n//so when a person meet 0 or firstperson he will know the secret\\n//the time when he meet 0 or firstperson is the time when he share the secret there\\n//if he meet before this time he will not know the secret\\n//so what is the approach as we know dijkstra is the best approach to find the shortest path\\n//so we know 0 and firstperson will know the secret at time=0 then we will update all there connection \\n// that you will get sceret from 0 at this time you will know the secret\\n//know we simply take the person which have known the secret at lowest time because may be there is a way he can\\n//send the secret to other person in less time eg-> if 0 have meeting with 1 at=4 and 0 have meeting with 2 at=5\\n// and 1 have meeting with 2 at=4 so 1 can send the secret to 2 in less time and then 2 can send the secret to other person in less time\\n//what if person meet before the time when he know the secret then no one know the secret so we will not update the connection\\n\\n\\n//please upvote the solution if you like it\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        \\n        vector<int> first(n,1e9);\\n        //we know that 0 and firstperson will know the secret at time=0\\n        first[firstPerson]=0;\\n        first[0]=0;\\n\\n        //it will store the time when a person will know the secret \\n        priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >pq;\\n\\n        vector<vector<pair<int,int> > >graph(n);\\n        for(int i=0;i<meetings.size();i++){\\n            int u=meetings[i][0],v=meetings[i][1],time=meetings[i][2];\\n            graph[u].push_back({v,time});\\n            graph[v].push_back({u,time});\\n            \\n        }\\n        //we push 0 and firstperson because the know secret at time =0;\\n        pq.push({0,0});\\n        pq.push({0,firstPerson});\\n\\n        while(pq.size()){\\n            pair<int,int> top=pq.top();\\n            pq.pop();\\n            //we take the lowest time person and update all the connection\\n            int current_time=top.first,node=top.second;\\n            if(first[node]<current_time){\\n\\t\\t\\t\\t//if we already visited this node in less time then all the connection are already know the screat at less time\\n                continue;\\n            }\\n            for(pair<int,int> a:graph[node]){\\n                if(a.second>=current_time&&first[a.first]>a.second){\\n                    first[a.first]=a.second;\\n                    pq.push({a.second,a.first});\\n                }\\n            }\\n        }\\n\\n        vector<int> ans;\\n        for(int i=0;i<n;i++){\\n            if(first[i]!=1e9){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2530437,
                "title": "python-simple-dfs-solution-w-explanation-o-v-e-time-o-v-e-space-no-dsu",
                "content": "**Idea** - Maintain a `visited` array where `visited[i]` represents the time by which i-th person knows the secret and initialize it with all `inf`. Propagate the time by which a person knows the secret through the `graph` with two DFS calls, one from 0-th person and another from `firstPerson`.\\n\\nFor example, if person `u` knows the secret by time `t` and has a meeting with person `v` at time `w`, we call DFS if and only if it is possible to update `visited[v]` with a better (lesser) time and the meeting is after (or when) `u` knows the secret, i.e., `w >= t`.\\n\\n**Complexity Analysis**\\nNo. of nodes in the graph, V = n\\nNo. of edges in the graph, E = No. of meetings, m\\n\\nTime Complexity = O(V+E) = O(n+m)\\nSpace Complexity = O(V+E) = O(n+m)\\n```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        # Build the graph & store time of the meeting as weights of the edges\\n        adj = defaultdict(list)\\n        for x, y, time in meetings:\\n            adj[x].append((y, time))\\n            adj[y].append((x, time))\\n        \\n        # visited[i] = Time by which i-th person knows the secret\\n        visited = [inf for i in range(n)]\\n        \\n        # u-th person knows the secret by time t\\n        def dfs(u, t):\\n            visited[u] = t\\n            \\n            # Call DFS on connected nodes if an update is possible & meeting is after u knows\\n            for v, w in adj[u]:\\n                if visited[v] > w and w >= t:\\n                    dfs(v, w)\\n        \\n        # Start DFS from firstPerson and 0-th person\\n        dfs(0, 0)\\n        dfs(firstPerson, 0)\\n        \\n        # A person knows the secret if it gets to know the secret before inf\\n        return [i for i in range(n) if visited[i] != inf]\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        # Build the graph & store time of the meeting as weights of the edges\\n        adj = defaultdict(list)\\n        for x, y, time in meetings:\\n            adj[x].append((y, time))\\n            adj[y].append((x, time))\\n        \\n        # visited[i] = Time by which i-th person knows the secret\\n        visited = [inf for i in range(n)]\\n        \\n        # u-th person knows the secret by time t\\n        def dfs(u, t):\\n            visited[u] = t\\n            \\n            # Call DFS on connected nodes if an update is possible & meeting is after u knows\\n            for v, w in adj[u]:\\n                if visited[v] > w and w >= t:\\n                    dfs(v, w)\\n        \\n        # Start DFS from firstPerson and 0-th person\\n        dfs(0, 0)\\n        dfs(firstPerson, 0)\\n        \\n        # A person knows the secret if it gets to know the secret before inf\\n        return [i for i in range(n) if visited[i] != inf]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525152,
                "title": "c-dijkstra",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n\\t\\t\\tvector<vector<vector<int>>> g(n);\\n\\t\\t\\tvector<int> res;\\n\\t\\t\\tfor(int i=0;i<meetings.size();i++)  {\\n\\t\\t\\t\\tg[meetings[i][0]].push_back({meetings[i][1],meetings[i][2]});\\n\\t\\t\\t\\tg[meetings[i][1]].push_back({meetings[i][0],meetings[i][2]});\\n\\t\\t\\t}\\n\\t\\t\\tpriority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>> pq;\\n\\t\\t\\tvector<int> dist(n,INT_MAX),vis(n);\\n\\t\\t\\tpq.push({0,firstPerson});\\n\\t\\t\\tpq.push({0,0});\\n\\t\\t\\tdist[firstPerson]=0;\\n\\t\\t\\tdist[0]=0;\\n\\t\\t\\twhile(pq.size()) {\\n\\t\\t\\t\\tint u= pq.top()[1];\\n\\t\\t\\t\\tint t = pq.top()[0];\\n\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t\\tif(vis[u]) continue;\\n\\t\\t\\t\\tvis[u] = 1;\\n\\t\\t\\t\\tfor(int i=0;i<g[u].size();i++) {\\n\\t\\t\\t\\t\\tint v=g[u][i][0];\\n\\t\\t\\t\\t\\tint d=g[u][i][1];\\n\\t\\t\\t\\t\\tif(d>=t) {\\n\\t\\t\\t\\t\\t\\tdist[v]=d;\\n\\t\\t\\t\\t\\t\\tpq.push({dist[v],v});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0;i<n;i++) {\\n\\t\\t\\t\\tif(dist[i]!=INT_MAX) res.push_back(i);\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n\\t\\t\\tvector<vector<vector<int>>> g(n);\\n\\t\\t\\tvector<int> res;\\n\\t\\t\\tfor(int i=0;i<meetings.size();i++)  {\\n\\t\\t\\t\\tg[meetings[i][0]].push_back({meetings[i][1],meetings[i][2]}",
                "codeTag": "Java"
            },
            {
                "id": 2524038,
                "title": "python3-bfs-with-pq-solution-for-reference",
                "content": "```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings, firstPerson: int):        \\n        g = defaultdict(list)\\n\\n        for s,e,m in meetings:\\n            g[s].append((e, m))\\n            g[e].append((s, m))\\n\\n        st = [(0,0), (0,firstPerson)]\\n        ans = set([])\\n                \\n        while st:\\n            timeline, person = heapq.heappop(st)\\n                \\n            ans.add(person)\\n                        \\n            for p, time in g[person]:\\n                if time >= timeline and p not in ans:\\n                    heapq.heappush(st, (time, p))\\n                        \\n        return ans\\n",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def findAllPeople(self, n: int, meetings, firstPerson: int):        \\n        g = defaultdict(list)\\n\\n        for s,e,m in meetings:\\n            g[s].append((e, m))\\n            g[e].append((s, m))\\n\\n        st = [(0,0), (0,firstPerson)]\\n        ans = set([])\\n                \\n        while st:\\n            timeline, person = heapq.heappop(st)\\n                \\n            ans.add(person)\\n                        \\n            for p, time in g[person]:\\n                if time >= timeline and p not in ans:\\n                    heapq.heappush(st, (time, p))\\n                        \\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 2501386,
                "title": "c-bfs-code-easy-in-depth-explanation-example",
                "content": "**IDEA:**\\n1. We work according to the timeline of meeting. If at current time there\\'s a person who knows the secret only he can share it with others with whom he has meeting at that time of knowing or after.\\n\\n2. Once a person knows the secret, we mark them visited b/c there\\'s no need of this person getting to know the secret again afterwards.\\n\\n3. Priority queue(min heap) is used to store the minimum time of meeting of pairs.\\n\\n4. We need minimum time which is greater than or equal to the other person\\'s(who already knows) time of knowing the secret b/c this is the first time the curret person gets to know the secret and can spread to it\\'s neighbours with whom he has meeting in future or at that time when he gets to know.\\n\\n5. Also there are same pairs having multiple meetings so we want to store the minimum time of knowing among all those meetings. \\n\\n**Example:** [0,2,4], [0,2,1], [2,5,3].  \\nIf we store only the first one and mark 2 visited, 2\\'s time of knowing = 4\\nThen when we come to 2\\'s neighbour 5 we see that they have already met at time 3 and at that time 2 didn\\'t know the secret so 5 cannot know the secret. \\nHowever we know that 0 and 2 had meeting at time 1 also so 2 knew the secret at time 1 itself so he can tell to 5 at time 3. \\n***Using minHeap*** when we store adjacency of 0 as {time,neighbour} we have {1,2} at top and then {4,2}. So the first occurence according to timeline is checked first to note the first time a person gets to know the secret and we mark that visited when it comes on top of queue. Then even after popping when we have {4,2} 2 is already visitedc(2 has already shared the secret with his neighbours) so we just pop{4,2} and continue the loop without any changes.\\n\\n```\\nclass Solution {\\npublic:\\n    typedef pair<int,int> p;\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstP) \\n    {\\n        vector<int> ans;\\n        vector<bool> vis(n, false);  //1st time a person gets to know the secret, visited\\n        vector<vector<p>> adj(n);    //adjacency list, pairs having meeting and their meeting time\\n        priority_queue<p, vector<p>, greater<p>> q;    //min heap, sort according to time\\n        int time, person;\\n        \\n        q.push({0,0}), q.push({0, firstP});   //because the know at time 0\\n        \\n        for(auto i: meetings)  \\n        {\\n            adj[i[0]].push_back({i[2], i[1]}); //person - time of meeting, other person with whom meeting\\n            adj[i[1]].push_back({i[2], i[0]});\\n        }\\n        \\n        while(!q.empty())   //BFS\\n        {\\n            time = q.top().first;\\n            person = q.top().second;\\n            q.pop();\\n            \\n            if(vis[person])     //the person has already told the secret to his neighbours\\n                continue;\\n            \\n            vis[person] = true;     //else mark visited\\n            ans.push_back(person);  //visited persons know the secret, jo jo jante ja rhe they will come in answer\\n            for(auto neigh: adj[person])\\n                if(vis[neigh.second] == false and neigh.first >= time)  \\n                    q.push(neigh);\\n\\t\\t\\t//if neighbouring person is not visited and has meeting with the current already knowing person after or at the time the current person gets to know the secret then we push it into the queue\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef pair<int,int> p;\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstP) \\n    {\\n        vector<int> ans;\\n        vector<bool> vis(n, false);  //1st time a person gets to know the secret, visited\\n        vector<vector<p>> adj(n);    //adjacency list, pairs having meeting and their meeting time\\n        priority_queue<p, vector<p>, greater<p>> q;    //min heap, sort according to time\\n        int time, person;\\n        \\n        q.push({0,0}), q.push({0, firstP});   //because the know at time 0\\n        \\n        for(auto i: meetings)  \\n        {\\n            adj[i[0]].push_back({i[2], i[1]}); //person - time of meeting, other person with whom meeting\\n            adj[i[1]].push_back({i[2], i[0]});\\n        }\\n        \\n        while(!q.empty())   //BFS\\n        {\\n            time = q.top().first;\\n            person = q.top().second;\\n            q.pop();\\n            \\n            if(vis[person])     //the person has already told the secret to his neighbours\\n                continue;\\n            \\n            vis[person] = true;     //else mark visited\\n            ans.push_back(person);  //visited persons know the secret, jo jo jante ja rhe they will come in answer\\n            for(auto neigh: adj[person])\\n                if(vis[neigh.second] == false and neigh.first >= time)  \\n                    q.push(neigh);\\n\\t\\t\\t//if neighbouring person is not visited and has meeting with the current already knowing person after or at the time the current person gets to know the secret then we push it into the queue\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489677,
                "title": "java-simple-dfs-code",
                "content": "Put all meetings in PriorityQueue, Sort based on the meeting time. \\n\\nFor every time \\'t\\'  Do\\n\\tCreate a undirected graph of all the meetings placed at a \\'t\\' time with Person as node.\\n\\tTraverse the Node of graph, if any node knows the secret call dfs and mark all the connecting nodes visited.\\n\\t\\n\\n```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)->meetings[a][2]-meetings[b][2]);\\n        int l=meetings.length;\\n        while(l-->0){\\n            pq.offer(l);\\n        }\\n        \\n        Set<Integer> set=new HashSet<>();\\n        set.add(0); set.add(firstPerson); \\n\\n        while(!pq.isEmpty()){\\n            int a=pq.poll();\\n            Map<Integer, List<Integer>> map=new HashMap<>();\\n            map.computeIfAbsent(meetings[a][0], k-> new ArrayList<>()).add(meetings[a][1]);\\n            map.computeIfAbsent(meetings[a][1], k-> new ArrayList<>()).add(meetings[a][0]);\\n            while(!pq.isEmpty()&&meetings[pq.peek()][2]==meetings[a][2]){\\n                a=pq.poll();\\n                map.computeIfAbsent(meetings[a][0], k-> new ArrayList<>()).add(meetings[a][1]);\\n                map.computeIfAbsent(meetings[a][1], k-> new ArrayList<>()).add(meetings[a][0]);\\n            }\\n            helper(map,set);\\n        }\\n        List<Integer> lst=new LinkedList<>(set);\\n        return lst;\\n    }\\n    \\n    // traverse key of graph, if any key find in set call dfs \\n    private void helper(Map<Integer,List<Integer>> graph, Set<Integer> set){\\n        Set<Integer> visited=new HashSet<>();\\n        for(Integer key: graph.keySet()){\\n            if(!visited.contains(key)&&set.contains(key)){\\n                dfs(key, graph, set, visited);\\n            }\\n        }\\n    }\\n    private void dfs(int m, Map<Integer, List<Integer>> graph, Set<Integer> set, Set<Integer> visited){\\n        Stack<Integer> s=new Stack<>();\\n        s.push(m);\\n        while(!s.isEmpty()){\\n            int p=s.pop();\\n            visited.add(p); set.add(p);\\n            for(int adj: graph.get(p)){\\n                if(!visited.contains(adj)){\\n                    s.push(adj);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)->meetings[a][2]-meetings[b][2]);\\n        int l=meetings.length;\\n        while(l-->0){\\n            pq.offer(l);\\n        }\\n        \\n        Set<Integer> set=new HashSet<>();\\n        set.add(0); set.add(firstPerson); \\n\\n        while(!pq.isEmpty()){\\n            int a=pq.poll();\\n            Map<Integer, List<Integer>> map=new HashMap<>();\\n            map.computeIfAbsent(meetings[a][0], k-> new ArrayList<>()).add(meetings[a][1]);\\n            map.computeIfAbsent(meetings[a][1], k-> new ArrayList<>()).add(meetings[a][0]);\\n            while(!pq.isEmpty()&&meetings[pq.peek()][2]==meetings[a][2]){\\n                a=pq.poll();\\n                map.computeIfAbsent(meetings[a][0], k-> new ArrayList<>()).add(meetings[a][1]);\\n                map.computeIfAbsent(meetings[a][1], k-> new ArrayList<>()).add(meetings[a][0]);\\n            }\\n            helper(map,set);\\n        }\\n        List<Integer> lst=new LinkedList<>(set);\\n        return lst;\\n    }\\n    \\n    // traverse key of graph, if any key find in set call dfs \\n    private void helper(Map<Integer,List<Integer>> graph, Set<Integer> set){\\n        Set<Integer> visited=new HashSet<>();\\n        for(Integer key: graph.keySet()){\\n            if(!visited.contains(key)&&set.contains(key)){\\n                dfs(key, graph, set, visited);\\n            }\\n        }\\n    }\\n    private void dfs(int m, Map<Integer, List<Integer>> graph, Set<Integer> set, Set<Integer> visited){\\n        Stack<Integer> s=new Stack<>();\\n        s.push(m);\\n        while(!s.isEmpty()){\\n            int p=s.pop();\\n            visited.add(p); set.add(p);\\n            for(int adj: graph.get(p)){\\n                if(!visited.contains(adj)){\\n                    s.push(adj);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2483273,
                "title": "c-prim-s-algorithm-solution-with-comments",
                "content": "The code is basically prims algorithm with an addition condition that the new meeting time should not be less than the last attended meeting. This check basically prevents the new meetings secret sharing from affecting the past meetings.\\n```\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        \\n        // preparing the graph\\n        vector<pair<int,int>> g[n];\\n        for(auto &meeting: meetings){\\n            int person1 = meeting[0], person2 = meeting[1], time = meeting[2];\\n            g[person1].push_back({time, person2});\\n            g[person2].push_back({time, person1});\\n        }\\n        \\n        // min heap to get the neighbour we can connect with next (min time)\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;\\n        \\n        // defining threshold because once we have a meeting at time=5, the meetings at\\n        // time<5 can\\'t be considered\\n        int time_threshold = 0;\\n        \\n        // people who know the secret, also acts as a visited array\\n        vector<int> secretPeople(n,0);\\n        \\n        // at time=0, both 0 and first person know the secret\\n        pq.push({0,0});\\n        pq.push({0,firstPerson});\\n        \\n        // iterate over min heap, find the next meeting that can take place, update secretPeople\\n        while(pq.size()){\\n            auto node = pq.top();\\n            pq.pop();\\n            int time = node.first, person = node.second;\\n            \\n            // a check to prevent re processing\\n            if(secretPeople[person]) continue;\\n            \\n            // updating threshold\\n            time_threshold = max(time, time_threshold);\\n            \\n            secretPeople[person] = 1;\\n            for(auto &neighbour: g[person]){\\n                // not visited and meeting time should be > the current time\\n                if(neighbour.first>= time_threshold && secretPeople[neighbour.second]==0){\\n                    pq.push({neighbour});\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<n;i++){\\n            if(secretPeople[i]) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        \\n        // preparing the graph\\n        vector<pair<int,int>> g[n];\\n        for(auto &meeting: meetings){\\n            int person1 = meeting[0], person2 = meeting[1], time = meeting[2];\\n            g[person1].push_back({time, person2});\\n            g[person2].push_back({time, person1});\\n        }\\n        \\n        // min heap to get the neighbour we can connect with next (min time)\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;\\n        \\n        // defining threshold because once we have a meeting at time=5, the meetings at\\n        // time<5 can\\'t be considered\\n        int time_threshold = 0;\\n        \\n        // people who know the secret, also acts as a visited array\\n        vector<int> secretPeople(n,0);\\n        \\n        // at time=0, both 0 and first person know the secret\\n        pq.push({0,0});\\n        pq.push({0,firstPerson});\\n        \\n        // iterate over min heap, find the next meeting that can take place, update secretPeople\\n        while(pq.size()){\\n            auto node = pq.top();\\n            pq.pop();\\n            int time = node.first, person = node.second;\\n            \\n            // a check to prevent re processing\\n            if(secretPeople[person]) continue;\\n            \\n            // updating threshold\\n            time_threshold = max(time, time_threshold);\\n            \\n            secretPeople[person] = 1;\\n            for(auto &neighbour: g[person]){\\n                // not visited and meeting time should be > the current time\\n                if(neighbour.first>= time_threshold && secretPeople[neighbour.second]==0){\\n                    pq.push({neighbour});\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<n;i++){\\n            if(secretPeople[i]) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2417827,
                "title": "python-bfs-easy-to-understand",
                "content": "sort the meetings according to time;\\nfor the meetings at the same time, we form a graph,\\nthen do bfs to update the set of nodes which know the secrete.\\n\\n```\\ndef findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        meetings.sort(key=lambda x:x[2])\\n        s=set([0,firstPerson])\\n        i=0\\n        \\n        def bfs(g):\\n            nonlocal s\\n            q=deque([])\\n            visited=set()\\n            for nd in g:\\n                if nd in s:\\n                    q.append(nd)\\n                    visited.add(nd)\\n            while q:\\n                nd=q.popleft()\\n                for v in g[nd]:\\n                    if v not in visited and v not in s:\\n                        s.add(v)\\n                        q.append(v)\\n                        visited.add(v)\\n            \\n        m=len(meetings)                \\n        while i<m:\\n            a,b,time=meetings[i]\\n            g=defaultdict(set)\\n            g[a].add(b)\\n            g[b].add(a)\\n            while i+1<m and time==meetings[i+1][2]:\\n                i+=1\\n                c,d,t=meetings[i]\\n                g[c].add(d)\\n                g[d].add(c)\\n            i+=1\\n            bfs(g)        \\n            \\n        return list(s)\\n",
                "solutionTags": [],
                "code": "sort the meetings according to time;\\nfor the meetings at the same time, we form a graph,\\nthen do bfs to update the set of nodes which know the secrete.\\n\\n```\\ndef findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        meetings.sort(key=lambda x:x[2])\\n        s=set([0,firstPerson])\\n        i=0\\n        \\n        def bfs(g):\\n            nonlocal s\\n            q=deque([])\\n            visited=set()\\n            for nd in g:\\n                if nd in s:\\n                    q.append(nd)\\n                    visited.add(nd)\\n            while q:\\n                nd=q.popleft()\\n                for v in g[nd]:\\n                    if v not in visited and v not in s:\\n                        s.add(v)\\n                        q.append(v)\\n                        visited.add(v)\\n            \\n        m=len(meetings)                \\n        while i<m:\\n            a,b,time=meetings[i]\\n            g=defaultdict(set)\\n            g[a].add(b)\\n            g[b].add(a)\\n            while i+1<m and time==meetings[i+1][2]:\\n                i+=1\\n                c,d,t=meetings[i]\\n                g[c].add(d)\\n                g[d].add(c)\\n            i+=1\\n            bfs(g)        \\n            \\n        return list(s)\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2400598,
                "title": "test-case-issue",
                "content": "\\nI don\\'t understand this test case. 11\\n[[5,1,4],[0,4,18]]\\n1\\n\\nexpected : [0,1,4,5]\\n\\n0 told 1 at t = 0\\n0 told 4 at t = 18\\nBut nobody told 5 so how do we have 5 in the answer?",
                "solutionTags": [],
                "code": "\\nI don\\'t understand this test case. 11\\n[[5,1,4],[0,4,18]]\\n1\\n\\nexpected : [0,1,4,5]\\n\\n0 told 1 at t = 0\\n0 told 4 at t = 18\\nBut nobody told 5 so how do we have 5 in the answer?",
                "codeTag": "Unknown"
            },
            {
                "id": 2395170,
                "title": "java-rollback-dsu",
                "content": "```\\nclass Solution {\\n    void merge(int[] nodes, int i, int j) {\\n        int pI = parent(nodes, i), pJ = parent(nodes, j);\\n        if(pI == pJ) return;\\n        if(pI < pJ)\\n            nodes[pJ] = pI;\\n        else \\n            nodes[pI] = pJ;\\n    }\\n    \\n    int parent(int[] nodes, int i) {\\n        if(nodes[i] == i) return i;\\n        nodes[i] = parent(nodes, nodes[i]); // compress\\n        return nodes[i];\\n    }\\n    \\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        List<Integer> ans = new LinkedList<>();\\n        Arrays.sort(meetings, Comparator.comparing(i -> i[2]));\\n        int[] nodes = new int[n];\\n        for(int j = 0; j < n; j++) {\\n            nodes[j] = j;\\n        }\\n        nodes[firstPerson] = 0;\\n        \\n        int i = 0, len = meetings.length;\\n        while(i < len) {\\n            int j = i;\\n            while(j < len && meetings[j][2] == meetings[i][2]) {\\n                j++;\\n            }\\n            for(int l = i; l < j; l++) {\\n                merge(nodes, meetings[l][0], meetings[l][1]);\\n            }\\n\\t\\t\\t// rollback\\n            for(int l = i; l < j; l++) {\\n                if(parent(nodes, meetings[l][0]) != 0) {\\n                    nodes[meetings[l][0]] = meetings[l][0];\\n                }\\n                if(parent(nodes, meetings[l][1]) != 0) {\\n                    nodes[meetings[l][1]] = meetings[l][1];\\n                }\\n            }\\n            i = j;\\n        }\\n        for(int j = 0; j < n; j++) {\\n            if(parent(nodes, j) == 0) {\\n                ans.add(j);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    void merge(int[] nodes, int i, int j) {\\n        int pI = parent(nodes, i), pJ = parent(nodes, j);\\n        if(pI == pJ) return;\\n        if(pI < pJ)\\n            nodes[pJ] = pI;\\n        else \\n            nodes[pI] = pJ;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2385011,
                "title": "java-priority-queue-can-somebody-point-out-why-its-giving-tle",
                "content": "```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        List<Integer> result = new ArrayList<>();\\n        result.add(0);\\n        if(meetings==null || meetings.length == 0) return result;\\n        Map<Integer, List<Meeting>> map = new HashMap<>();\\n        for(int i=0;i<n;i++)\\n            map.put(i, new ArrayList<>());\\n        map.computeIfAbsent(0, k-> new ArrayList<>()).add(new Meeting(firstPerson, 0));\\n        map.computeIfAbsent(firstPerson, k-> new ArrayList<>()).add(new Meeting(0, 0));\\n        // result.add(meetings[0][0]);\\n        for(int i=0;i<meetings.length;i++) {\\n            map.computeIfAbsent(meetings[i][0], k-> new ArrayList<>()).add(new Meeting(meetings[i][1], meetings[i][2]));\\n            map.computeIfAbsent(meetings[i][1], k-> new ArrayList<>()).add(new Meeting(meetings[i][0], meetings[i][2]));\\n        }\\n        // System.out.println(map);\\n        PriorityQueue<int[]> q = new PriorityQueue<>((a,b)->(a[1]-b[1]));\\n        q.add(new int[]{0, 0});\\n        Set<Integer> visited = new HashSet<>();\\n        while(!q.isEmpty()) {\\n            int[] po = q.poll();\\n            if(visited.contains(po[0])) continue;\\n            visited.add(po[0]);\\n            for(Meeting m : map.get(po[0])) {\\n                if(m.time<po[1])\\n                    continue;\\n                q.add(new int[]{m.person, m.time});\\n                if(!result.contains(m.person))\\n                    result.add(m.person);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\nclass Meeting {\\n    int person;\\n    int time;\\n    Meeting(int person, int time) {\\n        this.person = person;\\n        this.time = time;\\n    }\\n}\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        List<Integer> result = new ArrayList<>();\\n        result.add(0);\\n        if(meetings==null || meetings.length == 0) return result;\\n        Map<Integer, List<Meeting>> map = new HashMap<>();\\n        for(int i=0;i<n;i++)\\n            map.put(i, new ArrayList<>());\\n        map.computeIfAbsent(0, k-> new ArrayList<>()).add(new Meeting(firstPerson, 0));\\n        map.computeIfAbsent(firstPerson, k-> new ArrayList<>()).add(new Meeting(0, 0));\\n        // result.add(meetings[0][0]);\\n        for(int i=0;i<meetings.length;i++) {\\n            map.computeIfAbsent(meetings[i][0], k-> new ArrayList<>()).add(new Meeting(meetings[i][1], meetings[i][2]));\\n            map.computeIfAbsent(meetings[i][1], k-> new ArrayList<>()).add(new Meeting(meetings[i][0], meetings[i][2]));\\n        }\\n        // System.out.println(map);\\n        PriorityQueue<int[]> q = new PriorityQueue<>((a,b)->(a[1]-b[1]));\\n        q.add(new int[]{0, 0});\\n        Set<Integer> visited = new HashSet<>();\\n        while(!q.isEmpty()) {\\n            int[] po = q.poll();\\n            if(visited.contains(po[0])) continue;\\n            visited.add(po[0]);\\n            for(Meeting m : map.get(po[0])) {\\n                if(m.time<po[1])\\n                    continue;\\n                q.add(new int[]{m.person, m.time});\\n                if(!result.contains(m.person))\\n                    result.add(m.person);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\nclass Meeting {\\n    int person;\\n    int time;\\n    Meeting(int person, int time) {\\n        this.person = person;\\n        this.time = time;\\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2338592,
                "title": "javascript-graph-dfs",
                "content": "Explanation:\\nWe need to first sort the meetings with their times. Now, at each time, there might be multiple people having meetings. If one person is in a meeting with someone else, they will share the secret with them, and the second person will share it in all the meetings they are in and so on. Intutively, this creates a graph like structure, where at a particular time, the graph has edges which connect 2 people in a meeting. There is one graph for each time. \\n\\nFinally, we need to look at all the meeting times in increasing order and see who gets the secrets. The secret sharing is implemented using dfs starting at people who already have the secret at this point in time. We maintain a list **people** which tells us if a personId has the secret.\\n\\n**peopleMeetingAtTime** is a list of graphs corresponding to each meeting time. We have to run dfs for all these graphs and keep updating the **people** list for all the visited nodes. \\n\\n```/**\\n * @param {number} n\\n * @param {number[][]} meetings\\n * @param {number} firstPerson\\n * @return {number[]}\\n */\\nvar findAllPeople = function(n, meetings, firstPerson) {\\n    let people = new Array(n).fill(0);\\n    people[0] = 1;\\n    people[firstPerson] = 1;\\n    meetings = meetings.sort((x, y)=>{\\n        return (x[2] > y[2])?1:-1;\\n    });\\n    let maxTime = meetings[meetings.length - 1][2];\\n    let peopleMeetingAtTime = new Array(maxTime);\\n    for(let meeting of meetings) {\\n        let [x, y, time] = meeting;\\n        peopleMeetingAtTime[time] = peopleMeetingAtTime[time] || {};\\n        let graph  = peopleMeetingAtTime[time];\\n        graph[x] = graph[x] || [];\\n        graph[y] = graph[y] || [];\\n        graph[x].push(y);\\n        graph[y].push(x);\\n    }\\n    peopleMeetingAtTime = peopleMeetingAtTime.filter(x=>x);\\n    for(let graph of peopleMeetingAtTime) {\\n        let visited = {};\\n        for(let node in graph) {\\n            if(people[node] && !visited[node]) {\\n                dfs(graph, node, visited, people);\\n            }\\n        }\\n        \\n    }\\n    let out = [];\\n    for(let i = 0;i < n;i++) {\\n        if(people[i]) {\\n            out.push(i);\\n        }\\n    }\\n    return out;\\n};\\n\\nfunction dfs(graph, node, visited, people) {\\n    visited[node] = 1;\\n    people[node] = 1;\\n    for(let child of (graph[node] || [])) {\\n        if(!visited[child]) {\\n            dfs(graph, child, visited, people);\\n        }\\n    }\\n}",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "Explanation:\\nWe need to first sort the meetings with their times. Now, at each time, there might be multiple people having meetings. If one person is in a meeting with someone else, they will share the secret with them, and the second person will share it in all the meetings they are in and so on. Intutively, this creates a graph like structure, where at a particular time, the graph has edges which connect 2 people in a meeting. There is one graph for each time. \\n\\nFinally, we need to look at all the meeting times in increasing order and see who gets the secrets. The secret sharing is implemented using dfs starting at people who already have the secret at this point in time. We maintain a list **people** which tells us if a personId has the secret.\\n\\n**peopleMeetingAtTime** is a list of graphs corresponding to each meeting time. We have to run dfs for all these graphs and keep updating the **people** list for all the visited nodes. \\n\\n```/**\\n * @param {number} n\\n * @param {number[][]} meetings\\n * @param {number} firstPerson\\n * @return {number[]}\\n */\\nvar findAllPeople = function(n, meetings, firstPerson) {\\n    let people = new Array(n).fill(0);\\n    people[0] = 1;\\n    people[firstPerson] = 1;\\n    meetings = meetings.sort((x, y)=>{\\n        return (x[2] > y[2])?1:-1;\\n    });\\n    let maxTime = meetings[meetings.length - 1][2];\\n    let peopleMeetingAtTime = new Array(maxTime);\\n    for(let meeting of meetings) {\\n        let [x, y, time] = meeting;\\n        peopleMeetingAtTime[time] = peopleMeetingAtTime[time] || {};\\n        let graph  = peopleMeetingAtTime[time];\\n        graph[x] = graph[x] || [];\\n        graph[y] = graph[y] || [];\\n        graph[x].push(y);\\n        graph[y].push(x);\\n    }\\n    peopleMeetingAtTime = peopleMeetingAtTime.filter(x=>x);\\n    for(let graph of peopleMeetingAtTime) {\\n        let visited = {};\\n        for(let node in graph) {\\n            if(people[node] && !visited[node]) {\\n                dfs(graph, node, visited, people);\\n            }\\n        }\\n        \\n    }\\n    let out = [];\\n    for(let i = 0;i < n;i++) {\\n        if(people[i]) {\\n            out.push(i);\\n        }\\n    }\\n    return out;\\n};\\n\\nfunction dfs(graph, node, visited, people) {\\n    visited[node] = 1;\\n    people[node] = 1;\\n    for(let child of (graph[node] || [])) {\\n        if(!visited[child]) {\\n            dfs(graph, child, visited, people);\\n        }\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2332984,
                "title": "solution-in-java-bfs-treemap",
                "content": "```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {        \\n        Map<Integer, TreeMap<Integer, Set<Integer>>> schedule = buildMeetings(meetings);\\n        Set<Integer> secretOwners = new HashSet<>();\\n        PriorityQueue<int[]> q = new PriorityQueue<>((a,b)->a[1]-b[1]);\\n        q.offer(new int[]{0,0});\\n        q.offer(new int[]{firstPerson,0});\\n        \\n        while(!q.isEmpty()) {\\n            int[] personWithSecret = q.poll();\\n            if(secretOwners.contains(personWithSecret[0])) continue;\\n            secretOwners.add(personWithSecret[0]);\\n            Map<Integer, Set<Integer>> candidates = getCandidates(personWithSecret[0], schedule, personWithSecret[1]);\\n            for(Map.Entry<Integer, Set<Integer>> entry: candidates.entrySet()) {\\n                for(Integer candidate: entry.getValue()){\\n                    if(secretOwners.contains(candidate)) continue;\\n                    q.offer(new int[] {candidate, entry.getKey()});\\n                }\\n            }\\n        }\\n        \\n        return secretOwners.stream().collect(Collectors.toList());\\n    }\\n    \\n    private Map<Integer, Set<Integer>> getCandidates(int person, Map<Integer, TreeMap<Integer, Set<Integer>>> schedule, int startTime) {\\n        if(!schedule.containsKey(person) || schedule.get(person).isEmpty()) {\\n            return Collections.emptyMap();\\n        }\\n        List<int[]> res = new LinkedList<>();\\n        return schedule.get(person).tailMap(startTime);\\n    }\\n    \\n    private Map<Integer, TreeMap<Integer, Set<Integer>>> buildMeetings(int[][] meetings) {\\n        Map<Integer, TreeMap<Integer, Set<Integer>>> schedule = new HashMap<>();\\n        for(int[] meeting: meetings) {\\n            int p1 = meeting[0];\\n            int p2 = meeting[1];\\n            int time = meeting[2];\\n            \\n            schedule.putIfAbsent(p1, new TreeMap<>());\\n            schedule.putIfAbsent(p2, new TreeMap<>());\\n            \\n            schedule.get(p1).putIfAbsent(time, new HashSet<>());\\n            schedule.get(p2).putIfAbsent(time, new HashSet<>());\\n            schedule.get(p1).get(time).add(p2);\\n            schedule.get(p2).get(time).add(p1);\\n        }\\n        \\n        return schedule;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {        \\n        Map<Integer, TreeMap<Integer, Set<Integer>>> schedule = buildMeetings(meetings);\\n        Set<Integer> secretOwners = new HashSet<>();\\n        PriorityQueue<int[]> q = new PriorityQueue<>((a,b)->a[1]-b[1]);\\n        q.offer(new int[]{0,0});\\n        q.offer(new int[]{firstPerson,0});\\n        \\n        while(!q.isEmpty()) {\\n            int[] personWithSecret = q.poll();\\n            if(secretOwners.contains(personWithSecret[0])) continue;\\n            secretOwners.add(personWithSecret[0]);\\n            Map<Integer, Set<Integer>> candidates = getCandidates(personWithSecret[0], schedule, personWithSecret[1]);\\n            for(Map.Entry<Integer, Set<Integer>> entry: candidates.entrySet()) {\\n                for(Integer candidate: entry.getValue()){\\n                    if(secretOwners.contains(candidate)) continue;\\n                    q.offer(new int[] {candidate, entry.getKey()});\\n                }\\n            }\\n        }\\n        \\n        return secretOwners.stream().collect(Collectors.toList());\\n    }\\n    \\n    private Map<Integer, Set<Integer>> getCandidates(int person, Map<Integer, TreeMap<Integer, Set<Integer>>> schedule, int startTime) {\\n        if(!schedule.containsKey(person) || schedule.get(person).isEmpty()) {\\n            return Collections.emptyMap();\\n        }\\n        List<int[]> res = new LinkedList<>();\\n        return schedule.get(person).tailMap(startTime);\\n    }\\n    \\n    private Map<Integer, TreeMap<Integer, Set<Integer>>> buildMeetings(int[][] meetings) {\\n        Map<Integer, TreeMap<Integer, Set<Integer>>> schedule = new HashMap<>();\\n        for(int[] meeting: meetings) {\\n            int p1 = meeting[0];\\n            int p2 = meeting[1];\\n            int time = meeting[2];\\n            \\n            schedule.putIfAbsent(p1, new TreeMap<>());\\n            schedule.putIfAbsent(p2, new TreeMap<>());\\n            \\n            schedule.get(p1).putIfAbsent(time, new HashSet<>());\\n            schedule.get(p2).putIfAbsent(time, new HashSet<>());\\n            schedule.get(p1).get(time).add(p2);\\n            schedule.get(p2).get(time).add(p1);\\n        }\\n        \\n        return schedule;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2309054,
                "title": "readable-self-documenting-c",
                "content": "Time O(N * Log(N)).\\nSpace O(M^2) where M is the number of people who talked during a specific time.\\n\\n```\\npublic class Solution\\n{\\n    public IList<int> FindAllPeople(int n, int[][] meetings, int firstPerson)\\n    {\\n        var sortedMeetings = meetings\\n            .OrderBy(meeting => meeting[2])\\n            .ToArray();\\n        \\n        var secretKnowers = new HashSet<int>();\\n        \\n        secretKnowers.Add(0);\\n        secretKnowers.Add(firstPerson);\\n        \\n        // <int, List<int>> -> person talked to, people who talked to this person\\n        Dictionary<int, HashSet<int>> peopleWhoTalkedToPerson = new();\\n        \\n        // Each of these variables could have \"AtACertainTime\" appended to their names.\\n        var peopleWhoToldSecret = new Queue<int>();\\n        var secretLearners = new HashSet<int>();\\n        var seenSecretTellers = new HashSet<int>();\\n        var uniquePeopleWhoToldSecret = new HashSet<int>();\\n        \\n        var meeting = 0;\\n        \\n        // Internally, this loop processes groups of people that talked during the same time.\\n        // When we arrive back at the top of this loop, we will be looking at a time that differs\\n        // from the previous time that was proceesed.\\n        while (meeting < sortedMeetings.Length)\\n        {\\n            peopleWhoTalkedToPerson.Clear();\\n            \\n            var currentTime = sortedMeetings[meeting][2];\\n            \\n            // Gather all people for all meetings for a single, specific time.\\n            // For a given time - keep track of all people who talked and all of the people that\\n            // person talked to.\\n            while (meeting < sortedMeetings.Length && sortedMeetings[meeting][2] == currentTime)\\n            {\\n                if (!peopleWhoTalkedToPerson.ContainsKey(sortedMeetings[meeting][1]))\\n                {\\n                    peopleWhoTalkedToPerson.Add(sortedMeetings[meeting][1], new HashSet<int>());\\n                }\\n\\n                peopleWhoTalkedToPerson[sortedMeetings[meeting][1]].Add(sortedMeetings[meeting][0]);\\n                \\n                if (!peopleWhoTalkedToPerson.ContainsKey(sortedMeetings[meeting][0]))\\n                {\\n                    peopleWhoTalkedToPerson.Add(sortedMeetings[meeting][0], new HashSet<int>());\\n                }\\n\\n                peopleWhoTalkedToPerson[sortedMeetings[meeting][0]].Add(sortedMeetings[meeting][1]);\\n                \\n                meeting += 1;\\n            }\\n            \\n            var peopleWhoTalked = peopleWhoTalkedToPerson.Keys;\\n            \\n            // Identify people who told the secret.\\n            foreach (var person in peopleWhoTalked)\\n            {\\n                if (secretKnowers.Contains(person) && !uniquePeopleWhoToldSecret.Contains(person))\\n                {\\n                    peopleWhoToldSecret.Enqueue(person);\\n                    uniquePeopleWhoToldSecret.Add(person);\\n                }\\n            }\\n            \\n            // Clear all storage so we can use it as new.\\n            uniquePeopleWhoToldSecret.Clear();\\n            seenSecretTellers.Clear();\\n            secretLearners.Clear();\\n            \\n            // Process all that who told the secret - which also includes those which\\n            // just learned the secret during this time.\\n            // This takes care of the \"instantaneously\" criteria.\\n            while (peopleWhoToldSecret.Count > 0)\\n            {\\n                var secretSharer = peopleWhoToldSecret.Dequeue();\\n                if (seenSecretTellers.Contains(secretSharer))\\n                {\\n                    continue;\\n                }\\n                \\n                seenSecretTellers.Add(secretSharer);\\n                \\n                foreach (var secretLearner in peopleWhoTalkedToPerson[secretSharer])\\n                {\\n                    secretLearners.Add(secretLearner);\\n                    peopleWhoToldSecret.Enqueue(secretLearner);\\n                }\\n            }\\n            \\n            // Those who learned the secret are now secret knowers for future times.\\n            foreach (var secretLearner in secretLearners)\\n            {\\n                secretKnowers.Add(secretLearner);\\n            }\\n        }\\n        \\n        var output = new List<int>(secretKnowers);\\n        \\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public IList<int> FindAllPeople(int n, int[][] meetings, int firstPerson)\\n    {\\n        var sortedMeetings = meetings\\n            .OrderBy(meeting => meeting[2])\\n            .ToArray();\\n        \\n        var secretKnowers = new HashSet<int>();\\n        \\n        secretKnowers.Add(0);\\n        secretKnowers.Add(firstPerson);\\n        \\n        // <int, List<int>> -> person talked to, people who talked to this person\\n        Dictionary<int, HashSet<int>> peopleWhoTalkedToPerson = new();\\n        \\n        // Each of these variables could have \"AtACertainTime\" appended to their names.\\n        var peopleWhoToldSecret = new Queue<int>();\\n        var secretLearners = new HashSet<int>();\\n        var seenSecretTellers = new HashSet<int>();\\n        var uniquePeopleWhoToldSecret = new HashSet<int>();\\n        \\n        var meeting = 0;\\n        \\n        // Internally, this loop processes groups of people that talked during the same time.\\n        // When we arrive back at the top of this loop, we will be looking at a time that differs\\n        // from the previous time that was proceesed.\\n        while (meeting < sortedMeetings.Length)\\n        {\\n            peopleWhoTalkedToPerson.Clear();\\n            \\n            var currentTime = sortedMeetings[meeting][2];\\n            \\n            // Gather all people for all meetings for a single, specific time.\\n            // For a given time - keep track of all people who talked and all of the people that\\n            // person talked to.\\n            while (meeting < sortedMeetings.Length && sortedMeetings[meeting][2] == currentTime)\\n            {\\n                if (!peopleWhoTalkedToPerson.ContainsKey(sortedMeetings[meeting][1]))\\n                {\\n                    peopleWhoTalkedToPerson.Add(sortedMeetings[meeting][1], new HashSet<int>());\\n                }\\n\\n                peopleWhoTalkedToPerson[sortedMeetings[meeting][1]].Add(sortedMeetings[meeting][0]);\\n                \\n                if (!peopleWhoTalkedToPerson.ContainsKey(sortedMeetings[meeting][0]))\\n                {\\n                    peopleWhoTalkedToPerson.Add(sortedMeetings[meeting][0], new HashSet<int>());\\n                }\\n\\n                peopleWhoTalkedToPerson[sortedMeetings[meeting][0]].Add(sortedMeetings[meeting][1]);\\n                \\n                meeting += 1;\\n            }\\n            \\n            var peopleWhoTalked = peopleWhoTalkedToPerson.Keys;\\n            \\n            // Identify people who told the secret.\\n            foreach (var person in peopleWhoTalked)\\n            {\\n                if (secretKnowers.Contains(person) && !uniquePeopleWhoToldSecret.Contains(person))\\n                {\\n                    peopleWhoToldSecret.Enqueue(person);\\n                    uniquePeopleWhoToldSecret.Add(person);\\n                }\\n            }\\n            \\n            // Clear all storage so we can use it as new.\\n            uniquePeopleWhoToldSecret.Clear();\\n            seenSecretTellers.Clear();\\n            secretLearners.Clear();\\n            \\n            // Process all that who told the secret - which also includes those which\\n            // just learned the secret during this time.\\n            // This takes care of the \"instantaneously\" criteria.\\n            while (peopleWhoToldSecret.Count > 0)\\n            {\\n                var secretSharer = peopleWhoToldSecret.Dequeue();\\n                if (seenSecretTellers.Contains(secretSharer))\\n                {\\n                    continue;\\n                }\\n                \\n                seenSecretTellers.Add(secretSharer);\\n                \\n                foreach (var secretLearner in peopleWhoTalkedToPerson[secretSharer])\\n                {\\n                    secretLearners.Add(secretLearner);\\n                    peopleWhoToldSecret.Enqueue(secretLearner);\\n                }\\n            }\\n            \\n            // Those who learned the secret are now secret knowers for future times.\\n            foreach (var secretLearner in secretLearners)\\n            {\\n                secretKnowers.Add(secretLearner);\\n            }\\n        }\\n        \\n        var output = new List<int>(secretKnowers);\\n        \\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293339,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        \\n        //graph to store the mtgs of each person -- person,time as a list\\n        Map<Integer, List<int[]>> graph = new HashMap<>();\\n        \\n        for (int i=0; i < n; i++){\\n            graph.put(i, new ArrayList<int[]>());\\n        }\\n        \\n        for (int[] mtg : meetings){\\n            graph.get(mtg[0]).add(new int[] {mtg[1],mtg[2]} );\\n            graph.get(mtg[1]).add(new int[] {mtg[0],mtg[2]} );\\n        }\\n        \\n        //order in which person knows the secret\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> a[1] - b[1]);\\n        pq.add(new int[]{0,0});\\n        pq.add(new int[]{firstPerson,0});\\n        \\n        //who all knows the secret so far\\n        Set<Integer> knownSet = new HashSet<>();\\n        \\n        \\n        while(!pq.isEmpty()){\\n            int[] sh = pq.remove();\\n            int p1 = sh[0];\\n            int t1 = sh[1];\\n            \\n            if(knownSet.contains(p1))\\n                continue;\\n            \\n            knownSet.add(p1);\\n            \\n            for(int[] mtgs : graph.get(p1)){\\n                int p2 = mtgs[0];\\n                int t2 = mtgs[1];\\n                if (t2 >= t1 && !knownSet.contains(p2))\\n                    pq.add(new int[]{p2,t2});\\n            }\\n        }\\n        return knownSet.stream().collect(Collectors.toList());\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        \\n        //graph to store the mtgs of each person -- person,time as a list\\n        Map<Integer, List<int[]>> graph = new HashMap<>();\\n        \\n        for (int i=0; i < n; i++){\\n            graph.put(i, new ArrayList<int[]>());\\n        }\\n        \\n        for (int[] mtg : meetings){\\n            graph.get(mtg[0]).add(new int[] {mtg[1],mtg[2]} );\\n            graph.get(mtg[1]).add(new int[] {mtg[0],mtg[2]} );\\n        }\\n        \\n        //order in which person knows the secret\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> a[1] - b[1]);\\n        pq.add(new int[]{0,0});\\n        pq.add(new int[]{firstPerson,0});\\n        \\n        //who all knows the secret so far\\n        Set<Integer> knownSet = new HashSet<>();\\n        \\n        \\n        while(!pq.isEmpty()){\\n            int[] sh = pq.remove();\\n            int p1 = sh[0];\\n            int t1 = sh[1];\\n            \\n            if(knownSet.contains(p1))\\n                continue;\\n            \\n            knownSet.add(p1);\\n            \\n            for(int[] mtgs : graph.get(p1)){\\n                int p2 = mtgs[0];\\n                int t2 = mtgs[1];\\n                if (t2 >= t1 && !knownSet.contains(p2))\\n                    pq.add(new int[]{p2,t2});\\n            }\\n        }\\n        return knownSet.stream().collect(Collectors.toList());\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2281646,
                "title": "c-code-grouping",
                "content": "```\\nclass Solution {\\npublic:\\n    map<int,vector<pair<int,int>>> mp;\\n    int vis[100005];\\n    \\n    void dfs(int node,int parent,set<int> &ele,map<int,vector<int>> &adj){\\n        vis[node]=1;\\n        ele.insert(node);\\n        \\n        for (auto it: adj[node]){\\n            if (!vis[it]){\\n                dfs(it,node,ele,adj);\\n            }\\n        }\\n    }\\n    \\n    vector<int> findAllPeople(int n, vector<vector<int>>& v, int firstPerson) {\\n        \\n        int i,j;\\n        \\n        for (i=0; i<v.size(); i++){\\n            mp[v[i][2]].push_back({v[i][0],v[i][1]});\\n        }\\n        \\n        set<int> s;\\n        s.insert(0);\\n        s.insert(firstPerson);\\n        \\n        for (auto it: mp){\\n            vector<pair<int,int>> temp=it.second;\\n            set<int> start;\\n            \\n            for (i=0; i<temp.size(); i++){\\n               if (s.find(temp[i].first)!=s.end()){\\n                   start.insert(temp[i].first);\\n               }    \\n               if (s.find(temp[i].second)!=s.end()){\\n                   start.insert(temp[i].second);\\n               }\\n            }\\n            \\n            if (start.size()==0){\\n                continue;\\n            }\\n            \\n            map<int,vector<int>> adj;\\n            \\n            for (i=0; i<temp.size(); i++){\\n                adj[temp[i].first].push_back(temp[i].second);\\n                adj[temp[i].second].push_back(temp[i].first);\\n            }\\n            \\n            for (auto it2: start){\\n                dfs(it2,-1,s,adj);\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        for (auto it: s){\\n            ans.push_back(it);\\n        }\\n        \\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,vector<pair<int,int>>> mp;\\n    int vis[100005];\\n    \\n    void dfs(int node,int parent,set<int> &ele,map<int,vector<int>> &adj){\\n        vis[node]=1;\\n        ele.insert(node);\\n        \\n        for (auto it: adj[node]){\\n            if (!vis[it]){\\n                dfs(it,node,ele,adj);\\n            }\\n        }\\n    }\\n    \\n    vector<int> findAllPeople(int n, vector<vector<int>>& v, int firstPerson) {\\n        \\n        int i,j;\\n        \\n        for (i=0; i<v.size(); i++){\\n            mp[v[i][2]].push_back({v[i][0],v[i][1]});\\n        }\\n        \\n        set<int> s;\\n        s.insert(0);\\n        s.insert(firstPerson);\\n        \\n        for (auto it: mp){\\n            vector<pair<int,int>> temp=it.second;\\n            set<int> start;\\n            \\n            for (i=0; i<temp.size(); i++){\\n               if (s.find(temp[i].first)!=s.end()){\\n                   start.insert(temp[i].first);\\n               }    \\n               if (s.find(temp[i].second)!=s.end()){\\n                   start.insert(temp[i].second);\\n               }\\n            }\\n            \\n            if (start.size()==0){\\n                continue;\\n            }\\n            \\n            map<int,vector<int>> adj;\\n            \\n            for (i=0; i<temp.size(); i++){\\n                adj[temp[i].first].push_back(temp[i].second);\\n                adj[temp[i].second].push_back(temp[i].first);\\n            }\\n            \\n            for (auto it2: start){\\n                dfs(it2,-1,s,adj);\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        for (auto it: s){\\n            ans.push_back(it);\\n        }\\n        \\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2276310,
                "title": "dfs-solution-50-60-test-cases-passing",
                "content": "Any idea on what could be wrong here?\\n\\n```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        List<Integer> res = new ArrayList();\\n        HashMap<Integer, List<int[]>> map = new HashMap();\\n        \\n        map.putIfAbsent(0, new ArrayList());\\n        map.putIfAbsent(firstPerson, new ArrayList());\\n        map.get(0).add(new int[]{firstPerson, 0});\\n        map.get(firstPerson).add(new int[]{0, 0});\\n        \\n        for (int[] meeting : meetings) {\\n            map.putIfAbsent(meeting[0], new ArrayList());\\n            map.putIfAbsent(meeting[1], new ArrayList());\\n            \\n            map.get(meeting[0]).add(new int[] {meeting[1], meeting[2]});\\n            map.get(meeting[1]).add(new int[] {meeting[0], meeting[2]});\\n        }\\n        \\n       HashSet<Integer> visited = new HashSet();\\n       dfs(firstPerson, map, visited, res, 0);\\n       return res;\\n    }\\n    \\n    private void dfs(int person, HashMap<Integer, List<int[]>> map, HashSet<Integer> visited, List<Integer> res, int curTime) {\\n        for (int[] cur: map.get(person)) {\\n            if (cur[1] >= curTime && !visited.contains(cur[0])) {\\n                visited.add(cur[0]);\\n                res.add(cur[0]);\\n                dfs(cur[0], map, visited, res, cur[1]);\\n            }\\n        }\\n    } \\n}\\n```\\n\\nFailing Test case - \\n\\n135\\n[[26,7,481],[28,120,80],[87,71,36],[11,86,164],[87,32,4],[8,104,240],[110,6,27],[120,126,209],[5,67,220],[61,47,175],[60,52,86],[88,53,453],[40,124,206],[122,22,62],[4,26,433],[46,56,214],[15,6,264],[128,31,313],[24,20,393],[7,20,282],[65,84,216],[55,132,241],[50,32,338],[61,69,459],[130,2,53],[43,106,322],[61,51,99],[43,61,64],[34,37,474],[94,116,338],[19,133,277],[82,40,148],[124,129,496],[73,82,417],[7,6,416],[61,15,98],[92,45,293],[78,109,130],[120,9,181],[84,23,390],[102,78,263],[104,130,262],[46,124,25],[125,101,112],[131,44,427],[78,71,96],[81,16,73],[58,49,18],[72,113,437],[28,119,3],[9,19,249],[113,121,58],[18,93,219],[112,117,412],[69,110,111],[100,44,377],[8,121,359],[86,98,57],[78,75,49],[104,58,276],[2,43,178],[73,64,352],[104,37,298],[14,88,184],[76,56,393],[0,90,144],[17,8,219],[31,127,455],[61,101,84],[100,87,398],[3,118,342],[98,50,272],[126,123,113],[28,52,122],[44,69,32],[127,96,473],[113,116,72],[104,46,436],[1,69,343],[51,18,338],[15,23,250],[21,118,258],[98,6,287],[111,34,468],[66,5,163],[86,16,158],[113,4,31],[8,58,421],[58,96,351],[131,101,66],[38,41,19],[78,0,282],[90,128,494],[73,6,246],[117,22,186],[84,88,145],[96,109,119],[20,112,324],[74,2,6],[46,60,365],[50,17,117],[88,34,310],[4,53,89],[102,81,454],[75,10,172],[71,39,481],[4,1,472],[108,73,487],[34,23,84],[101,82,215],[17,76,83],[38,66,230],[89,72,142],[130,75,145],[44,76,320],[83,128,131],[108,121,245],[9,33,234],[42,9,394],[125,110,453],[89,27,127],[79,17,40],[119,25,434],[12,118,296],[79,124,430],[61,70,353],[0,125,447],[7,27,330],[27,132,406],[43,3,214],[49,11,246],[19,31,158],[41,4,438],[9,115,28],[118,128,314],[109,64,280],[99,105,486],[10,29,8],[30,51,179],[53,29,27],[105,12,143],[113,43,326],[123,90,126],[117,14,9],[65,10,20],[24,77,494],[80,24,308],[16,106,347],[100,41,384],[104,7,293],[34,15,464],[98,18,331],[128,80,432],[55,93,164],[50,30,397],[68,65,396],[122,44,383],[125,122,192],[117,110,261],[32,8,229],[24,132,183],[2,30,159],[70,76,151],[79,111,242],[108,33,260],[91,25,427],[36,2,360],[96,111,270],[85,104,456],[84,24,408],[11,16,471],[109,7,58],[90,35,232],[80,58,298],[74,67,41],[11,96,425],[108,79,272],[8,118,305],[82,53,470],[89,85,450],[94,60,230],[13,39,321],[23,48,195],[92,49,452],[60,86,92],[95,120,31],[28,45,429],[90,71,153],[51,19,132],[88,60,258],[121,83,377],[134,95,130],[84,129,341],[51,105,106],[70,125,138],[75,43,68],[108,7,124],[59,21,480],[30,31,425],[93,134,23],[68,76,109],[82,120,237],[20,120,50],[21,70,316],[105,48,383],[33,23,133],[92,21,147],[16,94,281],[30,74,70],[49,29,282],[61,103,273],[64,116,112],[0,34,393],[100,26,386],[99,12,298],[23,3,113],[69,53,463],[6,81,185],[127,74,128],[66,74,7],[11,61,270],[100,49,458],[69,103,429],[83,61,70],[57,96,469],[83,134,66],[40,120,116],[5,111,310],[11,97,422],[84,12,101],[24,8,391],[33,75,256],[118,98,307],[111,43,384],[18,28,127],[79,119,367],[129,113,331],[126,58,293],[18,23,445],[41,132,352],[120,74,82],[29,81,53],[123,29,462],[25,120,10],[4,33,359],[98,48,91],[104,3,187],[128,40,376],[89,37,314],[124,122,44],[29,77,88],[96,117,349],[97,17,483],[82,117,243],[98,69,311],[14,7,500],[72,36,148],[90,53,491],[125,71,432],[24,119,15],[130,118,161],[54,73,389],[88,32,276],[35,41,183],[94,56,336],[8,34,407],[10,50,421],[127,18,231],[126,115,109],[96,70,231],[36,32,272],[63,23,252],[52,57,409],[91,10,336],[122,38,398],[42,86,481],[32,91,8],[56,81,258],[49,6,439],[116,40,72],[119,62,17],[40,124,289],[134,69,355],[32,59,121],[65,129,258],[106,61,146],[94,41,113],[82,34,209],[119,44,462],[88,62,16],[30,134,365],[30,56,42],[104,134,397],[129,25,226],[104,14,55],[123,92,194],[85,21,386],[57,13,141],[76,13,118],[48,88,436],[121,0,155],[39,74,38],[35,104,188],[80,100,475],[128,34,219],[126,114,444],[13,25,465],[68,95,293],[132,56,204],[102,126,427],[105,70,34],[116,41,258],[97,128,458],[77,98,496],[27,123,425],[54,32,496],[77,63,17],[124,66,253],[132,55,283],[63,87,295],[82,33,267],[123,49,78],[86,31,468],[3,21,459],[51,21,342],[123,71,257],[12,90,431],[41,29,145],[110,124,355],[0,19,174],[79,133,414],[58,22,183],[72,79,429],[72,128,69],[85,70,429],[22,77,489],[2,108,50],[101,12,128],[68,53,41],[85,98,374],[54,44,211],[3,56,390],[86,87,317],[114,82,282],[95,88,439],[1,35,187],[17,57,220],[118,6,443],[11,81,4],[117,50,253],[60,29,118],[8,5,364],[51,7,194],[121,45,235],[38,13,170],[21,41,218],[64,24,294],[50,80,73],[114,67,332],[12,39,32],[68,36,390],[89,127,110],[113,126,239],[16,117,425],[43,42,454],[17,104,192],[7,133,28],[84,56,335],[63,44,449],[108,73,96],[53,27,171],[103,31,256],[87,47,372],[16,30,126],[59,63,49],[108,56,66],[74,10,431],[8,54,302],[74,117,452],[17,74,159],[85,20,475],[102,54,299],[16,42,123],[105,63,453],[9,37,403],[1,52,390],[38,16,418],[41,11,144],[71,98,76],[75,85,57],[98,125,469],[48,45,114],[58,52,7],[125,27,311],[84,107,301],[1,47,475],[125,43,458],[5,89,165],[2,21,200],[129,53,133],[98,17,429],[78,101,428],[80,45,459],[95,37,247],[8,63,226],[115,9,174],[5,72,340],[42,57,236],[42,5,144],[76,80,159],[76,45,484],[79,10,214],[89,123,443],[95,12,345],[131,68,257],[98,20,6],[79,69,123],[127,109,372],[71,94,155],[34,108,364]]\\n125",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        List<Integer> res = new ArrayList();\\n        HashMap<Integer, List<int[]>> map = new HashMap();\\n        \\n        map.putIfAbsent(0, new ArrayList());\\n        map.putIfAbsent(firstPerson, new ArrayList());\\n        map.get(0).add(new int[]{firstPerson, 0});\\n        map.get(firstPerson).add(new int[]{0, 0});\\n        \\n        for (int[] meeting : meetings) {\\n            map.putIfAbsent(meeting[0], new ArrayList());\\n            map.putIfAbsent(meeting[1], new ArrayList());\\n            \\n            map.get(meeting[0]).add(new int[] {meeting[1], meeting[2]});\\n            map.get(meeting[1]).add(new int[] {meeting[0], meeting[2]});\\n        }\\n        \\n       HashSet<Integer> visited = new HashSet();\\n       dfs(firstPerson, map, visited, res, 0);\\n       return res;\\n    }\\n    \\n    private void dfs(int person, HashMap<Integer, List<int[]>> map, HashSet<Integer> visited, List<Integer> res, int curTime) {\\n        for (int[] cur: map.get(person)) {\\n            if (cur[1] >= curTime && !visited.contains(cur[0])) {\\n                visited.add(cur[0]);\\n                res.add(cur[0]);\\n                dfs(cur[0], map, visited, res, cur[1]);\\n            }\\n        }\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2273965,
                "title": "java-graph-treeset",
                "content": "```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        Integer[] times = new Integer[n];\\n        times[0]=0;\\n        \\n        List<List<int[]>> adj = new ArrayList<>();\\n        for(int i = 0; i<n; i++)\\n            adj.add(new ArrayList<>());\\n        adj.get(0).add(new int[]{firstPerson,1});\\n        \\n        for(int[] m: meetings){\\n            adj.get(m[0]).add(new int[]{m[1], m[2]});\\n            adj.get(m[1]).add(new int[]{m[0], m[2]});\\n        }\\n        \\n\\t\\t//p[0]: id, p[1]: time when this person first knows the secret.\\n        TreeSet<int[]> people = new TreeSet<>((p1, p2)->{\\n            if(p1[1]!=p2[1]) return p1[1]-p2[1];\\n            return p1[0]-p2[0];\\n        });\\n        people.add(new int[]{0,0});\\n        \\n        while(!people.isEmpty()){\\n            int[] p1 = people.pollFirst();\\n            List<int[]> neighbors = adj.get(p1[0]);\\n            for(int[] p2: neighbors){\\n                if(times[p1[0]]>p2[1]) continue;\\n                if(times[p2[0]]==null||times[p2[0]]>p2[1]){\\n                    if(times[p2[0]]!=null) people.remove(new int[]{p2[0], times[p2[0]]});\\n                    times[p2[0]] = p2[1];\\n                    people.add(p2);\\n                }\\n            }\\n        }\\n        \\n        List<Integer> ret = new ArrayList<>();\\n        for(int i = 0; i<n; i++){\\n            if(times[i]!=null) ret.add(i);\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        Integer[] times = new Integer[n];\\n        times[0]=0;\\n        \\n        List<List<int[]>> adj = new ArrayList<>();\\n        for(int i = 0; i<n; i++)\\n            adj.add(new ArrayList<>());\\n        adj.get(0).add(new int[]{firstPerson,1});\\n        \\n        for(int[] m: meetings){\\n            adj.get(m[0]).add(new int[]{m[1], m[2]});\\n            adj.get(m[1]).add(new int[]{m[0], m[2]});\\n        }\\n        \\n\\t\\t//p[0]: id, p[1]: time when this person first knows the secret.\\n        TreeSet<int[]> people = new TreeSet<>((p1, p2)->{\\n            if(p1[1]!=p2[1]) return p1[1]-p2[1];\\n            return p1[0]-p2[0];\\n        });\\n        people.add(new int[]{0,0});\\n        \\n        while(!people.isEmpty()){\\n            int[] p1 = people.pollFirst();\\n            List<int[]> neighbors = adj.get(p1[0]);\\n            for(int[] p2: neighbors){\\n                if(times[p1[0]]>p2[1]) continue;\\n                if(times[p2[0]]==null||times[p2[0]]>p2[1]){\\n                    if(times[p2[0]]!=null) people.remove(new int[]{p2[0], times[p2[0]]});\\n                    times[p2[0]] = p2[1];\\n                    people.add(p2);\\n                }\\n            }\\n        }\\n        \\n        List<Integer> ret = new ArrayList<>();\\n        for(int i = 0; i<n; i++){\\n            if(times[i]!=null) ret.add(i);\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1570694,
                "content": [
                    {
                        "username": "pedro",
                        "content": "I finish all of the problems with accepted within 20 minutes (top 30). I leave the contest. I check at the end and my rating is still the same.\\n\\nA few days later I come back and find that the last problem was rejudged and considered a wrong answer, and now I am ranked 1388th (lol)\\n\\nIf all problems are subject to getting retroactively evaluated, just say \"initial tests passed\" and make it clear there may always be additional tests even after the contest ends. As it stands, it is reasonable to assume all problem results are final and one can leave the contest after getting accepted on all of them."
                    },
                    {
                        "username": "Sayan_Jasu",
                        "content": "class Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        vector<bool> vis(n+1,0);\\n        set<pair<int,int>> sp;\\n        vector<vector<pair<int,int>>> adj(n+1);\\n        for(auto &e:meetings){\\n            adj[e[0]].push_back({e[1],e[2]});\\n            adj[e[1]].push_back({e[0],e[2]});\\n        }\\n        vector<int> ans,dis(n+1,INT_MAX);\\n        sp.insert({0,0});dis[firstPerson]=0;\\n        sp.insert({0,firstPerson});dis[0]=0;\\n        // vis[0]=1,vis[firstPerson]=1;\\n        while(!sp.empty()){\\n            int t=sp.begin()->first,u=sp.begin()->second;\\n            sp.erase(sp.begin());if(vis[u]) continue;\\n            vis[u]=1;for(auto node:adj[u]){\\n                int v=node.first,mt=node.second;\\n                if(t<=mt) dis[v]=mt;\\n                sp.insert({mt,v});\\n            }\\n        }\\n        for(int i=0;i<n;i++) if(dis[i]!=INT_MAX) \\n            ans.push_back(i);\\n        return ans;\\n    }\\n};\\n\\nOk, so I was trying this method with min_heap, and using BFS to find the required people with secrets, but for some reason it doesn\\'t seem to work, can anybody help me where I am going wrong? I even found a solution which uses the same logic, but instead of set, they have used priority_queue, and their code works. I tried to implement my whole code using priority_queue, but it still doesn\\'t work. Where am I going south?\\n\\nFor reference, this is the test-case that is causing havoc:\\nn = 12 \\nmeetings = \\n[[10,8,6],[9,5,11],[0,5,18],[4,5,13],[11,6,17],[0,11,10],[10,11,7],[5,8,3],[7,6,16],[3,6,10],[3,11,1],[8,3,2],[5,0,7],[3,8,20],[11,0,20],[8,3,4],[1,9,4],[10,7,11],[8,10,18]]\\nfirstPerson = 9"
                    },
                    {
                        "username": "akshatpandey007",
                        "content": "There is a popular solution in Solutions tab, which is union-find + reset, In that if we take \"POOL\" to selective reset, instead of hard checking all the people who dont the secret and reset them, solution passes otherwise it gives a TLE, why? can someone explain how its complexity is changed?\n \n\n@lzl124631x  [Solution Link](https://leetcode.com/problems/find-all-people-with-secret/solutions/1599815/c-union-find/?orderBy=most_votes)"
                    },
                    {
                        "username": "hero080",
                        "content": "If you have only resets the nodes affects by the same timestamp, then the total number of resets you call is O(M) (It\\'s the number of edges if you sum them up). If you resets all nodes for each timestamp, then in the **worse** case you would be doing O(NM) (which could be 100000 * 100000)"
                    }
                ]
            },
            {
                "id": 1936664,
                "content": [
                    {
                        "username": "pedro",
                        "content": "I finish all of the problems with accepted within 20 minutes (top 30). I leave the contest. I check at the end and my rating is still the same.\\n\\nA few days later I come back and find that the last problem was rejudged and considered a wrong answer, and now I am ranked 1388th (lol)\\n\\nIf all problems are subject to getting retroactively evaluated, just say \"initial tests passed\" and make it clear there may always be additional tests even after the contest ends. As it stands, it is reasonable to assume all problem results are final and one can leave the contest after getting accepted on all of them."
                    },
                    {
                        "username": "Sayan_Jasu",
                        "content": "class Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        vector<bool> vis(n+1,0);\\n        set<pair<int,int>> sp;\\n        vector<vector<pair<int,int>>> adj(n+1);\\n        for(auto &e:meetings){\\n            adj[e[0]].push_back({e[1],e[2]});\\n            adj[e[1]].push_back({e[0],e[2]});\\n        }\\n        vector<int> ans,dis(n+1,INT_MAX);\\n        sp.insert({0,0});dis[firstPerson]=0;\\n        sp.insert({0,firstPerson});dis[0]=0;\\n        // vis[0]=1,vis[firstPerson]=1;\\n        while(!sp.empty()){\\n            int t=sp.begin()->first,u=sp.begin()->second;\\n            sp.erase(sp.begin());if(vis[u]) continue;\\n            vis[u]=1;for(auto node:adj[u]){\\n                int v=node.first,mt=node.second;\\n                if(t<=mt) dis[v]=mt;\\n                sp.insert({mt,v});\\n            }\\n        }\\n        for(int i=0;i<n;i++) if(dis[i]!=INT_MAX) \\n            ans.push_back(i);\\n        return ans;\\n    }\\n};\\n\\nOk, so I was trying this method with min_heap, and using BFS to find the required people with secrets, but for some reason it doesn\\'t seem to work, can anybody help me where I am going wrong? I even found a solution which uses the same logic, but instead of set, they have used priority_queue, and their code works. I tried to implement my whole code using priority_queue, but it still doesn\\'t work. Where am I going south?\\n\\nFor reference, this is the test-case that is causing havoc:\\nn = 12 \\nmeetings = \\n[[10,8,6],[9,5,11],[0,5,18],[4,5,13],[11,6,17],[0,11,10],[10,11,7],[5,8,3],[7,6,16],[3,6,10],[3,11,1],[8,3,2],[5,0,7],[3,8,20],[11,0,20],[8,3,4],[1,9,4],[10,7,11],[8,10,18]]\\nfirstPerson = 9"
                    },
                    {
                        "username": "akshatpandey007",
                        "content": "There is a popular solution in Solutions tab, which is union-find + reset, In that if we take \"POOL\" to selective reset, instead of hard checking all the people who dont the secret and reset them, solution passes otherwise it gives a TLE, why? can someone explain how its complexity is changed?\n \n\n@lzl124631x  [Solution Link](https://leetcode.com/problems/find-all-people-with-secret/solutions/1599815/c-union-find/?orderBy=most_votes)"
                    },
                    {
                        "username": "hero080",
                        "content": "If you have only resets the nodes affects by the same timestamp, then the total number of resets you call is O(M) (It\\'s the number of edges if you sum them up). If you resets all nodes for each timestamp, then in the **worse** case you would be doing O(NM) (which could be 100000 * 100000)"
                    }
                ]
            },
            {
                "id": 1706702,
                "content": [
                    {
                        "username": "pedro",
                        "content": "I finish all of the problems with accepted within 20 minutes (top 30). I leave the contest. I check at the end and my rating is still the same.\\n\\nA few days later I come back and find that the last problem was rejudged and considered a wrong answer, and now I am ranked 1388th (lol)\\n\\nIf all problems are subject to getting retroactively evaluated, just say \"initial tests passed\" and make it clear there may always be additional tests even after the contest ends. As it stands, it is reasonable to assume all problem results are final and one can leave the contest after getting accepted on all of them."
                    },
                    {
                        "username": "Sayan_Jasu",
                        "content": "class Solution {\\npublic:\\n    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson) {\\n        vector<bool> vis(n+1,0);\\n        set<pair<int,int>> sp;\\n        vector<vector<pair<int,int>>> adj(n+1);\\n        for(auto &e:meetings){\\n            adj[e[0]].push_back({e[1],e[2]});\\n            adj[e[1]].push_back({e[0],e[2]});\\n        }\\n        vector<int> ans,dis(n+1,INT_MAX);\\n        sp.insert({0,0});dis[firstPerson]=0;\\n        sp.insert({0,firstPerson});dis[0]=0;\\n        // vis[0]=1,vis[firstPerson]=1;\\n        while(!sp.empty()){\\n            int t=sp.begin()->first,u=sp.begin()->second;\\n            sp.erase(sp.begin());if(vis[u]) continue;\\n            vis[u]=1;for(auto node:adj[u]){\\n                int v=node.first,mt=node.second;\\n                if(t<=mt) dis[v]=mt;\\n                sp.insert({mt,v});\\n            }\\n        }\\n        for(int i=0;i<n;i++) if(dis[i]!=INT_MAX) \\n            ans.push_back(i);\\n        return ans;\\n    }\\n};\\n\\nOk, so I was trying this method with min_heap, and using BFS to find the required people with secrets, but for some reason it doesn\\'t seem to work, can anybody help me where I am going wrong? I even found a solution which uses the same logic, but instead of set, they have used priority_queue, and their code works. I tried to implement my whole code using priority_queue, but it still doesn\\'t work. Where am I going south?\\n\\nFor reference, this is the test-case that is causing havoc:\\nn = 12 \\nmeetings = \\n[[10,8,6],[9,5,11],[0,5,18],[4,5,13],[11,6,17],[0,11,10],[10,11,7],[5,8,3],[7,6,16],[3,6,10],[3,11,1],[8,3,2],[5,0,7],[3,8,20],[11,0,20],[8,3,4],[1,9,4],[10,7,11],[8,10,18]]\\nfirstPerson = 9"
                    },
                    {
                        "username": "akshatpandey007",
                        "content": "There is a popular solution in Solutions tab, which is union-find + reset, In that if we take \"POOL\" to selective reset, instead of hard checking all the people who dont the secret and reset them, solution passes otherwise it gives a TLE, why? can someone explain how its complexity is changed?\n \n\n@lzl124631x  [Solution Link](https://leetcode.com/problems/find-all-people-with-secret/solutions/1599815/c-union-find/?orderBy=most_votes)"
                    },
                    {
                        "username": "hero080",
                        "content": "If you have only resets the nodes affects by the same timestamp, then the total number of resets you call is O(M) (It\\'s the number of edges if you sum them up). If you resets all nodes for each timestamp, then in the **worse** case you would be doing O(NM) (which could be 100000 * 100000)"
                    }
                ]
            }
        ]
    }
]