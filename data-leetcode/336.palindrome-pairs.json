[
    {
        "title": "Valid Sudoku",
        "question_content": "Determine if a&nbsp;9 x 9 Sudoku board&nbsp;is valid.&nbsp;Only the filled cells need to be validated&nbsp;according to the following rules:\n\n\tEach row&nbsp;must contain the&nbsp;digits&nbsp;1-9 without repetition.\n\tEach column must contain the digits&nbsp;1-9&nbsp;without repetition.\n\tEach of the nine&nbsp;3 x 3 sub-boxes of the grid must contain the digits&nbsp;1-9&nbsp;without repetition.\n\nNote:\n\n\tA Sudoku board (partially filled) could be valid but is not necessarily solvable.\n\tOnly the filled cells need to be validated according to the mentioned&nbsp;rules.\n\n&nbsp;\nExample 1:\n\nInput: board = \n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\nOutput: true\n\nExample 2:\n\nInput: board = \n[[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\nOutput: false\nExplanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.\n\n&nbsp;\nConstraints:\n\n\tboard.length == 9\n\tboard[i].length == 9\n\tboard[i][j] is a digit 1-9 or '.'.",
        "solutions": [
            {
                "id": 15472,
                "title": "short-simple-java-using-strings",
                "content": "Collect the set of things we see, encoded as strings. For example:\\n\\n- `'4' in row 7` is encoded as `\"(4)7\"`.\\n- `'4' in column 7` is encoded as `\"7(4)\"`.\\n- `'4' in the top-right block` is encoded as `\"0(4)2\"`.\\n\\nScream `false` if we ever fail to add something because it was already added (i.e., seen before).\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        Set seen = new HashSet();\\n        for (int i=0; i<9; ++i) {\\n            for (int j=0; j<9; ++j) {\\n                if (board[i][j] != '.') {\\n                    String b = \"(\" + board[i][j] + \")\";\\n                    if (!seen.add(b + i) || !seen.add(j + b) || !seen.add(i/3 + b + j/3))\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n---\\n\\n**Edit:** Just occurred to me that we can also make it really clear and self-explaining. I'm loving it.\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        Set seen = new HashSet();\\n        for (int i=0; i<9; ++i) {\\n            for (int j=0; j<9; ++j) {\\n                char number = board[i][j];\\n                if (number != '.')\\n                    if (!seen.add(number + \" in row \" + i) ||\\n                        !seen.add(number + \" in column \" + j) ||\\n                        !seen.add(number + \" in block \" + i/3 + \"-\" + j/3))\\n                        return false;\\n            }\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Collect the set of things we see, encoded as strings. For example:\\n\\n- `'4' in row 7` is encoded as `\"(4)7\"`.\\n- `'4' in column 7` is encoded as `\"7(4)\"`.\\n- `'4' in the top-right block` is encoded as `\"0(4)2\"`.\\n\\nScream `false` if we ever fail to add something because it was already added (i.e., seen before).\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        Set seen = new HashSet();\\n        for (int i=0; i<9; ++i) {\\n            for (int j=0; j<9; ++j) {\\n                if (board[i][j] != '.') {\\n                    String b = \"(\" + board[i][j] + \")\";\\n                    if (!seen.add(b + i) || !seen.add(j + b) || !seen.add(i/3 + b + j/3))\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n---\\n\\n**Edit:** Just occurred to me that we can also make it really clear and self-explaining. I'm loving it.\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        Set seen = new HashSet();\\n        for (int i=0; i<9; ++i) {\\n            for (int j=0; j<9; ++j) {\\n                char number = board[i][j];\\n                if (number != '.')\\n                    if (!seen.add(number + \" in row \" + i) ||\\n                        !seen.add(number + \" in column \" + j) ||\\n                        !seen.add(number + \" in block \" + i/3 + \"-\" + j/3))\\n                        return false;\\n            }\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 15464,
                "title": "my-short-solution-by-c-o-n2",
                "content": "Three flags are used to check whether a number appear.\\n\\nused1: check each row\\n\\nused2: check each column\\n\\nused3: check each sub-boxes\\n \\n    class Solution\\n    {\\n    public:\\n        bool isValidSudoku(vector<vector<char> > &board)\\n        {\\n            int used1[9][9] = {0}, used2[9][9] = {0}, used3[9][9] = {0};\\n            \\n            for(int i = 0; i < board.size(); ++ i)\\n                for(int j = 0; j < board[i].size(); ++ j)\\n                    if(board[i][j] != '.')\\n                    {\\n                        int num = board[i][j] - '0' - 1, k = i / 3 * 3 + j / 3;\\n                        if(used1[i][num] || used2[j][num] || used3[k][num])\\n                            return false;\\n                        used1[i][num] = used2[j][num] = used3[k][num] = 1;\\n                    }\\n            \\n            return true;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n    public:\\n        bool isValidSudoku(vector<vector<char> > &board)\\n        {\\n            int used1[9][9] = {0}",
                "codeTag": "Java"
            },
            {
                "id": 15451,
                "title": "a-readable-python-solution",
                "content": "Apparently not the shortest solution but I think it's easy to follow the logic.\\n\\n    \\n    def isValidSudoku(self, board):\\n        return (self.is_row_valid(board) and\\n                self.is_col_valid(board) and\\n                self.is_square_valid(board))\\n    \\n    def is_row_valid(self, board):\\n        for row in board:\\n            if not self.is_unit_valid(row):\\n                return False\\n        return True\\n    \\n    def is_col_valid(self, board):\\n        for col in zip(*board):\\n            if not self.is_unit_valid(col):\\n                return False\\n        return True\\n        \\n    def is_square_valid(self, board):\\n        for i in (0, 3, 6):\\n            for j in (0, 3, 6):\\n                square = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)]\\n                if not self.is_unit_valid(square):\\n                    return False\\n        return True\\n        \\n    def is_unit_valid(self, unit):\\n        unit = [i for i in unit if i != '.']\\n        return len(set(unit)) == len(unit)",
                "solutionTags": [
                    "Python"
                ],
                "code": "Apparently not the shortest solution but I think it's easy to follow the logic.\\n\\n    \\n    def isValidSudoku(self, board):\\n        return (self.is_row_valid(board) and\\n                self.is_col_valid(board) and\\n                self.is_square_valid(board))\\n    \\n    def is_row_valid(self, board):\\n        for row in board:\\n            if not self.is_unit_valid(row):\\n                return False\\n        return True\\n    \\n    def is_col_valid(self, board):\\n        for col in zip(*board):\\n            if not self.is_unit_valid(col):\\n                return False\\n        return True\\n        \\n    def is_square_valid(self, board):\\n        for i in (0, 3, 6):\\n            for j in (0, 3, 6):\\n                square = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)]\\n                if not self.is_unit_valid(square):\\n                    return False\\n        return True\\n        \\n    def is_unit_valid(self, unit):\\n        unit = [i for i in unit if i != '.']\\n        return len(set(unit)) == len(unit)",
                "codeTag": "Python3"
            },
            {
                "id": 15450,
                "title": "shared-my-concise-java-code",
                "content": "    public boolean isValidSudoku(char[][] board) {\\n        for(int i = 0; i<9; i++){\\n            HashSet<Character> rows = new HashSet<Character>();\\n            HashSet<Character> columns = new HashSet<Character>();\\n            HashSet<Character> cube = new HashSet<Character>();\\n            for (int j = 0; j < 9;j++){\\n                if(board[i][j]!='.' && !rows.add(board[i][j]))\\n                    return false;\\n                if(board[j][i]!='.' && !columns.add(board[j][i]))\\n                    return false;\\n                int RowIndex = 3*(i/3);\\n                int ColIndex = 3*(i%3);\\n                if(board[RowIndex + j/3][ColIndex + j%3]!='.' && !cube.add(board[RowIndex + j/3][ColIndex + j%3]))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public boolean isValidSudoku(char[][] board) {\\n        for(int i = 0; i<9; i++){\\n            HashSet<Character> rows = new HashSet<Character>();\\n            HashSet<Character> columns = new HashSet<Character>();\\n            HashSet<Character> cube = new HashSet<Character>();\\n            for (int j = 0; j < 9;j++){\\n                if(board[i][j]!='.' && !rows.add(board[i][j]))\\n                    return false;\\n                if(board[j][i]!='.' && !columns.add(board[j][i]))\\n                    return false;\\n                int RowIndex = 3*(i/3);\\n                int ColIndex = 3*(i%3);\\n                if(board[RowIndex + j/3][ColIndex + j%3]!='.' && !cube.add(board[RowIndex + j/3][ColIndex + j%3]))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 15616,
                "title": "my-12-lines-c-c-solution-with-1-time-traversal-and-9x9x3-memory",
                "content": "\\n    int isValidSudoku(char** board, int boardRowSize, int boardColSize) {\\n        int rows[9][9]={0}; //rows[5][0] means whether number 1('0'+1) in row 5 has appeared.\\n    \\tint cols[9][9]={0}; //cols[3][8] means whether number 9('8'+1) in col 3 has appeared.\\n    \\tint blocks[3][3][9]={0};//blocks[0][2][5] means whether number '6' in block 0,2 (row 0~2,col 6~8) has appeared.\\n    \\tfor(int r=0;r<9;r++)    //traverse board r,c\\n    \\t\\tfor(int c=0;c<9;c++)\\n    \\t\\t\\tif(board[r][c]!='.'){   //skip all number '.'\\n    \\t\\t\\t\\tint number=board[r][c]-'1'; //calculate the number's index(board's number minus 1)\\n    \\t\\t\\t\\tif(rows[r][number]++) return 0; //if the number has already appeared once, return false.\\n    \\t\\t\\t\\tif(cols[c][number]++) return 0;\\n    \\t\\t\\t\\tif(blocks[r/3][c/3][number]++) return 0;\\n    \\t\\t\\t}\\n    \\treturn 1;\\n    }",
                "solutionTags": [],
                "code": "\\n    int isValidSudoku(char** board, int boardRowSize, int boardColSize) {\\n        int rows[9][9]={0}; //rows[5][0] means whether number 1('0'+1) in row 5 has appeared.\\n    \\tint cols[9][9]={0}; //cols[3][8] means whether number 9('8'+1) in col 3 has appeared.\\n    \\tint blocks[3][3][9]={0};//blocks[0][2][5] means whether number '6' in block 0,2 (row 0~2,col 6~8) has appeared.\\n    \\tfor(int r=0;r<9;r++)    //traverse board r,c\\n    \\t\\tfor(int c=0;c<9;c++)\\n    \\t\\t\\tif(board[r][c]!='.'){   //skip all number '.'\\n    \\t\\t\\t\\tint number=board[r][c]-'1'; //calculate the number's index(board's number minus 1)\\n    \\t\\t\\t\\tif(rows[r][number]++) return 0; //if the number has already appeared once, return false.\\n    \\t\\t\\t\\tif(cols[c][number]++) return 0;\\n    \\t\\t\\t\\tif(blocks[r/3][c/3][number]++) return 0;\\n    \\t\\t\\t}\\n    \\treturn 1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 15460,
                "title": "1-7-lines-python-4-solutions",
                "content": "**Idea**\\n\\nJust go through all you see (like \"7 in row 3\") and check for duplicates.\\n\\n**Solution 1**\\n\\nUsing `Counter`. One logical line, seven physical lines.\\n\\n    def isValidSudoku(self, board):\\n        return 1 == max(collections.Counter(\\n            x\\n            for i, row in enumerate(board)\\n            for j, c in enumerate(row)\\n            if c != '.'\\n            for x in ((c, i), (j, c), (i/3, j/3, c))\\n        ).values() + [1])\\n\\nThe ` + [1]` is only for the empty board, where `max` would get an empty list and complain. It's not necessary to get it accepted here, as the empty board isn't among the test cases, but it's good to have.\\n\\n**Solution 2**\\n\\nUsing `len(set)`.\\n\\n    def isValidSudoku(self, board):\\n        seen = sum(([(c, i), (j, c), (i/3, j/3, c)]\\n                    for i, row in enumerate(board)\\n                    for j, c in enumerate(row)\\n                    if c != '.'), [])\\n        return len(seen) == len(set(seen))\\n\\n**Solution 3**\\n\\nUsing `any`.\\n\\n    def isValidSudoku(self, board):\\n        seen = set()\\n        return not any(x in seen or seen.add(x)\\n                       for i, row in enumerate(board)\\n                       for j, c in enumerate(row)\\n                       if c != '.'\\n                       for x in ((c, i), (j, c), (i/3, j/3, c)))\\n\\n**Solution 4**\\n\\nIterating a different way.\\n\\n    def isValidSudoku(self, board):\\n        seen = sum(([(c, i), (j, c), (i/3, j/3, c)]\\n                    for i in range(9) for j in range(9)\\n                    for c in [board[i][j]] if c != '.'), [])\\n        return len(seen) == len(set(seen))",
                "solutionTags": [
                    "Python"
                ],
                "code": "**Idea**\\n\\nJust go through all you see (like \"7 in row 3\") and check for duplicates.\\n\\n**Solution 1**\\n\\nUsing `Counter`. One logical line, seven physical lines.\\n\\n    def isValidSudoku(self, board):\\n        return 1 == max(collections.Counter(\\n            x\\n            for i, row in enumerate(board)\\n            for j, c in enumerate(row)\\n            if c != '.'\\n            for x in ((c, i), (j, c), (i/3, j/3, c))\\n        ).values() + [1])\\n\\nThe ` + [1]` is only for the empty board, where `max` would get an empty list and complain. It's not necessary to get it accepted here, as the empty board isn't among the test cases, but it's good to have.\\n\\n**Solution 2**\\n\\nUsing `len(set)`.\\n\\n    def isValidSudoku(self, board):\\n        seen = sum(([(c, i), (j, c), (i/3, j/3, c)]\\n                    for i, row in enumerate(board)\\n                    for j, c in enumerate(row)\\n                    if c != '.'), [])\\n        return len(seen) == len(set(seen))\\n\\n**Solution 3**\\n\\nUsing `any`.\\n\\n    def isValidSudoku(self, board):\\n        seen = set()\\n        return not any(x in seen or seen.add(x)\\n                       for i, row in enumerate(board)\\n                       for j, c in enumerate(row)\\n                       if c != '.'\\n                       for x in ((c, i), (j, c), (i/3, j/3, c)))\\n\\n**Solution 4**\\n\\nIterating a different way.\\n\\n    def isValidSudoku(self, board):\\n        seen = sum(([(c, i), (j, c), (i/3, j/3, c)]\\n                    for i in range(9) for j in range(9)\\n                    for c in [board[i][j]] if c != '.'), [])\\n        return len(seen) == len(set(seen))",
                "codeTag": "Python3"
            },
            {
                "id": 476369,
                "title": "javascript-solution-beats-100-with-explanation-real-explanations",
                "content": "Adopted from [@Lorraine921](https://leetcode.com/lorraine921)\\'s answer [here](https://leetcode.com/problems/valid-sudoku/discuss/15450/Shared-my-concise-Java-code) if anyone wants to check out the original answer. I wanted to share some of my thoughts as I was going through the solution:\\n\\n**Thinking**\\nBasically we need to check three things:\\n\\n1. Are there duplicates in each row? If yes, `return false`\\n2. Are there duplicates in each column? If yes, `return false`\\n3. Are there duplicates in each 3x3 box? If yes, `return false`\\n\\nif everything passes, `return true` at the end.\\n\\nWhen dealing with checking for duplicates, we use a Hash Set. \\n\\n**Representations**\\nLet\\'s deal with rows and columns first because it\\'s easier to tackle:\\n\\n```\\nfor (let i = 0; i < 9; i++) {\\n\\tlet row = new Set(); /* row Set */\\n\\tlet col = new Set(); /* column Set */\\n\\tfor(let j = 0; j < 9; j++) {\\n\\t\\tboard[i][j] /* iterating row by row */\\n\\t\\tboard[j][i] /* iterating column by column */\\n\\t}\\n}\\n```\\nSo as we go through each row/column we add unseen number to the row/column `Set` accordingly. If `Set` has seen it, we `return false`.\\n```\\n/* example */\\nif (item != \\'.\\') {\\n\\tif (row.has(item)) return false;\\n\\trow.add(item);\\n}\\n```\\nNow let\\'s ace the 3x3 box iterating inside the same loop:\\nThis is a illustration of a sudoku in nine 3x3 boxes with each cell represented by a two-digit number `ij` (`i` means row index and `j` means column index).\\n```\\n00 01 02 | 03 04 05 | 06 07 08\\n10 11 12 | 13 14 15 | 16 17 18  // i = 0, 1, 2\\n20 21 22 | 23 24 25 | 26 27 28\\n------------------------------\\n30 31 32 | 33 34 35 | 36 37 38\\n40 41 42 | 43 44 45 | 46 47 48  // i = 3, 4, 5\\n50 51 52 | 53 54 55 | 56 57 58\\n------------------------------\\n60 61 62 | 63 64 65 | 66 67 68 \\n70 71 72 | 73 74 75 | 76 77 78  // i = 6, 7, 8\\n80 81 82 | 83 84 85 | 86 87 88\\n```\\nHow do we iterate using `i`, `j`, and `3`(because its 3x3)? \\nWe use `/` and `%` to help!\\n```\\t  \\nBecause we only want to start vertical traversal when horizontal traversal is done. \\n\\nUse / for vertical traversal because\\nMath.floor(0 / 3) = 0\\nMath.floor(1 / 3) = 0\\nMath.floor(2 / 3) = 0\\n\\nUse % for horizontal traversal beause \\n0 % 3 = 0\\n1 % 3 = 1\\n2 % 3 = 2\\n```\\nWe can represent the 3x3 box as:\\n```\\nfor (let i = 0; i < 9; i++) {\\n\\tfor(let j = 0; j < 9; j++) {\\n\\t\\tboard[3 * Math.floor(i/3) + Math.floor(j/3)][3 * i%3 + j%3]\\n\\t}\\n}\\n```\\n**Code**\\n```\\nvar isValidSudoku = function(board) {\\n  for (let i = 0; i < 9; i++) {\\n    let row = new Set(),\\n        col = new Set(),\\n        box = new Set();\\n\\n    for (let j = 0; j < 9; j++) {\\n      let _row = board[i][j];\\n      let _col = board[j][i];\\n      let _box = board[3*Math.floor(i/3)+Math.floor(j/3)][3*(i%3)+(j%3)]\\n      \\n      if (_row != \\'.\\') {\\n        if (row.has(_row)) return false;\\n        row.add(_row);\\n      }\\n      if (_col != \\'.\\') {\\n        if (col.has(_col)) return false;\\n        col.add(_col);\\n      }\\n      \\n      if (_box != \\'.\\') {\\n        if (box.has(_box)) return false;\\n        box.add(_box);\\n      } \\n    }\\n  }\\n  return true\\n};\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfor (let i = 0; i < 9; i++) {\\n\\tlet row = new Set(); /* row Set */\\n\\tlet col = new Set(); /* column Set */\\n\\tfor(let j = 0; j < 9; j++) {\\n\\t\\tboard[i][j] /* iterating row by row */\\n\\t\\tboard[j][i] /* iterating column by column */\\n\\t}\\n}\\n```\n```\\n/* example */\\nif (item != \\'.\\') {\\n\\tif (row.has(item)) return false;\\n\\trow.add(item);\\n}\\n```\n```\\n00 01 02 | 03 04 05 | 06 07 08\\n10 11 12 | 13 14 15 | 16 17 18  // i = 0, 1, 2\\n20 21 22 | 23 24 25 | 26 27 28\\n------------------------------\\n30 31 32 | 33 34 35 | 36 37 38\\n40 41 42 | 43 44 45 | 46 47 48  // i = 3, 4, 5\\n50 51 52 | 53 54 55 | 56 57 58\\n------------------------------\\n60 61 62 | 63 64 65 | 66 67 68 \\n70 71 72 | 73 74 75 | 76 77 78  // i = 6, 7, 8\\n80 81 82 | 83 84 85 | 86 87 88\\n```\n```\\t  \\nBecause we only want to start vertical traversal when horizontal traversal is done. \\n\\nUse / for vertical traversal because\\nMath.floor(0 / 3) = 0\\nMath.floor(1 / 3) = 0\\nMath.floor(2 / 3) = 0\\n\\nUse % for horizontal traversal beause \\n0 % 3 = 0\\n1 % 3 = 1\\n2 % 3 = 2\\n```\n```\\nfor (let i = 0; i < 9; i++) {\\n\\tfor(let j = 0; j < 9; j++) {\\n\\t\\tboard[3 * Math.floor(i/3) + Math.floor(j/3)][3 * i%3 + j%3]\\n\\t}\\n}\\n```\n```\\nvar isValidSudoku = function(board) {\\n  for (let i = 0; i < 9; i++) {\\n    let row = new Set(),\\n        col = new Set(),\\n        box = new Set();\\n\\n    for (let j = 0; j < 9; j++) {\\n      let _row = board[i][j];\\n      let _col = board[j][i];\\n      let _box = board[3*Math.floor(i/3)+Math.floor(j/3)][3*(i%3)+(j%3)]\\n      \\n      if (_row != \\'.\\') {\\n        if (row.has(_row)) return false;\\n        row.add(_row);\\n      }\\n      if (_col != \\'.\\') {\\n        if (col.has(_col)) return false;\\n        col.add(_col);\\n      }\\n      \\n      if (_box != \\'.\\') {\\n        if (box.has(_box)) return false;\\n        box.add(_box);\\n      } \\n    }\\n  }\\n  return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1332984,
                "title": "c-simple-and-easy-10-short-line-solution",
                "content": "For each row, column and block we keep a set of numbers.\\nIf we find a number that was seen already in that row, column or block - return false.\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        vector<set<int>> rows(9), cols(9), blocks(9);\\n        \\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                \\n                if (board[i][j] == \\'.\\') continue;\\n                \\n                int curr = board[i][j] - \\'0\\';\\n                if (rows[i].count(curr) || cols[j].count(curr) || blocks[(i/3)*3+j/3].count(curr)) \\n                    return false;\\n                \\n                rows[i].insert(curr);\\n                cols[j].insert(curr);\\n                blocks[(i/3)*3+j/3].insert(curr);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        vector<set<int>> rows(9), cols(9), blocks(9);\\n        \\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                \\n                if (board[i][j] == \\'.\\') continue;\\n                \\n                int curr = board[i][j] - \\'0\\';\\n                if (rows[i].count(curr) || cols[j].count(curr) || blocks[(i/3)*3+j/3].count(curr)) \\n                    return false;\\n                \\n                rows[i].insert(curr);\\n                cols[j].insert(curr);\\n                blocks[(i/3)*3+j/3].insert(curr);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15452,
                "title": "c-very-simple-and-easy-understand-using-bit-operation",
                "content": "       bool isValidSudoku(vector<vector<char>>& board) {\\n        vector<short> col(9, 0);\\n        vector<short> block(9, 0);\\n        vector<short> row(9, 0);\\n        for (int i = 0; i < 9; i++)\\n         for (int j = 0; j < 9; j++) {\\n             if (board[i][j] != '.') {\\n                 int idx = 1 << (board[i][j] - '0');\\n                 if (row[i] & idx || col[j] & idx || block[i/3 * 3 + j / 3] & idx)\\n                    return false;\\n                row[i] |= idx;\\n                col[j] |= idx;\\n                block[i/3 * 3 + j/3] |= idx;\\n             }\\n         }\\n         return true;\\n      }",
                "solutionTags": [],
                "code": "       bool isValidSudoku(vector<vector<char>>& board) {\\n        vector<short> col(9, 0);\\n        vector<short> block(9, 0);\\n        vector<short> row(9, 0);\\n        for (int i = 0; i < 9; i++)\\n         for (int j = 0; j < 9; j++) {\\n             if (board[i][j] != '.') {\\n                 int idx = 1 << (board[i][j] - '0');\\n                 if (row[i] & idx || col[j] & idx || block[i/3 * 3 + j / 3] & idx)\\n                    return false;\\n                row[i] |= idx;\\n                col[j] |= idx;\\n                block[i/3 * 3 + j/3] |= idx;\\n             }\\n         }\\n         return true;\\n      }",
                "codeTag": "Unknown"
            },
            {
                "id": 15509,
                "title": "clean-and-easy82ms-python",
                "content": "class Solution(object):\\n\\n    def isValidSudoku(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: bool\\n        \"\"\"\\n        big = set()\\n        for i in xrange(0,9):\\n            for j in xrange(0,9):\\n                if board[i][j]!='.':\\n                    cur = board[i][j]\\n                    if (i,cur) in big or (cur,j) in big or (i/3,j/3,cur) in big:\\n                        return False\\n                    big.add((i,cur))\\n                    big.add((cur,j))\\n                    big.add((i/3,j/3,cur))\\n        return True",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "class Solution(object):\\n\\n    def isValidSudoku(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: bool\\n        \"\"\"\\n        big = set()\\n        for i in xrange(0,9):\\n            for j in xrange(0,9):\\n                if board[i][j]!='.':\\n                    cur = board[i][j]\\n                    if (i,cur) in big or (cur,j) in big or (i/3,j/3,cur) in big:\\n                        return False\\n                    big.add((i,cur))\\n                    big.add((cur,j))\\n                    big.add((i/3,j/3,cur))\\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 3277043,
                "title": "beats-96-78-short-7-line-python-solution-with-detailed-explanation",
                "content": "\\n1)It initializes an empty list called \"res\", which will be used to store all the valid elements in the board.\\n\\n2)It loops through each cell in the board using two nested \"for\" loops.\\nFor each cell, it retrieves the value of the element in that cell and stores it in a variable called \"element\".\\n\\n3)If the element is not a dot (\\'.\\'), which means it\\'s a valid number, the method adds three tuples to the \"res\" list:\\n\\n- The first tuple contains the row index (i) and the element itself.\\n- The second tuple contains the element itself and the column index (j).\\n- The third tuple contains the floor division of the row index by 3 (i // 3), the floor division of the column index by 3 (j // 3), and the element itself. This tuple represents the 3x3 sub-grid that the current cell belongs to.\\n\\n4)After processing all the cells, the method checks if the length of \"res\" is equal to the length of the set of \"res\".\\n\\n```\\nclass Solution(object):\\n    def isValidSudoku(self, board):\\n        res = []\\n        for i in range(9):\\n            for j in range(9):\\n                element = board[i][j]\\n                if element != \\'.\\':\\n                    res += [(i, element), (element, j), (i // 3, j // 3, element)]\\n        return len(res) == len(set(res))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def isValidSudoku(self, board):\\n        res = []\\n        for i in range(9):\\n            for j in range(9):\\n                element = board[i][j]\\n                if element != \\'.\\':\\n                    res += [(i, element), (element, j), (i // 3, j // 3, element)]\\n        return len(res) == len(set(res))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15634,
                "title": "sharing-my-easy-understand-java-solution-using-set",
                "content": "    public class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        for (int i=0; i<9; i++) {\\n            if (!isParticallyValid(board,i,0,i,8)) return false;\\n            if (!isParticallyValid(board,0,i,8,i)) return false;\\n        }\\n        for (int i=0;i<3;i++){\\n            for(int j=0;j<3;j++){\\n                if (!isParticallyValid(board,i*3,j*3,i*3+2,j*3+2)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    private boolean isParticallyValid(char[][] board, int x1, int y1,int x2,int y2){\\n        Set singleSet = new HashSet();\\n        for (int i= x1; i<=x2; i++){\\n            for (int j=y1;j<=y2; j++){\\n                if (board[i][j]!='.') if(!singleSet.add(board[i][j])) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\nEach time send the coordinates to check if the board is partially valid.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        for (int i=0; i<9; i++) {\\n            if (!isParticallyValid(board,i,0,i,8)) return false;\\n            if (!isParticallyValid(board,0,i,8,i)) return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1414911,
                "title": "c-java-python-2-solutions-hashset-bitmasking-clean-concise-o-49",
                "content": "**\\u2714\\uFE0F Solution 1: Hash Set**\\n- The idea is super easy.\\n- For each row, we create a HashSet to check for duplicates in each row.\\n- For each column, we also create a HashSet to check for duplicates in each column.\\n- For each square, we also create a HashSet to check for duplicates in each square, but we need to convert the position `(r, c)` in the board to square by:\\n\\t- Square row: `sr = r / 3`.\\n\\t- Square col: `sc = c / 3`.\\n\\t- Square position: `sPos = sr * 3 + sc`.\\n\\n<iframe src=\"https://leetcode.com/playground/kopzUL7z/shared\" frameBorder=\"0\" width=\"100%\" height=\"520\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N^2)`, where `N = 9`. \\n- Space: `O(N^2)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: Bitmasking (Beat 100%)**\\n- Since we only need to store 2 states (exist, not exist) and store up to 9 positions.\\n- So to save space, we can store in the bitmask, `i` th bit represent the existence of the number `i`.\\n\\n<iframe src=\"https://leetcode.com/playground/cnqUk6bW/shared\" frameBorder=\"0\" width=\"100%\" height=\"450\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N^2)`, where `N = 9`. \\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "**\\u2714\\uFE0F Solution 1: Hash Set**\\n- The idea is super easy.\\n- For each row, we create a HashSet to check for duplicates in each row.\\n- For each column, we also create a HashSet to check for duplicates in each column.\\n- For each square, we also create a HashSet to check for duplicates in each square, but we need to convert the position `(r, c)` in the board to square by:\\n\\t- Square row: `sr = r / 3`.\\n\\t- Square col: `sc = c / 3`.\\n\\t- Square position: `sPos = sr * 3 + sc`.\\n\\n<iframe src=\"https://leetcode.com/playground/kopzUL7z/shared\" frameBorder=\"0\" width=\"100%\" height=\"520\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N^2)`, where `N = 9`. \\n- Space: `O(N^2)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: Bitmasking (Beat 100%)**\\n- Since we only need to store 2 states (exist, not exist) and store up to 9 positions.\\n- So to save space, we can store in the bitmask, `i` th bit represent the existence of the number `i`.\\n\\n<iframe src=\"https://leetcode.com/playground/cnqUk6bW/shared\" frameBorder=\"0\" width=\"100%\" height=\"450\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N^2)`, where `N = 9`. \\n- Space: `O(N)`",
                "codeTag": "Unknown"
            },
            {
                "id": 15560,
                "title": "yet-another-java-2ms-solution",
                "content": "    public boolean isValidSudoku(char[][] board) {\\n        int [] vset = new int [9];\\n        int [] hset = new int [9];\\n        int [] bckt = new int [9];\\n        int idx = 0;\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] != '.') {\\n                    idx = 1 << (board[i][j] - '0') ;\\n                    if ((hset[i] & idx) > 0 ||\\n                        (vset[j] & idx) > 0 ||\\n                        (bckt[(i / 3) * 3 + j / 3] & idx) > 0) return false;\\n                    hset[i] |= idx;\\n                    vset[j] |= idx;\\n                    bckt[(i / 3) * 3 + j / 3] |= idx;\\n                }\\n            }\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public boolean isValidSudoku(char[][] board) {\\n        int [] vset = new int [9];\\n        int [] hset = new int [9];\\n        int [] bckt = new int [9];\\n        int idx = 0;\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] != '.') {\\n                    idx = 1 << (board[i][j] - '0') ;\\n                    if ((hset[i] & idx) > 0 ||\\n                        (vset[j] & idx) > 0 ||\\n                        (bckt[(i / 3) * 3 + j / 3] & idx) > 0) return false;\\n                    hset[i] |= idx;\\n                    vset[j] |= idx;\\n                    bckt[(i / 3) * 3 + j / 3] |= idx;\\n                }\\n            }\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2572765,
                "title": "python-explained-steps-clean-code-best-method",
                "content": "Hello!\\n\\nTo solve this problem we have to check if each value in sudoku does not repeat in its:\\n1. column\\n2. row\\n3. square\\n\\nTo do this efficiently we will use **sets** to store elements in columns, rows and squares. This is easy to define column and row (by single index), but squares are defined using two indexes. We will use **//** (floor division) operator to know in which square we are right now.\\n\\nIndexes range from **0** to **8**. \\n0 // 3 = 0\\n1 // 3 = 0\\n2 // 3 = 0\\n3 // 3 = 1\\n4 // 3 = 1\\n5 // 3 = 1\\n6 // 3 = 2\\n7 // 3 = 2\\n8 // 3 = 2\\n\\nWe got 3 different values for each range (0-2: **0**, 3-5: **1**, 6-8: **2**), so we can use it to know in which square are currently are (by getting square **x** and **y** coordinate, we need 9 squares with indexes (0, 0), (0, 1), (0, 2), (1,0), ..., (2, 2)).\\n\\nIn code we do nothing if we meet **.** symbol, but if we have **digit** in cell, then we check if it is in cell\\'s row, column or square. \\nIf **yes**, then it means that the value is repeated, so sudoku is not valid one, so we return **False**.\\n\\nAfter checking, we add this value to its row, column and square.\\nIf number occurs 2 times in given row, cell or square, then the 2nd occurence is going to trigger **False** return (because in first occurence we add the value to the **sets**).\\n\\nCode:\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        rows = [set() for x in range(9)]\\n        columns = [set() for x in range(9)]\\n        squares = [[set() for x in range(3)] for y in range(3)]\\n        \\n        for x in range(9):\\n            for y in range(9):\\n                cell_value = board[x][y]\\n                if cell_value == \".\":\\n                    continue\\n                if cell_value in rows[x] or cell_value in columns[y] or cell_value in squares[x//3][y//3]:\\n                    return False\\n\\n                rows[x].add(cell_value)\\n                columns[y].add(cell_value)\\n                squares[x//3][y//3].add(cell_value)\\n        \\n        return True\\n```\\n\\nPlease upvote if it was helpful :))",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        rows = [set() for x in range(9)]\\n        columns = [set() for x in range(9)]\\n        squares = [[set() for x in range(3)] for y in range(3)]\\n        \\n        for x in range(9):\\n            for y in range(9):\\n                cell_value = board[x][y]\\n                if cell_value == \".\":\\n                    continue\\n                if cell_value in rows[x] or cell_value in columns[y] or cell_value in squares[x//3][y//3]:\\n                    return False\\n\\n                rows[x].add(cell_value)\\n                columns[y].add(cell_value)\\n                squares[x//3][y//3].add(cell_value)\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461845,
                "title": "simple-solution-using-set-in-c",
                "content": "**If you understand the approach please upvote!!!**\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        //since we have to verify that each element is appears once or not... for that purpose here we use \\n        //vector of sets since set stores only unique entries\\n        vector<set<int>> rows(9),cols(9),blocks(9); \\n        \\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                //if board[i][j] entry is \\'.\\' then we just continue as we only care about the duplicate values\\n                if(board[i][j] == \\'.\\'){\\n                    continue;\\n                }\\n                \\n                int curr = board[i][j]; //we can get the value at given index to check that if it is already \\n                // present in set or not\\n                \\n                //here our count function returns 1 if value is already present in row or column or block otherwise it will return 0\\n                \\n                //for block try this formula using pen and paper you will get it..\\n                if(rows[i].count(curr) || cols[j].count(curr) ||\\n                  blocks[(i/3)*3 + j/3].count(curr)){\\n                    return false; //we return false because the value currently we have is already present in set\\n                }\\n                //if we don\\'t found the value then after that we must enter this value in our set\\n                rows[i].insert(curr);\\n                cols[j].insert(curr);\\n                blocks[(i/3*3) + j/3].insert(curr);\\n            }\\n        }\\n        return true; //after loop finishes our control reaches here that means our sudoko is valid...\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        //since we have to verify that each element is appears once or not... for that purpose here we use \\n        //vector of sets since set stores only unique entries\\n        vector<set<int>> rows(9),cols(9),blocks(9); \\n        \\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                //if board[i][j] entry is \\'.\\' then we just continue as we only care about the duplicate values\\n                if(board[i][j] == \\'.\\'){\\n                    continue;\\n                }\\n                \\n                int curr = board[i][j]; //we can get the value at given index to check that if it is already \\n                // present in set or not\\n                \\n                //here our count function returns 1 if value is already present in row or column or block otherwise it will return 0\\n                \\n                //for block try this formula using pen and paper you will get it..\\n                if(rows[i].count(curr) || cols[j].count(curr) ||\\n                  blocks[(i/3)*3 + j/3].count(curr)){\\n                    return false; //we return false because the value currently we have is already present in set\\n                }\\n                //if we don\\'t found the value then after that we must enter this value in our set\\n                rows[i].insert(curr);\\n                cols[j].insert(curr);\\n                blocks[(i/3*3) + j/3].insert(curr);\\n            }\\n        }\\n        return true; //after loop finishes our control reaches here that means our sudoko is valid...\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 729180,
                "title": "python-solutions-single-traversal-single-dictionary",
                "content": "Just store the indexs of the numbers in a dictionary in `(x, y)` format. Then for every number check for same row, same col and same box condition.\\nThis will require a single traversal. The same box condition can be checked using `pos[0]//3 == x//3 and pos[1]//3 == y//3` since `i//3` and `j//3` give the box position.\\n\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        boardMap = collections.defaultdict(list)\\n        for x in range(9):\\n            for y in range(9):\\n                char = board[x][y]\\n                if char != \\'.\\': \\n                    if char in boardMap:\\n                        for pos in boardMap[char]:\\n                            if (pos[0]== x) or (pos[1] == y) or (pos[0]//3 == x//3 and pos[1]//3 == y//3):\\n                                return False\\n                    boardMap[char].append((x,y))\\n   \\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        boardMap = collections.defaultdict(list)\\n        for x in range(9):\\n            for y in range(9):\\n                char = board[x][y]\\n                if char != \\'.\\': \\n                    if char in boardMap:\\n                        for pos in boardMap[char]:\\n                            if (pos[0]== x) or (pos[1] == y) or (pos[0]//3 == x//3 and pos[1]//3 == y//3):\\n                                return False\\n                    boardMap[char].append((x,y))\\n   \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2840656,
                "title": "java-explained-in-detail-simple-fast-solution-intuitive-hash-table",
                "content": "I do my best everyday to give a clear explanation, so to help everyone improve their skills.\\n\\nIf you find this **helpful**, please \\uD83D\\uDC4D **upvote** this post and watch my [Github Repository](https://github.com/cheehwatang/leetcode-java).\\n\\nThank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.\\n\\n---\\n## 1st Approach - Intuitive\\n\\nUsing the intuitive way of checking, which is to check the row, the column and the box to see if any same number.\\n\\nWith that, we can split it into 3 separate methods to check the row, the column and the box respectively.\\n\\nThis approach is adapted from the solution to solving the whole sudoku.\\n\\nHowever, we need to take note to skip the current row and column when checking, which is not necessary when solving the sudoku.\\n\\n</br>\\n\\n## Complexity\\n\\n#### Time Complexity  : O(n^3),\\nwhere \\'n\\' is 9, the length and width of the \\'board\\'.\\n\\nFor each position in the board, we perform 3 checks, row, column and box, which iterates 9 positions each.\\n\\nThus, to be more exact, it is O(3 * 9 * 9 * 9).\\n\\n#### Space Complexity : O(1),\\nas only fixed auxiliary variable is used to check.\\n\\n</br>\\n\\n### Java - Intuitive (With Explanation)\\n```\\npublic class ValidSudoku {\\n\\n    // Main Method to check the valid sudoku.\\n    public boolean isValidSudoku(char[][] board) {\\n        // Checking every number in the \\'board\\'.\\n        for (int row = 0; row < 9; row++) {\\n            for (int column = 0; column < 9; column++) {\\n                // If the position is a number (!= \\'.\\'), and it is a not a valid placement, then return false.\\n                if (board[row][column] != \\'.\\' && !isValidPlacement(board, board[row][column], row, column))\\n                    return false;\\n            }\\n        }\\n        // If all checks succeed, then the \\'board\\' is a valid sudoku.\\n        return true;\\n    }\\n\\n    // Method to check if identical number found in the row.\\n    private boolean isNumberInRow(char[][] board, char number, int row, int column) {\\n        for (int i = 0; i < 9; i++) {\\n            // \"column != i\" to skip the current number.\\n            // Otherwise, check if any identical number in the row and return true if found.\\n            if (column != i && board[row][i] == number) return true;\\n        }\\n        // If we did not find any identical number in the row, then return false.\\n        return false;\\n    }\\n\\n    private boolean isNumberInColumn(char[][] board, char number, int row, int column) {\\n        for (int i = 0; i < 9; i++) {\\n            // \"row != i\" to skip the current number.\\n            // Otherwise, check if any identical number in the column and return true if found.\\n            if (row != i && board[i][column] == number) return true;\\n        }\\n        // If we did not find any identical number in the column, then return false.\\n        return false;\\n    }\\n\\n    private boolean isNumberInBox(char[][] board, char number, int row, int column) {\\n        // Here, we get the top left corner position of the box the \\'number\\' is in,\\n        // because we are going to scan from top left to bottom right of the box.\\n        int boxRow = row - row % 3;\\n        int boxColumn = column - column % 3;\\n\\n        // Checking just the 3 row and 3 column position in the box.\\n        for (int i = boxRow; i < boxRow + 3; i++) {\\n            for (int j = boxColumn; j < boxColumn + 3; j++) {\\n                // \"row != i && column != j\" to skip the current number.\\n                // Otherwise, check if any identical number in the box and return true if found.\\n                if (row != i && column != j && board[i][j] == number) return true;\\n            }\\n        }\\n        // If we did not find any identical number in the box, then return false.\\n        return false;\\n    }\\n\\n    // Additional wrapper method for all three checks to make the code more readable.\\n    private boolean isValidPlacement(char[][] board, char number, int row, int column) {\\n        // If the number is not found in the row, column and the box, then it is a valid placement and return true.\\n        return !isNumberInRow(board, number, row, column) &&\\n                !isNumberInColumn(board, number, row, column) &&\\n                !isNumberInBox(board, number, row, column);\\n    }\\n}\\n\\n```\\n\\n### Java - Intuitive (Clean Code)\\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        for (int row = 0; row < 9; row++) {\\n            for (int column = 0; column < 9; column++) {\\n                if (board[row][column] != \\'.\\' && !isValidPlacement(board, board[row][column], row, column))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private boolean isNumberInRow(char[][] board, char number, int row, int column) {\\n        for (int i = 0; i < 9; i++) {\\n            if (column != i && board[row][i] == number) return true;\\n        }\\n        return false;\\n    }\\n\\n    private boolean isNumberInColumn(char[][] board, char number, int row, int column) {\\n        for (int i = 0; i < 9; i++) {\\n            if (row != i && board[i][column] == number) return true;\\n        }\\n        return false;\\n    }\\n\\n    private boolean isNumberInBox(char[][] board, char number, int row, int column) {\\n        int boxRow = row - row % 3;\\n        int boxColumn = column - column % 3;\\n        for (int i = boxRow; i < boxRow + 3; i++) {\\n            for (int j = boxColumn; j < boxColumn + 3; j++) {\\n                if (row != i && column != j && board[i][j] == number) return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean isValidPlacement(char[][] board, char number, int row, int column) {\\n        return !isNumberInRow(board, number, row, column) &&\\n                !isNumberInColumn(board, number, row, column) &&\\n                !isNumberInBox(board, number, row, column);\\n    }\\n}\\n```\\n---\\n## 2nd Approach\\nCredit to @StefanPochmann for this clean and readable solution.\\n\\nUsing a HashSet to record the number that was already found in the row, column and box.\\n\\nIf there are any same number in the row, column or box is already in the HashSet, then we have found the identical number, which resulted in an invalid sudoku board.\\n\\nThere are multiple approaches for the HashSet, either use separate HashSet for the rows, columns and boxes, or using String to include all the information into a single HashSet.\\n\\nThe latter approach is implemented here.\\n\\n</br>\\n\\n## Complexity\\n\\n#### Time Complexity  : O(n^2),\\nwhere \\'n\\' is 9, the length and width of the \\'board\\'.\\nThis is because we iterate through every number in \\'board\\'.\\nDo note that the string concatenation take use some additional time, but they are constant time and do not scale linearly with \\'n\\'.\\n\\n\\n#### Space Complexity : O(n^2),\\n\\nwhere \\'n\\' is 9, the length and width of the \\'board\\'.\\nThis is due to the HashSet used, which stores the information of the number in the row, column and box.\\nEvery row with every 9 numbers, likewise for every column and every box, thus, to be more precise, it is O (n^2 + n^2 + n^2).\\n\\n</br>\\n\\n### Java - Hash Table (With Explanation)\\n```\\nclass Solution {\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        Set<String> set = new HashSet<>();\\n        for (int row = 0; row < 9; row++) {\\n            for (int column = 0; column < 9; column++) {\\n                char number = board[row][column];\\n                // If the position is a number (!= \\'.\\'),\\n                // then we can try adding the number and its information into the HashSet.\\n                if (number != \\'.\\') {\\n                    // The HashSet.add() function returns a boolean result, true if added successfully and false otherwise.\\n                    // As such, we can just use this boolean return from add() to check if we successfully added.\\n                    // If any of the 3 (row, column and box) is not added successfully,\\n                    // then \\'board\\' is not a valid sudoku board.\\n                    // 1. Store the number in the row.\\n                    // 2. Store the number in the column.\\n                    // 3. Store the number in the box. (Make sure to separate row and column information with a delimiter).\\n                    if (!set.add(number + \" in row \" + row) ||\\n                            !set.add(number + \" in column \" + column) ||\\n                            !set.add(number + \" in block \" + (row / 3) + \",\" + (column / 3)))\\n                        return false;\\n                }\\n            }\\n        }\\n        // If all checks succeed, then the \\'board\\' is a valid sudoku.\\n        return true;\\n    }\\n}\\n```\\n\\n### Java - Hash Table (Clean Code)\\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        Set<String> set = new HashSet<>();\\n        for (int row = 0; row < 9; row++) {\\n            for (int column = 0; column < 9; column++) {\\n                char number = board[row][column];\\n                if (number != \\'.\\') {\\n                    if (!set.add(number + \" in row \" + row) ||\\n                            !set.add(number + \" in column \" + column) ||\\n                            !set.add(number + \" in block \" + (row / 3) + \",\" + (column / 3)))\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class ValidSudoku {\\n\\n    // Main Method to check the valid sudoku.\\n    public boolean isValidSudoku(char[][] board) {\\n        // Checking every number in the \\'board\\'.\\n        for (int row = 0; row < 9; row++) {\\n            for (int column = 0; column < 9; column++) {\\n                // If the position is a number (!= \\'.\\'), and it is a not a valid placement, then return false.\\n                if (board[row][column] != \\'.\\' && !isValidPlacement(board, board[row][column], row, column))\\n                    return false;\\n            }\\n        }\\n        // If all checks succeed, then the \\'board\\' is a valid sudoku.\\n        return true;\\n    }\\n\\n    // Method to check if identical number found in the row.\\n    private boolean isNumberInRow(char[][] board, char number, int row, int column) {\\n        for (int i = 0; i < 9; i++) {\\n            // \"column != i\" to skip the current number.\\n            // Otherwise, check if any identical number in the row and return true if found.\\n            if (column != i && board[row][i] == number) return true;\\n        }\\n        // If we did not find any identical number in the row, then return false.\\n        return false;\\n    }\\n\\n    private boolean isNumberInColumn(char[][] board, char number, int row, int column) {\\n        for (int i = 0; i < 9; i++) {\\n            // \"row != i\" to skip the current number.\\n            // Otherwise, check if any identical number in the column and return true if found.\\n            if (row != i && board[i][column] == number) return true;\\n        }\\n        // If we did not find any identical number in the column, then return false.\\n        return false;\\n    }\\n\\n    private boolean isNumberInBox(char[][] board, char number, int row, int column) {\\n        // Here, we get the top left corner position of the box the \\'number\\' is in,\\n        // because we are going to scan from top left to bottom right of the box.\\n        int boxRow = row - row % 3;\\n        int boxColumn = column - column % 3;\\n\\n        // Checking just the 3 row and 3 column position in the box.\\n        for (int i = boxRow; i < boxRow + 3; i++) {\\n            for (int j = boxColumn; j < boxColumn + 3; j++) {\\n                // \"row != i && column != j\" to skip the current number.\\n                // Otherwise, check if any identical number in the box and return true if found.\\n                if (row != i && column != j && board[i][j] == number) return true;\\n            }\\n        }\\n        // If we did not find any identical number in the box, then return false.\\n        return false;\\n    }\\n\\n    // Additional wrapper method for all three checks to make the code more readable.\\n    private boolean isValidPlacement(char[][] board, char number, int row, int column) {\\n        // If the number is not found in the row, column and the box, then it is a valid placement and return true.\\n        return !isNumberInRow(board, number, row, column) &&\\n                !isNumberInColumn(board, number, row, column) &&\\n                !isNumberInBox(board, number, row, column);\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        for (int row = 0; row < 9; row++) {\\n            for (int column = 0; column < 9; column++) {\\n                if (board[row][column] != \\'.\\' && !isValidPlacement(board, board[row][column], row, column))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private boolean isNumberInRow(char[][] board, char number, int row, int column) {\\n        for (int i = 0; i < 9; i++) {\\n            if (column != i && board[row][i] == number) return true;\\n        }\\n        return false;\\n    }\\n\\n    private boolean isNumberInColumn(char[][] board, char number, int row, int column) {\\n        for (int i = 0; i < 9; i++) {\\n            if (row != i && board[i][column] == number) return true;\\n        }\\n        return false;\\n    }\\n\\n    private boolean isNumberInBox(char[][] board, char number, int row, int column) {\\n        int boxRow = row - row % 3;\\n        int boxColumn = column - column % 3;\\n        for (int i = boxRow; i < boxRow + 3; i++) {\\n            for (int j = boxColumn; j < boxColumn + 3; j++) {\\n                if (row != i && column != j && board[i][j] == number) return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean isValidPlacement(char[][] board, char number, int row, int column) {\\n        return !isNumberInRow(board, number, row, column) &&\\n                !isNumberInColumn(board, number, row, column) &&\\n                !isNumberInBox(board, number, row, column);\\n    }\\n}\\n```\n```\\nclass Solution {\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        Set<String> set = new HashSet<>();\\n        for (int row = 0; row < 9; row++) {\\n            for (int column = 0; column < 9; column++) {\\n                char number = board[row][column];\\n                // If the position is a number (!= \\'.\\'),\\n                // then we can try adding the number and its information into the HashSet.\\n                if (number != \\'.\\') {\\n                    // The HashSet.add() function returns a boolean result, true if added successfully and false otherwise.\\n                    // As such, we can just use this boolean return from add() to check if we successfully added.\\n                    // If any of the 3 (row, column and box) is not added successfully,\\n                    // then \\'board\\' is not a valid sudoku board.\\n                    // 1. Store the number in the row.\\n                    // 2. Store the number in the column.\\n                    // 3. Store the number in the box. (Make sure to separate row and column information with a delimiter).\\n                    if (!set.add(number + \" in row \" + row) ||\\n                            !set.add(number + \" in column \" + column) ||\\n                            !set.add(number + \" in block \" + (row / 3) + \",\" + (column / 3)))\\n                        return false;\\n                }\\n            }\\n        }\\n        // If all checks succeed, then the \\'board\\' is a valid sudoku.\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        Set<String> set = new HashSet<>();\\n        for (int row = 0; row < 9; row++) {\\n            for (int column = 0; column < 9; column++) {\\n                char number = board[row][column];\\n                if (number != \\'.\\') {\\n                    if (!set.add(number + \" in row \" + row) ||\\n                            !set.add(number + \" in column \" + column) ||\\n                            !set.add(number + \" in block \" + (row / 3) + \",\" + (column / 3)))\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2840666,
                "title": "python3-easy-to-understand-beginner-friendly",
                "content": "Since the Sudoku is 9 by 9, it doesn\\'t really matter if we go over it once, twice, or three times. I feel like if we get this question in an interview, the interviewer is looking for a clean code. The tricky part of this problem would be handling the sub-box indices.\\n\\n**Clear and Understandable Approach**\\n```python\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        # Given an arr of row/col/sub,\\n        # check if there are duplicates.\\n        def isValid(arr):\\n            s = \\'\\'.join(arr).replace(\\'.\\',\\'\\')\\n            return len(s) == len(set(s))\\n        \\n        # Check each row in the board\\n        def checkRow():\\n            for row in board:\\n                if not isValid(row):\\n                    return False\\n            return True\\n        \\n        # Check each col in the board,\\n        # To access each col, we first unpack the board into sperate lists using *\\n        # We then zip these rows together into columns.\\n        def checkCol():\\n            for col in zip(*board):\\n                if not isValid(col):\\n                    return False\\n            return True\\n        \\n        # To get each sub-box, we first get the top-left indices of each sub-box,\\n        # We then go 3 steps on each row and 3 steps on each col to construct the box.\\n        def checkSub():\\n            for r in range(0,9,3):\\n                for c in range(0,9,3):\\n                    sub = [board[r+dr][c+dc] for dr in range(3) for dc in range(3)]\\n                    if not isValid(sub):\\n                        return False\\n            return True\\n        \\n        # In order to be a valid Sudoku, all row, col, and sub-box need to be valid\\n        return checkRow() and checkCol() and checkSub()\\n```\\n\\n**One pass using row, col, sub-box ID**\\nWe can also optimize the solution a little bit, using a hashmap to store the visited elements for each row, col, and sub-box.\\n```python\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        # Row, Col, and subBox will each contain 9 sets to keep track of the visited element.\\n        # Using 0-8 as the id for each row, col, and sub-box.\\n        # At any time if the same number is visited twice, return False. \\n        Row = defaultdict(set)\\n        Col = defaultdict(set)\\n        subBox = defaultdict(set)\\n        \\n        for r in range(9):\\n            for c in range(9):\\n                \\n                cur = board[r][c]\\n                if cur==\\'.\\':\\n                    continue\\n                \\n                # r is the id for Row \\n                if cur in Row[r]:\\n                    return False\\n                Row[r].add(cur)\\n                \\n                # c is the id for Col\\n                if cur in Col[c]:\\n                    return False\\n                Col[c].add(cur)\\n                \\n                # sub-box id is a little bit tricky\\n                # r//3*3 will map the number 0-8 to 0,3,6 which is the starting id for each row.\\n                # c//3 will map the number 0-8 to 0,1,2, which is the column.\\n                # So r//3*3+c//3 is corresponding to sub-box id as shown\\n                                                             ----- ----- -----\\n                boxId = r//3*3+c//3                         |  0  |  1  |  2  |\\n                if cur in subBox[boxId]:                     ----- ----- -----\\n                    return False                            |  3  |  4  |  5  |\\n                subBox[boxId].add(cur)                       ----- ----- -----\\n                                                            |  6  |  7  |  8  |\\n                                                             ----- ----- -----\\n        # We passed all the tests, return True\\n        return True\\n```\\n\\nFor more advanced solutions check [HERE](https://leetcode.com/problems/valid-sudoku/discuss/2840529/PythonC%2B%2BJavaRust-O(1)-space-an-other-approaches...-%2B-BONUS-ONE-LINER-(explained))\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        # Given an arr of row/col/sub,\\n        # check if there are duplicates.\\n        def isValid(arr):\\n            s = \\'\\'.join(arr).replace(\\'.\\',\\'\\')\\n            return len(s) == len(set(s))\\n        \\n        # Check each row in the board\\n        def checkRow():\\n            for row in board:\\n                if not isValid(row):\\n                    return False\\n            return True\\n        \\n        # Check each col in the board,\\n        # To access each col, we first unpack the board into sperate lists using *\\n        # We then zip these rows together into columns.\\n        def checkCol():\\n            for col in zip(*board):\\n                if not isValid(col):\\n                    return False\\n            return True\\n        \\n        # To get each sub-box, we first get the top-left indices of each sub-box,\\n        # We then go 3 steps on each row and 3 steps on each col to construct the box.\\n        def checkSub():\\n            for r in range(0,9,3):\\n                for c in range(0,9,3):\\n                    sub = [board[r+dr][c+dc] for dr in range(3) for dc in range(3)]\\n                    if not isValid(sub):\\n                        return False\\n            return True\\n        \\n        # In order to be a valid Sudoku, all row, col, and sub-box need to be valid\\n        return checkRow() and checkCol() and checkSub()\\n```\n```python\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        # Row, Col, and subBox will each contain 9 sets to keep track of the visited element.\\n        # Using 0-8 as the id for each row, col, and sub-box.\\n        # At any time if the same number is visited twice, return False. \\n        Row = defaultdict(set)\\n        Col = defaultdict(set)\\n        subBox = defaultdict(set)\\n        \\n        for r in range(9):\\n            for c in range(9):\\n                \\n                cur = board[r][c]\\n                if cur==\\'.\\':\\n                    continue\\n                \\n                # r is the id for Row \\n                if cur in Row[r]:\\n                    return False\\n                Row[r].add(cur)\\n                \\n                # c is the id for Col\\n                if cur in Col[c]:\\n                    return False\\n                Col[c].add(cur)\\n                \\n                # sub-box id is a little bit tricky\\n                # r//3*3 will map the number 0-8 to 0,3,6 which is the starting id for each row.\\n                # c//3 will map the number 0-8 to 0,1,2, which is the column.\\n                # So r//3*3+c//3 is corresponding to sub-box id as shown\\n                                                             ----- ----- -----\\n                boxId = r//3*3+c//3                         |  0  |  1  |  2  |\\n                if cur in subBox[boxId]:                     ----- ----- -----\\n                    return False                            |  3  |  4  |  5  |\\n                subBox[boxId].add(cur)                       ----- ----- -----\\n                                                            |  6  |  7  |  8  |\\n                                                             ----- ----- -----\\n        # We passed all the tests, return True\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2840529,
                "title": "python-c-java-o-logn-space-and-other-approaches-bonus-one-liner-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nHere, I provide several approaches to check for a valid sudoku game. The best of them has **O(m\\\\*n)** time compleixty and **O(logN)** space complexity.\\n****\\n\\n**Comment.** There are numerous approaches on how to tackle this problem, however, they all differ in the amount of memoization done. The typical solutions employ:\\n1. Bit manipulation to reduce memory requirements to just one number. \\n2. Memoizing into a hashset until a collision happens.\\n3. Memoizing into a list, then making a set and comparing its size to the size of the original list.\\n\\n**Python #1.** An **O(logN)**-space solution using *zip* to transpose, a generator to yield blocks and bit memoization to check for unique digits.\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        # a function to check rows, columns and blocks using O(logN) space\\n        def not_valid(digits, m=0):\\n            return any( 1 & (m >> int(d)) + (m := (m | (1 << int(d))))*0\\n                        for d in digits if d != \".\")\\n                       \\n        # a generator to extract blocks\\n        def blocks():\\n            for i in range(3):\\n                for j in range(3):\\n                    yield (n for row in board[i*3:(i+1)*3] for n in row[j*3:(j+1)*3])\\n        \\n        if any(map(not_valid, board))       : return False       # [1] test rows\\n        if any(map(not_valid, zip(*board))) : return False       # [2] test columns\\n        if any(map(not_valid, blocks()))    : return False       # [3] test blocks\\n        \\n        return True\\n```\\nThe one-liner to check digits can be expanded as follows:\\n```\\ndef not_valid(digits, m=0):\\n\\tfor d in digits:\\n\\t\\tif d != \".\":\\n\\t\\t\\tif (1 & (m >> int(d))) == 1 : return True\\n\\t\\t\\tm |= (1 << int(d))\\n\\treturn False\\n```\\n\\nIf you\\'re not comfortable with it, you can use the standard `len(set(list)) != len(list)` technique that is linear in allocated space:\\n```\\ndef not_valid(digits):\\n\\treturn len(set(s:= [d for d in digits if d != \".\"])) != len(s)\\n```\\n\\n**Python #2.** Here, we use smart memoization where for rows, columns and blocks, different types of memoization elements are being constructed. This prevents interference between them when using `len(set(list)) == len(list)` approach.\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        seen = []\\n        \\n        for i, row in enumerate(board):\\n            for j, d in enumerate(row):\\n                if  d != \".\":\\n                    seen.extend([(d,i), (j,d), (d,i//3,j//3)])    # these tuples never interfere!\\n        \\n        return len(set(seen)) == len(seen)\\n```\\n\\n**Python #3.** Easy ranges with *numpy*.\\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        board = np.array(board)\\n        \\n        def not_valid(digits):\\n            s = \"\".join(digits).replace(\".\", \"\")\\n            return len(s) != len(set(s))\\n        \\n        for k in range(9):\\n            r, c = board[k,:], board[:,k]\\n            i, j = 3*(k//3), 3*(k%3)\\n            b    = board[i:i+3,j:j+3].flatten()\\n            if any(map(not_valid, (r,c,b))) : return False\\n        \\n        return True\\n```\\n\\nSolutions in other languages.\\n\\n<iframe src=\"https://leetcode.com/playground/Jjxoh3cu/shared\" frameBorder=\"0\" width=\"800\" height=\"380\"></iframe>\\n\\n**\\u2705 YOU MADE IT TILL THE BONUS SECTION... YOUR GREAT EFFORT DESERVES UPVOTING THIS POST!**\\n\\n**Python.** Finally, it\\'s one-liner time! The solution #2 can be compactified as follows.\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        return len(seen := sum(([(d,i),(j,d),(d,i//3,j//3)]\\n                                if  d != \".\" else []\\n                                for i, row in enumerate(board)\\n                                for j, d   in enumerate(row)),[])) == len(set(seen))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        # a function to check rows, columns and blocks using O(logN) space\\n        def not_valid(digits, m=0):\\n            return any( 1 & (m >> int(d)) + (m := (m | (1 << int(d))))*0\\n                        for d in digits if d != \".\")\\n                       \\n        # a generator to extract blocks\\n        def blocks():\\n            for i in range(3):\\n                for j in range(3):\\n                    yield (n for row in board[i*3:(i+1)*3] for n in row[j*3:(j+1)*3])\\n        \\n        if any(map(not_valid, board))       : return False       # [1] test rows\\n        if any(map(not_valid, zip(*board))) : return False       # [2] test columns\\n        if any(map(not_valid, blocks()))    : return False       # [3] test blocks\\n        \\n        return True\\n```\n```\\ndef not_valid(digits, m=0):\\n\\tfor d in digits:\\n\\t\\tif d != \".\":\\n\\t\\t\\tif (1 & (m >> int(d))) == 1 : return True\\n\\t\\t\\tm |= (1 << int(d))\\n\\treturn False\\n```\n```\\ndef not_valid(digits):\\n\\treturn len(set(s:= [d for d in digits if d != \".\"])) != len(s)\\n```\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        seen = []\\n        \\n        for i, row in enumerate(board):\\n            for j, d in enumerate(row):\\n                if  d != \".\":\\n                    seen.extend([(d,i), (j,d), (d,i//3,j//3)])    # these tuples never interfere!\\n        \\n        return len(set(seen)) == len(seen)\\n```\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        board = np.array(board)\\n        \\n        def not_valid(digits):\\n            s = \"\".join(digits).replace(\".\", \"\")\\n            return len(s) != len(set(s))\\n        \\n        for k in range(9):\\n            r, c = board[k,:], board[:,k]\\n            i, j = 3*(k//3), 3*(k%3)\\n            b    = board[i:i+3,j:j+3].flatten()\\n            if any(map(not_valid, (r,c,b))) : return False\\n        \\n        return True\\n```\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        return len(seen := sum(([(d,i),(j,d),(d,i//3,j//3)]\\n                                if  d != \".\" else []\\n                                for i, row in enumerate(board)\\n                                for j, d   in enumerate(row)),[])) == len(set(seen))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794580,
                "title": "solution-very-detailed-explanation-in-c-please-upvote-if-you-like",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n/*\\nThis problem looks intimidating in the first glance but we just need to split our solution into three parts:\\n1. Check if the sudoku board fulfils the row requirement that \"Each row must contain the digits 1-9 without repetition.\"\\n\\n2. Check if it fulfils column requirement that \"Each column must contain the digits 1-9 without repetition.\"\\n\\n3. Check if it has the right subbox such that \"Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.\"\\n\\nIf you scroll down to the bottom, \"Constraints\" section, you\\'ll find that board[i][j] must be a digit from 1 to 9. So all we need to check is if there is any repitition in row, column, and subbox. To support quick lookups, we can use hashmap, unordered_set specifically. \\n\\nA note is that I used two unordered_sets: check_row, check_col in my solution. However, you can just use one, which means that you reuse the unordered_set after part 1 by clearing its content and reusing it for part 2. \\n\\nTime complexity is O(1) because the nested for loops will run 81 (9 * 9) times. Space complexity is O(n). \\n\\nSince I\\'m a beginner, I\\'m still looking for ways to improve the time and memory efficiency of my solution, but I\\'m sure it\\'s an understandable, though not perfect, solution. \\n*/\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n    // 1. Check row quality\\n    for (int row = 0; row < 9; row++){\\n        unordered_set<char> check_row;\\n        for (int col = 0; col < 9; col++){\\n            if (board[row][col] != \\'.\\' && check_row.find(board[row][col]) != check_row.end()){\\n                return false;\\n            }\\n            check_row.insert(board[row][col]);\\n        }\\n    }\\n\\n    // 2. Check column quality\\n    for (int col = 0; col < 9; col++){\\n        unordered_set<char> check_col;\\n        for (int row = 0; row < 9; row++){\\n            if (board[row][col] != \\'.\\' && check_col.find(board[row][col]) != check_col.end()){\\n                return false;\\n            }\\n            check_col.insert(board[row][col]);\\n        }\\n    }\\n\\n    // 3. Check 3*3 sub-boxes\\n    /*\\n    Idea here is that we can break the Sudoku board into 9 subboxes, numbered 0, 1, 2, ..., 8, and these box numbers correspond to the index in the vector \"check_subbox.\"\\n\\n    Then, we need to find a way to determine which subbox an element should go based on its row and col number. We can use a formula: int location = (row/3) * 3 + col/3. This way, we can put the element into the desire box. One example is coordinate [8, 8]. It should be put into the last subbox (subbox 8). By this formula, it should go to (8/3) * 3 + 8/3 = 2*3 + 2 = 8. You can take other examples to verify but that\\'s pretty much the logics. \\n    */\\n    vector<unordered_set<char>> check_subbox(9);\\n    for (int row = 0; row < 9; row++){\\n        for (int col = 0; col < 9; col++){\\n            int loc = (row / 3) * 3 + col / 3;\\n            if (board[row][col] != \\'.\\' && check_subbox[loc].find(board[row][col]) != check_subbox[loc].end()){\\n                return false;\\n            }\\n            check_subbox[loc].insert(board[row][col]);\\n        }\\n    }\\n    return true;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n/*\\nThis problem looks intimidating in the first glance but we just need to split our solution into three parts:\\n1. Check if the sudoku board fulfils the row requirement that \"Each row must contain the digits 1-9 without repetition.\"\\n\\n2. Check if it fulfils column requirement that \"Each column must contain the digits 1-9 without repetition.\"\\n\\n3. Check if it has the right subbox such that \"Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.\"\\n\\nIf you scroll down to the bottom, \"Constraints\" section, you\\'ll find that board[i][j] must be a digit from 1 to 9. So all we need to check is if there is any repitition in row, column, and subbox. To support quick lookups, we can use hashmap, unordered_set specifically. \\n\\nA note is that I used two unordered_sets: check_row, check_col in my solution. However, you can just use one, which means that you reuse the unordered_set after part 1 by clearing its content and reusing it for part 2. \\n\\nTime complexity is O(1) because the nested for loops will run 81 (9 * 9) times. Space complexity is O(n). \\n\\nSince I\\'m a beginner, I\\'m still looking for ways to improve the time and memory efficiency of my solution, but I\\'m sure it\\'s an understandable, though not perfect, solution. \\n*/\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n    // 1. Check row quality\\n    for (int row = 0; row < 9; row++){\\n        unordered_set<char> check_row;\\n        for (int col = 0; col < 9; col++){\\n            if (board[row][col] != \\'.\\' && check_row.find(board[row][col]) != check_row.end()){\\n                return false;\\n            }\\n            check_row.insert(board[row][col]);\\n        }\\n    }\\n\\n    // 2. Check column quality\\n    for (int col = 0; col < 9; col++){\\n        unordered_set<char> check_col;\\n        for (int row = 0; row < 9; row++){\\n            if (board[row][col] != \\'.\\' && check_col.find(board[row][col]) != check_col.end()){\\n                return false;\\n            }\\n            check_col.insert(board[row][col]);\\n        }\\n    }\\n\\n    // 3. Check 3*3 sub-boxes\\n    /*\\n    Idea here is that we can break the Sudoku board into 9 subboxes, numbered 0, 1, 2, ..., 8, and these box numbers correspond to the index in the vector \"check_subbox.\"\\n\\n    Then, we need to find a way to determine which subbox an element should go based on its row and col number. We can use a formula: int location = (row/3) * 3 + col/3. This way, we can put the element into the desire box. One example is coordinate [8, 8]. It should be put into the last subbox (subbox 8). By this formula, it should go to (8/3) * 3 + 8/3 = 2*3 + 2 = 8. You can take other examples to verify but that\\'s pretty much the logics. \\n    */\\n    vector<unordered_set<char>> check_subbox(9);\\n    for (int row = 0; row < 9; row++){\\n        for (int col = 0; col < 9; col++){\\n            int loc = (row / 3) * 3 + col / 3;\\n            if (board[row][col] != \\'.\\' && check_subbox[loc].find(board[row][col]) != check_subbox[loc].end()){\\n                return false;\\n            }\\n            check_subbox[loc].insert(board[row][col]);\\n        }\\n    }\\n    return true;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841310,
                "title": "c-use-hashmap-easy-efficient-solution",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    \\n    bool isValidSudoku(vector<vector<char> > &board)\\n    {\\n\\t\\t//Hashmap for checking repeated number(from 1 to 9) in each row (9 rows), column (9 cols) and grid (9 grids)\\n        int row[9][9] = {0}, col[9][9] = {0}, grid_3x3[9][9] = {0}; \\n        \\n        for(int i = 0; i < board.size(); i++)\\n            for(int j = 0; j < board[i].size(); j++)\\n                if(board[i][j] != \\'.\\')\\n                {\\n                    int num = board[i][j] - \\'1\\', k = i/3*3+j/3; //k for finding grid index from 0 to 8\\n                    if(row[i][num] || col[j][num] || grid_3x3[k][num])\\n                        return false;\\n                    row[i][num] = col[j][num] = grid_3x3[k][num] = 1;\\n                }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    \\n    bool isValidSudoku(vector<vector<char> > &board)\\n    {\\n\\t\\t//Hashmap for checking repeated number(from 1 to 9) in each row (9 rows), column (9 cols) and grid (9 grids)\\n        int row[9][9] = {0}, col[9][9] = {0}, grid_3x3[9][9] = {0}; \\n        \\n        for(int i = 0; i < board.size(); i++)\\n            for(int j = 0; j < board[i].size(); j++)\\n                if(board[i][j] != \\'.\\')\\n                {\\n                    int num = board[i][j] - \\'1\\', k = i/3*3+j/3; //k for finding grid index from 0 to 8\\n                    if(row[i][num] || col[j][num] || grid_3x3[k][num])\\n                        return false;\\n                    row[i][num] = col[j][num] = grid_3x3[k][num] = 1;\\n                }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15643,
                "title": "simple-clear-java-solution",
                "content": "    public class Solution {\\n        public boolean isValidSudoku(char[][] board) {\\n            \\n           boolean[][] row = new boolean[9][9];\\n           boolean[][] column = new boolean[9][9];\\n           boolean[][] block = new boolean[9][9];\\n           \\n           for(int i = 0;i<9;i++){\\n               for(int j=0;j<9;j++){\\n                    int c = board[i][j] - '1';       \\n                    if(board[i][j]=='.'){\\n                        continue;\\n                    }\\n                    if(row[i][c]||column[j][c]||block[i - i % 3 + j / 3][c]){\\n                        return false;\\n                    }\\n                    row[i][c] = column[j][c] = block[i - i % 3 + j / 3][c] = true;\\n               }\\n           }\\n           return true;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isValidSudoku(char[][] board) {\\n            \\n           boolean[][] row = new boolean[9][9];\\n           boolean[][] column = new boolean[9][9];\\n           boolean[][] block = new boolean[9][9];\\n           \\n           for(int i = 0;i<9;i++){\\n               for(int j=0;j<9;j++){\\n                    int c = board[i][j] - '1';       \\n                    if(board[i][j]=='.'){\\n                        continue;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 511365,
                "title": "simple-intuitive-python-approach",
                "content": "![image](https://assets.leetcode.com/users/tohbaino/image_1581904292.png)\\n\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        rows = [set() for i in range(9)]\\n        cols = [set() for i in range(9)]\\n        mMat = [set() for i in range(9)]\\n        \\n        for i in range(9):\\n            for j in range(9):\\n                cur = board[i][j]\\n                if cur != \\'.\\':\\n                    \\n                    k = (i // 3 ) * 3 + j // 3\\n                \\n                    if cur not in rows[i]: rows[i].add(cur)\\n                    else: return False\\n                    \\n                    if cur not in cols[j]: cols[j].add(cur)\\n                    else: return False\\n                \\n                    if cur not in mMat[k]: mMat[k].add(cur)\\n                    else: return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        rows = [set() for i in range(9)]\\n        cols = [set() for i in range(9)]\\n        mMat = [set() for i in range(9)]\\n        \\n        for i in range(9):\\n            for j in range(9):\\n                cur = board[i][j]\\n                if cur != \\'.\\':\\n                    \\n                    k = (i // 3 ) * 3 + j // 3\\n                \\n                    if cur not in rows[i]: rows[i].add(cur)\\n                    else: return False\\n                    \\n                    if cur not in cols[j]: cols[j].add(cur)\\n                    else: return False\\n                \\n                    if cur not in mMat[k]: mMat[k].add(cur)\\n                    else: return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15642,
                "title": "share-my-c-solution",
                "content": "    bool isValidSudoku(vector<vector<char>>& board) {\\n        map<char,int> row[9],col[9],blk[9];\\n        char c;\\n        for(int i = 0;i<9;i++){\\n            for(int j =0;j<9;j++){\\n                c = board[i][j];\\n                if((c!='.')&&(0<row[i][c]++ || 0<col[j][c]++ || 0<blk[i/3*3+j/3][c]++)) return false;\\n            }\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    bool isValidSudoku(vector<vector<char>>& board) {\\n        map<char,int> row[9],col[9],blk[9];\\n        char c;\\n        for(int i = 0;i<9;i++){\\n            for(int j =0;j<9;j++){\\n                c = board[i][j];\\n                if((c!='.')&&(0<row[i][c]++ || 0<col[j][c]++ || 0<blk[i/3*3+j/3][c]++)) return false;\\n            }\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 160227,
                "title": "python-solution",
                "content": "Time complexity: `O(n)`, space complexity: `O(n)`.\\n\\n```\\nclass Solution(object):\\n    def isValidSudoku(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: bool\\n        \"\"\"\\n        dic_list1 = [set() for _ in range(9)]\\n        dic_list2 = [set() for _ in range(9)]\\n        dic_list3 = [[set() for _ in range(3)] for _ in range(3)]\\n        for i in range(9):\\n            for j in range(9):\\n                if not board[i][j].isnumeric():\\n                    continue\\n                y = i // 3\\n                x = j // 3\\n                num = board[i][j]\\n                if (num in dic_list1[i]) or (num in dic_list2[j]) or (num in dic_list3[x][y]):\\n                    return False\\n                else:\\n                    dic_list1[i].add(num)\\n                    dic_list2[j].add(num)\\n                    dic_list3[x][y].add(num)\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isValidSudoku(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: bool\\n        \"\"\"\\n        dic_list1 = [set() for _ in range(9)]\\n        dic_list2 = [set() for _ in range(9)]\\n        dic_list3 = [[set() for _ in range(3)] for _ in range(3)]\\n        for i in range(9):\\n            for j in range(9):\\n                if not board[i][j].isnumeric():\\n                    continue\\n                y = i // 3\\n                x = j // 3\\n                num = board[i][j]\\n                if (num in dic_list1[i]) or (num in dic_list2[j]) or (num in dic_list3[x][y]):\\n                    return False\\n                else:\\n                    dic_list1[i].add(num)\\n                    dic_list2[j].add(num)\\n                    dic_list3[x][y].add(num)\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 156618,
                "title": "javascript-using-arrays-of-hash-maps-beats-99-54",
                "content": "My solution is relatively straight-forward (an explanation for the value of `k` is explained below in the comments).\\n\\n```javascript\\n/**\\n * @param {character[][]} board\\n * @return {boolean}\\n */\\nvar isValidSudoku = function(board) {    \\n    const boxes = [{}, {}, {}, {}, {}, {}, {}, {}, {}];\\n    const cols = [{}, {}, {}, {}, {}, {}, {}, {}, {}]; \\n    const rows = [{}, {}, {}, {}, {}, {}, {}, {}, {}];   \\n    \\n    for (let i = 0; i < 9; i++) {              \\n        for (let j = 0; j < 9; j++) {            \\n            const digit = board[i][j];\\n            \\n            if (digit !== \\'.\\') {\\n                const k = Math.floor(j / 3) + (Math.floor(i / 3) * 3);\\n\\n                if (boxes[k][digit] || cols[j][digit] || rows[i][digit]) {\\n                    return false;\\n                }\\n\\n                boxes[k][digit] = cols[j][digit] = rows[i][digit] = true;       \\n            }\\n        }\\n    }\\n    \\n    return true;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * @param {character[][]} board\\n * @return {boolean}\\n */\\nvar isValidSudoku = function(board) {    \\n    const boxes = [{}, {}, {}, {}, {}, {}, {}, {}, {}];\\n    const cols = [{}, {}, {}, {}, {}, {}, {}, {}, {}]; \\n    const rows = [{}, {}, {}, {}, {}, {}, {}, {}, {}];   \\n    \\n    for (let i = 0; i < 9; i++) {              \\n        for (let j = 0; j < 9; j++) {            \\n            const digit = board[i][j];\\n            \\n            if (digit !== \\'.\\') {\\n                const k = Math.floor(j / 3) + (Math.floor(i / 3) * 3);\\n\\n                if (boxes[k][digit] || cols[j][digit] || rows[i][digit]) {\\n                    return false;\\n                }\\n\\n                boxes[k][digit] = cols[j][digit] = rows[i][digit] = true;       \\n            }\\n        }\\n    }\\n    \\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3055145,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int rows[9][9]={0};\\n\\tint cols[9][9]={0};\\n\\tint blocks[3][3][9]={0};\\n\\tfor(int r=0;r<9;r++)\\n\\t\\tfor(int c=0;c<9;c++)\\n\\t\\t\\tif(board[r][c]!=\\'.\\'){\\n\\t\\t\\t\\tint number=board[r][c]-\\'1\\';\\n\\t\\t\\t\\tif(rows[r][number]++)\\n                 return 0;\\n\\t\\t\\t\\tif(cols[c][number]++)\\n                 return 0;\\n\\t\\t\\t\\tif(blocks[r/3][c/3][number]++)\\n                 return 0;\\n\\t\\t\\t}\\n\\treturn 1;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int rows[9][9]={0};\\n\\tint cols[9][9]={0};\\n\\tint blocks[3][3][9]={0};\\n\\tfor(int r=0;r<9;r++)\\n\\t\\tfor(int c=0;c<9;c++)\\n\\t\\t\\tif(board[r][c]!=\\'.\\'){\\n\\t\\t\\t\\tint number=board[r][c]-\\'1\\';\\n\\t\\t\\t\\tif(rows[r][number]++)\\n                 return 0;\\n\\t\\t\\t\\tif(cols[c][number]++)\\n                 return 0;\\n\\t\\t\\t\\tif(blocks[r/3][c/3][number]++)\\n                 return 0;\\n\\t\\t\\t}\\n\\treturn 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513191,
                "title": "java-tc-o-9-9-sc-o-1-most-optimized-solution-using-bit-manipulation",
                "content": "```java\\n/**\\n * Most Optimized solution using Bit Manipulation\\n * \\n * Using only one int to store the bits for Row, Column and Box.\\n *\\n * This Solution uses True O(1) space and requires True O(N^2) time.\\n *\\n * Bit 0 -> 8 will represent ith Row\\n * Bit 9 -> 17 will represent ith Column\\n * Bit 18 -> 26 will represent ith Box\\n *\\n * Time Complexity: O(9*9)\\n *\\n * Space Complexity: O(1). Using only one integer.\\n */\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        if (board == null || board.length != 9 || board[0].length != 9) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        int rowColBox = 0;\\n\\n        for (int i = 0; i < 9; i++) { // Index of row, column and box\\n            for (int j = 0; j < 9; j++) {\\n                // Check ith row\\n                rowColBox = validateAndAddCell(board[i][j], 0, rowColBox);\\n                if (rowColBox == -1) {\\n                    return false;\\n                }\\n\\n                // Check ith column\\n                rowColBox = validateAndAddCell(board[j][i], 1, rowColBox);\\n                if (rowColBox == -1) {\\n                    return false;\\n                }\\n\\n                // Check ith box\\n                int boxRow = 3 * (i / 3) + (j / 3);\\n                int colRow = 3 * (i % 3) + (j % 3);\\n                rowColBox = validateAndAddCell(board[boxRow][colRow], 2, rowColBox);\\n                if (rowColBox == -1) {\\n                    return false;\\n                }\\n            }\\n            rowColBox = 0;\\n        }\\n\\n        return true;\\n    }\\n\\n    private int validateAndAddCell(char c, int type, int rowColBox) {\\n        if (c == \\'.\\') {\\n            return rowColBox;\\n        }\\n        if (c < \\'1\\' || c > \\'9\\') {\\n            return -1;\\n        }\\n\\n        int bitIdx = type * 9 + (c - \\'1\\');\\n        if (((rowColBox >> bitIdx) & 1) == 1) {\\n            return -1;\\n        }\\n\\n        return rowColBox | (1 << bitIdx);\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other parts of Sudoku question on LeetCode:\\n- [37. Sudoku Solver](https://leetcode.com/problems/sudoku-solver/discuss/1513192/Java-or-TC:-O(9N)-or-SC:-O(N)-or-Most-Optimized-Backtracking-solution-using-Bit-Manipulation)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Bit Manipulation",
                    "Matrix"
                ],
                "code": "```java\\n/**\\n * Most Optimized solution using Bit Manipulation\\n * \\n * Using only one int to store the bits for Row, Column and Box.\\n *\\n * This Solution uses True O(1) space and requires True O(N^2) time.\\n *\\n * Bit 0 -> 8 will represent ith Row\\n * Bit 9 -> 17 will represent ith Column\\n * Bit 18 -> 26 will represent ith Box\\n *\\n * Time Complexity: O(9*9)\\n *\\n * Space Complexity: O(1). Using only one integer.\\n */\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        if (board == null || board.length != 9 || board[0].length != 9) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        int rowColBox = 0;\\n\\n        for (int i = 0; i < 9; i++) { // Index of row, column and box\\n            for (int j = 0; j < 9; j++) {\\n                // Check ith row\\n                rowColBox = validateAndAddCell(board[i][j], 0, rowColBox);\\n                if (rowColBox == -1) {\\n                    return false;\\n                }\\n\\n                // Check ith column\\n                rowColBox = validateAndAddCell(board[j][i], 1, rowColBox);\\n                if (rowColBox == -1) {\\n                    return false;\\n                }\\n\\n                // Check ith box\\n                int boxRow = 3 * (i / 3) + (j / 3);\\n                int colRow = 3 * (i % 3) + (j % 3);\\n                rowColBox = validateAndAddCell(board[boxRow][colRow], 2, rowColBox);\\n                if (rowColBox == -1) {\\n                    return false;\\n                }\\n            }\\n            rowColBox = 0;\\n        }\\n\\n        return true;\\n    }\\n\\n    private int validateAndAddCell(char c, int type, int rowColBox) {\\n        if (c == \\'.\\') {\\n            return rowColBox;\\n        }\\n        if (c < \\'1\\' || c > \\'9\\') {\\n            return -1;\\n        }\\n\\n        int bitIdx = type * 9 + (c - \\'1\\');\\n        if (((rowColBox >> bitIdx) & 1) == 1) {\\n            return -1;\\n        }\\n\\n        return rowColBox | (1 << bitIdx);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1653359,
                "title": "solution-swift-valid-sudoku-test-cases",
                "content": "```swift\\nclass Solution {\\n    func isValidSudoku(_ board: [[Character]]) -> Bool {\\n        for i in board.indices {\\n            let rows = board[i].filter { $0 != \".\" }\\n            let cols = board.map{ $0[i] }.filter { $0 != \".\" }\\n            let n = (a: 3 * (i / 3), b: 3 * (i % 3))\\n            let blks = board[n.a ..< n.a + 3].flatMap{$0[n.b ..< n.b + 3]}.filter{$0 != \".\"}\\n            if rows.count != Set(rows).count ||\\n                cols.count != Set(cols).count ||\\n                blks.count != Set(blks).count { return false }\\n        }\\n        return true\\n    }\\n}\\n```\\n\\n---\\n\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.076 (0.078) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.isValidSudoku([[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n                                            [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\\n                                            [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\\n                                            [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\\n                                            [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\\n                                            [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\\n                                            [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\\n                                            [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\\n                                            [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]])\\n        XCTAssertEqual(value, true)\\n    }\\n    func test1() {\\n        let value = solution.isValidSudoku([[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n                                            [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\\n                                            [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\\n                                            [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\\n                                            [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\\n                                            [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\\n                                            [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\\n                                            [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\\n                                            [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]])\\n        XCTAssertEqual(value, false)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func isValidSudoku(_ board: [[Character]]) -> Bool {\\n        for i in board.indices {\\n            let rows = board[i].filter { $0 != \".\" }\\n            let cols = board.map{ $0[i] }.filter { $0 != \".\" }\\n            let n = (a: 3 * (i / 3), b: 3 * (i % 3))\\n            let blks = board[n.a ..< n.a + 3].flatMap{$0[n.b ..< n.b + 3]}.filter{$0 != \".\"}\\n            if rows.count != Set(rows).count ||\\n                cols.count != Set(cols).count ||\\n                blks.count != Set(blks).count { return false }\\n        }\\n        return true\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.isValidSudoku([[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n                                            [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\\n                                            [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\\n                                            [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\\n                                            [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\\n                                            [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\\n                                            [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\\n                                            [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\\n                                            [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]])\\n        XCTAssertEqual(value, true)\\n    }\\n    func test1() {\\n        let value = solution.isValidSudoku([[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n                                            [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\\n                                            [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\\n                                            [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\\n                                            [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\\n                                            [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\\n                                            [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\\n                                            [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\\n                                            [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]])\\n        XCTAssertEqual(value, false)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1237662,
                "title": "easiest-java-100-faster-98-2-less-memory",
                "content": "class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                if(board[i][j]!=\\'.\\'){\\n                    if(!isValid(board,i,j,board[i][j]))\\n                        return false;\\n                }\\n            }\\n         }\\n        return true;\\n    }\\n    \\n    public boolean isValid(char[][] board, int row, int col, char num){\\n        \\n        //for row checking\\n        for(int i=col+1;i<9;i++){\\n            if(board[row][i] == num)\\n                return false;\\n        }\\n        \\n        //For col checking\\n        for(int i=row+1;i<9;i++){\\n            if(board[i][col] == num)\\n                return false;\\n        }\\n        \\n        //for internal square\\n        int x = row - row%3, y = col-col%3;\\n        for(int i=x; i<x+3; i++){\\n            for(int j=y; j<y+3; j++){\\n                if(board[i][j]==num && !(i==row && j==col))\\n                    return false;\\n            }\\n        }   \\n        return true;\\n    }   \\n}\\n\\n\\n\\nPlease upvote if you find it easy and simple to understand\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                if(board[i][j]!=\\'.\\'){\\n                    if(!isValid(board,i,j,board[i][j]))\\n                        return false;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 780278,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {character[][]} board\\n * @return {boolean}\\n */\\nvar isValidSudoku = function(board) {\\n    let seen = new Set();\\n    for(let i = 0; i < 9; i++) {\\n      for(let j = 0; j < 9; j++) {\\n        let cell = board[i][j];\\n        if(cell != \\'.\\') {\\n            let colCell = `cell: ${j} ${cell}`;\\n            let rowCell = `row: ${i} ${cell}`;\\n            let subBoxCell = `subBox: ${parseInt(i/3)}-${parseInt(j/3)} ${cell}`;\\n        \\n            if(!seen.has(colCell) && !seen.has(rowCell) && !seen.has(subBoxCell)) {\\n                seen.add(colCell);\\n                seen.add(rowCell);\\n                seen.add(subBoxCell);\\n            }\\n            else \\n                return false;\\n          }\\n      }\\n    }\\n    return true;\\n};\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {character[][]} board\\n * @return {boolean}\\n */\\nvar isValidSudoku = function(board) {\\n    let seen = new Set();\\n    for(let i = 0; i < 9; i++) {\\n      for(let j = 0; j < 9; j++) {\\n        let cell = board[i][j];\\n        if(cell != \\'.\\') {\\n            let colCell = `cell: ${j} ${cell}`;\\n            let rowCell = `row: ${i} ${cell}`;\\n            let subBoxCell = `subBox: ${parseInt(i/3)}-${parseInt(j/3)} ${cell}`;\\n        \\n            if(!seen.has(colCell) && !seen.has(rowCell) && !seen.has(subBoxCell)) {\\n                seen.add(colCell);\\n                seen.add(rowCell);\\n                seen.add(subBoxCell);\\n            }\\n            else \\n                return false;\\n          }\\n      }\\n    }\\n    return true;\\n};\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 124036,
                "title": "readable-javascript-solution-w-comments",
                "content": "Didn\\'t come up with this, but I think I made it a bit more readable.\\n\\nInspired by:\\n1. https://leetcode.com/problems/valid-sudoku/discuss/15527/Simple-JavaScript-One-Pass-Solution \\n2. https://leetcode.com/problems/valid-sudoku/discuss/121921/javascript \\n\\n```\\nvar isValidSudoku = function(board) {\\n  // create an empty set for each row/col/square\\n  const rowRules = new Array(9).fill().map(() => new Set())\\n  const colRules = new Array(9).fill().map(() => new Set())\\n  const mixedRules = new Array(9).fill().map(() => new Set())\\n  \\n  // iterate through each cell on the board\\n  for (let row = 0; row < 9; row++) {\\n    for (let col = 0; col < 9; col++) {\\n      const curr = board[row][col]\\n      \\n      // some tricky math to get the index of the 3x3 squares\\n      const mixedIdx = Math.floor(row / 3) * 3 + Math.floor(col / 3)\\n\\n      if (curr === \".\") continue  // ignore dots\\n      \\n      // if the current number already exists in the set, board is invalid\\n      const a = rowRules[row].has(curr)\\n      const b = colRules[col].has(curr)\\n      const c = mixedRules[mixedIdx].has(curr)\\n      if (a || b || c) return false\\n      \\n      // add the number to the appropriate set\\n      rowRules[row].add(curr)\\n      colRules[col].add(curr)\\n      mixedRules[mixedIdx].add(curr)\\n    }\\n  }\\n  \\n  // all checks out\\n  return true\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isValidSudoku = function(board) {\\n  // create an empty set for each row/col/square\\n  const rowRules = new Array(9).fill().map(() => new Set())\\n  const colRules = new Array(9).fill().map(() => new Set())\\n  const mixedRules = new Array(9).fill().map(() => new Set())\\n  \\n  // iterate through each cell on the board\\n  for (let row = 0; row < 9; row++) {\\n    for (let col = 0; col < 9; col++) {\\n      const curr = board[row][col]\\n      \\n      // some tricky math to get the index of the 3x3 squares\\n      const mixedIdx = Math.floor(row / 3) * 3 + Math.floor(col / 3)\\n\\n      if (curr === \".\") continue  // ignore dots\\n      \\n      // if the current number already exists in the set, board is invalid\\n      const a = rowRules[row].has(curr)\\n      const b = colRules[col].has(curr)\\n      const c = mixedRules[mixedIdx].has(curr)\\n      if (a || b || c) return false\\n      \\n      // add the number to the appropriate set\\n      rowRules[row].add(curr)\\n      colRules[col].add(curr)\\n      mixedRules[mixedIdx].add(curr)\\n    }\\n  }\\n  \\n  // all checks out\\n  return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3194965,
                "title": "python-clean-simple-faster-than-96-in-runtime",
                "content": "To solve this problem we have to check if each value in sudoku does not repeat in its:\\n\\n1. Row\\n1. Column\\n1. Block\\n\\n# Complexity\\n- Time complexity: $$O(n*n)$$ \\n    where n is fiexed here.\\n    so, Time Complexity will be O(81) ==> O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n * n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        rows = [set() for _ in range(9)]\\n        cols = [set() for _ in range(9)]\\n        block = [[set() for _ in range(3)] for _ in range(3)]\\n\\n        for i in range(9):\\n            for j in range(9):\\n                curr = board[i][j]\\n                if curr == \\'.\\':\\n                    continue\\n                if (curr in rows[i]) or (curr in cols[j]) or (curr in block[i // 3][j // 3]):\\n                    return False\\n                rows[i].add(curr)\\n                cols[j].add(curr)\\n                block[i // 3][j // 3].add(curr)\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        rows = [set() for _ in range(9)]\\n        cols = [set() for _ in range(9)]\\n        block = [[set() for _ in range(3)] for _ in range(3)]\\n\\n        for i in range(9):\\n            for j in range(9):\\n                curr = board[i][j]\\n                if curr == \\'.\\':\\n                    continue\\n                if (curr in rows[i]) or (curr in cols[j]) or (curr in block[i // 3][j // 3]):\\n                    return False\\n                rows[i].add(curr)\\n                cols[j].add(curr)\\n                block[i // 3][j // 3].add(curr)\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15617,
                "title": "java-solution-easy-to-understand",
                "content": "    public boolean isValidSudoku(char[][] board) {\\n        boolean[][] col = new boolean[9][9];\\n        boolean[][] row = new boolean[9][9];\\n        boolean[][] block = new boolean[9][9];\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] == '.') {\\n                    continue;\\n                }\\n                int digit = board[i][j] - '1';\\n                int blockId = i / 3 * 3 + j / 3;\\n                if (col[j][digit]) {\\n                    return false;\\n                } else {\\n                    col[j][digit] = true;\\n                }\\n                if (row[i][digit]) {\\n                    return false;\\n                } else {\\n                    row[i][digit] = true;\\n                }\\n                if (block[blockId][digit]) {\\n                    return false;\\n                } else {\\n                    block[blockId][digit] = true;\\n                }\\n            }\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public boolean isValidSudoku(char[][] board) {\\n        boolean[][] col = new boolean[9][9];\\n        boolean[][] row = new boolean[9][9];\\n        boolean[][] block = new boolean[9][9];\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] == '.') {\\n                    continue;\\n                }\\n                int digit = board[i][j] - '1';\\n                int blockId = i / 3 * 3 + j / 3;\\n                if (col[j][digit]) {\\n                    return false;\\n                } else {\\n                    col[j][digit] = true;\\n                }\\n                if (row[i][digit]) {\\n                    return false;\\n                } else {\\n                    row[i][digit] = true;\\n                }\\n                if (block[blockId][digit]) {\\n                    return false;\\n                } else {\\n                    block[blockId][digit] = true;\\n                }\\n            }\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 936699,
                "title": "c-easiest-to-understand-hashset",
                "content": "Sharing my Very Readable C++ Solution:\\n\\n```\\nbool isValidSudoku(vector<vector<char>>& board) {\\n\\tvector<unordered_set<int>> rows(9, unordered_set<int>());\\n\\tvector<unordered_set<int>> columns(9, unordered_set<int>());\\n\\tvector<unordered_set<int>> boxes(9, unordered_set<int>());\\n\\n\\tfor (int i = 0; i < 9; ++i) {\\n\\t  for (int j = 0; j < 9; ++j) {\\n\\t\\tif (board[i][j] == \\'.\\')\\n\\t\\t  continue;\\n\\n\\t\\tint num = board[i][j] - \\'0\\';\\n\\n\\t\\tif (rows[i].count(num))\\n\\t\\t  return false;\\n\\n\\t\\tif (columns[j].count(num))\\n\\t\\t  return false;\\n\\n\\t\\t// This is a straight-forward math formula to locate a box\\n\\t\\t// Out of the 9 boxes\\n\\t\\tint box_index = (i / 3) * 3 + j / 3;\\n\\n\\t\\tif (boxes[box_index].count(num))\\n\\t\\t  return false;\\n\\n\\t\\trows[i].insert(num);\\n\\t\\tcolumns[j].insert(num);\\n\\t\\tboxes[box_index].insert(num);\\n\\t  }\\n\\t}\\n\\n\\treturn true;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nbool isValidSudoku(vector<vector<char>>& board) {\\n\\tvector<unordered_set<int>> rows(9, unordered_set<int>());\\n\\tvector<unordered_set<int>> columns(9, unordered_set<int>());\\n\\tvector<unordered_set<int>> boxes(9, unordered_set<int>());\\n\\n\\tfor (int i = 0; i < 9; ++i) {\\n\\t  for (int j = 0; j < 9; ++j) {\\n\\t\\tif (board[i][j] == \\'.\\')\\n\\t\\t  continue;\\n\\n\\t\\tint num = board[i][j] - \\'0\\';\\n\\n\\t\\tif (rows[i].count(num))\\n\\t\\t  return false;\\n\\n\\t\\tif (columns[j].count(num))\\n\\t\\t  return false;\\n\\n\\t\\t// This is a straight-forward math formula to locate a box\\n\\t\\t// Out of the 9 boxes\\n\\t\\tint box_index = (i / 3) * 3 + j / 3;\\n\\n\\t\\tif (boxes[box_index].count(num))\\n\\t\\t  return false;\\n\\n\\t\\trows[i].insert(num);\\n\\t\\tcolumns[j].insert(num);\\n\\t\\tboxes[box_index].insert(num);\\n\\t  }\\n\\t}\\n\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2134346,
                "title": "c-fast-easy-short-commented-code-8-lines-of-code",
                "content": "# Here we will run two for loops, one for rows and one for columns,\\n# If the element in the board is a number from 1 to 9 then we will check their presence---->\\n* ***IN THAT ROW :***   by using a row checker 2d array\\n* ***IN THE COLUMN :*** by using a column checker 2d array\\n* ***IN THAT BOX :*** by using the formula  **(row/3)3+(col/3)** \\uD83D\\uDE0E\\n\\n```\\nbool isValidSudoku(vector<vector<char>>& board) {\\n        int checkrow[10][10]={0},checkcol[10][10]={0},checkbox[10][10]={0};       //declaring three check arrays with initially zero values.\\n        for(int row=0;row<9;row++){\\n            for(int col=0;col<9;col++){\\n                if(board[row][col]==\\'.\\')continue;         //if not a number we need to skip to the next index.\\n                int num=board[row][col]-\\'0\\';                //as \\'char\\' is given we make it int.\\n                int box=(row/3)*3+(col/3);                 //applying formula\\n                if(checkrow[row][num] || checkcol[num][col] || checkbox[box][num])       //if any of the checker gives true then the number is already present in that row/col/box.\\n                    return false;\\n                checkrow[row][num]=checkcol[num][col]=checkbox[box][num]=true;       //after checking we set the values true\\n            }\\n        }\\n        return true;\\n    }\\n```\\n![image](https://assets.leetcode.com/users/images/d9d71f90-6afb-45c0-8a51-f7af505db1da_1654853094.572027.png)\\n\\n\\uD83D\\uDE0E\\uD83D\\uDE4C HAPPY CODING !! \\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool isValidSudoku(vector<vector<char>>& board) {\\n        int checkrow[10][10]={0},checkcol[10][10]={0},checkbox[10][10]={0};       //declaring three check arrays with initially zero values.\\n        for(int row=0;row<9;row++){\\n            for(int col=0;col<9;col++){\\n                if(board[row][col]==\\'.\\')continue;         //if not a number we need to skip to the next index.\\n                int num=board[row][col]-\\'0\\';                //as \\'char\\' is given we make it int.\\n                int box=(row/3)*3+(col/3);                 //applying formula\\n                if(checkrow[row][num] || checkcol[num][col] || checkbox[box][num])       //if any of the checker gives true then the number is already present in that row/col/box.\\n                    return false;\\n                checkrow[row][num]=checkcol[num][col]=checkbox[box][num]=true;       //after checking we set the values true\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1647166,
                "title": "javascript",
                "content": "```\\nvar isValidSudoku = function(board) {\\n  \\n    const set = new Set()\\n    \\n    \\n    //i rows, j columns\\n    //check valid columns and rows O(9*9)\\n    for(let i = 0; i < board.length; i++){\\n        for(let j = 0; j < board[0].length; j++){\\n            const value = board[i][j]\\n            if(value !== \".\"){\\n                const rowString = `${value} at row ${i}`\\n                const colString = `${value} at col ${j}`\\n                const boxString = `${value} at box ${Math.floor(i/3)}, ${Math.floor(j/3)}`\\n                \\n                if(set.has(rowString) || set.has(colString) || set.has(boxString)){\\n                    return false\\n                }else{\\n                    set.add(rowString)\\n                    set.add(colString)\\n                    set.add(boxString)\\n                }\\n            }\\n        }\\n    }\\n\\n    return true\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isValidSudoku = function(board) {\\n  \\n    const set = new Set()\\n    \\n    \\n    //i rows, j columns\\n    //check valid columns and rows O(9*9)\\n    for(let i = 0; i < board.length; i++){\\n        for(let j = 0; j < board[0].length; j++){\\n            const value = board[i][j]\\n            if(value !== \".\"){\\n                const rowString = `${value} at row ${i}`\\n                const colString = `${value} at col ${j}`\\n                const boxString = `${value} at box ${Math.floor(i/3)}, ${Math.floor(j/3)}`\\n                \\n                if(set.has(rowString) || set.has(colString) || set.has(boxString)){\\n                    return false\\n                }else{\\n                    set.add(rowString)\\n                    set.add(colString)\\n                    set.add(boxString)\\n                }\\n            }\\n        }\\n    }\\n\\n    return true\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 15660,
                "title": "share-my-solution-for-valid-sudoku",
                "content": "    public static boolean isValidSudoku(char[][] board) {\\n\\t\\tboolean[][] row = new boolean[9][9];\\n\\t\\tboolean[][] col = new boolean[9][9];\\n\\t\\tboolean[][] box = new boolean[9][9];\\n\\n\\t\\tfor (int i = 0; i < 9; i++) {\\n\\t\\t\\tfor (int j = 0; j < 9; j++) {\\n\\t\\t\\t\\tchar c = board[i][j];\\n\\t\\t\\t\\tif (c == '.')\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\tif (c < '0' || c > '9')\\n\\t\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\t\\tint number = c - '1';\\n\\t\\t\\t\\tif (row[i][number] || col[j][number] || box[(i / 3) * 3 + j / 3][number])\\n\\t\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\t\\trow[i][number] = true;\\n\\t\\t\\t\\tcol[j][number] = true;\\n\\t\\t\\t\\tbox[(i / 3) * 3 + j / 3][number] = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}",
                "solutionTags": [],
                "code": "    public static boolean isValidSudoku(char[][] board) {\\n\\t\\tboolean[][] row = new boolean[9][9];\\n\\t\\tboolean[][] col = new boolean[9][9];\\n\\t\\tboolean[][] box = new boolean[9][9];\\n\\n\\t\\tfor (int i = 0; i < 9; i++) {\\n\\t\\t\\tfor (int j = 0; j < 9; j++) {\\n\\t\\t\\t\\tchar c = board[i][j];\\n\\t\\t\\t\\tif (c == '.')\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\tif (c < '0' || c > '9')\\n\\t\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\t\\tint number = c - '1';\\n\\t\\t\\t\\tif (row[i][number] || col[j][number] || box[(i / 3) * 3 + j / 3][number])\\n\\t\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\t\\trow[i][number] = true;\\n\\t\\t\\t\\tcol[j][number] = true;\\n\\t\\t\\t\\tbox[(i / 3) * 3 + j / 3][number] = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2730348,
                "title": "java-hashset-easy",
                "content": "## Don\\'t forget to upvote if you like my solution \\uD83D\\uDE07\\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        Set<String> set = new HashSet<>();\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                char n = board[i][j];\\n                if (n != \\'.\\') {\\n                    if (set.contains(n + \"r\" + i) || set.contains(n + \"c\" + j) ||\\n                        set.contains(n + \"b\" + i / 3 + j / 3)) {\\n                        return false;\\n                    }\\n                    set.add(n + \"r\" + i);\\n                    set.add(n + \"c\" + j);\\n                    set.add(n + \"b\" + i / 3 + j / 3);\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\n**The same thing can be done in a shorter way:**\\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        Set<String> set = new HashSet<>();\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                char n = board[i][j];\\n                if (n != \\'.\\') {\\n                    if (!set.add(n + \"r\" + i) || \\n                        !set.add(n + \"c\" + j) ||\\n                        !set.add(n + \"b\" + i / 3 + j / 3)) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n// TC: O(9 ^ 2) => O(1)\\n// SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        Set<String> set = new HashSet<>();\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                char n = board[i][j];\\n                if (n != \\'.\\') {\\n                    if (set.contains(n + \"r\" + i) || set.contains(n + \"c\" + j) ||\\n                        set.contains(n + \"b\" + i / 3 + j / 3)) {\\n                        return false;\\n                    }\\n                    set.add(n + \"r\" + i);\\n                    set.add(n + \"c\" + j);\\n                    set.add(n + \"b\" + i / 3 + j / 3);\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        Set<String> set = new HashSet<>();\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                char n = board[i][j];\\n                if (n != \\'.\\') {\\n                    if (!set.add(n + \"r\" + i) || \\n                        !set.add(n + \"c\" + j) ||\\n                        !set.add(n + \"b\" + i / 3 + j / 3)) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n// TC: O(9 ^ 2) => O(1)\\n// SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1251171,
                "title": "c-explained-24ms-o-n2",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // To check if it is valid,\\n    // Firstly, replace the character with a \\'.\\' so that we can check even after this it is already present or not .. \\n    //  - Check for the entire row if it already has the same character twice? Return false if it does\\n    //  - Check for the entire col if it already has the same character twice? Return false if it does\\n    //  - Check for the 3x3 box to see it already has it? Return false if it does\\n    // Replace the incorrect \\'.\\' back to the character c\\n    \\n    // NOTE: Given a row, col, if we need to find the starting i,j of that 3x3 box, then we do row/3*3 and col/3*3\\n    \\n    bool isValid(vector<vector<char>>& board, int row, int col){\\n        int c = board[row][col];\\n        board[row][col] = \\'.\\';\\n        for(int i=0;i<9;i++)\\n            if(board[row][i] == c) return false;\\n        for(int i=0;i<9;i++)\\n            if(board[i][col] == c) return false;\\n        for(int i=0;i<3;i++)\\n            for(int j=0;j<3;j++)\\n                if(board[row/3*3 + i][col/3*3 + j] == c)\\n                    return false;\\n        \\n        board[row][col] = c;\\n        return true;\\n    }\\n    \\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        \\n        // Go for all the rows & columns looking for an invalid number\\n        // If you find an invalid entry, return false\\n        // If you don not find an invalid entry till the end, it has to be good, return true.\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\' && !isValid(board,i,j)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // To check if it is valid,\\n    // Firstly, replace the character with a \\'.\\' so that we can check even after this it is already present or not .. \\n    //  - Check for the entire row if it already has the same character twice? Return false if it does\\n    //  - Check for the entire col if it already has the same character twice? Return false if it does\\n    //  - Check for the 3x3 box to see it already has it? Return false if it does\\n    // Replace the incorrect \\'.\\' back to the character c\\n    \\n    // NOTE: Given a row, col, if we need to find the starting i,j of that 3x3 box, then we do row/3*3 and col/3*3\\n    \\n    bool isValid(vector<vector<char>>& board, int row, int col){\\n        int c = board[row][col];\\n        board[row][col] = \\'.\\';\\n        for(int i=0;i<9;i++)\\n            if(board[row][i] == c) return false;\\n        for(int i=0;i<9;i++)\\n            if(board[i][col] == c) return false;\\n        for(int i=0;i<3;i++)\\n            for(int j=0;j<3;j++)\\n                if(board[row/3*3 + i][col/3*3 + j] == c)\\n                    return false;\\n        \\n        board[row][col] = c;\\n        return true;\\n    }\\n    \\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        \\n        // Go for all the rows & columns looking for an invalid number\\n        // If you find an invalid entry, return false\\n        // If you don not find an invalid entry till the end, it has to be good, return true.\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\' && !isValid(board,i,j)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1266986,
                "title": "c-solution-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        unordered_map<string,int>hash;\\n        for(int row=0;row<9;row++){\\n            for(int col=0;col<9;col++){\\n                if(board[row][col] != \\'.\\')\\n                {\\n    \\n                    string r= \"row\"+to_string(row)+to_string(board[row][col]);\\n                    string c= \"col\"+to_string(col)+to_string(board[row][col]);\\n                    int b = (row/3) * 3 + (col/3);\\n                    string box= \"box\"+ to_string(b) + to_string(board[row][col]);\\n\\n                    if(hash[r] != 1 && hash[c] != 1 && hash[box] != 1){\\n                        hash[r]=1;\\n                        hash[c]=1;\\n                        hash[box]=1;\\n                    }else{\\n                        return false;\\n                    }\\n\\n                    }\\n                \\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        unordered_map<string,int>hash;\\n        for(int row=0;row<9;row++){\\n            for(int col=0;col<9;col++){\\n                if(board[row][col] != \\'.\\')\\n                {\\n    \\n                    string r= \"row\"+to_string(row)+to_string(board[row][col]);\\n                    string c= \"col\"+to_string(col)+to_string(board[row][col]);\\n                    int b = (row/3) * 3 + (col/3);\\n                    string box= \"box\"+ to_string(b) + to_string(board[row][col]);\\n\\n                    if(hash[r] != 1 && hash[c] != 1 && hash[box] != 1){\\n                        hash[r]=1;\\n                        hash[c]=1;\\n                        hash[box]=1;\\n                    }else{\\n                        return false;\\n                    }\\n\\n                    }\\n                \\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15613,
                "title": "share-my-java-solution",
                "content": "    public class Solution {\\n    public Set<Character> set=new HashSet<Character>();\\n    public boolean isValidSudoku(char[][] board) {\\n       for(int i=0;i<9;i++){\\n           if(validPartial(board,i,i,0,8)==false) return false;\\n           if(validPartial(board,0,8,i,i)==false) return false;\\n       } \\n       for(int i=0;i<9;i+=3){\\n           for(int j=0;j<9;j+=3){\\n               if(validPartial(board,i,i+2,j,j+2)==false) return false;\\n           }\\n       }\\n       return true;\\n    }\\n    public boolean validPartial(char[][] board,int row1,int row2,int col1,int col2){\\n        set.clear();\\n        for(int i=row1;i<=row2;i++){\\n            for(int j=col1;j<=col2;j++){\\n                if(board[i][j]!='.') {\\n                    if(!set.add(board[i][j])) return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public Set<Character> set=new HashSet<Character>();\\n    public boolean isValidSudoku(char[][] board) {\\n       for(int i=0;i<9;i++){\\n           if(validPartial(board,i,i,0,8)==false) return false;\\n           if(validPartial(board,0,8,i,i)==false) return false;\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 2291325,
                "title": "java-best-solution-to-ever-exist",
                "content": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n      HashSet<String> map = new HashSet<>();\\n      for(int i = 0; i < 9; i ++) {\\n        for(int j = 0; j < 9; j ++) {\\n          if(board[i][j] != \\'.\\') {\\n            char number = board[i][j];\\n            if(!map.add(number + \"in row\" + i) \\n               || !map.add(number + \"in column\" + j) \\n               || !map.add(number + \"in block\" + i / 3 + \"-\" + j / 3))\\n              return false;\\n          }\\n        }\\n      }\\n      return true;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF YOU LIKED IT",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n      HashSet<String> map = new HashSet<>();\\n      for(int i = 0; i < 9; i ++) {\\n        for(int j = 0; j < 9; j ++) {\\n          if(board[i][j] != \\'.\\') {\\n            char number = board[i][j];\\n            if(!map.add(number + \"in row\" + i) \\n               || !map.add(number + \"in column\" + j) \\n               || !map.add(number + \"in block\" + i / 3 + \"-\" + j / 3))\\n              return false;\\n          }\\n        }\\n      }\\n      return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 916780,
                "title": "javascript-simple-and-fast-solution-with-comments-easy-to-remember",
                "content": "```javascript\\nvar isValidSudoku = function(board) {\\n\\n    const map = {};                            // Map for storing our key-strings.\\n    \\n    for (let i = 0; i < 9; i++) {              // Outer-loop for rows.\\n        for (let j = 0; j < 9; j++) {          // Inner-loop for cols.\\n            \\n            if (board[i][j] === \\'.\\') continue; // Skip checking empty spaces.\\n            \\n            let num = board[i][j],\\n                x   = Math.floor(i / 3),       // We can iterate through each box\\n                y   = Math.floor(j / 3);       // using indices (i, j) divided by 3.\\n                \\n\\t\\t\\tlet err = (map[\\'r\\'+i+num] ||       // Check if any of the computed\\n\\t\\t\\t\\t\\t   map[\\'c\\'+j+num] ||       // key-strings already exist in\\n\\t\\t\\t\\t\\t   map[\\'b\\'+x+y+num]);      // our map object.\\n            \\n            if (err) return false;             // If \\'err\\' is true, board is invalid.\\n            \\n            map[\\'r\\'+i+num]   = 1;              // Add \\'row\\' key-string to map.\\n            map[\\'c\\'+j+num]   = 1;              // Add \\'col\\' key-string to map.\\n            map[\\'b\\'+x+y+num] = 1;              // Add \\'box\\' key-string to map.\\n        }\\n    }\\n    \\n    return true;                               // If no error, board is valid.\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar isValidSudoku = function(board) {\\n\\n    const map = {};                            // Map for storing our key-strings.\\n    \\n    for (let i = 0; i < 9; i++) {              // Outer-loop for rows.\\n        for (let j = 0; j < 9; j++) {          // Inner-loop for cols.\\n            \\n            if (board[i][j] === \\'.\\') continue; // Skip checking empty spaces.\\n            \\n            let num = board[i][j],\\n                x   = Math.floor(i / 3),       // We can iterate through each box\\n                y   = Math.floor(j / 3);       // using indices (i, j) divided by 3.\\n                \\n\\t\\t\\tlet err = (map[\\'r\\'+i+num] ||       // Check if any of the computed\\n\\t\\t\\t\\t\\t   map[\\'c\\'+j+num] ||       // key-strings already exist in\\n\\t\\t\\t\\t\\t   map[\\'b\\'+x+y+num]);      // our map object.\\n            \\n            if (err) return false;             // If \\'err\\' is true, board is invalid.\\n            \\n            map[\\'r\\'+i+num]   = 1;              // Add \\'row\\' key-string to map.\\n            map[\\'c\\'+j+num]   = 1;              // Add \\'col\\' key-string to map.\\n            map[\\'b\\'+x+y+num] = 1;              // Add \\'box\\' key-string to map.\\n        }\\n    }\\n    \\n    return true;                               // If no error, board is valid.\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 427130,
                "title": "very-clear-js-solution-memory-100-time-95",
                "content": "```\\nvar isValidSudoku = function(board) {\\n  let rows = new Set();\\n  let cols = new Set();\\n  let boxes = new Set();\\n  let curRowElem;\\n  let curColElem;\\n  let curBoxElem;\\n\\n  for (let i = 0; i < board.length; i += 1) {\\n    for (let j = 0; j < board[0].length; j += 1) {\\n      curRowElem = board[i][j]\\n      curColElem = board[j][i]\\n      curBoxElem = board[3 * Math.floor(i / 3) + Math.floor(j / 3)][((i * 3) % 9) + (j % 3)]\\n\\n      if (rows.has(curRowElem)) return false;\\n      if (curRowElem !== \".\") rows.add(curRowElem);\\n\\n      if (cols.has(curColElem)) return false;\\n      if (curColElem !== \".\") cols.add(curColElem);\\n\\n      if (boxes.has(curBoxElem)) return false;\\n      if (curBoxElem !== \".\") boxes.add(curBoxElem);\\n    }\\n\\n    rows.clear()\\n    cols.clear()\\n    boxes.clear()\\n  }\\n\\n  return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isValidSudoku = function(board) {\\n  let rows = new Set();\\n  let cols = new Set();\\n  let boxes = new Set();\\n  let curRowElem;\\n  let curColElem;\\n  let curBoxElem;\\n\\n  for (let i = 0; i < board.length; i += 1) {\\n    for (let j = 0; j < board[0].length; j += 1) {\\n      curRowElem = board[i][j]\\n      curColElem = board[j][i]\\n      curBoxElem = board[3 * Math.floor(i / 3) + Math.floor(j / 3)][((i * 3) % 9) + (j % 3)]\\n\\n      if (rows.has(curRowElem)) return false;\\n      if (curRowElem !== \".\") rows.add(curRowElem);\\n\\n      if (cols.has(curColElem)) return false;\\n      if (curColElem !== \".\") cols.add(curColElem);\\n\\n      if (boxes.has(curBoxElem)) return false;\\n      if (curBoxElem !== \".\") boxes.add(curBoxElem);\\n    }\\n\\n    rows.clear()\\n    cols.clear()\\n    boxes.clear()\\n  }\\n\\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 729690,
                "title": "swift-easy-solution-using-hashset",
                "content": "```\\nfinal class Solution {\\n    func isValidSudoku(_ board: [[Character]]) -> Bool {\\n        var seen = Set<String>()\\n        for i in 0..<9 {\\n            for j in 0..<9 {\\n                let currVal = board[i][j]\\n                if currVal == \".\" {\\n                    continue\\n                }\\n                let row = \"\\\\(currVal) found in row \\\\(i)\"\\n                let col = \"\\\\(currVal) found in col \\\\(j)\"\\n                let box = \"\\\\(currVal) found in box \\\\((i/3)) - \\\\((j/3))\"\\n                if seen.contains(row) {\\n                    return false\\n                } else {\\n                    seen.insert(row)\\n                }\\n                if seen.contains(col) {\\n                    return false\\n                } else {\\n                    seen.insert(col)\\n                }\\n                if seen.contains(box) {\\n                    return false\\n                } else {\\n                    seen.insert(box)\\n                }\\n            }\\n        }\\n        return true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfinal class Solution {\\n    func isValidSudoku(_ board: [[Character]]) -> Bool {\\n        var seen = Set<String>()\\n        for i in 0..<9 {\\n            for j in 0..<9 {\\n                let currVal = board[i][j]\\n                if currVal == \".\" {\\n                    continue\\n                }\\n                let row = \"\\\\(currVal) found in row \\\\(i)\"\\n                let col = \"\\\\(currVal) found in col \\\\(j)\"\\n                let box = \"\\\\(currVal) found in box \\\\((i/3)) - \\\\((j/3))\"\\n                if seen.contains(row) {\\n                    return false\\n                } else {\\n                    seen.insert(row)\\n                }\\n                if seen.contains(col) {\\n                    return false\\n                } else {\\n                    seen.insert(col)\\n                }\\n                if seen.contains(box) {\\n                    return false\\n                } else {\\n                    seen.insert(box)\\n                }\\n            }\\n        }\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15469,
                "title": "11-lines-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        vector<unordered_map<char, int>>row(n);\\n        vector<unordered_map<char, int>>col(n);\\n        vector<vector<unordered_map<char, int>>>sub(n/3, vector<unordered_map<char, int>>(n/3));\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < n; j++){\\n                char c = board[i][j];\\n                if(c == '.') continue;\\n                if(row[i][c]++ > 0 || col[j][c]++ > 0 || sub[i/3][j/3][c]++ > 0) return false;\\n            }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        vector<unordered_map<char, int>>row(n);\\n        vector<unordered_map<char, int>>col(n);\\n        vector<vector<unordered_map<char, int>>>sub(n/3, vector<unordered_map<char, int>>(n/3));\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < n; j++){\\n                char c = board[i][j];\\n                if(c == '.') continue;\\n                if(row[i][c]++ > 0 || col[j][c]++ > 0 || sub[i/3][j/3][c]++ > 0) return false;\\n            }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1430239,
                "title": "java-easy-solution",
                "content": "class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        Set<String> check = new HashSet<>();\\n        \\n        for(int i = 0; i < 9; i++){\\n            for(int j = 0; j < 9; j++){\\n                \\n                if(board[i][j] != \\'.\\'){\\n                    \\n                    // Making a unique key for every element\\n                    String row = board[i][j] + \"in row\" + i;\\n                    String col = board[i][j] + \"in col\" + j;\\n                    String box = board[i][j] + \"in box\" + i/3 + \"and\" + j/3;\\n                    \\n                    if(check.contains(row) || check.contains(col) || check.contains(box)){\\n                        return false;\\n                    }\\n                    \\n                    check.add(row);\\n                    check.add(col);\\n                    check.add(box);\\n                }\\n            }\\n        }\\n        \\n        return true;\\n        \\n    }\\n}\\n\\n\\n**Upvote if you find it easy to understand :)**",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        Set<String> check = new HashSet<>();\\n        \\n        for(int i = 0; i < 9; i++){\\n            for(int j = 0; j < 9; j++){\\n                \\n                if(board[i][j] != \\'.\\'){\\n                    \\n                    // Making a unique key for every element\\n                    String row = board[i][j] + \"in row\" + i;\\n                    String col = board[i][j] + \"in col\" + j;\\n                    String box = board[i][j] + \"in box\" + i/3 + \"and\" + j/3;\\n                    \\n                    if(check.contains(row) || check.contains(col) || check.contains(box)){\\n                        return false;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1206509,
                "title": "python3-no-need-explanation-solution-15-lines",
                "content": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        row_bag = defaultdict(set)\\n        col_bag = defaultdict(set)\\n        sec_bag = defaultdict(set)\\n        \\n        for i in range(9):\\n            for j in range(9):\\n                num = board[i][j]\\n\\n                if not num.isdigit():\\n                    continue\\n\\n                sec = (i // 3, j // 3)\\n                if num in row_bag[i] or num in col_bag[j] or num in sec_bag[sec]:\\n                    return False\\n                else:\\n                    row_bag[i].add(num)\\n                    col_bag[j].add(num)\\n                    sec_bag[sec].add(num)\\n        return True\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        row_bag = defaultdict(set)\\n        col_bag = defaultdict(set)\\n        sec_bag = defaultdict(set)\\n        \\n        for i in range(9):\\n            for j in range(9):\\n                num = board[i][j]\\n\\n                if not num.isdigit():\\n                    continue\\n\\n                sec = (i // 3, j // 3)\\n                if num in row_bag[i] or num in col_bag[j] or num in sec_bag[sec]:\\n                    return False\\n                else:\\n                    row_bag[i].add(num)\\n                    col_bag[j].add(num)\\n                    sec_bag[sec].add(num)\\n        return True\\n",
                "codeTag": "Java"
            },
            {
                "id": 15578,
                "title": "fast-and-clean-java-solution",
                "content": "       public boolean isValidSudoku(char[][] board) {\\n            //first dimension 0/horizontal 1/vertical 2/square\\n            //second dimension 0-8 represents the ith row/column/square\\n            //third dimension represents the occurrence of number 1-9\\n            boolean[][][] occur = new boolean[3][9][9];\\n            for (int i = 0; i < 9; i++){\\n                for (int j = 0; j < 9; j++){\\n                    if (board[i][j] == '.') continue;\\n                    int num = board[i][j] - '1';\\n                    if (occur[0][i][num]) return false;\\n                    else occur[0][i][num] = true;\\n                    if (occur[1][j][num]) return false;\\n                    else occur[1][j][num] = true;\\n                    int s = (i / 3) * 3 + j / 3;\\n                    if (occur[2][s][num]) return false;\\n                    else occur[2][s][num] = true;\\n                }\\n            }\\n            return true;\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "       public boolean isValidSudoku(char[][] board) {\\n            //first dimension 0/horizontal 1/vertical 2/square\\n            //second dimension 0-8 represents the ith row/column/square\\n            //third dimension represents the occurrence of number 1-9\\n            boolean[][][] occur = new boolean[3][9][9];\\n            for (int i = 0; i < 9; i++){\\n                for (int j = 0; j < 9; j++){\\n                    if (board[i][j] == '.') continue;\\n                    int num = board[i][j] - '1';\\n                    if (occur[0][i][num]) return false;\\n                    else occur[0][i][num] = true;\\n                    if (occur[1][j][num]) return false;\\n                    else occur[1][j][num] = true;\\n                    int s = (i / 3) * 3 + j / 3;\\n                    if (occur[2][s][num]) return false;\\n                    else occur[2][s][num] = true;\\n                }\\n            }\\n            return true;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3689261,
                "title": "very-easy-to-understand-time-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Very first approach in my mind** : Iterate through begining and create vector of vector of size 9 and keep checking for duplicates .\\nthis approach will also accpeted due to small size of problem .\\nTime complaxity O(n^3) // we check every index 3 times .\\nSpace complexiyt O(n^2)  // we create vector of vector.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe create set of pair of integer and char. And iterate through each index and check for row,col and grid , If yes they are there than we return false. Because the integer part denote the Row number abd character part denote the value at that respective row .If any pair will be same means the same value is presemt in same row .\\nSame for col and grid .\\n\\ngrid means the division of 3*3 sections,which we give the numbering from 0-9. we can calculate it through the given row and column number .\\n\\n---\\n\\n000 111 222  \\n000 111 222\\n000 111 222        \\n333 444 555\\n333 444 555\\n333 444 555\\n666 777 888\\n666 777 888\\n666 777 888\\n\\n---\\n\\nThis is our grid number and we can simply calculate it as we iterater following **:::::::** (0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(1,0)..... so on.\\nso our grid will will be such that ---> Divide the row by 3 **(gives the row no and divide by 3 gives the grid )**  than multiply by 3 **(represent that one row has the vlaue of 3 grid)** than add in it the vlaue of col/3;\\n\\n**you can give your view also to make better understanding**\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) \"where n is the size of box\" \\n as we iterate onces at every index \\n\\n//give your view also ,your view is very helpful for me \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n) we create set of pair\\n\\n//give your view also ,your view is very helpful for me \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        set<pair<int,char>> row,col,grid;\\n\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\'){\\n                int count=(i/3)*3 +j/3;\\n                \\n                if(row.find({i,board[i][j]})==row.end())\\n                    row.insert({{i,board[i][j]}});\\n                 else return false;\\n\\n                if(col.find({j,board[i][j]})==col.end())\\n                    col.insert({{j,board[i][j]}});\\n                 else return false;\\n\\n                if(grid.find({count,board[i][j]})==grid.end())\\n                    grid.insert({{count,board[i][j]}});\\n                 else  return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        set<pair<int,char>> row,col,grid;\\n\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\'){\\n                int count=(i/3)*3 +j/3;\\n                \\n                if(row.find({i,board[i][j]})==row.end())\\n                    row.insert({{i,board[i][j]}});\\n                 else return false;\\n\\n                if(col.find({j,board[i][j]})==col.end())\\n                    col.insert({{j,board[i][j]}});\\n                 else return false;\\n\\n                if(grid.find({count,board[i][j]})==grid.end())\\n                    grid.insert({{count,board[i][j]}});\\n                 else  return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1415177,
                "title": "c-simple-and-easy-10-short-line-solution",
                "content": "For each row, column and block we keep a set of numbers.\\nIf we find a number that was seen already in that row, column or block - return false.\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        vector<set<int>> rows(9), cols(9), blocks(9);\\n        \\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                \\n                if (board[i][j] == \\'.\\') continue;\\n                \\n                int curr = board[i][j] - \\'0\\';\\n                if (rows[i].count(curr) || cols[j].count(curr) || blocks[(i/3)*3+j/3].count(curr)) \\n                    return false;\\n                \\n                rows[i].insert(curr);\\n                cols[j].insert(curr);\\n                blocks[(i/3)*3+j/3].insert(curr);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        vector<set<int>> rows(9), cols(9), blocks(9);\\n        \\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                \\n                if (board[i][j] == \\'.\\') continue;\\n                \\n                int curr = board[i][j] - \\'0\\';\\n                if (rows[i].count(curr) || cols[j].count(curr) || blocks[(i/3)*3+j/3].count(curr)) \\n                    return false;\\n                \\n                rows[i].insert(curr);\\n                cols[j].insert(curr);\\n                blocks[(i/3)*3+j/3].insert(curr);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1414924,
                "title": "python-check-27-conditions-explained",
                "content": "We just need to check all `27` conditions - for every row, every column and every square.\\n\\n1. First `3` lines of code to check rows and columns: we check each row in `board` and in transposed board `*board` and collect all elements which are not equal to `.`\\n2. Next `4` lines of code to check all `9` cells: first we create all centers of `3x3` cells and then again collect all elements, not equal to `.`\\n\\n#### Complexity\\nTime complexity is `O(n^2)`, where `n` is size of board, space complexity is `O(n)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def isValidSudoku(self, board):\\n        for row in chain(board, zip(*board)):\\n            cand = [i for i in row if i != \".\"]\\n            if len(set(cand)) != len(cand): return False\\n            \\n        for x, y in product([1,4,7],[1,4,7]):\\n            cand = [board[x+i][y+j] for i,j in product([-1,0,1],[-1,0,1])]\\n            cand = [i for i in cand if i != \".\"]\\n            if len(set(cand)) != len(cand): return False\\n        \\n        return True\\n```\\n\\nf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Math"
                ],
                "code": "```python\\nclass Solution:\\n    def isValidSudoku(self, board):\\n        for row in chain(board, zip(*board)):\\n            cand = [i for i in row if i != \".\"]\\n            if len(set(cand)) != len(cand): return False\\n            \\n        for x, y in product([1,4,7],[1,4,7]):\\n            cand = [board[x+i][y+j] for i,j in product([-1,0,1],[-1,0,1])]\\n            cand = [i for i in cand if i != \".\"]\\n            if len(set(cand)) != len(cand): return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15662,
                "title": "java-solution-using-array-of-hashset",
                "content": "\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet[] row = new HashSet[9];\\n        HashSet[] col = new HashSet[9];\\n        HashSet[] cell = new HashSet[9];\\n        for (int i = 0; i < 9; i++) {\\n            row[i] = new HashSet<Character>();\\n            col[i] = new HashSet<Character>();\\n            cell[i] = new HashSet<Character>();\\n        }\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] != '.') {\\n                    if (row[i].contains(board[i][j]) || col[j].contains(board[i][j]) || cell[3*(i/3)+j/3].contains(board[i][j])) {\\n                        return false;\\n                    } else {\\n                        row[i].add(board[i][j]);\\n                        col[j].add(board[i][j]);\\n                        cell[3*(i/3)+j/3].add(board[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet[] row = new HashSet[9];\\n        HashSet[] col = new HashSet[9];\\n        HashSet[] cell = new HashSet[9];\\n        for (int i = 0; i < 9; i++) {\\n            row[i] = new HashSet<Character>();\\n            col[i] = new HashSet<Character>();\\n            cell[i] = new HashSet<Character>();\\n        }\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] != '.') {\\n                    if (row[i].contains(board[i][j]) || col[j].contains(board[i][j]) || cell[3*(i/3)+j/3].contains(board[i][j])) {\\n                        return false;\\n                    } else {\\n                        row[i].add(board[i][j]);\\n                        col[j].add(board[i][j]);\\n                        cell[3*(i/3)+j/3].add(board[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3471217,
                "title": "solution-with-explanatory",
                "content": "# Intuition\\nWe will go through 3 steps to check the correctness of the sudoku.\\n1-By checking each line, we will see if there are any numbers that are the same as each other.\\n2-We will check every 3x3 square to see if there are any numbers that are the same.\\n3- By checking each column, we will see if there are any numbers that are the same.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1- We will sort each row in order and check if it is a consecutive number.\\n\\n2-We will check with for loops for every3x3 block. While the first 2 for loops will travel through the squares in order, the next 2 for loops will travel inside the squares and each number inside the squares will be assigned to the vector we call control. Then, the elements in the vector will be sorted and it will be checked whether they are consecutive numbers.\\n\\n3- A for loop will return every column. The other for loop will through the columns and assign the elements inside each column to the control2 vector. We will perform a sequential number comparison by sorting the assigned elements.\\n\\nif consecutive number detection occurs at these stages, the function return false. Function return true if sudoku doesn\\'t get stuck in controls\\n<!-- Describe your approach to solving the problem. -->\\n\\n# extra\\nIf you get stuck on the solution, I can help you in the comments.\\n\\nI spend a lot of effort deciphering the codes, if you found the solution useful, you can support me by upvoting.Thanks.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n    \\t\\n\\n//      1-Rows--------------------\\n\\n    \\tfor(int t=0; t<9; t++){\\n    \\t\\tvector<char> vv = board[t];\\n    \\t    std::sort(vv.begin(), vv.end());\\n    \\t    for(int a=0; a<8; a++){\\n    \\t        if(vv[a] == vv[a+1] && vv[a] != \\'.\\'){\\n    \\t        \\treturn false;\\n    \\t        }\\n    \\t    }\\n    \\t}\\n//      2-3x3 Squares-------------\\n\\n    \\tfor(int i=0; i<9; i+=3) { \\n\\t        for(int j=0; j<9; j+=3) {\\n\\t            vector<char> control;\\n\\t            for(int k=0; k<3; k++) {\\n\\t                for(int l=0; l<3; l++) {\\n\\t                    control.push_back(board[i+k][j+l]);\\n\\t                }\\n\\t            }\\n\\t            sort(control.begin(), control.end()); \\n\\t            for(int k=1; k<control.size(); k++) {\\n\\t                if(control[k] == control[k-1] && control[k] != \\'.\\') {\\n\\t                    return false; \\n\\t                }\\n\\t            }\\n\\t        }\\n    \\t}\\n    \\t\\n\\n//      3-Columns------------------\\n\\n    \\tfor(int j=0; j<9; j++) { \\n\\t        vector<char> control2;\\n\\t        for(int i=0; i<9; i++) {\\n\\t            control2.push_back(board[i][j]);\\n\\t        }\\n\\t        sort(control2.begin(), control2.end()); \\n\\t        for(int k=1; k<control2.size(); k++) {\\n\\t            if(control2[k] == control2[k-1] && control2[k] != \\'.\\') {\\n\\t                return false; \\n\\t            }\\n\\t        }\\n    \\t}\\n    \\t\\n    \\treturn true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n    \\t\\n\\n//      1-Rows--------------------\\n\\n    \\tfor(int t=0; t<9; t++){\\n    \\t\\tvector<char> vv = board[t];\\n    \\t    std::sort(vv.begin(), vv.end());\\n    \\t    for(int a=0; a<8; a++){\\n    \\t        if(vv[a] == vv[a+1] && vv[a] != \\'.\\'){\\n    \\t        \\treturn false;\\n    \\t        }\\n    \\t    }\\n    \\t}\\n//      2-3x3 Squares-------------\\n\\n    \\tfor(int i=0; i<9; i+=3) { \\n\\t        for(int j=0; j<9; j+=3) {\\n\\t            vector<char> control;\\n\\t            for(int k=0; k<3; k++) {\\n\\t                for(int l=0; l<3; l++) {\\n\\t                    control.push_back(board[i+k][j+l]);\\n\\t                }\\n\\t            }\\n\\t            sort(control.begin(), control.end()); \\n\\t            for(int k=1; k<control.size(); k++) {\\n\\t                if(control[k] == control[k-1] && control[k] != \\'.\\') {\\n\\t                    return false; \\n\\t                }\\n\\t            }\\n\\t        }\\n    \\t}\\n    \\t\\n\\n//      3-Columns------------------\\n\\n    \\tfor(int j=0; j<9; j++) { \\n\\t        vector<char> control2;\\n\\t        for(int i=0; i<9; i++) {\\n\\t            control2.push_back(board[i][j]);\\n\\t        }\\n\\t        sort(control2.begin(), control2.end()); \\n\\t        for(int k=1; k<control2.size(); k++) {\\n\\t            if(control2[k] == control2[k-1] && control2[k] != \\'.\\') {\\n\\t                return false; \\n\\t            }\\n\\t        }\\n    \\t}\\n    \\t\\n    \\treturn true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1414952,
                "title": "python-super-easy-set-validation",
                "content": "**Idea**\\n* First create function `valid` to check duplicates \\n* Then simply check Validation **row wise**, **Column wise** and **Block wise** \\n* if either of them found not valid return **false**    and if all of them passed validation then simply return **true**\\n\\n**Complexity**\\n* Time Complexity :- `O(n^2)` i.e `O(81)`\\n* Space Complexity :- `O(n)` i.e. `O(9)` , because of `seen`, `col` and `block`\\n\\n**Block creation**\\ni/j \\xA0   0..2 3..5 6..8\\n0..2 \\xA0B1  \\xA0B2 \\xA0 B3\\n3..5 \\xA0B4  \\xA0B5  \\xA0B6\\n6..8 \\xA0B7 \\xA0 B8 \\xA0 B9\\n\\n**B1** and **B6** can be represented as \\n```\\nB1 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0  B6\\n00 01 02 \\xA0 \\xA0 \\xA0 \\xA036 37 38\\n10 11 12 \\xA0 \\xA0 \\xA0 \\xA046 47 48\\n20 21 22 \\xA0 \\xA0 \\xA0 \\xA056 57 58\\n```\\n\\n**code** \\xA0 \\xA0 \\xA0 \\xA0\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        #checking if 1D array valid\\n        def valid(arr):\\n            seen = set()\\n            for val in arr:\\n                if val == \\'.\\':\\n                    continue\\n                if val in seen:\\n                    return False\\n                seen.add(val)\\n            return True\\n        \\n        #Row wise\\n        for row in board:\\n            if not valid(row):\\n                return False\\n        \\n        #column wise\\n        for j in range(9):\\n            col = [board[i][j] for i in range(9)]\\n            if not valid(col):\\n                return False\\n       \\n        #Block wise\\n        for i in range(0, 9, 3):\\n            for j in range(0, 9, 3):\\n                block = [board[k][l] for k in range(i, i+3) for l in range(j, j+3)]\\n                if not valid(block):\\n                    return False\\n \\xA0 \\xA0 \\xA0 \\xA0return True\\n```\\n\\n*Please upvote if you like the solution and comment if have queries*. \\xA0 \\xA0 \\xA0",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nB1 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0  B6\\n00 01 02 \\xA0 \\xA0 \\xA0 \\xA036 37 38\\n10 11 12 \\xA0 \\xA0 \\xA0 \\xA046 47 48\\n20 21 22 \\xA0 \\xA0 \\xA0 \\xA056 57 58\\n```\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        #checking if 1D array valid\\n        def valid(arr):\\n            seen = set()\\n            for val in arr:\\n                if val == \\'.\\':\\n                    continue\\n                if val in seen:\\n                    return False\\n                seen.add(val)\\n            return True\\n        \\n        #Row wise\\n        for row in board:\\n            if not valid(row):\\n                return False\\n        \\n        #column wise\\n        for j in range(9):\\n            col = [board[i][j] for i in range(9)]\\n            if not valid(col):\\n                return False\\n       \\n        #Block wise\\n        for i in range(0, 9, 3):\\n            for j in range(0, 9, 3):\\n                block = [board[k][l] for k in range(i, i+3) for l in range(j, j+3)]\\n                if not valid(block):\\n                    return False\\n \\xA0 \\xA0 \\xA0 \\xA0return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 827706,
                "title": "c-beats-99",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int rows[9][10];\\n        int cols[9][10];\\n        int boxes[9][10];\\n        memset(rows, 0, sizeof(rows));\\n        memset(cols, 0, sizeof(cols));\\n        memset(boxes, 0, sizeof(boxes));\\n        for(int i = 0; i < 9; i++) {\\n            for(int j = 0; j < 9; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    int num = board[i][j] - \\'0\\';\\n                    if (++rows[i][num] > 1 || ++cols[j][num] > 1 || ++boxes[(i/3)*3 + j/3][num] > 1) return false;\\n                \\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int rows[9][10];\\n        int cols[9][10];\\n        int boxes[9][10];\\n        memset(rows, 0, sizeof(rows));\\n        memset(cols, 0, sizeof(cols));\\n        memset(boxes, 0, sizeof(boxes));\\n        for(int i = 0; i < 9; i++) {\\n            for(int j = 0; j < 9; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    int num = board[i][j] - \\'0\\';\\n                    if (++rows[i][num] > 1 || ++cols[j][num] > 1 || ++boxes[(i/3)*3 + j/3][num] > 1) return false;\\n                \\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15576,
                "title": "java-clear-solution",
                "content": "    public class Solution {\\n    public static boolean isValidSudoku(char[][] board) {\\n    \\t\\tSet<Character>[] setXX = new HashSet[9];\\n    \\t\\tSet<Character>[] setYY = new HashSet[9];\\n    \\t\\tSet<Character>[] setXY = new HashSet[9];\\n    \\t\\tfor (int i = 0; i < 9; i++) {\\n    \\t\\t\\tsetXX[i] = new HashSet<>();\\n    \\t\\t\\tsetYY[i] = new HashSet<>();\\n    \\t\\t\\tsetXY[i] = new HashSet<>();\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tfor (int i = 0; i < 9; i++) {\\n    \\t\\t\\tfor (int j = 0; j < 9; j++) {\\n    \\t\\t\\t\\tif (board[i][j] == '.') {\\n    \\t\\t\\t\\t\\tcontinue;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tif(!setXX[i].add(board[i][j])){\\n    \\t\\t\\t\\t\\treturn false;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tif(!setYY[j].add(board[i][j])){\\n    \\t\\t\\t\\t\\treturn false;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tif(!setXY[(j / 3)* 3 + i / 3].add(board[i][j])){\\n    \\t\\t\\t\\t\\treturn false;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn true;\\n    \\t}\\n    \\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n    public static boolean isValidSudoku(char[][] board) {\\n    \\t\\tSet<Character>[] setXX = new HashSet[9];\\n    \\t\\tSet<Character>[] setYY = new HashSet[9];\\n    \\t\\tSet<Character>[] setXY = new HashSet[9];\\n    \\t\\tfor (int i = 0; i < 9; i++) {\\n    \\t\\t\\tsetXX[i] = new HashSet<>();\\n    \\t\\t\\tsetYY[i] = new HashSet<>();\\n    \\t\\t\\tsetXY[i] = new HashSet<>();\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2840682,
                "title": "c-java-not-the-fastest-but-the-most-simple-to-grasp",
                "content": "\\nHere we will run two for loops, one for rows and one for columns,\\nIf the element in the board is a number from 1 to 9 then we will check their presence---->\\n* IN THAT ROW : by using a row checker 2d array\\n* IN THE COLUMN : by using a column checker 2d array\\n* IN THAT BOX : by using the formula (row/3)3+(col/3) \\n\\n**JAVA**\\n\\n```\\nclass Solution {\\n    public boolean IsSafe(char[][] board, int row, int col, char num){\\n\\n        for(int i = col+1; i < 9; i++){         //for row checking\\n            if(board[row][i] == num)\\n                return false;\\n        }\\n\\n        for(int i = row+1; i < 9; i++){         //For col checking\\n            if(board[i][col] == num)\\n                return false;\\n        }\\n\\n        int x = row - row%3, y = col-col%3;        //for internal square\\n        for(int i = x; i < x+3; i++){\\n            for(int j = y; j < y+3; j++){\\n                if(board[i][j] == num && !(i == row && j == col))\\n                    return false;\\n            }\\n        }   \\n        return true;\\n    } \\n    public boolean isValidSudoku(char[][] board) {\\n\\n        for(int i = 0; i < 9; i++){\\n            for(int j = 0; j < 9; j++){\\n                if(board[i][j] != \\'.\\'){\\n                    if(!IsSafe(board, i, j, board[i][j]))\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n\\n--------------------------------------------\\n\\n**c++**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool isSafe(vector<vector<char>>& board , int temp, int row, int col)\\n    {\\n        for(int i=0;i<board.size();i++)\\n        {\\n            if(board[row][i] == temp)\\n            {\\n                return false;\\n            }\\n            if(board[i][col] == temp)\\n            {\\n                return false;\\n            }\\n            if(board[row/3 *3 + i/3] [  col/3 * 3 +   (i%3)  ] == temp)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    \\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        \\n        for(int i=0;i<board.size();i++)\\n        {\\n            for(int j=0;j<board.size();j++)\\n            {\\n                \\n                if(board[i][j] != \\'.\\')                // If the position is a number (!= \\'.\\'), and it is a not a valid placement, then return false.\\n                {\\n                    int temp = board[i][j];\\n                    board[i][j]  = \\'*\\';\\n                    if(!isSafe(board, temp, i ,j))\\n                    {\\n                        return false;\\n                    }\\n                    board[i][j] =  temp;\\n                }\\n                \\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n-----------------------------------------------\\n\\n**However, if you need a faster and more optimal solution, here it is:**\\n\\n**C++**\\n\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int row[9][9] = {0}, col[9][9] = {0}, sub[9][9] = {0};\\n        \\n        for(int i = 0; i < 9; i++) {\\n            for(int j = 0; j < 9; j++)  {\\n                if(board[i][j] != \\'.\\')  {\\n                    int num = board[i][j] - \\'0\\' - 1, k = i/3*3 + j/3;\\n                    if(row[i][num] || col[j][num] || sub[k][num])\\n                        return false;\\n                    row[i][num] = col[j][num] = sub[k][num] = 1;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean IsSafe(char[][] board, int row, int col, char num){\\n\\n        for(int i = col+1; i < 9; i++){         //for row checking\\n            if(board[row][i] == num)\\n                return false;\\n        }\\n\\n        for(int i = row+1; i < 9; i++){         //For col checking\\n            if(board[i][col] == num)\\n                return false;\\n        }\\n\\n        int x = row - row%3, y = col-col%3;        //for internal square\\n        for(int i = x; i < x+3; i++){\\n            for(int j = y; j < y+3; j++){\\n                if(board[i][j] == num && !(i == row && j == col))\\n                    return false;\\n            }\\n        }   \\n        return true;\\n    } \\n    public boolean isValidSudoku(char[][] board) {\\n\\n        for(int i = 0; i < 9; i++){\\n            for(int j = 0; j < 9; j++){\\n                if(board[i][j] != \\'.\\'){\\n                    if(!IsSafe(board, i, j, board[i][j]))\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    bool isSafe(vector<vector<char>>& board , int temp, int row, int col)\\n    {\\n        for(int i=0;i<board.size();i++)\\n        {\\n            if(board[row][i] == temp)\\n            {\\n                return false;\\n            }\\n            if(board[i][col] == temp)\\n            {\\n                return false;\\n            }\\n            if(board[row/3 *3 + i/3] [  col/3 * 3 +   (i%3)  ] == temp)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    \\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        \\n        for(int i=0;i<board.size();i++)\\n        {\\n            for(int j=0;j<board.size();j++)\\n            {\\n                \\n                if(board[i][j] != \\'.\\')                // If the position is a number (!= \\'.\\'), and it is a not a valid placement, then return false.\\n                {\\n                    int temp = board[i][j];\\n                    board[i][j]  = \\'*\\';\\n                    if(!isSafe(board, temp, i ,j))\\n                    {\\n                        return false;\\n                    }\\n                    board[i][j] =  temp;\\n                }\\n                \\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int row[9][9] = {0}, col[9][9] = {0}, sub[9][9] = {0};\\n        \\n        for(int i = 0; i < 9; i++) {\\n            for(int j = 0; j < 9; j++)  {\\n                if(board[i][j] != \\'.\\')  {\\n                    int num = board[i][j] - \\'0\\' - 1, k = i/3*3 + j/3;\\n                    if(row[i][num] || col[j][num] || sub[k][num])\\n                        return false;\\n                    row[i][num] = col[j][num] = sub[k][num] = 1;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2397764,
                "title": "java-simple-solution-hashset",
                "content": "PLEASE UPVOTE IF YOU LIKE IT-\\n\\n**keypoint**- HashSet returns true if element is not present in HashSet else returns false;\\n\\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n       HashSet<String> seen = new HashSet<>();\\n      \\n        for(int i=0; i<9; i++){\\n             for(int j=0; j<9; j++){\\n              if(board[i][j] != \\'.\\'){ \\n                  char currentVal = board[i][j];\\n                   if(!(seen.add(currentVal + \"found in row \"+ i)) ||\\n                      !(seen.add(currentVal + \"found in column \"+ j) ) ||\\n                      !(seen.add(currentVal + \"found in sub box \"+ i/3 + \"-\"+ j/3)))\\n                       return false;\\n              }\\n          \\n           } \\n        \\n        }\\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n       HashSet<String> seen = new HashSet<>();\\n      \\n        for(int i=0; i<9; i++){\\n             for(int j=0; j<9; j++){\\n              if(board[i][j] != \\'.\\'){ \\n                  char currentVal = board[i][j];\\n                   if(!(seen.add(currentVal + \"found in row \"+ i)) ||\\n                      !(seen.add(currentVal + \"found in column \"+ j) ) ||\\n                      !(seen.add(currentVal + \"found in sub box \"+ i/3 + \"-\"+ j/3)))\\n                       return false;\\n              }\\n          \\n           } \\n        \\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905778,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func isValidSudoku(_ board: [[Character]]) -> Bool {\\n        func isInvalid(_ box: [Character]) -> Bool {\\n            var chars: [Character] = []\\n            for c in box where c != \".\" {\\n                if chars.contains(c) { return true } else { chars.append(c) }\\n            }\\n            return false\\n        }\\n\\n        for i in 0..<9 {\\n            if isInvalid(board[i]) { return false }\\n            if isInvalid(board.map({ $0[i] })) { return false }\\n            let col = (i % 3) * 3\\n            let row = (i / 3) * 3\\n            let box = Array(board[row][col..<col + 3]) + Array(board[row + 1][col..<col + 3]) + Array(board[row + 2][col..<col + 3])\\n            if isInvalid(box) { return false }\\n        }\\n        return true\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isValidSudoku(_ board: [[Character]]) -> Bool {\\n        func isInvalid(_ box: [Character]) -> Bool {\\n            var chars: [Character] = []\\n            for c in box where c != \".\" {\\n                if chars.contains(c) { return true } else { chars.append(c) }\\n            }\\n            return false\\n        }\\n\\n        for i in 0..<9 {\\n            if isInvalid(board[i]) { return false }\\n            if isInvalid(board.map({ $0[i] })) { return false }\\n            let col = (i % 3) * 3\\n            let row = (i / 3) * 3\\n            let box = Array(board[row][col..<col + 3]) + Array(board[row + 1][col..<col + 3]) + Array(board[row + 2][col..<col + 3])\\n            if isInvalid(box) { return false }\\n        }\\n        return true\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15605,
                "title": "3ms-concise-java-solution-with-bit-operation",
                "content": "    public class Solution {\\n        public boolean isValidSudoku(char[][] board) {\\n            int[] rows = new int[9];\\n            int[] columns = new int[9];\\n            int[] blocks = new int[9];\\n            for(int i=0;i<9;i++){\\n                for(int j=0;j<9;j++){\\n                    int mask = board[i][j]=='.'?0:(1<<(board[i][j]-'0'));\\n                    if(mask==0) continue;\\n                    if((rows[i]&mask)!=0) return false;\\n                    if((columns[j]&mask)!=0) return false;\\n                    if((blocks[i/3*3+j/3]&mask)!=0) return false;\\n                    rows[i] |= mask;\\n                    columns[j] |= mask;\\n                    blocks[i/3*3+j/3] |= mask;\\n                }\\n            }\\n            return true;\\n        }\\n    }",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n        public boolean isValidSudoku(char[][] board) {\\n            int[] rows = new int[9];\\n            int[] columns = new int[9];\\n            int[] blocks = new int[9];\\n            for(int i=0;i<9;i++){\\n                for(int j=0;j<9;j++){\\n                    int mask = board[i][j]=='.'?0:(1<<(board[i][j]-'0'));\\n                    if(mask==0) continue;\\n                    if((rows[i]&mask)!=0) return false;\\n                    if((columns[j]&mask)!=0) return false;\\n                    if((blocks[i/3*3+j/3]&mask)!=0) return false;\\n                    rows[i] |= mask;\\n                    columns[j] |= mask;\\n                    blocks[i/3*3+j/3] |= mask;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 705765,
                "title": "good-explanation-for-the-same-code-as-in-discussion",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        // Ok so it was a freaking great solution\\n        // What are we going to do is, lets say i got 3 2d vectors\\n        /// Now, I am going to start with current i,j i.e each row will have its\\n        // Own box, so my 0th row, will have a unique element box as well as 0th Column\\n        // So, for eg, if we start with the first element 5, we are going to check if\\n        // [0][5] present or not, that is, does current row have 5 as element or not\\n        // In similar way [0][5] for column, now, what about, the 3x3 box, what to do \\n        // about that, well this where freakin thinking of the user paid off\\n        // Ok so what we are going to do is, we are going to assign every 3x3 grid \\n        // as 1 box, i.e, First 3x3 Grid will have 0 number box, which will store all\\n        // The unique elements.\\n        \\n        vector<vector<int>> rbox(9, vector<int>(9)), cbox(9, vector<int>(9)), ubox(9, vector<int>(9));\\n        // Ok so this are row boxes, column boxes, unique boxes\\n        \\n        for(int i = 0;i<board.size();i++){\\n            for(int j = 0; j< board[i].size(); j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int nums = board[i][j] - \\'0\\' - 1;\\n                    // Now this is how we are going to check with respect to particular point\\n                    // Lets say our point is (1,2) That means I need to check 0th Unique Box if\\n                    // The element present is there or not\\n                    // Now how are we going to achieve that 0th Number, lets see,\\n                    // First of all, as you can see both are less than 3 becoz we need 3x3 grid\\n                    // Now lets take another example (2,6) Now which Unique Box it will be in\\n                    // It will be in 3rd Box, now how should we make a value that unique,\\n                    // Ok so we could reduce both numbers 2/3 = 0, 6/3 = 2 (As per indexing)\\n                    // Ok so if we divide the index by 3 it will be good, but\\n                    // Lets take another point, (6, 7) 6/3 = 2, 7/3 = 2 => 4th Unique Box\\n                    // Which is wrong, instead it will be in 9th Unique Box, so we are going to \\n                    // do that, by multiplying, ith index by 3 we will get 2x3 = 6, 6 + 2 \\n                    // which is 8(Indexing), we got our 9th Unique Box, noice\\n                    // Lets apply for our first point, and see if it helps\\n                    // 1/3 = 0, 0x3 = 0; 2/3 = 0 => Which means we are at our 1st Unique box\\n                    // Noice.....\\n                    int k = i/3*3 + j/3;\\n\\n                    if(rbox[i][nums] || cbox[j][nums] || ubox[k][nums]){\\n                        return false;\\n                    }\\n\\n                    rbox[i][nums] = cbox[j][nums] = ubox[k][nums] = 1;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        // Ok so it was a freaking great solution\\n        // What are we going to do is, lets say i got 3 2d vectors\\n        /// Now, I am going to start with current i,j i.e each row will have its\\n        // Own box, so my 0th row, will have a unique element box as well as 0th Column\\n        // So, for eg, if we start with the first element 5, we are going to check if\\n        // [0][5] present or not, that is, does current row have 5 as element or not\\n        // In similar way [0][5] for column, now, what about, the 3x3 box, what to do \\n        // about that, well this where freakin thinking of the user paid off\\n        // Ok so what we are going to do is, we are going to assign every 3x3 grid \\n        // as 1 box, i.e, First 3x3 Grid will have 0 number box, which will store all\\n        // The unique elements.\\n        \\n        vector<vector<int>> rbox(9, vector<int>(9)), cbox(9, vector<int>(9)), ubox(9, vector<int>(9));\\n        // Ok so this are row boxes, column boxes, unique boxes\\n        \\n        for(int i = 0;i<board.size();i++){\\n            for(int j = 0; j< board[i].size(); j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int nums = board[i][j] - \\'0\\' - 1;\\n                    // Now this is how we are going to check with respect to particular point\\n                    // Lets say our point is (1,2) That means I need to check 0th Unique Box if\\n                    // The element present is there or not\\n                    // Now how are we going to achieve that 0th Number, lets see,\\n                    // First of all, as you can see both are less than 3 becoz we need 3x3 grid\\n                    // Now lets take another example (2,6) Now which Unique Box it will be in\\n                    // It will be in 3rd Box, now how should we make a value that unique,\\n                    // Ok so we could reduce both numbers 2/3 = 0, 6/3 = 2 (As per indexing)\\n                    // Ok so if we divide the index by 3 it will be good, but\\n                    // Lets take another point, (6, 7) 6/3 = 2, 7/3 = 2 => 4th Unique Box\\n                    // Which is wrong, instead it will be in 9th Unique Box, so we are going to \\n                    // do that, by multiplying, ith index by 3 we will get 2x3 = 6, 6 + 2 \\n                    // which is 8(Indexing), we got our 9th Unique Box, noice\\n                    // Lets apply for our first point, and see if it helps\\n                    // 1/3 = 0, 0x3 = 0; 2/3 = 0 => Which means we are at our 1st Unique box\\n                    // Noice.....\\n                    int k = i/3*3 + j/3;\\n\\n                    if(rbox[i][nums] || cbox[j][nums] || ubox[k][nums]){\\n                        return false;\\n                    }\\n\\n                    rbox[i][nums] = cbox[j][nums] = ubox[k][nums] = 1;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 355779,
                "title": "python-solution-using-set-76ms",
                "content": "```\\nclass Solution(object):\\n    def isValidSudoku(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: bool\\n        \"\"\"\\n        rows  = [set() for _ in range(9)]\\n        cols  = [set() for _ in range(9)]\\n        dices = [[set() for _ in range(3)] for _ in range(3)]\\n\\n        for i in range(9):\\n            for j in range(9):\\n                e = board[i][j]\\n                if e == \\'.\\': continue\\n                if e in rows[i] or e in cols[j] or e in dices[i//3][j//3]: return False\\n                rows[i].add(e)\\n                cols[j].add(e)\\n                dices[i//3][j//3].add(e)\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isValidSudoku(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: bool\\n        \"\"\"\\n        rows  = [set() for _ in range(9)]\\n        cols  = [set() for _ in range(9)]\\n        dices = [[set() for _ in range(3)] for _ in range(3)]\\n\\n        for i in range(9):\\n            for j in range(9):\\n                e = board[i][j]\\n                if e == \\'.\\': continue\\n                if e in rows[i] or e in cols[j] or e in dices[i//3][j//3]: return False\\n                rows[i].add(e)\\n                cols[j].add(e)\\n                dices[i//3][j//3].add(e)\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 326928,
                "title": "python-4-lines",
                "content": "```python\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        row = [[x for x in y if x != \\'.\\'] for y in board]\\n        col = [[x for x in y if x != \\'.\\'] for y in zip(*board)]\\n        pal = [[board[i+m][j+n] for m in range(3) for n in range(3) if board[i+m][j+n] != \\'.\\'] for i in (0, 3, 6) for j in (0, 3, 6)]\\n        return all(len(set(x)) == len(x) for x in (*row, *col, *pal))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        row = [[x for x in y if x != \\'.\\'] for y in board]\\n        col = [[x for x in y if x != \\'.\\'] for y in zip(*board)]\\n        pal = [[board[i+m][j+n] for m in range(3) for n in range(3) if board[i+m][j+n] != \\'.\\'] for i in (0, 3, 6) for j in (0, 3, 6)]\\n        return all(len(set(x)) == len(x) for x in (*row, *col, *pal))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 160973,
                "title": "go-solution",
                "content": "```\\nfunc isValidSudoku(board [][]byte) bool {\\n    var rows, cols, boxes []map[byte]bool\\n    for i := 0; i < 9; i++ {\\n        rows = append(rows, make(map[byte]bool))\\n        cols = append(cols, make(map[byte]bool))\\n        boxes = append(boxes, make(map[byte]bool))\\n    }\\n    for i := range board {\\n        for j, num := range board[i] {\\n            if num == \\'.\\' { continue }\\n            if rows[i][num] || cols[j][num] || boxes[(i/3)*3+j/3][num] {\\n                return false\\n            }\\n            rows[i][num] = true\\n            cols[j][num] = true\\n            boxes[(i/3)*3+j/3][num] = true\\n        }\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc isValidSudoku(board [][]byte) bool {\\n    var rows, cols, boxes []map[byte]bool\\n    for i := 0; i < 9; i++ {\\n        rows = append(rows, make(map[byte]bool))\\n        cols = append(cols, make(map[byte]bool))\\n        boxes = append(boxes, make(map[byte]bool))\\n    }\\n    for i := range board {\\n        for j, num := range board[i] {\\n            if num == \\'.\\' { continue }\\n            if rows[i][num] || cols[j][num] || boxes[(i/3)*3+j/3][num] {\\n                return false\\n            }\\n            rows[i][num] = true\\n            cols[j][num] = true\\n            boxes[(i/3)*3+j/3][num] = true\\n        }\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 15687,
                "title": "sharing-my-simple-o-n-2-c-solution",
                "content": "    class Solution {\\n    public:\\n        bool isValidSudoku(vector<vector<char> > &board) {\\n            int rows = board.size();\\n            int cols = board[0].size();\\n            int mask=0;\\n            int val;\\n            for(int i=0;i<rows;i++){\\n                mask=0;\\n                for(int j=0;j<cols;j++){\\n                    if(board[i][j]!='.'){\\n                        int val = (int)(board[i][j]-'0');\\n                        if(mask & (1<<val))\\n                            return false;\\n                        else mask |= (1<<val);\\n                    }\\n                }\\n            }\\n            //rows are checked\\n            for(int j=0;j<cols;j++){\\n                mask=0;\\n                for(int i=0;i<rows;i++){\\n                    if(board[i][j]!='.'){\\n                        int val = (int)(board[i][j]-'0');\\n                        if(mask & (1<<val))\\n                            return false;\\n                        else mask |= (1<<val);\\n                    }\\n                }\\n            }\\n            //cols are checked\\n            for(int i=0;i<rows;i+=3)\\n            {\\n                for(int j=0;j<cols;j+=3)\\n                {\\n                    mask=0;\\n                    for(int k=i;k<=i+2;k++)\\n                    {\\n                        for(int l=j;l<=j+2;l++)\\n                        {\\n                            if(board[k][l]!='.'){\\n                                val = (int)(board[k][l]-'0');\\n                                if(mask&(1<<val))\\n                                    return false;\\n                                else mask|=(1<<val);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            return true;\\n        }\\n    };\\n\\nI use 'mask' to see which all digits have occurred before. This check is done using binary operators. This check is done for each row, each column and each block of 3*3. Any comments/suggestions/improvements are welcome!",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isValidSudoku(vector<vector<char> > &board) {\\n            int rows = board.size();\\n            int cols = board[0].size();\\n            int mask=0;\\n            int val;\\n            for(int i=0;i<rows;i++){\\n                mask=0;\\n                for(int j=0;j<cols;j++){\\n                    if(board[i][j]!='.'){\\n                        int val = (int)(board[i][j]-'0');\\n                        if(mask & (1<<val))\\n                            return false;\\n                        else mask |= (1<<val);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3254549,
                "title": "c-easiest-solution-hashing",
                "content": "# Intuition\\nCheck Every Row,Column,Box, if there is duplicate of not.\\nWe will do it in one iteration.\\n\\n# Approach\\nThere will be 9 row, 9 col and 9 box. We can determine the row and col no. easily (i,j if we iterate throw board ). And to to determine the box no --> [(i/3)*3 +(j/3)] ;\\n\\n# Complexity\\n- Time complexity:\\nO(N*N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        set<char> row[9];\\n        set<char> col[9];\\n        set<char> box[9];\\n        for(int i=0;i<9;i++)\\n        {\\n            for(int j=0;j<9;j++)\\n            {\\n                char ch=board[i][j];\\n                if(ch==\\'.\\') continue;\\n\\n                <!-- Checking the Row -->\\n                if(row[i].count(ch)>=1) return false;\\n                else row[i].insert(ch);\\n\\n                <!-- Checking the Col -->\\n                if(col[j].count(ch)>=1) return false;\\n                else col[j].insert(ch);\\n                \\n                <!-- Calculating the box no-->\\n                int bi=(i/3)*3 + (j/3);\\n\\n                <!-- Checking the Box -->\\n                if(box[bi].count(ch)>=1) return false;\\n                else box[bi].insert(ch);\\n            }\\n        }\\n\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        set<char> row[9];\\n        set<char> col[9];\\n        set<char> box[9];\\n        for(int i=0;i<9;i++)\\n        {\\n            for(int j=0;j<9;j++)\\n            {\\n                char ch=board[i][j];\\n                if(ch==\\'.\\') continue;\\n\\n                <!-- Checking the Row -->\\n                if(row[i].count(ch)>=1) return false;\\n                else row[i].insert(ch);\\n\\n                <!-- Checking the Col -->\\n                if(col[j].count(ch)>=1) return false;\\n                else col[j].insert(ch);\\n                \\n                <!-- Calculating the box no-->\\n                int bi=(i/3)*3 + (j/3);\\n\\n                <!-- Checking the Box -->\\n                if(box[bi].count(ch)>=1) return false;\\n                else box[bi].insert(ch);\\n            }\\n        }\\n\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925966,
                "title": "time-o-1-space-o-1",
                "content": "# Intuition\\nIn this problem, we simply need to check whether the board is a valid board, i.e. there are no duplicate numbers in any row, column, or box. We could brute force it by repeating work to check each row, column, box, individually. However, to improve performance, we will maintain 9 hashsets for each row/col/box. The only complication is how to determine the box based on the row, col. Let\\'s consider a couple options:\\n\\n```\\nrow = 2, col = 2, box should be 0\\nrow = 2, col = 8, box should be 2\\nrow = 5, col = 5, box should be 4\\nrow = 7, col = 7, box should be 8\\n```\\n\\nBased on the above examples, I came up with the following:\\n```\\nbox = 3*(row/3) + (col/3)\\n```\\n\\nYou can check the math yourself if you are interested.\\n\\n\\n# Approach\\n1. Maintain hashsets for each row, col, and box\\n2. If \\'.\\' continue, otherwise, check if element in the corresponding hashset\\n3. If ever found, return false. Otherwise, after processing all elements, return true \\n\\n# Complexity in general case\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(3 * n)$$ ~ $$O(n)$$\\n\\n# Complexity in specific case\\n- Time complexity:\\n$$O(9 * 9)$$ = $$O(81)$$ ~ $$O(1)$$\\n\\n- Space complexity:\\n$$O(9 * 9 * 3)$$ ~ $$O(243)$$ ~ $$O(1)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool IsValidSudoku(char[][] board) {\\n        HashSet<char>[] row = new HashSet<char>[9];\\n        HashSet<char>[] col = new HashSet<char>[9];\\n        HashSet<char>[] box = new HashSet<char>[9];\\n        for (int i = 0; i < 9; i++) {\\n            row[i] = new HashSet<char>();\\n            col[i] = new HashSet<char>();\\n            box[i] = new HashSet<char>();\\n        }\\n\\n        for (int r = 0; r < board.Length; r++) {\\n            for (int c = 0; c < board[r].Length; c++) {\\n                char elem = board[r][c];\\n                if (elem == \\'.\\') {\\n                    continue;\\n                }\\n\\n                if (!row[r].Add(elem)) {\\n                    return false;\\n                }\\n\\n                if (!col[c].Add(elem)) {\\n                    return false;\\n                }\\n                \\n                int b = (3 * (r / 3)) + (c / 3);\\n                if (!box[b].Add(elem)) {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nrow = 2, col = 2, box should be 0\\nrow = 2, col = 8, box should be 2\\nrow = 5, col = 5, box should be 4\\nrow = 7, col = 7, box should be 8\\n```\n```\\nbox = 3*(row/3) + (col/3)\\n```\n```\\npublic class Solution {\\n    public bool IsValidSudoku(char[][] board) {\\n        HashSet<char>[] row = new HashSet<char>[9];\\n        HashSet<char>[] col = new HashSet<char>[9];\\n        HashSet<char>[] box = new HashSet<char>[9];\\n        for (int i = 0; i < 9; i++) {\\n            row[i] = new HashSet<char>();\\n            col[i] = new HashSet<char>();\\n            box[i] = new HashSet<char>();\\n        }\\n\\n        for (int r = 0; r < board.Length; r++) {\\n            for (int c = 0; c < board[r].Length; c++) {\\n                char elem = board[r][c];\\n                if (elem == \\'.\\') {\\n                    continue;\\n                }\\n\\n                if (!row[r].Add(elem)) {\\n                    return false;\\n                }\\n\\n                if (!col[c].Add(elem)) {\\n                    return false;\\n                }\\n                \\n                int b = (3 * (r / 3)) + (c / 3);\\n                if (!box[b].Add(elem)) {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2116277,
                "title": "python-brute-force-use-3-dictionaries-with-comments",
                "content": "I use brute force to scan through each cell in the sudoku. Use 3 dictionaries to store:\\n1. number that filled in each row\\n2. number that filled in each column\\n3. number that filled in each block\\nA trick is to use ```(r//3, c//3)``` to identify each block as follows\\n![image](https://assets.leetcode.com/users/images/88531b71-a215-4561-a269-c6e8327fdbc6_1654479090.7013428.jpeg)\\n\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        row = collections.defaultdict(set) # r: set(\"1\", \"2\", \"3\", ...)\\n        col = collections.defaultdict(set) # c: set(\"1\", \"2\", \"3\", ...)       \\n        block = collections.defaultdict(set) # (r//3, c//3): set(\"1\", \"2\", \"3\", ...)\\n        \\n        for r in range(9):\\n            for c in range(9):\\n                if board[r][c] == \".\": # don\\'t need to check empty cells\\n                    continue\\n                # return false if the number in the cell has been filled in the same row, column, or block.\\n                if (board[r][c] in row[r]) or (board[r][c] in col[c]) or (board[r][c] in block[(r//3, c//3)]):\\n                    return False\\n                # otherwise, add the number to the hash set\\n                row[r].add(board[r][c])\\n                col[c].add(board[r][c])\\n                block[(r//3, c//3)].add(board[r][c])\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```(r//3, c//3)```\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        row = collections.defaultdict(set) # r: set(\"1\", \"2\", \"3\", ...)\\n        col = collections.defaultdict(set) # c: set(\"1\", \"2\", \"3\", ...)       \\n        block = collections.defaultdict(set) # (r//3, c//3): set(\"1\", \"2\", \"3\", ...)\\n        \\n        for r in range(9):\\n            for c in range(9):\\n                if board[r][c] == \".\": # don\\'t need to check empty cells\\n                    continue\\n                # return false if the number in the cell has been filled in the same row, column, or block.\\n                if (board[r][c] in row[r]) or (board[r][c] in col[c]) or (board[r][c] in block[(r//3, c//3)]):\\n                    return False\\n                # otherwise, add the number to the hash set\\n                row[r].add(board[r][c])\\n                col[c].add(board[r][c])\\n                block[(r//3, c//3)].add(board[r][c])\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074970,
                "title": "valid-sudoku-using-back-tracking-100-faster-with-proper-explanation",
                "content": "Just tell me who hasn\\'t played sudoku ,there might be some.\\nBut now tell me who hasn\\'t even listen sudoku word ,nobody. Right!. thats all we need.\\nHowever,if you want to learn more about sudoku you can read it here\\nhttps://en.wikipedia.org/wiki/Sudoku\\nlet\\'s solve this problem together.\\nThis is a problem of sudoku which will be solved using techniques \\n1. Recursion.\\n2. only BackTracking\\n3. Hashing\\nQuestion says you need to tell whether the given sudoku is valid or not\\n\\nYou really donot need to solve \"Sudoku\" to find out whether it is valid or not\\nSay if our sudoku is whole empty thats also a valid sudoku \"The Question clearly says\".and we donot need Recursion anymore.\\n-\\nyou can really get the idea if you pass the test case \\nyou can check out by having the test case \\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\nif you are  really a sudoku solver  you will say this is an invalid sudoku ,but unfortunately this is what the question says.\\nNow comes the point how will you tell whether the sudoku is valid or not.\\nProgram-All we need to check the given number present in any 1* 1 cell should not be present in the row,column ,big 3* 3 cell associated with that 1* 1 cell.\\nAlgorithm\\n1. we here traverse the sudoku in breadth search manner this is row-wise we will assess each cell character.\\n2. if 1*1 cell conatins \\'.\\' then nothing needs to be checked\\n3. else store the present number and change it to \\' .\\' . \\n4. check the stored number if present anywhere in the row,in the column,or  in the block associated with that cell ,immediately return false;\\n5. else change it back to the number it was storing repeat the process until gets completed.\\n6. \\nNow ,the question arises how will you check whether the given number is present anywhere in the row ,in the column or in the block to with which the cell is associated.\\n-\\nwe will solve it using one for loop.\\n1. we are supposed to get the row no. of the cell and column no. of the cell and number that was there\\n2. run a loop from 0 to 9\\n3. fix row as row no. given \\n4. fix colum as column number given\\n\\t5. now divide the sudoku into 3 * 3 from 9* 9 i.e, coordinate shifting as shown\\n\\t![image](https://assets.leetcode.com/users/images/03a9ef26-b35e-44d2-80d3-4f8ce945a16f_1653546224.107758.png)\\n0 to 8 can be shifted to block \\nfirst of all the find the \\nblock row no.-row no./3\\nblock column number -column no./3\\nreal row index-(row no./3)*3+(k/3)\\n//k/3 will always gives value\\nfor k={0,1,2}->k/3 is {0,0,0} respectively/*row remains same for block*/\\nfor k={3,4,5}->k/3 is {1,1,1} respectively/*row remains same for block*/\\nfor k={6,7,8}->k/3 is t{2,2,2} respectively/*row remains same for block*/\\n#add respective block column number you will get required indexes\\nreal column idex-(column no./3)*3+(k%3)\\n//k%3 will always gives value\\nfor k={0,1,2}->k%3 is {0,1,2} respectively/*column varies for block*/\\nfor k={3,4,5}->k%3 is {0,1,2} respectively/*column varies for block*/\\nfor k={6,7,8}->k%3 is {0,1,2} respectively/*column varies for block*/\\nthat is used to switch columns within block\\n#add respective block row number you will get required indexes\\n\\ncode-\\n-\\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n     for(int i=0;i<9;i++)\\n     {\\n         for(int j=0;j<9;j++)//traverse in bfs manner \\n         {\\n             char ch=board[i][j];\\n             if(ch!=\\'.\\')//if ch is apart from \\'.\\'we need to check whether the given number is verifiable\\n             {\\n                 board[i][j]=\\'.\\';//change it to . so that it cannot consider itself\\n                 if(!isValid(board,ch,i,j))//if not verifiable\\n                     return false;//invalid sudoku\\n                 board[i][j]=ch;//after checking change it to its initial value\\n             }\\n         }\\n     }\\n        return true;\\n    }\\n    static boolean isValid(char[][]ch,char ch1,int i,int j)\\n    {\\n      for(int k=0;k<9;k++)\\n      {\\n          if(ch[i][k]==ch1)return false;//for checking row associated with it\\n          if(ch[k][j]==ch1)return false;//for checking column associated with it\\n          if(ch[3*(i/3)+k/3][3*(j/3)+k%3]==ch1)return false;//for checking block associated with it\\n      }\\n        return true;\\n    }\\n}\\n```\\nthis question is very easy ,just in any case if you face any problem anywhere let me know in the comments.\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n     for(int i=0;i<9;i++)\\n     {\\n         for(int j=0;j<9;j++)//traverse in bfs manner \\n         {\\n             char ch=board[i][j];\\n             if(ch!=\\'.\\')//if ch is apart from \\'.\\'we need to check whether the given number is verifiable\\n             {\\n                 board[i][j]=\\'.\\';//change it to . so that it cannot consider itself\\n                 if(!isValid(board,ch,i,j))//if not verifiable\\n                     return false;//invalid sudoku\\n                 board[i][j]=ch;//after checking change it to its initial value\\n             }\\n         }\\n     }\\n        return true;\\n    }\\n    static boolean isValid(char[][]ch,char ch1,int i,int j)\\n    {\\n      for(int k=0;k<9;k++)\\n      {\\n          if(ch[i][k]==ch1)return false;//for checking row associated with it\\n          if(ch[k][j]==ch1)return false;//for checking column associated with it\\n          if(ch[3*(i/3)+k/3][3*(j/3)+k%3]==ch1)return false;//for checking block associated with it\\n      }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1135904,
                "title": "0ms-simple-go-code",
                "content": "```\\nfunc isValidSudoku(board [][]byte) bool {\\n    rowsMap := [9][9]bool{}\\n    colsMap := [9][9]bool{}\\n    gridMap := [9][9]bool{}\\n    \\n    for row:=0; row<9; row++ {\\n        for col:=0; col<9; col++ {\\n            val, err := strconv.Atoi(string(board[row][col]))\\n            if err != nil {\\n                continue\\n            }\\n            val--\\n            gridIndex := col/3 + (row/3) * 3\\n            if rowsMap[row][val] || colsMap[col][val] || gridMap[gridIndex][val] {\\n                return false\\n            } \\n            rowsMap[row][val] = true\\n            colsMap[col][val] = true    \\n            gridMap[gridIndex][val] = true\\n        }\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isValidSudoku(board [][]byte) bool {\\n    rowsMap := [9][9]bool{}\\n    colsMap := [9][9]bool{}\\n    gridMap := [9][9]bool{}\\n    \\n    for row:=0; row<9; row++ {\\n        for col:=0; col<9; col++ {\\n            val, err := strconv.Atoi(string(board[row][col]))\\n            if err != nil {\\n                continue\\n            }\\n            val--\\n            gridIndex := col/3 + (row/3) * 3\\n            if rowsMap[row][val] || colsMap[col][val] || gridMap[gridIndex][val] {\\n                return false\\n            } \\n            rowsMap[row][val] = true\\n            colsMap[col][val] = true    \\n            gridMap[gridIndex][val] = true\\n        }\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 476302,
                "title": "javascript-string-map-solution",
                "content": "```\\nvar isValidSudoku = function(board) {\\n  const map = {};\\n  \\n  for (let row = 0; row < 9; row ++) {\\n    for (let col = 0; col < 9; col ++) {\\n      const val = board[row][col];\\n      \\n      if (val === \\'.\\') continue;\\n      \\n      const keyRow = `row ${row} has ${val}`;\\n      const keyCol = `col ${col} has ${val}`;\\n      const keyBox = `box ${Math.floor(row / 3)}-${Math.floor(col / 3)} has ${val}`;\\n\\n      if (map[keyRow] || map[keyCol] || map[keyBox]) return false;\\n\\n      map[keyRow] = true;\\n      map[keyCol] = true;\\n      map[keyBox] = true;\\n    }\\n  }\\n  \\n  return true;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isValidSudoku = function(board) {\\n  const map = {};\\n  \\n  for (let row = 0; row < 9; row ++) {\\n    for (let col = 0; col < 9; col ++) {\\n      const val = board[row][col];\\n      \\n      if (val === \\'.\\') continue;\\n      \\n      const keyRow = `row ${row} has ${val}`;\\n      const keyCol = `col ${col} has ${val}`;\\n      const keyBox = `box ${Math.floor(row / 3)}-${Math.floor(col / 3)} has ${val}`;\\n\\n      if (map[keyRow] || map[keyCol] || map[keyBox]) return false;\\n\\n      map[keyRow] = true;\\n      map[keyCol] = true;\\n      map[keyBox] = true;\\n    }\\n  }\\n  \\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 15587,
                "title": "my-one-pass-o-1-space-solution-using-java",
                "content": " \\n  This solution saves more space. \\n  Using bit-map to represent the occupation of each number.\\n  In the outer loop, the i represents ith row, column and block \\n  for the row, col and block variable separately to validate \\n  the jth element in this row (column and the block) seperately.\\n\\n\\n  Time complexity: O(n^2); where n is the width of the board.\\n\\n  Space complexity: O(1);\\n\\n  Status: Accepted.\\n \\n\\n    public class Solution {\\n        public boolean isValidSudoku(char[][] board) {\\n            // precondition: board is not null\\n            if (board == null) {\\n                throw new NullPointerException();\\n            }\\n    \\n            for (int i = 0; i < 9; i++) {\\n                int row = 0;\\n                int col = 0;\\n                int block = 0;\\n                for (int j = 0; j < 9; j++) {\\n                    int rowVal = board[i][j] - '1';\\n                    int colVal = board[j][i] - '1';\\n                    int blockVal = board[i/3*3 + j/3][i%3*3 + j%3] - '1';\\n                    if (rowVal >= 0 && (row & (1 << rowVal)) != 0\\n                     || colVal >= 0 && (col & (1 << colVal)) != 0\\n                     || blockVal >= 0 && (block & (1 << blockVal)) !=0) {\\n                        return false;\\n                    }\\n                    row |= rowVal >= 0 ? 1 << rowVal : 0;\\n                    col |= colVal >=0 ? 1 << colVal : 0;\\n                    block |= blockVal >= 0 ? 1 << blockVal : 0;\\n                }\\n            }\\n    \\n            return true;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isValidSudoku(char[][] board) {\\n            // precondition: board is not null\\n            if (board == null) {\\n                throw new NullPointerException();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3919253,
                "title": "beats-96-06-50-145-top-interview-question",
                "content": "# Intuition\\n*A simple straight-forward solution!*\\n\\n# Approach\\nThis code block is an implementation of the solution to `isValidSudoku`. Let\\'s break down the code step by step:\\n\\n1. The code starts by importing the `collections` module, which is used to create defaultdicts (Why? Will explain!).\\n   \\n2. Within the `isValidSudoku` method, three defaultdicts are created: `rows`, `columns`, and `sub_boxes`. These defaultdicts will store sets of numbers that are present in each row, column, and sub-box of the Sudoku board, respectively.\\n\\n3. The code then uses two nested loops to iterate through each cell in the 9x9 Sudoku board.\\n\\n4. For each cell, it checks the value of the number in the cell (`num`):\\n\\n   - If the cell contains a period (`.`), which represents an empty cell, it skips the current iteration using `continue`.\\n\\n   - If the cell contains a number, it checks three conditions to determine if the number violates the rules of Sudoku:\\n\\n     - It checks if the number is already present in the set of numbers in the same row (`rows[row]`).\\n     \\n     - It checks if the number is already present in the set of numbers in the same column (`columns[col]`).\\n     \\n     - It checks if the number is already present in the set of numbers in the corresponding sub-box (`sub_boxes[(row//3, col//3)]`).\\n\\n   - If any of these conditions are met, it means the Sudoku rules are violated, and the function immediately returns `False`, indicating that the Sudoku board is not valid.\\n\\n5. If none of the conditions are met, meaning the number can be safely placed in the current cell without violating any rules, the code updates the sets in `rows`, `columns`, and `sub_boxes` to include the new number.\\n\\n6. After iterating through the entire board, if no violations were found, the function returns `True`, indicating that the Sudoku board is valid.\\n\\n\\n# Complexity\\n- Time complexity:\\n    O(1) , ***Actually O(81) since constant\\'s are O(1)***\\n\\n- Space complexity:\\n    O(1),  ***Confusing? It\\'s simple. The total space incurred will be three times the size of the Sudoku board, and it\\'s constant in length! It might get smaller but will never exceed 3(9+1 x 9+1).***\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        # Create dictionaries to keep track of numbers in rows, columns, and sub-boxes\\n        rows = collections.defaultdict(set)\\n        columns = collections.defaultdict(set)\\n        sub_boxes = collections.defaultdict(set)\\n\\n        # Iterate through each cell in the 9x9 Sudoku board\\n        for row in range(9):\\n            for col in range(9):\\n                num = board[row][col]\\n\\n                # Skip empty cells represented by \".\"\\n                if num == \".\":\\n                    continue\\n\\n                # Check if the current number violates Sudoku rules\\n                if (num in rows[row] or \\n                    num in columns[col] or \\n                    num in sub_boxes[(row // 3, col // 3)]):\\n                   return False\\n\\n                # Update sets to keep track of encountered numbers\\n                rows[row].add(num)\\n                columns[col].add(num)\\n                sub_boxes[(row // 3, col // 3)].add(num)\\n\\n        # If all cells satisfy Sudoku rules, the board is valid\\n        return True\\n\\n```\\n\\n***Extra note:***\\n\\n*Why we used **defaultdict?**.*\\n-- *It is to simplify the process of initializing and accessing values in a dictionary, especially when dealing with keys that might not exist yet. It provides a convenient way to handle default values for keys that are not present in the dictionary.*\\n\\n\\n- `num in sub_boxes[(row // 3, col // 3)]`:\\n\\n*This line checks whether the number `num` is already present in the set that corresponds to the specific ***3x3*** sub-box where the current cell is located.*\\n\\n*Imagine you\\'re playing a game on a ***9x9*** Sudoku board. To make sure you\\'re not violating the rules, you want to know if the number you\\'re considering ***(let\\'s say \"5\")*** is already in the little ***3x3*** box that your current cell is part of. You\\'d look at that ***3x3*** box, see if the number ***\"5\"*** is already there, and if it is, you\\'d know you can\\'t place another ***\"5\"*** there. This line of code is doing that exact check for you, but programmatically.*\\n\\n```\\n    0       1      2\\n   - - - | - - - | - - -\\n0  - - - | - - - | - - -  // sub_boxes key\\'s as a tuple (x,y)\\n   - - - | - - - | - - -\\n  -----------------------\\n   - - - | - - - | - - -\\n1  - - - | - - - | - - -\\n   - - - | - - - | - - -\\n  -----------------------\\n   - - - | - - - | - - -\\n2  - - - | - - - | - - -\\n   - - - | - - - | - - -\\n```\\n\\n- `sub_boxes[(row // 3, col // 3)].add(num)`:\\n\\n*This line adds the current number `num` to the set that corresponds to the ***3x3*** sub-box where the current cell is located.*\\n\\n*Continuing from the previous analogy, let\\'s say you found that the number **\"5\"** isn\\'t in the ***3x3*** box yet, so you want to add it there. You take your pen and add the ***\"5\"*** to the list of numbers you\\'ve placed in that box. This line of code does the same thing in code. It adds the current number `num` to the set that represents the numbers placed in that specific ***3x3*** sub-box.*\\n\\n***In both cases, these lines help ensure that you\\'re following the rules of Sudoku by keeping track of the numbers in rows, columns, and sub-boxes, making sure no number repeats within the same row, column, or sub-box.***\\n\\n***END***\\n\\n\\n*It took a lot of time and effort to write this documentation, but I will be really happy if it becomes useful to someone!* \\n\\n\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        # Create dictionaries to keep track of numbers in rows, columns, and sub-boxes\\n        rows = collections.defaultdict(set)\\n        columns = collections.defaultdict(set)\\n        sub_boxes = collections.defaultdict(set)\\n\\n        # Iterate through each cell in the 9x9 Sudoku board\\n        for row in range(9):\\n            for col in range(9):\\n                num = board[row][col]\\n\\n                # Skip empty cells represented by \".\"\\n                if num == \".\":\\n                    continue\\n\\n                # Check if the current number violates Sudoku rules\\n                if (num in rows[row] or \\n                    num in columns[col] or \\n                    num in sub_boxes[(row // 3, col // 3)]):\\n                   return False\\n\\n                # Update sets to keep track of encountered numbers\\n                rows[row].add(num)\\n                columns[col].add(num)\\n                sub_boxes[(row // 3, col // 3)].add(num)\\n\\n        # If all cells satisfy Sudoku rules, the board is valid\\n        return True\\n\\n```\n```\\n    0       1      2\\n   - - - | - - - | - - -\\n0  - - - | - - - | - - -  // sub_boxes key\\'s as a tuple (x,y)\\n   - - - | - - - | - - -\\n  -----------------------\\n   - - - | - - - | - - -\\n1  - - - | - - - | - - -\\n   - - - | - - - | - - -\\n  -----------------------\\n   - - - | - - - | - - -\\n2  - - - | - - - | - - -\\n   - - - | - - - | - - -\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474482,
                "title": "typescript-easy-solution-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n\\n# Code\\n```\\nfunction isValidSudoku(board: string[][]): boolean {\\n    const set = new Set()\\n\\n    for(let i = 0; i < board.length; i++) {\\n        for(let j = 0; j < board[i].length; j++) {\\n            const cell = board[i][j]\\n            if(cell === \\'.\\') continue\\n            const row = `row: ${i}, value: ${cell}`\\n            const column = `column: ${j}, value: ${cell}`\\n            const boxNumber = 3 * Math.floor(i / 3) + Math.floor(j / 3)\\n            const box = `boxNumber: ${boxNumber}, value: ${cell}`\\n            if(set.has(row) || set.has(column) || set.has(box)) return false\\n            set.add(row).add(column).add(box)\\n        }\\n    }\\n    return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nfunction isValidSudoku(board: string[][]): boolean {\\n    const set = new Set()\\n\\n    for(let i = 0; i < board.length; i++) {\\n        for(let j = 0; j < board[i].length; j++) {\\n            const cell = board[i][j]\\n            if(cell === \\'.\\') continue\\n            const row = `row: ${i}, value: ${cell}`\\n            const column = `column: ${j}, value: ${cell}`\\n            const boxNumber = 3 * Math.floor(i / 3) + Math.floor(j / 3)\\n            const box = `boxNumber: ${boxNumber}, value: ${cell}`\\n            if(set.has(row) || set.has(column) || set.has(box)) return false\\n            set.add(row).add(column).add(box)\\n        }\\n    }\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2840609,
                "title": "python-solution-using-set-faster-than-95",
                "content": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        # idea: mark row, col, and sub-board appearance for each element. Check repetition at the end. \\n        tags = []\\n        for i in range(9):\\n            for j in range(9):\\n                ele = board[i][j]\\n                if ele != \\'.\\':\\n                    tags.append(f\\'{ele} @ {i}th row\\')\\n                    tags.append(f\\'{ele} @ {j}th col\\') \\n                    tags.append(f\\'{ele} @ {i//3}-{j//3}th subboard\\')\\n\\n        return len(tags) == len(set(tags))\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        # idea: mark row, col, and sub-board appearance for each element. Check repetition at the end. \\n        tags = []\\n        for i in range(9):\\n            for j in range(9):\\n                ele = board[i][j]\\n                if ele != \\'.\\':\\n                    tags.append(f\\'{ele} @ {i}th row\\')\\n                    tags.append(f\\'{ele} @ {j}th col\\') \\n                    tags.append(f\\'{ele} @ {i//3}-{j//3}th subboard\\')\\n\\n        return len(tags) == len(set(tags))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2534738,
                "title": "typescript-javascript-map-hashset",
                "content": "This solution is technically constant time because the number of cells never exceeds 81\\n\\n```\\nconst EMPTY_CELL = \".\";\\nconst NUMBER_OF_CELLS = 81;\\nconst SUB_BOARD_WIDTH = 3;\\nconst SUB_BOARD_HEIGHT = 3;\\n\\nfunction isValidSudoku(board: string[][]): boolean {\\n  const rows = new Map<number, Set<number>>();\\n  const columns = new Map<number, Set<number>>();\\n  const boxes = new Map<number, Set<number>>();\\n  \\n  for(let i = 0 ; i < NUMBER_OF_CELLS ; i++){\\n    const row = Math.floor(i / 9);\\n    const column = i % 9;\\n    const box =  Math.floor(row / 3) * 3 + Math.floor(column / 3);\\n    const cell = Number(board[row][column]);\\n    \\n    // if empty cell, skip\\n    if(isNaN(cell)) continue;\\n    \\n    // initialize sets if not initialized for\\n    // row, column, or box\\n    if(!rows.has(row)) rows.set(row, new Set<number>());\\n    if(!columns.has(column)) columns.set(column, new Set<number>());\\n    if(!boxes.has(box)) boxes.set(box, new Set<number>());\\n    \\n    // if the cell value was seen before, this means\\n    // this is an invalid sudoku, return false\\n    if(rows.get(row).has(cell)) return false;\\n    if(columns.get(column).has(cell)) return false;\\n    if(boxes.get(box).has(cell)) return false;\\n    \\n    // if we haven\\'t seen the cell before, add it to\\n    // row, column, and box\\n    rows.get(row).add(cell)\\n    columns.get(column).add(cell)\\n    boxes.get(box).add(cell)\\n  }\\n  \\n  \\n  // if we manage to exit the loop without breaking\\n  // sudoku rules, then this is a valid sudoku\\n  return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst EMPTY_CELL = \".\";\\nconst NUMBER_OF_CELLS = 81;\\nconst SUB_BOARD_WIDTH = 3;\\nconst SUB_BOARD_HEIGHT = 3;\\n\\nfunction isValidSudoku(board: string[][]): boolean {\\n  const rows = new Map<number, Set<number>>();\\n  const columns = new Map<number, Set<number>>();\\n  const boxes = new Map<number, Set<number>>();\\n  \\n  for(let i = 0 ; i < NUMBER_OF_CELLS ; i++){\\n    const row = Math.floor(i / 9);\\n    const column = i % 9;\\n    const box =  Math.floor(row / 3) * 3 + Math.floor(column / 3);\\n    const cell = Number(board[row][column]);\\n    \\n    // if empty cell, skip\\n    if(isNaN(cell)) continue;\\n    \\n    // initialize sets if not initialized for\\n    // row, column, or box\\n    if(!rows.has(row)) rows.set(row, new Set<number>());\\n    if(!columns.has(column)) columns.set(column, new Set<number>());\\n    if(!boxes.has(box)) boxes.set(box, new Set<number>());\\n    \\n    // if the cell value was seen before, this means\\n    // this is an invalid sudoku, return false\\n    if(rows.get(row).has(cell)) return false;\\n    if(columns.get(column).has(cell)) return false;\\n    if(boxes.get(box).has(cell)) return false;\\n    \\n    // if we haven\\'t seen the cell before, add it to\\n    // row, column, and box\\n    rows.get(row).add(cell)\\n    columns.get(column).add(cell)\\n    boxes.get(box).add(cell)\\n  }\\n  \\n  \\n  // if we manage to exit the loop without breaking\\n  // sudoku rules, then this is a valid sudoku\\n  return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2494087,
                "title": "easy-100-fully-explained-java-clean-solution-two-approaches",
                "content": "# **Java Solution:**\\n```\\n/** First Approach **/\\n\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        // Base case...\\n        if (board == null || board.length != 9 || board[0].length != 9)\\n\\t\\t    return false;\\n        \\n\\t    //For each column check that their is repeatation of any digit present in filled cells...\\n\\t    for (int i = 0; i < 9; i++) {\\n\\t\\t    boolean[] set = new boolean[9];\\n\\t\\t    for (int j = 0; j < 9; j++) {\\n                // For filled cells only...\\n\\t\\t\\t    if (board[i][j] != \\'.\\') {\\n                    // That number-1, is its index in every checking array...\\n\\t\\t\\t\\t    if (set[(int) (board[i][j] - \\'1\\')]) {\\n\\t\\t\\t\\t\\t    return false;\\n\\t\\t\\t\\t    }\\n\\t\\t\\t\\t    set[(int) (board[i][j] - \\'1\\')] = true;\\n\\t\\t\\t    }\\n\\t\\t    }\\n\\t    }\\n\\n\\t    // For each row check that their is repeatation of any digit present in filled cells...\\n\\t    for (int j = 0; j < 9; j++) {\\n\\t\\t    boolean[] set = new boolean[9];\\n\\t\\t    for (int i = 0; i < 9; i++) {\\n                // For filled cells only\\n\\t\\t\\t    if (board[i][j] != \\'.\\') {\\n                    // That number-1, is its index in every checking array...\\n\\t\\t\\t\\t    if (set[(int) (board[i][j] - \\'1\\')]) {\\n\\t\\t\\t\\t\\t    return false;\\n\\t\\t\\t\\t    }\\n\\t\\t\\t\\t    set[(int) (board[i][j] - \\'1\\')] = true;\\n\\t\\t\\t    }\\n\\t\\t    }\\n\\t    }\\n \\n\\t    // Check that every 3*3 grid must contain different values means no repeatation of any digit present in filled cells...\\n\\t    for (int grid = 0; grid < 9; grid++) {\\n\\t\\t    boolean[] set = new boolean[9];\\n            // Traverse each grid through the loops...\\n\\t\\t    for (int i = grid / 3 * 3; i < grid / 3 * 3 + 3; i++) {\\n\\t\\t\\t    for (int j = grid % 3 * 3; j < grid % 3 * 3 + 3; j++) {\\n                    // For filled cells only...\\n\\t\\t\\t\\t    if (board[i][j] != \\'.\\') {\\n                        // That number-1, is its index in every checking array\\n\\t\\t\\t\\t\\t    if (set[(int) (board[i][j] - \\'1\\')]) {\\n\\t\\t\\t\\t\\t\\t    return false;\\n\\t\\t\\t\\t\\t    }\\n\\t\\t\\t\\t\\t    set[(int) (board[i][j] - \\'1\\')] = true;\\n\\t\\t\\t\\t    }\\n\\t\\t\\t    }\\n\\t\\t    }\\n\\t    }\\n\\t    return true;\\n    }\\n}\\n\\n__________________________________________________________________________________________________________________________________________________________________\\n\\n\\n/** Second Approach **/\\n\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        Set<String> set = new HashSet<>();\\n        // Traverse all the elements of all the boxes through loops...\\n        for (int i = 0; i < 9; ++i)\\n            for (int j = 0; j < 9; ++j) {\\n                // For filled cells only...\\n                if (board[i][j] == \\'.\\')\\n                    continue;\\n                final char ch = board[i][j];\\n                // Check each row, column & 3x3 box...\\n                if (!set.add(ch + \"@row\" + i) || !set.add(ch + \"@col\" + j) || !set.add(ch + \"@box\" + i/3 + j/3))\\n                    return false;\\n            }\\n        return true;\\n    }\\n}\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\n/** First Approach **/\\n\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        // Base case...\\n        if (board == null || board.length != 9 || board[0].length != 9)\\n\\t\\t    return false;\\n        \\n\\t    //For each column check that their is repeatation of any digit present in filled cells...\\n\\t    for (int i = 0; i < 9; i++) {\\n\\t\\t    boolean[] set = new boolean[9];\\n\\t\\t    for (int j = 0; j < 9; j++) {\\n                // For filled cells only...\\n\\t\\t\\t    if (board[i][j] != \\'.\\') {\\n                    // That number-1, is its index in every checking array...\\n\\t\\t\\t\\t    if (set[(int) (board[i][j] - \\'1\\')]) {\\n\\t\\t\\t\\t\\t    return false;\\n\\t\\t\\t\\t    }\\n\\t\\t\\t\\t    set[(int) (board[i][j] - \\'1\\')] = true;\\n\\t\\t\\t    }\\n\\t\\t    }\\n\\t    }\\n\\n\\t    // For each row check that their is repeatation of any digit present in filled cells...\\n\\t    for (int j = 0; j < 9; j++) {\\n\\t\\t    boolean[] set = new boolean[9];\\n\\t\\t    for (int i = 0; i < 9; i++) {\\n                // For filled cells only\\n\\t\\t\\t    if (board[i][j] != \\'.\\') {\\n                    // That number-1, is its index in every checking array...\\n\\t\\t\\t\\t    if (set[(int) (board[i][j] - \\'1\\')]) {\\n\\t\\t\\t\\t\\t    return false;\\n\\t\\t\\t\\t    }\\n\\t\\t\\t\\t    set[(int) (board[i][j] - \\'1\\')] = true;\\n\\t\\t\\t    }\\n\\t\\t    }\\n\\t    }\\n \\n\\t    // Check that every 3*3 grid must contain different values means no repeatation of any digit present in filled cells...\\n\\t    for (int grid = 0; grid < 9; grid++) {\\n\\t\\t    boolean[] set = new boolean[9];\\n            // Traverse each grid through the loops...\\n\\t\\t    for (int i = grid / 3 * 3; i < grid / 3 * 3 + 3; i++) {\\n\\t\\t\\t    for (int j = grid % 3 * 3; j < grid % 3 * 3 + 3; j++) {\\n                    // For filled cells only...\\n\\t\\t\\t\\t    if (board[i][j] != \\'.\\') {\\n                        // That number-1, is its index in every checking array\\n\\t\\t\\t\\t\\t    if (set[(int) (board[i][j] - \\'1\\')]) {\\n\\t\\t\\t\\t\\t\\t    return false;\\n\\t\\t\\t\\t\\t    }\\n\\t\\t\\t\\t\\t    set[(int) (board[i][j] - \\'1\\')] = true;\\n\\t\\t\\t\\t    }\\n\\t\\t\\t    }\\n\\t\\t    }\\n\\t    }\\n\\t    return true;\\n    }\\n}\\n\\n__________________________________________________________________________________________________________________________________________________________________\\n\\n\\n/** Second Approach **/\\n\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        Set<String> set = new HashSet<>();\\n        // Traverse all the elements of all the boxes through loops...\\n        for (int i = 0; i < 9; ++i)\\n            for (int j = 0; j < 9; ++j) {\\n                // For filled cells only...\\n                if (board[i][j] == \\'.\\')\\n                    continue;\\n                final char ch = board[i][j];\\n                // Check each row, column & 3x3 box...\\n                if (!set.add(ch + \"@row\" + i) || !set.add(ch + \"@col\" + j) || !set.add(ch + \"@box\" + i/3 + j/3))\\n                    return false;\\n            }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2466662,
                "title": "java-hashset-with-minimal-lines-of-code",
                "content": "```\\npublic boolean isValidSudoku(char[][] board) {\\n        HashSet<String> set = new HashSet<>();\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                char currVal = board[i][j];\\n                if(currVal!=\\'.\\'){\\n                    if(!set.add(currVal+\" found in row \"+i) ||\\n                        !set.add(currVal+\" found in column \"+j) ||\\n                        !set.add(currVal+\" found in sub Box \"+i/3+j/3))\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isValidSudoku(char[][] board) {\\n        HashSet<String> set = new HashSet<>();\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                char currVal = board[i][j];\\n                if(currVal!=\\'.\\'){\\n                    if(!set.add(currVal+\" found in row \"+i) ||\\n                        !set.add(currVal+\" found in column \"+j) ||\\n                        !set.add(currVal+\" found in sub Box \"+i/3+j/3))\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1668785,
                "title": "java-clean-code",
                "content": "```\\nimport java.util.HashSet;\\n\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<String> hs = new HashSet<>();\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    String r = \\'r\\' + \"-\" + i + \"-\" + board[i][j];\\n                    String c = \\'c\\' + \"-\" + j + \"-\" + board[i][j];\\n                    String rc = (i / 3) + \"-\" + board[i][j] + \"-\" + (j / 3);\\n                    if (!hs.add(r) || !hs.add(c) || !hs.add(rc)) \\n                        return false;\\n\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.HashSet;\\n\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<String> hs = new HashSet<>();\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    String r = \\'r\\' + \"-\" + i + \"-\" + board[i][j];\\n                    String c = \\'c\\' + \"-\" + j + \"-\" + board[i][j];\\n                    String rc = (i / 3) + \"-\" + board[i][j] + \"-\" + (j / 3);\\n                    if (!hs.add(r) || !hs.add(c) || !hs.add(rc)) \\n                        return false;\\n\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1622505,
                "title": "pythonic-python",
                "content": "Very python\\n\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \"\"\"\\n        Let\\'s keep tracking each element and see where they belong\\n        \"\"\"\\n        \\n        # Initialize tackers for each row, column and box\\n        row = {i: [] for i in range(9)}\\n        col = {i: [] for i in range(9)}\\n        box = {i: [] for i in range(9)}\\n        \\n        for i in range(9):\\n            for j in range(9):\\n                e = board[i][j]\\n                box_index = (i // 3) * 3 + j // 3\\n                \\n                if e == \\'.\\':\\n                    continue\\n                    \\n                if e in row[i] or e in col[j] or e in box[box_index]:\\n                    return False\\n                else:\\n                    row[i].append(e)\\n                    col[j].append(e)\\n                    box[box_index].append(e)\\n                    \\n        return True\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \"\"\"\\n        Let\\'s keep tracking each element and see where they belong\\n        \"\"\"\\n        \\n        # Initialize tackers for each row, column and box\\n        row = {i: [] for i in range(9)}\\n        col = {i: [] for i in range(9)}\\n        box = {i: [] for i in range(9)}\\n        \\n        for i in range(9):\\n            for j in range(9):\\n                e = board[i][j]\\n                box_index = (i // 3) * 3 + j // 3\\n                \\n                if e == \\'.\\':\\n                    continue\\n                    \\n                if e in row[i] or e in col[j] or e in box[box_index]:\\n                    return False\\n                else:\\n                    row[i].append(e)\\n                    col[j].append(e)\\n                    box[box_index].append(e)\\n                    \\n        return True\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1320921,
                "title": "python-clean-soln",
                "content": "```\\ndef isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        cols = defaultdict(set)\\n        rows = defaultdict(set)\\n        squares = defaultdict(set)\\n\\n        for r in range(9):\\n            for c in range(9):\\n                if board[r][c] == \\'.\\':\\n                    continue\\n                if (board[r][c] in rows[r] or board[r][c] in cols[c] or\\n                        board[r][c] in squares[(r//3, c//3)]):\\n                    return False\\n\\n                rows[r].add(board[r][c])\\n                cols[c].add(board[r][c])\\n                squares[(r//3, c//3)].add(board[r][c])\\n\\n        return True\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        cols = defaultdict(set)\\n        rows = defaultdict(set)\\n        squares = defaultdict(set)\\n\\n        for r in range(9):\\n            for c in range(9):\\n                if board[r][c] == \\'.\\':\\n                    continue\\n                if (board[r][c] in rows[r] or board[r][c] in cols[c] or\\n                        board[r][c] in squares[(r//3, c//3)]):\\n                    return False\\n\\n                rows[r].add(board[r][c])\\n                cols[c].add(board[r][c])\\n                squares[(r//3, c//3)].add(board[r][c])\\n\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1151068,
                "title": "python-clean-easy-solution",
                "content": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        seen = set()\\n        for i in range(9):\\n            for j in range(9):\\n                number = str(board[i][j])\\n                if number != \\'.\\':\\n                    row = number +\\'in row\\' + str(i)\\n                    col = number +\\'in col\\' + str(j)\\n                    # // for integer\\n                    block = number +\\'in block\\' + str(i//3) + str(j//3)\\n                    if row in seen or col in seen or block in seen:\\n                        return False\\n                    seen.add(row)\\n                    seen.add(col)\\n                    seen.add(block)\\n        return True\\n                    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        seen = set()\\n        for i in range(9):\\n            for j in range(9):\\n                number = str(board[i][j])\\n                if number != \\'.\\':\\n                    row = number +\\'in row\\' + str(i)\\n                    col = number +\\'in col\\' + str(j)\\n                    # // for integer\\n                    block = number +\\'in block\\' + str(i//3) + str(j//3)\\n                    if row in seen or col in seen or block in seen:\\n                        return False\\n                    seen.add(row)\\n                    seen.add(col)\\n                    seen.add(block)\\n        return True\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 410216,
                "title": "easy-to-understand-c-solution-8ms-beats-98",
                "content": "Runtime: 8 ms, faster than 98.48% of C++ online submissions for Valid Sudoku.\\nMemory Usage: 9.8 MB, less than 58.97% of C++ online submissions for Valid Sudoku.\\n\\n```\\n bool isValidSudoku(vector<vector<char>>& board) {\\n        \\n        //check for each row\\n        for(int r=0; r<board.size(); r++)\\n        {\\n            vector<int> mpRow(10,0);\\n            for(int elem=0; elem < board[0].size(); elem++)\\n            {\\n                if(\\'1\\' <= board[r][elem] && board[r][elem] <= \\'9\\')\\n                    mpRow[board[r][elem]-\\'0\\']++;\\n            }\\n            \\n            for(int i=1; i<10; i++)\\n            {\\n                if(mpRow[i] > 1)\\n                    return false;\\n            }\\n        }\\n        \\n        //check for each col\\n        for(int c=0; c<board[0].size(); c++)\\n        {\\n            vector<int> mpCol(10,0);\\n            for(int elem=0; elem < board.size(); elem++)\\n            {\\n                if(\\'1\\' <= board[elem][c] && board[elem][c] <= \\'9\\')\\n                    mpCol[board[elem][c]-\\'0\\']++;\\n            }\\n            \\n            for(int i=1; i<10; i++)\\n            {\\n                if(mpCol[i] > 1)\\n                    return false;\\n            }\\n        }\\n        \\n        //check for 3*3 cells\\n        for(int i=0; i<9; i+=3)\\n        {\\n            for(int j=0; j<9; j+=3)\\n            {\\n                vector<int> mpBox(10,0);\\n                for(int k=i; k<i+3; k++)\\n                {\\n                    for(int l=j; l<j+3; l++)\\n                    {\\n                        if(\\'1\\' <= board[k][l] && board[k][l] <= \\'9\\')\\n                            mpBox[board[k][l]-\\'0\\']++;\\n                    }\\n                }\\n                \\n                for(int i=1; i<10; i++)\\n                {\\n                    if(mpBox[i] > 1)\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "Runtime: 8 ms, faster than 98.48% of C++ online submissions for Valid Sudoku.\\nMemory Usage: 9.8 MB, less than 58.97% of C++ online submissions for Valid Sudoku.\\n\\n```\\n bool isValidSudoku(vector<vector<char>>& board) {\\n        \\n        //check for each row\\n        for(int r=0; r<board.size(); r++)\\n        {\\n            vector<int> mpRow(10,0);\\n            for(int elem=0; elem < board[0].size(); elem++)\\n            {\\n                if(\\'1\\' <= board[r][elem] && board[r][elem] <= \\'9\\')\\n                    mpRow[board[r][elem]-\\'0\\']++;\\n            }\\n            \\n            for(int i=1; i<10; i++)\\n            {\\n                if(mpRow[i] > 1)\\n                    return false;\\n            }\\n        }\\n        \\n        //check for each col\\n        for(int c=0; c<board[0].size(); c++)\\n        {\\n            vector<int> mpCol(10,0);\\n            for(int elem=0; elem < board.size(); elem++)\\n            {\\n                if(\\'1\\' <= board[elem][c] && board[elem][c] <= \\'9\\')\\n                    mpCol[board[elem][c]-\\'0\\']++;\\n            }\\n            \\n            for(int i=1; i<10; i++)\\n            {\\n                if(mpCol[i] > 1)\\n                    return false;\\n            }\\n        }\\n        \\n        //check for 3*3 cells\\n        for(int i=0; i<9; i+=3)\\n        {\\n            for(int j=0; j<9; j+=3)\\n            {\\n                vector<int> mpBox(10,0);\\n                for(int k=i; k<i+3; k++)\\n                {\\n                    for(int l=j; l<j+3; l++)\\n                    {\\n                        if(\\'1\\' <= board[k][l] && board[k][l] <= \\'9\\')\\n                            mpBox[board[k][l]-\\'0\\']++;\\n                    }\\n                }\\n                \\n                for(int i=1; i<10; i++)\\n                {\\n                    if(mpBox[i] > 1)\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 338064,
                "title": "javascript-13-lines-short-solution",
                "content": "```\\nvar isValidSudoku = function(board) {\\n  for (let i = 0; i < 9; i++) {\\n    let row = new Set(), col = new Set(), sqr = new Set();\\n    for (let j = 0; j < 9; j++) {\\n      let rowc = board[i][j];\\n      let colc = board[j][i];\\n      let sqrc = board[Math.floor(i / 3) * 3 + Math.floor(j / 3)][(i % 3) * 3 + j % 3];\\n      if (row.has(rowc) || col.has(colc) || sqr.has(sqrc)) return false;\\n      if (rowc !== \".\") row.add(rowc);\\n      if (colc !== \".\") col.add(colc);\\n      if (sqrc !== \".\") sqr.add(sqrc);\\n    }\\n  }\\n  return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isValidSudoku = function(board) {\\n  for (let i = 0; i < 9; i++) {\\n    let row = new Set(), col = new Set(), sqr = new Set();\\n    for (let j = 0; j < 9; j++) {\\n      let rowc = board[i][j];\\n      let colc = board[j][i];\\n      let sqrc = board[Math.floor(i / 3) * 3 + Math.floor(j / 3)][(i % 3) * 3 + j % 3];\\n      if (row.has(rowc) || col.has(colc) || sqr.has(sqrc)) return false;\\n      if (rowc !== \".\") row.add(rowc);\\n      if (colc !== \".\") col.add(colc);\\n      if (sqrc !== \".\") sqr.add(sqrc);\\n    }\\n  }\\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 15455,
                "title": "simple-ruby-solution-using-sets",
                "content": "The idea is to initialize a set per collection of (1-9) characters that we care about (each row, each column, and each box) to ensure that there are no duplicate numbers, which would make the solution invalid.\\n\\n```\\ndef is_valid_sudoku(board)\\n    boxes = Array.new(3) { Array.new(3) { Set.new } }\\n    rows = Array.new(9) { Set.new }\\n    cols = Array.new(9) { Set.new }\\n    \\n    board.each_with_index do |array, row|\\n        array.each_with_index do |num, col|\\n            next if num == '.'\\n            return false unless boxes[row/3][col/3].add?(num) && rows[row].add?(num) && cols[col].add?(num)\\n        end\\n    end\\n    true\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef is_valid_sudoku(board)\\n    boxes = Array.new(3) { Array.new(3) { Set.new } }\\n    rows = Array.new(9) { Set.new }\\n    cols = Array.new(9) { Set.new }\\n    \\n    board.each_with_index do |array, row|\\n        array.each_with_index do |num, col|\\n            next if num == '.'\\n            return false unless boxes[row/3][col/3].add?(num) && rows[row].add?(num) && cols[col].add?(num)\\n        end\\n    end\\n    true\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3427605,
                "title": "simple-swift-solution-easy-to-understand",
                "content": "# Approach\\nThe solution iterates through each `row` of the board. For each `row`, it creates a new `set` to keep track of the digits seen so far. It then iterates through each cell of the `row` and checks if the cell is empty or not. If the cell is not empty, it checks if the digit already exists in the `set` or not. If the digit already exists in the `set`, it returns `false` as it violates the Sudoku rule. Otherwise, it adds the digit to the `set` and continues to the next cell. If the iteration completes without finding any violation, it continues to the next `row`.\\n\\nThe solution then iterates through each `column` of the board. For each `column`, it creates a new `set` to keep track of the digits seen so far. It then iterates through each cell of the `column` and checks if the cell is empty or not. If the cell is not empty, it checks if the digit already exists in the `set` or not. If the digit already exists in the `set`, it returns `false` as it violates the Sudoku rule. Otherwise, it adds the digit to the `set` and continues to the next cell. If the iteration completes without finding any violation, it continues to the next `column`.\\n\\nThe solution then iterates through each $$3 \\\\times 3$$ sub-box of the board. For each $$3 \\\\times 3$$ sub-box, it creates a new `set` to keep track of the digits seen so far. It then iterates through each cell of the sub-box and checks if the cell is empty or not. If the cell is not empty, it checks if the digit already exists in the `set` or not. If the digit already exists in the `set`, it returns `false` as it violates the Sudoku rule. Otherwise, it adds the digit to the `set` and continues to the next cell. If the iteration completes without finding any violation, it continues to the next $$3 \\\\times 3$$ sub-box.\\n\\nIf the solution completes all iterations without finding any violation, it returns `true` indicating that the board is a valid Sudoku board. Otherwise, it returns `false` indicating that the board is not valid.\\n\\n# Complexity\\nThe *time complexity* of the given solution is $$O(n^2)$$, where $$n$$ is the number of cells in the Sudoku board.\\n\\nThe *space complexity* of the solution is $$O(n)$$, where $$n$$ is the number of cells in the Sudoku board.\\n\\n# Code\\n```\\nclass Solution {\\n    func isValidSudoku(_ board: [[Character]]) -> Bool {\\n        for i in 0 ..< 9 {\\n            var set = Set<Character>()\\n            for j in 0 ..< 9 {\\n                if board[i][j] != \".\", set.contains(board[i][j]) {\\n                    return false\\n                }\\n                set.insert(board[i][j])\\n            }\\n        }\\n\\n        for j in 0 ..< 9 {\\n            var set = Set<Character>()\\n            for i in 0 ..< 9 {\\n                if board[i][j] != \".\", set.contains(board[i][j]) {\\n                    return false\\n                }\\n                set.insert(board[i][j])\\n            }\\n        }\\n\\n        for k in 0 ..< 9 {\\n            var set = Set<Character>()\\n            for i in k / 3 * 3 ..< k / 3 * 3 + 3 {\\n                for j in k % 3 * 3 ..< k % 3 * 3 + 3 {\\n                    if board[i][j] != \".\", set.contains(board[i][j]) {\\n                        return false\\n                    }\\n                    set.insert(board[i][j])\\n                }\\n            }\\n        }\\n\\n        return true\\n    }\\n}\\n```\\n\\n# Upvote ^^\\n\\n![upvote.png](https://assets.leetcode.com/users/images/241e5676-737d-4137-ab6b-440f1d715ee1_1681748155.5014086.png)\\n",
                "solutionTags": [
                    "Swift",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    func isValidSudoku(_ board: [[Character]]) -> Bool {\\n        for i in 0 ..< 9 {\\n            var set = Set<Character>()\\n            for j in 0 ..< 9 {\\n                if board[i][j] != \".\", set.contains(board[i][j]) {\\n                    return false\\n                }\\n                set.insert(board[i][j])\\n            }\\n        }\\n\\n        for j in 0 ..< 9 {\\n            var set = Set<Character>()\\n            for i in 0 ..< 9 {\\n                if board[i][j] != \".\", set.contains(board[i][j]) {\\n                    return false\\n                }\\n                set.insert(board[i][j])\\n            }\\n        }\\n\\n        for k in 0 ..< 9 {\\n            var set = Set<Character>()\\n            for i in k / 3 * 3 ..< k / 3 * 3 + 3 {\\n                for j in k % 3 * 3 ..< k % 3 * 3 + 3 {\\n                    if board[i][j] != \".\", set.contains(board[i][j]) {\\n                        return false\\n                    }\\n                    set.insert(board[i][j])\\n                }\\n            }\\n        }\\n\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140050,
                "title": "simple-java-c-easy-readable-3-lines-code-100-working",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet <String> seen = new HashSet <>();\\n        \\n        for (int i = 0; i < 9; i ++) {\\n            for (int j = 0; j < 9; j ++) {\\n                char cur = board[i][j];\\n                if(cur != \\'.\\') if(!seen.add(cur + \"row\" + i)||!seen.add(cur + \"col\" + j)||!seen.add(cur + \"grid\" + i / 3 + \"-\" + j / 3)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet <String> seen = new HashSet <>();\\n        \\n        for (int i = 0; i < 9; i ++) {\\n            for (int j = 0; j < 9; j ++) {\\n                char cur = board[i][j];\\n                if(cur != \\'.\\') if(!seen.add(cur + \"row\" + i)||!seen.add(cur + \"col\" + j)||!seen.add(cur + \"grid\" + i / 3 + \"-\" + j / 3)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843298,
                "title": "python-3-explained-solution-beginner-friendly",
                "content": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        #checking for each row if a value doesn\\'t repeat \\n        for row in range(9): #for each row\\n            row_values=[] #we create a list of values that are in the row\\n            for col in range(9): #we go through each column\\n                if board[row][col] != \".\": #if there is a number \\n                    if board[row][col] in row_values: #and the number is already in the list of values that are in the row => repetition \\n                        return False #sudoku is not valid\\n                    row_values.append(board[row][col]) #if the number is not in the list of values that are in the row, we add it\\n                    \\n        #checking for each col if a value doesn\\'t repeat\\n        for col in range(9): #for each column\\n            col_values=[] #we create a list of values that are in the column\\n            for row in range(9): #we go through each row\\n                if board[row][col] != \".\": #if there is a number\\n                    if board[row][col] in col_values: #and the number is already in the list of values that are in the column => repetition\\n                        return False #sudoku is not valid \\n                    col_values.append(board[row][col]) #if the number is not in the list of values that are in the column, we add it\\n    \\n        #checking for each 3*3 squares\\n        #the combination of squares are : \\n\\t\\t#[0,1,2][0,1,2] [0,1,2][3,4,5] [0,1,2][6,7,8]\\n\\t\\t#[3,4,5][0,1,2] [3,4,5][3,4,5] [3,4,5][6,7,8]\\n\\t\\t#[6,7,8][0,1,2] [6,7,8][3,4,5] [6,7,8][6,7,8]\\n\\t\\tlist = [[0,1,2], [3,4,5], [6,7,8]] \\n\\t\\t#those squares are the combination of the same indexes so we create a list to iterate upon with i and j\\n        for i in range(3): \\n            for j in range(3):\\n                square_values = [] #for each square we create a list of value that are in the square\\n                for col in list[i]: #we\\'re gonna go through 3 columns (1st : col 0, col 1 & col 2, then : col 3, col 4 & col 5 and finally : col 6, col 7, col 8)\\n                    for row in list[j]:#and 3 rows (1st : row 0, row 1 & row 2, then : row 3, row 4 & row 5 and finally : row 6, row 7, row 8)\\n                        if board[row][col] != \".\": #if there is a number \\n                            if board[row][col] in square_values: #and the number is already in the list of values that are in the square\\n                                return False #sudoku isn\\'t valid\\n                            square_values.append(board[row][col]) #if the number is not in the list of values that are in the square, we add it \\n        \\n        return True #if we could not find invalid sudoku in those 3 cases, then sudoku is valid\\n```\\nPlease upvote if it does help ! :)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        #checking for each row if a value doesn\\'t repeat \\n        for row in range(9): #for each row\\n            row_values=[] #we create a list of values that are in the row\\n            for col in range(9): #we go through each column\\n                if board[row][col] != \".\": #if there is a number \\n                    if board[row][col] in row_values: #and the number is already in the list of values that are in the row => repetition \\n                        return False #sudoku is not valid\\n                    row_values.append(board[row][col]) #if the number is not in the list of values that are in the row, we add it\\n                    \\n        #checking for each col if a value doesn\\'t repeat\\n        for col in range(9): #for each column\\n            col_values=[] #we create a list of values that are in the column\\n            for row in range(9): #we go through each row\\n                if board[row][col] != \".\": #if there is a number\\n                    if board[row][col] in col_values: #and the number is already in the list of values that are in the column => repetition\\n                        return False #sudoku is not valid \\n                    col_values.append(board[row][col]) #if the number is not in the list of values that are in the column, we add it\\n    \\n        #checking for each 3*3 squares\\n        #the combination of squares are : \\n\\t\\t#[0,1,2][0,1,2] [0,1,2][3,4,5] [0,1,2][6,7,8]\\n\\t\\t#[3,4,5][0,1,2] [3,4,5][3,4,5] [3,4,5][6,7,8]\\n\\t\\t#[6,7,8][0,1,2] [6,7,8][3,4,5] [6,7,8][6,7,8]\\n\\t\\tlist = [[0,1,2], [3,4,5], [6,7,8]] \\n\\t\\t#those squares are the combination of the same indexes so we create a list to iterate upon with i and j\\n        for i in range(3): \\n            for j in range(3):\\n                square_values = [] #for each square we create a list of value that are in the square\\n                for col in list[i]: #we\\'re gonna go through 3 columns (1st : col 0, col 1 & col 2, then : col 3, col 4 & col 5 and finally : col 6, col 7, col 8)\\n                    for row in list[j]:#and 3 rows (1st : row 0, row 1 & row 2, then : row 3, row 4 & row 5 and finally : row 6, row 7, row 8)\\n                        if board[row][col] != \".\": #if there is a number \\n                            if board[row][col] in square_values: #and the number is already in the list of values that are in the square\\n                                return False #sudoku isn\\'t valid\\n                            square_values.append(board[row][col]) #if the number is not in the list of values that are in the square, we add it \\n        \\n        return True #if we could not find invalid sudoku in those 3 cases, then sudoku is valid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841289,
                "title": "c-using-set-comments-added-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) \\n    {\\n        map<int,set<int>> rows;                                      // for keep cheking the previous row value\\n        map<int,set<int>> cols;                                       // for keep cheking the previous col value\\n        map<pair<int,int>,set<int>> subBox;                 // for keep cheking the previous curr 3x3 matrix value by pair\\n        \\n        for(int r=0;r<9;r++)                                              // each row\\n        {\\n            for(int c=0;c<9;c++)                                        // each col\\n            {\\n                // if it is . skip it\\n                if(board[r][c]==\\'.\\') continue;\\n                \\n                // if we found current value previously then return false\\n                \\n                // Check row\\n                if(rows[r].find(board[r][c]-\\'0\\') != rows[r].end())\\n                    return false;\\n                \\n                // check col\\n                if(cols[c].find(board[r][c]-\\'0\\') != cols[c].end())\\n                    return false;\\n                \\n                // check sub boxes\\n\\t\\t\\t\\t// (r/3,c/3) will tell the curr sub Box as we are taking them from (0,0) to (2,2)\\n                if(subBox[{r/3,c/3}].find(board[r][c]-\\'0\\') != subBox[{r/3,c/3}].end())\\n                    return false;\\n                \\n                \\n                // if none of then return false then add curr board value to the declared set for next check\\n                rows[r].insert(board[r][c]-\\'0\\');\\n                cols[c].insert(board[r][c]-\\'0\\');\\n                subBox[{r/3,c/3}].insert(board[r][c]-\\'0\\');\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) \\n    {\\n        map<int,set<int>> rows;                                      // for keep cheking the previous row value\\n        map<int,set<int>> cols;                                       // for keep cheking the previous col value\\n        map<pair<int,int>,set<int>> subBox;                 // for keep cheking the previous curr 3x3 matrix value by pair\\n        \\n        for(int r=0;r<9;r++)                                              // each row\\n        {\\n            for(int c=0;c<9;c++)                                        // each col\\n            {\\n                // if it is . skip it\\n                if(board[r][c]==\\'.\\') continue;\\n                \\n                // if we found current value previously then return false\\n                \\n                // Check row\\n                if(rows[r].find(board[r][c]-\\'0\\') != rows[r].end())\\n                    return false;\\n                \\n                // check col\\n                if(cols[c].find(board[r][c]-\\'0\\') != cols[c].end())\\n                    return false;\\n                \\n                // check sub boxes\\n\\t\\t\\t\\t// (r/3,c/3) will tell the curr sub Box as we are taking them from (0,0) to (2,2)\\n                if(subBox[{r/3,c/3}].find(board[r][c]-\\'0\\') != subBox[{r/3,c/3}].end())\\n                    return false;\\n                \\n                \\n                // if none of then return false then add curr board value to the declared set for next check\\n                rows[r].insert(board[r][c]-\\'0\\');\\n                cols[c].insert(board[r][c]-\\'0\\');\\n                subBox[{r/3,c/3}].insert(board[r][c]-\\'0\\');\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2840703,
                "title": "c-hashset-faster-easy-to-understand",
                "content": "* ***Using Hashset***\\n\\n* ***Time Complexity :- O(N * N)***\\n\\n* ***Space Complexity :- O(N * N)***\\n\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& mat) {\\n        \\n        // declare a set\\n        \\n        unordered_set<string> s;\\n        \\n        // box number for any cell [i, j] is (i / 3) * + j / 3, taking (3 * 3) boxes\\n        \\n        for(int i = 0; i < 9; i++)\\n        {\\n            for(int j = 0; j < 9; j++)\\n            {\\n                if(mat[i][j] != \\'.\\')\\n                {\\n                    // if the curr number is already present in set\\n                    \\n                    if(s.count(\"row\" + to_string(i) + \"*\" + to_string(mat[i][j])))\\n                    {\\n                        return false;\\n                    }\\n                \\n                    if(s.count(\"col\" + to_string(j) + \"*\" + to_string(mat[i][j])))\\n                    {\\n                         return false;\\n                    }\\n                \\n                    if(s.count(\"box\" + to_string((i / 3) * 3 + j / 3) + \"*\" + to_string(mat[i][j])))\\n                    {\\n                        return false;\\n                    }\\n                    \\n                    // insert the curr number in set with row no., col no., box no.\\n                \\n                    s.insert(\"row\" + to_string(i) + \"*\" + to_string(mat[i][j]));\\n                \\n                    s.insert(\"col\" + to_string(j) + \"*\" + to_string(mat[i][j]));\\n                \\n                    s.insert(\"box\" + to_string((i / 3) * 3 + j / 3) + \"*\" + to_string(mat[i][j]));\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& mat) {\\n        \\n        // declare a set\\n        \\n        unordered_set<string> s;\\n        \\n        // box number for any cell [i, j] is (i / 3) * + j / 3, taking (3 * 3) boxes\\n        \\n        for(int i = 0; i < 9; i++)\\n        {\\n            for(int j = 0; j < 9; j++)\\n            {\\n                if(mat[i][j] != \\'.\\')\\n                {\\n                    // if the curr number is already present in set\\n                    \\n                    if(s.count(\"row\" + to_string(i) + \"*\" + to_string(mat[i][j])))\\n                    {\\n                        return false;\\n                    }\\n                \\n                    if(s.count(\"col\" + to_string(j) + \"*\" + to_string(mat[i][j])))\\n                    {\\n                         return false;\\n                    }\\n                \\n                    if(s.count(\"box\" + to_string((i / 3) * 3 + j / 3) + \"*\" + to_string(mat[i][j])))\\n                    {\\n                        return false;\\n                    }\\n                    \\n                    // insert the curr number in set with row no., col no., box no.\\n                \\n                    s.insert(\"row\" + to_string(i) + \"*\" + to_string(mat[i][j]));\\n                \\n                    s.insert(\"col\" + to_string(j) + \"*\" + to_string(mat[i][j]));\\n                \\n                    s.insert(\"box\" + to_string((i / 3) * 3 + j / 3) + \"*\" + to_string(mat[i][j]));\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423241,
                "title": "c-best-explanation-simple-100-faster",
                "content": "**Approach**\\n**1. Brute Force**\\n(a) - You can use 3 nested loops \\n(b) - For checking rows,column and box seperately.\\n\\n**2. Using a Single loop**\\n(a) - Make vectors of sets.\\n(b) - Each vector contain 9 sets. i.e, *9 set for rows, 9 set for column & 9 for box.*\\n(c) - Check if element is present in the box or not.\\n(d) - If Present, **return false**.\\n(e) - If Not Present, insert it into set and check for next element.\\n\\n`For accessing box set we use this formula  (i/3)*3 + (j/3)`\\n\\n![image](https://assets.leetcode.com/users/images/740929b0-0a47-4a0f-bd75-cc83920148c2_1660460466.4924154.jpeg)\\n\\n**Code :-**\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        \\n        vector<set<int>> row(9),col(9),box(9);\\n        \\n        for(int i=0;i< 9;i++)\\n        {\\n            for(int j = 0;j < 9;j++)\\n            {\\n                if(board[i][j] != \\'.\\')\\n                {\\n                    int num = board[i][j] - \\'0\\';\\n                    \\n                    if(row[i].count(num) || col[j].count(num) || box[(i/3)*3 + (j/3)].count(num))\\n                    {\\n                        return false;\\n                    }\\n                    \\n                    row[i].insert(num);\\n                    col[j].insert(num);\\n                    box[(i/3)*3 + (j/3)].insert(num);\\n            \\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        \\n        vector<set<int>> row(9),col(9),box(9);\\n        \\n        for(int i=0;i< 9;i++)\\n        {\\n            for(int j = 0;j < 9;j++)\\n            {\\n                if(board[i][j] != \\'.\\')\\n                {\\n                    int num = board[i][j] - \\'0\\';\\n                    \\n                    if(row[i].count(num) || col[j].count(num) || box[(i/3)*3 + (j/3)].count(num))\\n                    {\\n                        return false;\\n                    }\\n                    \\n                    row[i].insert(num);\\n                    col[j].insert(num);\\n                    box[(i/3)*3 + (j/3)].insert(num);\\n            \\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2151963,
                "title": "c-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        unordered_map<string, int> seen;\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                int element = board[i][j];\\n                // skip if the cell is not filled\\n                if(element == \\'.\\')\\n                    continue;\\n                \\n                // string for each element found at a row to store in hashmap\\n                string rowFind = to_string(element) + \"found at row\" + to_string(i);\\n                \\n                // string for each element found at a column to store in hashmap\\n                string colFind = to_string(element) + \"found at column\" + to_string(j);\\n                \\n                // string for each element found at a sub-box to store in hashmap\\n                string boxFind = to_string(element) + \"found at box\" + to_string(i/3) + \\'-\\' + to_string(j/3);\\n                \\n                // checking if those are already inside hashmap, if not we\\'ll be putting em into hashmap\\n                if(seen.find(rowFind) != seen.end() ||\\n                   seen.find(colFind) != seen.end() ||\\n                   seen.find(boxFind) != seen.end()){\\n                    return false;\\n                }\\n                else{\\n                    seen[rowFind]++;\\n                    seen[colFind]++;\\n                    seen[boxFind]++;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        unordered_map<string, int> seen;\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                int element = board[i][j];\\n                // skip if the cell is not filled\\n                if(element == \\'.\\')\\n                    continue;\\n                \\n                // string for each element found at a row to store in hashmap\\n                string rowFind = to_string(element) + \"found at row\" + to_string(i);\\n                \\n                // string for each element found at a column to store in hashmap\\n                string colFind = to_string(element) + \"found at column\" + to_string(j);\\n                \\n                // string for each element found at a sub-box to store in hashmap\\n                string boxFind = to_string(element) + \"found at box\" + to_string(i/3) + \\'-\\' + to_string(j/3);\\n                \\n                // checking if those are already inside hashmap, if not we\\'ll be putting em into hashmap\\n                if(seen.find(rowFind) != seen.end() ||\\n                   seen.find(colFind) != seen.end() ||\\n                   seen.find(boxFind) != seen.end()){\\n                    return false;\\n                }\\n                else{\\n                    seen[rowFind]++;\\n                    seen[colFind]++;\\n                    seen[boxFind]++;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1527978,
                "title": "java-short-solution",
                "content": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        HashSet<String> set = new HashSet<>();\\n        \\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++){\\n                \\n                if(board[i][j] != \\'.\\'){\\n                    \\n                    if(!set.add(\"row\" + i+ board[i][j]) || !set.add(\"col\" + j + board[i][j]) || !set.add(\"box\" + (i/3) *3+j/3 + board[i][j] )){\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        HashSet<String> set = new HashSet<>();\\n        \\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++){\\n                \\n                if(board[i][j] != \\'.\\'){\\n                    \\n                    if(!set.add(\"row\" + i+ board[i][j]) || !set.add(\"col\" + j + board[i][j]) || !set.add(\"box\" + (i/3) *3+j/3 + board[i][j] )){\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1462256,
                "title": "js-set-time-and-space-o-1",
                "content": "```\\n\\n//approach: using set\\n//as I loop through the board\\'s col and row, I will make sure to put the element inside the set\\n//we know same row, col and the subBox cannot have the same value more than once, if it does, return false\\n\\nvar isValidSudoku = function(board) {\\n    let set = new Set();\\n    \\n    for(let r = 0; r < board.length; r++){\\n        for(let c = 0; c < board[r].length; c++){\\n            let val = board[r][c];\\n            \\n            if(val === \\'.\\')\\n                continue;\\n            \\n            //basically, formula is 3 * row + col --> to turn 2d array into 1d array\\n            //using Math.floor(row/3) + Math.floor(col/3) --> so we can find row and col of our sub box \\n            let boxNum = 3 * Math.floor(r/3) + Math.floor(c/3);\\n            \\n            let inRow = `row: ${r}, value: ${val}`;\\n            let inCol = `col: ${c}, value: ${val}`;\\n            let inSubBox = `subBox: ${boxNum}, value: ${val}`;\\n            \\n            if(set.has(inRow) || set.has(inCol) || set.has(inSubBox))\\n                return false;\\n            \\n            set.add(inRow);\\n            set.add(inCol);\\n            set.add(inSubBox);\\n        }\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\n\\n//approach: using set\\n//as I loop through the board\\'s col and row, I will make sure to put the element inside the set\\n//we know same row, col and the subBox cannot have the same value more than once, if it does, return false\\n\\nvar isValidSudoku = function(board) {\\n    let set = new Set();\\n    \\n    for(let r = 0; r < board.length; r++){\\n        for(let c = 0; c < board[r].length; c++){\\n            let val = board[r][c];\\n            \\n            if(val === \\'.\\')\\n                continue;\\n            \\n            //basically, formula is 3 * row + col --> to turn 2d array into 1d array\\n            //using Math.floor(row/3) + Math.floor(col/3) --> so we can find row and col of our sub box \\n            let boxNum = 3 * Math.floor(r/3) + Math.floor(c/3);\\n            \\n            let inRow = `row: ${r}, value: ${val}`;\\n            let inCol = `col: ${c}, value: ${val}`;\\n            let inSubBox = `subBox: ${boxNum}, value: ${val}`;\\n            \\n            if(set.has(inRow) || set.has(inCol) || set.has(inSubBox))\\n                return false;\\n            \\n            set.add(inRow);\\n            set.add(inCol);\\n            set.add(inSubBox);\\n        }\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 684745,
                "title": "98-5-time-python3-using-prime-numbers",
                "content": "Assign each value (1-9) to a unique prime number, doesn\\'t matter which.\\n\\nFor each container, e.g. row,col, or box, assign its value to be the product of all the chosen primes.\\n\\nWhen you encounter a value x in some container, divide that container\\'s value by x. If this division results in a non-zero remainder, you know the container is invalid. This works because the remainder will only be nonzero if we\\'ve divided by x more than once. \\n\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        primes = [2,3,5,7,11,13,17,19,23]\\n        prod = 1\\n        for p in primes:\\n            prod *= p\\n        boxes = [prod] * 9\\n        rows = [prod] * 9\\n        cols = [prod] * 9\\n        for r in range(9):\\n            for c in range(9):\\n                s = board[r][c]\\n                if s == \".\":\\n                    continue\\n                b = (r // 3) * 3 + c // 3\\n                p = primes[int(s)-1]\\n                if boxes[b] % p != 0:\\n                    return False\\n                boxes[b] /= p\\n                if rows[r] % p != 0:\\n                    return False\\n                rows[r] /= p\\n                if cols[c] % p != 0:\\n                    return False\\n                cols[c] /= p\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        primes = [2,3,5,7,11,13,17,19,23]\\n        prod = 1\\n        for p in primes:\\n            prod *= p\\n        boxes = [prod] * 9\\n        rows = [prod] * 9\\n        cols = [prod] * 9\\n        for r in range(9):\\n            for c in range(9):\\n                s = board[r][c]\\n                if s == \".\":\\n                    continue\\n                b = (r // 3) * 3 + c // 3\\n                p = primes[int(s)-1]\\n                if boxes[b] % p != 0:\\n                    return False\\n                boxes[b] /= p\\n                if rows[r] % p != 0:\\n                    return False\\n                rows[r] /= p\\n                if cols[c] % p != 0:\\n                    return False\\n                cols[c] /= p\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15552,
                "title": "python-solution-simple-and-fast",
                "content": "    class Solution(object):\\n    def isValidSudoku(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: bool\\n        \"\"\"\\n    \\n        map_row = [{} for _ in xrange(9)]\\n        map_col = [{} for _ in xrange(9)]\\n        map_cell = [[{} for _ in xrange(3)] for __ in xrange(3)]\\n        for i in xrange(9):\\n            for j in xrange(9):\\n                char = board[i][j]\\n                if char == '.': continue\\n                if char in map_row[i]: return False\\n                else: map_row[i][char] = [i,j]\\n                if char in map_col[j]: return False\\n                else: map_col[j][char] = [i,j]\\n                if char in map_cell[i/3][j/3]: return False\\n                else: map_cell[i/3][j/3][char] = [i,j]\\n        return True",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):\\n    def isValidSudoku(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: bool\\n        \"\"\"\\n    \\n        map_row = [{}",
                "codeTag": "Java"
            },
            {
                "id": 4073241,
                "title": "simple-java-solutions-runtime-2ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java\\nclass Solution {\\n   public boolean isValidSudoku(char[][] board) {\\n\\n         for (int i = 0; i < 9; i++) {\\n            HashSet<Character> RowSet = new HashSet<>();\\n            HashSet<Character> ColSet = new HashSet<>();\\n            for (int j = 0; j < 9; j++) {\\n                char r = board[i][j];\\n                char c = board[j][i];\\n                if ( (r != \\'.\\' && !RowSet.add(r) ) || (c != \\'.\\' && !ColSet.add(c))) {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < 9; i = i + 3) {\\n            for (int j = 0; j < 9; j = j + 3) {\\n                if (!checkBlock(i, j, board))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public static boolean checkBlock(int IdI, int IdJ, char[][] boards) {\\n        HashSet<Character> set = new HashSet<>();\\n\\n        int rows = IdI + 3;\\n        int cols = IdJ + 3;\\n        for (int i = IdI; i < rows; i++) {\\n            for (int j = IdJ; j < cols; j++) {\\n                char c = boards[i][j];\\n                if (c != \\'.\\' && !set.add(c)) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n![abcd1.jpeg](https://assets.leetcode.com/users/images/19750e74-99dc-4312-82af-f5aaa467fe64_1695313499.690562.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n   public boolean isValidSudoku(char[][] board) {\\n\\n         for (int i = 0; i < 9; i++) {\\n            HashSet<Character> RowSet = new HashSet<>();\\n            HashSet<Character> ColSet = new HashSet<>();\\n            for (int j = 0; j < 9; j++) {\\n                char r = board[i][j];\\n                char c = board[j][i];\\n                if ( (r != \\'.\\' && !RowSet.add(r) ) || (c != \\'.\\' && !ColSet.add(c))) {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < 9; i = i + 3) {\\n            for (int j = 0; j < 9; j = j + 3) {\\n                if (!checkBlock(i, j, board))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public static boolean checkBlock(int IdI, int IdJ, char[][] boards) {\\n        HashSet<Character> set = new HashSet<>();\\n\\n        int rows = IdI + 3;\\n        int cols = IdJ + 3;\\n        for (int i = IdI; i < rows; i++) {\\n            for (int j = IdJ; j < cols; j++) {\\n                char c = boards[i][j];\\n                if (c != \\'.\\' && !set.add(c)) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2842282,
                "title": "brute-force-c-solution-working-fine",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        map<char, int> mp;\\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                if(board[i][j] != \\'.\\')\\n                mp[board[i][j]]++;\\n            }\\n            for(auto x : mp){\\n                if(x.second > 1)\\n                return false;\\n            }\\n            mp.clear();\\n        }\\n\\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                if(board[j][i] != \\'.\\')\\n                mp[board[j][i]]++;\\n            }\\n            for(auto x : mp){\\n                if(x.second > 1)\\n                return false;\\n            }\\n            mp.clear();\\n        }\\n        for(int m=0; m<9; m+=3){\\n            for(int i=0; i<9; i+=3){\\n                for(int j=m; j<m+3; j++){\\n                    for(int k=i; k<i+3; k++){\\n                        if(board[j][k] != \\'.\\')\\n                        mp[board[j][k]]++;\\n                    }\\n                }\\n                for(auto x : mp){\\n                    if(x.second > 1)\\n                    return false;\\n                }\\n                mp.clear();\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        map<char, int> mp;\\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                if(board[i][j] != \\'.\\')\\n                mp[board[i][j]]++;\\n            }\\n            for(auto x : mp){\\n                if(x.second > 1)\\n                return false;\\n            }\\n            mp.clear();\\n        }\\n\\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                if(board[j][i] != \\'.\\')\\n                mp[board[j][i]]++;\\n            }\\n            for(auto x : mp){\\n                if(x.second > 1)\\n                return false;\\n            }\\n            mp.clear();\\n        }\\n        for(int m=0; m<9; m+=3){\\n            for(int i=0; i<9; i+=3){\\n                for(int j=m; j<m+3; j++){\\n                    for(int k=i; k<i+3; k++){\\n                        if(board[j][k] != \\'.\\')\\n                        mp[board[j][k]]++;\\n                    }\\n                }\\n                for(auto x : mp){\\n                    if(x.second > 1)\\n                    return false;\\n                }\\n                mp.clear();\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841489,
                "title": "rust-iterators-14-lines-4mc",
                "content": "```\\nfn uniq<\\'a>(it: impl Iterator<Item = &\\'a char>) -> bool {\\n    let mut v = [0; 10];\\n    it.filter_map(|c| c.to_digit(10))\\n        .for_each(|c| v[c as usize] += 1);\\n    v.iter().all(|&v| v < 2)\\n}\\n\\nimpl Solution {\\n    pub fn is_valid_sudoku(board: Vec<Vec<char>>) -> bool {\\n        let block_it = |i, j| board[i..i + 3].iter().flat_map(move |row| &row[j..j + 3]);\\n\\n        (0..3).all(|i| (0..3).all(|j| uniq(block_it(i * 3, j * 3))))\\n            && (0..9).all(|i| uniq(board.iter().map(|row| &row[i])))\\n            && board.iter().map(|v| v.iter()).all(uniq)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Iterator"
                ],
                "code": "```\\nfn uniq<\\'a>(it: impl Iterator<Item = &\\'a char>) -> bool {\\n    let mut v = [0; 10];\\n    it.filter_map(|c| c.to_digit(10))\\n        .for_each(|c| v[c as usize] += 1);\\n    v.iter().all(|&v| v < 2)\\n}\\n\\nimpl Solution {\\n    pub fn is_valid_sudoku(board: Vec<Vec<char>>) -> bool {\\n        let block_it = |i, j| board[i..i + 3].iter().flat_map(move |row| &row[j..j + 3]);\\n\\n        (0..3).all(|i| (0..3).all(|j| uniq(block_it(i * 3, j * 3))))\\n            && (0..9).all(|i| uniq(board.iter().map(|row| &row[i])))\\n            && board.iter().map(|v| v.iter()).all(uniq)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2807940,
                "title": "easy-c-solution-explanation-in-simple-hinglish-for-intuition",
                "content": "Pure sudoku board ko 9 boxes/grid mein divide kar do aur numbering 0 to 8 kar do\\n0 1 2\\n3 4 5 \\n6 7 8\\n\\nHar ek box ek grid ki tarah hai to ab usko calculate karne ka formula hai :=\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t(row/3)*3+(col/3)\\n\\npure ke pure value ko string bana ke attach kar do= \"ROW+row_val+element\".....\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tsimilarly column aur box ke liye karo.\\n\\nFir set mein check karo kya pehle se row ya col ya grid ka strings set mein h?? \\nAgar hai to false return kar do nai to insert kar do.\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        set<string> s;\\n        for(int i=0;i<9;i++)\\n        {\\n            for(int j=0;j<9;j++)\\n            {\\n                if(board[i][j]!=\\'.\\')\\n                {\\n                    string row=\"row\"+to_string(i)+board[i][j];\\n                    string col=\"col\"+to_string(j)+board[i][j];\\n                    string box=\"box\"+to_string((i/3)*3+(j/3))+board[i][j];\\n                    \\n                    if(s.find(row)==s.end() && s.find(col)==s.end() && s.find(box)==s.end())\\n                    {\\n                        s.insert(row);\\n                        s.insert(col);\\n                        s.insert(box);\\n                    }\\n                    else\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        set<string> s;\\n        for(int i=0;i<9;i++)\\n        {\\n            for(int j=0;j<9;j++)\\n            {\\n                if(board[i][j]!=\\'.\\')\\n                {\\n                    string row=\"row\"+to_string(i)+board[i][j];\\n                    string col=\"col\"+to_string(j)+board[i][j];\\n                    string box=\"box\"+to_string((i/3)*3+(j/3))+board[i][j];\\n                    \\n                    if(s.find(row)==s.end() && s.find(col)==s.end() && s.find(box)==s.end())\\n                    {\\n                        s.insert(row);\\n                        s.insert(col);\\n                        s.insert(box);\\n                    }\\n                    else\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1504217,
                "title": "python-hashset-simple-solution",
                "content": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        # Validate each row\\n        for r in range(9):\\n            hashSet = set()\\n            for c in range(9):\\n                if board[r][c] != \\'.\\':\\n                    if board[r][c] in hashSet:\\n                        return False\\n                    hashSet.add(board[r][c])\\n        \\n        # Validate each column\\n        for c in range(9):\\n            hashSet = set()\\n            for r in range(9):\\n                if board[r][c] != \\'.\\':\\n                    if board[r][c] in hashSet:\\n                        return False\\n                    hashSet.add(board[r][c])\\n        \\n        # Validate each box\\n        r, c = 0, 0\\n        while True:\\n            hashSet = set()\\n            for i in range(r, r+3):\\n                for j in range(c, c+3):\\n                    if board[i][j] != \\'.\\':\\n                        if board[i][j] in hashSet:\\n                            return False\\n                        hashSet.add(board[i][j])\\n            c += 3\\n            if c == 9:\\n                r += 3\\n                # Break if we have verified all 9 boxes\\n                if r == 9:\\n                    break\\n                c = 0\\n        return True\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        # Validate each row\\n        for r in range(9):\\n            hashSet = set()\\n            for c in range(9):\\n                if board[r][c] != \\'.\\':\\n                    if board[r][c] in hashSet:\\n                        return False\\n                    hashSet.add(board[r][c])\\n        \\n        # Validate each column\\n        for c in range(9):\\n            hashSet = set()\\n            for r in range(9):\\n                if board[r][c] != \\'.\\':\\n                    if board[r][c] in hashSet:\\n                        return False\\n                    hashSet.add(board[r][c])\\n        \\n        # Validate each box\\n        r, c = 0, 0\\n        while True:\\n            hashSet = set()\\n            for i in range(r, r+3):\\n                for j in range(c, c+3):\\n                    if board[i][j] != \\'.\\':\\n                        if board[i][j] in hashSet:\\n                            return False\\n                        hashSet.add(board[i][j])\\n            c += 3\\n            if c == 9:\\n                r += 3\\n                # Break if we have verified all 9 boxes\\n                if r == 9:\\n                    break\\n                c = 0\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488448,
                "title": "c-just-12-lines-of-code-no-space-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& ar) {\\n        \\n        for(int i=0;i<ar.size();i++)\\n            for(int j=0;j<ar.size();j++)\\n                if(ar[i][j] != \\'.\\'){\\n                    for(int k=0;k<9;k++)\\n                        if( (i!=k && ar[k][j]==ar[i][j]) || (j!=k && ar[i][k]==ar[i][j]) )\\n                            return 0;\\n                    for(int row=3*(i/3); row<3*(i/3)+3; row++)\\n                        for(int col=3*(j/3); col<3*(j/3)+3; col++)\\n                            if( (row!=i || col!=j) && ar[row][col]==ar[i][j])\\n                                return 0;\\n                }\\n        return 1;\\n    }\\n};\\n\\nHit like if found helpful : )",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& ar) {\\n        \\n        for(int i=0;i<ar.size();i++)\\n            for(int j=0;j<ar.size();j++)\\n                if(ar[i][j] != \\'.\\'){\\n                    for(int k=0;k<9;k++)\\n                        if( (i!=k && ar[k][j]==ar[i][j]) || (j!=k && ar[i][k]==ar[i][j]) )\\n                            return 0;\\n                    for(int row=3*(i/3); row<3*(i/3)+3; row++)\\n                        for(int col=3*(j/3); col<3*(j/3)+3; col++)\\n                            if( (row!=i || col!=j) && ar[row][col]==ar[i][j])\\n                                return 0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1471156,
                "title": "1ms-java-solution-brute-force-hashmap-hashset",
                "content": "**HashMap**\\n```\\n    public boolean isValidSudoku(char[][] board) {\\n        Map<String, Integer> map = new HashMap<>();\\n        \\n        for(int i=0; i<9; i++)\\n            for(int j=0; j<9; j++)\\n                if(board[i][j] != \\'.\\') {\\n                    \\n                    String row = board[i][j] + \" row \" + i;\\n                    String col = board[i][j] + \" col \" + j;\\n                    String box = board[i][j] + \" box \" + i/3 + \"and\" + j/3;\\n                    \\n                    map.put(row, map.getOrDefault(row, 0) + 1);\\n                    map.put(col, map.getOrDefault(col, 0) + 1);\\n                    map.put(box, map.getOrDefault(box, 0) + 1);\\n                    \\n                    if(map.get(row) > 1 || map.get(col) > 1 || map.get(box) > 1)\\n                        return false;\\n                }\\n                \\n        return true;\\n    }\\n```\\nSimilarly, You can implement this using HahsSet.\\n\\n**Brute force**\\n```\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        boolean[][] row = new boolean[9][9];\\n        boolean[][] col = new boolean[9][9];\\n        boolean[][] box = new boolean[9][9];\\n        \\n        for (int i = 0; i < 9; i++)\\n            for (int j = 0; j < 9; j++)\\n                if (board[i][j] != \\'.\\') {\\n                    \\n                    int n = board[i][j] - \\'1\\';\\n                    \\n                    if (row[n][i]) \\n                        return false;\\n                    row[n][i] = true;\\n                    \\n                    if (col[n][j]) \\n                        return false;\\n                    col[n][j] = true;\\n                    \\n                    int bi = (i / 3) * 3 + (j / 3);\\n                    \\n                    if (box[n][bi]) \\n                        return false;\\n                    box[n][bi] = true;\\n                }\\n                \\n        return true;\\n    }\\n```\\n\\n**Please UPVOTE ^ If this post is useful for you.**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public boolean isValidSudoku(char[][] board) {\\n        Map<String, Integer> map = new HashMap<>();\\n        \\n        for(int i=0; i<9; i++)\\n            for(int j=0; j<9; j++)\\n                if(board[i][j] != \\'.\\') {\\n                    \\n                    String row = board[i][j] + \" row \" + i;\\n                    String col = board[i][j] + \" col \" + j;\\n                    String box = board[i][j] + \" box \" + i/3 + \"and\" + j/3;\\n                    \\n                    map.put(row, map.getOrDefault(row, 0) + 1);\\n                    map.put(col, map.getOrDefault(col, 0) + 1);\\n                    map.put(box, map.getOrDefault(box, 0) + 1);\\n                    \\n                    if(map.get(row) > 1 || map.get(col) > 1 || map.get(box) > 1)\\n                        return false;\\n                }\\n                \\n        return true;\\n    }\\n```\n```\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        boolean[][] row = new boolean[9][9];\\n        boolean[][] col = new boolean[9][9];\\n        boolean[][] box = new boolean[9][9];\\n        \\n        for (int i = 0; i < 9; i++)\\n            for (int j = 0; j < 9; j++)\\n                if (board[i][j] != \\'.\\') {\\n                    \\n                    int n = board[i][j] - \\'1\\';\\n                    \\n                    if (row[n][i]) \\n                        return false;\\n                    row[n][i] = true;\\n                    \\n                    if (col[n][j]) \\n                        return false;\\n                    col[n][j] = true;\\n                    \\n                    int bi = (i / 3) * 3 + (j / 3);\\n                    \\n                    if (box[n][bi]) \\n                        return false;\\n                    box[n][bi] = true;\\n                }\\n                \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1415732,
                "title": "kotlin-simple-easy-and-short-solution",
                "content": "```\\nclass Solution {\\n    fun isValidSudoku(board: Array<CharArray>): Boolean {\\n        val rowRecord = Array(9) { mutableSetOf<Char>() }\\n        val columnRecord = Array(9) { mutableSetOf<Char>() }\\n        val subBoxRecord = Array(9) { mutableSetOf<Char>() }\\n\\n        board.forEachIndexed { rowIndex, chars ->\\n            chars.forEachIndexed { columnIndex, c ->\\n                if (c in \\'1\\'..\\'9\\') {\\n                    val subBoxIndex = rowIndex / 3 * 3 + columnIndex / 3\\n                    if (!rowRecord[rowIndex].add(c)\\n                        || !columnRecord[columnIndex].add(c)\\n                        || !subBoxRecord[subBoxIndex].add(c)) {\\n                        return false\\n                    }\\n                }\\n            }\\n        }\\n\\n        return true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    fun isValidSudoku(board: Array<CharArray>): Boolean {\\n        val rowRecord = Array(9) { mutableSetOf<Char>() }\\n        val columnRecord = Array(9) { mutableSetOf<Char>() }\\n        val subBoxRecord = Array(9) { mutableSetOf<Char>() }\\n\\n        board.forEachIndexed { rowIndex, chars ->\\n            chars.forEachIndexed { columnIndex, c ->\\n                if (c in \\'1\\'..\\'9\\') {\\n                    val subBoxIndex = rowIndex / 3 * 3 + columnIndex / 3\\n                    if (!rowRecord[rowIndex].add(c)\\n                        || !columnRecord[columnIndex].add(c)\\n                        || !subBoxRecord[subBoxIndex].add(c)) {\\n                        return false\\n                    }\\n                }\\n            }\\n        }\\n\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 700753,
                "title": "python-solution",
                "content": "The goal of this problem is to check if the current board is valid or not.\\nLet\\'s define what it means to be valid in a game of sudoku:\\n1. Each row should have unique numbers from 1 - 9\\n2. Each column should have unique numbers from 1 - 9\\n3. Each box should have unique numbers from 1 - 9\\n\\nThus, this means if we hold the values of each row, column, and box and check for duplicates, we will be able to check if the board is valid or not.\\nThe trickiest part would be to check the duplicate values for each box.\\nOne way to do this would be to name each box as 0~8, and consider the box as (row // 3)*3 + (col // 3).\\n\\n```\\ndef isValidSudoku(self, board):\\n\\trows = [set() for i in range(9)]\\n\\tcols = [set() for i in range(9)]\\n\\tboxes = [set() for i in range(9)]\\n\\t#quadrant = (row / 3) * 3 + (col / 3)\\n\\tfor row in range(len(board)):\\n\\t\\tfor col in range(len(board)):\\n\\t\\t\\tif board[row][col] == \\'.\\':\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tnumber = board[row][col]\\n\\t\\t\\tbox = (row // 3) * 3 + col // 3\\n\\t\\t\\tif number in rows[row] or number in cols[col] or number in boxes[box]:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\trows[row].add(number)\\n\\t\\t\\tcols[col].add(number)\\n\\t\\t\\tboxes[box].add(number)\\n\\treturn True\\n```\\n",
                "solutionTags": [],
                "code": "```\\ndef isValidSudoku(self, board):\\n\\trows = [set() for i in range(9)]\\n\\tcols = [set() for i in range(9)]\\n\\tboxes = [set() for i in range(9)]\\n\\t#quadrant = (row / 3) * 3 + (col / 3)\\n\\tfor row in range(len(board)):\\n\\t\\tfor col in range(len(board)):\\n\\t\\t\\tif board[row][col] == \\'.\\':\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tnumber = board[row][col]\\n\\t\\t\\tbox = (row // 3) * 3 + col // 3\\n\\t\\t\\tif number in rows[row] or number in cols[col] or number in boxes[box]:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\trows[row].add(number)\\n\\t\\t\\tcols[col].add(number)\\n\\t\\t\\tboxes[box].add(number)\\n\\treturn True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 304054,
                "title": "java-beats-100",
                "content": "```java\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int[] rows = new int[9], cols = new int[9], squares = new int[9];\\n        for(int r=0; r<board.length; r++){\\n            for(int c=0; c<board[0].length; c++){\\n                if(board[r][c] != \\'.\\'){\\n                    int value = (1 << (board[r][c] - \\'1\\'));\\n                    if((value & rows[r]) > 0 || (value & cols[c]) > 0 || (value & squares[3*(r/3)+c/3]) > 0) return false;\\n                    rows[r] |= value;\\n                    cols[c] |= value;\\n                    squares[3*(r/3)+c/3] |= value;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int[] rows = new int[9], cols = new int[9], squares = new int[9];\\n        for(int r=0; r<board.length; r++){\\n            for(int c=0; c<board[0].length; c++){\\n                if(board[r][c] != \\'.\\'){\\n                    int value = (1 << (board[r][c] - \\'1\\'));\\n                    if((value & rows[r]) > 0 || (value & cols[c]) > 0 || (value & squares[3*(r/3)+c/3]) > 0) return false;\\n                    rows[r] |= value;\\n                    cols[c] |= value;\\n                    squares[3*(r/3)+c/3] |= value;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15493,
                "title": "c-o-n-2-solution",
                "content": "```\\npublic class Solution {\\n    public bool IsValidSudoku(char[,] board) {\\n        for(var i=0;i<9;++i){\\n            var col = new HashSet<char>();\\n            var row = new HashSet<char>();\\n            var sub = new HashSet<char>();\\n\\n            for(var j=0;j<9;j++){\\n                \\n                if(board[i,j]!='.' && col.Contains(board[i,j])) return false;\\n                col.Add(board[i,j]);\\n                \\n                if(board[j,i]!='.' && row.Contains(board[j,i])) return false;\\n                row.Add(board[j,i]);\\n                \\n                var x = (i%3)*3 + j%3;\\n                var y = (i/3)*3 + j/3;\\n                if(board[x,y]!='.' && sub.Contains(board[x,y])) return false;\\n                sub.Add(board[x,y]);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool IsValidSudoku(char[,] board) {\\n        for(var i=0;i<9;++i){\\n            var col = new HashSet<char>();\\n            var row = new HashSet<char>();\\n            var sub = new HashSet<char>();\\n\\n            for(var j=0;j<9;j++){\\n                \\n                if(board[i,j]!='.' && col.Contains(board[i,j])) return false;\\n                col.Add(board[i,j]);\\n                \\n                if(board[j,i]!='.' && row.Contains(board[j,i])) return false;\\n                row.Add(board[j,i]);\\n                \\n                var x = (i%3)*3 + j%3;\\n                var y = (i/3)*3 + j/3;\\n                if(board[x,y]!='.' && sub.Contains(board[x,y])) return false;\\n                sub.Add(board[x,y]);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15612,
                "title": "simple-solution-with-explanation",
                "content": "For this problem, just according to the define of Sudoku, \\n\\n1. row: in the row, there can't have  same number.\\n\\n2. column: in the  column, there can't have  same number.\\n\\n3. 3 * 3 grid:  in the 3 * 3 grid, there can't have  same number.\\n\\nwe can get a simple solution. One place to need to pay attention to is board[i / 3 * 3][j / 3 * 3] is the top left of the 3 * 3 grid.\\n\\n    public static boolean isValidSudoku(char[][] board) {\\n\\t\\tfor (int i = 0; i < 9; i++) {\\n\\t\\t\\tfor (int j = 0; j < 9; j++) {\\n\\t\\t\\t\\tif (board[i][j] == '.')\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif (!isValid(board, i, j))\\n\\t\\t\\t\\t\\treturn false;\\t\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true; \\n    }\\n\\tprivate static  boolean isValid(char[][] board, int i, int j) {\\n\\t\\tfor (int m = 0; m < 9; m++) {\\n\\t\\t\\tif (m != j && board[i][m] == board[i][j]) // row\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tif (m != i && board[m][j] == board[i][j]) // column\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tfor (int m = i / 3 * 3; m < i / 3 * 3 + 3; m++) { // 3 * 3 grid\\n\\t\\t\\tfor (int n = j / 3 * 3; n < j / 3 * 3 + 3; n++) {\\n\\t\\t\\t\\tif (m != i && n != j && board[m][n] == board[i][j])\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}",
                "solutionTags": [],
                "code": "For this problem, just according to the define of Sudoku, \\n\\n1. row: in the row, there can't have  same number.\\n\\n2. column: in the  column, there can't have  same number.\\n\\n3. 3 * 3 grid:  in the 3 * 3 grid, there can't have  same number.\\n\\nwe can get a simple solution. One place to need to pay attention to is board[i / 3 * 3][j / 3 * 3] is the top left of the 3 * 3 grid.\\n\\n    public static boolean isValidSudoku(char[][] board) {\\n\\t\\tfor (int i = 0; i < 9; i++) {\\n\\t\\t\\tfor (int j = 0; j < 9; j++) {\\n\\t\\t\\t\\tif (board[i][j] == '.')\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif (!isValid(board, i, j))\\n\\t\\t\\t\\t\\treturn false;\\t\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true; \\n    }\\n\\tprivate static  boolean isValid(char[][] board, int i, int j) {\\n\\t\\tfor (int m = 0; m < 9; m++) {\\n\\t\\t\\tif (m != j && board[i][m] == board[i][j]) // row\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tif (m != i && board[m][j] == board[i][j]) // column\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tfor (int m = i / 3 * 3; m < i / 3 * 3 + 3; m++) { // 3 * 3 grid\\n\\t\\t\\tfor (int n = j / 3 * 3; n < j / 3 * 3 + 3; n++) {\\n\\t\\t\\t\\tif (m != i && n != j && board[m][n] == board[i][j])\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 15705,
                "title": "my-c-code-o-n2-time-and-space",
                "content": "The basic idea is to use an array to indicate whether a number in a row/column/3x3 sub-block already occurs. We need a 9x9 array existNum and\\na) the LSB of existNum[i][j] indicates whether number j occurs on the i-th row before\\nb) the 2-LSB of existNum[i][j] indicates whether number j occurs on the i-th column before\\nc) the 3-LSB of existNum[i][j] indicates whether number j occurs on the i-th sub-block before, k= (i/3)*3 + j/3\\n\\n\\n    class Solution {\\n    public:\\n        bool isValidSudoku(vector<vector<char> > &board) {\\n            char existNum[10][10]={0};\\n            int i,j;\\n            \\n            for(i=0; i<9; i++)\\n            {\\n                for(j=0; j<9; j++)\\n                {\\n                    if(board[i][j]!='.')\\n                    {\\n                        if(existNum[i][board[i][j] - '0'] & 0x1)return false; // check if the i-row already has such number, LSB\\n                        if(existNum[j][board[i][j] - '0'] & 0x2) return false; // check if the j-col already has such number, 2-LSB\\n                        if(existNum[(i/3) *3 + j/3][board[i][j] - '0'] & 0x4) return false; // check if the k-subblock already has such number, 3-LSB\\n                        existNum[i][board[i][j] - '0'] ^=0x1;\\n                        existNum[j][board[i][j] - '0'] ^=0x2;\\n                        existNum[(i/3) *3 + j/3][board[i][j] - '0'] ^=0x4;\\n                    }\\n                    \\n                }\\n            }\\n            \\n            return true;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isValidSudoku(vector<vector<char> > &board) {\\n            char existNum[10][10]={0}",
                "codeTag": "Java"
            },
            {
                "id": 3768728,
                "title": "100-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        return solve(board);\\n    }\\n     boolean solve(char[][]board)\\n    { for(int i=0;i<board.length;i++)\\n    {for(int j=0;j<board.length;j++)\\n    { if(board[i][j] != \\'.\\')\\n    { char num=board[i][j];\\n     board[i][j]=\\'.\\';\\n     if(!isSafe(board,i,j,num)) return false;\\n      else\\n    //backtrack\\n     board[i][j]=num;\\n     } }}\\n    return true; }\\n     boolean isSafe(char[][] board,int row,int col,char num)\\n    { // check the row\\n      for(int i=0;i<board.length;i++)\\n      { // check if the number is in the row\\n        if(board[i][col] == num)  return false;\\n         // check the column\\n        // check if the number is in the column\\n        if(board[row][i]== num) return false;\\n      }int sqrt=(int)(Math.sqrt(board.length));\\n      int rowStart=row - row % sqrt;\\n      int colStart=col - col % sqrt;\\n      for(int r=rowStart;r<rowStart + sqrt;r++)\\n      { for(int c=colStart;c<colStart + sqrt;c++)\\n       {if(board[r][c] == num)   return false; }\\n      }return true;\\n}\\n}\\n\\n```\\n![5kej8w.jpg](https://assets.leetcode.com/users/images/91a30870-3320-44a9-84bb-88a9fb3a4f2e_1689425161.7847996.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        return solve(board);\\n    }\\n     boolean solve(char[][]board)\\n    { for(int i=0;i<board.length;i++)\\n    {for(int j=0;j<board.length;j++)\\n    { if(board[i][j] != \\'.\\')\\n    { char num=board[i][j];\\n     board[i][j]=\\'.\\';\\n     if(!isSafe(board,i,j,num)) return false;\\n      else\\n    //backtrack\\n     board[i][j]=num;\\n     } }}\\n    return true; }\\n     boolean isSafe(char[][] board,int row,int col,char num)\\n    { // check the row\\n      for(int i=0;i<board.length;i++)\\n      { // check if the number is in the row\\n        if(board[i][col] == num)  return false;\\n         // check the column\\n        // check if the number is in the column\\n        if(board[row][i]== num) return false;\\n      }int sqrt=(int)(Math.sqrt(board.length));\\n      int rowStart=row - row % sqrt;\\n      int colStart=col - col % sqrt;\\n      for(int r=rowStart;r<rowStart + sqrt;r++)\\n      { for(int c=colStart;c<colStart + sqrt;c++)\\n       {if(board[r][c] == num)   return false; }\\n      }return true;\\n}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653296,
                "title": "c-easy-fully-explained-hindi-english-best",
                "content": "\\n\\n# Approach\\nThe question is asking us to check whether any integer between 1-9 appears more than once in a particular row, column, or 3x3 grid.\\n\\nFor this, we will create three hash arrays, a, b, and c. Array a will check whether any integer from 1 to 9 appears more than once in a particular row, array b will check whether any integer from 1 to 9 appears more than once in a particular column, and array c will check whether any integer from 1 to 9 appears more than once in a particular 3x3 grid.\\n\\nIf any of these conditions are true, we will return false; otherwise, we will return true\\n\\nk = i / 3 * 3 + j / 3\\nfor those who need to visualize k > here\\n\\n0 0 0 | 1 1 1 | 2 2 2\\n0 0 0 | 1 1 1 | 2 2 2\\n0 0 0 | 1 1 1 | 2 2 2\\n--------+---------+---------\\n3 3 3 | 4 4 4 | 5 5 5\\n3 3 3 | 4 4 4 | 5 5 5\\n3 3 3 | 4 4 4 | 5 5 5\\n--------+----------+--------\\n6 6 6 | 7 7 7 | 8 8 8\\n6 6 6 | 7 7 7 | 8 8 8\\n6 6 6 | 7 7 7 | 8 8 8\\n\\nPLease upvote the solution.****\\n\\nhindi-\\nEss question mai hame check karna hai ki koi integer{1-9} particular row ya coloum ya 3*3 ki grid mai ek se jayda baar na aaye .\\n\\niske liye ham a,b,c 3 hash array create karenge jisme A check karegi ki kya koi integer[1-9] ek row mai do baar toh nahi aa rha or B check karegi ki kya koi integer[1-9] ek coloum mai do baar toh nahi aa rha or C ka kaam hoga ki check karna ki kya koi integer[1-9] ek 3*3 ki grid mai do baar toh nahi aa rha agar isme se ek bhi condition true hoti hai to ham false return karenge else true return karenge\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int a[9][9]={0},b[9][9]={0},c[9][9]={0};\\n        for(int i=0;i<board.size();++i){\\n            for(int j=0;j<board.size();++j){\\n                if(board[i][j]!=\\'.\\'){\\n                    int num=board[i][j]-\\'0\\'-1;\\n                    int k= i / 3 * 3 + j / 3;\\n                    if(a[i][num]||b[j][num]||c[k][num]){\\n                        return false;\\n                    }\\n                        a[i][num]=b[j][num]=c[k][num]=1;\\n                    \\n                }\\n\\n            \\n            }\\n\\n        }\\n        return true;\\n\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int a[9][9]={0},b[9][9]={0},c[9][9]={0};\\n        for(int i=0;i<board.size();++i){\\n            for(int j=0;j<board.size();++j){\\n                if(board[i][j]!=\\'.\\'){\\n                    int num=board[i][j]-\\'0\\'-1;\\n                    int k= i / 3 * 3 + j / 3;\\n                    if(a[i][num]||b[j][num]||c[k][num]){\\n                        return false;\\n                    }\\n                        a[i][num]=b[j][num]=c[k][num]=1;\\n                    \\n                }\\n\\n            \\n            }\\n\\n        }\\n        return true;\\n\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613853,
                "title": "w-explanation-c-c-python-solution-uses-bool-arrays-bitsets-sets-as-hash-tables",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nFrom {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9>, boolean arrays or sets suffice to use for recording and checking and play the role of hash tables!! \\n\\nLeetcode 37. Sudoku Solver is also solved in the similar manner.\\n[https://leetcode.com/problems/sudoku-solver/solutions/3622243/w-explain-c-c-solves-via-backtracking-bool-arrays-in-3-ms/](https://leetcode.com/problems/sudoku-solver/solutions/3622243/w-explain-c-c-solves-via-backtracking-bool-arrays-in-3-ms/)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nC solution Runtime 8 ms Beats 92.31%.\\n[Please turn on English subtitles if neccessary]\\n[https://youtu.be/hkXrewUTqyc](https://youtu.be/hkXrewUTqyc)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bitset<9> Col[9];\\n        bitset<9> Row[9];\\n        bitset<9> Block[9];\\n\\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                char c = board[i][j];\\n                if (c == \\'.\\') continue;\\n                int x=(c-\\'0\\')%9; \\n                // Convert the character digit to an index (0-8) 0 for 9\\n\\n                if (Row[i][x]) return 0;\\n                Row[i][x] = 1;\\n\\n                if (Col[j][x]) return 0;\\n                Col[j][x] = 1;\\n                \\n                int bidx = (i / 3) * 3 + j / 3;\\n                if (Block[bidx][x]) return 0;\\n                Block[bidx][x] = 1;\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```\\n```C []\\nbool isValidSudoku(char** board, int boardSize, int* boardColSize)\\n{\\n    bool Col[9][9]={0};\\n    bool Row[9][9]={0};\\n    bool Block[9][9]={0};\\n\\n    for(int i=0; i<9; i++){\\n        for(int j=0; j<9; j++){\\n            char c = board[i][j];\\n            if (c == \\'.\\') continue;\\n            int x=(c-\\'0\\')%9; \\n            // Convert the character digit to an index (0-8) 0 for 9\\n\\n            if (Row[i][x]==1) return 0;\\n            Row[i][x] = 1;\\n\\n            if (Col[j][x]==1) return 0;\\n            Col[j][x] = 1;\\n                \\n            int bidx = (i / 3) * 3 + j / 3;\\n            if (Block[bidx][x]==1) return 0;\\n            Block[bidx][x] = 1;\\n        }\\n    }\\n    return 1;\\n}\\n```\\n```Python []\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        # Use sets\\n        Col = [set() for _ in range(9)]\\n        Row = [set() for _ in range(9)]\\n        Block = [set() for _ in range(9)]\\n\\n        for i in range(9):\\n            for j in range(9):\\n                c=board[i][j]\\n                if c==\\'.\\': continue\\n                x=(ord(c)-ord(\\'0\\'))%9\\n\\n                if x in Row[i]: return False\\n                Row[i].add(x)\\n\\n                if x in Col[j]: return False\\n                Col[j].add(x)\\n\\n                idx=i//3*3+j//3\\n                if x in Block[idx]: return False\\n                Block[idx].add(x)\\n        return True\\'\\n```\\nAnother approach uses C++ unordered_set for strings.\\n# C++ solution uses unordered_set\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        unordered_set<string> C;\\n        int n=0;\\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                char c = board[i][j];\\n                if (c != \\'.\\') {\\n                    n++;\\n                    string row=\"row\"+to_string(i)+c;\\n                    string col=\"col\"+to_string(j)+c;\\n                    int bidx = (i / 3) * 3 + j / 3;\\n                    string block=\"block\"+to_string(bidx)+c;\\n                    C.insert(row);\\n                    C.insert(col);\\n                    C.insert(block);\\n                }\\n            }\\n        }\\n        return C.size()==3*n;\\n    }\\n};\\n```\\nNext step is to use backtracking solving it!\\n[https://youtu.be/_B8ihi2SVSU](https://youtu.be/_B8ihi2SVSU)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bitset<9> Col[9];\\n        bitset<9> Row[9];\\n        bitset<9> Block[9];\\n\\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                char c = board[i][j];\\n                if (c == \\'.\\') continue;\\n                int x=(c-\\'0\\')%9; \\n                // Convert the character digit to an index (0-8) 0 for 9\\n\\n                if (Row[i][x]) return 0;\\n                Row[i][x] = 1;\\n\\n                if (Col[j][x]) return 0;\\n                Col[j][x] = 1;\\n                \\n                int bidx = (i / 3) * 3 + j / 3;\\n                if (Block[bidx][x]) return 0;\\n                Block[bidx][x] = 1;\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```\n```C []\\nbool isValidSudoku(char** board, int boardSize, int* boardColSize)\\n{\\n    bool Col[9][9]={0};\\n    bool Row[9][9]={0};\\n    bool Block[9][9]={0};\\n\\n    for(int i=0; i<9; i++){\\n        for(int j=0; j<9; j++){\\n            char c = board[i][j];\\n            if (c == \\'.\\') continue;\\n            int x=(c-\\'0\\')%9; \\n            // Convert the character digit to an index (0-8) 0 for 9\\n\\n            if (Row[i][x]==1) return 0;\\n            Row[i][x] = 1;\\n\\n            if (Col[j][x]==1) return 0;\\n            Col[j][x] = 1;\\n                \\n            int bidx = (i / 3) * 3 + j / 3;\\n            if (Block[bidx][x]==1) return 0;\\n            Block[bidx][x] = 1;\\n        }\\n    }\\n    return 1;\\n}\\n```\n```Python []\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        # Use sets\\n        Col = [set() for _ in range(9)]\\n        Row = [set() for _ in range(9)]\\n        Block = [set() for _ in range(9)]\\n\\n        for i in range(9):\\n            for j in range(9):\\n                c=board[i][j]\\n                if c==\\'.\\': continue\\n                x=(ord(c)-ord(\\'0\\'))%9\\n\\n                if x in Row[i]: return False\\n                Row[i].add(x)\\n\\n                if x in Col[j]: return False\\n                Col[j].add(x)\\n\\n                idx=i//3*3+j//3\\n                if x in Block[idx]: return False\\n                Block[idx].add(x)\\n        return True\\'\\n```\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        unordered_set<string> C;\\n        int n=0;\\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                char c = board[i][j];\\n                if (c != \\'.\\') {\\n                    n++;\\n                    string row=\"row\"+to_string(i)+c;\\n                    string col=\"col\"+to_string(j)+c;\\n                    int bidx = (i / 3) * 3 + j / 3;\\n                    string block=\"block\"+to_string(bidx)+c;\\n                    C.insert(row);\\n                    C.insert(col);\\n                    C.insert(block);\\n                }\\n            }\\n        }\\n        return C.size()==3*n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324188,
                "title": "powerful-logic-with-two-method",
                "content": "\\n\\n# 1. Without Hashtable Approach\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        def valid(arr):\\n            s=\\'\\'.join(arr).replace(\\'.\\',\\'\\')\\n            return len(s)==len(set(s))\\n        def checkrow():\\n            for row in board:\\n                if not valid(row):\\n                    return False\\n            return True\\n        def checkcol():\\n            for col in zip(*board):\\n                if not valid(col):\\n                    return False\\n            return True\\n        def square():\\n            for r in range(0,9,3):\\n                for c in range(0,9,3):\\n                    nums=[board[r+i][c+j] for i in range(3) for j in range(3)]\\n                    if not valid(nums):\\n                        return False\\n            return True\\n        return checkrow() and checkcol() and square()\\n\\n//please upvote me it would encourage me alot\\n\\n```\\n\\n# 2.With Hashtable Approach\\n```\\n\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        row=defaultdict(set)\\n        col=defaultdict(set)\\n        square=defaultdict(set)\\n        for r in range(9):\\n            for c in range(9):\\n                x=board[r][c]\\n                if board[r][c]==\".\":\\n                    continue\\n                if x in row[r] or x in col[c] or x in square[(r//3,c//3)]:\\n                    return False\\n                row[r].add(board[r][c])\\n                col[c].add(board[r][c])\\n                square[(r//3,c//3)].add(board[r][c])\\n        return True\\n        \\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        def valid(arr):\\n            s=\\'\\'.join(arr).replace(\\'.\\',\\'\\')\\n            return len(s)==len(set(s))\\n        def checkrow():\\n            for row in board:\\n                if not valid(row):\\n                    return False\\n            return True\\n        def checkcol():\\n            for col in zip(*board):\\n                if not valid(col):\\n                    return False\\n            return True\\n        def square():\\n            for r in range(0,9,3):\\n                for c in range(0,9,3):\\n                    nums=[board[r+i][c+j] for i in range(3) for j in range(3)]\\n                    if not valid(nums):\\n                        return False\\n            return True\\n        return checkrow() and checkcol() and square()\\n\\n//please upvote me it would encourage me alot\\n\\n```\n```\\n\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        row=defaultdict(set)\\n        col=defaultdict(set)\\n        square=defaultdict(set)\\n        for r in range(9):\\n            for c in range(9):\\n                x=board[r][c]\\n                if board[r][c]==\".\":\\n                    continue\\n                if x in row[r] or x in col[c] or x in square[(r//3,c//3)]:\\n                    return False\\n                row[r].add(board[r][c])\\n                col[c].add(board[r][c])\\n                square[(r//3,c//3)].add(board[r][c])\\n        return True\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079159,
                "title": "javascript-99-4-fast-very-very-easy-to-understand-solution-with-video-explanation",
                "content": "Here is video for explain if it is helpful please subscribe! :\\n\\nhttps://youtu.be/yaMicoAZsrI\\n\\n# Code\\n```\\n/**\\n * @param {character[][]} board\\n * @return {boolean}\\n */\\nvar isValidSudoku = function(board) {\\n    \\n    for(let i =0; i<board.length;i++){\\n        let rowMap = {}\\n        let colMap = {}\\n        let boxMap = {}\\n        for(let j=0; j<board[i].length;j++){\\n\\n            let box = board[3* Math.floor(i/3) +Math.floor(j/3)][3*(i%3)+(j%3)]\\n            \\n            if(board[i][j] != \\'.\\'){\\n                if(rowMap[board[i][j]]) return false;\\n                rowMap[board[i][j]] = 1;\\n            }\\n            if(board[j][i] != \\'.\\') {\\n                if(colMap[board[j][i]]) return false;\\n                colMap[board[j][i]] = 1;\\n            }\\n            if(box!= \\'.\\'){\\n                if(boxMap[box]) return false;\\n                boxMap[box] = 1;\\n            }\\n        }\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {character[][]} board\\n * @return {boolean}\\n */\\nvar isValidSudoku = function(board) {\\n    \\n    for(let i =0; i<board.length;i++){\\n        let rowMap = {}\\n        let colMap = {}\\n        let boxMap = {}\\n        for(let j=0; j<board[i].length;j++){\\n\\n            let box = board[3* Math.floor(i/3) +Math.floor(j/3)][3*(i%3)+(j%3)]\\n            \\n            if(board[i][j] != \\'.\\'){\\n                if(rowMap[board[i][j]]) return false;\\n                rowMap[board[i][j]] = 1;\\n            }\\n            if(board[j][i] != \\'.\\') {\\n                if(colMap[board[j][i]]) return false;\\n                colMap[board[j][i]] = 1;\\n            }\\n            if(box!= \\'.\\'){\\n                if(boxMap[box]) return false;\\n                boxMap[box] = 1;\\n            }\\n        }\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3005232,
                "title": "single-pass-python-solution-easiest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe initial approach was to traverse the sudoku 3 times and check for row satisfiability in first pass, column satisfiability in second pass and sub-box satisfiability in third pass. However, we could design an approach with an extra space to optimize this and check for all conditions in a single pass of the sudoku.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDeclare an defaultdict(taking set as the default_factory). Iterate the Sudoku and check if the number exists in our defaultdict for row, column and sub-box condition with the help of keys (discussed below). If it is not present at all 3 keys, add the number in the 3 locations. If it is present, return False as it is not a valid Sudoku.\\nIf we successfully traverse the Sudoku without encountering a single instance where number is already present in the defaultdict, it means it is a valid Sudoku so return True.\\n\\n# Keys:\\n**i** : For Row i.e. defaultdict[i] will have the numbers in i\\'th row.\\n**j+9**: For Column i.e. defaultdict[j+9] will have numbers in the j\\'th column. 9 added to avoid clash with keys of rows.\\n**(i//3,j//3)**: For Sub-box condition, as the key represent\\'s the sub box in which the element of (i\\'th row,j\\'th column) exists.\\n\\n# Complexity\\n- Time complexity: O(N^2) [Basically Single pass over the Sudoku. ]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) [A dictionary of 27 keys and each having a set as the value to store the numbers].\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n***Please Like the Solution if you understood it***.\\n\\n# Code\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        checker = defaultdict(set)\\n        for i in range(9):\\n            for j in range(9):\\n                if board[i][j]==\".\":\\n                    continue\\n\\n                box = (i//3,j//3)\\n                if board[i][j] in checker[i] or board[i][j] in checker[j+9] or board[i][j] in checker[box]:\\n                    return False\\n                else:\\n                    checker[i].add(board[i][j])\\n                    checker[j+9].add(board[i][j])\\n                    checker[box].add(board[i][j])\\n        #print(checker)\\n        return True\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Matrix",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        checker = defaultdict(set)\\n        for i in range(9):\\n            for j in range(9):\\n                if board[i][j]==\".\":\\n                    continue\\n\\n                box = (i//3,j//3)\\n                if board[i][j] in checker[i] or board[i][j] in checker[j+9] or board[i][j] in checker[box]:\\n                    return False\\n                else:\\n                    checker[i].add(board[i][j])\\n                    checker[j+9].add(board[i][j])\\n                    checker[box].add(board[i][j])\\n        #print(checker)\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597616,
                "title": "python3-simple-solution-using-hashset",
                "content": "Code:\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        cols = collections.defaultdict(set)\\n        rows = collections.defaultdict(set)\\n        squares = collections.defaultdict(set)\\n        \\n        for r in range(9):\\n            for c in range(9):\\n                if board[r][c] == \".\":\\n                    continue\\n                if (board[r][c] in rows[r] or \\n                    board[r][c] in cols[c] or \\n                    board[r][c] in squares[(r//3,c//3)]):\\n                    return False\\n                cols[c].add(board[r][c])\\n                rows[r].add(board[r][c])\\n                squares[(r//3,c//3)].add(board[r][c])\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        cols = collections.defaultdict(set)\\n        rows = collections.defaultdict(set)\\n        squares = collections.defaultdict(set)\\n        \\n        for r in range(9):\\n            for c in range(9):\\n                if board[r][c] == \".\":\\n                    continue\\n                if (board[r][c] in rows[r] or \\n                    board[r][c] in cols[c] or \\n                    board[r][c] in squares[(r//3,c//3)]):\\n                    return False\\n                cols[c].add(board[r][c])\\n                rows[r].add(board[r][c])\\n                squares[(r//3,c//3)].add(board[r][c])\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457762,
                "title": "c-easy-solution-set-solution",
                "content": "Here ATQ,\\n  For Valid sudoko , we need some validation .\\n  1. No two elements should be in the same row .\\n  2. No two elements should be in the same column.\\n  3. No same should present in each 3*3  Block Matrix.\\n \\n So for that we are taking the set data structures to store and validate.\\n The main key is here for the  9block  -   3* 3 blocks  to validate.\\n For traversing in the block index becomes   (i/3)*3 + j/3;\\n\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        // using set data structure to store and validate in rows , cols  and 3*3 each blocks.\\n        \\n       vector<set<int>> rows(9), cols(9), blocks(9);\\n        \\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                \\n                if (board[i][j] == \\'.\\') continue;\\n                \\n                int curr = board[i][j] - \\'0\\';\\n                if (rows[i].count(curr) || cols[j].count(curr) || blocks[(i/3)*3+j/3].count(curr)) \\n                    return false;\\n                \\n                rows[i].insert(curr);\\n                cols[j].insert(curr);\\n                blocks[(i/3)*3+j/3].insert(curr);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        // using set data structure to store and validate in rows , cols  and 3*3 each blocks.\\n        \\n       vector<set<int>> rows(9), cols(9), blocks(9);\\n        \\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                \\n                if (board[i][j] == \\'.\\') continue;\\n                \\n                int curr = board[i][j] - \\'0\\';\\n                if (rows[i].count(curr) || cols[j].count(curr) || blocks[(i/3)*3+j/3].count(curr)) \\n                    return false;\\n                \\n                rows[i].insert(curr);\\n                cols[j].insert(curr);\\n                blocks[(i/3)*3+j/3].insert(curr);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2434689,
                "title": "simple-optimal-solution-kotlin-using-string",
                "content": "```\\nclass Solution {\\n    fun isValidSudoku(board: Array<CharArray>): Boolean {\\n       val seen = HashSet<String>()\\n       \\n       for(i in 0 until 9){\\n           for(j in 0 until 9){\\n               var number = board[i][j]\\n               if(number != \\'.\\'){\\n                   if(!seen.add(\"$number in row $i\") ||\\n                      !seen.add(\"$number in column $j\") ||\\n                      !seen.add(\"$number in block ${i/3}-${j/3}\")) return false\\n                   \\n               }\\n           }\\n       }\\n       \\n       return true\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    fun isValidSudoku(board: Array<CharArray>): Boolean {\\n       val seen = HashSet<String>()\\n       \\n       for(i in 0 until 9){\\n           for(j in 0 until 9){\\n               var number = board[i][j]\\n               if(number != \\'.\\'){\\n                   if(!seen.add(\"$number in row $i\") ||\\n                      !seen.add(\"$number in column $j\") ||\\n                      !seen.add(\"$number in block ${i/3}-${j/3}\")) return false\\n                   \\n               }\\n           }\\n       }\\n       \\n       return true\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430291,
                "title": "python-91ms-faster-than-98-w-proof-easy-to-understand-readable",
                "content": "1. Initialize a set\\n2. Traverse through the cells one by one and add them to set with proper names for example,\\n\\t1. If `3` is in `board[0][1]`, then add these three keys to the set\\n\\t2. `3 in row 0`\\n\\t3. `3 in col 1`\\n\\t4. `3 in box 0`\\n3. If the key already exists in the set, then return False\\n\\n```\\ndef isValidSudoku(self, board: List[List[str]]) -> bool:\\n\\ts = set()\\n\\n\\tfor i in range(9):\\n\\t\\tfor j in range(9):\\n\\t\\t\\tif board[i][j] != \\'.\\':\\n\\t\\t\\t\\tc = board[i][j]\\n\\n\\t\\t\\t\\t# Row check\\n\\t\\t\\t\\tkey = f\\'{c} in row {i}\\' # same as -> str(c) + \\' in row \\' + str(i)\\n\\n\\t\\t\\t\\tif key in s:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ts.add(key)\\n\\n\\t\\t\\t\\t# Column check\\n\\t\\t\\t\\tkey = f\\'{c} in col {j}\\' # same as -> str(c) + \\' in col \\' + str(j)\\n\\n\\t\\t\\t\\tif key in s:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ts.add(key)\\n\\n\\t\\t\\t\\t# Box check\\n\\t\\t\\t\\tboxIndex = (i // 3) * 3 + (j // 3)\\n\\t\\t\\t\\tkey = f\\'{c} in box {boxIndex}\\' # same as -> str(c) + \\' in box \\' + str(boxIndex)\\n\\n\\t\\t\\t\\tif key in s:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ts.add(key) \\n\\n\\treturn True\\n```\\n\\n![image](https://assets.leetcode.com/users/images/6a37c991-15e9-4c82-915d-81f86191a795_1660582920.076614.png)\\n\\n![image](https://assets.leetcode.com/users/images/ae445c1c-9ed7-447e-bb74-134e7cd36e35_1660753850.275268.png)\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef isValidSudoku(self, board: List[List[str]]) -> bool:\\n\\ts = set()\\n\\n\\tfor i in range(9):\\n\\t\\tfor j in range(9):\\n\\t\\t\\tif board[i][j] != \\'.\\':\\n\\t\\t\\t\\tc = board[i][j]\\n\\n\\t\\t\\t\\t# Row check\\n\\t\\t\\t\\tkey = f\\'{c} in row {i}\\' # same as -> str(c) + \\' in row \\' + str(i)\\n\\n\\t\\t\\t\\tif key in s:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ts.add(key)\\n\\n\\t\\t\\t\\t# Column check\\n\\t\\t\\t\\tkey = f\\'{c} in col {j}\\' # same as -> str(c) + \\' in col \\' + str(j)\\n\\n\\t\\t\\t\\tif key in s:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ts.add(key)\\n\\n\\t\\t\\t\\t# Box check\\n\\t\\t\\t\\tboxIndex = (i // 3) * 3 + (j // 3)\\n\\t\\t\\t\\tkey = f\\'{c} in box {boxIndex}\\' # same as -> str(c) + \\' in box \\' + str(boxIndex)\\n\\n\\t\\t\\t\\tif key in s:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ts.add(key) \\n\\n\\treturn True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2374430,
                "title": "simple-java-0ms-100-faster-solution",
                "content": "**Java \\u2705 || 0ms || 100% faster Solution**\\n\\n**Please  \\uD83D\\uDC4D this.solution if(you understood == true)**\\n\\n```\\n// Best Approach : HashSet\\n// Time Complexity : O(n2)\\n// Space Complexity : O(n2)\\n// Author - Nikhil Sharma\\n// LinkedIn - https://www.linkedin.com/in/nikhil-sharma-41a287226/\\n// Twitter - https://twitter.com/Sharma_Nikh12\\n\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        Set set = new HashSet();\\n        for (int i=0; i<9; ++i) {\\n            for (int j=0; j<9; ++j) {\\n                if (board[i][j] != \\'.\\') {\\n                    String el = \"[\" + board[i][j] + \"]\";\\n                    if (!set.add(el + i) || !set.add(j + el) || !set.add(i/3 + el + j/3))\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\n// Best Approach : HashSet\\n// Time Complexity : O(n2)\\n// Space Complexity : O(n2)\\n// Author - Nikhil Sharma\\n// LinkedIn - https://www.linkedin.com/in/nikhil-sharma-41a287226/\\n// Twitter - https://twitter.com/Sharma_Nikh12\\n\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        Set set = new HashSet();\\n        for (int i=0; i<9; ++i) {\\n            for (int j=0; j<9; ++j) {\\n                if (board[i][j] != \\'.\\') {\\n                    String el = \"[\" + board[i][j] + \"]\";\\n                    if (!set.add(el + i) || !set.add(j + el) || !set.add(i/3 + el + j/3))\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2287201,
                "title": "rust-simple-hashset-0ms",
                "content": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn is_valid_sudoku(board: Vec<Vec<char>>) -> bool {\\n        let mut row_set = HashSet::new();\\n        let mut col_set = HashSet::new();\\n        let mut sub_box_sets = vec![HashSet::new(); 9];\\n        \\n        for r in 0..9 {\\n            for c in 0..9 {\\n                if let Some(digit) = board[r][c].to_digit(10) {\\n\\t\\t\\t\\t\\t// Has this combination of row number r and digit already been encountered?\\n                    if !row_set.insert((r, digit)) {\\n                        return false;\\n                    }\\n\\t\\t\\t\\t\\t// Has this combination of column number c and digit already been encountered?\\n                    if !col_set.insert((c, digit)) {\\n                        return false;\\n                    }\\n\\t\\t\\t\\t\\t// Iterator math to determine which of the 9 sub boxes the current board[r][c] is in. \\n\\t\\t\\t\\t\\t// Has it already been encountered?\\n                    if !sub_box_sets[3 * (r/3) + c/3].insert(digit) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn is_valid_sudoku(board: Vec<Vec<char>>) -> bool {\\n        let mut row_set = HashSet::new();\\n        let mut col_set = HashSet::new();\\n        let mut sub_box_sets = vec![HashSet::new(); 9];\\n        \\n        for r in 0..9 {\\n            for c in 0..9 {\\n                if let Some(digit) = board[r][c].to_digit(10) {\\n\\t\\t\\t\\t\\t// Has this combination of row number r and digit already been encountered?\\n                    if !row_set.insert((r, digit)) {\\n                        return false;\\n                    }\\n\\t\\t\\t\\t\\t// Has this combination of column number c and digit already been encountered?\\n                    if !col_set.insert((c, digit)) {\\n                        return false;\\n                    }\\n\\t\\t\\t\\t\\t// Iterator math to determine which of the 9 sub boxes the current board[r][c] is in. \\n\\t\\t\\t\\t\\t// Has it already been encountered?\\n                    if !sub_box_sets[3 * (r/3) + c/3].insert(digit) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1745150,
                "title": "c-simple-and-easy-hashset",
                "content": "For each row, column and block we keep a set of characters.\\nIf we find the char again while inserting we return a false.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n\\t\\n        vector<set<char>> row(9), col(9), block(9); // each char set for checking every row coloumn and block\\n        \\n        for(int i = 0; i < 9; i++) {\\n            for(int j = 0; j < 9; j++) {\\n                if(board[i][j] != \\'.\\') {\\n                    char c = board[i][j];\\n                    if(!row[j].insert(c).second or !col[i].insert(c).second or !block[(i/3)*3 + j/3].insert(c).second) \\n\\t\\t\\t\\t\\t\\treturn false;\\n/* checking while inserting in the set\\t\\t\\t\\t\\t\\t\\n   An insert operation on a set returns a pair, with its member first set to an iterator pointing\\n   to either the newly inserted element or to the equivalent element already in the set. \\n   The second element in the pair is set to true if a new element was inserted or false if an equivalent element already existed.*/\\t\\t\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\nFor block[(i/3)*3 + j/3] \\nWe have to map each 3x3 boxes, and label the boxes like this:\\n\\n0 1 2\\n3 4 5\\n6 7 8\\n\\nSo we have boxIndex as  r/3*3 +c/3\\nDo a dry run you will get to know easily.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n\\t\\n        vector<set<char>> row(9), col(9), block(9); // each char set for checking every row coloumn and block\\n        \\n        for(int i = 0; i < 9; i++) {\\n            for(int j = 0; j < 9; j++) {\\n                if(board[i][j] != \\'.\\') {\\n                    char c = board[i][j];\\n                    if(!row[j].insert(c).second or !col[i].insert(c).second or !block[(i/3)*3 + j/3].insert(c).second) \\n\\t\\t\\t\\t\\t\\treturn false;\\n/* checking while inserting in the set\\t\\t\\t\\t\\t\\t\\n   An insert operation on a set returns a pair, with its member first set to an iterator pointing\\n   to either the newly inserted element or to the equivalent element already in the set. \\n   The second element in the pair is set to true if a new element was inserted or false if an equivalent element already existed.*/\\t\\t\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1706655,
                "title": "o-1-time-complexity-using-set-with-comments",
                "content": "```\\nclass Solution {\\n    /*in this we have to check 3 things\\n    1:-that each number should be unique in the colum\\n    2:- each number should be unique in th row\\n    3:- each number should be unique in the box\\n   steps:-\\n   \\n   1:-we will make set of string type\\n   2:- then we will make 3 string row,colum,box\\n   3:-and we will make the string in this way like:-\\n   \\n   row = row+number(board[i][j])+i;\\n   colum = colum+number+j;\\n   and to get the which in which box it belongs we have one formula\\n   int Box=((i/3)*3+(j/3));\\n   and every itration row colum will change accordingly string will also change .\\n   \\n   so if supppose we have string like:-\\n   row+number+i = row5 abd the row is 3\\n   row+number+i = row5 and the row is 3\\n   then it will give false same for colum and box;\\n   \\n   4:- if(box[i][j]!=\\'.\\') then only we have to chck\\n   \\n   5:- now check if have the string then return false;\\n   \\n   6:- otherwise add into the set.\\n   */\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n         unordered_set<string>u;\\n        for(int i=0;i<9;i++)\\n        {\\n            for(int j=0;j<9;j++)\\n            {\\n                string row=\"\";\\n                row+=\"row\";\\n                row+=board[i][j];\\n                row+=i;\\n                \\n                string colum=\"\";\\n                colum+=\"colum\";\\n                colum+=board[i][j];\\n                colum+=j;\\n                \\n                int Box=((i/3)*3+(j/3));\\n                string box=\"\";\\n                box+=\"box\";\\n                box+=board[i][j];\\n                box+=Box;\\n                if(board[i][j]!=\\'.\\')\\n                if(u.count(row) || u.count(colum) ||u.count(box))\\n                {\\n                    return false;\\n                }\\n                else\\n                {\\n                    u.insert(row);\\n                    u.insert(colum);\\n                    u.insert(box);\\n                }\\n                \\n            }\\n        }\\n        return true;\\n    }\\n    \\n};\\n```\\n\\n**PLEASE LET ME KNOW IF ANY SUGGESTION OR DOUBTS**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    /*in this we have to check 3 things\\n    1:-that each number should be unique in the colum\\n    2:- each number should be unique in th row\\n    3:- each number should be unique in the box\\n   steps:-\\n   \\n   1:-we will make set of string type\\n   2:- then we will make 3 string row,colum,box\\n   3:-and we will make the string in this way like:-\\n   \\n   row = row+number(board[i][j])+i;\\n   colum = colum+number+j;\\n   and to get the which in which box it belongs we have one formula\\n   int Box=((i/3)*3+(j/3));\\n   and every itration row colum will change accordingly string will also change .\\n   \\n   so if supppose we have string like:-\\n   row+number+i = row5 abd the row is 3\\n   row+number+i = row5 and the row is 3\\n   then it will give false same for colum and box;\\n   \\n   4:- if(box[i][j]!=\\'.\\') then only we have to chck\\n   \\n   5:- now check if have the string then return false;\\n   \\n   6:- otherwise add into the set.\\n   */\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n         unordered_set<string>u;\\n        for(int i=0;i<9;i++)\\n        {\\n            for(int j=0;j<9;j++)\\n            {\\n                string row=\"\";\\n                row+=\"row\";\\n                row+=board[i][j];\\n                row+=i;\\n                \\n                string colum=\"\";\\n                colum+=\"colum\";\\n                colum+=board[i][j];\\n                colum+=j;\\n                \\n                int Box=((i/3)*3+(j/3));\\n                string box=\"\";\\n                box+=\"box\";\\n                box+=board[i][j];\\n                box+=Box;\\n                if(board[i][j]!=\\'.\\')\\n                if(u.count(row) || u.count(colum) ||u.count(box))\\n                {\\n                    return false;\\n                }\\n                else\\n                {\\n                    u.insert(row);\\n                    u.insert(colum);\\n                    u.insert(box);\\n                }\\n                \\n            }\\n        }\\n        return true;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1493936,
                "title": "c-easy-solution-using-hashmap-runtime-32-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int N = board.size();\\n        unordered_set<char>rowset[N],colset[N],boxset[N];\\n        for(int i=0;i<N;i++){\\n            for(int j=0;j<N;j++){\\n                int boxno = (i/3)*3+(j/3);\\n                char val = board[i][j];\\n                if(val==\\'.\\')\\n                    continue;\\n                if(rowset[i].count(val) || colset[j].count(val) || boxset[boxno].count(val))\\n                    return false;\\n                rowset[i].insert(val);\\n                colset[j].insert(val);\\n                boxset[boxno].insert(val);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n*Please feel free to ask in the comments if you were not able to grasp anything from this solution*\\n**Happy Coding\\uD83D\\uDE07**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int N = board.size();\\n        unordered_set<char>rowset[N],colset[N],boxset[N];\\n        for(int i=0;i<N;i++){\\n            for(int j=0;j<N;j++){\\n                int boxno = (i/3)*3+(j/3);\\n                char val = board[i][j];\\n                if(val==\\'.\\')\\n                    continue;\\n                if(rowset[i].count(val) || colset[j].count(val) || boxset[boxno].count(val))\\n                    return false;\\n                rowset[i].insert(val);\\n                colset[j].insert(val);\\n                boxset[boxno].insert(val);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1416689,
                "title": "c-3-approaches-with-diagrams",
                "content": "```\\n//Approach-1 (Naive and simplest using 3 iterations of the sudoku)\\nclass Solution {\\npublic:\\n    bool validSub(vector<vector<char>>& board, int sr, int er, int sc, int ec) {\\n        unordered_set<char> st;\\n        for(int row = sr; row<=er; row++) {\\n            for(int col = sc; col <= ec; col++) {\\n                char ch = board[row][col];\\n                if(ch == \\'.\\') continue;\\n                if(st.count(ch)) return false;\\n                st.insert(ch);\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        //validate rows\\n        for(int row = 0; row<9; row++) {\\n            unordered_set<char> st;\\n            for(int col = 0; col <9; col++) {\\n                char ch = board[row][col];\\n                if(ch == \\'.\\') continue;\\n                if(st.count(ch)) return false;\\n                st.insert(ch);\\n            }\\n        }\\n        \\n        //validate columns\\n        for(int col = 0; col<9; col++) {\\n            unordered_set<char> st;\\n            for(int row = 0; row <9; row++) {\\n                char ch = board[row][col];\\n                if(ch == \\'.\\') continue;\\n                if(st.count(ch)) return false;\\n                st.insert(ch);\\n            }\\n        }\\n        \\n\\t\\t//validate ech 3*3 box\\n\\t\\t/*\\n\\t\\t\\tsr = start row\\n\\t\\t\\ter = end row\\n\\t\\t\\tsc = start column\\n\\t\\t\\tec = end column\\n\\t\\t*/\\n        for(int sr = 0; sr < 9; sr+=3) {\\n            int er = sr+2;\\n            for(int sc = 0; sc < 9; sc+=3) {\\n                int ec = sc+2;\\n                if(!validSub(board, sr, er, sc, ec))\\n                    return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (One iteration using hashmap and indexing boxes)\\n//see the diagrma below to understand the indexing of the boxes\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        unordered_set<string> st;\\n        \\n        for(int i = 0; i<9; i++) {\\n            for(int j = 0; j<9; j++) {\\n                if(board[i][j] == \\'.\\') continue;\\n                \\n                string row = string(1, board[i][j]) + \"_row_\" + to_string(i);\\n                string col = string(1, board[i][j]) + \"_col_\" + to_string(j);\\n                string box = string(1, board[i][j]) + \"_box_\" + to_string(i/3) + \"_\" + to_string(j/3);\\n                if(st.count(row) || st.count(col) || st.count(box)) return false;\\n                st.insert(row);\\n                st.insert(col);\\n                st.insert(box);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\nDiagram for approach-2 :\\n![image](https://assets.leetcode.com/users/images/57d3cdd5-96a8-4e92-a247-0cf704cd6975_1629523773.4062777.jpeg)\\n\\n\\n```\\n//Approach-3 (Assigning a number to each box)\\n//see the diagrma below to understand how I have numbered the boxes\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bool row[9][9] = {0};\\n        bool col[9][9] = {0};\\n        bool box[9][9] = {0};\\n        for(int i = 0; i<9; i++) {\\n            for(int j = 0; j<9; j++) {\\n                if(board[i][j] == \\'.\\') continue;\\n                \\n                int digit     = board[i][j] - \\'0\\' - 1; //(-1 to avoid overflow in index)\\n                \\n                //we have numbered 9 boxes of (3*3) as 0, 1, 2, 3, 4 ... 9 (see the diagram below)\\n                int boxIndex  = (i/3)*3 + (j/3);\\n                \\n                if(row[i][digit] || col[j][digit] || box[boxIndex][digit]) return false;\\n                row[i][digit]        = true;\\n                col[j][digit]        = true;\\n                box[boxIndex][digit] = true;\\n                \\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n//YouTube : https://www.youtube.com/watch?v=dGZjzA9zLW8\\n```\\n\\nDiagram for approach-2 :\\n![image](https://assets.leetcode.com/users/images/9feb7938-89d9-4bfe-a336-177037ebdf04_1629523884.2286322.jpeg)\\n",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Naive and simplest using 3 iterations of the sudoku)\\nclass Solution {\\npublic:\\n    bool validSub(vector<vector<char>>& board, int sr, int er, int sc, int ec) {\\n        unordered_set<char> st;\\n        for(int row = sr; row<=er; row++) {\\n            for(int col = sc; col <= ec; col++) {\\n                char ch = board[row][col];\\n                if(ch == \\'.\\') continue;\\n                if(st.count(ch)) return false;\\n                st.insert(ch);\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        //validate rows\\n        for(int row = 0; row<9; row++) {\\n            unordered_set<char> st;\\n            for(int col = 0; col <9; col++) {\\n                char ch = board[row][col];\\n                if(ch == \\'.\\') continue;\\n                if(st.count(ch)) return false;\\n                st.insert(ch);\\n            }\\n        }\\n        \\n        //validate columns\\n        for(int col = 0; col<9; col++) {\\n            unordered_set<char> st;\\n            for(int row = 0; row <9; row++) {\\n                char ch = board[row][col];\\n                if(ch == \\'.\\') continue;\\n                if(st.count(ch)) return false;\\n                st.insert(ch);\\n            }\\n        }\\n        \\n\\t\\t//validate ech 3*3 box\\n\\t\\t/*\\n\\t\\t\\tsr = start row\\n\\t\\t\\ter = end row\\n\\t\\t\\tsc = start column\\n\\t\\t\\tec = end column\\n\\t\\t*/\\n        for(int sr = 0; sr < 9; sr+=3) {\\n            int er = sr+2;\\n            for(int sc = 0; sc < 9; sc+=3) {\\n                int ec = sc+2;\\n                if(!validSub(board, sr, er, sc, ec))\\n                    return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\n```\\n//Approach-2 (One iteration using hashmap and indexing boxes)\\n//see the diagrma below to understand the indexing of the boxes\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        unordered_set<string> st;\\n        \\n        for(int i = 0; i<9; i++) {\\n            for(int j = 0; j<9; j++) {\\n                if(board[i][j] == \\'.\\') continue;\\n                \\n                string row = string(1, board[i][j]) + \"_row_\" + to_string(i);\\n                string col = string(1, board[i][j]) + \"_col_\" + to_string(j);\\n                string box = string(1, board[i][j]) + \"_box_\" + to_string(i/3) + \"_\" + to_string(j/3);\\n                if(st.count(row) || st.count(col) || st.count(box)) return false;\\n                st.insert(row);\\n                st.insert(col);\\n                st.insert(box);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\n```\\n//Approach-3 (Assigning a number to each box)\\n//see the diagrma below to understand how I have numbered the boxes\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bool row[9][9] = {0};\\n        bool col[9][9] = {0};\\n        bool box[9][9] = {0};\\n        for(int i = 0; i<9; i++) {\\n            for(int j = 0; j<9; j++) {\\n                if(board[i][j] == \\'.\\') continue;\\n                \\n                int digit     = board[i][j] - \\'0\\' - 1; //(-1 to avoid overflow in index)\\n                \\n                //we have numbered 9 boxes of (3*3) as 0, 1, 2, 3, 4 ... 9 (see the diagram below)\\n                int boxIndex  = (i/3)*3 + (j/3);\\n                \\n                if(row[i][digit] || col[j][digit] || box[boxIndex][digit]) return false;\\n                row[i][digit]        = true;\\n                col[j][digit]        = true;\\n                box[boxIndex][digit] = true;\\n                \\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n//YouTube : https://www.youtube.com/watch?v=dGZjzA9zLW8\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1261934,
                "title": "rust-solution-using-three-1-d-arrays-with-bit-manipulation-instead-of-hashset",
                "content": "Normally, simplest approach here would be to instantiate 9 HashSets for Rows, Columns, and Boxes to check for duplicate entries - but it is very wasteful. Instead, we could simply use an array and represent values as bits which span from 1 to 9. Thus, it is possible to represent all in `u16` type.\\n\\n```rust\\nimpl Solution \\n{\\n    pub fn is_valid_sudoku(board: Vec<Vec<char>>) -> bool \\n    {\\n        let mut rows: [u16; 9] = [0; 9];\\n        let mut cols: [u16; 9] = [0; 9];\\n        let mut boxes: [u16; 9] = [0; 9];\\n        \\n        for i in 0..9 {\\n            for j in 0..9 {\\n                match board[i][j] \\n                {\\n                    \\'.\\' => continue,\\n                    c => {\\n                        let b: usize = (i / 3) * 3 + (j / 3);\\n                        let curr = 1 << (c.to_digit(10).unwrap());\\n                        \\n                        if rows[i] & curr != 0 || cols[j] & curr != 0 || boxes[b] & curr != 0 {\\n                            return false;\\n                        }\\n    \\n                        rows[i] |= curr;\\n                        cols[j] |= curr;\\n                        boxes[b] |= curr;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```rust\\nimpl Solution \\n{\\n    pub fn is_valid_sudoku(board: Vec<Vec<char>>) -> bool \\n    {\\n        let mut rows: [u16; 9] = [0; 9];\\n        let mut cols: [u16; 9] = [0; 9];\\n        let mut boxes: [u16; 9] = [0; 9];\\n        \\n        for i in 0..9 {\\n            for j in 0..9 {\\n                match board[i][j] \\n                {\\n                    \\'.\\' => continue,\\n                    c => {\\n                        let b: usize = (i / 3) * 3 + (j / 3);\\n                        let curr = 1 << (c.to_digit(10).unwrap());\\n                        \\n                        if rows[i] & curr != 0 || cols[j] & curr != 0 || boxes[b] & curr != 0 {\\n                            return false;\\n                        }\\n    \\n                        rows[i] |= curr;\\n                        cols[j] |= curr;\\n                        boxes[b] |= curr;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 788607,
                "title": "swift-simple-sweet-for-100-complexity",
                "content": "Time; O(n), Space: O(n) where n is 81. In other words, it is **O(1)** for both\\n```\\nfunc isValidSudoku(_ board: [[Character]]) -> Bool {\\n\\tvar set = Set<String>()\\n\\n\\tfor row in 0..<9 {\\n\\t\\tfor col in 0..<9 {\\n\\t\\t\\tlet char = board[row][col]\\n\\t\\t\\tif char != \".\" {\\n\\t\\t\\t\\tlet num = char.wholeNumberValue!\\n\\n\\t\\t\\t\\tif !set.insert(\"\\\\(row)(\\\\(num))\").0 { return false }\\n\\t\\t\\t\\tif !set.insert(\"(\\\\(num))\\\\(col)\").0 { return false }\\n\\t\\t\\t\\tif !set.insert(\"\\\\(row/3)(\\\\(num))\\\\(col/3)\").0 { return false }\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc isValidSudoku(_ board: [[Character]]) -> Bool {\\n\\tvar set = Set<String>()\\n\\n\\tfor row in 0..<9 {\\n\\t\\tfor col in 0..<9 {\\n\\t\\t\\tlet char = board[row][col]\\n\\t\\t\\tif char != \".\" {\\n\\t\\t\\t\\tlet num = char.wholeNumberValue!\\n\\n\\t\\t\\t\\tif !set.insert(\"\\\\(row)(\\\\(num))\").0 { return false }\\n\\t\\t\\t\\tif !set.insert(\"(\\\\(num))\\\\(col)\").0 { return false }\\n\\t\\t\\t\\tif !set.insert(\"\\\\(row/3)(\\\\(num))\\\\(col/3)\").0 { return false }\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 310692,
                "title": "java-o-2-beats-100",
                "content": "Rule 1 and 2 are trivial, rule 3 a little bit tricky. We use division to get whole part. Lets say we have item [3][5], so it will be 3* (3/3) + 5/3 = 3 + 1 = 4 hence it will be block 4 (overall there are 9 blocks with indicies from 0 to 8). I used 10 iteams instead of 9 just to avoid -1 every time since java indicies start with 0.\\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        boolean[][] rule1 = new boolean[9][10];\\n        boolean[][] rule2 = new boolean[9][10];\\n        boolean[][] rule3 = new boolean[9][10];\\n        for(int i=0; i<9; ++i) {\\n            for(int j=0; j<9; j++) {\\n                char digit = board[i][j];\\n\\n                if (digit != \\'.\\') {\\n                    int idx3 = 3 * (i / 3) + j / 3;\\n                    // convert char to int \\'0\\' -> 0\\n                    digit -= \\'0\\';\\n                    if (rule1[j][digit] || rule2[i][digit] || rule3[idx3][digit]) {\\n                        return false;\\n                    }\\n                    rule1[j][digit] = true;\\n                    rule2[i][digit] = true;\\n                    rule3[idx3][digit] = true; \\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        boolean[][] rule1 = new boolean[9][10];\\n        boolean[][] rule2 = new boolean[9][10];\\n        boolean[][] rule3 = new boolean[9][10];\\n        for(int i=0; i<9; ++i) {\\n            for(int j=0; j<9; j++) {\\n                char digit = board[i][j];\\n\\n                if (digit != \\'.\\') {\\n                    int idx3 = 3 * (i / 3) + j / 3;\\n                    // convert char to int \\'0\\' -> 0\\n                    digit -= \\'0\\';\\n                    if (rule1[j][digit] || rule2[i][digit] || rule3[idx3][digit]) {\\n                        return false;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 240709,
                "title": "simple-c-code",
                "content": "```\\nbool isValidSudoku(char** board, int boardRowSize, int boardColSize) {\\n    char tmpR[9][9] = {0};\\n    char tmpC[9][9] = {0};\\n    char tmpI[9][9] = {0};\\n    int num;\\n    int index;\\n    for(int i = 0 ; i < 9;++i){\\n        for(int j = 0; j < 9; ++j){\\n            if(board[i][j] == \\'.\\'){\\n                continue;\\n            }\\n            num = board[i][j] - \\'1\\';\\n            index = (i/3)*3 + j/3;\\n            if(tmpR[i][num]|tmpC[j][num]|tmpI[index][num]){\\n                return false;\\n            }\\n            tmpR[i][num] = tmpC[j][num] = tmpI[index][num] = 1;\\n        }\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool isValidSudoku(char** board, int boardRowSize, int boardColSize) {\\n    char tmpR[9][9] = {0};\\n    char tmpC[9][9] = {0};\\n    char tmpI[9][9] = {0};\\n    int num;\\n    int index;\\n    for(int i = 0 ; i < 9;++i){\\n        for(int j = 0; j < 9; ++j){\\n            if(board[i][j] == \\'.\\'){\\n                continue;\\n            }\\n            num = board[i][j] - \\'1\\';\\n            index = (i/3)*3 + j/3;\\n            if(tmpR[i][num]|tmpC[j][num]|tmpI[index][num]){\\n                return false;\\n            }\\n            tmpR[i][num] = tmpC[j][num] = tmpI[index][num] = 1;\\n        }\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 196923,
                "title": "java-beat-97-code",
                "content": "\\u6C42\\u70B9\\u8D5E\\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        boolean[][] map_row = new boolean[10][10];\\n        boolean[][] map_col = new boolean[10][10];       \\n        //check row and col\\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int num = board[i][j] - \\'0\\';\\n                    if(map_row[i][num]) return false;\\n                    map_row[i][num] = true;\\n                    if(map_col[num][j]) return false;\\n                    map_col[num][j] = true;\\n                }\\n            }\\n        }\\n        \\n        //check 3*3\\n        for(int i=0; i<9; i= i+3){\\n            for(int j=0; j<9; j=j+3) {\\n                boolean[] map = new boolean[10];\\n                for(int k=0; k<3; k++){\\n                    for(int t=0; t<3; t++){\\n                        int num = board[k+i][t+j] - \\'0\\';\\n                        if(board[k+i][t+j] != \\'.\\'){\\n                            if(map[num]) return false;\\n                            map[num] = true;\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n     return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        boolean[][] map_row = new boolean[10][10];\\n        boolean[][] map_col = new boolean[10][10];       \\n        //check row and col\\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int num = board[i][j] - \\'0\\';\\n                    if(map_row[i][num]) return false;\\n                    map_row[i][num] = true;\\n                    if(map_col[num][j]) return false;\\n                    map_col[num][j] = true;\\n                }\\n            }\\n        }\\n        \\n        //check 3*3\\n        for(int i=0; i<9; i= i+3){\\n            for(int j=0; j<9; j=j+3) {\\n                boolean[] map = new boolean[10];\\n                for(int k=0; k<3; k++){\\n                    for(int t=0; t<3; t++){\\n                        int num = board[k+i][t+j] - \\'0\\';\\n                        if(board[k+i][t+j] != \\'.\\'){\\n                            if(map[num]) return false;\\n                            map[num] = true;\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n     return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 175187,
                "title": "beats-77-java-with-explanations",
                "content": "**Logic**\\nA valid Sudoku should satisfy 3 requirements. For each requirement, we go through the whole grid once.\\n**Thought**\\nThe bottleneck of the Brute Force approach described above is that we traverse the grid 3 times. Could we do better?\\nWe could do row-validation and column-validation together within one traversal. That reduces the time complexity from O(3n) to O(2n) - n is the number of cells in the board (9 x 9 in this case).\\nAs for the validation on sub-boxes, it\\'s tricky to do with multi-level for-loops. If we regard a sub-box as a whole, there are 3 x 3 sub-boxes. Then we focus on the cells within a sub-box. \\n\\n**Code**\\n```\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        Set<Character> rowSet = new HashSet<>(); // Helper set to check duplicates of one row.\\n        Set<Character> colSet = new HashSet<>(); // Helper set to check duplicates of one column.\\n        Set<Character> boxSet = new HashSet<>(); // Helper set to check duplicates of one 3x3 sub-box.\\n        \\n        // Check for row and column (together).\\n        for (int i = 0; i < 9; i++) {\\n            rowSet.clear();\\n            colSet.clear();\\n            for (int j = 0; j < 9; j++) {               \\n                char val = board[i][j];\\n                if (val != \\'.\\') {\\n                    if (rowSet.contains(val))\\n                        return false;\\n                    rowSet.add(val);\\n                }\\n                char symmetricVal = board[j][i];\\n                if (symmetricVal != \\'.\\') {\\n                    if (colSet.contains(symmetricVal))\\n                        return false;\\n                    colSet.add(symmetricVal);                    \\n                }\\n            }\\n        }\\n        \\n        // Check for 3x3 sub-boxes of the grid.\\n        for (int i = 0; i < 3; i++) { // Subbox row number.\\n            for (int j = 0; j < 3; j++) { // Subbox column number.\\n                boxSet.clear();\\n                for (int x = i * 3; x < i * 3 + 3; x++) { // Cell row number.\\n                    for (int y = j * 3; y < j * 3 + 3; y++) { // Cel column number.\\n                        if (board[x][y] != \\'.\\' && !boxSet.add(board[x][y])) {\\n                            return false;\\n                        }\\n                    }\\n                }\\n           }\\n        }\\n        \\n        return true;\\n    }\\n```\\n**I appreciate your VOTE UP (\\u25B0\\u2579\\u25E1\\u2579\\u25B0)**",
                "solutionTags": [],
                "code": "```\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        Set<Character> rowSet = new HashSet<>(); // Helper set to check duplicates of one row.\\n        Set<Character> colSet = new HashSet<>(); // Helper set to check duplicates of one column.\\n        Set<Character> boxSet = new HashSet<>(); // Helper set to check duplicates of one 3x3 sub-box.\\n        \\n        // Check for row and column (together).\\n        for (int i = 0; i < 9; i++) {\\n            rowSet.clear();\\n            colSet.clear();\\n            for (int j = 0; j < 9; j++) {               \\n                char val = board[i][j];\\n                if (val != \\'.\\') {\\n                    if (rowSet.contains(val))\\n                        return false;\\n                    rowSet.add(val);\\n                }\\n                char symmetricVal = board[j][i];\\n                if (symmetricVal != \\'.\\') {\\n                    if (colSet.contains(symmetricVal))\\n                        return false;\\n                    colSet.add(symmetricVal);                    \\n                }\\n            }\\n        }\\n        \\n        // Check for 3x3 sub-boxes of the grid.\\n        for (int i = 0; i < 3; i++) { // Subbox row number.\\n            for (int j = 0; j < 3; j++) { // Subbox column number.\\n                boxSet.clear();\\n                for (int x = i * 3; x < i * 3 + 3; x++) { // Cell row number.\\n                    for (int y = j * 3; y < j * 3 + 3; y++) { // Cel column number.\\n                        if (board[x][y] != \\'.\\' && !boxSet.add(board[x][y])) {\\n                            return false;\\n                        }\\n                    }\\n                }\\n           }\\n        }\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3576940,
                "title": "go-15-lines-using-array-100-100",
                "content": "\\n```\\nfunc isValidSudoku(board [][]byte) bool {\\n    var rows, columns, squares [9][9]bool\\n    for i, row := range board {\\n        for j, v := range row {\\n            if v != \\'.\\' {\\n                k := int(v)-49\\n                if rows[i][k] || columns[j][k] || squares[i/3*3 + j/3][k] {\\n                    return false\\n                }\\n                rows[i][k], columns[j][k], squares[i/3*3 + j/3][k] = true, true, true\\n            }\\n        }\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isValidSudoku(board [][]byte) bool {\\n    var rows, columns, squares [9][9]bool\\n    for i, row := range board {\\n        for j, v := range row {\\n            if v != \\'.\\' {\\n                k := int(v)-49\\n                if rows[i][k] || columns[j][k] || squares[i/3*3 + j/3][k] {\\n                    return false\\n                }\\n                rows[i][k], columns[j][k], squares[i/3*3 + j/3][k] = true, true, true\\n            }\\n        }\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3545709,
                "title": "easy-intuitive-java-solution-beats-100-online-submissions",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n\\n        int[] res;\\n\\n        for(int i = 0;i < 9;i++){\\n\\n            res = new int[9];\\n\\n            for(int j = 0;j < 9;j++){\\n                if(board[i][j] == \\'.\\'){\\n                    continue;\\n                }\\n\\n                res[board[i][j]-\\'1\\']++;\\n\\n                if(res[board[i][j]-\\'1\\'] > 1){\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        for(int i = 0;i < 9;i++){\\n\\n            res = new int[9];\\n\\n            for(int j = 0;j < 9;j++){\\n                if(board[j][i] == \\'.\\'){\\n                    continue;\\n                }\\n\\n                res[board[j][i]-\\'1\\']++;\\n\\n                if(res[board[j][i]-\\'1\\'] > 1){\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0;i < 3;i++){\\n            for(int j = 0;j < 3;j++){\\n                res = new int[9];\\n                for(int p = 3*i;p < 3*i+3;p++){\\n                    for(int q = 3*j;q < 3*j+3;q++){\\n                        if(board[p][q] == \\'.\\'){\\n                            continue;\\n                        }\\n\\n                        res[board[p][q]-\\'1\\']++;\\n\\n                        if(res[board[p][q]-\\'1\\'] > 1){\\n                            return false;\\n                        }\\n\\n                    }\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Matrix",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n\\n        int[] res;\\n\\n        for(int i = 0;i < 9;i++){\\n\\n            res = new int[9];\\n\\n            for(int j = 0;j < 9;j++){\\n                if(board[i][j] == \\'.\\'){\\n                    continue;\\n                }\\n\\n                res[board[i][j]-\\'1\\']++;\\n\\n                if(res[board[i][j]-\\'1\\'] > 1){\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        for(int i = 0;i < 9;i++){\\n\\n            res = new int[9];\\n\\n            for(int j = 0;j < 9;j++){\\n                if(board[j][i] == \\'.\\'){\\n                    continue;\\n                }\\n\\n                res[board[j][i]-\\'1\\']++;\\n\\n                if(res[board[j][i]-\\'1\\'] > 1){\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0;i < 3;i++){\\n            for(int j = 0;j < 3;j++){\\n                res = new int[9];\\n                for(int p = 3*i;p < 3*i+3;p++){\\n                    for(int q = 3*j;q < 3*j+3;q++){\\n                        if(board[p][q] == \\'.\\'){\\n                            continue;\\n                        }\\n\\n                        res[board[p][q]-\\'1\\']++;\\n\\n                        if(res[board[p][q]-\\'1\\'] > 1){\\n                            return false;\\n                        }\\n\\n                    }\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2951286,
                "title": "single-iteration-c",
                "content": "\\n# Complexity\\n- Time complexity:\\n- O(n\\xB2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n\\xB2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        set<string> s;\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(board[i][j] != \\'.\\'){\\n                    string r = \"r\" + to_string(i) +  board[i][j];\\n                    string c = \"c\" + to_string(j) +  board[i][j];\\n                    string sqr = \"sqr\" + to_string((i/3)*3 + (j/3)) +  board[i][j];\\n\\n                    if(s.find(r)==s.end() && s.find(c)==s.end() && s.find(sqr)==s.end()){\\n                        s.insert(r);\\n                        s.insert(c);\\n                        s.insert(sqr);\\n                    }\\n                    else{\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        set<string> s;\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(board[i][j] != \\'.\\'){\\n                    string r = \"r\" + to_string(i) +  board[i][j];\\n                    string c = \"c\" + to_string(j) +  board[i][j];\\n                    string sqr = \"sqr\" + to_string((i/3)*3 + (j/3)) +  board[i][j];\\n\\n                    if(s.find(r)==s.end() && s.find(c)==s.end() && s.find(sqr)==s.end()){\\n                        s.insert(r);\\n                        s.insert(c);\\n                        s.insert(sqr);\\n                    }\\n                    else{\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843411,
                "title": "python-easy-99-73-faster-using-set",
                "content": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        def check(a):\\n            s=set()\\n            for i in a:\\n                if i==\\'.\\':\\n                    continue\\n                if i in s:\\n                    return False\\n                s.add(i)\\n            return True\\n        \\n        #To check each row must contain the digits 1-9 without repetition.\\n        for row in board:\\n            if not check(row):\\n                return False\\n        \\n        #To check each column must contain the digits 1-9 without repetition.\\n        for i in range(9):\\n            column=[]\\n            for j in range(9):\\n                column.append(board[j][i])\\n            if not check(column):\\n                return False\\n        \\n        #To check each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9                without repetition.\\n        for i in range(0,9,3):\\n            for j in range(0,9,3):\\n                square=[]\\n                for k in range(i,i+3):\\n                    for l in range(j,j+3):\\n                        square.append(board[k][l])\\n                if not check(square):\\n                    return False\\n        return True\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        def check(a):\\n            s=set()\\n            for i in a:\\n                if i==\\'.\\':\\n                    continue\\n                if i in s:\\n                    return False\\n                s.add(i)\\n            return True\\n        \\n        #To check each row must contain the digits 1-9 without repetition.\\n        for row in board:\\n            if not check(row):\\n                return False\\n        \\n        #To check each column must contain the digits 1-9 without repetition.\\n        for i in range(9):\\n            column=[]\\n            for j in range(9):\\n                column.append(board[j][i])\\n            if not check(column):\\n                return False\\n        \\n        #To check each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9                without repetition.\\n        for i in range(0,9,3):\\n            for j in range(0,9,3):\\n                square=[]\\n                for k in range(i,i+3):\\n                    for l in range(j,j+3):\\n                        square.append(board[k][l])\\n                if not check(square):\\n                    return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841718,
                "title": "c-just-check-for-everything",
                "content": "```\\n#define vb vector<bool>\\n#define vvc vector<vector<char>>\\nclass Solution {\\npublic:\\n    void hash_setter (vb &hash){\\n        for (int i = 0; i < 10; i++) hash[i] = 0;\\n    }    \\n    \\n    bool row_check (vvc &board){\\n        vb hash (10, 0);\\n        \\n        for (int i = 0; i < 9; i++){\\n            for (int j = 0; j < 9; j++){\\n                if (board[i][j] == \\'.\\') continue;\\n                if (hash[board[i][j]-\\'0\\']) return 0;\\n                \\n                hash[board[i][j]-\\'0\\'] = 1;\\n            }\\n            \\n            hash_setter (hash);\\n        }\\n        \\n        return 1;\\n    }\\n    \\n    bool col_check (vvc &board){\\n        vb hash (10, 0);\\n        \\n        for (int i = 0; i < 9; i++){\\n            for (int j = 0; j < 9; j++){\\n                if (board[j][i] == \\'.\\') continue;\\n                if (hash[board[j][i]-\\'0\\']) return 0;\\n                \\n                hash[board[j][i]-\\'0\\'] = 1;\\n            }\\n            \\n            hash_setter (hash);\\n        }\\n        \\n        return 1;\\n    }\\n    \\n    bool sub_box_check (vvc &board, int i, int j){\\n        vb hash (10,0);\\n        \\n        for (int k = i; k < i+3; k++){\\n            for (int l = j; l < j+3; l++){\\n                if (board[k][l] == \\'.\\') continue;\\n                if (hash[board[k][l]-\\'0\\']) return 0;\\n                \\n                hash[board[k][l]-\\'0\\'] = 1;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    bool sub_box_generate (vvc &board){\\n        for (int i = 0; i < 9; i+=3){\\n            for (int j = 0; j < 9; j+=3){\\n                if (sub_box_check (board, i, j) == 0) return 0;\\n            }\\n        }\\n        \\n        return 1;\\n    }\\n    \\n    \\n    bool isValidSudoku(vector<vector<char>>& board) { \\n        if (!row_check (board) || !col_check (board) || !sub_box_generate (board)) return 0;\\n        \\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define vb vector<bool>\\n#define vvc vector<vector<char>>\\nclass Solution {\\npublic:\\n    void hash_setter (vb &hash){\\n        for (int i = 0; i < 10; i++) hash[i] = 0;\\n    }    \\n    \\n    bool row_check (vvc &board){\\n        vb hash (10, 0);\\n        \\n        for (int i = 0; i < 9; i++){\\n            for (int j = 0; j < 9; j++){\\n                if (board[i][j] == \\'.\\') continue;\\n                if (hash[board[i][j]-\\'0\\']) return 0;\\n                \\n                hash[board[i][j]-\\'0\\'] = 1;\\n            }\\n            \\n            hash_setter (hash);\\n        }\\n        \\n        return 1;\\n    }\\n    \\n    bool col_check (vvc &board){\\n        vb hash (10, 0);\\n        \\n        for (int i = 0; i < 9; i++){\\n            for (int j = 0; j < 9; j++){\\n                if (board[j][i] == \\'.\\') continue;\\n                if (hash[board[j][i]-\\'0\\']) return 0;\\n                \\n                hash[board[j][i]-\\'0\\'] = 1;\\n            }\\n            \\n            hash_setter (hash);\\n        }\\n        \\n        return 1;\\n    }\\n    \\n    bool sub_box_check (vvc &board, int i, int j){\\n        vb hash (10,0);\\n        \\n        for (int k = i; k < i+3; k++){\\n            for (int l = j; l < j+3; l++){\\n                if (board[k][l] == \\'.\\') continue;\\n                if (hash[board[k][l]-\\'0\\']) return 0;\\n                \\n                hash[board[k][l]-\\'0\\'] = 1;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    bool sub_box_generate (vvc &board){\\n        for (int i = 0; i < 9; i+=3){\\n            for (int j = 0; j < 9; j+=3){\\n                if (sub_box_check (board, i, j) == 0) return 0;\\n            }\\n        }\\n        \\n        return 1;\\n    }\\n    \\n    \\n    bool isValidSudoku(vector<vector<char>>& board) { \\n        if (!row_check (board) || !col_check (board) || !sub_box_generate (board)) return 0;\\n        \\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841476,
                "title": "c-bit-masking-easy-to-understand",
                "content": "# Approach 1: bitmasking\\nN.B. ```\\'1\\' & 0xf == 1```, this yields the same result as ```\\'1\\' - \\'0\\'```, but is still a neat trick to convert ASCII digits. That\\'s a trick from the times when CPUs where a lot slower and it was cheaper to do ```and``` than ```sub```.\\n\\n```cpp\\n    static bool isValidSudoku(const vector<vector<char>>& board) noexcept {\\n        array<int, 9> rows = {};\\n        array<int, 9> cols = {};\\n        array<int, 9> boxes = {};\\n        for (int r = 0; r < 9; ++r) {\\n            for (int c = 0; c < 9; ++c) {\\n                if (board[r][c] == \\'.\\') continue;\\n                const int mask = 1 << (board[r][c] & 0xf);\\n                // row\\n                if (rows[r] & mask) return false;\\n                rows[r] |= mask;\\n                // col\\n                if (cols[c] & mask) return false;\\n                cols[c] |= mask;\\n                // box    \\n                const int box = (r / 3)  * 3 + (c / 3);\\n                if (boxes[box] & mask) return false;\\n                boxes[box] |= mask;\\n            }\\n        }        \\n        return true;\\n    }\\n```\\n\\nMaybe a quesion of taste, but we could also write this a bit more compact:\\n\\n```cpp\\n    static bool isValidSudoku(const vector<vector<char>>& board) noexcept {\\n        array<int, 9> rows = {};\\n        array<int, 9> cols = {};\\n        array<int, 9> boxes = {};\\n        for (int r = 0; r < 9; ++r) {\\n            for (int c = 0; c < 9; ++c) {\\n                if (board[r][c] == \\'.\\') continue;\\n                const int mask = 1 << (board[r][c] & 0xf);\\n                const int box = (r / 3)  * 3 + (c / 3);\\n                if ((rows[r] & mask) || (cols[c] & mask) || (boxes[box] & mask))\\n                    return false;\\n                rows[r] |= mask;\\n                cols[c] |= mask;\\n                boxes[box] |= mask;\\n            }\\n        }        \\n        return true;\\n    }\\n```\\n\\nStrictly speaking we could use ```array<short, 9>``` instead of ```array<int, 9>``` or maybe even pack everything into a ```bitset<81>```.\\n\\n**Complexity Analysis**\\nThe input size is fixed, hence this is $$O(1)$$ in both cases. Is this correct?\\n  * Time complexity: $$O(1)$$.\\n  * Space complexity: $$O(1)$$.\\n\\nOTAH if we considered $$n$$ as the length of the board, i.e. 9 and assume it could grow then:\\n  * Time complexity: $$O(n^2)$$ and\\n  * Space complexity: $$O(n)$$.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\'1\\' & 0xf == 1```\n```\\'1\\' - \\'0\\'```\n```and```\n```sub```\n```cpp\\n    static bool isValidSudoku(const vector<vector<char>>& board) noexcept {\\n        array<int, 9> rows = {};\\n        array<int, 9> cols = {};\\n        array<int, 9> boxes = {};\\n        for (int r = 0; r < 9; ++r) {\\n            for (int c = 0; c < 9; ++c) {\\n                if (board[r][c] == \\'.\\') continue;\\n                const int mask = 1 << (board[r][c] & 0xf);\\n                // row\\n                if (rows[r] & mask) return false;\\n                rows[r] |= mask;\\n                // col\\n                if (cols[c] & mask) return false;\\n                cols[c] |= mask;\\n                // box    \\n                const int box = (r / 3)  * 3 + (c / 3);\\n                if (boxes[box] & mask) return false;\\n                boxes[box] |= mask;\\n            }\\n        }        \\n        return true;\\n    }\\n```\n```cpp\\n    static bool isValidSudoku(const vector<vector<char>>& board) noexcept {\\n        array<int, 9> rows = {};\\n        array<int, 9> cols = {};\\n        array<int, 9> boxes = {};\\n        for (int r = 0; r < 9; ++r) {\\n            for (int c = 0; c < 9; ++c) {\\n                if (board[r][c] == \\'.\\') continue;\\n                const int mask = 1 << (board[r][c] & 0xf);\\n                const int box = (r / 3)  * 3 + (c / 3);\\n                if ((rows[r] & mask) || (cols[c] & mask) || (boxes[box] & mask))\\n                    return false;\\n                rows[r] |= mask;\\n                cols[c] |= mask;\\n                boxes[box] |= mask;\\n            }\\n        }        \\n        return true;\\n    }\\n```\n```array<short, 9>```\n```array<int, 9>```\n```bitset<81>```",
                "codeTag": "Unknown"
            },
            {
                "id": 2841425,
                "title": "java-easy-to-understand-with-comments-using-hashset-beats-100",
                "content": "*Upvote if you like the solution!!!*\\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<Character> Rset = new HashSet<>(); //to check repetition in rows\\n        HashSet<Character> Cset = new HashSet<>(); //to check repetition in columns\\n\\n        for(int i=0;i<board.length;i++){\\n            for(int j=0;j<board.length;j++){\\n                if(board[i][j]==\\'.\\') continue;\\n                else {\\n                    if(!Rset.add(board[i][j])) return false;  //if same elemets are added Rset.add return false;\\n                }\\n                }\\n            Rset = new HashSet<>();  //clearing the Rset after checking for one row.\\n            }\\n        \\n\\n        for(int j=0;j<board.length;j++){\\n            for(int i=0;i<board.length;i++){\\n                if(board[i][j]==\\'.\\')continue;\\n                    else{\\n                    if(!Cset.add(board[i][j])) return false; //if same elemets are added Cset.add return false;\\n                    }\\n            }\\n            Cset = new HashSet<>();  //clearing the Cset after checking for one column.\\n        }\\n        \\n        //now the 3rd condition checking repetitions in 3x3 sub-boxes.\\n        for(int i=0;i<9;i+=3){\\n            for(int j=0;j<9;j+=3){\\n                if(!check3(i,j,board)) return false;\\n            }\\n        }\\n        \\n        //if all conditions are validated we return true.\\n        return true;\\n        }\\n    \\n    //this function checks repetition in a 3x3 matrix\\n    public boolean check3(int i,int j,char[][] board){\\n        HashSet<Character> set3 = new HashSet<>();\\n        for(int m=i;m<3+i;m++){\\n            for(int n=j;n<3+j;n++){\\n                if(board[m][n]==\\'.\\') continue;\\n                else {\\n                    if(!set3.add(board[m][n])) return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<Character> Rset = new HashSet<>(); //to check repetition in rows\\n        HashSet<Character> Cset = new HashSet<>(); //to check repetition in columns\\n\\n        for(int i=0;i<board.length;i++){\\n            for(int j=0;j<board.length;j++){\\n                if(board[i][j]==\\'.\\') continue;\\n                else {\\n                    if(!Rset.add(board[i][j])) return false;  //if same elemets are added Rset.add return false;\\n                }\\n                }\\n            Rset = new HashSet<>();  //clearing the Rset after checking for one row.\\n            }\\n        \\n\\n        for(int j=0;j<board.length;j++){\\n            for(int i=0;i<board.length;i++){\\n                if(board[i][j]==\\'.\\')continue;\\n                    else{\\n                    if(!Cset.add(board[i][j])) return false; //if same elemets are added Cset.add return false;\\n                    }\\n            }\\n            Cset = new HashSet<>();  //clearing the Cset after checking for one column.\\n        }\\n        \\n        //now the 3rd condition checking repetitions in 3x3 sub-boxes.\\n        for(int i=0;i<9;i+=3){\\n            for(int j=0;j<9;j+=3){\\n                if(!check3(i,j,board)) return false;\\n            }\\n        }\\n        \\n        //if all conditions are validated we return true.\\n        return true;\\n        }\\n    \\n    //this function checks repetition in a 3x3 matrix\\n    public boolean check3(int i,int j,char[][] board){\\n        HashSet<Character> set3 = new HashSet<>();\\n        for(int m=i;m<3+i;m++){\\n            for(int n=j;n<3+j;n++){\\n                if(board[m][n]==\\'.\\') continue;\\n                else {\\n                    if(!set3.add(board[m][n])) return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2840675,
                "title": "python-3-10-lines-bitmaps-t-m-95-85",
                "content": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n\\n        row, col, hse = [0]*9, [0]*9, [0]*9\\n\\n        for i,j in product(range(9), range(9)):\\n\\n            b = board[i][j]\\n            if not b.isdigit(): continue\\n            b, ij = 1<<int(b), 3*(i//3)+j//3\\n\\n            if row[i]&b or col[j]&b or hse[ij]&b: return False\\n\\n            row[i ]|=b\\n            col[j ]|=b\\n            hse[ij]|=b\\n\\n        return True\\n```\\n[https://leetcode.com/problems/valid-sudoku/submissions/997890268/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(1) and space complexity is *O*(1).\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n\\n        row, col, hse = [0]*9, [0]*9, [0]*9\\n\\n        for i,j in product(range(9), range(9)):\\n\\n            b = board[i][j]\\n            if not b.isdigit(): continue\\n            b, ij = 1<<int(b), 3*(i//3)+j//3\\n\\n            if row[i]&b or col[j]&b or hse[ij]&b: return False\\n\\n            row[i ]|=b\\n            col[j ]|=b\\n            hse[ij]|=b\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2291296,
                "title": "java-cleanest-code-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n      HashSet<String> map = new HashSet<>();\\n      for(int i = 0; i < 9; i ++) {\\n        for(int j = 0; j < 9; j ++) {\\n          if(board[i][j] != \\'.\\') {\\n            String r = \\'r\\' + \"-\" + i + board[i][j];\\n            String c = \\'c\\' + \"-\" + j + board[i][j];\\n            String rc = (i / 3) + \"-\" + board[i][j] + \"-\" + (j / 3);\\n            \\n            if(!map.add(r) || !map.add(c) || !map.add(rc))\\n              return false;\\n          }\\n        }\\n      }\\n      return true;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n      HashSet<String> map = new HashSet<>();\\n      for(int i = 0; i < 9; i ++) {\\n        for(int j = 0; j < 9; j ++) {\\n          if(board[i][j] != \\'.\\') {\\n            String r = \\'r\\' + \"-\" + i + board[i][j];\\n            String c = \\'c\\' + \"-\" + j + board[i][j];\\n            String rc = (i / 3) + \"-\" + board[i][j] + \"-\" + (j / 3);\\n            \\n            if(!map.add(r) || !map.add(c) || !map.add(rc))\\n              return false;\\n          }\\n        }\\n      }\\n      return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2281872,
                "title": "java-in-depth-explanation-easy-to-implement",
                "content": "**Intuition**\\nBasically, we need to check three conditions:\\n\\n1. Each row must contain the digits 1-9 without repetition.\\n2. Each column must contain the digits 1-9 without repetition.\\n3. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.\\n\\nIf all of them are true, then return true. Otherwise, return false.\\n\\n**Debat**\\nI personally think both time and space complexity are O(1) since we would achieve O(81) mostly because of the size of board[ ][ ]. But this could be debatable. You could talk this to your interviewer during the interview. My interviwer agrees my point by the way. \\n\\n```\\nclass Solution \\n{\\n    public boolean isValidSudoku(char[][] board)\\n    {\\n        // O(1) time | O(1) space\\n        HashSet<String> mySet = new HashSet<>();\\n        \\n        for(int i = 0; i < 9; i++)\\n        {\\n            for(int j = 0; j < 9; j++)\\n            {\\n                if(board[i][j] != \\'.\\')\\n                {\\n                    if(mySet.contains(\"row\" + i + board[i][j]) || mySet.contains(\"col\" + j + board[i][j]) || mySet.contains(\"box\" + i/3 + j/3 + board[i][j]))\\n                        return false;\\n                    \\n                    mySet.add(\"row\" + i + board[i][j]);\\n                    mySet.add(\"col\" + j + board[i][j]);\\n                    mySet.add(\"box\" + i/3 + j/3 + board[i][j]);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public boolean isValidSudoku(char[][] board)\\n    {\\n        // O(1) time | O(1) space\\n        HashSet<String> mySet = new HashSet<>();\\n        \\n        for(int i = 0; i < 9; i++)\\n        {\\n            for(int j = 0; j < 9; j++)\\n            {\\n                if(board[i][j] != \\'.\\')\\n                {\\n                    if(mySet.contains(\"row\" + i + board[i][j]) || mySet.contains(\"col\" + j + board[i][j]) || mySet.contains(\"box\" + i/3 + j/3 + board[i][j]))\\n                        return false;\\n                    \\n                    mySet.add(\"row\" + i + board[i][j]);\\n                    mySet.add(\"col\" + j + board[i][j]);\\n                    mySet.add(\"box\" + i/3 + j/3 + board[i][j]);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2033555,
                "title": "javascript-hashmap-solution-with-short-comment-97-12-faster",
                "content": "```\\nvar isValidSudoku = function(board) {\\n    const hash = {};\\n    \\n    for(let i = 0; i < board.length; i++) {\\n        for(let j = 0; j < board[i].length; j++) {\\n            if(board[i][j] === \\'.\\') continue; // if current value is equal \\'.\\' , skip to next index\\n            if(hash[board[i][j]] === undefined) { \\n                const box = calculateBox(i,j);\\n                hash[board[i][j]] = [[i, j, box]]; // because the same value can be repeated, it is created as an array\\n            } \\n            else { \\n                for(let k = 0; k < hash[board[i][j]].length; k++) {  \\n                    const [row, col, box] = hash[board[i][j]][k];  // Get row, col, and box information of the same value as the current value\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// check current value is validated with sdoku rules\\n                    if(row === i || col === j) return false;  \\n                    else if(calculateBox(i,j) === box) return false;\\n                }\\n                hash[board[i][j]].push([i, j, calculateBox(i,j)]); // if it is valitated sudoku rules, push to hashmap  for example hash {\\'5\\': [ [ 2, 0, 1 ], [ 3, 3, 5 ] ] }\\n            }\\n        }\\n    }\\n    return true;\\n};\\n\\n\\nfunction calculateBox(row, col) { //calculate box number with row and col\\n return Math.floor(row/3) * 3 + Math.floor(col/3);\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isValidSudoku = function(board) {\\n    const hash = {};\\n    \\n    for(let i = 0; i < board.length; i++) {\\n        for(let j = 0; j < board[i].length; j++) {\\n            if(board[i][j] === \\'.\\') continue; // if current value is equal \\'.\\' , skip to next index\\n            if(hash[board[i][j]] === undefined) { \\n                const box = calculateBox(i,j);\\n                hash[board[i][j]] = [[i, j, box]]; // because the same value can be repeated, it is created as an array\\n            } \\n            else { \\n                for(let k = 0; k < hash[board[i][j]].length; k++) {  \\n                    const [row, col, box] = hash[board[i][j]][k];  // Get row, col, and box information of the same value as the current value\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// check current value is validated with sdoku rules\\n                    if(row === i || col === j) return false;  \\n                    else if(calculateBox(i,j) === box) return false;\\n                }\\n                hash[board[i][j]].push([i, j, calculateBox(i,j)]); // if it is valitated sudoku rules, push to hashmap  for example hash {\\'5\\': [ [ 2, 0, 1 ], [ 3, 3, 5 ] ] }\\n            }\\n        }\\n    }\\n    return true;\\n};\\n\\n\\nfunction calculateBox(row, col) { //calculate box number with row and col\\n return Math.floor(row/3) * 3 + Math.floor(col/3);\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1918864,
                "title": "java-easy-solution-2-lines-of-logic",
                "content": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        HashSet<String> seen = new HashSet();\\n        \\n        for (int i =0 ; i < 9; i++) {\\n            \\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    if (!seen.add(\"row\" + i + board[i][j]) || !seen.add(\"col\" + j + board[i][j])) {\\n                        return false;\\n                    }\\n                    if (!seen.add(\"box\" + (i / 3) * 3 + j / 3 + board[i][j])) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        HashSet<String> seen = new HashSet();\\n        \\n        for (int i =0 ; i < 9; i++) {\\n            \\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    if (!seen.add(\"row\" + i + board[i][j]) || !seen.add(\"col\" + j + board[i][j])) {\\n                        return false;\\n                    }\\n                    if (!seen.add(\"box\" + (i / 3) * 3 + j / 3 + board[i][j])) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822522,
                "title": "using-unordered-set-with-comments-c",
                "content": "Implementation\\n\\n**Using Unordered Set\\nTime Complexity = O(N^2)\\nSpace Complexity = O(N^2)**\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        \\n        // store the row index and value of that particular row index\\n        // store the col index and value of that particular col index\\n        // store the particular box index and value in the particular box index\\n        // we will store the row, col & box index and their value into this visited unordered set\\n        unordered_set<string> visited;\\n        \\n        for(int row = 0; row < 9; row++){\\n            for(int col = 0; col < 9; col++){\\n                \\n                // if the current index value is dot(.) then we don\\'t need to do anything \\n                if(board[row][col] != \\'.\\'){\\n                    \\n                    // if any particular (row index with value) or (col index with value) or (box index with value) already visited it means that is not a valid sudoku, so we will directly return false\\n                    if(visited.find(\"Row\" + to_string(row) + to_string(board[row][col])) != visited.end()\\n                       || visited.find(\"Col\" + to_string(col) + to_string(board[row][col])) != visited.end()\\n                       || visited.find(\"Box\" + to_string(((row/3) * 3 + (col/3))) + to_string(board[row][col])) != visited.end()){\\n                        return false;\\n                    }\\n                    \\n                    // if not visited yet, then add (row index & value) and (col index & value) and (box index & value) into the visited unordered set\\n                    visited.insert(\"Row\" + to_string(row) + to_string(board[row][col]));\\n                    visited.insert(\"Col\" + to_string(col) + to_string(board[row][col]));\\n                    visited.insert(\"Box\" + to_string((row/3)*3 + (col/3)) + to_string(board[row][col]));\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "String",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        \\n        // store the row index and value of that particular row index\\n        // store the col index and value of that particular col index\\n        // store the particular box index and value in the particular box index\\n        // we will store the row, col & box index and their value into this visited unordered set\\n        unordered_set<string> visited;\\n        \\n        for(int row = 0; row < 9; row++){\\n            for(int col = 0; col < 9; col++){\\n                \\n                // if the current index value is dot(.) then we don\\'t need to do anything \\n                if(board[row][col] != \\'.\\'){\\n                    \\n                    // if any particular (row index with value) or (col index with value) or (box index with value) already visited it means that is not a valid sudoku, so we will directly return false\\n                    if(visited.find(\"Row\" + to_string(row) + to_string(board[row][col])) != visited.end()\\n                       || visited.find(\"Col\" + to_string(col) + to_string(board[row][col])) != visited.end()\\n                       || visited.find(\"Box\" + to_string(((row/3) * 3 + (col/3))) + to_string(board[row][col])) != visited.end()){\\n                        return false;\\n                    }\\n                    \\n                    // if not visited yet, then add (row index & value) and (col index & value) and (box index & value) into the visited unordered set\\n                    visited.insert(\"Row\" + to_string(row) + to_string(board[row][col]));\\n                    visited.insert(\"Col\" + to_string(col) + to_string(board[row][col]));\\n                    visited.insert(\"Box\" + to_string((row/3)*3 + (col/3)) + to_string(board[row][col]));\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777939,
                "title": "easy-to-understand-c",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    string toStr(int k)\\n    {\\n        stringstream ss;\\n        ss << k;\\n        string s;\\n        ss >> s;\\n        return s;\\n    }\\n    bool isValidSudoku(vector<vector<char>> &board)\\n    {\\n        map<string, int> mp;\\n        string temp;\\n        int n = board.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (board[i][j] != \\'.\\')\\n                {\\n                    //-------------------Inserting for ROW and value in its cell\\n                    //-------------------In case the same row contains the duplicate values, we can find it by map/ set or any DS.\\n                    temp = \"ROW\";\\n                    temp += toStr(i) + (board[i][j]);\\n                    if (mp.find(temp) == mp.end())\\n                    {\\n                        mp[temp]++;\\n                    }\\n                    else\\n                        return false;\\n\\n                    //-------------------Inserting for COL and value in its cell\\n                    temp = \"COL\";\\n                    temp += toStr(j) + (board[i][j]);\\n                    if (mp.find(temp) == mp.end())\\n                    {\\n                        mp[temp]++;\\n                    }\\n                    else\\n                        return false;\\n\\n                    //-------------------Inserting for BOX \\n                    //-------------------There are 9 boxes of size 3x3 in sudoku\\n                    //-------------------and every value in box should be unique\\n                    temp = \"BOX\";\\n                    temp += toStr((i / 3) * 3 + (j / 3)) + (board[i][j]);\\n                    // cout<<temp<<endl;\\n                    if (mp.find(temp) == mp.end())\\n                    {\\n                        mp[temp]++;\\n                    }\\n                    else\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    string toStr(int k)\\n    {\\n        stringstream ss;\\n        ss << k;\\n        string s;\\n        ss >> s;\\n        return s;\\n    }\\n    bool isValidSudoku(vector<vector<char>> &board)\\n    {\\n        map<string, int> mp;\\n        string temp;\\n        int n = board.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (board[i][j] != \\'.\\')\\n                {\\n                    //-------------------Inserting for ROW and value in its cell\\n                    //-------------------In case the same row contains the duplicate values, we can find it by map/ set or any DS.\\n                    temp = \"ROW\";\\n                    temp += toStr(i) + (board[i][j]);\\n                    if (mp.find(temp) == mp.end())\\n                    {\\n                        mp[temp]++;\\n                    }\\n                    else\\n                        return false;\\n\\n                    //-------------------Inserting for COL and value in its cell\\n                    temp = \"COL\";\\n                    temp += toStr(j) + (board[i][j]);\\n                    if (mp.find(temp) == mp.end())\\n                    {\\n                        mp[temp]++;\\n                    }\\n                    else\\n                        return false;\\n\\n                    //-------------------Inserting for BOX \\n                    //-------------------There are 9 boxes of size 3x3 in sudoku\\n                    //-------------------and every value in box should be unique\\n                    temp = \"BOX\";\\n                    temp += toStr((i / 3) * 3 + (j / 3)) + (board[i][j]);\\n                    // cout<<temp<<endl;\\n                    if (mp.find(temp) == mp.end())\\n                    {\\n                        mp[temp]++;\\n                    }\\n                    else\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1714485,
                "title": "python-3-using-hash-o-n-time-o-n-space",
                "content": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        rows = [{} for _ in range(9)] # check which value exists in each row\\n        cols = [{} for _ in range(9)] # check which value exists in each column\\n        boxes = [{} for _ in range(9)] # check which value exists in each box\\n        for row in range(9):\\n            for col in range(9):\\n                bIdx =(row//3)*3 + col//3 # convert cell location to box location\\n                v = board[row][col]\\n                if v!=\\'.\\':\\n                    if v in rows[row] or v in cols[col] or v in boxes[bIdx]: # if exist in either rows/cols/boxes\\n                        return False\\n                    else: # add them in\\n                        rows[row][v] = True\\n                        cols[col][v] = True\\n                        boxes[bIdx][v] = True\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        rows = [{} for _ in range(9)] # check which value exists in each row\\n        cols = [{} for _ in range(9)] # check which value exists in each column\\n        boxes = [{} for _ in range(9)] # check which value exists in each box\\n        for row in range(9):\\n            for col in range(9):\\n                bIdx =(row//3)*3 + col//3 # convert cell location to box location\\n                v = board[row][col]\\n                if v!=\\'.\\':\\n                    if v in rows[row] or v in cols[col] or v in boxes[bIdx]: # if exist in either rows/cols/boxes\\n                        return False\\n                    else: # add them in\\n                        rows[row][v] = True\\n                        cols[col][v] = True\\n                        boxes[bIdx][v] = True\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1442272,
                "title": "c-using-set",
                "content": "**Please Upvote if you like!**\\n\\n     bool isValidSudoku(vector<vector<char>>& board) {\\n\\t\\t// Create vectors of unordered sets to keep track of numbers in rows, columns, and boxes\\n\\t\\tvector<unordered_set<int>> rows(9);\\n\\t\\tvector<unordered_set<int>> columns(9);\\n\\t\\tvector<unordered_set<int>> boxes(9);\\n\\n\\t\\t// Iterate through each cell in the Sudoku board\\n\\t\\tfor (int i = 0; i < 9; i++) {\\n\\t\\t\\tfor (int j = 0; j < 9; j++) {\\n\\t\\t\\t\\t// If the cell is empty, continue to the next cell\\n\\t\\t\\t\\tif (board[i][j] == \\'.\\') {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Convert the character to an integer to get the number in the cell\\n\\t\\t\\t\\tint num = board[i][j] - \\'0\\';\\n\\n\\t\\t\\t\\t// Check if the same number already exists in the current row\\n\\t\\t\\t\\tif (rows[i].count(num)) {\\n\\t\\t\\t\\t\\treturn false; // If yes, the Sudoku is invalid\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Check if the same number already exists in the current column\\n\\t\\t\\t\\tif (columns[j].count(num)) {\\n\\t\\t\\t\\t\\treturn false; // If yes, the Sudoku is invalid\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Calculate the index of the box the current cell belongs to\\n\\t\\t\\t\\tint index = (i / 3) * 3 + j / 3;\\n\\n\\t\\t\\t\\t// Check if the same number already exists in the current box\\n\\t\\t\\t\\tif (boxes[index].count(num)) {\\n\\t\\t\\t\\t\\treturn false; // If yes, the Sudoku is invalid\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// If the number doesn\\'t violate any rules, insert it into the sets\\n\\t\\t\\t\\trows[i].insert(num);\\n\\t\\t\\t\\tcolumns[j].insert(num);\\n\\t\\t\\t\\tboxes[index].insert(num);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// If the Sudoku has been checked and no violations were found, it\\'s valid\\n\\t\\treturn true;\\n\\t}\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "**Please Upvote if you like!**\\n\\n     bool isValidSudoku(vector<vector<char>>& board) {\\n\\t\\t// Create vectors of unordered sets to keep track of numbers in rows, columns, and boxes\\n\\t\\tvector<unordered_set<int>> rows(9);\\n\\t\\tvector<unordered_set<int>> columns(9);\\n\\t\\tvector<unordered_set<int>> boxes(9);\\n\\n\\t\\t// Iterate through each cell in the Sudoku board\\n\\t\\tfor (int i = 0; i < 9; i++) {\\n\\t\\t\\tfor (int j = 0; j < 9; j++) {\\n\\t\\t\\t\\t// If the cell is empty, continue to the next cell\\n\\t\\t\\t\\tif (board[i][j] == \\'.\\') {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Convert the character to an integer to get the number in the cell\\n\\t\\t\\t\\tint num = board[i][j] - \\'0\\';\\n\\n\\t\\t\\t\\t// Check if the same number already exists in the current row\\n\\t\\t\\t\\tif (rows[i].count(num)) {\\n\\t\\t\\t\\t\\treturn false; // If yes, the Sudoku is invalid\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Check if the same number already exists in the current column\\n\\t\\t\\t\\tif (columns[j].count(num)) {\\n\\t\\t\\t\\t\\treturn false; // If yes, the Sudoku is invalid\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Calculate the index of the box the current cell belongs to\\n\\t\\t\\t\\tint index = (i / 3) * 3 + j / 3;\\n\\n\\t\\t\\t\\t// Check if the same number already exists in the current box\\n\\t\\t\\t\\tif (boxes[index].count(num)) {\\n\\t\\t\\t\\t\\treturn false; // If yes, the Sudoku is invalid\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// If the number doesn\\'t violate any rules, insert it into the sets\\n\\t\\t\\t\\trows[i].insert(num);\\n\\t\\t\\t\\tcolumns[j].insert(num);\\n\\t\\t\\t\\tboxes[index].insert(num);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// If the Sudoku has been checked and no violations were found, it\\'s valid\\n\\t\\treturn true;\\n\\t}\\n",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1566470,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1568854,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1572579,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1711763,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1565592,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1567818,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1798774,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1576771,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1572483,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1921338,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1566470,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1568854,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1572579,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1711763,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1565592,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1567818,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1798774,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1576771,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1572483,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1921338,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1683701,
                "content": [
                    {
                        "username": "bikcrum",
                        "content": "Why is this a medium problem? Should be easy imo."
                    },
                    {
                        "username": "Demaxl",
                        "content": "If its too easy for you just move on to another problem why do you have to say this. A beginner might find it difficult "
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Yeah it should be hard."
                    },
                    {
                        "username": "leetcancode",
                        "content": "No bru, not easy for beginners."
                    },
                    {
                        "username": "192731",
                        "content": "the boxes though"
                    },
                    {
                        "username": "egithinji",
                        "content": "I must say, I agree"
                    },
                    {
                        "username": "glaucusec",
                        "content": "[@thepasterover](/thepasterover) can relate to this"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "[@Naveen_kumar_0910](/Naveen_kumar_0910)  just use mapping for numbers it will be easy "
                    },
                    {
                        "username": "Naveen_kumar_0910",
                        "content": "can you give out any hint to solve the condition with grids"
                    },
                    {
                        "username": "thepasterover",
                        "content": "[@Zelda_Galadriel](/Zelda_Galadriel) Hard agree. I have figured out how to do rows and cols. I just cant figure out how to do it with grids"
                    },
                    {
                        "username": "Zelda_Galadriel",
                        "content": "Nah the easy version of this problem would just be the rows and columns, without the boxes."
                    },
                    {
                        "username": "user2628Z",
                        "content": "\\nHow can this expect true?\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "This is true because there\\'s no repeatition in the columns, rows and 3 x 3 sub square. Check the question description."
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "raman56",
                        "content": "\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nthere\\'s no valid sudoku fro this testcase"
                    },
                    {
                        "username": "ZhixiL",
                        "content": "Since its stated that \"A Sudoku board (partially filled) could be valid but is not necessarily solvable.\"\\nAnd for this case, all the three restriction passed:\\nEach row must contain the digits 1-9 without repetition. (Check)\\nEach column must contain the digits 1-9 without repetition. (Check)\\nEach of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. (Check)\\nSo this is a valid case."
                    },
                    {
                        "username": "user5378Ua",
                        "content": "[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n [\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n [\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWhy that case(368) should return false?"
                    },
                    {
                        "username": "asthashrivastava11",
                        "content": "Why the following test case must return true? \\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThere are no digits in any row/columns or quadrant? As per the description a valid sudoku is where each row/column and quadrant must contain digit from 1-9 without repetition. Hence the above case must return false but expected is true. can anyone explain? "
                    },
                    {
                        "username": "mihir-k5",
                        "content": "Only filled cells need to be validated with the rule. Your code should ignore any cells with \".\" (dot). This type of problems, you check for a rule, and even a single False is enough to stop the function. But True is returned only at very end, after all checks are done. So the code should skip all \".\" then the last line of your function will return True."
                    },
                    {
                        "username": "amitjha00",
                        "content": "can anyone help me in checking that non repeating elements in box 3x3 how to check"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "To get the indexes for the boxes divide row and column by 3."
                    },
                    {
                        "username": "betrayy",
                        "content": "Was it just me who couldn\\'t figure out the \"formula\" for knowing which sub-box you\\'re in at position (r,c)? "
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is expected to return false, but i think it is clearly true bcoz there is no repitation?\\nCan anyone please tell me what is wrong in this?\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],\\n[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],\\n[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],\\n[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "oh thankyou karthik i just got it\ni missed the condition of 3x3"
                    },
                    {
                        "username": "KarthikV123",
                        "content": "Its False as we have 1 in positions (1,8) and (3,9)\\n"
                    },
                    {
                        "username": "mdw",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "Padma_Dhar",
                        "content": "This should evaluate to false. However OJ says it is true\\n\\n[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"4\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"6\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"5\"]]"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "the testcases might be confusing"
                    }
                ]
            },
            {
                "id": 1569508,
                "content": [
                    {
                        "username": "bikcrum",
                        "content": "Why is this a medium problem? Should be easy imo."
                    },
                    {
                        "username": "Demaxl",
                        "content": "If its too easy for you just move on to another problem why do you have to say this. A beginner might find it difficult "
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Yeah it should be hard."
                    },
                    {
                        "username": "leetcancode",
                        "content": "No bru, not easy for beginners."
                    },
                    {
                        "username": "192731",
                        "content": "the boxes though"
                    },
                    {
                        "username": "egithinji",
                        "content": "I must say, I agree"
                    },
                    {
                        "username": "glaucusec",
                        "content": "[@thepasterover](/thepasterover) can relate to this"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "[@Naveen_kumar_0910](/Naveen_kumar_0910)  just use mapping for numbers it will be easy "
                    },
                    {
                        "username": "Naveen_kumar_0910",
                        "content": "can you give out any hint to solve the condition with grids"
                    },
                    {
                        "username": "thepasterover",
                        "content": "[@Zelda_Galadriel](/Zelda_Galadriel) Hard agree. I have figured out how to do rows and cols. I just cant figure out how to do it with grids"
                    },
                    {
                        "username": "Zelda_Galadriel",
                        "content": "Nah the easy version of this problem would just be the rows and columns, without the boxes."
                    },
                    {
                        "username": "user2628Z",
                        "content": "\\nHow can this expect true?\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "This is true because there\\'s no repeatition in the columns, rows and 3 x 3 sub square. Check the question description."
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "raman56",
                        "content": "\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nthere\\'s no valid sudoku fro this testcase"
                    },
                    {
                        "username": "ZhixiL",
                        "content": "Since its stated that \"A Sudoku board (partially filled) could be valid but is not necessarily solvable.\"\\nAnd for this case, all the three restriction passed:\\nEach row must contain the digits 1-9 without repetition. (Check)\\nEach column must contain the digits 1-9 without repetition. (Check)\\nEach of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. (Check)\\nSo this is a valid case."
                    },
                    {
                        "username": "user5378Ua",
                        "content": "[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n [\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n [\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWhy that case(368) should return false?"
                    },
                    {
                        "username": "asthashrivastava11",
                        "content": "Why the following test case must return true? \\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThere are no digits in any row/columns or quadrant? As per the description a valid sudoku is where each row/column and quadrant must contain digit from 1-9 without repetition. Hence the above case must return false but expected is true. can anyone explain? "
                    },
                    {
                        "username": "mihir-k5",
                        "content": "Only filled cells need to be validated with the rule. Your code should ignore any cells with \".\" (dot). This type of problems, you check for a rule, and even a single False is enough to stop the function. But True is returned only at very end, after all checks are done. So the code should skip all \".\" then the last line of your function will return True."
                    },
                    {
                        "username": "amitjha00",
                        "content": "can anyone help me in checking that non repeating elements in box 3x3 how to check"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "To get the indexes for the boxes divide row and column by 3."
                    },
                    {
                        "username": "betrayy",
                        "content": "Was it just me who couldn\\'t figure out the \"formula\" for knowing which sub-box you\\'re in at position (r,c)? "
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is expected to return false, but i think it is clearly true bcoz there is no repitation?\\nCan anyone please tell me what is wrong in this?\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],\\n[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],\\n[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],\\n[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "oh thankyou karthik i just got it\ni missed the condition of 3x3"
                    },
                    {
                        "username": "KarthikV123",
                        "content": "Its False as we have 1 in positions (1,8) and (3,9)\\n"
                    },
                    {
                        "username": "mdw",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "Padma_Dhar",
                        "content": "This should evaluate to false. However OJ says it is true\\n\\n[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"4\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"6\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"5\"]]"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "the testcases might be confusing"
                    }
                ]
            },
            {
                "id": 1567730,
                "content": [
                    {
                        "username": "bikcrum",
                        "content": "Why is this a medium problem? Should be easy imo."
                    },
                    {
                        "username": "Demaxl",
                        "content": "If its too easy for you just move on to another problem why do you have to say this. A beginner might find it difficult "
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Yeah it should be hard."
                    },
                    {
                        "username": "leetcancode",
                        "content": "No bru, not easy for beginners."
                    },
                    {
                        "username": "192731",
                        "content": "the boxes though"
                    },
                    {
                        "username": "egithinji",
                        "content": "I must say, I agree"
                    },
                    {
                        "username": "glaucusec",
                        "content": "[@thepasterover](/thepasterover) can relate to this"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "[@Naveen_kumar_0910](/Naveen_kumar_0910)  just use mapping for numbers it will be easy "
                    },
                    {
                        "username": "Naveen_kumar_0910",
                        "content": "can you give out any hint to solve the condition with grids"
                    },
                    {
                        "username": "thepasterover",
                        "content": "[@Zelda_Galadriel](/Zelda_Galadriel) Hard agree. I have figured out how to do rows and cols. I just cant figure out how to do it with grids"
                    },
                    {
                        "username": "Zelda_Galadriel",
                        "content": "Nah the easy version of this problem would just be the rows and columns, without the boxes."
                    },
                    {
                        "username": "user2628Z",
                        "content": "\\nHow can this expect true?\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "This is true because there\\'s no repeatition in the columns, rows and 3 x 3 sub square. Check the question description."
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "raman56",
                        "content": "\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nthere\\'s no valid sudoku fro this testcase"
                    },
                    {
                        "username": "ZhixiL",
                        "content": "Since its stated that \"A Sudoku board (partially filled) could be valid but is not necessarily solvable.\"\\nAnd for this case, all the three restriction passed:\\nEach row must contain the digits 1-9 without repetition. (Check)\\nEach column must contain the digits 1-9 without repetition. (Check)\\nEach of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. (Check)\\nSo this is a valid case."
                    },
                    {
                        "username": "user5378Ua",
                        "content": "[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n [\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n [\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWhy that case(368) should return false?"
                    },
                    {
                        "username": "asthashrivastava11",
                        "content": "Why the following test case must return true? \\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThere are no digits in any row/columns or quadrant? As per the description a valid sudoku is where each row/column and quadrant must contain digit from 1-9 without repetition. Hence the above case must return false but expected is true. can anyone explain? "
                    },
                    {
                        "username": "mihir-k5",
                        "content": "Only filled cells need to be validated with the rule. Your code should ignore any cells with \".\" (dot). This type of problems, you check for a rule, and even a single False is enough to stop the function. But True is returned only at very end, after all checks are done. So the code should skip all \".\" then the last line of your function will return True."
                    },
                    {
                        "username": "amitjha00",
                        "content": "can anyone help me in checking that non repeating elements in box 3x3 how to check"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "To get the indexes for the boxes divide row and column by 3."
                    },
                    {
                        "username": "betrayy",
                        "content": "Was it just me who couldn\\'t figure out the \"formula\" for knowing which sub-box you\\'re in at position (r,c)? "
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is expected to return false, but i think it is clearly true bcoz there is no repitation?\\nCan anyone please tell me what is wrong in this?\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],\\n[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],\\n[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],\\n[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "oh thankyou karthik i just got it\ni missed the condition of 3x3"
                    },
                    {
                        "username": "KarthikV123",
                        "content": "Its False as we have 1 in positions (1,8) and (3,9)\\n"
                    },
                    {
                        "username": "mdw",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "Padma_Dhar",
                        "content": "This should evaluate to false. However OJ says it is true\\n\\n[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"4\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"6\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"5\"]]"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "the testcases might be confusing"
                    }
                ]
            },
            {
                "id": 1862520,
                "content": [
                    {
                        "username": "bikcrum",
                        "content": "Why is this a medium problem? Should be easy imo."
                    },
                    {
                        "username": "Demaxl",
                        "content": "If its too easy for you just move on to another problem why do you have to say this. A beginner might find it difficult "
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Yeah it should be hard."
                    },
                    {
                        "username": "leetcancode",
                        "content": "No bru, not easy for beginners."
                    },
                    {
                        "username": "192731",
                        "content": "the boxes though"
                    },
                    {
                        "username": "egithinji",
                        "content": "I must say, I agree"
                    },
                    {
                        "username": "glaucusec",
                        "content": "[@thepasterover](/thepasterover) can relate to this"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "[@Naveen_kumar_0910](/Naveen_kumar_0910)  just use mapping for numbers it will be easy "
                    },
                    {
                        "username": "Naveen_kumar_0910",
                        "content": "can you give out any hint to solve the condition with grids"
                    },
                    {
                        "username": "thepasterover",
                        "content": "[@Zelda_Galadriel](/Zelda_Galadriel) Hard agree. I have figured out how to do rows and cols. I just cant figure out how to do it with grids"
                    },
                    {
                        "username": "Zelda_Galadriel",
                        "content": "Nah the easy version of this problem would just be the rows and columns, without the boxes."
                    },
                    {
                        "username": "user2628Z",
                        "content": "\\nHow can this expect true?\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "This is true because there\\'s no repeatition in the columns, rows and 3 x 3 sub square. Check the question description."
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "raman56",
                        "content": "\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nthere\\'s no valid sudoku fro this testcase"
                    },
                    {
                        "username": "ZhixiL",
                        "content": "Since its stated that \"A Sudoku board (partially filled) could be valid but is not necessarily solvable.\"\\nAnd for this case, all the three restriction passed:\\nEach row must contain the digits 1-9 without repetition. (Check)\\nEach column must contain the digits 1-9 without repetition. (Check)\\nEach of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. (Check)\\nSo this is a valid case."
                    },
                    {
                        "username": "user5378Ua",
                        "content": "[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n [\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n [\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWhy that case(368) should return false?"
                    },
                    {
                        "username": "asthashrivastava11",
                        "content": "Why the following test case must return true? \\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThere are no digits in any row/columns or quadrant? As per the description a valid sudoku is where each row/column and quadrant must contain digit from 1-9 without repetition. Hence the above case must return false but expected is true. can anyone explain? "
                    },
                    {
                        "username": "mihir-k5",
                        "content": "Only filled cells need to be validated with the rule. Your code should ignore any cells with \".\" (dot). This type of problems, you check for a rule, and even a single False is enough to stop the function. But True is returned only at very end, after all checks are done. So the code should skip all \".\" then the last line of your function will return True."
                    },
                    {
                        "username": "amitjha00",
                        "content": "can anyone help me in checking that non repeating elements in box 3x3 how to check"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "To get the indexes for the boxes divide row and column by 3."
                    },
                    {
                        "username": "betrayy",
                        "content": "Was it just me who couldn\\'t figure out the \"formula\" for knowing which sub-box you\\'re in at position (r,c)? "
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is expected to return false, but i think it is clearly true bcoz there is no repitation?\\nCan anyone please tell me what is wrong in this?\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],\\n[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],\\n[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],\\n[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "oh thankyou karthik i just got it\ni missed the condition of 3x3"
                    },
                    {
                        "username": "KarthikV123",
                        "content": "Its False as we have 1 in positions (1,8) and (3,9)\\n"
                    },
                    {
                        "username": "mdw",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "Padma_Dhar",
                        "content": "This should evaluate to false. However OJ says it is true\\n\\n[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"4\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"6\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"5\"]]"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "the testcases might be confusing"
                    }
                ]
            },
            {
                "id": 1809889,
                "content": [
                    {
                        "username": "bikcrum",
                        "content": "Why is this a medium problem? Should be easy imo."
                    },
                    {
                        "username": "Demaxl",
                        "content": "If its too easy for you just move on to another problem why do you have to say this. A beginner might find it difficult "
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Yeah it should be hard."
                    },
                    {
                        "username": "leetcancode",
                        "content": "No bru, not easy for beginners."
                    },
                    {
                        "username": "192731",
                        "content": "the boxes though"
                    },
                    {
                        "username": "egithinji",
                        "content": "I must say, I agree"
                    },
                    {
                        "username": "glaucusec",
                        "content": "[@thepasterover](/thepasterover) can relate to this"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "[@Naveen_kumar_0910](/Naveen_kumar_0910)  just use mapping for numbers it will be easy "
                    },
                    {
                        "username": "Naveen_kumar_0910",
                        "content": "can you give out any hint to solve the condition with grids"
                    },
                    {
                        "username": "thepasterover",
                        "content": "[@Zelda_Galadriel](/Zelda_Galadriel) Hard agree. I have figured out how to do rows and cols. I just cant figure out how to do it with grids"
                    },
                    {
                        "username": "Zelda_Galadriel",
                        "content": "Nah the easy version of this problem would just be the rows and columns, without the boxes."
                    },
                    {
                        "username": "user2628Z",
                        "content": "\\nHow can this expect true?\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "This is true because there\\'s no repeatition in the columns, rows and 3 x 3 sub square. Check the question description."
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "raman56",
                        "content": "\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nthere\\'s no valid sudoku fro this testcase"
                    },
                    {
                        "username": "ZhixiL",
                        "content": "Since its stated that \"A Sudoku board (partially filled) could be valid but is not necessarily solvable.\"\\nAnd for this case, all the three restriction passed:\\nEach row must contain the digits 1-9 without repetition. (Check)\\nEach column must contain the digits 1-9 without repetition. (Check)\\nEach of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. (Check)\\nSo this is a valid case."
                    },
                    {
                        "username": "user5378Ua",
                        "content": "[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n [\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n [\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWhy that case(368) should return false?"
                    },
                    {
                        "username": "asthashrivastava11",
                        "content": "Why the following test case must return true? \\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThere are no digits in any row/columns or quadrant? As per the description a valid sudoku is where each row/column and quadrant must contain digit from 1-9 without repetition. Hence the above case must return false but expected is true. can anyone explain? "
                    },
                    {
                        "username": "mihir-k5",
                        "content": "Only filled cells need to be validated with the rule. Your code should ignore any cells with \".\" (dot). This type of problems, you check for a rule, and even a single False is enough to stop the function. But True is returned only at very end, after all checks are done. So the code should skip all \".\" then the last line of your function will return True."
                    },
                    {
                        "username": "amitjha00",
                        "content": "can anyone help me in checking that non repeating elements in box 3x3 how to check"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "To get the indexes for the boxes divide row and column by 3."
                    },
                    {
                        "username": "betrayy",
                        "content": "Was it just me who couldn\\'t figure out the \"formula\" for knowing which sub-box you\\'re in at position (r,c)? "
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is expected to return false, but i think it is clearly true bcoz there is no repitation?\\nCan anyone please tell me what is wrong in this?\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],\\n[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],\\n[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],\\n[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "oh thankyou karthik i just got it\ni missed the condition of 3x3"
                    },
                    {
                        "username": "KarthikV123",
                        "content": "Its False as we have 1 in positions (1,8) and (3,9)\\n"
                    },
                    {
                        "username": "mdw",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "Padma_Dhar",
                        "content": "This should evaluate to false. However OJ says it is true\\n\\n[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"4\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"6\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"5\"]]"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "the testcases might be confusing"
                    }
                ]
            },
            {
                "id": 1884629,
                "content": [
                    {
                        "username": "bikcrum",
                        "content": "Why is this a medium problem? Should be easy imo."
                    },
                    {
                        "username": "Demaxl",
                        "content": "If its too easy for you just move on to another problem why do you have to say this. A beginner might find it difficult "
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Yeah it should be hard."
                    },
                    {
                        "username": "leetcancode",
                        "content": "No bru, not easy for beginners."
                    },
                    {
                        "username": "192731",
                        "content": "the boxes though"
                    },
                    {
                        "username": "egithinji",
                        "content": "I must say, I agree"
                    },
                    {
                        "username": "glaucusec",
                        "content": "[@thepasterover](/thepasterover) can relate to this"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "[@Naveen_kumar_0910](/Naveen_kumar_0910)  just use mapping for numbers it will be easy "
                    },
                    {
                        "username": "Naveen_kumar_0910",
                        "content": "can you give out any hint to solve the condition with grids"
                    },
                    {
                        "username": "thepasterover",
                        "content": "[@Zelda_Galadriel](/Zelda_Galadriel) Hard agree. I have figured out how to do rows and cols. I just cant figure out how to do it with grids"
                    },
                    {
                        "username": "Zelda_Galadriel",
                        "content": "Nah the easy version of this problem would just be the rows and columns, without the boxes."
                    },
                    {
                        "username": "user2628Z",
                        "content": "\\nHow can this expect true?\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "This is true because there\\'s no repeatition in the columns, rows and 3 x 3 sub square. Check the question description."
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "raman56",
                        "content": "\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nthere\\'s no valid sudoku fro this testcase"
                    },
                    {
                        "username": "ZhixiL",
                        "content": "Since its stated that \"A Sudoku board (partially filled) could be valid but is not necessarily solvable.\"\\nAnd for this case, all the three restriction passed:\\nEach row must contain the digits 1-9 without repetition. (Check)\\nEach column must contain the digits 1-9 without repetition. (Check)\\nEach of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. (Check)\\nSo this is a valid case."
                    },
                    {
                        "username": "user5378Ua",
                        "content": "[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n [\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n [\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWhy that case(368) should return false?"
                    },
                    {
                        "username": "asthashrivastava11",
                        "content": "Why the following test case must return true? \\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThere are no digits in any row/columns or quadrant? As per the description a valid sudoku is where each row/column and quadrant must contain digit from 1-9 without repetition. Hence the above case must return false but expected is true. can anyone explain? "
                    },
                    {
                        "username": "mihir-k5",
                        "content": "Only filled cells need to be validated with the rule. Your code should ignore any cells with \".\" (dot). This type of problems, you check for a rule, and even a single False is enough to stop the function. But True is returned only at very end, after all checks are done. So the code should skip all \".\" then the last line of your function will return True."
                    },
                    {
                        "username": "amitjha00",
                        "content": "can anyone help me in checking that non repeating elements in box 3x3 how to check"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "To get the indexes for the boxes divide row and column by 3."
                    },
                    {
                        "username": "betrayy",
                        "content": "Was it just me who couldn\\'t figure out the \"formula\" for knowing which sub-box you\\'re in at position (r,c)? "
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is expected to return false, but i think it is clearly true bcoz there is no repitation?\\nCan anyone please tell me what is wrong in this?\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],\\n[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],\\n[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],\\n[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "oh thankyou karthik i just got it\ni missed the condition of 3x3"
                    },
                    {
                        "username": "KarthikV123",
                        "content": "Its False as we have 1 in positions (1,8) and (3,9)\\n"
                    },
                    {
                        "username": "mdw",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "Padma_Dhar",
                        "content": "This should evaluate to false. However OJ says it is true\\n\\n[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"4\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"6\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"5\"]]"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "the testcases might be confusing"
                    }
                ]
            },
            {
                "id": 1770423,
                "content": [
                    {
                        "username": "bikcrum",
                        "content": "Why is this a medium problem? Should be easy imo."
                    },
                    {
                        "username": "Demaxl",
                        "content": "If its too easy for you just move on to another problem why do you have to say this. A beginner might find it difficult "
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Yeah it should be hard."
                    },
                    {
                        "username": "leetcancode",
                        "content": "No bru, not easy for beginners."
                    },
                    {
                        "username": "192731",
                        "content": "the boxes though"
                    },
                    {
                        "username": "egithinji",
                        "content": "I must say, I agree"
                    },
                    {
                        "username": "glaucusec",
                        "content": "[@thepasterover](/thepasterover) can relate to this"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "[@Naveen_kumar_0910](/Naveen_kumar_0910)  just use mapping for numbers it will be easy "
                    },
                    {
                        "username": "Naveen_kumar_0910",
                        "content": "can you give out any hint to solve the condition with grids"
                    },
                    {
                        "username": "thepasterover",
                        "content": "[@Zelda_Galadriel](/Zelda_Galadriel) Hard agree. I have figured out how to do rows and cols. I just cant figure out how to do it with grids"
                    },
                    {
                        "username": "Zelda_Galadriel",
                        "content": "Nah the easy version of this problem would just be the rows and columns, without the boxes."
                    },
                    {
                        "username": "user2628Z",
                        "content": "\\nHow can this expect true?\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "This is true because there\\'s no repeatition in the columns, rows and 3 x 3 sub square. Check the question description."
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "raman56",
                        "content": "\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nthere\\'s no valid sudoku fro this testcase"
                    },
                    {
                        "username": "ZhixiL",
                        "content": "Since its stated that \"A Sudoku board (partially filled) could be valid but is not necessarily solvable.\"\\nAnd for this case, all the three restriction passed:\\nEach row must contain the digits 1-9 without repetition. (Check)\\nEach column must contain the digits 1-9 without repetition. (Check)\\nEach of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. (Check)\\nSo this is a valid case."
                    },
                    {
                        "username": "user5378Ua",
                        "content": "[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n [\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n [\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWhy that case(368) should return false?"
                    },
                    {
                        "username": "asthashrivastava11",
                        "content": "Why the following test case must return true? \\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThere are no digits in any row/columns or quadrant? As per the description a valid sudoku is where each row/column and quadrant must contain digit from 1-9 without repetition. Hence the above case must return false but expected is true. can anyone explain? "
                    },
                    {
                        "username": "mihir-k5",
                        "content": "Only filled cells need to be validated with the rule. Your code should ignore any cells with \".\" (dot). This type of problems, you check for a rule, and even a single False is enough to stop the function. But True is returned only at very end, after all checks are done. So the code should skip all \".\" then the last line of your function will return True."
                    },
                    {
                        "username": "amitjha00",
                        "content": "can anyone help me in checking that non repeating elements in box 3x3 how to check"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "To get the indexes for the boxes divide row and column by 3."
                    },
                    {
                        "username": "betrayy",
                        "content": "Was it just me who couldn\\'t figure out the \"formula\" for knowing which sub-box you\\'re in at position (r,c)? "
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is expected to return false, but i think it is clearly true bcoz there is no repitation?\\nCan anyone please tell me what is wrong in this?\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],\\n[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],\\n[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],\\n[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "oh thankyou karthik i just got it\ni missed the condition of 3x3"
                    },
                    {
                        "username": "KarthikV123",
                        "content": "Its False as we have 1 in positions (1,8) and (3,9)\\n"
                    },
                    {
                        "username": "mdw",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "Padma_Dhar",
                        "content": "This should evaluate to false. However OJ says it is true\\n\\n[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"4\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"6\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"5\"]]"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "the testcases might be confusing"
                    }
                ]
            },
            {
                "id": 1694929,
                "content": [
                    {
                        "username": "bikcrum",
                        "content": "Why is this a medium problem? Should be easy imo."
                    },
                    {
                        "username": "Demaxl",
                        "content": "If its too easy for you just move on to another problem why do you have to say this. A beginner might find it difficult "
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Yeah it should be hard."
                    },
                    {
                        "username": "leetcancode",
                        "content": "No bru, not easy for beginners."
                    },
                    {
                        "username": "192731",
                        "content": "the boxes though"
                    },
                    {
                        "username": "egithinji",
                        "content": "I must say, I agree"
                    },
                    {
                        "username": "glaucusec",
                        "content": "[@thepasterover](/thepasterover) can relate to this"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "[@Naveen_kumar_0910](/Naveen_kumar_0910)  just use mapping for numbers it will be easy "
                    },
                    {
                        "username": "Naveen_kumar_0910",
                        "content": "can you give out any hint to solve the condition with grids"
                    },
                    {
                        "username": "thepasterover",
                        "content": "[@Zelda_Galadriel](/Zelda_Galadriel) Hard agree. I have figured out how to do rows and cols. I just cant figure out how to do it with grids"
                    },
                    {
                        "username": "Zelda_Galadriel",
                        "content": "Nah the easy version of this problem would just be the rows and columns, without the boxes."
                    },
                    {
                        "username": "user2628Z",
                        "content": "\\nHow can this expect true?\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "This is true because there\\'s no repeatition in the columns, rows and 3 x 3 sub square. Check the question description."
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "raman56",
                        "content": "\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nthere\\'s no valid sudoku fro this testcase"
                    },
                    {
                        "username": "ZhixiL",
                        "content": "Since its stated that \"A Sudoku board (partially filled) could be valid but is not necessarily solvable.\"\\nAnd for this case, all the three restriction passed:\\nEach row must contain the digits 1-9 without repetition. (Check)\\nEach column must contain the digits 1-9 without repetition. (Check)\\nEach of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. (Check)\\nSo this is a valid case."
                    },
                    {
                        "username": "user5378Ua",
                        "content": "[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n [\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n [\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWhy that case(368) should return false?"
                    },
                    {
                        "username": "asthashrivastava11",
                        "content": "Why the following test case must return true? \\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThere are no digits in any row/columns or quadrant? As per the description a valid sudoku is where each row/column and quadrant must contain digit from 1-9 without repetition. Hence the above case must return false but expected is true. can anyone explain? "
                    },
                    {
                        "username": "mihir-k5",
                        "content": "Only filled cells need to be validated with the rule. Your code should ignore any cells with \".\" (dot). This type of problems, you check for a rule, and even a single False is enough to stop the function. But True is returned only at very end, after all checks are done. So the code should skip all \".\" then the last line of your function will return True."
                    },
                    {
                        "username": "amitjha00",
                        "content": "can anyone help me in checking that non repeating elements in box 3x3 how to check"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "To get the indexes for the boxes divide row and column by 3."
                    },
                    {
                        "username": "betrayy",
                        "content": "Was it just me who couldn\\'t figure out the \"formula\" for knowing which sub-box you\\'re in at position (r,c)? "
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is expected to return false, but i think it is clearly true bcoz there is no repitation?\\nCan anyone please tell me what is wrong in this?\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],\\n[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],\\n[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],\\n[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "oh thankyou karthik i just got it\ni missed the condition of 3x3"
                    },
                    {
                        "username": "KarthikV123",
                        "content": "Its False as we have 1 in positions (1,8) and (3,9)\\n"
                    },
                    {
                        "username": "mdw",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "Padma_Dhar",
                        "content": "This should evaluate to false. However OJ says it is true\\n\\n[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"4\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"6\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"5\"]]"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "the testcases might be confusing"
                    }
                ]
            },
            {
                "id": 1571088,
                "content": [
                    {
                        "username": "bikcrum",
                        "content": "Why is this a medium problem? Should be easy imo."
                    },
                    {
                        "username": "Demaxl",
                        "content": "If its too easy for you just move on to another problem why do you have to say this. A beginner might find it difficult "
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Yeah it should be hard."
                    },
                    {
                        "username": "leetcancode",
                        "content": "No bru, not easy for beginners."
                    },
                    {
                        "username": "192731",
                        "content": "the boxes though"
                    },
                    {
                        "username": "egithinji",
                        "content": "I must say, I agree"
                    },
                    {
                        "username": "glaucusec",
                        "content": "[@thepasterover](/thepasterover) can relate to this"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "[@Naveen_kumar_0910](/Naveen_kumar_0910)  just use mapping for numbers it will be easy "
                    },
                    {
                        "username": "Naveen_kumar_0910",
                        "content": "can you give out any hint to solve the condition with grids"
                    },
                    {
                        "username": "thepasterover",
                        "content": "[@Zelda_Galadriel](/Zelda_Galadriel) Hard agree. I have figured out how to do rows and cols. I just cant figure out how to do it with grids"
                    },
                    {
                        "username": "Zelda_Galadriel",
                        "content": "Nah the easy version of this problem would just be the rows and columns, without the boxes."
                    },
                    {
                        "username": "user2628Z",
                        "content": "\\nHow can this expect true?\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "This is true because there\\'s no repeatition in the columns, rows and 3 x 3 sub square. Check the question description."
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "raman56",
                        "content": "\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nthere\\'s no valid sudoku fro this testcase"
                    },
                    {
                        "username": "ZhixiL",
                        "content": "Since its stated that \"A Sudoku board (partially filled) could be valid but is not necessarily solvable.\"\\nAnd for this case, all the three restriction passed:\\nEach row must contain the digits 1-9 without repetition. (Check)\\nEach column must contain the digits 1-9 without repetition. (Check)\\nEach of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. (Check)\\nSo this is a valid case."
                    },
                    {
                        "username": "user5378Ua",
                        "content": "[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n [\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n [\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWhy that case(368) should return false?"
                    },
                    {
                        "username": "asthashrivastava11",
                        "content": "Why the following test case must return true? \\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThere are no digits in any row/columns or quadrant? As per the description a valid sudoku is where each row/column and quadrant must contain digit from 1-9 without repetition. Hence the above case must return false but expected is true. can anyone explain? "
                    },
                    {
                        "username": "mihir-k5",
                        "content": "Only filled cells need to be validated with the rule. Your code should ignore any cells with \".\" (dot). This type of problems, you check for a rule, and even a single False is enough to stop the function. But True is returned only at very end, after all checks are done. So the code should skip all \".\" then the last line of your function will return True."
                    },
                    {
                        "username": "amitjha00",
                        "content": "can anyone help me in checking that non repeating elements in box 3x3 how to check"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "To get the indexes for the boxes divide row and column by 3."
                    },
                    {
                        "username": "betrayy",
                        "content": "Was it just me who couldn\\'t figure out the \"formula\" for knowing which sub-box you\\'re in at position (r,c)? "
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is expected to return false, but i think it is clearly true bcoz there is no repitation?\\nCan anyone please tell me what is wrong in this?\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],\\n[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],\\n[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],\\n[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "oh thankyou karthik i just got it\ni missed the condition of 3x3"
                    },
                    {
                        "username": "KarthikV123",
                        "content": "Its False as we have 1 in positions (1,8) and (3,9)\\n"
                    },
                    {
                        "username": "mdw",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "Padma_Dhar",
                        "content": "This should evaluate to false. However OJ says it is true\\n\\n[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"4\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"6\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"5\"]]"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "the testcases might be confusing"
                    }
                ]
            },
            {
                "id": 2076453,
                "content": [
                    {
                        "username": "bikcrum",
                        "content": "Why is this a medium problem? Should be easy imo."
                    },
                    {
                        "username": "Demaxl",
                        "content": "If its too easy for you just move on to another problem why do you have to say this. A beginner might find it difficult "
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Yeah it should be hard."
                    },
                    {
                        "username": "leetcancode",
                        "content": "No bru, not easy for beginners."
                    },
                    {
                        "username": "192731",
                        "content": "the boxes though"
                    },
                    {
                        "username": "egithinji",
                        "content": "I must say, I agree"
                    },
                    {
                        "username": "glaucusec",
                        "content": "[@thepasterover](/thepasterover) can relate to this"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "[@Naveen_kumar_0910](/Naveen_kumar_0910)  just use mapping for numbers it will be easy "
                    },
                    {
                        "username": "Naveen_kumar_0910",
                        "content": "can you give out any hint to solve the condition with grids"
                    },
                    {
                        "username": "thepasterover",
                        "content": "[@Zelda_Galadriel](/Zelda_Galadriel) Hard agree. I have figured out how to do rows and cols. I just cant figure out how to do it with grids"
                    },
                    {
                        "username": "Zelda_Galadriel",
                        "content": "Nah the easy version of this problem would just be the rows and columns, without the boxes."
                    },
                    {
                        "username": "user2628Z",
                        "content": "\\nHow can this expect true?\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "This is true because there\\'s no repeatition in the columns, rows and 3 x 3 sub square. Check the question description."
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "raman56",
                        "content": "\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nthere\\'s no valid sudoku fro this testcase"
                    },
                    {
                        "username": "ZhixiL",
                        "content": "Since its stated that \"A Sudoku board (partially filled) could be valid but is not necessarily solvable.\"\\nAnd for this case, all the three restriction passed:\\nEach row must contain the digits 1-9 without repetition. (Check)\\nEach column must contain the digits 1-9 without repetition. (Check)\\nEach of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. (Check)\\nSo this is a valid case."
                    },
                    {
                        "username": "user5378Ua",
                        "content": "[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n [\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n [\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWhy that case(368) should return false?"
                    },
                    {
                        "username": "asthashrivastava11",
                        "content": "Why the following test case must return true? \\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThere are no digits in any row/columns or quadrant? As per the description a valid sudoku is where each row/column and quadrant must contain digit from 1-9 without repetition. Hence the above case must return false but expected is true. can anyone explain? "
                    },
                    {
                        "username": "mihir-k5",
                        "content": "Only filled cells need to be validated with the rule. Your code should ignore any cells with \".\" (dot). This type of problems, you check for a rule, and even a single False is enough to stop the function. But True is returned only at very end, after all checks are done. So the code should skip all \".\" then the last line of your function will return True."
                    },
                    {
                        "username": "amitjha00",
                        "content": "can anyone help me in checking that non repeating elements in box 3x3 how to check"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "To get the indexes for the boxes divide row and column by 3."
                    },
                    {
                        "username": "betrayy",
                        "content": "Was it just me who couldn\\'t figure out the \"formula\" for knowing which sub-box you\\'re in at position (r,c)? "
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is expected to return false, but i think it is clearly true bcoz there is no repitation?\\nCan anyone please tell me what is wrong in this?\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],\\n[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],\\n[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],\\n[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "oh thankyou karthik i just got it\ni missed the condition of 3x3"
                    },
                    {
                        "username": "KarthikV123",
                        "content": "Its False as we have 1 in positions (1,8) and (3,9)\\n"
                    },
                    {
                        "username": "mdw",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "Padma_Dhar",
                        "content": "This should evaluate to false. However OJ says it is true\\n\\n[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"4\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"6\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"5\"]]"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "the testcases might be confusing"
                    }
                ]
            },
            {
                "id": 2071938,
                "content": [
                    {
                        "username": "ankitk742",
                        "content": "As a hint , A particular element can be uniquely identified by the row , column and block. Use this unique identifier to check if soduku is valid or not "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good bro"
                    },
                    {
                        "username": "AdamGold",
                        "content": "Why is this a medium? This question is basically asking if you know how for loops work and if you know how to determine if a character has been repeated. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yes, but to put everything together is not trivial."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@be4ko](/be4ko) Yes, two nested loops are O(n^2)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "idk"
                    },
                    {
                        "username": "be4ko",
                        "content": "if you are gonna only use for loops is that gonna be a O(n^2) ?? "
                    },
                    {
                        "username": "be4ko",
                        "content": "What Data Structure should I use to Solve this Problem Set ? Map ?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I am using arrays of unordered_set. unordered_set is using hashing, set is using a tree."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good question, I used ordered set"
                    },
                    {
                        "username": "revolution14",
                        "content": "getting runtime error when checking for duplicates in box, any hints? \n        `unordered_set<char> setRow, setColumn;\n        unordered_map<int, unordered_set<char>> setBox;\n\n        for(int i=0; i<9; i++){\n            for(int j=0; j<9; j++){\n                char num = board[i][j], num2 = board[j][i];\n                 \n                // checking for row\n                if(num!='.' && setRow.find(num)!=setRow.end())\n                    return false;\n                setRow.insert(num);\n\n                // checking for column\n                if(num2!='.' && setColumn.find(num2)!=setColumn.end())\n                    return false;\n                setColumn.insert(num2);\n\n                // checking for individual box\n                auto it = setBox.find((i/3)*3+j/3);\n                if(it==setBox.end()){\n                    setBox.insert({(i/3)*3+j/3, unordered_set<char> ({num})}) ;\n                }\n                else if(num!='.' && it->second.find(num)!=it->second.end())\n                    return false;\n                it->second.insert(num);\n\n                \n            }\n\n            setRow.clear();\n            setColumn.clear();\n        }\n\n        return true;\n`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "nope"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I got confused in string and char because of example contains \"\" on elements."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "i think \"\" will return false"
                    },
                    {
                        "username": "nadabao",
                        "content": "what a boring question."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I find it interesting."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "same"
                    },
                    {
                        "username": "Lainaaa",
                        "content": "The condition says that each row and column must have a number, but in the test where all the points are, the correct answer is true."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "what should be the time complexity for this code\\n"
                    },
                    {
                        "username": "weswithley",
                        "content": "This case looks no repition exist, but why output should be false ?\\n[\\n\\t[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n\\t[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n\\t[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n]\\n\\nUPDATE : \\nAs my understanding, all the re-org groups from top left to bottom right should be :  \\n1. [\".\", \".\", \"4\", \".\", \".\", \".\", \"5\", \".\", \".\"]\\n2. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n3. [\"6\", \"3\", \".\", \".\", \".\", \".\", \".\", \"9\", \".\"]\\n4. [\".\", \".\", \".\", \"4\", \".\", \"3\", \".\", \".\", \".\"]\\n5. [\"5\", \"6\", \".\", \".\", \".\", \".\", \"7\", \".\", \".\"]\\n6. [\".\", \"9\", \".\", \".\", \".\", \".\", \".\", \".\", \"1\"]\\n7. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n8. [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n9. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n\\nlooks like no repitation in each group. \\uD83E\\uDD14"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "There\\'s a repeatition in the first column. look out for 5"
                    },
                    {
                        "username": "Coder0622",
                        "content": "There\\'s a repetition in the first row. The number 5 exists in [5][0], and [8,0]."
                    },
                    {
                        "username": "AnkitRaj06",
                        "content": "Can someone please help me understand, how can the below test case give an output \"False\"?\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The fourth column has two 5\\'s: [3][3] and [7][3]"
                    }
                ]
            },
            {
                "id": 2052835,
                "content": [
                    {
                        "username": "ankitk742",
                        "content": "As a hint , A particular element can be uniquely identified by the row , column and block. Use this unique identifier to check if soduku is valid or not "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good bro"
                    },
                    {
                        "username": "AdamGold",
                        "content": "Why is this a medium? This question is basically asking if you know how for loops work and if you know how to determine if a character has been repeated. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yes, but to put everything together is not trivial."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@be4ko](/be4ko) Yes, two nested loops are O(n^2)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "idk"
                    },
                    {
                        "username": "be4ko",
                        "content": "if you are gonna only use for loops is that gonna be a O(n^2) ?? "
                    },
                    {
                        "username": "be4ko",
                        "content": "What Data Structure should I use to Solve this Problem Set ? Map ?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I am using arrays of unordered_set. unordered_set is using hashing, set is using a tree."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good question, I used ordered set"
                    },
                    {
                        "username": "revolution14",
                        "content": "getting runtime error when checking for duplicates in box, any hints? \n        `unordered_set<char> setRow, setColumn;\n        unordered_map<int, unordered_set<char>> setBox;\n\n        for(int i=0; i<9; i++){\n            for(int j=0; j<9; j++){\n                char num = board[i][j], num2 = board[j][i];\n                 \n                // checking for row\n                if(num!='.' && setRow.find(num)!=setRow.end())\n                    return false;\n                setRow.insert(num);\n\n                // checking for column\n                if(num2!='.' && setColumn.find(num2)!=setColumn.end())\n                    return false;\n                setColumn.insert(num2);\n\n                // checking for individual box\n                auto it = setBox.find((i/3)*3+j/3);\n                if(it==setBox.end()){\n                    setBox.insert({(i/3)*3+j/3, unordered_set<char> ({num})}) ;\n                }\n                else if(num!='.' && it->second.find(num)!=it->second.end())\n                    return false;\n                it->second.insert(num);\n\n                \n            }\n\n            setRow.clear();\n            setColumn.clear();\n        }\n\n        return true;\n`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "nope"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I got confused in string and char because of example contains \"\" on elements."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "i think \"\" will return false"
                    },
                    {
                        "username": "nadabao",
                        "content": "what a boring question."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I find it interesting."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "same"
                    },
                    {
                        "username": "Lainaaa",
                        "content": "The condition says that each row and column must have a number, but in the test where all the points are, the correct answer is true."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "what should be the time complexity for this code\\n"
                    },
                    {
                        "username": "weswithley",
                        "content": "This case looks no repition exist, but why output should be false ?\\n[\\n\\t[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n\\t[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n\\t[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n]\\n\\nUPDATE : \\nAs my understanding, all the re-org groups from top left to bottom right should be :  \\n1. [\".\", \".\", \"4\", \".\", \".\", \".\", \"5\", \".\", \".\"]\\n2. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n3. [\"6\", \"3\", \".\", \".\", \".\", \".\", \".\", \"9\", \".\"]\\n4. [\".\", \".\", \".\", \"4\", \".\", \"3\", \".\", \".\", \".\"]\\n5. [\"5\", \"6\", \".\", \".\", \".\", \".\", \"7\", \".\", \".\"]\\n6. [\".\", \"9\", \".\", \".\", \".\", \".\", \".\", \".\", \"1\"]\\n7. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n8. [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n9. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n\\nlooks like no repitation in each group. \\uD83E\\uDD14"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "There\\'s a repeatition in the first column. look out for 5"
                    },
                    {
                        "username": "Coder0622",
                        "content": "There\\'s a repetition in the first row. The number 5 exists in [5][0], and [8,0]."
                    },
                    {
                        "username": "AnkitRaj06",
                        "content": "Can someone please help me understand, how can the below test case give an output \"False\"?\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The fourth column has two 5\\'s: [3][3] and [7][3]"
                    }
                ]
            },
            {
                "id": 2051907,
                "content": [
                    {
                        "username": "ankitk742",
                        "content": "As a hint , A particular element can be uniquely identified by the row , column and block. Use this unique identifier to check if soduku is valid or not "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good bro"
                    },
                    {
                        "username": "AdamGold",
                        "content": "Why is this a medium? This question is basically asking if you know how for loops work and if you know how to determine if a character has been repeated. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yes, but to put everything together is not trivial."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@be4ko](/be4ko) Yes, two nested loops are O(n^2)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "idk"
                    },
                    {
                        "username": "be4ko",
                        "content": "if you are gonna only use for loops is that gonna be a O(n^2) ?? "
                    },
                    {
                        "username": "be4ko",
                        "content": "What Data Structure should I use to Solve this Problem Set ? Map ?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I am using arrays of unordered_set. unordered_set is using hashing, set is using a tree."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good question, I used ordered set"
                    },
                    {
                        "username": "revolution14",
                        "content": "getting runtime error when checking for duplicates in box, any hints? \n        `unordered_set<char> setRow, setColumn;\n        unordered_map<int, unordered_set<char>> setBox;\n\n        for(int i=0; i<9; i++){\n            for(int j=0; j<9; j++){\n                char num = board[i][j], num2 = board[j][i];\n                 \n                // checking for row\n                if(num!='.' && setRow.find(num)!=setRow.end())\n                    return false;\n                setRow.insert(num);\n\n                // checking for column\n                if(num2!='.' && setColumn.find(num2)!=setColumn.end())\n                    return false;\n                setColumn.insert(num2);\n\n                // checking for individual box\n                auto it = setBox.find((i/3)*3+j/3);\n                if(it==setBox.end()){\n                    setBox.insert({(i/3)*3+j/3, unordered_set<char> ({num})}) ;\n                }\n                else if(num!='.' && it->second.find(num)!=it->second.end())\n                    return false;\n                it->second.insert(num);\n\n                \n            }\n\n            setRow.clear();\n            setColumn.clear();\n        }\n\n        return true;\n`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "nope"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I got confused in string and char because of example contains \"\" on elements."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "i think \"\" will return false"
                    },
                    {
                        "username": "nadabao",
                        "content": "what a boring question."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I find it interesting."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "same"
                    },
                    {
                        "username": "Lainaaa",
                        "content": "The condition says that each row and column must have a number, but in the test where all the points are, the correct answer is true."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "what should be the time complexity for this code\\n"
                    },
                    {
                        "username": "weswithley",
                        "content": "This case looks no repition exist, but why output should be false ?\\n[\\n\\t[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n\\t[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n\\t[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n]\\n\\nUPDATE : \\nAs my understanding, all the re-org groups from top left to bottom right should be :  \\n1. [\".\", \".\", \"4\", \".\", \".\", \".\", \"5\", \".\", \".\"]\\n2. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n3. [\"6\", \"3\", \".\", \".\", \".\", \".\", \".\", \"9\", \".\"]\\n4. [\".\", \".\", \".\", \"4\", \".\", \"3\", \".\", \".\", \".\"]\\n5. [\"5\", \"6\", \".\", \".\", \".\", \".\", \"7\", \".\", \".\"]\\n6. [\".\", \"9\", \".\", \".\", \".\", \".\", \".\", \".\", \"1\"]\\n7. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n8. [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n9. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n\\nlooks like no repitation in each group. \\uD83E\\uDD14"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "There\\'s a repeatition in the first column. look out for 5"
                    },
                    {
                        "username": "Coder0622",
                        "content": "There\\'s a repetition in the first row. The number 5 exists in [5][0], and [8,0]."
                    },
                    {
                        "username": "AnkitRaj06",
                        "content": "Can someone please help me understand, how can the below test case give an output \"False\"?\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The fourth column has two 5\\'s: [3][3] and [7][3]"
                    }
                ]
            },
            {
                "id": 2050119,
                "content": [
                    {
                        "username": "ankitk742",
                        "content": "As a hint , A particular element can be uniquely identified by the row , column and block. Use this unique identifier to check if soduku is valid or not "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good bro"
                    },
                    {
                        "username": "AdamGold",
                        "content": "Why is this a medium? This question is basically asking if you know how for loops work and if you know how to determine if a character has been repeated. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yes, but to put everything together is not trivial."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@be4ko](/be4ko) Yes, two nested loops are O(n^2)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "idk"
                    },
                    {
                        "username": "be4ko",
                        "content": "if you are gonna only use for loops is that gonna be a O(n^2) ?? "
                    },
                    {
                        "username": "be4ko",
                        "content": "What Data Structure should I use to Solve this Problem Set ? Map ?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I am using arrays of unordered_set. unordered_set is using hashing, set is using a tree."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good question, I used ordered set"
                    },
                    {
                        "username": "revolution14",
                        "content": "getting runtime error when checking for duplicates in box, any hints? \n        `unordered_set<char> setRow, setColumn;\n        unordered_map<int, unordered_set<char>> setBox;\n\n        for(int i=0; i<9; i++){\n            for(int j=0; j<9; j++){\n                char num = board[i][j], num2 = board[j][i];\n                 \n                // checking for row\n                if(num!='.' && setRow.find(num)!=setRow.end())\n                    return false;\n                setRow.insert(num);\n\n                // checking for column\n                if(num2!='.' && setColumn.find(num2)!=setColumn.end())\n                    return false;\n                setColumn.insert(num2);\n\n                // checking for individual box\n                auto it = setBox.find((i/3)*3+j/3);\n                if(it==setBox.end()){\n                    setBox.insert({(i/3)*3+j/3, unordered_set<char> ({num})}) ;\n                }\n                else if(num!='.' && it->second.find(num)!=it->second.end())\n                    return false;\n                it->second.insert(num);\n\n                \n            }\n\n            setRow.clear();\n            setColumn.clear();\n        }\n\n        return true;\n`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "nope"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I got confused in string and char because of example contains \"\" on elements."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "i think \"\" will return false"
                    },
                    {
                        "username": "nadabao",
                        "content": "what a boring question."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I find it interesting."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "same"
                    },
                    {
                        "username": "Lainaaa",
                        "content": "The condition says that each row and column must have a number, but in the test where all the points are, the correct answer is true."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "what should be the time complexity for this code\\n"
                    },
                    {
                        "username": "weswithley",
                        "content": "This case looks no repition exist, but why output should be false ?\\n[\\n\\t[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n\\t[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n\\t[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n]\\n\\nUPDATE : \\nAs my understanding, all the re-org groups from top left to bottom right should be :  \\n1. [\".\", \".\", \"4\", \".\", \".\", \".\", \"5\", \".\", \".\"]\\n2. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n3. [\"6\", \"3\", \".\", \".\", \".\", \".\", \".\", \"9\", \".\"]\\n4. [\".\", \".\", \".\", \"4\", \".\", \"3\", \".\", \".\", \".\"]\\n5. [\"5\", \"6\", \".\", \".\", \".\", \".\", \"7\", \".\", \".\"]\\n6. [\".\", \"9\", \".\", \".\", \".\", \".\", \".\", \".\", \"1\"]\\n7. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n8. [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n9. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n\\nlooks like no repitation in each group. \\uD83E\\uDD14"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "There\\'s a repeatition in the first column. look out for 5"
                    },
                    {
                        "username": "Coder0622",
                        "content": "There\\'s a repetition in the first row. The number 5 exists in [5][0], and [8,0]."
                    },
                    {
                        "username": "AnkitRaj06",
                        "content": "Can someone please help me understand, how can the below test case give an output \"False\"?\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The fourth column has two 5\\'s: [3][3] and [7][3]"
                    }
                ]
            },
            {
                "id": 2040084,
                "content": [
                    {
                        "username": "ankitk742",
                        "content": "As a hint , A particular element can be uniquely identified by the row , column and block. Use this unique identifier to check if soduku is valid or not "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good bro"
                    },
                    {
                        "username": "AdamGold",
                        "content": "Why is this a medium? This question is basically asking if you know how for loops work and if you know how to determine if a character has been repeated. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yes, but to put everything together is not trivial."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@be4ko](/be4ko) Yes, two nested loops are O(n^2)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "idk"
                    },
                    {
                        "username": "be4ko",
                        "content": "if you are gonna only use for loops is that gonna be a O(n^2) ?? "
                    },
                    {
                        "username": "be4ko",
                        "content": "What Data Structure should I use to Solve this Problem Set ? Map ?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I am using arrays of unordered_set. unordered_set is using hashing, set is using a tree."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good question, I used ordered set"
                    },
                    {
                        "username": "revolution14",
                        "content": "getting runtime error when checking for duplicates in box, any hints? \n        `unordered_set<char> setRow, setColumn;\n        unordered_map<int, unordered_set<char>> setBox;\n\n        for(int i=0; i<9; i++){\n            for(int j=0; j<9; j++){\n                char num = board[i][j], num2 = board[j][i];\n                 \n                // checking for row\n                if(num!='.' && setRow.find(num)!=setRow.end())\n                    return false;\n                setRow.insert(num);\n\n                // checking for column\n                if(num2!='.' && setColumn.find(num2)!=setColumn.end())\n                    return false;\n                setColumn.insert(num2);\n\n                // checking for individual box\n                auto it = setBox.find((i/3)*3+j/3);\n                if(it==setBox.end()){\n                    setBox.insert({(i/3)*3+j/3, unordered_set<char> ({num})}) ;\n                }\n                else if(num!='.' && it->second.find(num)!=it->second.end())\n                    return false;\n                it->second.insert(num);\n\n                \n            }\n\n            setRow.clear();\n            setColumn.clear();\n        }\n\n        return true;\n`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "nope"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I got confused in string and char because of example contains \"\" on elements."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "i think \"\" will return false"
                    },
                    {
                        "username": "nadabao",
                        "content": "what a boring question."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I find it interesting."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "same"
                    },
                    {
                        "username": "Lainaaa",
                        "content": "The condition says that each row and column must have a number, but in the test where all the points are, the correct answer is true."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "what should be the time complexity for this code\\n"
                    },
                    {
                        "username": "weswithley",
                        "content": "This case looks no repition exist, but why output should be false ?\\n[\\n\\t[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n\\t[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n\\t[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n]\\n\\nUPDATE : \\nAs my understanding, all the re-org groups from top left to bottom right should be :  \\n1. [\".\", \".\", \"4\", \".\", \".\", \".\", \"5\", \".\", \".\"]\\n2. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n3. [\"6\", \"3\", \".\", \".\", \".\", \".\", \".\", \"9\", \".\"]\\n4. [\".\", \".\", \".\", \"4\", \".\", \"3\", \".\", \".\", \".\"]\\n5. [\"5\", \"6\", \".\", \".\", \".\", \".\", \"7\", \".\", \".\"]\\n6. [\".\", \"9\", \".\", \".\", \".\", \".\", \".\", \".\", \"1\"]\\n7. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n8. [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n9. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n\\nlooks like no repitation in each group. \\uD83E\\uDD14"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "There\\'s a repeatition in the first column. look out for 5"
                    },
                    {
                        "username": "Coder0622",
                        "content": "There\\'s a repetition in the first row. The number 5 exists in [5][0], and [8,0]."
                    },
                    {
                        "username": "AnkitRaj06",
                        "content": "Can someone please help me understand, how can the below test case give an output \"False\"?\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The fourth column has two 5\\'s: [3][3] and [7][3]"
                    }
                ]
            },
            {
                "id": 2038730,
                "content": [
                    {
                        "username": "ankitk742",
                        "content": "As a hint , A particular element can be uniquely identified by the row , column and block. Use this unique identifier to check if soduku is valid or not "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good bro"
                    },
                    {
                        "username": "AdamGold",
                        "content": "Why is this a medium? This question is basically asking if you know how for loops work and if you know how to determine if a character has been repeated. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yes, but to put everything together is not trivial."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@be4ko](/be4ko) Yes, two nested loops are O(n^2)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "idk"
                    },
                    {
                        "username": "be4ko",
                        "content": "if you are gonna only use for loops is that gonna be a O(n^2) ?? "
                    },
                    {
                        "username": "be4ko",
                        "content": "What Data Structure should I use to Solve this Problem Set ? Map ?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I am using arrays of unordered_set. unordered_set is using hashing, set is using a tree."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good question, I used ordered set"
                    },
                    {
                        "username": "revolution14",
                        "content": "getting runtime error when checking for duplicates in box, any hints? \n        `unordered_set<char> setRow, setColumn;\n        unordered_map<int, unordered_set<char>> setBox;\n\n        for(int i=0; i<9; i++){\n            for(int j=0; j<9; j++){\n                char num = board[i][j], num2 = board[j][i];\n                 \n                // checking for row\n                if(num!='.' && setRow.find(num)!=setRow.end())\n                    return false;\n                setRow.insert(num);\n\n                // checking for column\n                if(num2!='.' && setColumn.find(num2)!=setColumn.end())\n                    return false;\n                setColumn.insert(num2);\n\n                // checking for individual box\n                auto it = setBox.find((i/3)*3+j/3);\n                if(it==setBox.end()){\n                    setBox.insert({(i/3)*3+j/3, unordered_set<char> ({num})}) ;\n                }\n                else if(num!='.' && it->second.find(num)!=it->second.end())\n                    return false;\n                it->second.insert(num);\n\n                \n            }\n\n            setRow.clear();\n            setColumn.clear();\n        }\n\n        return true;\n`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "nope"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I got confused in string and char because of example contains \"\" on elements."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "i think \"\" will return false"
                    },
                    {
                        "username": "nadabao",
                        "content": "what a boring question."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I find it interesting."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "same"
                    },
                    {
                        "username": "Lainaaa",
                        "content": "The condition says that each row and column must have a number, but in the test where all the points are, the correct answer is true."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "what should be the time complexity for this code\\n"
                    },
                    {
                        "username": "weswithley",
                        "content": "This case looks no repition exist, but why output should be false ?\\n[\\n\\t[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n\\t[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n\\t[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n]\\n\\nUPDATE : \\nAs my understanding, all the re-org groups from top left to bottom right should be :  \\n1. [\".\", \".\", \"4\", \".\", \".\", \".\", \"5\", \".\", \".\"]\\n2. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n3. [\"6\", \"3\", \".\", \".\", \".\", \".\", \".\", \"9\", \".\"]\\n4. [\".\", \".\", \".\", \"4\", \".\", \"3\", \".\", \".\", \".\"]\\n5. [\"5\", \"6\", \".\", \".\", \".\", \".\", \"7\", \".\", \".\"]\\n6. [\".\", \"9\", \".\", \".\", \".\", \".\", \".\", \".\", \"1\"]\\n7. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n8. [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n9. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n\\nlooks like no repitation in each group. \\uD83E\\uDD14"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "There\\'s a repeatition in the first column. look out for 5"
                    },
                    {
                        "username": "Coder0622",
                        "content": "There\\'s a repetition in the first row. The number 5 exists in [5][0], and [8,0]."
                    },
                    {
                        "username": "AnkitRaj06",
                        "content": "Can someone please help me understand, how can the below test case give an output \"False\"?\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The fourth column has two 5\\'s: [3][3] and [7][3]"
                    }
                ]
            },
            {
                "id": 1879995,
                "content": [
                    {
                        "username": "ankitk742",
                        "content": "As a hint , A particular element can be uniquely identified by the row , column and block. Use this unique identifier to check if soduku is valid or not "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good bro"
                    },
                    {
                        "username": "AdamGold",
                        "content": "Why is this a medium? This question is basically asking if you know how for loops work and if you know how to determine if a character has been repeated. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yes, but to put everything together is not trivial."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@be4ko](/be4ko) Yes, two nested loops are O(n^2)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "idk"
                    },
                    {
                        "username": "be4ko",
                        "content": "if you are gonna only use for loops is that gonna be a O(n^2) ?? "
                    },
                    {
                        "username": "be4ko",
                        "content": "What Data Structure should I use to Solve this Problem Set ? Map ?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I am using arrays of unordered_set. unordered_set is using hashing, set is using a tree."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good question, I used ordered set"
                    },
                    {
                        "username": "revolution14",
                        "content": "getting runtime error when checking for duplicates in box, any hints? \n        `unordered_set<char> setRow, setColumn;\n        unordered_map<int, unordered_set<char>> setBox;\n\n        for(int i=0; i<9; i++){\n            for(int j=0; j<9; j++){\n                char num = board[i][j], num2 = board[j][i];\n                 \n                // checking for row\n                if(num!='.' && setRow.find(num)!=setRow.end())\n                    return false;\n                setRow.insert(num);\n\n                // checking for column\n                if(num2!='.' && setColumn.find(num2)!=setColumn.end())\n                    return false;\n                setColumn.insert(num2);\n\n                // checking for individual box\n                auto it = setBox.find((i/3)*3+j/3);\n                if(it==setBox.end()){\n                    setBox.insert({(i/3)*3+j/3, unordered_set<char> ({num})}) ;\n                }\n                else if(num!='.' && it->second.find(num)!=it->second.end())\n                    return false;\n                it->second.insert(num);\n\n                \n            }\n\n            setRow.clear();\n            setColumn.clear();\n        }\n\n        return true;\n`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "nope"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I got confused in string and char because of example contains \"\" on elements."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "i think \"\" will return false"
                    },
                    {
                        "username": "nadabao",
                        "content": "what a boring question."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I find it interesting."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "same"
                    },
                    {
                        "username": "Lainaaa",
                        "content": "The condition says that each row and column must have a number, but in the test where all the points are, the correct answer is true."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "what should be the time complexity for this code\\n"
                    },
                    {
                        "username": "weswithley",
                        "content": "This case looks no repition exist, but why output should be false ?\\n[\\n\\t[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n\\t[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n\\t[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n]\\n\\nUPDATE : \\nAs my understanding, all the re-org groups from top left to bottom right should be :  \\n1. [\".\", \".\", \"4\", \".\", \".\", \".\", \"5\", \".\", \".\"]\\n2. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n3. [\"6\", \"3\", \".\", \".\", \".\", \".\", \".\", \"9\", \".\"]\\n4. [\".\", \".\", \".\", \"4\", \".\", \"3\", \".\", \".\", \".\"]\\n5. [\"5\", \"6\", \".\", \".\", \".\", \".\", \"7\", \".\", \".\"]\\n6. [\".\", \"9\", \".\", \".\", \".\", \".\", \".\", \".\", \"1\"]\\n7. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n8. [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n9. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n\\nlooks like no repitation in each group. \\uD83E\\uDD14"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "There\\'s a repeatition in the first column. look out for 5"
                    },
                    {
                        "username": "Coder0622",
                        "content": "There\\'s a repetition in the first row. The number 5 exists in [5][0], and [8,0]."
                    },
                    {
                        "username": "AnkitRaj06",
                        "content": "Can someone please help me understand, how can the below test case give an output \"False\"?\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The fourth column has two 5\\'s: [3][3] and [7][3]"
                    }
                ]
            },
            {
                "id": 1806063,
                "content": [
                    {
                        "username": "ankitk742",
                        "content": "As a hint , A particular element can be uniquely identified by the row , column and block. Use this unique identifier to check if soduku is valid or not "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good bro"
                    },
                    {
                        "username": "AdamGold",
                        "content": "Why is this a medium? This question is basically asking if you know how for loops work and if you know how to determine if a character has been repeated. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yes, but to put everything together is not trivial."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@be4ko](/be4ko) Yes, two nested loops are O(n^2)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "idk"
                    },
                    {
                        "username": "be4ko",
                        "content": "if you are gonna only use for loops is that gonna be a O(n^2) ?? "
                    },
                    {
                        "username": "be4ko",
                        "content": "What Data Structure should I use to Solve this Problem Set ? Map ?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I am using arrays of unordered_set. unordered_set is using hashing, set is using a tree."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good question, I used ordered set"
                    },
                    {
                        "username": "revolution14",
                        "content": "getting runtime error when checking for duplicates in box, any hints? \n        `unordered_set<char> setRow, setColumn;\n        unordered_map<int, unordered_set<char>> setBox;\n\n        for(int i=0; i<9; i++){\n            for(int j=0; j<9; j++){\n                char num = board[i][j], num2 = board[j][i];\n                 \n                // checking for row\n                if(num!='.' && setRow.find(num)!=setRow.end())\n                    return false;\n                setRow.insert(num);\n\n                // checking for column\n                if(num2!='.' && setColumn.find(num2)!=setColumn.end())\n                    return false;\n                setColumn.insert(num2);\n\n                // checking for individual box\n                auto it = setBox.find((i/3)*3+j/3);\n                if(it==setBox.end()){\n                    setBox.insert({(i/3)*3+j/3, unordered_set<char> ({num})}) ;\n                }\n                else if(num!='.' && it->second.find(num)!=it->second.end())\n                    return false;\n                it->second.insert(num);\n\n                \n            }\n\n            setRow.clear();\n            setColumn.clear();\n        }\n\n        return true;\n`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "nope"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I got confused in string and char because of example contains \"\" on elements."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "i think \"\" will return false"
                    },
                    {
                        "username": "nadabao",
                        "content": "what a boring question."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I find it interesting."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "same"
                    },
                    {
                        "username": "Lainaaa",
                        "content": "The condition says that each row and column must have a number, but in the test where all the points are, the correct answer is true."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "what should be the time complexity for this code\\n"
                    },
                    {
                        "username": "weswithley",
                        "content": "This case looks no repition exist, but why output should be false ?\\n[\\n\\t[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n\\t[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n\\t[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n]\\n\\nUPDATE : \\nAs my understanding, all the re-org groups from top left to bottom right should be :  \\n1. [\".\", \".\", \"4\", \".\", \".\", \".\", \"5\", \".\", \".\"]\\n2. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n3. [\"6\", \"3\", \".\", \".\", \".\", \".\", \".\", \"9\", \".\"]\\n4. [\".\", \".\", \".\", \"4\", \".\", \"3\", \".\", \".\", \".\"]\\n5. [\"5\", \"6\", \".\", \".\", \".\", \".\", \"7\", \".\", \".\"]\\n6. [\".\", \"9\", \".\", \".\", \".\", \".\", \".\", \".\", \"1\"]\\n7. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n8. [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n9. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n\\nlooks like no repitation in each group. \\uD83E\\uDD14"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "There\\'s a repeatition in the first column. look out for 5"
                    },
                    {
                        "username": "Coder0622",
                        "content": "There\\'s a repetition in the first row. The number 5 exists in [5][0], and [8,0]."
                    },
                    {
                        "username": "AnkitRaj06",
                        "content": "Can someone please help me understand, how can the below test case give an output \"False\"?\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The fourth column has two 5\\'s: [3][3] and [7][3]"
                    }
                ]
            },
            {
                "id": 1575839,
                "content": [
                    {
                        "username": "ankitk742",
                        "content": "As a hint , A particular element can be uniquely identified by the row , column and block. Use this unique identifier to check if soduku is valid or not "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good bro"
                    },
                    {
                        "username": "AdamGold",
                        "content": "Why is this a medium? This question is basically asking if you know how for loops work and if you know how to determine if a character has been repeated. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yes, but to put everything together is not trivial."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@be4ko](/be4ko) Yes, two nested loops are O(n^2)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "idk"
                    },
                    {
                        "username": "be4ko",
                        "content": "if you are gonna only use for loops is that gonna be a O(n^2) ?? "
                    },
                    {
                        "username": "be4ko",
                        "content": "What Data Structure should I use to Solve this Problem Set ? Map ?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I am using arrays of unordered_set. unordered_set is using hashing, set is using a tree."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good question, I used ordered set"
                    },
                    {
                        "username": "revolution14",
                        "content": "getting runtime error when checking for duplicates in box, any hints? \n        `unordered_set<char> setRow, setColumn;\n        unordered_map<int, unordered_set<char>> setBox;\n\n        for(int i=0; i<9; i++){\n            for(int j=0; j<9; j++){\n                char num = board[i][j], num2 = board[j][i];\n                 \n                // checking for row\n                if(num!='.' && setRow.find(num)!=setRow.end())\n                    return false;\n                setRow.insert(num);\n\n                // checking for column\n                if(num2!='.' && setColumn.find(num2)!=setColumn.end())\n                    return false;\n                setColumn.insert(num2);\n\n                // checking for individual box\n                auto it = setBox.find((i/3)*3+j/3);\n                if(it==setBox.end()){\n                    setBox.insert({(i/3)*3+j/3, unordered_set<char> ({num})}) ;\n                }\n                else if(num!='.' && it->second.find(num)!=it->second.end())\n                    return false;\n                it->second.insert(num);\n\n                \n            }\n\n            setRow.clear();\n            setColumn.clear();\n        }\n\n        return true;\n`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "nope"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I got confused in string and char because of example contains \"\" on elements."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "i think \"\" will return false"
                    },
                    {
                        "username": "nadabao",
                        "content": "what a boring question."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I find it interesting."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "same"
                    },
                    {
                        "username": "Lainaaa",
                        "content": "The condition says that each row and column must have a number, but in the test where all the points are, the correct answer is true."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "what should be the time complexity for this code\\n"
                    },
                    {
                        "username": "weswithley",
                        "content": "This case looks no repition exist, but why output should be false ?\\n[\\n\\t[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n\\t[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n\\t[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n]\\n\\nUPDATE : \\nAs my understanding, all the re-org groups from top left to bottom right should be :  \\n1. [\".\", \".\", \"4\", \".\", \".\", \".\", \"5\", \".\", \".\"]\\n2. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n3. [\"6\", \"3\", \".\", \".\", \".\", \".\", \".\", \"9\", \".\"]\\n4. [\".\", \".\", \".\", \"4\", \".\", \"3\", \".\", \".\", \".\"]\\n5. [\"5\", \"6\", \".\", \".\", \".\", \".\", \"7\", \".\", \".\"]\\n6. [\".\", \"9\", \".\", \".\", \".\", \".\", \".\", \".\", \"1\"]\\n7. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n8. [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n9. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n\\nlooks like no repitation in each group. \\uD83E\\uDD14"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "There\\'s a repeatition in the first column. look out for 5"
                    },
                    {
                        "username": "Coder0622",
                        "content": "There\\'s a repetition in the first row. The number 5 exists in [5][0], and [8,0]."
                    },
                    {
                        "username": "AnkitRaj06",
                        "content": "Can someone please help me understand, how can the below test case give an output \"False\"?\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The fourth column has two 5\\'s: [3][3] and [7][3]"
                    }
                ]
            },
            {
                "id": 1574493,
                "content": [
                    {
                        "username": "ankitk742",
                        "content": "As a hint , A particular element can be uniquely identified by the row , column and block. Use this unique identifier to check if soduku is valid or not "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good bro"
                    },
                    {
                        "username": "AdamGold",
                        "content": "Why is this a medium? This question is basically asking if you know how for loops work and if you know how to determine if a character has been repeated. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yes, but to put everything together is not trivial."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@be4ko](/be4ko) Yes, two nested loops are O(n^2)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "idk"
                    },
                    {
                        "username": "be4ko",
                        "content": "if you are gonna only use for loops is that gonna be a O(n^2) ?? "
                    },
                    {
                        "username": "be4ko",
                        "content": "What Data Structure should I use to Solve this Problem Set ? Map ?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I am using arrays of unordered_set. unordered_set is using hashing, set is using a tree."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good question, I used ordered set"
                    },
                    {
                        "username": "revolution14",
                        "content": "getting runtime error when checking for duplicates in box, any hints? \n        `unordered_set<char> setRow, setColumn;\n        unordered_map<int, unordered_set<char>> setBox;\n\n        for(int i=0; i<9; i++){\n            for(int j=0; j<9; j++){\n                char num = board[i][j], num2 = board[j][i];\n                 \n                // checking for row\n                if(num!='.' && setRow.find(num)!=setRow.end())\n                    return false;\n                setRow.insert(num);\n\n                // checking for column\n                if(num2!='.' && setColumn.find(num2)!=setColumn.end())\n                    return false;\n                setColumn.insert(num2);\n\n                // checking for individual box\n                auto it = setBox.find((i/3)*3+j/3);\n                if(it==setBox.end()){\n                    setBox.insert({(i/3)*3+j/3, unordered_set<char> ({num})}) ;\n                }\n                else if(num!='.' && it->second.find(num)!=it->second.end())\n                    return false;\n                it->second.insert(num);\n\n                \n            }\n\n            setRow.clear();\n            setColumn.clear();\n        }\n\n        return true;\n`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "nope"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I got confused in string and char because of example contains \"\" on elements."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "i think \"\" will return false"
                    },
                    {
                        "username": "nadabao",
                        "content": "what a boring question."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I find it interesting."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "same"
                    },
                    {
                        "username": "Lainaaa",
                        "content": "The condition says that each row and column must have a number, but in the test where all the points are, the correct answer is true."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "what should be the time complexity for this code\\n"
                    },
                    {
                        "username": "weswithley",
                        "content": "This case looks no repition exist, but why output should be false ?\\n[\\n\\t[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n\\t[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n\\t[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n]\\n\\nUPDATE : \\nAs my understanding, all the re-org groups from top left to bottom right should be :  \\n1. [\".\", \".\", \"4\", \".\", \".\", \".\", \"5\", \".\", \".\"]\\n2. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n3. [\"6\", \"3\", \".\", \".\", \".\", \".\", \".\", \"9\", \".\"]\\n4. [\".\", \".\", \".\", \"4\", \".\", \"3\", \".\", \".\", \".\"]\\n5. [\"5\", \"6\", \".\", \".\", \".\", \".\", \"7\", \".\", \".\"]\\n6. [\".\", \"9\", \".\", \".\", \".\", \".\", \".\", \".\", \"1\"]\\n7. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n8. [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n9. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n\\nlooks like no repitation in each group. \\uD83E\\uDD14"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "There\\'s a repeatition in the first column. look out for 5"
                    },
                    {
                        "username": "Coder0622",
                        "content": "There\\'s a repetition in the first row. The number 5 exists in [5][0], and [8,0]."
                    },
                    {
                        "username": "AnkitRaj06",
                        "content": "Can someone please help me understand, how can the below test case give an output \"False\"?\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The fourth column has two 5\\'s: [3][3] and [7][3]"
                    }
                ]
            },
            {
                "id": 1574352,
                "content": [
                    {
                        "username": "YogeshK",
                        "content": "not sure its not going through in my head and dont wanna memorize it...\\nEnded up comparing x and y and calculating each box index."
                    },
                    {
                        "username": "lgdelacruz",
                        "content": "I spent a long time on this thinking it has to be solvable to be valid. No, you just need to check if it is valid."
                    },
                    {
                        "username": "ronghuali980303",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nMy submission fails at this one. It\\'s appearently only 9 can be in the first element according to the row.However 9 also exists in the first column. Therefore my answer to this is false. But the expected output is true. Anyone can tell me why?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "ksuzuki",
                        "content": "There is a test case:\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nwhich should return False because the top left corner can\\'t populate any values without breaking the constraints. Column is looking for a 1, but Row is looking for a 9. But leetcode is expecting the output to be True.\\n\\nany thoughts?\\n"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "divi13",
                        "content": "Hi,\\n\\nFor the second input (with 8 instead of 5), the grader says that my code produces the result \\'true\\' but when I run it myself, I am getting the expected false. This happened a few days ago too with another question. Is it possible that the grader is somehow storing the previous result and incorrectly outputting that as the current result too? Could you please fix the grader?"
                    },
                    {
                        "username": "JingxuOuyang",
                        "content": "{{\\'.\\',\\'8\\',\\'7\\',\\'6\\',\\'5\\',\\'4\\',\\'3\\',\\'2\\',\\'1\\'},\\n{\\'2\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'3\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'4\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'5\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'6\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'7\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'8\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'9\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'}}\\nexcept true?"
                    },
                    {
                        "username": "otherside2",
                        "content": "How is this a valid Sudoku?\\n\\nWrong Answer\\nInput: \\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\nOutput: false\\nExpected: true"
                    },
                    {
                        "username": "kaihua",
                        "content": "the last input is \\n[\"..5.....6\",\"....14...\",\".........\",\".....92..\",\"5....2...\",\".......3.\",\"...54....\",\"3.....42.\",\"...27.6..\"]\\n\\n\".....92..\",\"5....2...\" will be wrong."
                    },
                    {
                        "username": "42nl",
                        "content": "below is the outcome from my judge:\\n\\nInput:\\t[\"..4...63.\",\".........\",\"5......9.\",\"...56....\",\"4.3.....1\",\"...7.....\",\"...5.....\",\".........\",\".........\"]\\nOutput:\\ttrue\\nExpected:\\tfalse\\n\\nDoes anybody know why this input should be false? Could you tell me?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "4th row has the number 5 two times in it"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "I tried this for 2 hours and after checking out the discussions, i found out that we don\\'t have to solve it, but have to check than whether it is a valid sudoku or not.\\nMoral of the story: Read the question very carefully."
                    }
                ]
            },
            {
                "id": 1574267,
                "content": [
                    {
                        "username": "YogeshK",
                        "content": "not sure its not going through in my head and dont wanna memorize it...\\nEnded up comparing x and y and calculating each box index."
                    },
                    {
                        "username": "lgdelacruz",
                        "content": "I spent a long time on this thinking it has to be solvable to be valid. No, you just need to check if it is valid."
                    },
                    {
                        "username": "ronghuali980303",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nMy submission fails at this one. It\\'s appearently only 9 can be in the first element according to the row.However 9 also exists in the first column. Therefore my answer to this is false. But the expected output is true. Anyone can tell me why?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "ksuzuki",
                        "content": "There is a test case:\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nwhich should return False because the top left corner can\\'t populate any values without breaking the constraints. Column is looking for a 1, but Row is looking for a 9. But leetcode is expecting the output to be True.\\n\\nany thoughts?\\n"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "divi13",
                        "content": "Hi,\\n\\nFor the second input (with 8 instead of 5), the grader says that my code produces the result \\'true\\' but when I run it myself, I am getting the expected false. This happened a few days ago too with another question. Is it possible that the grader is somehow storing the previous result and incorrectly outputting that as the current result too? Could you please fix the grader?"
                    },
                    {
                        "username": "JingxuOuyang",
                        "content": "{{\\'.\\',\\'8\\',\\'7\\',\\'6\\',\\'5\\',\\'4\\',\\'3\\',\\'2\\',\\'1\\'},\\n{\\'2\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'3\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'4\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'5\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'6\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'7\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'8\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'9\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'}}\\nexcept true?"
                    },
                    {
                        "username": "otherside2",
                        "content": "How is this a valid Sudoku?\\n\\nWrong Answer\\nInput: \\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\nOutput: false\\nExpected: true"
                    },
                    {
                        "username": "kaihua",
                        "content": "the last input is \\n[\"..5.....6\",\"....14...\",\".........\",\".....92..\",\"5....2...\",\".......3.\",\"...54....\",\"3.....42.\",\"...27.6..\"]\\n\\n\".....92..\",\"5....2...\" will be wrong."
                    },
                    {
                        "username": "42nl",
                        "content": "below is the outcome from my judge:\\n\\nInput:\\t[\"..4...63.\",\".........\",\"5......9.\",\"...56....\",\"4.3.....1\",\"...7.....\",\"...5.....\",\".........\",\".........\"]\\nOutput:\\ttrue\\nExpected:\\tfalse\\n\\nDoes anybody know why this input should be false? Could you tell me?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "4th row has the number 5 two times in it"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "I tried this for 2 hours and after checking out the discussions, i found out that we don\\'t have to solve it, but have to check than whether it is a valid sudoku or not.\\nMoral of the story: Read the question very carefully."
                    }
                ]
            },
            {
                "id": 1573556,
                "content": [
                    {
                        "username": "YogeshK",
                        "content": "not sure its not going through in my head and dont wanna memorize it...\\nEnded up comparing x and y and calculating each box index."
                    },
                    {
                        "username": "lgdelacruz",
                        "content": "I spent a long time on this thinking it has to be solvable to be valid. No, you just need to check if it is valid."
                    },
                    {
                        "username": "ronghuali980303",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nMy submission fails at this one. It\\'s appearently only 9 can be in the first element according to the row.However 9 also exists in the first column. Therefore my answer to this is false. But the expected output is true. Anyone can tell me why?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "ksuzuki",
                        "content": "There is a test case:\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nwhich should return False because the top left corner can\\'t populate any values without breaking the constraints. Column is looking for a 1, but Row is looking for a 9. But leetcode is expecting the output to be True.\\n\\nany thoughts?\\n"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "divi13",
                        "content": "Hi,\\n\\nFor the second input (with 8 instead of 5), the grader says that my code produces the result \\'true\\' but when I run it myself, I am getting the expected false. This happened a few days ago too with another question. Is it possible that the grader is somehow storing the previous result and incorrectly outputting that as the current result too? Could you please fix the grader?"
                    },
                    {
                        "username": "JingxuOuyang",
                        "content": "{{\\'.\\',\\'8\\',\\'7\\',\\'6\\',\\'5\\',\\'4\\',\\'3\\',\\'2\\',\\'1\\'},\\n{\\'2\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'3\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'4\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'5\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'6\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'7\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'8\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'9\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'}}\\nexcept true?"
                    },
                    {
                        "username": "otherside2",
                        "content": "How is this a valid Sudoku?\\n\\nWrong Answer\\nInput: \\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\nOutput: false\\nExpected: true"
                    },
                    {
                        "username": "kaihua",
                        "content": "the last input is \\n[\"..5.....6\",\"....14...\",\".........\",\".....92..\",\"5....2...\",\".......3.\",\"...54....\",\"3.....42.\",\"...27.6..\"]\\n\\n\".....92..\",\"5....2...\" will be wrong."
                    },
                    {
                        "username": "42nl",
                        "content": "below is the outcome from my judge:\\n\\nInput:\\t[\"..4...63.\",\".........\",\"5......9.\",\"...56....\",\"4.3.....1\",\"...7.....\",\"...5.....\",\".........\",\".........\"]\\nOutput:\\ttrue\\nExpected:\\tfalse\\n\\nDoes anybody know why this input should be false? Could you tell me?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "4th row has the number 5 two times in it"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "I tried this for 2 hours and after checking out the discussions, i found out that we don\\'t have to solve it, but have to check than whether it is a valid sudoku or not.\\nMoral of the story: Read the question very carefully."
                    }
                ]
            },
            {
                "id": 1573156,
                "content": [
                    {
                        "username": "YogeshK",
                        "content": "not sure its not going through in my head and dont wanna memorize it...\\nEnded up comparing x and y and calculating each box index."
                    },
                    {
                        "username": "lgdelacruz",
                        "content": "I spent a long time on this thinking it has to be solvable to be valid. No, you just need to check if it is valid."
                    },
                    {
                        "username": "ronghuali980303",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nMy submission fails at this one. It\\'s appearently only 9 can be in the first element according to the row.However 9 also exists in the first column. Therefore my answer to this is false. But the expected output is true. Anyone can tell me why?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "ksuzuki",
                        "content": "There is a test case:\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nwhich should return False because the top left corner can\\'t populate any values without breaking the constraints. Column is looking for a 1, but Row is looking for a 9. But leetcode is expecting the output to be True.\\n\\nany thoughts?\\n"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "divi13",
                        "content": "Hi,\\n\\nFor the second input (with 8 instead of 5), the grader says that my code produces the result \\'true\\' but when I run it myself, I am getting the expected false. This happened a few days ago too with another question. Is it possible that the grader is somehow storing the previous result and incorrectly outputting that as the current result too? Could you please fix the grader?"
                    },
                    {
                        "username": "JingxuOuyang",
                        "content": "{{\\'.\\',\\'8\\',\\'7\\',\\'6\\',\\'5\\',\\'4\\',\\'3\\',\\'2\\',\\'1\\'},\\n{\\'2\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'3\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'4\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'5\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'6\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'7\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'8\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'9\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'}}\\nexcept true?"
                    },
                    {
                        "username": "otherside2",
                        "content": "How is this a valid Sudoku?\\n\\nWrong Answer\\nInput: \\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\nOutput: false\\nExpected: true"
                    },
                    {
                        "username": "kaihua",
                        "content": "the last input is \\n[\"..5.....6\",\"....14...\",\".........\",\".....92..\",\"5....2...\",\".......3.\",\"...54....\",\"3.....42.\",\"...27.6..\"]\\n\\n\".....92..\",\"5....2...\" will be wrong."
                    },
                    {
                        "username": "42nl",
                        "content": "below is the outcome from my judge:\\n\\nInput:\\t[\"..4...63.\",\".........\",\"5......9.\",\"...56....\",\"4.3.....1\",\"...7.....\",\"...5.....\",\".........\",\".........\"]\\nOutput:\\ttrue\\nExpected:\\tfalse\\n\\nDoes anybody know why this input should be false? Could you tell me?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "4th row has the number 5 two times in it"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "I tried this for 2 hours and after checking out the discussions, i found out that we don\\'t have to solve it, but have to check than whether it is a valid sudoku or not.\\nMoral of the story: Read the question very carefully."
                    }
                ]
            },
            {
                "id": 1573029,
                "content": [
                    {
                        "username": "YogeshK",
                        "content": "not sure its not going through in my head and dont wanna memorize it...\\nEnded up comparing x and y and calculating each box index."
                    },
                    {
                        "username": "lgdelacruz",
                        "content": "I spent a long time on this thinking it has to be solvable to be valid. No, you just need to check if it is valid."
                    },
                    {
                        "username": "ronghuali980303",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nMy submission fails at this one. It\\'s appearently only 9 can be in the first element according to the row.However 9 also exists in the first column. Therefore my answer to this is false. But the expected output is true. Anyone can tell me why?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "ksuzuki",
                        "content": "There is a test case:\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nwhich should return False because the top left corner can\\'t populate any values without breaking the constraints. Column is looking for a 1, but Row is looking for a 9. But leetcode is expecting the output to be True.\\n\\nany thoughts?\\n"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "divi13",
                        "content": "Hi,\\n\\nFor the second input (with 8 instead of 5), the grader says that my code produces the result \\'true\\' but when I run it myself, I am getting the expected false. This happened a few days ago too with another question. Is it possible that the grader is somehow storing the previous result and incorrectly outputting that as the current result too? Could you please fix the grader?"
                    },
                    {
                        "username": "JingxuOuyang",
                        "content": "{{\\'.\\',\\'8\\',\\'7\\',\\'6\\',\\'5\\',\\'4\\',\\'3\\',\\'2\\',\\'1\\'},\\n{\\'2\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'3\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'4\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'5\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'6\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'7\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'8\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'9\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'}}\\nexcept true?"
                    },
                    {
                        "username": "otherside2",
                        "content": "How is this a valid Sudoku?\\n\\nWrong Answer\\nInput: \\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\nOutput: false\\nExpected: true"
                    },
                    {
                        "username": "kaihua",
                        "content": "the last input is \\n[\"..5.....6\",\"....14...\",\".........\",\".....92..\",\"5....2...\",\".......3.\",\"...54....\",\"3.....42.\",\"...27.6..\"]\\n\\n\".....92..\",\"5....2...\" will be wrong."
                    },
                    {
                        "username": "42nl",
                        "content": "below is the outcome from my judge:\\n\\nInput:\\t[\"..4...63.\",\".........\",\"5......9.\",\"...56....\",\"4.3.....1\",\"...7.....\",\"...5.....\",\".........\",\".........\"]\\nOutput:\\ttrue\\nExpected:\\tfalse\\n\\nDoes anybody know why this input should be false? Could you tell me?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "4th row has the number 5 two times in it"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "I tried this for 2 hours and after checking out the discussions, i found out that we don\\'t have to solve it, but have to check than whether it is a valid sudoku or not.\\nMoral of the story: Read the question very carefully."
                    }
                ]
            },
            {
                "id": 1572416,
                "content": [
                    {
                        "username": "YogeshK",
                        "content": "not sure its not going through in my head and dont wanna memorize it...\\nEnded up comparing x and y and calculating each box index."
                    },
                    {
                        "username": "lgdelacruz",
                        "content": "I spent a long time on this thinking it has to be solvable to be valid. No, you just need to check if it is valid."
                    },
                    {
                        "username": "ronghuali980303",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nMy submission fails at this one. It\\'s appearently only 9 can be in the first element according to the row.However 9 also exists in the first column. Therefore my answer to this is false. But the expected output is true. Anyone can tell me why?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "ksuzuki",
                        "content": "There is a test case:\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nwhich should return False because the top left corner can\\'t populate any values without breaking the constraints. Column is looking for a 1, but Row is looking for a 9. But leetcode is expecting the output to be True.\\n\\nany thoughts?\\n"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "divi13",
                        "content": "Hi,\\n\\nFor the second input (with 8 instead of 5), the grader says that my code produces the result \\'true\\' but when I run it myself, I am getting the expected false. This happened a few days ago too with another question. Is it possible that the grader is somehow storing the previous result and incorrectly outputting that as the current result too? Could you please fix the grader?"
                    },
                    {
                        "username": "JingxuOuyang",
                        "content": "{{\\'.\\',\\'8\\',\\'7\\',\\'6\\',\\'5\\',\\'4\\',\\'3\\',\\'2\\',\\'1\\'},\\n{\\'2\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'3\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'4\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'5\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'6\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'7\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'8\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'9\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'}}\\nexcept true?"
                    },
                    {
                        "username": "otherside2",
                        "content": "How is this a valid Sudoku?\\n\\nWrong Answer\\nInput: \\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\nOutput: false\\nExpected: true"
                    },
                    {
                        "username": "kaihua",
                        "content": "the last input is \\n[\"..5.....6\",\"....14...\",\".........\",\".....92..\",\"5....2...\",\".......3.\",\"...54....\",\"3.....42.\",\"...27.6..\"]\\n\\n\".....92..\",\"5....2...\" will be wrong."
                    },
                    {
                        "username": "42nl",
                        "content": "below is the outcome from my judge:\\n\\nInput:\\t[\"..4...63.\",\".........\",\"5......9.\",\"...56....\",\"4.3.....1\",\"...7.....\",\"...5.....\",\".........\",\".........\"]\\nOutput:\\ttrue\\nExpected:\\tfalse\\n\\nDoes anybody know why this input should be false? Could you tell me?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "4th row has the number 5 two times in it"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "I tried this for 2 hours and after checking out the discussions, i found out that we don\\'t have to solve it, but have to check than whether it is a valid sudoku or not.\\nMoral of the story: Read the question very carefully."
                    }
                ]
            },
            {
                "id": 1572116,
                "content": [
                    {
                        "username": "YogeshK",
                        "content": "not sure its not going through in my head and dont wanna memorize it...\\nEnded up comparing x and y and calculating each box index."
                    },
                    {
                        "username": "lgdelacruz",
                        "content": "I spent a long time on this thinking it has to be solvable to be valid. No, you just need to check if it is valid."
                    },
                    {
                        "username": "ronghuali980303",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nMy submission fails at this one. It\\'s appearently only 9 can be in the first element according to the row.However 9 also exists in the first column. Therefore my answer to this is false. But the expected output is true. Anyone can tell me why?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "ksuzuki",
                        "content": "There is a test case:\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nwhich should return False because the top left corner can\\'t populate any values without breaking the constraints. Column is looking for a 1, but Row is looking for a 9. But leetcode is expecting the output to be True.\\n\\nany thoughts?\\n"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "divi13",
                        "content": "Hi,\\n\\nFor the second input (with 8 instead of 5), the grader says that my code produces the result \\'true\\' but when I run it myself, I am getting the expected false. This happened a few days ago too with another question. Is it possible that the grader is somehow storing the previous result and incorrectly outputting that as the current result too? Could you please fix the grader?"
                    },
                    {
                        "username": "JingxuOuyang",
                        "content": "{{\\'.\\',\\'8\\',\\'7\\',\\'6\\',\\'5\\',\\'4\\',\\'3\\',\\'2\\',\\'1\\'},\\n{\\'2\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'3\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'4\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'5\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'6\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'7\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'8\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'9\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'}}\\nexcept true?"
                    },
                    {
                        "username": "otherside2",
                        "content": "How is this a valid Sudoku?\\n\\nWrong Answer\\nInput: \\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\nOutput: false\\nExpected: true"
                    },
                    {
                        "username": "kaihua",
                        "content": "the last input is \\n[\"..5.....6\",\"....14...\",\".........\",\".....92..\",\"5....2...\",\".......3.\",\"...54....\",\"3.....42.\",\"...27.6..\"]\\n\\n\".....92..\",\"5....2...\" will be wrong."
                    },
                    {
                        "username": "42nl",
                        "content": "below is the outcome from my judge:\\n\\nInput:\\t[\"..4...63.\",\".........\",\"5......9.\",\"...56....\",\"4.3.....1\",\"...7.....\",\"...5.....\",\".........\",\".........\"]\\nOutput:\\ttrue\\nExpected:\\tfalse\\n\\nDoes anybody know why this input should be false? Could you tell me?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "4th row has the number 5 two times in it"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "I tried this for 2 hours and after checking out the discussions, i found out that we don\\'t have to solve it, but have to check than whether it is a valid sudoku or not.\\nMoral of the story: Read the question very carefully."
                    }
                ]
            },
            {
                "id": 1571089,
                "content": [
                    {
                        "username": "YogeshK",
                        "content": "not sure its not going through in my head and dont wanna memorize it...\\nEnded up comparing x and y and calculating each box index."
                    },
                    {
                        "username": "lgdelacruz",
                        "content": "I spent a long time on this thinking it has to be solvable to be valid. No, you just need to check if it is valid."
                    },
                    {
                        "username": "ronghuali980303",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nMy submission fails at this one. It\\'s appearently only 9 can be in the first element according to the row.However 9 also exists in the first column. Therefore my answer to this is false. But the expected output is true. Anyone can tell me why?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "ksuzuki",
                        "content": "There is a test case:\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nwhich should return False because the top left corner can\\'t populate any values without breaking the constraints. Column is looking for a 1, but Row is looking for a 9. But leetcode is expecting the output to be True.\\n\\nany thoughts?\\n"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "divi13",
                        "content": "Hi,\\n\\nFor the second input (with 8 instead of 5), the grader says that my code produces the result \\'true\\' but when I run it myself, I am getting the expected false. This happened a few days ago too with another question. Is it possible that the grader is somehow storing the previous result and incorrectly outputting that as the current result too? Could you please fix the grader?"
                    },
                    {
                        "username": "JingxuOuyang",
                        "content": "{{\\'.\\',\\'8\\',\\'7\\',\\'6\\',\\'5\\',\\'4\\',\\'3\\',\\'2\\',\\'1\\'},\\n{\\'2\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'3\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'4\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'5\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'6\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'7\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'8\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'9\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'}}\\nexcept true?"
                    },
                    {
                        "username": "otherside2",
                        "content": "How is this a valid Sudoku?\\n\\nWrong Answer\\nInput: \\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\nOutput: false\\nExpected: true"
                    },
                    {
                        "username": "kaihua",
                        "content": "the last input is \\n[\"..5.....6\",\"....14...\",\".........\",\".....92..\",\"5....2...\",\".......3.\",\"...54....\",\"3.....42.\",\"...27.6..\"]\\n\\n\".....92..\",\"5....2...\" will be wrong."
                    },
                    {
                        "username": "42nl",
                        "content": "below is the outcome from my judge:\\n\\nInput:\\t[\"..4...63.\",\".........\",\"5......9.\",\"...56....\",\"4.3.....1\",\"...7.....\",\"...5.....\",\".........\",\".........\"]\\nOutput:\\ttrue\\nExpected:\\tfalse\\n\\nDoes anybody know why this input should be false? Could you tell me?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "4th row has the number 5 two times in it"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "I tried this for 2 hours and after checking out the discussions, i found out that we don\\'t have to solve it, but have to check than whether it is a valid sudoku or not.\\nMoral of the story: Read the question very carefully."
                    }
                ]
            },
            {
                "id": 1571090,
                "content": [
                    {
                        "username": "YogeshK",
                        "content": "not sure its not going through in my head and dont wanna memorize it...\\nEnded up comparing x and y and calculating each box index."
                    },
                    {
                        "username": "lgdelacruz",
                        "content": "I spent a long time on this thinking it has to be solvable to be valid. No, you just need to check if it is valid."
                    },
                    {
                        "username": "ronghuali980303",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nMy submission fails at this one. It\\'s appearently only 9 can be in the first element according to the row.However 9 also exists in the first column. Therefore my answer to this is false. But the expected output is true. Anyone can tell me why?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "ksuzuki",
                        "content": "There is a test case:\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nwhich should return False because the top left corner can\\'t populate any values without breaking the constraints. Column is looking for a 1, but Row is looking for a 9. But leetcode is expecting the output to be True.\\n\\nany thoughts?\\n"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "divi13",
                        "content": "Hi,\\n\\nFor the second input (with 8 instead of 5), the grader says that my code produces the result \\'true\\' but when I run it myself, I am getting the expected false. This happened a few days ago too with another question. Is it possible that the grader is somehow storing the previous result and incorrectly outputting that as the current result too? Could you please fix the grader?"
                    },
                    {
                        "username": "JingxuOuyang",
                        "content": "{{\\'.\\',\\'8\\',\\'7\\',\\'6\\',\\'5\\',\\'4\\',\\'3\\',\\'2\\',\\'1\\'},\\n{\\'2\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'3\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'4\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'5\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'6\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'7\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'8\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'9\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'}}\\nexcept true?"
                    },
                    {
                        "username": "otherside2",
                        "content": "How is this a valid Sudoku?\\n\\nWrong Answer\\nInput: \\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\nOutput: false\\nExpected: true"
                    },
                    {
                        "username": "kaihua",
                        "content": "the last input is \\n[\"..5.....6\",\"....14...\",\".........\",\".....92..\",\"5....2...\",\".......3.\",\"...54....\",\"3.....42.\",\"...27.6..\"]\\n\\n\".....92..\",\"5....2...\" will be wrong."
                    },
                    {
                        "username": "42nl",
                        "content": "below is the outcome from my judge:\\n\\nInput:\\t[\"..4...63.\",\".........\",\"5......9.\",\"...56....\",\"4.3.....1\",\"...7.....\",\"...5.....\",\".........\",\".........\"]\\nOutput:\\ttrue\\nExpected:\\tfalse\\n\\nDoes anybody know why this input should be false? Could you tell me?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "4th row has the number 5 two times in it"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "I tried this for 2 hours and after checking out the discussions, i found out that we don\\'t have to solve it, but have to check than whether it is a valid sudoku or not.\\nMoral of the story: Read the question very carefully."
                    }
                ]
            },
            {
                "id": 1574892,
                "content": [
                    {
                        "username": "YogeshK",
                        "content": "not sure its not going through in my head and dont wanna memorize it...\\nEnded up comparing x and y and calculating each box index."
                    },
                    {
                        "username": "lgdelacruz",
                        "content": "I spent a long time on this thinking it has to be solvable to be valid. No, you just need to check if it is valid."
                    },
                    {
                        "username": "ronghuali980303",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nMy submission fails at this one. It\\'s appearently only 9 can be in the first element according to the row.However 9 also exists in the first column. Therefore my answer to this is false. But the expected output is true. Anyone can tell me why?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "ksuzuki",
                        "content": "There is a test case:\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nwhich should return False because the top left corner can\\'t populate any values without breaking the constraints. Column is looking for a 1, but Row is looking for a 9. But leetcode is expecting the output to be True.\\n\\nany thoughts?\\n"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "divi13",
                        "content": "Hi,\\n\\nFor the second input (with 8 instead of 5), the grader says that my code produces the result \\'true\\' but when I run it myself, I am getting the expected false. This happened a few days ago too with another question. Is it possible that the grader is somehow storing the previous result and incorrectly outputting that as the current result too? Could you please fix the grader?"
                    },
                    {
                        "username": "JingxuOuyang",
                        "content": "{{\\'.\\',\\'8\\',\\'7\\',\\'6\\',\\'5\\',\\'4\\',\\'3\\',\\'2\\',\\'1\\'},\\n{\\'2\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'3\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'4\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'5\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'6\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'7\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'8\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'9\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'}}\\nexcept true?"
                    },
                    {
                        "username": "otherside2",
                        "content": "How is this a valid Sudoku?\\n\\nWrong Answer\\nInput: \\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\nOutput: false\\nExpected: true"
                    },
                    {
                        "username": "kaihua",
                        "content": "the last input is \\n[\"..5.....6\",\"....14...\",\".........\",\".....92..\",\"5....2...\",\".......3.\",\"...54....\",\"3.....42.\",\"...27.6..\"]\\n\\n\".....92..\",\"5....2...\" will be wrong."
                    },
                    {
                        "username": "42nl",
                        "content": "below is the outcome from my judge:\\n\\nInput:\\t[\"..4...63.\",\".........\",\"5......9.\",\"...56....\",\"4.3.....1\",\"...7.....\",\"...5.....\",\".........\",\".........\"]\\nOutput:\\ttrue\\nExpected:\\tfalse\\n\\nDoes anybody know why this input should be false? Could you tell me?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "4th row has the number 5 two times in it"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "I tried this for 2 hours and after checking out the discussions, i found out that we don\\'t have to solve it, but have to check than whether it is a valid sudoku or not.\\nMoral of the story: Read the question very carefully."
                    }
                ]
            },
            {
                "id": 1571885,
                "content": [
                    {
                        "username": "zackzhu20",
                        "content": "I am wondering if this question is about checking the validity of the sudoku or checking if there is solution for this sudoku. If it is the latter case, it is much more difficult then (need to solve the sudoku and check)"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is only about checking the validity of sudoku"
                    },
                    {
                        "username": "HamzaGorcevic",
                        "content": "Why is fasle expected:\\n [[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n. I sent rules and board to chatgpt and it says its valid"
                    },
                    {
                        "username": "adevlinb",
                        "content": "Not all of the test cases are giving the proper outcome..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@adevlinb](/adevlinb) The testcases are wrote by computer"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) I cannot reproduce that. My Javascript solution got accepted."
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev) \\n\\nJavascript"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) Which programming language is that?"
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev)  \\na human wrote the test, no? So it is possible that the test is wrong... #473:\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThis is set to expect the value of False.. when in fact.. it is True that it is a valid sudoku board.. if you read each horizontal and vertical line.. there are no repeating numbers.. The test is wrong. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "why"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Then your code is wrong."
                    },
                    {
                        "username": "amitpr02",
                        "content": "class Solution {\\n    bool isValid(vector<vector<char>> &board, char ch, int row, int col) {\\n        for (int i = 0; i < 9; i++) {\\n            if (board[i][col] == ch) \\n                return false;\\n            if (board[row][i] == ch) \\n                return false;\\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == ch) \\n                return false;       \\n        }\\n        return true;\\n    }\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    char ch = board[i][j];\\n                    if (!isValid(board, ch, i, j)) \\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\nWhat\\'s wrong in the code. Can anybody tell?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Use arrays of hash sets."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Remained stuck in this Test case for a duplicate column. it is a good question can have been categorized as Easy too. \n                          {{'.','.','4','.','.','.','6','3','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'5','.','.','.','.','.','.','9','.'},\n\t\t                   {'.','.','.','5','6','.','.','.','.'},\n\t\t                   {'4','.','3','.','.','.','.','.','1'},\n\t\t                   {'.','.','.','7','.','.','.','.','.'},\n\t\t                   {'.','.','.','5','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'}};"
                    },
                    {
                        "username": "nikhikpal173",
                        "content": "the discussion number was 69  before this \\u2665"
                    },
                    {
                        "username": "m1059006",
                        "content": "I thought it is a challenging problem at the first sight. Later, I found it is actually not too hard. I was just overthinking.\\nIt just asked you to check if the initial board is valid (so that following all rules in the description).  It doesn\\'t matter it is solvable or not."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "test case 473: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"];\\nI have checked and found no repeatition. All rows and columns have unique values.\\nwhy expected answer is false? can anyone help me? Thanks in advance."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "I have the answer -- each 3x3 sub box must have unique digits"
                    },
                    {
                        "username": "EricTsaiQA",
                        "content": "Having q question about test case 371, if all elements are \".\" , why it should return true ?  i suppose it should return false, lol"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It does not have duplicate numbers, so it is valid."
                    },
                    {
                        "username": "adhyayana",
                        "content": "Why this code is not working :\\nclass Solution {\\n\\n    public  boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public  boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n}\\n"
                    }
                ]
            },
            {
                "id": 2059206,
                "content": [
                    {
                        "username": "zackzhu20",
                        "content": "I am wondering if this question is about checking the validity of the sudoku or checking if there is solution for this sudoku. If it is the latter case, it is much more difficult then (need to solve the sudoku and check)"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is only about checking the validity of sudoku"
                    },
                    {
                        "username": "HamzaGorcevic",
                        "content": "Why is fasle expected:\\n [[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n. I sent rules and board to chatgpt and it says its valid"
                    },
                    {
                        "username": "adevlinb",
                        "content": "Not all of the test cases are giving the proper outcome..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@adevlinb](/adevlinb) The testcases are wrote by computer"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) I cannot reproduce that. My Javascript solution got accepted."
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev) \\n\\nJavascript"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) Which programming language is that?"
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev)  \\na human wrote the test, no? So it is possible that the test is wrong... #473:\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThis is set to expect the value of False.. when in fact.. it is True that it is a valid sudoku board.. if you read each horizontal and vertical line.. there are no repeating numbers.. The test is wrong. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "why"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Then your code is wrong."
                    },
                    {
                        "username": "amitpr02",
                        "content": "class Solution {\\n    bool isValid(vector<vector<char>> &board, char ch, int row, int col) {\\n        for (int i = 0; i < 9; i++) {\\n            if (board[i][col] == ch) \\n                return false;\\n            if (board[row][i] == ch) \\n                return false;\\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == ch) \\n                return false;       \\n        }\\n        return true;\\n    }\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    char ch = board[i][j];\\n                    if (!isValid(board, ch, i, j)) \\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\nWhat\\'s wrong in the code. Can anybody tell?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Use arrays of hash sets."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Remained stuck in this Test case for a duplicate column. it is a good question can have been categorized as Easy too. \n                          {{'.','.','4','.','.','.','6','3','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'5','.','.','.','.','.','.','9','.'},\n\t\t                   {'.','.','.','5','6','.','.','.','.'},\n\t\t                   {'4','.','3','.','.','.','.','.','1'},\n\t\t                   {'.','.','.','7','.','.','.','.','.'},\n\t\t                   {'.','.','.','5','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'}};"
                    },
                    {
                        "username": "nikhikpal173",
                        "content": "the discussion number was 69  before this \\u2665"
                    },
                    {
                        "username": "m1059006",
                        "content": "I thought it is a challenging problem at the first sight. Later, I found it is actually not too hard. I was just overthinking.\\nIt just asked you to check if the initial board is valid (so that following all rules in the description).  It doesn\\'t matter it is solvable or not."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "test case 473: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"];\\nI have checked and found no repeatition. All rows and columns have unique values.\\nwhy expected answer is false? can anyone help me? Thanks in advance."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "I have the answer -- each 3x3 sub box must have unique digits"
                    },
                    {
                        "username": "EricTsaiQA",
                        "content": "Having q question about test case 371, if all elements are \".\" , why it should return true ?  i suppose it should return false, lol"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It does not have duplicate numbers, so it is valid."
                    },
                    {
                        "username": "adhyayana",
                        "content": "Why this code is not working :\\nclass Solution {\\n\\n    public  boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public  boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n}\\n"
                    }
                ]
            },
            {
                "id": 2058299,
                "content": [
                    {
                        "username": "zackzhu20",
                        "content": "I am wondering if this question is about checking the validity of the sudoku or checking if there is solution for this sudoku. If it is the latter case, it is much more difficult then (need to solve the sudoku and check)"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is only about checking the validity of sudoku"
                    },
                    {
                        "username": "HamzaGorcevic",
                        "content": "Why is fasle expected:\\n [[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n. I sent rules and board to chatgpt and it says its valid"
                    },
                    {
                        "username": "adevlinb",
                        "content": "Not all of the test cases are giving the proper outcome..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@adevlinb](/adevlinb) The testcases are wrote by computer"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) I cannot reproduce that. My Javascript solution got accepted."
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev) \\n\\nJavascript"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) Which programming language is that?"
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev)  \\na human wrote the test, no? So it is possible that the test is wrong... #473:\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThis is set to expect the value of False.. when in fact.. it is True that it is a valid sudoku board.. if you read each horizontal and vertical line.. there are no repeating numbers.. The test is wrong. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "why"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Then your code is wrong."
                    },
                    {
                        "username": "amitpr02",
                        "content": "class Solution {\\n    bool isValid(vector<vector<char>> &board, char ch, int row, int col) {\\n        for (int i = 0; i < 9; i++) {\\n            if (board[i][col] == ch) \\n                return false;\\n            if (board[row][i] == ch) \\n                return false;\\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == ch) \\n                return false;       \\n        }\\n        return true;\\n    }\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    char ch = board[i][j];\\n                    if (!isValid(board, ch, i, j)) \\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\nWhat\\'s wrong in the code. Can anybody tell?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Use arrays of hash sets."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Remained stuck in this Test case for a duplicate column. it is a good question can have been categorized as Easy too. \n                          {{'.','.','4','.','.','.','6','3','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'5','.','.','.','.','.','.','9','.'},\n\t\t                   {'.','.','.','5','6','.','.','.','.'},\n\t\t                   {'4','.','3','.','.','.','.','.','1'},\n\t\t                   {'.','.','.','7','.','.','.','.','.'},\n\t\t                   {'.','.','.','5','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'}};"
                    },
                    {
                        "username": "nikhikpal173",
                        "content": "the discussion number was 69  before this \\u2665"
                    },
                    {
                        "username": "m1059006",
                        "content": "I thought it is a challenging problem at the first sight. Later, I found it is actually not too hard. I was just overthinking.\\nIt just asked you to check if the initial board is valid (so that following all rules in the description).  It doesn\\'t matter it is solvable or not."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "test case 473: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"];\\nI have checked and found no repeatition. All rows and columns have unique values.\\nwhy expected answer is false? can anyone help me? Thanks in advance."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "I have the answer -- each 3x3 sub box must have unique digits"
                    },
                    {
                        "username": "EricTsaiQA",
                        "content": "Having q question about test case 371, if all elements are \".\" , why it should return true ?  i suppose it should return false, lol"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It does not have duplicate numbers, so it is valid."
                    },
                    {
                        "username": "adhyayana",
                        "content": "Why this code is not working :\\nclass Solution {\\n\\n    public  boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public  boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n}\\n"
                    }
                ]
            },
            {
                "id": 2025457,
                "content": [
                    {
                        "username": "zackzhu20",
                        "content": "I am wondering if this question is about checking the validity of the sudoku or checking if there is solution for this sudoku. If it is the latter case, it is much more difficult then (need to solve the sudoku and check)"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is only about checking the validity of sudoku"
                    },
                    {
                        "username": "HamzaGorcevic",
                        "content": "Why is fasle expected:\\n [[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n. I sent rules and board to chatgpt and it says its valid"
                    },
                    {
                        "username": "adevlinb",
                        "content": "Not all of the test cases are giving the proper outcome..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@adevlinb](/adevlinb) The testcases are wrote by computer"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) I cannot reproduce that. My Javascript solution got accepted."
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev) \\n\\nJavascript"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) Which programming language is that?"
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev)  \\na human wrote the test, no? So it is possible that the test is wrong... #473:\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThis is set to expect the value of False.. when in fact.. it is True that it is a valid sudoku board.. if you read each horizontal and vertical line.. there are no repeating numbers.. The test is wrong. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "why"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Then your code is wrong."
                    },
                    {
                        "username": "amitpr02",
                        "content": "class Solution {\\n    bool isValid(vector<vector<char>> &board, char ch, int row, int col) {\\n        for (int i = 0; i < 9; i++) {\\n            if (board[i][col] == ch) \\n                return false;\\n            if (board[row][i] == ch) \\n                return false;\\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == ch) \\n                return false;       \\n        }\\n        return true;\\n    }\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    char ch = board[i][j];\\n                    if (!isValid(board, ch, i, j)) \\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\nWhat\\'s wrong in the code. Can anybody tell?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Use arrays of hash sets."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Remained stuck in this Test case for a duplicate column. it is a good question can have been categorized as Easy too. \n                          {{'.','.','4','.','.','.','6','3','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'5','.','.','.','.','.','.','9','.'},\n\t\t                   {'.','.','.','5','6','.','.','.','.'},\n\t\t                   {'4','.','3','.','.','.','.','.','1'},\n\t\t                   {'.','.','.','7','.','.','.','.','.'},\n\t\t                   {'.','.','.','5','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'}};"
                    },
                    {
                        "username": "nikhikpal173",
                        "content": "the discussion number was 69  before this \\u2665"
                    },
                    {
                        "username": "m1059006",
                        "content": "I thought it is a challenging problem at the first sight. Later, I found it is actually not too hard. I was just overthinking.\\nIt just asked you to check if the initial board is valid (so that following all rules in the description).  It doesn\\'t matter it is solvable or not."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "test case 473: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"];\\nI have checked and found no repeatition. All rows and columns have unique values.\\nwhy expected answer is false? can anyone help me? Thanks in advance."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "I have the answer -- each 3x3 sub box must have unique digits"
                    },
                    {
                        "username": "EricTsaiQA",
                        "content": "Having q question about test case 371, if all elements are \".\" , why it should return true ?  i suppose it should return false, lol"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It does not have duplicate numbers, so it is valid."
                    },
                    {
                        "username": "adhyayana",
                        "content": "Why this code is not working :\\nclass Solution {\\n\\n    public  boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public  boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n}\\n"
                    }
                ]
            },
            {
                "id": 2020432,
                "content": [
                    {
                        "username": "zackzhu20",
                        "content": "I am wondering if this question is about checking the validity of the sudoku or checking if there is solution for this sudoku. If it is the latter case, it is much more difficult then (need to solve the sudoku and check)"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is only about checking the validity of sudoku"
                    },
                    {
                        "username": "HamzaGorcevic",
                        "content": "Why is fasle expected:\\n [[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n. I sent rules and board to chatgpt and it says its valid"
                    },
                    {
                        "username": "adevlinb",
                        "content": "Not all of the test cases are giving the proper outcome..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@adevlinb](/adevlinb) The testcases are wrote by computer"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) I cannot reproduce that. My Javascript solution got accepted."
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev) \\n\\nJavascript"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) Which programming language is that?"
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev)  \\na human wrote the test, no? So it is possible that the test is wrong... #473:\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThis is set to expect the value of False.. when in fact.. it is True that it is a valid sudoku board.. if you read each horizontal and vertical line.. there are no repeating numbers.. The test is wrong. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "why"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Then your code is wrong."
                    },
                    {
                        "username": "amitpr02",
                        "content": "class Solution {\\n    bool isValid(vector<vector<char>> &board, char ch, int row, int col) {\\n        for (int i = 0; i < 9; i++) {\\n            if (board[i][col] == ch) \\n                return false;\\n            if (board[row][i] == ch) \\n                return false;\\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == ch) \\n                return false;       \\n        }\\n        return true;\\n    }\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    char ch = board[i][j];\\n                    if (!isValid(board, ch, i, j)) \\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\nWhat\\'s wrong in the code. Can anybody tell?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Use arrays of hash sets."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Remained stuck in this Test case for a duplicate column. it is a good question can have been categorized as Easy too. \n                          {{'.','.','4','.','.','.','6','3','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'5','.','.','.','.','.','.','9','.'},\n\t\t                   {'.','.','.','5','6','.','.','.','.'},\n\t\t                   {'4','.','3','.','.','.','.','.','1'},\n\t\t                   {'.','.','.','7','.','.','.','.','.'},\n\t\t                   {'.','.','.','5','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'}};"
                    },
                    {
                        "username": "nikhikpal173",
                        "content": "the discussion number was 69  before this \\u2665"
                    },
                    {
                        "username": "m1059006",
                        "content": "I thought it is a challenging problem at the first sight. Later, I found it is actually not too hard. I was just overthinking.\\nIt just asked you to check if the initial board is valid (so that following all rules in the description).  It doesn\\'t matter it is solvable or not."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "test case 473: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"];\\nI have checked and found no repeatition. All rows and columns have unique values.\\nwhy expected answer is false? can anyone help me? Thanks in advance."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "I have the answer -- each 3x3 sub box must have unique digits"
                    },
                    {
                        "username": "EricTsaiQA",
                        "content": "Having q question about test case 371, if all elements are \".\" , why it should return true ?  i suppose it should return false, lol"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It does not have duplicate numbers, so it is valid."
                    },
                    {
                        "username": "adhyayana",
                        "content": "Why this code is not working :\\nclass Solution {\\n\\n    public  boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public  boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1984607,
                "content": [
                    {
                        "username": "zackzhu20",
                        "content": "I am wondering if this question is about checking the validity of the sudoku or checking if there is solution for this sudoku. If it is the latter case, it is much more difficult then (need to solve the sudoku and check)"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is only about checking the validity of sudoku"
                    },
                    {
                        "username": "HamzaGorcevic",
                        "content": "Why is fasle expected:\\n [[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n. I sent rules and board to chatgpt and it says its valid"
                    },
                    {
                        "username": "adevlinb",
                        "content": "Not all of the test cases are giving the proper outcome..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@adevlinb](/adevlinb) The testcases are wrote by computer"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) I cannot reproduce that. My Javascript solution got accepted."
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev) \\n\\nJavascript"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) Which programming language is that?"
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev)  \\na human wrote the test, no? So it is possible that the test is wrong... #473:\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThis is set to expect the value of False.. when in fact.. it is True that it is a valid sudoku board.. if you read each horizontal and vertical line.. there are no repeating numbers.. The test is wrong. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "why"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Then your code is wrong."
                    },
                    {
                        "username": "amitpr02",
                        "content": "class Solution {\\n    bool isValid(vector<vector<char>> &board, char ch, int row, int col) {\\n        for (int i = 0; i < 9; i++) {\\n            if (board[i][col] == ch) \\n                return false;\\n            if (board[row][i] == ch) \\n                return false;\\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == ch) \\n                return false;       \\n        }\\n        return true;\\n    }\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    char ch = board[i][j];\\n                    if (!isValid(board, ch, i, j)) \\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\nWhat\\'s wrong in the code. Can anybody tell?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Use arrays of hash sets."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Remained stuck in this Test case for a duplicate column. it is a good question can have been categorized as Easy too. \n                          {{'.','.','4','.','.','.','6','3','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'5','.','.','.','.','.','.','9','.'},\n\t\t                   {'.','.','.','5','6','.','.','.','.'},\n\t\t                   {'4','.','3','.','.','.','.','.','1'},\n\t\t                   {'.','.','.','7','.','.','.','.','.'},\n\t\t                   {'.','.','.','5','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'}};"
                    },
                    {
                        "username": "nikhikpal173",
                        "content": "the discussion number was 69  before this \\u2665"
                    },
                    {
                        "username": "m1059006",
                        "content": "I thought it is a challenging problem at the first sight. Later, I found it is actually not too hard. I was just overthinking.\\nIt just asked you to check if the initial board is valid (so that following all rules in the description).  It doesn\\'t matter it is solvable or not."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "test case 473: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"];\\nI have checked and found no repeatition. All rows and columns have unique values.\\nwhy expected answer is false? can anyone help me? Thanks in advance."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "I have the answer -- each 3x3 sub box must have unique digits"
                    },
                    {
                        "username": "EricTsaiQA",
                        "content": "Having q question about test case 371, if all elements are \".\" , why it should return true ?  i suppose it should return false, lol"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It does not have duplicate numbers, so it is valid."
                    },
                    {
                        "username": "adhyayana",
                        "content": "Why this code is not working :\\nclass Solution {\\n\\n    public  boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public  boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1973127,
                "content": [
                    {
                        "username": "zackzhu20",
                        "content": "I am wondering if this question is about checking the validity of the sudoku or checking if there is solution for this sudoku. If it is the latter case, it is much more difficult then (need to solve the sudoku and check)"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is only about checking the validity of sudoku"
                    },
                    {
                        "username": "HamzaGorcevic",
                        "content": "Why is fasle expected:\\n [[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n. I sent rules and board to chatgpt and it says its valid"
                    },
                    {
                        "username": "adevlinb",
                        "content": "Not all of the test cases are giving the proper outcome..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@adevlinb](/adevlinb) The testcases are wrote by computer"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) I cannot reproduce that. My Javascript solution got accepted."
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev) \\n\\nJavascript"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) Which programming language is that?"
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev)  \\na human wrote the test, no? So it is possible that the test is wrong... #473:\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThis is set to expect the value of False.. when in fact.. it is True that it is a valid sudoku board.. if you read each horizontal and vertical line.. there are no repeating numbers.. The test is wrong. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "why"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Then your code is wrong."
                    },
                    {
                        "username": "amitpr02",
                        "content": "class Solution {\\n    bool isValid(vector<vector<char>> &board, char ch, int row, int col) {\\n        for (int i = 0; i < 9; i++) {\\n            if (board[i][col] == ch) \\n                return false;\\n            if (board[row][i] == ch) \\n                return false;\\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == ch) \\n                return false;       \\n        }\\n        return true;\\n    }\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    char ch = board[i][j];\\n                    if (!isValid(board, ch, i, j)) \\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\nWhat\\'s wrong in the code. Can anybody tell?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Use arrays of hash sets."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Remained stuck in this Test case for a duplicate column. it is a good question can have been categorized as Easy too. \n                          {{'.','.','4','.','.','.','6','3','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'5','.','.','.','.','.','.','9','.'},\n\t\t                   {'.','.','.','5','6','.','.','.','.'},\n\t\t                   {'4','.','3','.','.','.','.','.','1'},\n\t\t                   {'.','.','.','7','.','.','.','.','.'},\n\t\t                   {'.','.','.','5','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'}};"
                    },
                    {
                        "username": "nikhikpal173",
                        "content": "the discussion number was 69  before this \\u2665"
                    },
                    {
                        "username": "m1059006",
                        "content": "I thought it is a challenging problem at the first sight. Later, I found it is actually not too hard. I was just overthinking.\\nIt just asked you to check if the initial board is valid (so that following all rules in the description).  It doesn\\'t matter it is solvable or not."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "test case 473: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"];\\nI have checked and found no repeatition. All rows and columns have unique values.\\nwhy expected answer is false? can anyone help me? Thanks in advance."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "I have the answer -- each 3x3 sub box must have unique digits"
                    },
                    {
                        "username": "EricTsaiQA",
                        "content": "Having q question about test case 371, if all elements are \".\" , why it should return true ?  i suppose it should return false, lol"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It does not have duplicate numbers, so it is valid."
                    },
                    {
                        "username": "adhyayana",
                        "content": "Why this code is not working :\\nclass Solution {\\n\\n    public  boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public  boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1949150,
                "content": [
                    {
                        "username": "zackzhu20",
                        "content": "I am wondering if this question is about checking the validity of the sudoku or checking if there is solution for this sudoku. If it is the latter case, it is much more difficult then (need to solve the sudoku and check)"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is only about checking the validity of sudoku"
                    },
                    {
                        "username": "HamzaGorcevic",
                        "content": "Why is fasle expected:\\n [[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n. I sent rules and board to chatgpt and it says its valid"
                    },
                    {
                        "username": "adevlinb",
                        "content": "Not all of the test cases are giving the proper outcome..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@adevlinb](/adevlinb) The testcases are wrote by computer"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) I cannot reproduce that. My Javascript solution got accepted."
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev) \\n\\nJavascript"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) Which programming language is that?"
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev)  \\na human wrote the test, no? So it is possible that the test is wrong... #473:\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThis is set to expect the value of False.. when in fact.. it is True that it is a valid sudoku board.. if you read each horizontal and vertical line.. there are no repeating numbers.. The test is wrong. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "why"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Then your code is wrong."
                    },
                    {
                        "username": "amitpr02",
                        "content": "class Solution {\\n    bool isValid(vector<vector<char>> &board, char ch, int row, int col) {\\n        for (int i = 0; i < 9; i++) {\\n            if (board[i][col] == ch) \\n                return false;\\n            if (board[row][i] == ch) \\n                return false;\\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == ch) \\n                return false;       \\n        }\\n        return true;\\n    }\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    char ch = board[i][j];\\n                    if (!isValid(board, ch, i, j)) \\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\nWhat\\'s wrong in the code. Can anybody tell?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Use arrays of hash sets."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Remained stuck in this Test case for a duplicate column. it is a good question can have been categorized as Easy too. \n                          {{'.','.','4','.','.','.','6','3','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'5','.','.','.','.','.','.','9','.'},\n\t\t                   {'.','.','.','5','6','.','.','.','.'},\n\t\t                   {'4','.','3','.','.','.','.','.','1'},\n\t\t                   {'.','.','.','7','.','.','.','.','.'},\n\t\t                   {'.','.','.','5','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'}};"
                    },
                    {
                        "username": "nikhikpal173",
                        "content": "the discussion number was 69  before this \\u2665"
                    },
                    {
                        "username": "m1059006",
                        "content": "I thought it is a challenging problem at the first sight. Later, I found it is actually not too hard. I was just overthinking.\\nIt just asked you to check if the initial board is valid (so that following all rules in the description).  It doesn\\'t matter it is solvable or not."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "test case 473: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"];\\nI have checked and found no repeatition. All rows and columns have unique values.\\nwhy expected answer is false? can anyone help me? Thanks in advance."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "I have the answer -- each 3x3 sub box must have unique digits"
                    },
                    {
                        "username": "EricTsaiQA",
                        "content": "Having q question about test case 371, if all elements are \".\" , why it should return true ?  i suppose it should return false, lol"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It does not have duplicate numbers, so it is valid."
                    },
                    {
                        "username": "adhyayana",
                        "content": "Why this code is not working :\\nclass Solution {\\n\\n    public  boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public  boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1946320,
                "content": [
                    {
                        "username": "zackzhu20",
                        "content": "I am wondering if this question is about checking the validity of the sudoku or checking if there is solution for this sudoku. If it is the latter case, it is much more difficult then (need to solve the sudoku and check)"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is only about checking the validity of sudoku"
                    },
                    {
                        "username": "HamzaGorcevic",
                        "content": "Why is fasle expected:\\n [[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n. I sent rules and board to chatgpt and it says its valid"
                    },
                    {
                        "username": "adevlinb",
                        "content": "Not all of the test cases are giving the proper outcome..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@adevlinb](/adevlinb) The testcases are wrote by computer"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) I cannot reproduce that. My Javascript solution got accepted."
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev) \\n\\nJavascript"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) Which programming language is that?"
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev)  \\na human wrote the test, no? So it is possible that the test is wrong... #473:\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThis is set to expect the value of False.. when in fact.. it is True that it is a valid sudoku board.. if you read each horizontal and vertical line.. there are no repeating numbers.. The test is wrong. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "why"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Then your code is wrong."
                    },
                    {
                        "username": "amitpr02",
                        "content": "class Solution {\\n    bool isValid(vector<vector<char>> &board, char ch, int row, int col) {\\n        for (int i = 0; i < 9; i++) {\\n            if (board[i][col] == ch) \\n                return false;\\n            if (board[row][i] == ch) \\n                return false;\\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == ch) \\n                return false;       \\n        }\\n        return true;\\n    }\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    char ch = board[i][j];\\n                    if (!isValid(board, ch, i, j)) \\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\nWhat\\'s wrong in the code. Can anybody tell?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Use arrays of hash sets."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Remained stuck in this Test case for a duplicate column. it is a good question can have been categorized as Easy too. \n                          {{'.','.','4','.','.','.','6','3','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'5','.','.','.','.','.','.','9','.'},\n\t\t                   {'.','.','.','5','6','.','.','.','.'},\n\t\t                   {'4','.','3','.','.','.','.','.','1'},\n\t\t                   {'.','.','.','7','.','.','.','.','.'},\n\t\t                   {'.','.','.','5','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'}};"
                    },
                    {
                        "username": "nikhikpal173",
                        "content": "the discussion number was 69  before this \\u2665"
                    },
                    {
                        "username": "m1059006",
                        "content": "I thought it is a challenging problem at the first sight. Later, I found it is actually not too hard. I was just overthinking.\\nIt just asked you to check if the initial board is valid (so that following all rules in the description).  It doesn\\'t matter it is solvable or not."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "test case 473: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"];\\nI have checked and found no repeatition. All rows and columns have unique values.\\nwhy expected answer is false? can anyone help me? Thanks in advance."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "I have the answer -- each 3x3 sub box must have unique digits"
                    },
                    {
                        "username": "EricTsaiQA",
                        "content": "Having q question about test case 371, if all elements are \".\" , why it should return true ?  i suppose it should return false, lol"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It does not have duplicate numbers, so it is valid."
                    },
                    {
                        "username": "adhyayana",
                        "content": "Why this code is not working :\\nclass Solution {\\n\\n    public  boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public  boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1910695,
                "content": [
                    {
                        "username": "zackzhu20",
                        "content": "I am wondering if this question is about checking the validity of the sudoku or checking if there is solution for this sudoku. If it is the latter case, it is much more difficult then (need to solve the sudoku and check)"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is only about checking the validity of sudoku"
                    },
                    {
                        "username": "HamzaGorcevic",
                        "content": "Why is fasle expected:\\n [[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n. I sent rules and board to chatgpt and it says its valid"
                    },
                    {
                        "username": "adevlinb",
                        "content": "Not all of the test cases are giving the proper outcome..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@adevlinb](/adevlinb) The testcases are wrote by computer"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) I cannot reproduce that. My Javascript solution got accepted."
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev) \\n\\nJavascript"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) Which programming language is that?"
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev)  \\na human wrote the test, no? So it is possible that the test is wrong... #473:\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThis is set to expect the value of False.. when in fact.. it is True that it is a valid sudoku board.. if you read each horizontal and vertical line.. there are no repeating numbers.. The test is wrong. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "why"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Then your code is wrong."
                    },
                    {
                        "username": "amitpr02",
                        "content": "class Solution {\\n    bool isValid(vector<vector<char>> &board, char ch, int row, int col) {\\n        for (int i = 0; i < 9; i++) {\\n            if (board[i][col] == ch) \\n                return false;\\n            if (board[row][i] == ch) \\n                return false;\\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == ch) \\n                return false;       \\n        }\\n        return true;\\n    }\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    char ch = board[i][j];\\n                    if (!isValid(board, ch, i, j)) \\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\nWhat\\'s wrong in the code. Can anybody tell?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Use arrays of hash sets."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Remained stuck in this Test case for a duplicate column. it is a good question can have been categorized as Easy too. \n                          {{'.','.','4','.','.','.','6','3','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'5','.','.','.','.','.','.','9','.'},\n\t\t                   {'.','.','.','5','6','.','.','.','.'},\n\t\t                   {'4','.','3','.','.','.','.','.','1'},\n\t\t                   {'.','.','.','7','.','.','.','.','.'},\n\t\t                   {'.','.','.','5','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'}};"
                    },
                    {
                        "username": "nikhikpal173",
                        "content": "the discussion number was 69  before this \\u2665"
                    },
                    {
                        "username": "m1059006",
                        "content": "I thought it is a challenging problem at the first sight. Later, I found it is actually not too hard. I was just overthinking.\\nIt just asked you to check if the initial board is valid (so that following all rules in the description).  It doesn\\'t matter it is solvable or not."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "test case 473: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"];\\nI have checked and found no repeatition. All rows and columns have unique values.\\nwhy expected answer is false? can anyone help me? Thanks in advance."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "I have the answer -- each 3x3 sub box must have unique digits"
                    },
                    {
                        "username": "EricTsaiQA",
                        "content": "Having q question about test case 371, if all elements are \".\" , why it should return true ?  i suppose it should return false, lol"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It does not have duplicate numbers, so it is valid."
                    },
                    {
                        "username": "adhyayana",
                        "content": "Why this code is not working :\\nclass Solution {\\n\\n    public  boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public  boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1891660,
                "content": [
                    {
                        "username": "lethienluc2021",
                        "content": "why [[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] has result true"
                    },
                    {
                        "username": "NithinModiboyana",
                        "content": "[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"]\\n,[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"]\\n,[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"]\\n,[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"]\\n,[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"]\\n,[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\ncan someone explain why is this False? "
                    },
                    {
                        "username": "Skripko",
                        "content": "In my view, this task should be easy, not medium"
                    },
                    {
                        "username": "Janvigurjar",
                        "content": "def isValid(row,col,board,c):\\n            for i in range(len(board)):\\n                if board[row][i]==c  and i!=row:\\n                    return False\\n                if board[i][col]==c and i!=col:\\n                    return False\\n                if board[3*(row//3)+i//3][3*(col//3)+i%3]==c and i!= 3*(row//3)+i//3 :\\n                    return False\\n            return True\\n        \\ndef check(board):\\n    for i in range(len(board)):\\n        for j in range(len(board)):\\n            if board[i][j]!=\".\":\\n                if isValid(i,j,board,board[i][j])==False:\\n                    return False\\n    return True\\n\\n\\n\\ncan anyone help in this"
                    },
                    {
                        "username": "zaman_ishtiyaq",
                        "content": "is this board solvable?\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n"
                    },
                    {
                        "username": "Navfalbek",
                        "content": "I think there is a bug in testcase 350 which is:\\n[[\".\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"],\\n          [\"2\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"3\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"4\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"6\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"7\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"8\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"9\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]]\\n\\nWhen I submited the solution it only fails in this one. But when I run the same code on PyCharm the result was True (Valid) however, when I run in LeetCode\\'s codespace it gives False. I do not know why this is happening. Is there someone also faced with this problem?"
                    },
                    {
                        "username": "kanishkamehrotra",
                        "content": "why is this test case failing ,my solution is giving true for this but it seems that the answer is false ,no number is rows coloumns are repeating and not even in the blocks \\n[\\n[\".\",\".\",\"4\", \".\",\".\",\".\", \"6\",\"3\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\"5\",\".\",\".\", \".\",\".\",\".\", \".\",\"9\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\"6\",\".\", \".\",\".\",\".\"],\\n[\"4\",\".\",\"3\", \".\",\".\",\".\", \".\",\".\",\"1\"],\\n[\".\",\".\",\".\", \"7\",\".\",\".\", \".\",\".\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"]\\n]"
                    },
                    {
                        "username": "itsathakur30",
                        "content": "How output can be true?\\n\\n\\nboard =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n\\nOutput\\nfalse\\n\\n\\nExpected\\ntrue\\n\\n\\n\\n"
                    },
                    {
                        "username": "h4sh_19",
                        "content": "who else wrote the code to solve the sudoku and find the valid sudoku instead of just checking only filled spots? Only me ? \\uD83D\\uDE29"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Can someone help me find the bug here ?\\n\\nLooks like object.equals is not working as expected from the print statements , I am not sure where is the actual bug in the method. \\n\\nTest case 2 fails with this approach as the solution cannot detect that two 8\\'s are in the same grid even though they map to the same grid. \\n\\nFWIW I solved it through another approach but wanted to do it in a OOPS way.\\n\\n\\n   ` class Solution {\\n\\n     char[][] board;\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        this.board = board;\\n        \\n        return solveUsingOOPS();\\n    \\n    }\\n\\n    private boolean solveUsingOOPS(){\\n\\n        Set<SudokuPosition> set = new HashSet<>();\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int rowGrid = i/3;\\n                    int colGrid = j/3;\\n                    SudokuPosition pos = new SudokuPosition(board[i][j],i,j,rowGrid*3+colGrid);\\n\\n                    if(set.contains(pos)){\\n                        return false;\\n                    }else{\\n                        set.add(pos);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    private class SudokuPosition{\\n        char val;\\n        int row; \\n        int col;\\n        int grid;\\n\\n        public SudokuPosition(char val,int row,int col,int grid){\\n            this.val = val;\\n            this.row = row;\\n            this.col = col;\\n            this.grid = grid;\\n        }\\n\\n        @Override\\n    public boolean equals(Object other) {\\n        if (!(other instanceof SudokuPosition)) {\\n            return false;\\n        }\\n        SudokuPosition spos = (SudokuPosition)other;\\n        return (this.val == spos.val) &&\\n               ((this.row == spos.row) || (this.col == spos.col) || (this.grid == spos.grid)); \\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return 31 * (31 * row + col) + grid;\\n    }\\n    \\n    }\\n\\n    }`"
                    }
                ]
            },
            {
                "id": 1890091,
                "content": [
                    {
                        "username": "lethienluc2021",
                        "content": "why [[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] has result true"
                    },
                    {
                        "username": "NithinModiboyana",
                        "content": "[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"]\\n,[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"]\\n,[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"]\\n,[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"]\\n,[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"]\\n,[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\ncan someone explain why is this False? "
                    },
                    {
                        "username": "Skripko",
                        "content": "In my view, this task should be easy, not medium"
                    },
                    {
                        "username": "Janvigurjar",
                        "content": "def isValid(row,col,board,c):\\n            for i in range(len(board)):\\n                if board[row][i]==c  and i!=row:\\n                    return False\\n                if board[i][col]==c and i!=col:\\n                    return False\\n                if board[3*(row//3)+i//3][3*(col//3)+i%3]==c and i!= 3*(row//3)+i//3 :\\n                    return False\\n            return True\\n        \\ndef check(board):\\n    for i in range(len(board)):\\n        for j in range(len(board)):\\n            if board[i][j]!=\".\":\\n                if isValid(i,j,board,board[i][j])==False:\\n                    return False\\n    return True\\n\\n\\n\\ncan anyone help in this"
                    },
                    {
                        "username": "zaman_ishtiyaq",
                        "content": "is this board solvable?\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n"
                    },
                    {
                        "username": "Navfalbek",
                        "content": "I think there is a bug in testcase 350 which is:\\n[[\".\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"],\\n          [\"2\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"3\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"4\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"6\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"7\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"8\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"9\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]]\\n\\nWhen I submited the solution it only fails in this one. But when I run the same code on PyCharm the result was True (Valid) however, when I run in LeetCode\\'s codespace it gives False. I do not know why this is happening. Is there someone also faced with this problem?"
                    },
                    {
                        "username": "kanishkamehrotra",
                        "content": "why is this test case failing ,my solution is giving true for this but it seems that the answer is false ,no number is rows coloumns are repeating and not even in the blocks \\n[\\n[\".\",\".\",\"4\", \".\",\".\",\".\", \"6\",\"3\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\"5\",\".\",\".\", \".\",\".\",\".\", \".\",\"9\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\"6\",\".\", \".\",\".\",\".\"],\\n[\"4\",\".\",\"3\", \".\",\".\",\".\", \".\",\".\",\"1\"],\\n[\".\",\".\",\".\", \"7\",\".\",\".\", \".\",\".\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"]\\n]"
                    },
                    {
                        "username": "itsathakur30",
                        "content": "How output can be true?\\n\\n\\nboard =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n\\nOutput\\nfalse\\n\\n\\nExpected\\ntrue\\n\\n\\n\\n"
                    },
                    {
                        "username": "h4sh_19",
                        "content": "who else wrote the code to solve the sudoku and find the valid sudoku instead of just checking only filled spots? Only me ? \\uD83D\\uDE29"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Can someone help me find the bug here ?\\n\\nLooks like object.equals is not working as expected from the print statements , I am not sure where is the actual bug in the method. \\n\\nTest case 2 fails with this approach as the solution cannot detect that two 8\\'s are in the same grid even though they map to the same grid. \\n\\nFWIW I solved it through another approach but wanted to do it in a OOPS way.\\n\\n\\n   ` class Solution {\\n\\n     char[][] board;\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        this.board = board;\\n        \\n        return solveUsingOOPS();\\n    \\n    }\\n\\n    private boolean solveUsingOOPS(){\\n\\n        Set<SudokuPosition> set = new HashSet<>();\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int rowGrid = i/3;\\n                    int colGrid = j/3;\\n                    SudokuPosition pos = new SudokuPosition(board[i][j],i,j,rowGrid*3+colGrid);\\n\\n                    if(set.contains(pos)){\\n                        return false;\\n                    }else{\\n                        set.add(pos);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    private class SudokuPosition{\\n        char val;\\n        int row; \\n        int col;\\n        int grid;\\n\\n        public SudokuPosition(char val,int row,int col,int grid){\\n            this.val = val;\\n            this.row = row;\\n            this.col = col;\\n            this.grid = grid;\\n        }\\n\\n        @Override\\n    public boolean equals(Object other) {\\n        if (!(other instanceof SudokuPosition)) {\\n            return false;\\n        }\\n        SudokuPosition spos = (SudokuPosition)other;\\n        return (this.val == spos.val) &&\\n               ((this.row == spos.row) || (this.col == spos.col) || (this.grid == spos.grid)); \\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return 31 * (31 * row + col) + grid;\\n    }\\n    \\n    }\\n\\n    }`"
                    }
                ]
            },
            {
                "id": 1866863,
                "content": [
                    {
                        "username": "lethienluc2021",
                        "content": "why [[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] has result true"
                    },
                    {
                        "username": "NithinModiboyana",
                        "content": "[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"]\\n,[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"]\\n,[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"]\\n,[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"]\\n,[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"]\\n,[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\ncan someone explain why is this False? "
                    },
                    {
                        "username": "Skripko",
                        "content": "In my view, this task should be easy, not medium"
                    },
                    {
                        "username": "Janvigurjar",
                        "content": "def isValid(row,col,board,c):\\n            for i in range(len(board)):\\n                if board[row][i]==c  and i!=row:\\n                    return False\\n                if board[i][col]==c and i!=col:\\n                    return False\\n                if board[3*(row//3)+i//3][3*(col//3)+i%3]==c and i!= 3*(row//3)+i//3 :\\n                    return False\\n            return True\\n        \\ndef check(board):\\n    for i in range(len(board)):\\n        for j in range(len(board)):\\n            if board[i][j]!=\".\":\\n                if isValid(i,j,board,board[i][j])==False:\\n                    return False\\n    return True\\n\\n\\n\\ncan anyone help in this"
                    },
                    {
                        "username": "zaman_ishtiyaq",
                        "content": "is this board solvable?\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n"
                    },
                    {
                        "username": "Navfalbek",
                        "content": "I think there is a bug in testcase 350 which is:\\n[[\".\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"],\\n          [\"2\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"3\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"4\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"6\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"7\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"8\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"9\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]]\\n\\nWhen I submited the solution it only fails in this one. But when I run the same code on PyCharm the result was True (Valid) however, when I run in LeetCode\\'s codespace it gives False. I do not know why this is happening. Is there someone also faced with this problem?"
                    },
                    {
                        "username": "kanishkamehrotra",
                        "content": "why is this test case failing ,my solution is giving true for this but it seems that the answer is false ,no number is rows coloumns are repeating and not even in the blocks \\n[\\n[\".\",\".\",\"4\", \".\",\".\",\".\", \"6\",\"3\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\"5\",\".\",\".\", \".\",\".\",\".\", \".\",\"9\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\"6\",\".\", \".\",\".\",\".\"],\\n[\"4\",\".\",\"3\", \".\",\".\",\".\", \".\",\".\",\"1\"],\\n[\".\",\".\",\".\", \"7\",\".\",\".\", \".\",\".\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"]\\n]"
                    },
                    {
                        "username": "itsathakur30",
                        "content": "How output can be true?\\n\\n\\nboard =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n\\nOutput\\nfalse\\n\\n\\nExpected\\ntrue\\n\\n\\n\\n"
                    },
                    {
                        "username": "h4sh_19",
                        "content": "who else wrote the code to solve the sudoku and find the valid sudoku instead of just checking only filled spots? Only me ? \\uD83D\\uDE29"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Can someone help me find the bug here ?\\n\\nLooks like object.equals is not working as expected from the print statements , I am not sure where is the actual bug in the method. \\n\\nTest case 2 fails with this approach as the solution cannot detect that two 8\\'s are in the same grid even though they map to the same grid. \\n\\nFWIW I solved it through another approach but wanted to do it in a OOPS way.\\n\\n\\n   ` class Solution {\\n\\n     char[][] board;\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        this.board = board;\\n        \\n        return solveUsingOOPS();\\n    \\n    }\\n\\n    private boolean solveUsingOOPS(){\\n\\n        Set<SudokuPosition> set = new HashSet<>();\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int rowGrid = i/3;\\n                    int colGrid = j/3;\\n                    SudokuPosition pos = new SudokuPosition(board[i][j],i,j,rowGrid*3+colGrid);\\n\\n                    if(set.contains(pos)){\\n                        return false;\\n                    }else{\\n                        set.add(pos);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    private class SudokuPosition{\\n        char val;\\n        int row; \\n        int col;\\n        int grid;\\n\\n        public SudokuPosition(char val,int row,int col,int grid){\\n            this.val = val;\\n            this.row = row;\\n            this.col = col;\\n            this.grid = grid;\\n        }\\n\\n        @Override\\n    public boolean equals(Object other) {\\n        if (!(other instanceof SudokuPosition)) {\\n            return false;\\n        }\\n        SudokuPosition spos = (SudokuPosition)other;\\n        return (this.val == spos.val) &&\\n               ((this.row == spos.row) || (this.col == spos.col) || (this.grid == spos.grid)); \\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return 31 * (31 * row + col) + grid;\\n    }\\n    \\n    }\\n\\n    }`"
                    }
                ]
            },
            {
                "id": 1852501,
                "content": [
                    {
                        "username": "lethienluc2021",
                        "content": "why [[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] has result true"
                    },
                    {
                        "username": "NithinModiboyana",
                        "content": "[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"]\\n,[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"]\\n,[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"]\\n,[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"]\\n,[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"]\\n,[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\ncan someone explain why is this False? "
                    },
                    {
                        "username": "Skripko",
                        "content": "In my view, this task should be easy, not medium"
                    },
                    {
                        "username": "Janvigurjar",
                        "content": "def isValid(row,col,board,c):\\n            for i in range(len(board)):\\n                if board[row][i]==c  and i!=row:\\n                    return False\\n                if board[i][col]==c and i!=col:\\n                    return False\\n                if board[3*(row//3)+i//3][3*(col//3)+i%3]==c and i!= 3*(row//3)+i//3 :\\n                    return False\\n            return True\\n        \\ndef check(board):\\n    for i in range(len(board)):\\n        for j in range(len(board)):\\n            if board[i][j]!=\".\":\\n                if isValid(i,j,board,board[i][j])==False:\\n                    return False\\n    return True\\n\\n\\n\\ncan anyone help in this"
                    },
                    {
                        "username": "zaman_ishtiyaq",
                        "content": "is this board solvable?\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n"
                    },
                    {
                        "username": "Navfalbek",
                        "content": "I think there is a bug in testcase 350 which is:\\n[[\".\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"],\\n          [\"2\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"3\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"4\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"6\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"7\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"8\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"9\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]]\\n\\nWhen I submited the solution it only fails in this one. But when I run the same code on PyCharm the result was True (Valid) however, when I run in LeetCode\\'s codespace it gives False. I do not know why this is happening. Is there someone also faced with this problem?"
                    },
                    {
                        "username": "kanishkamehrotra",
                        "content": "why is this test case failing ,my solution is giving true for this but it seems that the answer is false ,no number is rows coloumns are repeating and not even in the blocks \\n[\\n[\".\",\".\",\"4\", \".\",\".\",\".\", \"6\",\"3\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\"5\",\".\",\".\", \".\",\".\",\".\", \".\",\"9\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\"6\",\".\", \".\",\".\",\".\"],\\n[\"4\",\".\",\"3\", \".\",\".\",\".\", \".\",\".\",\"1\"],\\n[\".\",\".\",\".\", \"7\",\".\",\".\", \".\",\".\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"]\\n]"
                    },
                    {
                        "username": "itsathakur30",
                        "content": "How output can be true?\\n\\n\\nboard =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n\\nOutput\\nfalse\\n\\n\\nExpected\\ntrue\\n\\n\\n\\n"
                    },
                    {
                        "username": "h4sh_19",
                        "content": "who else wrote the code to solve the sudoku and find the valid sudoku instead of just checking only filled spots? Only me ? \\uD83D\\uDE29"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Can someone help me find the bug here ?\\n\\nLooks like object.equals is not working as expected from the print statements , I am not sure where is the actual bug in the method. \\n\\nTest case 2 fails with this approach as the solution cannot detect that two 8\\'s are in the same grid even though they map to the same grid. \\n\\nFWIW I solved it through another approach but wanted to do it in a OOPS way.\\n\\n\\n   ` class Solution {\\n\\n     char[][] board;\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        this.board = board;\\n        \\n        return solveUsingOOPS();\\n    \\n    }\\n\\n    private boolean solveUsingOOPS(){\\n\\n        Set<SudokuPosition> set = new HashSet<>();\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int rowGrid = i/3;\\n                    int colGrid = j/3;\\n                    SudokuPosition pos = new SudokuPosition(board[i][j],i,j,rowGrid*3+colGrid);\\n\\n                    if(set.contains(pos)){\\n                        return false;\\n                    }else{\\n                        set.add(pos);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    private class SudokuPosition{\\n        char val;\\n        int row; \\n        int col;\\n        int grid;\\n\\n        public SudokuPosition(char val,int row,int col,int grid){\\n            this.val = val;\\n            this.row = row;\\n            this.col = col;\\n            this.grid = grid;\\n        }\\n\\n        @Override\\n    public boolean equals(Object other) {\\n        if (!(other instanceof SudokuPosition)) {\\n            return false;\\n        }\\n        SudokuPosition spos = (SudokuPosition)other;\\n        return (this.val == spos.val) &&\\n               ((this.row == spos.row) || (this.col == spos.col) || (this.grid == spos.grid)); \\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return 31 * (31 * row + col) + grid;\\n    }\\n    \\n    }\\n\\n    }`"
                    }
                ]
            },
            {
                "id": 1842159,
                "content": [
                    {
                        "username": "lethienluc2021",
                        "content": "why [[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] has result true"
                    },
                    {
                        "username": "NithinModiboyana",
                        "content": "[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"]\\n,[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"]\\n,[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"]\\n,[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"]\\n,[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"]\\n,[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\ncan someone explain why is this False? "
                    },
                    {
                        "username": "Skripko",
                        "content": "In my view, this task should be easy, not medium"
                    },
                    {
                        "username": "Janvigurjar",
                        "content": "def isValid(row,col,board,c):\\n            for i in range(len(board)):\\n                if board[row][i]==c  and i!=row:\\n                    return False\\n                if board[i][col]==c and i!=col:\\n                    return False\\n                if board[3*(row//3)+i//3][3*(col//3)+i%3]==c and i!= 3*(row//3)+i//3 :\\n                    return False\\n            return True\\n        \\ndef check(board):\\n    for i in range(len(board)):\\n        for j in range(len(board)):\\n            if board[i][j]!=\".\":\\n                if isValid(i,j,board,board[i][j])==False:\\n                    return False\\n    return True\\n\\n\\n\\ncan anyone help in this"
                    },
                    {
                        "username": "zaman_ishtiyaq",
                        "content": "is this board solvable?\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n"
                    },
                    {
                        "username": "Navfalbek",
                        "content": "I think there is a bug in testcase 350 which is:\\n[[\".\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"],\\n          [\"2\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"3\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"4\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"6\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"7\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"8\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"9\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]]\\n\\nWhen I submited the solution it only fails in this one. But when I run the same code on PyCharm the result was True (Valid) however, when I run in LeetCode\\'s codespace it gives False. I do not know why this is happening. Is there someone also faced with this problem?"
                    },
                    {
                        "username": "kanishkamehrotra",
                        "content": "why is this test case failing ,my solution is giving true for this but it seems that the answer is false ,no number is rows coloumns are repeating and not even in the blocks \\n[\\n[\".\",\".\",\"4\", \".\",\".\",\".\", \"6\",\"3\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\"5\",\".\",\".\", \".\",\".\",\".\", \".\",\"9\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\"6\",\".\", \".\",\".\",\".\"],\\n[\"4\",\".\",\"3\", \".\",\".\",\".\", \".\",\".\",\"1\"],\\n[\".\",\".\",\".\", \"7\",\".\",\".\", \".\",\".\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"]\\n]"
                    },
                    {
                        "username": "itsathakur30",
                        "content": "How output can be true?\\n\\n\\nboard =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n\\nOutput\\nfalse\\n\\n\\nExpected\\ntrue\\n\\n\\n\\n"
                    },
                    {
                        "username": "h4sh_19",
                        "content": "who else wrote the code to solve the sudoku and find the valid sudoku instead of just checking only filled spots? Only me ? \\uD83D\\uDE29"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Can someone help me find the bug here ?\\n\\nLooks like object.equals is not working as expected from the print statements , I am not sure where is the actual bug in the method. \\n\\nTest case 2 fails with this approach as the solution cannot detect that two 8\\'s are in the same grid even though they map to the same grid. \\n\\nFWIW I solved it through another approach but wanted to do it in a OOPS way.\\n\\n\\n   ` class Solution {\\n\\n     char[][] board;\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        this.board = board;\\n        \\n        return solveUsingOOPS();\\n    \\n    }\\n\\n    private boolean solveUsingOOPS(){\\n\\n        Set<SudokuPosition> set = new HashSet<>();\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int rowGrid = i/3;\\n                    int colGrid = j/3;\\n                    SudokuPosition pos = new SudokuPosition(board[i][j],i,j,rowGrid*3+colGrid);\\n\\n                    if(set.contains(pos)){\\n                        return false;\\n                    }else{\\n                        set.add(pos);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    private class SudokuPosition{\\n        char val;\\n        int row; \\n        int col;\\n        int grid;\\n\\n        public SudokuPosition(char val,int row,int col,int grid){\\n            this.val = val;\\n            this.row = row;\\n            this.col = col;\\n            this.grid = grid;\\n        }\\n\\n        @Override\\n    public boolean equals(Object other) {\\n        if (!(other instanceof SudokuPosition)) {\\n            return false;\\n        }\\n        SudokuPosition spos = (SudokuPosition)other;\\n        return (this.val == spos.val) &&\\n               ((this.row == spos.row) || (this.col == spos.col) || (this.grid == spos.grid)); \\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return 31 * (31 * row + col) + grid;\\n    }\\n    \\n    }\\n\\n    }`"
                    }
                ]
            },
            {
                "id": 1804528,
                "content": [
                    {
                        "username": "lethienluc2021",
                        "content": "why [[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] has result true"
                    },
                    {
                        "username": "NithinModiboyana",
                        "content": "[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"]\\n,[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"]\\n,[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"]\\n,[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"]\\n,[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"]\\n,[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\ncan someone explain why is this False? "
                    },
                    {
                        "username": "Skripko",
                        "content": "In my view, this task should be easy, not medium"
                    },
                    {
                        "username": "Janvigurjar",
                        "content": "def isValid(row,col,board,c):\\n            for i in range(len(board)):\\n                if board[row][i]==c  and i!=row:\\n                    return False\\n                if board[i][col]==c and i!=col:\\n                    return False\\n                if board[3*(row//3)+i//3][3*(col//3)+i%3]==c and i!= 3*(row//3)+i//3 :\\n                    return False\\n            return True\\n        \\ndef check(board):\\n    for i in range(len(board)):\\n        for j in range(len(board)):\\n            if board[i][j]!=\".\":\\n                if isValid(i,j,board,board[i][j])==False:\\n                    return False\\n    return True\\n\\n\\n\\ncan anyone help in this"
                    },
                    {
                        "username": "zaman_ishtiyaq",
                        "content": "is this board solvable?\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n"
                    },
                    {
                        "username": "Navfalbek",
                        "content": "I think there is a bug in testcase 350 which is:\\n[[\".\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"],\\n          [\"2\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"3\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"4\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"6\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"7\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"8\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"9\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]]\\n\\nWhen I submited the solution it only fails in this one. But when I run the same code on PyCharm the result was True (Valid) however, when I run in LeetCode\\'s codespace it gives False. I do not know why this is happening. Is there someone also faced with this problem?"
                    },
                    {
                        "username": "kanishkamehrotra",
                        "content": "why is this test case failing ,my solution is giving true for this but it seems that the answer is false ,no number is rows coloumns are repeating and not even in the blocks \\n[\\n[\".\",\".\",\"4\", \".\",\".\",\".\", \"6\",\"3\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\"5\",\".\",\".\", \".\",\".\",\".\", \".\",\"9\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\"6\",\".\", \".\",\".\",\".\"],\\n[\"4\",\".\",\"3\", \".\",\".\",\".\", \".\",\".\",\"1\"],\\n[\".\",\".\",\".\", \"7\",\".\",\".\", \".\",\".\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"]\\n]"
                    },
                    {
                        "username": "itsathakur30",
                        "content": "How output can be true?\\n\\n\\nboard =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n\\nOutput\\nfalse\\n\\n\\nExpected\\ntrue\\n\\n\\n\\n"
                    },
                    {
                        "username": "h4sh_19",
                        "content": "who else wrote the code to solve the sudoku and find the valid sudoku instead of just checking only filled spots? Only me ? \\uD83D\\uDE29"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Can someone help me find the bug here ?\\n\\nLooks like object.equals is not working as expected from the print statements , I am not sure where is the actual bug in the method. \\n\\nTest case 2 fails with this approach as the solution cannot detect that two 8\\'s are in the same grid even though they map to the same grid. \\n\\nFWIW I solved it through another approach but wanted to do it in a OOPS way.\\n\\n\\n   ` class Solution {\\n\\n     char[][] board;\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        this.board = board;\\n        \\n        return solveUsingOOPS();\\n    \\n    }\\n\\n    private boolean solveUsingOOPS(){\\n\\n        Set<SudokuPosition> set = new HashSet<>();\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int rowGrid = i/3;\\n                    int colGrid = j/3;\\n                    SudokuPosition pos = new SudokuPosition(board[i][j],i,j,rowGrid*3+colGrid);\\n\\n                    if(set.contains(pos)){\\n                        return false;\\n                    }else{\\n                        set.add(pos);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    private class SudokuPosition{\\n        char val;\\n        int row; \\n        int col;\\n        int grid;\\n\\n        public SudokuPosition(char val,int row,int col,int grid){\\n            this.val = val;\\n            this.row = row;\\n            this.col = col;\\n            this.grid = grid;\\n        }\\n\\n        @Override\\n    public boolean equals(Object other) {\\n        if (!(other instanceof SudokuPosition)) {\\n            return false;\\n        }\\n        SudokuPosition spos = (SudokuPosition)other;\\n        return (this.val == spos.val) &&\\n               ((this.row == spos.row) || (this.col == spos.col) || (this.grid == spos.grid)); \\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return 31 * (31 * row + col) + grid;\\n    }\\n    \\n    }\\n\\n    }`"
                    }
                ]
            },
            {
                "id": 1801860,
                "content": [
                    {
                        "username": "lethienluc2021",
                        "content": "why [[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] has result true"
                    },
                    {
                        "username": "NithinModiboyana",
                        "content": "[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"]\\n,[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"]\\n,[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"]\\n,[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"]\\n,[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"]\\n,[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\ncan someone explain why is this False? "
                    },
                    {
                        "username": "Skripko",
                        "content": "In my view, this task should be easy, not medium"
                    },
                    {
                        "username": "Janvigurjar",
                        "content": "def isValid(row,col,board,c):\\n            for i in range(len(board)):\\n                if board[row][i]==c  and i!=row:\\n                    return False\\n                if board[i][col]==c and i!=col:\\n                    return False\\n                if board[3*(row//3)+i//3][3*(col//3)+i%3]==c and i!= 3*(row//3)+i//3 :\\n                    return False\\n            return True\\n        \\ndef check(board):\\n    for i in range(len(board)):\\n        for j in range(len(board)):\\n            if board[i][j]!=\".\":\\n                if isValid(i,j,board,board[i][j])==False:\\n                    return False\\n    return True\\n\\n\\n\\ncan anyone help in this"
                    },
                    {
                        "username": "zaman_ishtiyaq",
                        "content": "is this board solvable?\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n"
                    },
                    {
                        "username": "Navfalbek",
                        "content": "I think there is a bug in testcase 350 which is:\\n[[\".\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"],\\n          [\"2\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"3\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"4\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"6\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"7\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"8\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"9\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]]\\n\\nWhen I submited the solution it only fails in this one. But when I run the same code on PyCharm the result was True (Valid) however, when I run in LeetCode\\'s codespace it gives False. I do not know why this is happening. Is there someone also faced with this problem?"
                    },
                    {
                        "username": "kanishkamehrotra",
                        "content": "why is this test case failing ,my solution is giving true for this but it seems that the answer is false ,no number is rows coloumns are repeating and not even in the blocks \\n[\\n[\".\",\".\",\"4\", \".\",\".\",\".\", \"6\",\"3\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\"5\",\".\",\".\", \".\",\".\",\".\", \".\",\"9\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\"6\",\".\", \".\",\".\",\".\"],\\n[\"4\",\".\",\"3\", \".\",\".\",\".\", \".\",\".\",\"1\"],\\n[\".\",\".\",\".\", \"7\",\".\",\".\", \".\",\".\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"]\\n]"
                    },
                    {
                        "username": "itsathakur30",
                        "content": "How output can be true?\\n\\n\\nboard =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n\\nOutput\\nfalse\\n\\n\\nExpected\\ntrue\\n\\n\\n\\n"
                    },
                    {
                        "username": "h4sh_19",
                        "content": "who else wrote the code to solve the sudoku and find the valid sudoku instead of just checking only filled spots? Only me ? \\uD83D\\uDE29"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Can someone help me find the bug here ?\\n\\nLooks like object.equals is not working as expected from the print statements , I am not sure where is the actual bug in the method. \\n\\nTest case 2 fails with this approach as the solution cannot detect that two 8\\'s are in the same grid even though they map to the same grid. \\n\\nFWIW I solved it through another approach but wanted to do it in a OOPS way.\\n\\n\\n   ` class Solution {\\n\\n     char[][] board;\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        this.board = board;\\n        \\n        return solveUsingOOPS();\\n    \\n    }\\n\\n    private boolean solveUsingOOPS(){\\n\\n        Set<SudokuPosition> set = new HashSet<>();\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int rowGrid = i/3;\\n                    int colGrid = j/3;\\n                    SudokuPosition pos = new SudokuPosition(board[i][j],i,j,rowGrid*3+colGrid);\\n\\n                    if(set.contains(pos)){\\n                        return false;\\n                    }else{\\n                        set.add(pos);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    private class SudokuPosition{\\n        char val;\\n        int row; \\n        int col;\\n        int grid;\\n\\n        public SudokuPosition(char val,int row,int col,int grid){\\n            this.val = val;\\n            this.row = row;\\n            this.col = col;\\n            this.grid = grid;\\n        }\\n\\n        @Override\\n    public boolean equals(Object other) {\\n        if (!(other instanceof SudokuPosition)) {\\n            return false;\\n        }\\n        SudokuPosition spos = (SudokuPosition)other;\\n        return (this.val == spos.val) &&\\n               ((this.row == spos.row) || (this.col == spos.col) || (this.grid == spos.grid)); \\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return 31 * (31 * row + col) + grid;\\n    }\\n    \\n    }\\n\\n    }`"
                    }
                ]
            },
            {
                "id": 1793480,
                "content": [
                    {
                        "username": "lethienluc2021",
                        "content": "why [[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] has result true"
                    },
                    {
                        "username": "NithinModiboyana",
                        "content": "[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"]\\n,[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"]\\n,[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"]\\n,[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"]\\n,[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"]\\n,[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\ncan someone explain why is this False? "
                    },
                    {
                        "username": "Skripko",
                        "content": "In my view, this task should be easy, not medium"
                    },
                    {
                        "username": "Janvigurjar",
                        "content": "def isValid(row,col,board,c):\\n            for i in range(len(board)):\\n                if board[row][i]==c  and i!=row:\\n                    return False\\n                if board[i][col]==c and i!=col:\\n                    return False\\n                if board[3*(row//3)+i//3][3*(col//3)+i%3]==c and i!= 3*(row//3)+i//3 :\\n                    return False\\n            return True\\n        \\ndef check(board):\\n    for i in range(len(board)):\\n        for j in range(len(board)):\\n            if board[i][j]!=\".\":\\n                if isValid(i,j,board,board[i][j])==False:\\n                    return False\\n    return True\\n\\n\\n\\ncan anyone help in this"
                    },
                    {
                        "username": "zaman_ishtiyaq",
                        "content": "is this board solvable?\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n"
                    },
                    {
                        "username": "Navfalbek",
                        "content": "I think there is a bug in testcase 350 which is:\\n[[\".\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"],\\n          [\"2\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"3\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"4\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"6\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"7\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"8\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"9\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]]\\n\\nWhen I submited the solution it only fails in this one. But when I run the same code on PyCharm the result was True (Valid) however, when I run in LeetCode\\'s codespace it gives False. I do not know why this is happening. Is there someone also faced with this problem?"
                    },
                    {
                        "username": "kanishkamehrotra",
                        "content": "why is this test case failing ,my solution is giving true for this but it seems that the answer is false ,no number is rows coloumns are repeating and not even in the blocks \\n[\\n[\".\",\".\",\"4\", \".\",\".\",\".\", \"6\",\"3\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\"5\",\".\",\".\", \".\",\".\",\".\", \".\",\"9\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\"6\",\".\", \".\",\".\",\".\"],\\n[\"4\",\".\",\"3\", \".\",\".\",\".\", \".\",\".\",\"1\"],\\n[\".\",\".\",\".\", \"7\",\".\",\".\", \".\",\".\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"]\\n]"
                    },
                    {
                        "username": "itsathakur30",
                        "content": "How output can be true?\\n\\n\\nboard =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n\\nOutput\\nfalse\\n\\n\\nExpected\\ntrue\\n\\n\\n\\n"
                    },
                    {
                        "username": "h4sh_19",
                        "content": "who else wrote the code to solve the sudoku and find the valid sudoku instead of just checking only filled spots? Only me ? \\uD83D\\uDE29"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Can someone help me find the bug here ?\\n\\nLooks like object.equals is not working as expected from the print statements , I am not sure where is the actual bug in the method. \\n\\nTest case 2 fails with this approach as the solution cannot detect that two 8\\'s are in the same grid even though they map to the same grid. \\n\\nFWIW I solved it through another approach but wanted to do it in a OOPS way.\\n\\n\\n   ` class Solution {\\n\\n     char[][] board;\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        this.board = board;\\n        \\n        return solveUsingOOPS();\\n    \\n    }\\n\\n    private boolean solveUsingOOPS(){\\n\\n        Set<SudokuPosition> set = new HashSet<>();\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int rowGrid = i/3;\\n                    int colGrid = j/3;\\n                    SudokuPosition pos = new SudokuPosition(board[i][j],i,j,rowGrid*3+colGrid);\\n\\n                    if(set.contains(pos)){\\n                        return false;\\n                    }else{\\n                        set.add(pos);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    private class SudokuPosition{\\n        char val;\\n        int row; \\n        int col;\\n        int grid;\\n\\n        public SudokuPosition(char val,int row,int col,int grid){\\n            this.val = val;\\n            this.row = row;\\n            this.col = col;\\n            this.grid = grid;\\n        }\\n\\n        @Override\\n    public boolean equals(Object other) {\\n        if (!(other instanceof SudokuPosition)) {\\n            return false;\\n        }\\n        SudokuPosition spos = (SudokuPosition)other;\\n        return (this.val == spos.val) &&\\n               ((this.row == spos.row) || (this.col == spos.col) || (this.grid == spos.grid)); \\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return 31 * (31 * row + col) + grid;\\n    }\\n    \\n    }\\n\\n    }`"
                    }
                ]
            },
            {
                "id": 1793287,
                "content": [
                    {
                        "username": "lethienluc2021",
                        "content": "why [[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] has result true"
                    },
                    {
                        "username": "NithinModiboyana",
                        "content": "[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"]\\n,[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"]\\n,[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"]\\n,[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"]\\n,[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"]\\n,[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\ncan someone explain why is this False? "
                    },
                    {
                        "username": "Skripko",
                        "content": "In my view, this task should be easy, not medium"
                    },
                    {
                        "username": "Janvigurjar",
                        "content": "def isValid(row,col,board,c):\\n            for i in range(len(board)):\\n                if board[row][i]==c  and i!=row:\\n                    return False\\n                if board[i][col]==c and i!=col:\\n                    return False\\n                if board[3*(row//3)+i//3][3*(col//3)+i%3]==c and i!= 3*(row//3)+i//3 :\\n                    return False\\n            return True\\n        \\ndef check(board):\\n    for i in range(len(board)):\\n        for j in range(len(board)):\\n            if board[i][j]!=\".\":\\n                if isValid(i,j,board,board[i][j])==False:\\n                    return False\\n    return True\\n\\n\\n\\ncan anyone help in this"
                    },
                    {
                        "username": "zaman_ishtiyaq",
                        "content": "is this board solvable?\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n"
                    },
                    {
                        "username": "Navfalbek",
                        "content": "I think there is a bug in testcase 350 which is:\\n[[\".\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"],\\n          [\"2\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"3\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"4\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"6\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"7\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"8\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"9\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]]\\n\\nWhen I submited the solution it only fails in this one. But when I run the same code on PyCharm the result was True (Valid) however, when I run in LeetCode\\'s codespace it gives False. I do not know why this is happening. Is there someone also faced with this problem?"
                    },
                    {
                        "username": "kanishkamehrotra",
                        "content": "why is this test case failing ,my solution is giving true for this but it seems that the answer is false ,no number is rows coloumns are repeating and not even in the blocks \\n[\\n[\".\",\".\",\"4\", \".\",\".\",\".\", \"6\",\"3\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\"5\",\".\",\".\", \".\",\".\",\".\", \".\",\"9\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\"6\",\".\", \".\",\".\",\".\"],\\n[\"4\",\".\",\"3\", \".\",\".\",\".\", \".\",\".\",\"1\"],\\n[\".\",\".\",\".\", \"7\",\".\",\".\", \".\",\".\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"]\\n]"
                    },
                    {
                        "username": "itsathakur30",
                        "content": "How output can be true?\\n\\n\\nboard =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n\\nOutput\\nfalse\\n\\n\\nExpected\\ntrue\\n\\n\\n\\n"
                    },
                    {
                        "username": "h4sh_19",
                        "content": "who else wrote the code to solve the sudoku and find the valid sudoku instead of just checking only filled spots? Only me ? \\uD83D\\uDE29"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Can someone help me find the bug here ?\\n\\nLooks like object.equals is not working as expected from the print statements , I am not sure where is the actual bug in the method. \\n\\nTest case 2 fails with this approach as the solution cannot detect that two 8\\'s are in the same grid even though they map to the same grid. \\n\\nFWIW I solved it through another approach but wanted to do it in a OOPS way.\\n\\n\\n   ` class Solution {\\n\\n     char[][] board;\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        this.board = board;\\n        \\n        return solveUsingOOPS();\\n    \\n    }\\n\\n    private boolean solveUsingOOPS(){\\n\\n        Set<SudokuPosition> set = new HashSet<>();\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int rowGrid = i/3;\\n                    int colGrid = j/3;\\n                    SudokuPosition pos = new SudokuPosition(board[i][j],i,j,rowGrid*3+colGrid);\\n\\n                    if(set.contains(pos)){\\n                        return false;\\n                    }else{\\n                        set.add(pos);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    private class SudokuPosition{\\n        char val;\\n        int row; \\n        int col;\\n        int grid;\\n\\n        public SudokuPosition(char val,int row,int col,int grid){\\n            this.val = val;\\n            this.row = row;\\n            this.col = col;\\n            this.grid = grid;\\n        }\\n\\n        @Override\\n    public boolean equals(Object other) {\\n        if (!(other instanceof SudokuPosition)) {\\n            return false;\\n        }\\n        SudokuPosition spos = (SudokuPosition)other;\\n        return (this.val == spos.val) &&\\n               ((this.row == spos.row) || (this.col == spos.col) || (this.grid == spos.grid)); \\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return 31 * (31 * row + col) + grid;\\n    }\\n    \\n    }\\n\\n    }`"
                    }
                ]
            },
            {
                "id": 1792556,
                "content": [
                    {
                        "username": "lethienluc2021",
                        "content": "why [[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] has result true"
                    },
                    {
                        "username": "NithinModiboyana",
                        "content": "[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"]\\n,[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"]\\n,[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"]\\n,[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"]\\n,[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"]\\n,[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\ncan someone explain why is this False? "
                    },
                    {
                        "username": "Skripko",
                        "content": "In my view, this task should be easy, not medium"
                    },
                    {
                        "username": "Janvigurjar",
                        "content": "def isValid(row,col,board,c):\\n            for i in range(len(board)):\\n                if board[row][i]==c  and i!=row:\\n                    return False\\n                if board[i][col]==c and i!=col:\\n                    return False\\n                if board[3*(row//3)+i//3][3*(col//3)+i%3]==c and i!= 3*(row//3)+i//3 :\\n                    return False\\n            return True\\n        \\ndef check(board):\\n    for i in range(len(board)):\\n        for j in range(len(board)):\\n            if board[i][j]!=\".\":\\n                if isValid(i,j,board,board[i][j])==False:\\n                    return False\\n    return True\\n\\n\\n\\ncan anyone help in this"
                    },
                    {
                        "username": "zaman_ishtiyaq",
                        "content": "is this board solvable?\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n"
                    },
                    {
                        "username": "Navfalbek",
                        "content": "I think there is a bug in testcase 350 which is:\\n[[\".\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"],\\n          [\"2\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"3\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"4\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"6\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"7\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"8\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"9\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]]\\n\\nWhen I submited the solution it only fails in this one. But when I run the same code on PyCharm the result was True (Valid) however, when I run in LeetCode\\'s codespace it gives False. I do not know why this is happening. Is there someone also faced with this problem?"
                    },
                    {
                        "username": "kanishkamehrotra",
                        "content": "why is this test case failing ,my solution is giving true for this but it seems that the answer is false ,no number is rows coloumns are repeating and not even in the blocks \\n[\\n[\".\",\".\",\"4\", \".\",\".\",\".\", \"6\",\"3\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\"5\",\".\",\".\", \".\",\".\",\".\", \".\",\"9\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\"6\",\".\", \".\",\".\",\".\"],\\n[\"4\",\".\",\"3\", \".\",\".\",\".\", \".\",\".\",\"1\"],\\n[\".\",\".\",\".\", \"7\",\".\",\".\", \".\",\".\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"]\\n]"
                    },
                    {
                        "username": "itsathakur30",
                        "content": "How output can be true?\\n\\n\\nboard =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n\\nOutput\\nfalse\\n\\n\\nExpected\\ntrue\\n\\n\\n\\n"
                    },
                    {
                        "username": "h4sh_19",
                        "content": "who else wrote the code to solve the sudoku and find the valid sudoku instead of just checking only filled spots? Only me ? \\uD83D\\uDE29"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Can someone help me find the bug here ?\\n\\nLooks like object.equals is not working as expected from the print statements , I am not sure where is the actual bug in the method. \\n\\nTest case 2 fails with this approach as the solution cannot detect that two 8\\'s are in the same grid even though they map to the same grid. \\n\\nFWIW I solved it through another approach but wanted to do it in a OOPS way.\\n\\n\\n   ` class Solution {\\n\\n     char[][] board;\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        this.board = board;\\n        \\n        return solveUsingOOPS();\\n    \\n    }\\n\\n    private boolean solveUsingOOPS(){\\n\\n        Set<SudokuPosition> set = new HashSet<>();\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int rowGrid = i/3;\\n                    int colGrid = j/3;\\n                    SudokuPosition pos = new SudokuPosition(board[i][j],i,j,rowGrid*3+colGrid);\\n\\n                    if(set.contains(pos)){\\n                        return false;\\n                    }else{\\n                        set.add(pos);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    private class SudokuPosition{\\n        char val;\\n        int row; \\n        int col;\\n        int grid;\\n\\n        public SudokuPosition(char val,int row,int col,int grid){\\n            this.val = val;\\n            this.row = row;\\n            this.col = col;\\n            this.grid = grid;\\n        }\\n\\n        @Override\\n    public boolean equals(Object other) {\\n        if (!(other instanceof SudokuPosition)) {\\n            return false;\\n        }\\n        SudokuPosition spos = (SudokuPosition)other;\\n        return (this.val == spos.val) &&\\n               ((this.row == spos.row) || (this.col == spos.col) || (this.grid == spos.grid)); \\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return 31 * (31 * row + col) + grid;\\n    }\\n    \\n    }\\n\\n    }`"
                    }
                ]
            },
            {
                "id": 1768442,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why this code is passing only for 4 test cases ? for sudoku solver problem \\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n\\n}"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why im able to run this for only 4 test cases..\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row=board.length;\\n        int col=board[0].length;\\n        return solve(board,row,col);\\n    }\\n    public boolean solve(char[][] board,int row,int col){\\n        int i,j;\\n        char c;\\n         for(i=0;i<row;i++){\\n             for(j=0;j<col;j++){\\n                 if(board[i][j]==\\'.\\')\\n                 {\\n                     for(c=\\'1\\';c<=\\'9\\';c++){\\n                     if(valid(c,i,j,board)){\\n                        board[i][j]=c;\\n                        if(solve(board,row,col)==true)\\n                        return true;\\n                        else\\n                        board[i][j]=\\'.\\';\\n\\n                       }\\n                       \\n                    }\\n                    return false;\\n                 }\\n                 \\n             }\\n             \\n         }\\n       return true;\\n    }\\n  \\n\\n\\n\\nboolean valid(char c,int r,int cl,char board[][]){\\n    int i;\\n    for(i=0;i<9;i++){\\n            if(board[i][cl]==c)\\n            return false;\\n            if(board[r][i]==c)\\n            return false;\\n            if(board[3*(r/3)+i/3][3*(cl/3)+i%3]==c)\\n            return false;\\n        \\n    }\\n    return true;\\n}\\n} "
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "Algorithm for basic python solution\n\nSteps\n1. The first loop should check for the vertical and horizontal stretch simultaneaously to find a repeatition. Dictionary could be useful here\n\n2. The next should check for each 3 x 3 square for a repeatition.\n"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Found the difficulty on this problem to be in the \"2nd\" part so to speak, because each 3x3 box has to have unique numbers.\\nThe unique numbers part, not an issue, but the iterating through the box elements, and delimiting boxes. omg such a PITA, and really not much intuition needed.\\n\\nAs a hint:\\n(do not read if you don\\'t want hints)\\n\\nhint 1:\\non each level (0,1,2) iterate through each box set (0,1,2)\\nreset the i, j starts depending on the level and box set nr respectively.\\nTbh, this is pen & paper and you figuring out indexes.\\n\\nhint 2:\\nBonus for JS: much easier with sets than with maps\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "r0kkka",
                        "content": "are these not the same?\n\n```\n# if key in rows[i] or key in cols[j] or key in grids[(i // 3, j // 3)]:\n#     return False\n\nif key in [rows[i], cols[j], grids[(i // 3, j // 3)]]:\n    return False\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "I have to admit that the description is quite misleading and vague"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    }
                ]
            },
            {
                "id": 1767626,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why this code is passing only for 4 test cases ? for sudoku solver problem \\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n\\n}"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why im able to run this for only 4 test cases..\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row=board.length;\\n        int col=board[0].length;\\n        return solve(board,row,col);\\n    }\\n    public boolean solve(char[][] board,int row,int col){\\n        int i,j;\\n        char c;\\n         for(i=0;i<row;i++){\\n             for(j=0;j<col;j++){\\n                 if(board[i][j]==\\'.\\')\\n                 {\\n                     for(c=\\'1\\';c<=\\'9\\';c++){\\n                     if(valid(c,i,j,board)){\\n                        board[i][j]=c;\\n                        if(solve(board,row,col)==true)\\n                        return true;\\n                        else\\n                        board[i][j]=\\'.\\';\\n\\n                       }\\n                       \\n                    }\\n                    return false;\\n                 }\\n                 \\n             }\\n             \\n         }\\n       return true;\\n    }\\n  \\n\\n\\n\\nboolean valid(char c,int r,int cl,char board[][]){\\n    int i;\\n    for(i=0;i<9;i++){\\n            if(board[i][cl]==c)\\n            return false;\\n            if(board[r][i]==c)\\n            return false;\\n            if(board[3*(r/3)+i/3][3*(cl/3)+i%3]==c)\\n            return false;\\n        \\n    }\\n    return true;\\n}\\n} "
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "Algorithm for basic python solution\n\nSteps\n1. The first loop should check for the vertical and horizontal stretch simultaneaously to find a repeatition. Dictionary could be useful here\n\n2. The next should check for each 3 x 3 square for a repeatition.\n"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Found the difficulty on this problem to be in the \"2nd\" part so to speak, because each 3x3 box has to have unique numbers.\\nThe unique numbers part, not an issue, but the iterating through the box elements, and delimiting boxes. omg such a PITA, and really not much intuition needed.\\n\\nAs a hint:\\n(do not read if you don\\'t want hints)\\n\\nhint 1:\\non each level (0,1,2) iterate through each box set (0,1,2)\\nreset the i, j starts depending on the level and box set nr respectively.\\nTbh, this is pen & paper and you figuring out indexes.\\n\\nhint 2:\\nBonus for JS: much easier with sets than with maps\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "r0kkka",
                        "content": "are these not the same?\n\n```\n# if key in rows[i] or key in cols[j] or key in grids[(i // 3, j // 3)]:\n#     return False\n\nif key in [rows[i], cols[j], grids[(i // 3, j // 3)]]:\n    return False\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "I have to admit that the description is quite misleading and vague"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    }
                ]
            },
            {
                "id": 1766850,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why this code is passing only for 4 test cases ? for sudoku solver problem \\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n\\n}"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why im able to run this for only 4 test cases..\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row=board.length;\\n        int col=board[0].length;\\n        return solve(board,row,col);\\n    }\\n    public boolean solve(char[][] board,int row,int col){\\n        int i,j;\\n        char c;\\n         for(i=0;i<row;i++){\\n             for(j=0;j<col;j++){\\n                 if(board[i][j]==\\'.\\')\\n                 {\\n                     for(c=\\'1\\';c<=\\'9\\';c++){\\n                     if(valid(c,i,j,board)){\\n                        board[i][j]=c;\\n                        if(solve(board,row,col)==true)\\n                        return true;\\n                        else\\n                        board[i][j]=\\'.\\';\\n\\n                       }\\n                       \\n                    }\\n                    return false;\\n                 }\\n                 \\n             }\\n             \\n         }\\n       return true;\\n    }\\n  \\n\\n\\n\\nboolean valid(char c,int r,int cl,char board[][]){\\n    int i;\\n    for(i=0;i<9;i++){\\n            if(board[i][cl]==c)\\n            return false;\\n            if(board[r][i]==c)\\n            return false;\\n            if(board[3*(r/3)+i/3][3*(cl/3)+i%3]==c)\\n            return false;\\n        \\n    }\\n    return true;\\n}\\n} "
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "Algorithm for basic python solution\n\nSteps\n1. The first loop should check for the vertical and horizontal stretch simultaneaously to find a repeatition. Dictionary could be useful here\n\n2. The next should check for each 3 x 3 square for a repeatition.\n"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Found the difficulty on this problem to be in the \"2nd\" part so to speak, because each 3x3 box has to have unique numbers.\\nThe unique numbers part, not an issue, but the iterating through the box elements, and delimiting boxes. omg such a PITA, and really not much intuition needed.\\n\\nAs a hint:\\n(do not read if you don\\'t want hints)\\n\\nhint 1:\\non each level (0,1,2) iterate through each box set (0,1,2)\\nreset the i, j starts depending on the level and box set nr respectively.\\nTbh, this is pen & paper and you figuring out indexes.\\n\\nhint 2:\\nBonus for JS: much easier with sets than with maps\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "r0kkka",
                        "content": "are these not the same?\n\n```\n# if key in rows[i] or key in cols[j] or key in grids[(i // 3, j // 3)]:\n#     return False\n\nif key in [rows[i], cols[j], grids[(i // 3, j // 3)]]:\n    return False\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "I have to admit that the description is quite misleading and vague"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    }
                ]
            },
            {
                "id": 1762149,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why this code is passing only for 4 test cases ? for sudoku solver problem \\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n\\n}"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why im able to run this for only 4 test cases..\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row=board.length;\\n        int col=board[0].length;\\n        return solve(board,row,col);\\n    }\\n    public boolean solve(char[][] board,int row,int col){\\n        int i,j;\\n        char c;\\n         for(i=0;i<row;i++){\\n             for(j=0;j<col;j++){\\n                 if(board[i][j]==\\'.\\')\\n                 {\\n                     for(c=\\'1\\';c<=\\'9\\';c++){\\n                     if(valid(c,i,j,board)){\\n                        board[i][j]=c;\\n                        if(solve(board,row,col)==true)\\n                        return true;\\n                        else\\n                        board[i][j]=\\'.\\';\\n\\n                       }\\n                       \\n                    }\\n                    return false;\\n                 }\\n                 \\n             }\\n             \\n         }\\n       return true;\\n    }\\n  \\n\\n\\n\\nboolean valid(char c,int r,int cl,char board[][]){\\n    int i;\\n    for(i=0;i<9;i++){\\n            if(board[i][cl]==c)\\n            return false;\\n            if(board[r][i]==c)\\n            return false;\\n            if(board[3*(r/3)+i/3][3*(cl/3)+i%3]==c)\\n            return false;\\n        \\n    }\\n    return true;\\n}\\n} "
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "Algorithm for basic python solution\n\nSteps\n1. The first loop should check for the vertical and horizontal stretch simultaneaously to find a repeatition. Dictionary could be useful here\n\n2. The next should check for each 3 x 3 square for a repeatition.\n"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Found the difficulty on this problem to be in the \"2nd\" part so to speak, because each 3x3 box has to have unique numbers.\\nThe unique numbers part, not an issue, but the iterating through the box elements, and delimiting boxes. omg such a PITA, and really not much intuition needed.\\n\\nAs a hint:\\n(do not read if you don\\'t want hints)\\n\\nhint 1:\\non each level (0,1,2) iterate through each box set (0,1,2)\\nreset the i, j starts depending on the level and box set nr respectively.\\nTbh, this is pen & paper and you figuring out indexes.\\n\\nhint 2:\\nBonus for JS: much easier with sets than with maps\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "r0kkka",
                        "content": "are these not the same?\n\n```\n# if key in rows[i] or key in cols[j] or key in grids[(i // 3, j // 3)]:\n#     return False\n\nif key in [rows[i], cols[j], grids[(i // 3, j // 3)]]:\n    return False\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "I have to admit that the description is quite misleading and vague"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    }
                ]
            },
            {
                "id": 1757021,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why this code is passing only for 4 test cases ? for sudoku solver problem \\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n\\n}"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why im able to run this for only 4 test cases..\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row=board.length;\\n        int col=board[0].length;\\n        return solve(board,row,col);\\n    }\\n    public boolean solve(char[][] board,int row,int col){\\n        int i,j;\\n        char c;\\n         for(i=0;i<row;i++){\\n             for(j=0;j<col;j++){\\n                 if(board[i][j]==\\'.\\')\\n                 {\\n                     for(c=\\'1\\';c<=\\'9\\';c++){\\n                     if(valid(c,i,j,board)){\\n                        board[i][j]=c;\\n                        if(solve(board,row,col)==true)\\n                        return true;\\n                        else\\n                        board[i][j]=\\'.\\';\\n\\n                       }\\n                       \\n                    }\\n                    return false;\\n                 }\\n                 \\n             }\\n             \\n         }\\n       return true;\\n    }\\n  \\n\\n\\n\\nboolean valid(char c,int r,int cl,char board[][]){\\n    int i;\\n    for(i=0;i<9;i++){\\n            if(board[i][cl]==c)\\n            return false;\\n            if(board[r][i]==c)\\n            return false;\\n            if(board[3*(r/3)+i/3][3*(cl/3)+i%3]==c)\\n            return false;\\n        \\n    }\\n    return true;\\n}\\n} "
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "Algorithm for basic python solution\n\nSteps\n1. The first loop should check for the vertical and horizontal stretch simultaneaously to find a repeatition. Dictionary could be useful here\n\n2. The next should check for each 3 x 3 square for a repeatition.\n"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Found the difficulty on this problem to be in the \"2nd\" part so to speak, because each 3x3 box has to have unique numbers.\\nThe unique numbers part, not an issue, but the iterating through the box elements, and delimiting boxes. omg such a PITA, and really not much intuition needed.\\n\\nAs a hint:\\n(do not read if you don\\'t want hints)\\n\\nhint 1:\\non each level (0,1,2) iterate through each box set (0,1,2)\\nreset the i, j starts depending on the level and box set nr respectively.\\nTbh, this is pen & paper and you figuring out indexes.\\n\\nhint 2:\\nBonus for JS: much easier with sets than with maps\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "r0kkka",
                        "content": "are these not the same?\n\n```\n# if key in rows[i] or key in cols[j] or key in grids[(i // 3, j // 3)]:\n#     return False\n\nif key in [rows[i], cols[j], grids[(i // 3, j // 3)]]:\n    return False\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "I have to admit that the description is quite misleading and vague"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    }
                ]
            },
            {
                "id": 1753314,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why this code is passing only for 4 test cases ? for sudoku solver problem \\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n\\n}"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why im able to run this for only 4 test cases..\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row=board.length;\\n        int col=board[0].length;\\n        return solve(board,row,col);\\n    }\\n    public boolean solve(char[][] board,int row,int col){\\n        int i,j;\\n        char c;\\n         for(i=0;i<row;i++){\\n             for(j=0;j<col;j++){\\n                 if(board[i][j]==\\'.\\')\\n                 {\\n                     for(c=\\'1\\';c<=\\'9\\';c++){\\n                     if(valid(c,i,j,board)){\\n                        board[i][j]=c;\\n                        if(solve(board,row,col)==true)\\n                        return true;\\n                        else\\n                        board[i][j]=\\'.\\';\\n\\n                       }\\n                       \\n                    }\\n                    return false;\\n                 }\\n                 \\n             }\\n             \\n         }\\n       return true;\\n    }\\n  \\n\\n\\n\\nboolean valid(char c,int r,int cl,char board[][]){\\n    int i;\\n    for(i=0;i<9;i++){\\n            if(board[i][cl]==c)\\n            return false;\\n            if(board[r][i]==c)\\n            return false;\\n            if(board[3*(r/3)+i/3][3*(cl/3)+i%3]==c)\\n            return false;\\n        \\n    }\\n    return true;\\n}\\n} "
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "Algorithm for basic python solution\n\nSteps\n1. The first loop should check for the vertical and horizontal stretch simultaneaously to find a repeatition. Dictionary could be useful here\n\n2. The next should check for each 3 x 3 square for a repeatition.\n"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Found the difficulty on this problem to be in the \"2nd\" part so to speak, because each 3x3 box has to have unique numbers.\\nThe unique numbers part, not an issue, but the iterating through the box elements, and delimiting boxes. omg such a PITA, and really not much intuition needed.\\n\\nAs a hint:\\n(do not read if you don\\'t want hints)\\n\\nhint 1:\\non each level (0,1,2) iterate through each box set (0,1,2)\\nreset the i, j starts depending on the level and box set nr respectively.\\nTbh, this is pen & paper and you figuring out indexes.\\n\\nhint 2:\\nBonus for JS: much easier with sets than with maps\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "r0kkka",
                        "content": "are these not the same?\n\n```\n# if key in rows[i] or key in cols[j] or key in grids[(i // 3, j // 3)]:\n#     return False\n\nif key in [rows[i], cols[j], grids[(i // 3, j // 3)]]:\n    return False\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "I have to admit that the description is quite misleading and vague"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    }
                ]
            },
            {
                "id": 1752608,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why this code is passing only for 4 test cases ? for sudoku solver problem \\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n\\n}"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why im able to run this for only 4 test cases..\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row=board.length;\\n        int col=board[0].length;\\n        return solve(board,row,col);\\n    }\\n    public boolean solve(char[][] board,int row,int col){\\n        int i,j;\\n        char c;\\n         for(i=0;i<row;i++){\\n             for(j=0;j<col;j++){\\n                 if(board[i][j]==\\'.\\')\\n                 {\\n                     for(c=\\'1\\';c<=\\'9\\';c++){\\n                     if(valid(c,i,j,board)){\\n                        board[i][j]=c;\\n                        if(solve(board,row,col)==true)\\n                        return true;\\n                        else\\n                        board[i][j]=\\'.\\';\\n\\n                       }\\n                       \\n                    }\\n                    return false;\\n                 }\\n                 \\n             }\\n             \\n         }\\n       return true;\\n    }\\n  \\n\\n\\n\\nboolean valid(char c,int r,int cl,char board[][]){\\n    int i;\\n    for(i=0;i<9;i++){\\n            if(board[i][cl]==c)\\n            return false;\\n            if(board[r][i]==c)\\n            return false;\\n            if(board[3*(r/3)+i/3][3*(cl/3)+i%3]==c)\\n            return false;\\n        \\n    }\\n    return true;\\n}\\n} "
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "Algorithm for basic python solution\n\nSteps\n1. The first loop should check for the vertical and horizontal stretch simultaneaously to find a repeatition. Dictionary could be useful here\n\n2. The next should check for each 3 x 3 square for a repeatition.\n"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Found the difficulty on this problem to be in the \"2nd\" part so to speak, because each 3x3 box has to have unique numbers.\\nThe unique numbers part, not an issue, but the iterating through the box elements, and delimiting boxes. omg such a PITA, and really not much intuition needed.\\n\\nAs a hint:\\n(do not read if you don\\'t want hints)\\n\\nhint 1:\\non each level (0,1,2) iterate through each box set (0,1,2)\\nreset the i, j starts depending on the level and box set nr respectively.\\nTbh, this is pen & paper and you figuring out indexes.\\n\\nhint 2:\\nBonus for JS: much easier with sets than with maps\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "r0kkka",
                        "content": "are these not the same?\n\n```\n# if key in rows[i] or key in cols[j] or key in grids[(i // 3, j // 3)]:\n#     return False\n\nif key in [rows[i], cols[j], grids[(i // 3, j // 3)]]:\n    return False\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "I have to admit that the description is quite misleading and vague"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    }
                ]
            },
            {
                "id": 1749110,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why this code is passing only for 4 test cases ? for sudoku solver problem \\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n\\n}"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why im able to run this for only 4 test cases..\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row=board.length;\\n        int col=board[0].length;\\n        return solve(board,row,col);\\n    }\\n    public boolean solve(char[][] board,int row,int col){\\n        int i,j;\\n        char c;\\n         for(i=0;i<row;i++){\\n             for(j=0;j<col;j++){\\n                 if(board[i][j]==\\'.\\')\\n                 {\\n                     for(c=\\'1\\';c<=\\'9\\';c++){\\n                     if(valid(c,i,j,board)){\\n                        board[i][j]=c;\\n                        if(solve(board,row,col)==true)\\n                        return true;\\n                        else\\n                        board[i][j]=\\'.\\';\\n\\n                       }\\n                       \\n                    }\\n                    return false;\\n                 }\\n                 \\n             }\\n             \\n         }\\n       return true;\\n    }\\n  \\n\\n\\n\\nboolean valid(char c,int r,int cl,char board[][]){\\n    int i;\\n    for(i=0;i<9;i++){\\n            if(board[i][cl]==c)\\n            return false;\\n            if(board[r][i]==c)\\n            return false;\\n            if(board[3*(r/3)+i/3][3*(cl/3)+i%3]==c)\\n            return false;\\n        \\n    }\\n    return true;\\n}\\n} "
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "Algorithm for basic python solution\n\nSteps\n1. The first loop should check for the vertical and horizontal stretch simultaneaously to find a repeatition. Dictionary could be useful here\n\n2. The next should check for each 3 x 3 square for a repeatition.\n"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Found the difficulty on this problem to be in the \"2nd\" part so to speak, because each 3x3 box has to have unique numbers.\\nThe unique numbers part, not an issue, but the iterating through the box elements, and delimiting boxes. omg such a PITA, and really not much intuition needed.\\n\\nAs a hint:\\n(do not read if you don\\'t want hints)\\n\\nhint 1:\\non each level (0,1,2) iterate through each box set (0,1,2)\\nreset the i, j starts depending on the level and box set nr respectively.\\nTbh, this is pen & paper and you figuring out indexes.\\n\\nhint 2:\\nBonus for JS: much easier with sets than with maps\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "r0kkka",
                        "content": "are these not the same?\n\n```\n# if key in rows[i] or key in cols[j] or key in grids[(i // 3, j // 3)]:\n#     return False\n\nif key in [rows[i], cols[j], grids[(i // 3, j // 3)]]:\n    return False\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "I have to admit that the description is quite misleading and vague"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    }
                ]
            },
            {
                "id": 1737683,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why this code is passing only for 4 test cases ? for sudoku solver problem \\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n\\n}"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why im able to run this for only 4 test cases..\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row=board.length;\\n        int col=board[0].length;\\n        return solve(board,row,col);\\n    }\\n    public boolean solve(char[][] board,int row,int col){\\n        int i,j;\\n        char c;\\n         for(i=0;i<row;i++){\\n             for(j=0;j<col;j++){\\n                 if(board[i][j]==\\'.\\')\\n                 {\\n                     for(c=\\'1\\';c<=\\'9\\';c++){\\n                     if(valid(c,i,j,board)){\\n                        board[i][j]=c;\\n                        if(solve(board,row,col)==true)\\n                        return true;\\n                        else\\n                        board[i][j]=\\'.\\';\\n\\n                       }\\n                       \\n                    }\\n                    return false;\\n                 }\\n                 \\n             }\\n             \\n         }\\n       return true;\\n    }\\n  \\n\\n\\n\\nboolean valid(char c,int r,int cl,char board[][]){\\n    int i;\\n    for(i=0;i<9;i++){\\n            if(board[i][cl]==c)\\n            return false;\\n            if(board[r][i]==c)\\n            return false;\\n            if(board[3*(r/3)+i/3][3*(cl/3)+i%3]==c)\\n            return false;\\n        \\n    }\\n    return true;\\n}\\n} "
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "Algorithm for basic python solution\n\nSteps\n1. The first loop should check for the vertical and horizontal stretch simultaneaously to find a repeatition. Dictionary could be useful here\n\n2. The next should check for each 3 x 3 square for a repeatition.\n"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Found the difficulty on this problem to be in the \"2nd\" part so to speak, because each 3x3 box has to have unique numbers.\\nThe unique numbers part, not an issue, but the iterating through the box elements, and delimiting boxes. omg such a PITA, and really not much intuition needed.\\n\\nAs a hint:\\n(do not read if you don\\'t want hints)\\n\\nhint 1:\\non each level (0,1,2) iterate through each box set (0,1,2)\\nreset the i, j starts depending on the level and box set nr respectively.\\nTbh, this is pen & paper and you figuring out indexes.\\n\\nhint 2:\\nBonus for JS: much easier with sets than with maps\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "r0kkka",
                        "content": "are these not the same?\n\n```\n# if key in rows[i] or key in cols[j] or key in grids[(i // 3, j // 3)]:\n#     return False\n\nif key in [rows[i], cols[j], grids[(i // 3, j // 3)]]:\n    return False\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "I have to admit that the description is quite misleading and vague"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    }
                ]
            },
            {
                "id": 1729151,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why this code is passing only for 4 test cases ? for sudoku solver problem \\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n\\n}"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why im able to run this for only 4 test cases..\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row=board.length;\\n        int col=board[0].length;\\n        return solve(board,row,col);\\n    }\\n    public boolean solve(char[][] board,int row,int col){\\n        int i,j;\\n        char c;\\n         for(i=0;i<row;i++){\\n             for(j=0;j<col;j++){\\n                 if(board[i][j]==\\'.\\')\\n                 {\\n                     for(c=\\'1\\';c<=\\'9\\';c++){\\n                     if(valid(c,i,j,board)){\\n                        board[i][j]=c;\\n                        if(solve(board,row,col)==true)\\n                        return true;\\n                        else\\n                        board[i][j]=\\'.\\';\\n\\n                       }\\n                       \\n                    }\\n                    return false;\\n                 }\\n                 \\n             }\\n             \\n         }\\n       return true;\\n    }\\n  \\n\\n\\n\\nboolean valid(char c,int r,int cl,char board[][]){\\n    int i;\\n    for(i=0;i<9;i++){\\n            if(board[i][cl]==c)\\n            return false;\\n            if(board[r][i]==c)\\n            return false;\\n            if(board[3*(r/3)+i/3][3*(cl/3)+i%3]==c)\\n            return false;\\n        \\n    }\\n    return true;\\n}\\n} "
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "Algorithm for basic python solution\n\nSteps\n1. The first loop should check for the vertical and horizontal stretch simultaneaously to find a repeatition. Dictionary could be useful here\n\n2. The next should check for each 3 x 3 square for a repeatition.\n"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Found the difficulty on this problem to be in the \"2nd\" part so to speak, because each 3x3 box has to have unique numbers.\\nThe unique numbers part, not an issue, but the iterating through the box elements, and delimiting boxes. omg such a PITA, and really not much intuition needed.\\n\\nAs a hint:\\n(do not read if you don\\'t want hints)\\n\\nhint 1:\\non each level (0,1,2) iterate through each box set (0,1,2)\\nreset the i, j starts depending on the level and box set nr respectively.\\nTbh, this is pen & paper and you figuring out indexes.\\n\\nhint 2:\\nBonus for JS: much easier with sets than with maps\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "r0kkka",
                        "content": "are these not the same?\n\n```\n# if key in rows[i] or key in cols[j] or key in grids[(i // 3, j // 3)]:\n#     return False\n\nif key in [rows[i], cols[j], grids[(i // 3, j // 3)]]:\n    return False\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "I have to admit that the description is quite misleading and vague"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    }
                ]
            },
            {
                "id": 1728953,
                "content": [
                    {
                        "username": "singhsupriya711",
                        "content": "344/507 testcases passed can anyone tell me y?\\n\\nclass Solution {\\npublic:\\nbool isvalid(vector<vector<char>>& board,int row,int col){\\n    for(int i=0;i<9;i++){\\n        if(board[row][i]==board[row][col]){\\n            return false;\\n        }\\n        if(board[i][col]==board[row][col]){\\n            return false;\\n        }\\n        if(board[3*(row/3)+i/3][3*(col/3)+i%3]==board[row][col]){\\n            return false;\\n        }\\n        \\n    }\\n\\n    return true;\\n}\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bool t=false;\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\'){\\n                    if(isvalid(board,i,j)){\\n                        t=true;\\n                    }else t=false;\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n};"
                    },
                    {
                        "username": "AverageDPenjoyer",
                        "content": " `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row[] = new int[9];\\n        int col[] = new int[9];\\n        int box [][] = new int[3][3];\\n        for(int i=0;i<9;i++){\\n            for(int j =0;j<9;j++){\\n                int ch = Character.getNumericValue(board[i][j]);\\n                \\n                if(ch!=(-1)){\\n                    System.out.println(ch);\\n                    if(row[i]==ch || col[i]==ch || box[i/3][j/3]==ch){\\n                        return false;\\n                    }\\n                    row[i]=ch;\\n                    col[j]=ch;\\n                    box[i/3][j/3]=ch;\\n                }\\n            }\\n        }\\n        return true;\\n\\n    }\\n}`\\nCan somebody explain what is wrong in my code "
                    },
                    {
                        "username": "qingcheng2014",
                        "content": "board =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n4 / 507 testcases passed\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nthis test case is wrong? omg????????\\nwhy  expected value is true??????"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\\nMy testcase is not getting passed, expected answer is false, it is showing true for me. Please help\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n=board.size();\\n        vector<unordered_map<char,int>> r(n);\\n          vector<unordered_map<char,int>>  col(n);\\n\\n        for (int i=0;i<board.size();i++)\\n        {  \\n            for (int j=0;j<board.size();j++)\\n            {   \\n                char c=board[i][j];\\n                if (c==\\'.\\')\\n                    continue;\\n                if (r[i][c]++ >0 ||col[j][c]++ >0 )\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "while calculating boxnum if I\\'m using (i) + (j/3) it\\'s giving me wrong ans but if I\\'m using  int boxnum = ((i/3)*3) + (j/3); it\\'s giving correct ans. Why is this?\\n\\n `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<String> hs = new HashSet<>();\\n\\n        for(int i=0; i<board.length; i++){\\n            for(int j=0; j<board[0].length; j++){\\n               if(board[i][j] != \\'.\\'){\\n                    String row = \"row\"+i+board[i][j];\\n                    String col = \"col\"+j+board[i][j];\\n                    int boxnum = ((i/3)*3) + (j/3);\\n                    String box = \"box\"+boxnum+board[i][j];\\n\\n                    if(hs.contains(row) || hs.contains(col) || hs.contains(box)) return false;\\n\\n                    hs.add(row);\\n                    hs.add(col);\\n                    hs.add(box);\\n\\n               }\\n\\n            }\\n        }\\n        return true;\\n    }\\n} `"
                    },
                    {
                        "username": "Udit_69",
                        "content": "class Solution {\\n    final int radix = 10;\\n    public boolean isSafe(char board[][],int row,int col,int digit){\\n        //column\\n        for(int i=0;i<=8;i++){\\n            if(board[i][col]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // row\\n        for(int j=0;j<=8;j++){\\n           if(board[row][j]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // grid\\n        int sr = (row/3)*3;\\n        int sc = (col/3)*3;\\n        for(int i=sr;i<sr+3;i++){\\n            for(int j=sc;j<sc+3;j++){\\n                if(board[i][j]==Character.forDigit(digit,radix))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean sudokoSol(char board[][],int row,int col){\\n        // base case\\n        if(row==9)\\n           return true;   \\n        // recursion work\\n        int nextRow = row , nextCol = col+1;\\n        if(nextCol==9){\\n            nextRow = row+1;\\n            nextCol=0;\\n        }\\n        if(board[row][col]!=\\'.\\'){\\n            return sudokoSol(board,nextRow,nextCol);\\n        }\\n        for(int digit=1;digit<=9;digit++){\\n           if(isSafe(board,row,col,digit)){\\n               char c= Character.forDigit(digit,radix);\\n               board[row][col] = c;\\n               if(sudokoSol(board,nextRow,nextCol)){\\n                   return true;\\n               }\\n               board[row][col]=\\'.\\';\\n           }\\n        }\\n        return false;\\n\\n    }\\n    public boolean isValidSudoku(char[][] board) {\\n        if(sudokoSol(board,0,0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\ncan anyone please explain why this code is passing 4 testcases only?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "https://leetcode.com/problems/valid-sudoku/discussion/comments/1694929\\nplease?"
                    },
                    {
                        "username": "Mitulagr",
                        "content": "Converting i (0-9) & j(0-9) to Mini-Square Indices : \\nRow Index = j/3 + 3*(i/3)\\nCol Index = j%3 + 3*(i%3)"
                    },
                    {
                        "username": "zoomber",
                        "content": "There should be a third Testcase for testing sub 3x3 boxes. "
                    },
                    {
                        "username": "anshuman_raina",
                        "content": "To those of us who are getting false in this case :\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWe also have to remember that the mini squares too must not have a repetition. i.e. square with diagonal a[0][0]-a[2]][2]"
                    },
                    {
                        "username": "sparklingness",
                        "content": "There\\'s duplicated 1\\'s at a[0][7] and a[2][8].\\nThey are in the same square."
                    }
                ]
            },
            {
                "id": 1728092,
                "content": [
                    {
                        "username": "singhsupriya711",
                        "content": "344/507 testcases passed can anyone tell me y?\\n\\nclass Solution {\\npublic:\\nbool isvalid(vector<vector<char>>& board,int row,int col){\\n    for(int i=0;i<9;i++){\\n        if(board[row][i]==board[row][col]){\\n            return false;\\n        }\\n        if(board[i][col]==board[row][col]){\\n            return false;\\n        }\\n        if(board[3*(row/3)+i/3][3*(col/3)+i%3]==board[row][col]){\\n            return false;\\n        }\\n        \\n    }\\n\\n    return true;\\n}\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bool t=false;\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\'){\\n                    if(isvalid(board,i,j)){\\n                        t=true;\\n                    }else t=false;\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n};"
                    },
                    {
                        "username": "AverageDPenjoyer",
                        "content": " `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row[] = new int[9];\\n        int col[] = new int[9];\\n        int box [][] = new int[3][3];\\n        for(int i=0;i<9;i++){\\n            for(int j =0;j<9;j++){\\n                int ch = Character.getNumericValue(board[i][j]);\\n                \\n                if(ch!=(-1)){\\n                    System.out.println(ch);\\n                    if(row[i]==ch || col[i]==ch || box[i/3][j/3]==ch){\\n                        return false;\\n                    }\\n                    row[i]=ch;\\n                    col[j]=ch;\\n                    box[i/3][j/3]=ch;\\n                }\\n            }\\n        }\\n        return true;\\n\\n    }\\n}`\\nCan somebody explain what is wrong in my code "
                    },
                    {
                        "username": "qingcheng2014",
                        "content": "board =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n4 / 507 testcases passed\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nthis test case is wrong? omg????????\\nwhy  expected value is true??????"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\\nMy testcase is not getting passed, expected answer is false, it is showing true for me. Please help\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n=board.size();\\n        vector<unordered_map<char,int>> r(n);\\n          vector<unordered_map<char,int>>  col(n);\\n\\n        for (int i=0;i<board.size();i++)\\n        {  \\n            for (int j=0;j<board.size();j++)\\n            {   \\n                char c=board[i][j];\\n                if (c==\\'.\\')\\n                    continue;\\n                if (r[i][c]++ >0 ||col[j][c]++ >0 )\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "while calculating boxnum if I\\'m using (i) + (j/3) it\\'s giving me wrong ans but if I\\'m using  int boxnum = ((i/3)*3) + (j/3); it\\'s giving correct ans. Why is this?\\n\\n `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<String> hs = new HashSet<>();\\n\\n        for(int i=0; i<board.length; i++){\\n            for(int j=0; j<board[0].length; j++){\\n               if(board[i][j] != \\'.\\'){\\n                    String row = \"row\"+i+board[i][j];\\n                    String col = \"col\"+j+board[i][j];\\n                    int boxnum = ((i/3)*3) + (j/3);\\n                    String box = \"box\"+boxnum+board[i][j];\\n\\n                    if(hs.contains(row) || hs.contains(col) || hs.contains(box)) return false;\\n\\n                    hs.add(row);\\n                    hs.add(col);\\n                    hs.add(box);\\n\\n               }\\n\\n            }\\n        }\\n        return true;\\n    }\\n} `"
                    },
                    {
                        "username": "Udit_69",
                        "content": "class Solution {\\n    final int radix = 10;\\n    public boolean isSafe(char board[][],int row,int col,int digit){\\n        //column\\n        for(int i=0;i<=8;i++){\\n            if(board[i][col]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // row\\n        for(int j=0;j<=8;j++){\\n           if(board[row][j]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // grid\\n        int sr = (row/3)*3;\\n        int sc = (col/3)*3;\\n        for(int i=sr;i<sr+3;i++){\\n            for(int j=sc;j<sc+3;j++){\\n                if(board[i][j]==Character.forDigit(digit,radix))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean sudokoSol(char board[][],int row,int col){\\n        // base case\\n        if(row==9)\\n           return true;   \\n        // recursion work\\n        int nextRow = row , nextCol = col+1;\\n        if(nextCol==9){\\n            nextRow = row+1;\\n            nextCol=0;\\n        }\\n        if(board[row][col]!=\\'.\\'){\\n            return sudokoSol(board,nextRow,nextCol);\\n        }\\n        for(int digit=1;digit<=9;digit++){\\n           if(isSafe(board,row,col,digit)){\\n               char c= Character.forDigit(digit,radix);\\n               board[row][col] = c;\\n               if(sudokoSol(board,nextRow,nextCol)){\\n                   return true;\\n               }\\n               board[row][col]=\\'.\\';\\n           }\\n        }\\n        return false;\\n\\n    }\\n    public boolean isValidSudoku(char[][] board) {\\n        if(sudokoSol(board,0,0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\ncan anyone please explain why this code is passing 4 testcases only?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "https://leetcode.com/problems/valid-sudoku/discussion/comments/1694929\\nplease?"
                    },
                    {
                        "username": "Mitulagr",
                        "content": "Converting i (0-9) & j(0-9) to Mini-Square Indices : \\nRow Index = j/3 + 3*(i/3)\\nCol Index = j%3 + 3*(i%3)"
                    },
                    {
                        "username": "zoomber",
                        "content": "There should be a third Testcase for testing sub 3x3 boxes. "
                    },
                    {
                        "username": "anshuman_raina",
                        "content": "To those of us who are getting false in this case :\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWe also have to remember that the mini squares too must not have a repetition. i.e. square with diagonal a[0][0]-a[2]][2]"
                    },
                    {
                        "username": "sparklingness",
                        "content": "There\\'s duplicated 1\\'s at a[0][7] and a[2][8].\\nThey are in the same square."
                    }
                ]
            },
            {
                "id": 1726273,
                "content": [
                    {
                        "username": "singhsupriya711",
                        "content": "344/507 testcases passed can anyone tell me y?\\n\\nclass Solution {\\npublic:\\nbool isvalid(vector<vector<char>>& board,int row,int col){\\n    for(int i=0;i<9;i++){\\n        if(board[row][i]==board[row][col]){\\n            return false;\\n        }\\n        if(board[i][col]==board[row][col]){\\n            return false;\\n        }\\n        if(board[3*(row/3)+i/3][3*(col/3)+i%3]==board[row][col]){\\n            return false;\\n        }\\n        \\n    }\\n\\n    return true;\\n}\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bool t=false;\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\'){\\n                    if(isvalid(board,i,j)){\\n                        t=true;\\n                    }else t=false;\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n};"
                    },
                    {
                        "username": "AverageDPenjoyer",
                        "content": " `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row[] = new int[9];\\n        int col[] = new int[9];\\n        int box [][] = new int[3][3];\\n        for(int i=0;i<9;i++){\\n            for(int j =0;j<9;j++){\\n                int ch = Character.getNumericValue(board[i][j]);\\n                \\n                if(ch!=(-1)){\\n                    System.out.println(ch);\\n                    if(row[i]==ch || col[i]==ch || box[i/3][j/3]==ch){\\n                        return false;\\n                    }\\n                    row[i]=ch;\\n                    col[j]=ch;\\n                    box[i/3][j/3]=ch;\\n                }\\n            }\\n        }\\n        return true;\\n\\n    }\\n}`\\nCan somebody explain what is wrong in my code "
                    },
                    {
                        "username": "qingcheng2014",
                        "content": "board =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n4 / 507 testcases passed\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nthis test case is wrong? omg????????\\nwhy  expected value is true??????"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\\nMy testcase is not getting passed, expected answer is false, it is showing true for me. Please help\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n=board.size();\\n        vector<unordered_map<char,int>> r(n);\\n          vector<unordered_map<char,int>>  col(n);\\n\\n        for (int i=0;i<board.size();i++)\\n        {  \\n            for (int j=0;j<board.size();j++)\\n            {   \\n                char c=board[i][j];\\n                if (c==\\'.\\')\\n                    continue;\\n                if (r[i][c]++ >0 ||col[j][c]++ >0 )\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "while calculating boxnum if I\\'m using (i) + (j/3) it\\'s giving me wrong ans but if I\\'m using  int boxnum = ((i/3)*3) + (j/3); it\\'s giving correct ans. Why is this?\\n\\n `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<String> hs = new HashSet<>();\\n\\n        for(int i=0; i<board.length; i++){\\n            for(int j=0; j<board[0].length; j++){\\n               if(board[i][j] != \\'.\\'){\\n                    String row = \"row\"+i+board[i][j];\\n                    String col = \"col\"+j+board[i][j];\\n                    int boxnum = ((i/3)*3) + (j/3);\\n                    String box = \"box\"+boxnum+board[i][j];\\n\\n                    if(hs.contains(row) || hs.contains(col) || hs.contains(box)) return false;\\n\\n                    hs.add(row);\\n                    hs.add(col);\\n                    hs.add(box);\\n\\n               }\\n\\n            }\\n        }\\n        return true;\\n    }\\n} `"
                    },
                    {
                        "username": "Udit_69",
                        "content": "class Solution {\\n    final int radix = 10;\\n    public boolean isSafe(char board[][],int row,int col,int digit){\\n        //column\\n        for(int i=0;i<=8;i++){\\n            if(board[i][col]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // row\\n        for(int j=0;j<=8;j++){\\n           if(board[row][j]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // grid\\n        int sr = (row/3)*3;\\n        int sc = (col/3)*3;\\n        for(int i=sr;i<sr+3;i++){\\n            for(int j=sc;j<sc+3;j++){\\n                if(board[i][j]==Character.forDigit(digit,radix))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean sudokoSol(char board[][],int row,int col){\\n        // base case\\n        if(row==9)\\n           return true;   \\n        // recursion work\\n        int nextRow = row , nextCol = col+1;\\n        if(nextCol==9){\\n            nextRow = row+1;\\n            nextCol=0;\\n        }\\n        if(board[row][col]!=\\'.\\'){\\n            return sudokoSol(board,nextRow,nextCol);\\n        }\\n        for(int digit=1;digit<=9;digit++){\\n           if(isSafe(board,row,col,digit)){\\n               char c= Character.forDigit(digit,radix);\\n               board[row][col] = c;\\n               if(sudokoSol(board,nextRow,nextCol)){\\n                   return true;\\n               }\\n               board[row][col]=\\'.\\';\\n           }\\n        }\\n        return false;\\n\\n    }\\n    public boolean isValidSudoku(char[][] board) {\\n        if(sudokoSol(board,0,0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\ncan anyone please explain why this code is passing 4 testcases only?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "https://leetcode.com/problems/valid-sudoku/discussion/comments/1694929\\nplease?"
                    },
                    {
                        "username": "Mitulagr",
                        "content": "Converting i (0-9) & j(0-9) to Mini-Square Indices : \\nRow Index = j/3 + 3*(i/3)\\nCol Index = j%3 + 3*(i%3)"
                    },
                    {
                        "username": "zoomber",
                        "content": "There should be a third Testcase for testing sub 3x3 boxes. "
                    },
                    {
                        "username": "anshuman_raina",
                        "content": "To those of us who are getting false in this case :\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWe also have to remember that the mini squares too must not have a repetition. i.e. square with diagonal a[0][0]-a[2]][2]"
                    },
                    {
                        "username": "sparklingness",
                        "content": "There\\'s duplicated 1\\'s at a[0][7] and a[2][8].\\nThey are in the same square."
                    }
                ]
            },
            {
                "id": 1721325,
                "content": [
                    {
                        "username": "singhsupriya711",
                        "content": "344/507 testcases passed can anyone tell me y?\\n\\nclass Solution {\\npublic:\\nbool isvalid(vector<vector<char>>& board,int row,int col){\\n    for(int i=0;i<9;i++){\\n        if(board[row][i]==board[row][col]){\\n            return false;\\n        }\\n        if(board[i][col]==board[row][col]){\\n            return false;\\n        }\\n        if(board[3*(row/3)+i/3][3*(col/3)+i%3]==board[row][col]){\\n            return false;\\n        }\\n        \\n    }\\n\\n    return true;\\n}\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bool t=false;\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\'){\\n                    if(isvalid(board,i,j)){\\n                        t=true;\\n                    }else t=false;\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n};"
                    },
                    {
                        "username": "AverageDPenjoyer",
                        "content": " `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row[] = new int[9];\\n        int col[] = new int[9];\\n        int box [][] = new int[3][3];\\n        for(int i=0;i<9;i++){\\n            for(int j =0;j<9;j++){\\n                int ch = Character.getNumericValue(board[i][j]);\\n                \\n                if(ch!=(-1)){\\n                    System.out.println(ch);\\n                    if(row[i]==ch || col[i]==ch || box[i/3][j/3]==ch){\\n                        return false;\\n                    }\\n                    row[i]=ch;\\n                    col[j]=ch;\\n                    box[i/3][j/3]=ch;\\n                }\\n            }\\n        }\\n        return true;\\n\\n    }\\n}`\\nCan somebody explain what is wrong in my code "
                    },
                    {
                        "username": "qingcheng2014",
                        "content": "board =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n4 / 507 testcases passed\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nthis test case is wrong? omg????????\\nwhy  expected value is true??????"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\\nMy testcase is not getting passed, expected answer is false, it is showing true for me. Please help\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n=board.size();\\n        vector<unordered_map<char,int>> r(n);\\n          vector<unordered_map<char,int>>  col(n);\\n\\n        for (int i=0;i<board.size();i++)\\n        {  \\n            for (int j=0;j<board.size();j++)\\n            {   \\n                char c=board[i][j];\\n                if (c==\\'.\\')\\n                    continue;\\n                if (r[i][c]++ >0 ||col[j][c]++ >0 )\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "while calculating boxnum if I\\'m using (i) + (j/3) it\\'s giving me wrong ans but if I\\'m using  int boxnum = ((i/3)*3) + (j/3); it\\'s giving correct ans. Why is this?\\n\\n `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<String> hs = new HashSet<>();\\n\\n        for(int i=0; i<board.length; i++){\\n            for(int j=0; j<board[0].length; j++){\\n               if(board[i][j] != \\'.\\'){\\n                    String row = \"row\"+i+board[i][j];\\n                    String col = \"col\"+j+board[i][j];\\n                    int boxnum = ((i/3)*3) + (j/3);\\n                    String box = \"box\"+boxnum+board[i][j];\\n\\n                    if(hs.contains(row) || hs.contains(col) || hs.contains(box)) return false;\\n\\n                    hs.add(row);\\n                    hs.add(col);\\n                    hs.add(box);\\n\\n               }\\n\\n            }\\n        }\\n        return true;\\n    }\\n} `"
                    },
                    {
                        "username": "Udit_69",
                        "content": "class Solution {\\n    final int radix = 10;\\n    public boolean isSafe(char board[][],int row,int col,int digit){\\n        //column\\n        for(int i=0;i<=8;i++){\\n            if(board[i][col]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // row\\n        for(int j=0;j<=8;j++){\\n           if(board[row][j]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // grid\\n        int sr = (row/3)*3;\\n        int sc = (col/3)*3;\\n        for(int i=sr;i<sr+3;i++){\\n            for(int j=sc;j<sc+3;j++){\\n                if(board[i][j]==Character.forDigit(digit,radix))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean sudokoSol(char board[][],int row,int col){\\n        // base case\\n        if(row==9)\\n           return true;   \\n        // recursion work\\n        int nextRow = row , nextCol = col+1;\\n        if(nextCol==9){\\n            nextRow = row+1;\\n            nextCol=0;\\n        }\\n        if(board[row][col]!=\\'.\\'){\\n            return sudokoSol(board,nextRow,nextCol);\\n        }\\n        for(int digit=1;digit<=9;digit++){\\n           if(isSafe(board,row,col,digit)){\\n               char c= Character.forDigit(digit,radix);\\n               board[row][col] = c;\\n               if(sudokoSol(board,nextRow,nextCol)){\\n                   return true;\\n               }\\n               board[row][col]=\\'.\\';\\n           }\\n        }\\n        return false;\\n\\n    }\\n    public boolean isValidSudoku(char[][] board) {\\n        if(sudokoSol(board,0,0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\ncan anyone please explain why this code is passing 4 testcases only?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "https://leetcode.com/problems/valid-sudoku/discussion/comments/1694929\\nplease?"
                    },
                    {
                        "username": "Mitulagr",
                        "content": "Converting i (0-9) & j(0-9) to Mini-Square Indices : \\nRow Index = j/3 + 3*(i/3)\\nCol Index = j%3 + 3*(i%3)"
                    },
                    {
                        "username": "zoomber",
                        "content": "There should be a third Testcase for testing sub 3x3 boxes. "
                    },
                    {
                        "username": "anshuman_raina",
                        "content": "To those of us who are getting false in this case :\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWe also have to remember that the mini squares too must not have a repetition. i.e. square with diagonal a[0][0]-a[2]][2]"
                    },
                    {
                        "username": "sparklingness",
                        "content": "There\\'s duplicated 1\\'s at a[0][7] and a[2][8].\\nThey are in the same square."
                    }
                ]
            },
            {
                "id": 1720748,
                "content": [
                    {
                        "username": "singhsupriya711",
                        "content": "344/507 testcases passed can anyone tell me y?\\n\\nclass Solution {\\npublic:\\nbool isvalid(vector<vector<char>>& board,int row,int col){\\n    for(int i=0;i<9;i++){\\n        if(board[row][i]==board[row][col]){\\n            return false;\\n        }\\n        if(board[i][col]==board[row][col]){\\n            return false;\\n        }\\n        if(board[3*(row/3)+i/3][3*(col/3)+i%3]==board[row][col]){\\n            return false;\\n        }\\n        \\n    }\\n\\n    return true;\\n}\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bool t=false;\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\'){\\n                    if(isvalid(board,i,j)){\\n                        t=true;\\n                    }else t=false;\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n};"
                    },
                    {
                        "username": "AverageDPenjoyer",
                        "content": " `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row[] = new int[9];\\n        int col[] = new int[9];\\n        int box [][] = new int[3][3];\\n        for(int i=0;i<9;i++){\\n            for(int j =0;j<9;j++){\\n                int ch = Character.getNumericValue(board[i][j]);\\n                \\n                if(ch!=(-1)){\\n                    System.out.println(ch);\\n                    if(row[i]==ch || col[i]==ch || box[i/3][j/3]==ch){\\n                        return false;\\n                    }\\n                    row[i]=ch;\\n                    col[j]=ch;\\n                    box[i/3][j/3]=ch;\\n                }\\n            }\\n        }\\n        return true;\\n\\n    }\\n}`\\nCan somebody explain what is wrong in my code "
                    },
                    {
                        "username": "qingcheng2014",
                        "content": "board =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n4 / 507 testcases passed\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nthis test case is wrong? omg????????\\nwhy  expected value is true??????"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\\nMy testcase is not getting passed, expected answer is false, it is showing true for me. Please help\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n=board.size();\\n        vector<unordered_map<char,int>> r(n);\\n          vector<unordered_map<char,int>>  col(n);\\n\\n        for (int i=0;i<board.size();i++)\\n        {  \\n            for (int j=0;j<board.size();j++)\\n            {   \\n                char c=board[i][j];\\n                if (c==\\'.\\')\\n                    continue;\\n                if (r[i][c]++ >0 ||col[j][c]++ >0 )\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "while calculating boxnum if I\\'m using (i) + (j/3) it\\'s giving me wrong ans but if I\\'m using  int boxnum = ((i/3)*3) + (j/3); it\\'s giving correct ans. Why is this?\\n\\n `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<String> hs = new HashSet<>();\\n\\n        for(int i=0; i<board.length; i++){\\n            for(int j=0; j<board[0].length; j++){\\n               if(board[i][j] != \\'.\\'){\\n                    String row = \"row\"+i+board[i][j];\\n                    String col = \"col\"+j+board[i][j];\\n                    int boxnum = ((i/3)*3) + (j/3);\\n                    String box = \"box\"+boxnum+board[i][j];\\n\\n                    if(hs.contains(row) || hs.contains(col) || hs.contains(box)) return false;\\n\\n                    hs.add(row);\\n                    hs.add(col);\\n                    hs.add(box);\\n\\n               }\\n\\n            }\\n        }\\n        return true;\\n    }\\n} `"
                    },
                    {
                        "username": "Udit_69",
                        "content": "class Solution {\\n    final int radix = 10;\\n    public boolean isSafe(char board[][],int row,int col,int digit){\\n        //column\\n        for(int i=0;i<=8;i++){\\n            if(board[i][col]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // row\\n        for(int j=0;j<=8;j++){\\n           if(board[row][j]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // grid\\n        int sr = (row/3)*3;\\n        int sc = (col/3)*3;\\n        for(int i=sr;i<sr+3;i++){\\n            for(int j=sc;j<sc+3;j++){\\n                if(board[i][j]==Character.forDigit(digit,radix))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean sudokoSol(char board[][],int row,int col){\\n        // base case\\n        if(row==9)\\n           return true;   \\n        // recursion work\\n        int nextRow = row , nextCol = col+1;\\n        if(nextCol==9){\\n            nextRow = row+1;\\n            nextCol=0;\\n        }\\n        if(board[row][col]!=\\'.\\'){\\n            return sudokoSol(board,nextRow,nextCol);\\n        }\\n        for(int digit=1;digit<=9;digit++){\\n           if(isSafe(board,row,col,digit)){\\n               char c= Character.forDigit(digit,radix);\\n               board[row][col] = c;\\n               if(sudokoSol(board,nextRow,nextCol)){\\n                   return true;\\n               }\\n               board[row][col]=\\'.\\';\\n           }\\n        }\\n        return false;\\n\\n    }\\n    public boolean isValidSudoku(char[][] board) {\\n        if(sudokoSol(board,0,0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\ncan anyone please explain why this code is passing 4 testcases only?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "https://leetcode.com/problems/valid-sudoku/discussion/comments/1694929\\nplease?"
                    },
                    {
                        "username": "Mitulagr",
                        "content": "Converting i (0-9) & j(0-9) to Mini-Square Indices : \\nRow Index = j/3 + 3*(i/3)\\nCol Index = j%3 + 3*(i%3)"
                    },
                    {
                        "username": "zoomber",
                        "content": "There should be a third Testcase for testing sub 3x3 boxes. "
                    },
                    {
                        "username": "anshuman_raina",
                        "content": "To those of us who are getting false in this case :\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWe also have to remember that the mini squares too must not have a repetition. i.e. square with diagonal a[0][0]-a[2]][2]"
                    },
                    {
                        "username": "sparklingness",
                        "content": "There\\'s duplicated 1\\'s at a[0][7] and a[2][8].\\nThey are in the same square."
                    }
                ]
            },
            {
                "id": 1699178,
                "content": [
                    {
                        "username": "singhsupriya711",
                        "content": "344/507 testcases passed can anyone tell me y?\\n\\nclass Solution {\\npublic:\\nbool isvalid(vector<vector<char>>& board,int row,int col){\\n    for(int i=0;i<9;i++){\\n        if(board[row][i]==board[row][col]){\\n            return false;\\n        }\\n        if(board[i][col]==board[row][col]){\\n            return false;\\n        }\\n        if(board[3*(row/3)+i/3][3*(col/3)+i%3]==board[row][col]){\\n            return false;\\n        }\\n        \\n    }\\n\\n    return true;\\n}\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bool t=false;\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\'){\\n                    if(isvalid(board,i,j)){\\n                        t=true;\\n                    }else t=false;\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n};"
                    },
                    {
                        "username": "AverageDPenjoyer",
                        "content": " `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row[] = new int[9];\\n        int col[] = new int[9];\\n        int box [][] = new int[3][3];\\n        for(int i=0;i<9;i++){\\n            for(int j =0;j<9;j++){\\n                int ch = Character.getNumericValue(board[i][j]);\\n                \\n                if(ch!=(-1)){\\n                    System.out.println(ch);\\n                    if(row[i]==ch || col[i]==ch || box[i/3][j/3]==ch){\\n                        return false;\\n                    }\\n                    row[i]=ch;\\n                    col[j]=ch;\\n                    box[i/3][j/3]=ch;\\n                }\\n            }\\n        }\\n        return true;\\n\\n    }\\n}`\\nCan somebody explain what is wrong in my code "
                    },
                    {
                        "username": "qingcheng2014",
                        "content": "board =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n4 / 507 testcases passed\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nthis test case is wrong? omg????????\\nwhy  expected value is true??????"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\\nMy testcase is not getting passed, expected answer is false, it is showing true for me. Please help\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n=board.size();\\n        vector<unordered_map<char,int>> r(n);\\n          vector<unordered_map<char,int>>  col(n);\\n\\n        for (int i=0;i<board.size();i++)\\n        {  \\n            for (int j=0;j<board.size();j++)\\n            {   \\n                char c=board[i][j];\\n                if (c==\\'.\\')\\n                    continue;\\n                if (r[i][c]++ >0 ||col[j][c]++ >0 )\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "while calculating boxnum if I\\'m using (i) + (j/3) it\\'s giving me wrong ans but if I\\'m using  int boxnum = ((i/3)*3) + (j/3); it\\'s giving correct ans. Why is this?\\n\\n `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<String> hs = new HashSet<>();\\n\\n        for(int i=0; i<board.length; i++){\\n            for(int j=0; j<board[0].length; j++){\\n               if(board[i][j] != \\'.\\'){\\n                    String row = \"row\"+i+board[i][j];\\n                    String col = \"col\"+j+board[i][j];\\n                    int boxnum = ((i/3)*3) + (j/3);\\n                    String box = \"box\"+boxnum+board[i][j];\\n\\n                    if(hs.contains(row) || hs.contains(col) || hs.contains(box)) return false;\\n\\n                    hs.add(row);\\n                    hs.add(col);\\n                    hs.add(box);\\n\\n               }\\n\\n            }\\n        }\\n        return true;\\n    }\\n} `"
                    },
                    {
                        "username": "Udit_69",
                        "content": "class Solution {\\n    final int radix = 10;\\n    public boolean isSafe(char board[][],int row,int col,int digit){\\n        //column\\n        for(int i=0;i<=8;i++){\\n            if(board[i][col]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // row\\n        for(int j=0;j<=8;j++){\\n           if(board[row][j]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // grid\\n        int sr = (row/3)*3;\\n        int sc = (col/3)*3;\\n        for(int i=sr;i<sr+3;i++){\\n            for(int j=sc;j<sc+3;j++){\\n                if(board[i][j]==Character.forDigit(digit,radix))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean sudokoSol(char board[][],int row,int col){\\n        // base case\\n        if(row==9)\\n           return true;   \\n        // recursion work\\n        int nextRow = row , nextCol = col+1;\\n        if(nextCol==9){\\n            nextRow = row+1;\\n            nextCol=0;\\n        }\\n        if(board[row][col]!=\\'.\\'){\\n            return sudokoSol(board,nextRow,nextCol);\\n        }\\n        for(int digit=1;digit<=9;digit++){\\n           if(isSafe(board,row,col,digit)){\\n               char c= Character.forDigit(digit,radix);\\n               board[row][col] = c;\\n               if(sudokoSol(board,nextRow,nextCol)){\\n                   return true;\\n               }\\n               board[row][col]=\\'.\\';\\n           }\\n        }\\n        return false;\\n\\n    }\\n    public boolean isValidSudoku(char[][] board) {\\n        if(sudokoSol(board,0,0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\ncan anyone please explain why this code is passing 4 testcases only?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "https://leetcode.com/problems/valid-sudoku/discussion/comments/1694929\\nplease?"
                    },
                    {
                        "username": "Mitulagr",
                        "content": "Converting i (0-9) & j(0-9) to Mini-Square Indices : \\nRow Index = j/3 + 3*(i/3)\\nCol Index = j%3 + 3*(i%3)"
                    },
                    {
                        "username": "zoomber",
                        "content": "There should be a third Testcase for testing sub 3x3 boxes. "
                    },
                    {
                        "username": "anshuman_raina",
                        "content": "To those of us who are getting false in this case :\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWe also have to remember that the mini squares too must not have a repetition. i.e. square with diagonal a[0][0]-a[2]][2]"
                    },
                    {
                        "username": "sparklingness",
                        "content": "There\\'s duplicated 1\\'s at a[0][7] and a[2][8].\\nThey are in the same square."
                    }
                ]
            },
            {
                "id": 1695612,
                "content": [
                    {
                        "username": "singhsupriya711",
                        "content": "344/507 testcases passed can anyone tell me y?\\n\\nclass Solution {\\npublic:\\nbool isvalid(vector<vector<char>>& board,int row,int col){\\n    for(int i=0;i<9;i++){\\n        if(board[row][i]==board[row][col]){\\n            return false;\\n        }\\n        if(board[i][col]==board[row][col]){\\n            return false;\\n        }\\n        if(board[3*(row/3)+i/3][3*(col/3)+i%3]==board[row][col]){\\n            return false;\\n        }\\n        \\n    }\\n\\n    return true;\\n}\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bool t=false;\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\'){\\n                    if(isvalid(board,i,j)){\\n                        t=true;\\n                    }else t=false;\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n};"
                    },
                    {
                        "username": "AverageDPenjoyer",
                        "content": " `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row[] = new int[9];\\n        int col[] = new int[9];\\n        int box [][] = new int[3][3];\\n        for(int i=0;i<9;i++){\\n            for(int j =0;j<9;j++){\\n                int ch = Character.getNumericValue(board[i][j]);\\n                \\n                if(ch!=(-1)){\\n                    System.out.println(ch);\\n                    if(row[i]==ch || col[i]==ch || box[i/3][j/3]==ch){\\n                        return false;\\n                    }\\n                    row[i]=ch;\\n                    col[j]=ch;\\n                    box[i/3][j/3]=ch;\\n                }\\n            }\\n        }\\n        return true;\\n\\n    }\\n}`\\nCan somebody explain what is wrong in my code "
                    },
                    {
                        "username": "qingcheng2014",
                        "content": "board =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n4 / 507 testcases passed\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nthis test case is wrong? omg????????\\nwhy  expected value is true??????"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\\nMy testcase is not getting passed, expected answer is false, it is showing true for me. Please help\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n=board.size();\\n        vector<unordered_map<char,int>> r(n);\\n          vector<unordered_map<char,int>>  col(n);\\n\\n        for (int i=0;i<board.size();i++)\\n        {  \\n            for (int j=0;j<board.size();j++)\\n            {   \\n                char c=board[i][j];\\n                if (c==\\'.\\')\\n                    continue;\\n                if (r[i][c]++ >0 ||col[j][c]++ >0 )\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "while calculating boxnum if I\\'m using (i) + (j/3) it\\'s giving me wrong ans but if I\\'m using  int boxnum = ((i/3)*3) + (j/3); it\\'s giving correct ans. Why is this?\\n\\n `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<String> hs = new HashSet<>();\\n\\n        for(int i=0; i<board.length; i++){\\n            for(int j=0; j<board[0].length; j++){\\n               if(board[i][j] != \\'.\\'){\\n                    String row = \"row\"+i+board[i][j];\\n                    String col = \"col\"+j+board[i][j];\\n                    int boxnum = ((i/3)*3) + (j/3);\\n                    String box = \"box\"+boxnum+board[i][j];\\n\\n                    if(hs.contains(row) || hs.contains(col) || hs.contains(box)) return false;\\n\\n                    hs.add(row);\\n                    hs.add(col);\\n                    hs.add(box);\\n\\n               }\\n\\n            }\\n        }\\n        return true;\\n    }\\n} `"
                    },
                    {
                        "username": "Udit_69",
                        "content": "class Solution {\\n    final int radix = 10;\\n    public boolean isSafe(char board[][],int row,int col,int digit){\\n        //column\\n        for(int i=0;i<=8;i++){\\n            if(board[i][col]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // row\\n        for(int j=0;j<=8;j++){\\n           if(board[row][j]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // grid\\n        int sr = (row/3)*3;\\n        int sc = (col/3)*3;\\n        for(int i=sr;i<sr+3;i++){\\n            for(int j=sc;j<sc+3;j++){\\n                if(board[i][j]==Character.forDigit(digit,radix))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean sudokoSol(char board[][],int row,int col){\\n        // base case\\n        if(row==9)\\n           return true;   \\n        // recursion work\\n        int nextRow = row , nextCol = col+1;\\n        if(nextCol==9){\\n            nextRow = row+1;\\n            nextCol=0;\\n        }\\n        if(board[row][col]!=\\'.\\'){\\n            return sudokoSol(board,nextRow,nextCol);\\n        }\\n        for(int digit=1;digit<=9;digit++){\\n           if(isSafe(board,row,col,digit)){\\n               char c= Character.forDigit(digit,radix);\\n               board[row][col] = c;\\n               if(sudokoSol(board,nextRow,nextCol)){\\n                   return true;\\n               }\\n               board[row][col]=\\'.\\';\\n           }\\n        }\\n        return false;\\n\\n    }\\n    public boolean isValidSudoku(char[][] board) {\\n        if(sudokoSol(board,0,0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\ncan anyone please explain why this code is passing 4 testcases only?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "https://leetcode.com/problems/valid-sudoku/discussion/comments/1694929\\nplease?"
                    },
                    {
                        "username": "Mitulagr",
                        "content": "Converting i (0-9) & j(0-9) to Mini-Square Indices : \\nRow Index = j/3 + 3*(i/3)\\nCol Index = j%3 + 3*(i%3)"
                    },
                    {
                        "username": "zoomber",
                        "content": "There should be a third Testcase for testing sub 3x3 boxes. "
                    },
                    {
                        "username": "anshuman_raina",
                        "content": "To those of us who are getting false in this case :\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWe also have to remember that the mini squares too must not have a repetition. i.e. square with diagonal a[0][0]-a[2]][2]"
                    },
                    {
                        "username": "sparklingness",
                        "content": "There\\'s duplicated 1\\'s at a[0][7] and a[2][8].\\nThey are in the same square."
                    }
                ]
            },
            {
                "id": 1694022,
                "content": [
                    {
                        "username": "singhsupriya711",
                        "content": "344/507 testcases passed can anyone tell me y?\\n\\nclass Solution {\\npublic:\\nbool isvalid(vector<vector<char>>& board,int row,int col){\\n    for(int i=0;i<9;i++){\\n        if(board[row][i]==board[row][col]){\\n            return false;\\n        }\\n        if(board[i][col]==board[row][col]){\\n            return false;\\n        }\\n        if(board[3*(row/3)+i/3][3*(col/3)+i%3]==board[row][col]){\\n            return false;\\n        }\\n        \\n    }\\n\\n    return true;\\n}\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bool t=false;\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\'){\\n                    if(isvalid(board,i,j)){\\n                        t=true;\\n                    }else t=false;\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n};"
                    },
                    {
                        "username": "AverageDPenjoyer",
                        "content": " `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row[] = new int[9];\\n        int col[] = new int[9];\\n        int box [][] = new int[3][3];\\n        for(int i=0;i<9;i++){\\n            for(int j =0;j<9;j++){\\n                int ch = Character.getNumericValue(board[i][j]);\\n                \\n                if(ch!=(-1)){\\n                    System.out.println(ch);\\n                    if(row[i]==ch || col[i]==ch || box[i/3][j/3]==ch){\\n                        return false;\\n                    }\\n                    row[i]=ch;\\n                    col[j]=ch;\\n                    box[i/3][j/3]=ch;\\n                }\\n            }\\n        }\\n        return true;\\n\\n    }\\n}`\\nCan somebody explain what is wrong in my code "
                    },
                    {
                        "username": "qingcheng2014",
                        "content": "board =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n4 / 507 testcases passed\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nthis test case is wrong? omg????????\\nwhy  expected value is true??????"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\\nMy testcase is not getting passed, expected answer is false, it is showing true for me. Please help\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n=board.size();\\n        vector<unordered_map<char,int>> r(n);\\n          vector<unordered_map<char,int>>  col(n);\\n\\n        for (int i=0;i<board.size();i++)\\n        {  \\n            for (int j=0;j<board.size();j++)\\n            {   \\n                char c=board[i][j];\\n                if (c==\\'.\\')\\n                    continue;\\n                if (r[i][c]++ >0 ||col[j][c]++ >0 )\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "while calculating boxnum if I\\'m using (i) + (j/3) it\\'s giving me wrong ans but if I\\'m using  int boxnum = ((i/3)*3) + (j/3); it\\'s giving correct ans. Why is this?\\n\\n `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<String> hs = new HashSet<>();\\n\\n        for(int i=0; i<board.length; i++){\\n            for(int j=0; j<board[0].length; j++){\\n               if(board[i][j] != \\'.\\'){\\n                    String row = \"row\"+i+board[i][j];\\n                    String col = \"col\"+j+board[i][j];\\n                    int boxnum = ((i/3)*3) + (j/3);\\n                    String box = \"box\"+boxnum+board[i][j];\\n\\n                    if(hs.contains(row) || hs.contains(col) || hs.contains(box)) return false;\\n\\n                    hs.add(row);\\n                    hs.add(col);\\n                    hs.add(box);\\n\\n               }\\n\\n            }\\n        }\\n        return true;\\n    }\\n} `"
                    },
                    {
                        "username": "Udit_69",
                        "content": "class Solution {\\n    final int radix = 10;\\n    public boolean isSafe(char board[][],int row,int col,int digit){\\n        //column\\n        for(int i=0;i<=8;i++){\\n            if(board[i][col]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // row\\n        for(int j=0;j<=8;j++){\\n           if(board[row][j]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // grid\\n        int sr = (row/3)*3;\\n        int sc = (col/3)*3;\\n        for(int i=sr;i<sr+3;i++){\\n            for(int j=sc;j<sc+3;j++){\\n                if(board[i][j]==Character.forDigit(digit,radix))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean sudokoSol(char board[][],int row,int col){\\n        // base case\\n        if(row==9)\\n           return true;   \\n        // recursion work\\n        int nextRow = row , nextCol = col+1;\\n        if(nextCol==9){\\n            nextRow = row+1;\\n            nextCol=0;\\n        }\\n        if(board[row][col]!=\\'.\\'){\\n            return sudokoSol(board,nextRow,nextCol);\\n        }\\n        for(int digit=1;digit<=9;digit++){\\n           if(isSafe(board,row,col,digit)){\\n               char c= Character.forDigit(digit,radix);\\n               board[row][col] = c;\\n               if(sudokoSol(board,nextRow,nextCol)){\\n                   return true;\\n               }\\n               board[row][col]=\\'.\\';\\n           }\\n        }\\n        return false;\\n\\n    }\\n    public boolean isValidSudoku(char[][] board) {\\n        if(sudokoSol(board,0,0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\ncan anyone please explain why this code is passing 4 testcases only?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "https://leetcode.com/problems/valid-sudoku/discussion/comments/1694929\\nplease?"
                    },
                    {
                        "username": "Mitulagr",
                        "content": "Converting i (0-9) & j(0-9) to Mini-Square Indices : \\nRow Index = j/3 + 3*(i/3)\\nCol Index = j%3 + 3*(i%3)"
                    },
                    {
                        "username": "zoomber",
                        "content": "There should be a third Testcase for testing sub 3x3 boxes. "
                    },
                    {
                        "username": "anshuman_raina",
                        "content": "To those of us who are getting false in this case :\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWe also have to remember that the mini squares too must not have a repetition. i.e. square with diagonal a[0][0]-a[2]][2]"
                    },
                    {
                        "username": "sparklingness",
                        "content": "There\\'s duplicated 1\\'s at a[0][7] and a[2][8].\\nThey are in the same square."
                    }
                ]
            },
            {
                "id": 1693586,
                "content": [
                    {
                        "username": "singhsupriya711",
                        "content": "344/507 testcases passed can anyone tell me y?\\n\\nclass Solution {\\npublic:\\nbool isvalid(vector<vector<char>>& board,int row,int col){\\n    for(int i=0;i<9;i++){\\n        if(board[row][i]==board[row][col]){\\n            return false;\\n        }\\n        if(board[i][col]==board[row][col]){\\n            return false;\\n        }\\n        if(board[3*(row/3)+i/3][3*(col/3)+i%3]==board[row][col]){\\n            return false;\\n        }\\n        \\n    }\\n\\n    return true;\\n}\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bool t=false;\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\'){\\n                    if(isvalid(board,i,j)){\\n                        t=true;\\n                    }else t=false;\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n};"
                    },
                    {
                        "username": "AverageDPenjoyer",
                        "content": " `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row[] = new int[9];\\n        int col[] = new int[9];\\n        int box [][] = new int[3][3];\\n        for(int i=0;i<9;i++){\\n            for(int j =0;j<9;j++){\\n                int ch = Character.getNumericValue(board[i][j]);\\n                \\n                if(ch!=(-1)){\\n                    System.out.println(ch);\\n                    if(row[i]==ch || col[i]==ch || box[i/3][j/3]==ch){\\n                        return false;\\n                    }\\n                    row[i]=ch;\\n                    col[j]=ch;\\n                    box[i/3][j/3]=ch;\\n                }\\n            }\\n        }\\n        return true;\\n\\n    }\\n}`\\nCan somebody explain what is wrong in my code "
                    },
                    {
                        "username": "qingcheng2014",
                        "content": "board =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n4 / 507 testcases passed\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nthis test case is wrong? omg????????\\nwhy  expected value is true??????"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\\nMy testcase is not getting passed, expected answer is false, it is showing true for me. Please help\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n=board.size();\\n        vector<unordered_map<char,int>> r(n);\\n          vector<unordered_map<char,int>>  col(n);\\n\\n        for (int i=0;i<board.size();i++)\\n        {  \\n            for (int j=0;j<board.size();j++)\\n            {   \\n                char c=board[i][j];\\n                if (c==\\'.\\')\\n                    continue;\\n                if (r[i][c]++ >0 ||col[j][c]++ >0 )\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "while calculating boxnum if I\\'m using (i) + (j/3) it\\'s giving me wrong ans but if I\\'m using  int boxnum = ((i/3)*3) + (j/3); it\\'s giving correct ans. Why is this?\\n\\n `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<String> hs = new HashSet<>();\\n\\n        for(int i=0; i<board.length; i++){\\n            for(int j=0; j<board[0].length; j++){\\n               if(board[i][j] != \\'.\\'){\\n                    String row = \"row\"+i+board[i][j];\\n                    String col = \"col\"+j+board[i][j];\\n                    int boxnum = ((i/3)*3) + (j/3);\\n                    String box = \"box\"+boxnum+board[i][j];\\n\\n                    if(hs.contains(row) || hs.contains(col) || hs.contains(box)) return false;\\n\\n                    hs.add(row);\\n                    hs.add(col);\\n                    hs.add(box);\\n\\n               }\\n\\n            }\\n        }\\n        return true;\\n    }\\n} `"
                    },
                    {
                        "username": "Udit_69",
                        "content": "class Solution {\\n    final int radix = 10;\\n    public boolean isSafe(char board[][],int row,int col,int digit){\\n        //column\\n        for(int i=0;i<=8;i++){\\n            if(board[i][col]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // row\\n        for(int j=0;j<=8;j++){\\n           if(board[row][j]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // grid\\n        int sr = (row/3)*3;\\n        int sc = (col/3)*3;\\n        for(int i=sr;i<sr+3;i++){\\n            for(int j=sc;j<sc+3;j++){\\n                if(board[i][j]==Character.forDigit(digit,radix))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean sudokoSol(char board[][],int row,int col){\\n        // base case\\n        if(row==9)\\n           return true;   \\n        // recursion work\\n        int nextRow = row , nextCol = col+1;\\n        if(nextCol==9){\\n            nextRow = row+1;\\n            nextCol=0;\\n        }\\n        if(board[row][col]!=\\'.\\'){\\n            return sudokoSol(board,nextRow,nextCol);\\n        }\\n        for(int digit=1;digit<=9;digit++){\\n           if(isSafe(board,row,col,digit)){\\n               char c= Character.forDigit(digit,radix);\\n               board[row][col] = c;\\n               if(sudokoSol(board,nextRow,nextCol)){\\n                   return true;\\n               }\\n               board[row][col]=\\'.\\';\\n           }\\n        }\\n        return false;\\n\\n    }\\n    public boolean isValidSudoku(char[][] board) {\\n        if(sudokoSol(board,0,0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\ncan anyone please explain why this code is passing 4 testcases only?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "https://leetcode.com/problems/valid-sudoku/discussion/comments/1694929\\nplease?"
                    },
                    {
                        "username": "Mitulagr",
                        "content": "Converting i (0-9) & j(0-9) to Mini-Square Indices : \\nRow Index = j/3 + 3*(i/3)\\nCol Index = j%3 + 3*(i%3)"
                    },
                    {
                        "username": "zoomber",
                        "content": "There should be a third Testcase for testing sub 3x3 boxes. "
                    },
                    {
                        "username": "anshuman_raina",
                        "content": "To those of us who are getting false in this case :\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWe also have to remember that the mini squares too must not have a repetition. i.e. square with diagonal a[0][0]-a[2]][2]"
                    },
                    {
                        "username": "sparklingness",
                        "content": "There\\'s duplicated 1\\'s at a[0][7] and a[2][8].\\nThey are in the same square."
                    }
                ]
            },
            {
                "id": 1686551,
                "content": [
                    {
                        "username": "singhsupriya711",
                        "content": "344/507 testcases passed can anyone tell me y?\\n\\nclass Solution {\\npublic:\\nbool isvalid(vector<vector<char>>& board,int row,int col){\\n    for(int i=0;i<9;i++){\\n        if(board[row][i]==board[row][col]){\\n            return false;\\n        }\\n        if(board[i][col]==board[row][col]){\\n            return false;\\n        }\\n        if(board[3*(row/3)+i/3][3*(col/3)+i%3]==board[row][col]){\\n            return false;\\n        }\\n        \\n    }\\n\\n    return true;\\n}\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bool t=false;\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\'){\\n                    if(isvalid(board,i,j)){\\n                        t=true;\\n                    }else t=false;\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n};"
                    },
                    {
                        "username": "AverageDPenjoyer",
                        "content": " `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row[] = new int[9];\\n        int col[] = new int[9];\\n        int box [][] = new int[3][3];\\n        for(int i=0;i<9;i++){\\n            for(int j =0;j<9;j++){\\n                int ch = Character.getNumericValue(board[i][j]);\\n                \\n                if(ch!=(-1)){\\n                    System.out.println(ch);\\n                    if(row[i]==ch || col[i]==ch || box[i/3][j/3]==ch){\\n                        return false;\\n                    }\\n                    row[i]=ch;\\n                    col[j]=ch;\\n                    box[i/3][j/3]=ch;\\n                }\\n            }\\n        }\\n        return true;\\n\\n    }\\n}`\\nCan somebody explain what is wrong in my code "
                    },
                    {
                        "username": "qingcheng2014",
                        "content": "board =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n4 / 507 testcases passed\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nthis test case is wrong? omg????????\\nwhy  expected value is true??????"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\\nMy testcase is not getting passed, expected answer is false, it is showing true for me. Please help\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n=board.size();\\n        vector<unordered_map<char,int>> r(n);\\n          vector<unordered_map<char,int>>  col(n);\\n\\n        for (int i=0;i<board.size();i++)\\n        {  \\n            for (int j=0;j<board.size();j++)\\n            {   \\n                char c=board[i][j];\\n                if (c==\\'.\\')\\n                    continue;\\n                if (r[i][c]++ >0 ||col[j][c]++ >0 )\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "while calculating boxnum if I\\'m using (i) + (j/3) it\\'s giving me wrong ans but if I\\'m using  int boxnum = ((i/3)*3) + (j/3); it\\'s giving correct ans. Why is this?\\n\\n `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<String> hs = new HashSet<>();\\n\\n        for(int i=0; i<board.length; i++){\\n            for(int j=0; j<board[0].length; j++){\\n               if(board[i][j] != \\'.\\'){\\n                    String row = \"row\"+i+board[i][j];\\n                    String col = \"col\"+j+board[i][j];\\n                    int boxnum = ((i/3)*3) + (j/3);\\n                    String box = \"box\"+boxnum+board[i][j];\\n\\n                    if(hs.contains(row) || hs.contains(col) || hs.contains(box)) return false;\\n\\n                    hs.add(row);\\n                    hs.add(col);\\n                    hs.add(box);\\n\\n               }\\n\\n            }\\n        }\\n        return true;\\n    }\\n} `"
                    },
                    {
                        "username": "Udit_69",
                        "content": "class Solution {\\n    final int radix = 10;\\n    public boolean isSafe(char board[][],int row,int col,int digit){\\n        //column\\n        for(int i=0;i<=8;i++){\\n            if(board[i][col]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // row\\n        for(int j=0;j<=8;j++){\\n           if(board[row][j]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // grid\\n        int sr = (row/3)*3;\\n        int sc = (col/3)*3;\\n        for(int i=sr;i<sr+3;i++){\\n            for(int j=sc;j<sc+3;j++){\\n                if(board[i][j]==Character.forDigit(digit,radix))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean sudokoSol(char board[][],int row,int col){\\n        // base case\\n        if(row==9)\\n           return true;   \\n        // recursion work\\n        int nextRow = row , nextCol = col+1;\\n        if(nextCol==9){\\n            nextRow = row+1;\\n            nextCol=0;\\n        }\\n        if(board[row][col]!=\\'.\\'){\\n            return sudokoSol(board,nextRow,nextCol);\\n        }\\n        for(int digit=1;digit<=9;digit++){\\n           if(isSafe(board,row,col,digit)){\\n               char c= Character.forDigit(digit,radix);\\n               board[row][col] = c;\\n               if(sudokoSol(board,nextRow,nextCol)){\\n                   return true;\\n               }\\n               board[row][col]=\\'.\\';\\n           }\\n        }\\n        return false;\\n\\n    }\\n    public boolean isValidSudoku(char[][] board) {\\n        if(sudokoSol(board,0,0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\ncan anyone please explain why this code is passing 4 testcases only?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "https://leetcode.com/problems/valid-sudoku/discussion/comments/1694929\\nplease?"
                    },
                    {
                        "username": "Mitulagr",
                        "content": "Converting i (0-9) & j(0-9) to Mini-Square Indices : \\nRow Index = j/3 + 3*(i/3)\\nCol Index = j%3 + 3*(i%3)"
                    },
                    {
                        "username": "zoomber",
                        "content": "There should be a third Testcase for testing sub 3x3 boxes. "
                    },
                    {
                        "username": "anshuman_raina",
                        "content": "To those of us who are getting false in this case :\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWe also have to remember that the mini squares too must not have a repetition. i.e. square with diagonal a[0][0]-a[2]][2]"
                    },
                    {
                        "username": "sparklingness",
                        "content": "There\\'s duplicated 1\\'s at a[0][7] and a[2][8].\\nThey are in the same square."
                    }
                ]
            }
        ]
    },
    {
        "title": "Single Number",
        "question_content": "<p>Given a <strong>non-empty</strong>&nbsp;array of integers <code>nums</code>, every element appears <em>twice</em> except for one. Find that single one.</p>\n\n<p>You must&nbsp;implement a solution with a linear runtime complexity and use&nbsp;only constant&nbsp;extra space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [2,2,1]\n<strong>Output:</strong> 1\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [4,1,2,1,2]\n<strong>Output:</strong> 4\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> nums = [1]\n<strong>Output:</strong> 1\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-3 * 10<sup>4</sup> &lt;= nums[i] &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li>Each element in the array appears twice except for one element which appears only once.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1771720,
                "title": "c-easy-solutions-sorting-xor-maps-or-frequency-array",
                "content": "Hi , everybody . This question is quite easy. I am quite confident that most of you would have reached atleast 1 of the following approaches to solve this question. But , incase you missed any of them , do give this a read.\\n### EXPLANATION :\\n**The question simply asks us to find an element in the given array whose frequency is 1.All the other elements have a frequency=2. \\nWe have to do so in :**\\n* **Linear Time**\\n* **Using Constant Space**\\n\\n\\n\\n##### METHOD 1 : USING MAPS (NOT USING CONSTANT SPACE ) \\nThe question states that we have to find an element in the array with frequency=1. \\nSo , the first idea that pops in the mind is to store the frequency of each element in a map (or a frequency array) and then traverse that map/array and return the element with frequency=1. \\n\\n1. Map the given array\\'s elements to their frequency. ( KEY : ELEMENT , VALUE : FREQUENCY )\\n2. Traverse that map and return the key whose value =1. \\n\\n##### CODE : \\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       unordered_map<int,int> a;\\n\\t   for(auto x: nums)\\n\\t\\t   a[x]++;\\n\\t   for(auto z:a)\\n\\t\\t   if(z.second==1)\\n\\t\\t\\t   return z.first;\\n\\t   return -1;\\n    }\\n};\\n```\\n\\n**TC: O(N)**\\n**SC: O(N)**\\n\\n\\nNow , if we see the above method uses variable extra space, which is why it can\\'t be our answer. \\n(Although it is an approach to solve this problem). \\nThen how do we solve this ?? \\nImagine you have blocks with the array elements inscribed on them. Now , if I sort the array for you and now ask you to find the element , CAN YOU DO SO ?? \\n\\nYes , upon sorting , every element will have a similar element adjacent to it , if it has the frequency of 2.\\n\\n##### METHOD 2 : USING SORTING (USING CONSTANT SPACE ) \\nAs explained above , we do the following :\\n1. Sort the array. \\n2. Traverse the array and check if one of the adjacent elements is equal to the current element or not. \\n3. If yes , move ahead. Else return the current element. \\n\\n##### CODE : \\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       sort(nums.begin(),nums.end());\\n        for(int i=1;i<nums.size();i+=2)\\n        {\\n            if(nums[i]!=nums[i-1])\\n                return nums[i-1];\\n        }\\n        return nums[nums.size()-1];\\n    }\\n};\\n```\\n\\n**TC: O(NlogN)**\\n**SC: O(1)**\\n\\nThe above approach can be used to solve the problem . But what if we can improve the time complexity ??\\nWhat if we don\\'t have to sort the array ?? \\nThe following method deals with that approach. \\n##### METHOD 3 : USING BITWISE XOR OPERATOR (USING CONSTANT SPACE ) \\nTo use this approach you first need to understand about Bitwise XOR operator. \\nMost of us who have a background in physics ( highschool level ) , are aware of the LOGIC GATES. \\nOne of such gates is the XOR Gate : \\nAccording to this gate , the output is true , only if both the inputs are of opposite kind . \\nThat is , \\n\\t\\t\\t\\t\\t **A             B                   Y**\\n\\t\\t\\t\\t\\t **0             0                    0**\\n\\t\\t\\t\\t\\t **0             1                    1**\\n\\t\\t\\t\\t\\t **1             0                    1**\\n\\t\\t\\t\\t\\t **1             1                    0**\\n\\t\\t\\t\\t\\t \\nWe apply the extended version of this gate in our bitwise XOR operator. \\nIf we do \"a^b\" , it means that we are applying the XOR gate on the 2 numbers in a bitwise fashion ( on each of the corresponding bits of the numbers). \\nSimilarly , if we observe , \\n1.  ***A^A=0***\\n2.  ***A^B^A=B***\\n3.  ***(A^A^B) = (B^A^A) = (A^B^A) = B***  This shows that position doesn\\'t matter. \\n4.  Similarly , if we see , ***a^a^a......... (even times)=0 and a^a^a........(odd times)=a***\\n\\nGoogle It for more details. \\n\\nWe apply the above observations : \\n1. Traverse the array and take the Bitwise XOR of each element. \\n2. Return the value. \\n\\n**Why does this work ??**\\nBecause , the elements with frequency=2 will result in 0. And then the only element with frequency=1 will generate the answer. \\n\\t\\t\\t\\t\\t \\n##### CODE : \\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       int ans=0;\\n\\t   for(auto x:nums)\\n\\t   ans^=x;\\n\\t   return ans;\\n    }\\n};\\n```\\n\\n**TC: O(N)**\\n**SC: O(1)**\\n\\n\\n### PS : METHOD 4: SUM OF ELEMENTS \\nAll the unique elements , in the array have a frequency of 2 , except one element. \\n\\n1. Store all the unique elements in set. \\n2. Add the elements of the set and multiply by 2 (SUM_1). \\n3. Add all the elements of the array(ARRAY_SUM). \\n4. Return (SUM_1 - ARRAY_SUM) . \\n\\n**Why does this work ??**\\nARRAY_SUM = 2*(a1+a2+a3...+ak) + a(k+1)\\nSUM_1 = 2*(a1+a2+a3+....+ak+ a(k+1)) \\n\\n*a(x) represents the xth unique element in the array. \\na(k+1) represents the element with frequency=1.*\\n\\nHope you found this post useful . If so , then do upvote and comment below.\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       unordered_map<int,int> a;\\n\\t   for(auto x: nums)\\n\\t\\t   a[x]++;\\n\\t   for(auto z:a)\\n\\t\\t   if(z.second==1)\\n\\t\\t\\t   return z.first;\\n\\t   return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       sort(nums.begin(),nums.end());\\n        for(int i=1;i<nums.size();i+=2)\\n        {\\n            if(nums[i]!=nums[i-1])\\n                return nums[i-1];\\n        }\\n        return nums[nums.size()-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       int ans=0;\\n\\t   for(auto x:nums)\\n\\t   ans^=x;\\n\\t   return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1771771,
                "title": "think-it-through-time-o-n-space-o-1-python-explained",
                "content": "\\n### Edge Cases:\\n1. No element appears twice; it is a constraint so not possible\\n2. Single length array; return the only element already present in the array\\n3. len(nums) > 1; find the single element that does not appear twice\\n\\n### Approaches:\\n1. **Brute Force**\\nIntuition:\\nIterate through every element in the nums and check if any of the element does not appear twice, in that case return the element.\\n*Time: O(n^2)\\nSpace: O(1)*\\n\\n2. **Use Sorting**\\nIntuition:\\nIf the elements of the nums array are sorted/when we sort it, we can compare the neighbours to find the single element. It is already mentioned that all other elements appear twice except one.\\n*Time: O(nlogn) for sorting then O(n) to check neighbouring elements\\nSpace: O(1)*\\n\\n3. **Use Hashing/Set**\\nIntuition:\\ni) As we iterate through the nums array we store the elements encountered and check if we find them again while iteration continues. While checking if we find them again, we maintain a single_element object/variable which stores that single element, eventually returning the single_element.\\nii) The other way is to maintain a num_frequency hashmap/dictionary and iterate over it to find which has exactly 1 frequency and return that key/num.\\n*Time: O(n) for iterating over the nums array\\nSpace: O(n) for hashing*\\n\\n4. **Use Xor/Bit Manipulation**\\nIntuition:\\nXor of any two num gives the difference of bit as 1 and same bit as 0.\\nThus, using this we get 1 ^ 1 == 0 because the same numbers have same bits.\\nSo, we will always get the single element because all the same ones will evaluate to 0 and 0^single_number = single_number.\\n*Time: O(n)\\nSpace: O(1)*\\n\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        xor = 0\\n        for num in nums:\\n            xor ^= num\\n        \\n        return xor\\n\\n```\\n\\n**Updated**:\\n*You can find more of my solutions like this in discuss forums by searching through either **satyamsinha93** or **Think it through**.*\\n\\nThanks for all the love and upvoting!",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        xor = 0\\n        for num in nums:\\n            xor ^= num\\n        \\n        return xor\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772139,
                "title": "c-explained-everything-w-why-xor-works-brute-force-to-optimized-step-by-step-dry-run",
                "content": "***Brief note about Question-***\\n* We have to return the number which is *appears single time* in the array.\\n```\\nLet\\'s take an example not given in question -\\nSuppose our array is arr[]: [5, 1, 3, 1, 3, 4, 5, 7, 4]\\n\\nSo, our answer should be \\'7\\' as it appears only single time in the array. \\n```\\n_________________\\n***Solution - I (using unorderd map, Accepted)-***\\n* Since we are very obedient person and don\\'t want to do anything extra from our side.\\n* So, on seeing the question, the first idea that clicks to our mind is to ***store frequency*** of all over the elements.\\n* After storing frequency, we will simply ***find the element whose frequency is 1***.\\n* The element whose frequency is 1, that is our answer.\\n```\\nTime Complexity --> O(n) // where n is the size of the array\\nSpace Complexity --> O(n) // we will store the frequency of every element\\n\\nIt paases [ 61 / 61 ] in built test cases\\n```\\n***So, How we will implement that?***\\n* Whenever we heard the name *frequency*, we will call our one and only superhero i.e `unordered_map`.\\n* We will store frequency of each element in our unorderd map.\\n* After that, we **traverse from the map**, and for every element we check whether it\\'s **frequency is 1** or not.\\n* If it\\'s frequency is 1, then we will simply store the answer and break the loop.\\n* See, an example.\\n```\\nSuppose our array is arr[]: [5, 1, 3, 1, 3, 4, 5, 7, 4]\\nso, after storing frequency of each element in our map, our map looks like -\\n5 -> 2\\n1 -> 2\\n3 -> 2\\n4 -> 2\\n7 -> 1     On traversing, we will see that it\\'s frequency is 1, so this should be our answer.\\n```\\n**Code (C++)**\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& arr) {\\n        int n = arr.size(); // taking the size of the array \\n        \\n        unordered_map<int, int> mp; // unordered map to store the frequency\\n        \\n        // storing frequency in the map\\n        for(int i = 0; i < n; i++)\\n        {\\n            mp[arr[i]]++;\\n        }\\n        \\n        int ans; // variable to store our answer\\n        for(auto x: mp) // traverse from the map\\n        {\\n            if(x.second == 1) //if frequency of any elemennt is 1\\n            {\\n                ans = x.first; // store in our answer\\n                break; // break the loop, as we got our answer now\\n            }\\n        }\\n        \\n        return ans; // return ans\\n    }\\n};\\n```\\n____\\n***Solution - II (using property of xor, Accepted)-***\\n* Now, the question arises, is their any way so that we do not need to store frequency, i.e \\n**can we space optimized our answer**?\\n* Since, we want not to use map, so we will see our map that where is the problem?\\n* We observe a very basic thing that other than our answer, **frequency of each element is 2**, that means our question wants to say that, ***every element appears twice except the single one and we have to find that particular single element.***\\n* So, if every element appears twice, *do we really need to store the frequency of each element*?\\n* Answer is **No**, we do not need to store the frequency of each element because we already know that, for each element their is only two ways, **either it\\'s frequency is 1 or it\\'s frequency is 2**. Their is not any third option other than that.\\n* In this way, we can think of ***the property of XOR-***\\n```\\n0 ^ 0 --> 0\\n0 ^ 1 --> 1\\n1 ^ 0 --> 1\\n1 ^ 1 --> 0\\n```\\n* If we see, we will find out that ***xor of two same number is zero***.\\n* Can we use this property here?\\n* Answer is ***Yes***. But how? \\n* We will run a loop from all over the array, and simply start taking xor of two.\\n* We do xor between prev answer of xor and current element.\\n* See dry run for more clarification.\\n* But, Question is **WHY**? why this works?\\n```\\nWe know every number is appears twice except a single number which appears only single time.\\n\\nSee, we already discuss a thing a that xor of a same number with itself is zero, i.e A ^ A = 0\\nNow, we will look some more property of xor-\\n\\n1) xor of a same number with itself is zero, i.e A ^ A = 0\\n2) xor is commutative that means a ^ b = b ^ a.\\n3) xor of any number with zero is the number itself i.e A ^ 0 = A.\\n\\nSuppose our array is arr[]: [5, 1, 3, 1, 3, 4, 5, 7, 4]\\nwe will rearrange the array, and take all the numbers together, then our array looks like\\n                     arr[]: [1, 1, 3, 3, 4, 4, 5, 5, 7]\\n\\t\\t\\t\\t\\t now, take xor of all numbers -\\n\\t\\t\\t\\t\\t 1 ^ 1 ^ 3 ^ 3 ^ 4 ^ 4 ^ 5 ^ 5 ^ 7   (rearrange the array)\\n\\t\\t\\t\\t\\t   0   ^   0   ^   0   ^   0   ^ 7   (see point number 1)\\n\\t\\t\\t\\t\\t               7                     (see point number 3) \\n\\n```\\n* Now, The question again arises, **do we really need to rearrange the array ?**\\n* Answer is ***NO***.\\n* We already know a property of xor, that says we don\\'t need to rearrange the array. But wait, where?\\n* `xor is commutative that means a ^ b = b ^ a. (see above point number 2)`  \\n* Okay, if this is ? **Can you do this without rearaanging the array?**\\n* Answer is **Yes**, see below-\\n```\\nSo, our array is arr[]: [5, 1, 3, 1, 3, 4, 5, 7, 4] \\n\\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n \\u2191  \\u2191\\n 5 ^ 1 = 4\\n \\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n       \\u2191                       \\n\\t   4 ^ 3 = 7 (prev answer xor current index)\\n\\t   \\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n\\t      \\u2191\\n\\t\\t  7 ^ 1 = 6 (prev answer xor current index)\\n\\t\\t  \\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n             \\u2191\\n\\t\\t\\t 6 ^ 3 = 5 (prev answer xor current index)\\n\\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n                \\u2191\\n\\t\\t\\t\\t5 ^ 4 = 1  (prev answer xor current index)\\n\\t\\t\\t\\t\\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n                   \\u2191\\n\\t\\t\\t\\t   1 ^ 5 = 4 (prev answer xor current index)\\n\\t\\t\\t\\t   \\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n                      \\u2191\\n\\t\\t\\t\\t\\t  4 ^ 7 = 3 (prev answer xor current index)\\n\\t\\t\\t\\t\\t  \\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n                         \\u2191\\n\\t\\t\\t\\t\\t\\t 3 ^ 4 = 7 (prev answer xor current index)\\n\\t\\t\\t\\t\\t\\t \\nSo, the element which we got as left should be our answer, so the answer is \\'7\\'\\n```\\n```\\nTime Complexity --> O(n) // where n is the size of the array\\nSpace Complexity --> O(1) // we are not using anything extra from our side\\n\\nIt paases [ 61 / 61 ] in built test cases\\n```\\n**Code (C++)**\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& arr) {\\n        int n = arr.size(); // extracting the size of the array\\n        \\n        // traverse from the array\\n        for(int i = 0; i < n - 1; i++)\\n        {\\n            arr[i + 1] = arr[i] ^ arr[i + 1]; // (prev answer xor current index)\\n        }\\n        \\n        return arr[n- 1]; // return left over element\\n    }\\n};\\n```\\n***`If u find this useful , please consider to give a upvote!!`***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nLet\\'s take an example not given in question -\\nSuppose our array is arr[]: [5, 1, 3, 1, 3, 4, 5, 7, 4]\\n\\nSo, our answer should be \\'7\\' as it appears only single time in the array. \\n```\n```\\nTime Complexity --> O(n) // where n is the size of the array\\nSpace Complexity --> O(n) // we will store the frequency of every element\\n\\nIt paases [ 61 / 61 ] in built test cases\\n```\n```\\nSuppose our array is arr[]: [5, 1, 3, 1, 3, 4, 5, 7, 4]\\nso, after storing frequency of each element in our map, our map looks like -\\n5 -> 2\\n1 -> 2\\n3 -> 2\\n4 -> 2\\n7 -> 1     On traversing, we will see that it\\'s frequency is 1, so this should be our answer.\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& arr) {\\n        int n = arr.size(); // taking the size of the array \\n        \\n        unordered_map<int, int> mp; // unordered map to store the frequency\\n        \\n        // storing frequency in the map\\n        for(int i = 0; i < n; i++)\\n        {\\n            mp[arr[i]]++;\\n        }\\n        \\n        int ans; // variable to store our answer\\n        for(auto x: mp) // traverse from the map\\n        {\\n            if(x.second == 1) //if frequency of any elemennt is 1\\n            {\\n                ans = x.first; // store in our answer\\n                break; // break the loop, as we got our answer now\\n            }\\n        }\\n        \\n        return ans; // return ans\\n    }\\n};\\n```\n```\\n0 ^ 0 --> 0\\n0 ^ 1 --> 1\\n1 ^ 0 --> 1\\n1 ^ 1 --> 0\\n```\n```\\nWe know every number is appears twice except a single number which appears only single time.\\n\\nSee, we already discuss a thing a that xor of a same number with itself is zero, i.e A ^ A = 0\\nNow, we will look some more property of xor-\\n\\n1) xor of a same number with itself is zero, i.e A ^ A = 0\\n2) xor is commutative that means a ^ b = b ^ a.\\n3) xor of any number with zero is the number itself i.e A ^ 0 = A.\\n\\nSuppose our array is arr[]: [5, 1, 3, 1, 3, 4, 5, 7, 4]\\nwe will rearrange the array, and take all the numbers together, then our array looks like\\n                     arr[]: [1, 1, 3, 3, 4, 4, 5, 5, 7]\\n\\t\\t\\t\\t\\t now, take xor of all numbers -\\n\\t\\t\\t\\t\\t 1 ^ 1 ^ 3 ^ 3 ^ 4 ^ 4 ^ 5 ^ 5 ^ 7   (rearrange the array)\\n\\t\\t\\t\\t\\t   0   ^   0   ^   0   ^   0   ^ 7   (see point number 1)\\n\\t\\t\\t\\t\\t               7                     (see point number 3) \\n\\n```\n```\\nSo, our array is arr[]: [5, 1, 3, 1, 3, 4, 5, 7, 4] \\n\\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n \\u2191  \\u2191\\n 5 ^ 1 = 4\\n \\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n       \\u2191                       \\n\\t   4 ^ 3 = 7 (prev answer xor current index)\\n\\t   \\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n\\t      \\u2191\\n\\t\\t  7 ^ 1 = 6 (prev answer xor current index)\\n\\t\\t  \\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n             \\u2191\\n\\t\\t\\t 6 ^ 3 = 5 (prev answer xor current index)\\n\\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n                \\u2191\\n\\t\\t\\t\\t5 ^ 4 = 1  (prev answer xor current index)\\n\\t\\t\\t\\t\\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n                   \\u2191\\n\\t\\t\\t\\t   1 ^ 5 = 4 (prev answer xor current index)\\n\\t\\t\\t\\t   \\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n                      \\u2191\\n\\t\\t\\t\\t\\t  4 ^ 7 = 3 (prev answer xor current index)\\n\\t\\t\\t\\t\\t  \\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n                         \\u2191\\n\\t\\t\\t\\t\\t\\t 3 ^ 4 = 7 (prev answer xor current index)\\n\\t\\t\\t\\t\\t\\t \\nSo, the element which we got as left should be our answer, so the answer is \\'7\\'\\n```\n```\\nTime Complexity --> O(n) // where n is the size of the array\\nSpace Complexity --> O(1) // we are not using anything extra from our side\\n\\nIt paases [ 61 / 61 ] in built test cases\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& arr) {\\n        int n = arr.size(); // extracting the size of the array\\n        \\n        // traverse from the array\\n        for(int i = 0; i < n - 1; i++)\\n        {\\n            arr[i + 1] = arr[i] ^ arr[i + 1]; // (prev answer xor current index)\\n        }\\n        \\n        return arr[n- 1]; // return left over element\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1771791,
                "title": "python3-one-liner-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nWe use the nice property of XOR operation which is if you XOR same numbers it will return zero. Since the `nums` contains just one non-repeating number, we can just XOR all numbers together and the final result will be our answer.\\n\\n*For reference about `reduce`: https://thepythonguru.com/python-builtin-functions/reduce/*\\n\\n```\\ndef singleNumber(self, nums: List[int]) -> int:\\n\\treturn reduce(lambda total, el: total ^ el, nums)\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\ndef singleNumber(self, nums: List[int]) -> int:\\n\\treturn reduce(lambda total, el: total ^ el, nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 42997,
                "title": "my-o-n-solution-using-xor",
                "content": "known that A XOR A = 0 and the XOR operator is commutative, the solution will be very straightforward.\\n`\\n\\n    int singleNumber(int A[], int n) {\\n        int result = 0;\\n        for (int i = 0; i<n; i++)\\n        {\\n\\t\\t\\tresult ^=A[i];\\n        }\\n\\t\\treturn result;\\n    }\\n`",
                "solutionTags": [],
                "code": "known that A XOR A = 0 and the XOR operator is commutative, the solution will be very straightforward.\\n`\\n\\n    int singleNumber(int A[], int n) {\\n        int result = 0;\\n        for (int i = 0; i<n; i++)\\n        {\\n\\t\\t\\tresult ^=A[i];\\n        }\\n\\t\\treturn result;\\n    }\\n`",
                "codeTag": "Unknown"
            },
            {
                "id": 43000,
                "title": "python-different-solutions",
                "content": "   \\n    def singleNumber1(self, nums):\\n        dic = {}\\n        for num in nums:\\n            dic[num] = dic.get(num, 0)+1\\n        for key, val in dic.items():\\n            if val == 1:\\n                return key\\n    \\n    def singleNumber2(self, nums):\\n        res = 0\\n        for num in nums:\\n            res ^= num\\n        return res\\n        \\n    def singleNumber3(self, nums):\\n        return 2*sum(set(nums))-sum(nums)\\n        \\n    def singleNumber4(self, nums):\\n        return reduce(lambda x, y: x ^ y, nums)\\n        \\n    def singleNumber(self, nums):\\n        return reduce(operator.xor, nums)",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "   \\n    def singleNumber1(self, nums):\\n        dic = {}\\n        for num in nums:\\n            dic[num] = dic.get(num, 0)+1\\n        for key, val in dic.items():\\n            if val == 1:\\n                return key\\n    \\n    def singleNumber2(self, nums):\\n        res = 0\\n        for num in nums:\\n            res ^= num\\n        return res\\n        \\n    def singleNumber3(self, nums):\\n        return 2*sum(set(nums))-sum(nums)\\n        \\n    def singleNumber4(self, nums):\\n        return reduce(lambda x, y: x ^ y, nums)\\n        \\n    def singleNumber(self, nums):\\n        return reduce(operator.xor, nums)",
                "codeTag": "Python3"
            },
            {
                "id": 3171261,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        int ans = nums[0];\\n\\n        for(int i = 1 ; i < nums.size() ; i++){\\n            ans = ans ^ nums[i];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n  def singleNumber(self, nums: List[int]) -> int:\\n    return functools.reduce(lambda x, y: x ^ y, nums, 0)\\n```\\n\\n```Java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int result=0;\\n        for(int i=0; i<nums.length; i++) {\\n            result = result^nums[i];\\n        }\\n        return result;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        int ans = nums[0];\\n\\n        for(int i = 1 ; i < nums.size() ; i++){\\n            ans = ans ^ nums[i];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n  def singleNumber(self, nums: List[int]) -> int:\\n    return functools.reduce(lambda x, y: x ^ y, nums, 0)\\n```\n```Java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int result=0;\\n        for(int i=0; i<nums.length; i++) {\\n            result = result^nums[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43201,
                "title": "easy-java-solution-tell-you-why-using-bitwise-xor",
                "content": "  \\nwe use bitwise XOR to solve this problem : \\n\\nfirst , we have to know the bitwise XOR in java\\n\\n 1. **0 ^ N = N**\\n 2. **N ^ N = 0**\\n\\n\\nSo..... if N is the single number\\n\\nN1 ^ N1 ^ N2 ^ N2 ^..............^ Nx ^ Nx ^ N  \\n\\n  = (N1^N1) ^ (N2^N2) ^..............^ (Nx^Nx) ^ N\\n\\n  = 0 ^ 0 ^ ..........^ 0 ^ N\\n\\n  = N  \\n\\n\\n  \\n \\n\\n\\n\\n    public int singleNumber(int[] nums) {\\n        int ans =0;\\n        \\n        int len = nums.length;\\n        for(int i=0;i!=len;i++)\\n            ans ^= nums[i];\\n        \\n        return ans;\\n        \\n    }",
                "solutionTags": [],
                "code": "  \\nwe use bitwise XOR to solve this problem : \\n\\nfirst , we have to know the bitwise XOR in java\\n\\n 1. **0 ^ N = N**\\n 2. **N ^ N = 0**\\n\\n\\nSo..... if N is the single number\\n\\nN1 ^ N1 ^ N2 ^ N2 ^..............^ Nx ^ Nx ^ N  \\n\\n  = (N1^N1) ^ (N2^N2) ^..............^ (Nx^Nx) ^ N\\n\\n  = 0 ^ 0 ^ ..........^ 0 ^ N\\n\\n  = N  \\n\\n\\n  \\n \\n\\n\\n\\n    public int singleNumber(int[] nums) {\\n        int ans =0;\\n        \\n        int len = nums.length;\\n        for(int i=0;i!=len;i++)\\n            ans ^= nums[i];\\n        \\n        return ans;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3021354,
                "title": "java-easy-solution-beats-100-runtime-1ms-bit-manipulation",
                "content": "\\n# Approach\\nUsing Bit Manipulation - \\n\\n1) As we know XOR operation with 0 gives the same number \\ni.e,  a XOR 0 = a\\neg, for decimal no. 2=>  2 XOR 0 = 2\\nin binary, 010 XOR 000 = 010 \\n\\n2) Also we know that , XOR operation with same number gives 0\\ni.e, a XOR a = 0 \\neg, 2 XOR 2 = 0\\nin binary, 010 XOR 010 = 000 \\n\\n3) XOR is associative (like sum)\\ni.e, (2 XOR 3) XOR 4 = 2 XOR (3 XOR 4), So the order doesn\\'t matter in performing XOR operation. \\neg, 2^3^4^6 = 3^2^6^4 = 4^2^6^3 ......\\n\\nSo, using these three properties of XOR , we will solve the question. we will take ans variable with 0 as initial value. And then for each element i in array, we will perform the XOR operation of the element  with 0, ans will become 0 if the same number is found (as a XOR a = 0) and so after the completion of the loop, only element with no duplicate number will remain and will be returned as ans.\\n\\n\\nHope this helps!!\\nDo Upvote if you like it.\\n\\nThanks :)\\n\\n# Code\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=0; //since XOR with 0 returns same number \\n        for(int i=0; i<nums.length; i++){\\n            ans ^= nums[i];  // ans = (ans) XOR (array element at i) \\n        }\\n        return ans;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=0; //since XOR with 0 returns same number \\n        for(int i=0; i<nums.length; i++){\\n            ans ^= nums[i];  // ans = (ans) XOR (array element at i) \\n        }\\n        return ans;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43228,
                "title": "easiest-way-to-solve-by-using-bit-manipulation",
                "content": "\\n**Logic:** XOR will return 1 only on two different bits. So if two numbers are the same, XOR will return 0. Finally only one number left.\\nA ^ A = 0 and A ^ B ^ A = B.\\n\\n\\n\\n\\n\\n    class Solution {\\n        public:\\n            int singleNumber(int A[], int n) {\\n                int result=A[0];\\n                for(int i=1;i<n;i++)\\n                {\\n                    result= result^A[i];  /* Get the xor of all elements */\\n                }\\n                return result;\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            int singleNumber(int A[], int n) {\\n                int result=A[0];\\n                for(int i=1;i<n;i++)\\n                {\\n                    result= result^A[i];  /* Get the xor of all elements */\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 43171,
                "title": "1ms-java-solution",
                "content": "public class Solution {\\n    \\n    public int singleNumber(int[] nums) {\\n        int result = 0;\\n        for(int i : nums) {\\n            result ^= i;\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    public int singleNumber(int[] nums) {\\n        int result = 0;\\n        for(int i : nums) {\\n            result ^= i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2438883,
                "title": "very-easy-0-ms-100-fully-explained-java-c-python-js-c-python3",
                "content": "**Problem:**\\nGiven a non-empty array of integers nums, every element appears twice except for one. Find that single one.\\n**Input:**   nums = [ 4, 1, 2, 1, 2 ]\\n**Output:**  4\\n**Explanation:**   1\\u2019s and 2\\u2019s appear twice, only 4 appears exactly once. So the answer is 4.\\n**Concept of XOR:**\\nXOR of zero and some bit returns that bit i.e. x^0 = x...\\nXOR of two same bits returns 0 i.e. x^x = 0...\\nAnd,  x^y^x = (x^x)^y = 0^y = y...\\nXOR all bits together to find the unique number.\\n\\n\\n# **Java Solution:**\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Single Number.\\nMemory Usage: 46.2 MB, less than 89.95% of Java online submissions for Single Number.\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        // Initialize the unique number...\\n        int uniqNum = 0;\\n        // TRaverse all elements through the loop...\\n        for (int idx : nums) {\\n            // Concept of XOR...\\n            uniqNum ^= idx;\\n        } return uniqNum;       // Return the unique number...\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\nRuntime: 6 ms, faster than 98.77% of C++ online submissions for Single Number.\\nMemory Usage: 11.8 MB, less than 98.93% of C++ online submissions for Single Number.\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        // Initialize the unique number...\\n        int uniqNum = 0;\\n        // TRaverse all elements through the loop...\\n        for (int idx : nums) {\\n            // Concept of XOR...\\n            uniqNum ^= idx;\\n        } return uniqNum;       // Return the unique number...\\n    }\\n};\\n```\\n\\n# **Python Solution:**\\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        # Initialize the unique number...\\n        uniqNum = 0;\\n        # TRaverse all elements through the loop...\\n        for idx in nums:\\n            # Concept of XOR...\\n            uniqNum ^= idx;\\n        return uniqNum;       # Return the unique number...\\n```\\n            \\n# **JavaScript Solution:**\\n```\\nvar singleNumber = function(nums) {\\n    // Initialize the unique number...\\n    let uniqNum = 0;\\n    // TRaverse all elements through the loop...\\n    for (let idx = 0; idx < nums.length; idx++) {\\n        // Concept of XOR...\\n        uniqNum = uniqNum ^ nums[idx];\\n    } return uniqNum;       // Return the unique number...\\n};\\n```\\n\\n# **C Language:**\\n```\\nint singleNumber(int* nums, int numsSize){\\n    // Initialize the unique number...\\n    int uniqNum = 0;\\n    // TRaverse all elements through the loop...\\n    for (int idx = 0; idx < numsSize; idx++) {\\n        // Concept of XOR...\\n        uniqNum = uniqNum ^ nums[idx];\\n    } return uniqNum;       // Return the unique number...\\n}\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        # Initialize the unique number...\\n        uniqNum = 0;\\n        # TRaverse all elements through the loop...\\n        for idx in nums:\\n            # Concept of XOR...\\n            uniqNum ^= idx;\\n        return uniqNum;       # Return the unique number...\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        // Initialize the unique number...\\n        int uniqNum = 0;\\n        // TRaverse all elements through the loop...\\n        for (int idx : nums) {\\n            // Concept of XOR...\\n            uniqNum ^= idx;\\n        } return uniqNum;       // Return the unique number...\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        // Initialize the unique number...\\n        int uniqNum = 0;\\n        // TRaverse all elements through the loop...\\n        for (int idx : nums) {\\n            // Concept of XOR...\\n            uniqNum ^= idx;\\n        } return uniqNum;       // Return the unique number...\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        # Initialize the unique number...\\n        uniqNum = 0;\\n        # TRaverse all elements through the loop...\\n        for idx in nums:\\n            # Concept of XOR...\\n            uniqNum ^= idx;\\n        return uniqNum;       # Return the unique number...\\n```\n```\\nvar singleNumber = function(nums) {\\n    // Initialize the unique number...\\n    let uniqNum = 0;\\n    // TRaverse all elements through the loop...\\n    for (let idx = 0; idx < nums.length; idx++) {\\n        // Concept of XOR...\\n        uniqNum = uniqNum ^ nums[idx];\\n    } return uniqNum;       // Return the unique number...\\n};\\n```\n```\\nint singleNumber(int* nums, int numsSize){\\n    // Initialize the unique number...\\n    int uniqNum = 0;\\n    // TRaverse all elements through the loop...\\n    for (int idx = 0; idx < numsSize; idx++) {\\n        // Concept of XOR...\\n        uniqNum = uniqNum ^ nums[idx];\\n    } return uniqNum;       // Return the unique number...\\n}\\n```\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        # Initialize the unique number...\\n        uniqNum = 0;\\n        # TRaverse all elements through the loop...\\n        for idx in nums:\\n            # Concept of XOR...\\n            uniqNum ^= idx;\\n        return uniqNum;       # Return the unique number...\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264959,
                "title": "well-expalined-code-in-java",
                "content": "\\n\\n# Approach\\nThe code is a Java implementation of a function that takes an integer array nums as input and returns the single integer in the array that appears only once. The function assumes that all other integers in the array appear exactly twice.\\n\\nThe implementation sorts the input array using the Arrays.sort() method. Sorting the array ensures that all duplicate integers are adjacent to each other. Then, the implementation iterates through the sorted array using a loop that increments the index by 2 in each iteration. Inside the loop, the implementation checks if the current integer and the next integer are not equal. If they are not equal, the implementation returns the current integer as the single integer that appears only once.\\n\\nIf the loop completes without finding a single integer that appears only once, the implementation returns the last element of the sorted array. This is because the last element is the only remaining element in the array, and it must be the single integer that appears only once.\\n\\n# Complexity\\n- Time complexity:\\nThe Arrays.sort method used at the beginning of the function has a time complexity of O(n log n), where n is the length of the input array. This is because it uses a variant of the quicksort algorithm, which has an average time complexity of O(nlogn).\\n\\n- Space complexity:\\nThe space complexity of the function is O(1), as it uses only a constant amount of additional memory to store the loop variable and some temporary variables for the sorting operation. The sorting operation is performed in-place, so it does not require any additional memory allocation.\\n\\n# Code\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length-1;i+=2){\\n            if(nums[i]!=nums[i+1]){\\n                return nums[i];\\n            }\\n        }\\n       return nums[nums.length-1];\\n    }\\n    \\n}\\n```\\n![upvote.jpeg](https://assets.leetcode.com/users/images/02c5a619-d6fa-418b-b177-8b523fc2b30f_1678114992.5292022.jpeg)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length-1;i+=2){\\n            if(nums[i]!=nums[i+1]){\\n                return nums[i];\\n            }\\n        }\\n       return nums[nums.length-1];\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43237,
                "title": "4-lines-of-c-solution",
                "content": "    nt singleNumber(int a[], int n) {\\n         //xor all numbers, the left over number would be the non repeated one\\n         // since the equl numbers cancel out each others bits\\n         int num = 0;\\n         for (int i = 0; i < n; ++i) {\\n             num ^= a[i];\\n         }\\n         return num;\\n        }",
                "solutionTags": [],
                "code": "    nt singleNumber(int a[], int n) {\\n         //xor all numbers, the left over number would be the non repeated one\\n         // since the equl numbers cancel out each others bits\\n         int num = 0;\\n         for (int i = 0; i < n; ++i) {\\n             num ^= a[i];\\n         }\\n         return num;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 558767,
                "title": "python-space-o-1-xor-reduce-very-simple-one-liner-with-explanation",
                "content": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return reduce(lambda x, y: x^y, nums, 0)\\n```\\n\\n**Explanation**\\nI will try to explain this solution by walking through the initial solution that I wrote:\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        result = 0\\n\\t\\tfor n in nums:\\n\\t\\t\\tresult ^= n\\n\\t\\treturn result\\n```\\nThe most crucial trick here is to recognize that if you XOR any same number together, you cancel it out (=0).\\nFor example:\\nnums = [2,4,5,4,3,5,2]\\nXORing everything together\\n= 2 ^ 4 ^ 5 ^ 4 ^ 3 ^ 5 ^ 2\\n= (2^2) ^ (4^4) ^ (5^5) ^ 3\\n= 0 ^ 0 ^0 ^ 3\\n= 3\\n\\n(If you are unfamiliar with the XOR operation, you can check out [this stackoverflow post](https://stackoverflow.com/questions/14526584/what-does-the-xor-operator-do))\\n\\nNow, let\\'s go back to the one liner:\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return reduce(lambda x, y: x^y, nums, 0)\\n```\\n- The `reduce` here just simplifies the previous `for` loop into one line, it\\'s not doing anything different. \\n- The initializer `0` is put there to prevent the the scenerio where `nums` is an empty list (I didn\\'t realize that the question statement explicitly mentioned that it would be non-empty).",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return reduce(lambda x, y: x^y, nums, 0)\\n```\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        result = 0\\n\\t\\tfor n in nums:\\n\\t\\t\\tresult ^= n\\n\\t\\treturn result\\n```\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return reduce(lambda x, y: x^y, nums, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43193,
                "title": "javascript-solution",
                "content": "```js\\nfunction singleNumber(nums) {\\n\\treturn nums.reduce((prev, curr) => prev ^ curr);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nfunction singleNumber(nums) {\\n\\treturn nums.reduce((prev, curr) => prev ^ curr);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1174407,
                "title": "easy-c-solution-beginner-friendly",
                "content": "**AN UPVOTE WOULD BE HIGHLY APPRECIATED**\\n\\n**Optimised Approach**\\n* Since in XOR Operations 0^0 = 0 and 1^1 = 0.\\n* Hence here the same bits(numbers) will cancel out each other i.e result to zero and only the unique bit(number) will be left.!!!\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        int ans = 0;\\n        \\n        for(int i=0; i<nums.size(); i++) {\\n            ans = ans^nums[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Bruteforce Approach**\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        if(nums.size() < 1) {\\n            return 0;\\n        }\\n        \\n        else if(nums.size() > 1) {\\n            \\n            sort(nums.begin(), nums.end());\\n            \\n            for(int i=0; i<nums.size(); i++) {\\n                if(nums[i] != nums[i+1]) {\\n                    return nums[i];\\n                }\\n                i++;\\n            }\\n        }\\n        \\n        //else for nums.size() == 1\\n        return nums[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        int ans = 0;\\n        \\n        for(int i=0; i<nums.size(); i++) {\\n            ans = ans^nums[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        if(nums.size() < 1) {\\n            return 0;\\n        }\\n        \\n        else if(nums.size() > 1) {\\n            \\n            sort(nums.begin(), nums.end());\\n            \\n            for(int i=0; i<nums.size(); i++) {\\n                if(nums[i] != nums[i+1]) {\\n                    return nums[i];\\n                }\\n                i++;\\n            }\\n        }\\n        \\n        //else for nums.size() == 1\\n        return nums[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43216,
                "title": "my-very-simple-solution-linear-time-no-extra-memory",
                "content": "\\nXOR of two equal numbers is 0 : a^a=0. This is the main idea of the algorithm.\\n\\n    class Solution { \\n        public:\\n            int singleNumber(int A[], int n) {\\n                for (int i = 1; i < n; ++i)\\n                    A[0] ^= A[i];\\n                 return A[0];\\n            } \\n        };",
                "solutionTags": [],
                "code": "class Solution { \\n        public:\\n            int singleNumber(int A[], int n) {\\n                for (int i = 1; i < n; ++i)\\n                    A[0] ^= A[i];\\n                 return A[0];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 43019,
                "title": "1-line-simple-python-solution",
                "content": "    class Solution(object):\\n    def singleNumber(self, nums):\\n        return sum(list(set(nums)))*2 - sum(nums)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n    def singleNumber(self, nums):\\n        return sum(list(set(nums)))*2 - sum(nums)",
                "codeTag": "Java"
            },
            {
                "id": 43153,
                "title": "my-java-solution-in-o-n-time-complexity-and-o-1-space-complexity-using-xor",
                "content": "    public class Solution {\\n        public int singleNumber(int[] nums) {\\n            int res = 0;\\n            for(int num : nums) {\\n                res ^= num;\\n            }\\n            return res;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n        public int singleNumber(int[] nums) {\\n            int res = 0;\\n            for(int num : nums) {\\n                res ^= num;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1428325,
                "title": "all-c-solutions-100-faster-99-26-less-space",
                "content": "***1. O(NLog N) Time and O(1) Space solution: [99.26% less space]***\\n```\\n    int singleNumber(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size()-1;){\\n            if(nums[i+1] != nums[i])\\n                return nums[i];\\n            else\\n                i+=2;\\n        }\\n        return nums[nums.size()-1];\\n    }\\n```\\n\\n***2. Using Unordered Maps (Hash Tables)***\\n```\\n    int singleNumber(vector<int>& nums) {        \\n        unordered_map<int, int> um;\\n        for(int a: nums)\\n            um[a]++;\\n        for(auto it = um.begin(); it!=um.end(); it++){\\n            if(it->second==1)\\n                return it->first;\\n        }\\n        return 0;\\n    }\\n```\\n\\n***3. Using XOR(^) bitwise operator to find unique number*** (Fastest)\\nBitwise XOR Operator(^) has three properties: \\n1. a^a = 0\\n2. 0^a = a\\n3. XOR is associative just like addition, multiplication, etc which means that -> a^b^c = a^(b^c) = (a^b)^c = (a^c)^b\\nSo, when we XOR all the numbers in the list, all the numbers that occur 2 times become 0 as a^a = 0. At the end, we will be left with an expression like 0^n, where n is the only number occurring once. Using second property 0^a = a :-  0^n = n. Hence, we get the unique number.\\n```\\n    int singleNumber(vector<int>& nums) {        \\n        \\n        // Using XOR property for Unique number\\n        int resultXOR = 0;                \\n        for(int a: nums)\\n            resultXOR ^= a;        \\n        return resultXOR;            \\n    }\\n```\\n***Please Upvote if found useful!***",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n    int singleNumber(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size()-1;){\\n            if(nums[i+1] != nums[i])\\n                return nums[i];\\n            else\\n                i+=2;\\n        }\\n        return nums[nums.size()-1];\\n    }\\n```\n```\\n    int singleNumber(vector<int>& nums) {        \\n        unordered_map<int, int> um;\\n        for(int a: nums)\\n            um[a]++;\\n        for(auto it = um.begin(); it!=um.end(); it++){\\n            if(it->second==1)\\n                return it->first;\\n        }\\n        return 0;\\n    }\\n```\n```\\n    int singleNumber(vector<int>& nums) {        \\n        \\n        // Using XOR property for Unique number\\n        int resultXOR = 0;                \\n        for(int a: nums)\\n            resultXOR ^= a;        \\n        return resultXOR;            \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43232,
                "title": "simple-c-solution",
                "content": "The trick is: A^B^A=B\\n\\n    class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            if(nums.empty()) return 0;\\n            int first = nums[0];\\n            for(int i = 1; i<nums.size();i++) {\\n                first = first ^ nums[i];\\n            }\\n            return first;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            if(nums.empty()) return 0;\\n            int first = nums[0];\\n            for(int i = 1; i<nums.size();i++) {\\n                first = first ^ nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1184007,
                "title": "3-different-java-solutions-with-explanations",
                "content": "First Approach by using hashMap  :-\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        HashMap<Integer, Integer> hash = new<Integer, Integer> HashMap();\\n        \\n        for(int x : nums){\\n            if(hash.containsKey(x)){       //if hashmap contains \\'element\\', then increase correspoding val\\n                int count = hash.get(x);\\n                hash.put(x, ++count);\\n            }\\n            else\\n                hash.put(x, 1);           //if hashmap does not contain  \\'element\\', then put it in hashmap\\n        }\\n        \\n        for(int x : hash.keySet()){       //Iterate through \\'keys\\' of HashMap\\n            if(hash.get(x)==1)            //if \\'value\\' for \\'key\\' is \\'1\\', then return that \\'key\\' element\\n                return x;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\\nTime Complexity : O(nlogn) , as there is a for loop and inside for loop \\'hash.containsKey\\' \\nSpace Complexity : O(n)  ,  as HashMap of size nearly \\'n/2\\' is used.\\n\\n\\nSecond Approach by using \\'Sort()\\' method :-\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);                          //Sort the array\\n        for(int i=0 ; i<nums.length-1; i+=2){       \\n            if(nums[i]!=nums[i+1])                  //Check pairwise values in array\\n                return nums[i];                     //if any pairwise values are different, then it is answer\\n        }\\n        return nums[nums.length - 1];       //if answer is largest value, then it will not be detected in above loop hence return it here\\n   }\\n}\\n```\\nTime Complexity : O(nlogn) , as \\'sort()\\' method is used \\nSpace Complexity : O(1)  ,  as No extra space is used other than some constant\\n\\n\\n\\nOptimal Approach by using \\'XOR\\'  :-\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int result = 0;\\n        for(int x: nums){\\n            result = result ^ x;\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\nBitwise \\'XOR\\' gives zero when both inputs are same. And if we apply XOR for \\'zero\\' and \\'any number\\', it will give output as that number itself. So if the array is {4,1,2,1,2} then \\'XOR\\' operation is\\n        ((2^2)^(1^1)^(4)) => (0^0^4) => 4\\n\\t\\t\\nTime Complexity : O(n) , as only one \\'for\\'loop\\nSpace Complexity : O(1)  , as No extra space is used other than some constant\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        HashMap<Integer, Integer> hash = new<Integer, Integer> HashMap();\\n        \\n        for(int x : nums){\\n            if(hash.containsKey(x)){       //if hashmap contains \\'element\\', then increase correspoding val\\n                int count = hash.get(x);\\n                hash.put(x, ++count);\\n            }\\n            else\\n                hash.put(x, 1);           //if hashmap does not contain  \\'element\\', then put it in hashmap\\n        }\\n        \\n        for(int x : hash.keySet()){       //Iterate through \\'keys\\' of HashMap\\n            if(hash.get(x)==1)            //if \\'value\\' for \\'key\\' is \\'1\\', then return that \\'key\\' element\\n                return x;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);                          //Sort the array\\n        for(int i=0 ; i<nums.length-1; i+=2){       \\n            if(nums[i]!=nums[i+1])                  //Check pairwise values in array\\n                return nums[i];                     //if any pairwise values are different, then it is answer\\n        }\\n        return nums[nums.length - 1];       //if answer is largest value, then it will not be detected in above loop hence return it here\\n   }\\n}\\n```\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int result = 0;\\n        for(int x: nums){\\n            result = result ^ x;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 558787,
                "title": "python-3",
                "content": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        r=nums[0]\\n        for i in range(1,n):\\n            r = r ^ nums[i] \\n\\n        return r\\n```\\n\\t\\t\\n\\t\\nexplanation:-\\nLet ^ be xor operator as in python 3\\n\\nr = 7 ^ 3 ^ 5 ^ 4 ^ 5 ^ 3 ^ 4\\n\\nSince XOR is associative and commutative, above \\nexpression can be written as:\\nr = 7 ^ (3 ^ 3) ^ (4 ^ 4) ^ (5 ^ 5)  \\n    = 7 ^ 0 ^ 0 ^ 0\\n    = 7 ^ 0\\n    = 7",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        r=nums[0]\\n        for i in range(1,n):\\n            r = r ^ nums[i] \\n\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43209,
                "title": "non-bitwise-java-solution-using-set",
                "content": "    public int singleNumber(int[] A) {\\n            \\n           Set<Integer> s = new HashSet<Integer>();\\n    \\t    for (int i: A){\\n    \\t    \\tif(!s.add(i)){\\n    \\t    \\t\\ts.remove(i);\\n    \\t    \\t}\\n    \\t    }\\n    \\t    return s.iterator().next();\\n            \\n        }",
                "solutionTags": [],
                "code": "    public int singleNumber(int[] A) {\\n            \\n           Set<Integer> s = new HashSet<Integer>();\\n    \\t    for (int i: A){\\n    \\t    \\tif(!s.add(i)){\\n    \\t    \\t\\ts.remove(i);\\n    \\t    \\t}\\n    \\t    }\\n    \\t    return s.iterator().next();\\n            \\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 43217,
                "title": "java-solution-with-explanation",
                "content": "    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            res = res^nums[i];\\n        }\\n        return res;\\n    }\\n\\n\\n----------\\nidea: for every bit, use bit manipulation. 0^0^0 = 0, 1^1^1 = 1, 0^0^1 = 1, 1^1^0 = 0. Thus, after the bit manipulation of XOR, the every bit of result is the bit of single number.",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            res = res^nums[i];\\n        }\\n        return res;\\n    }\\n\\n\\n----------\\nidea: for every bit, use bit manipulation. 0^0^0 = 0, 1^1^1 = 1, 0^0^1 = 1, 1^1^0 = 0. Thus, after the bit manipulation of XOR, the every bit of result is the bit of single number.",
                "codeTag": "Unknown"
            },
            {
                "id": 690738,
                "title": "python-o-1-space-simple-solution-with-detailed-explanation",
                "content": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        ## RC ##\\n        ## APPROACH : XOR ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n        \\n        # If we take XOR of zero and some bit, it will return that bit\\n        # a XOR 0 = a, a XOR 0=a\\n        # If we take XOR of two same bits, it will return 0\\n        # a XOR a = 0 a XOR a=0\\n        # a XOR b XOR a = (a XOR a) XOR b = 0 XOR b = b \\n        # a\\u2295b\\u2295a=(a\\u2295a)\\u2295b=0\\u2295b=b\\n        # So we can XOR all bits together to find the unique number.\\n        \\n        a = 0\\n        for i in nums:\\n            a ^= i\\n        return a\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        ## RC ##\\n        ## APPROACH : XOR ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n        \\n        # If we take XOR of zero and some bit, it will return that bit\\n        # a XOR 0 = a, a XOR 0=a\\n        # If we take XOR of two same bits, it will return 0\\n        # a XOR a = 0 a XOR a=0\\n        # a XOR b XOR a = (a XOR a) XOR b = 0 XOR b = b \\n        # a\\u2295b\\u2295a=(a\\u2295a)\\u2295b=0\\u2295b=b\\n        # So we can XOR all bits together to find the unique number.\\n        \\n        a = 0\\n        for i in nums:\\n            a ^= i\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1387175,
                "title": "python-3-xor-explanation",
                "content": "This problem asks us to solve it in **O(n) time** and **O(1) space**. \\n\\nThe best way to do this is to use **XOR (\\u2295)** operations (`^` in Python), because there are two benefits from XOR operation:\\n\\n1. **The XOR of any two identical numbers is 0.** For example, `0101 ^ 0101 = 0000`.\\n2. **The XOR of any number and 0 is the number itself.** For example, `0101 ^ 0000 = 0101`\\n\\nIn addition, XOR operations are associative and commutative; therefore, the operations can be written in the following form:\\n\\n```\\n    4 ^ 1 ^ 2 ^ 1 ^ 2\\n=   4 ^ 1 ^ 1 ^ 2 ^ 2      (commutativity)\\n=   4 ^ (1 ^ 1) ^ (2 ^ 2)  (associativity)\\n=   4 ^ 0 ^ 0\\n=   4\\n```\\n\\n\\n``` py\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        z = nums[0]\\n        for num in nums[1:]:\\n            z^= num\\n        return z\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\n    4 ^ 1 ^ 2 ^ 1 ^ 2\\n=   4 ^ 1 ^ 1 ^ 2 ^ 2      (commutativity)\\n=   4 ^ (1 ^ 1) ^ (2 ^ 2)  (associativity)\\n=   4 ^ 0 ^ 0\\n=   4\\n```\n``` py\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        z = nums[0]\\n        for num in nums[1:]:\\n            z^= num\\n        return z\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43028,
                "title": "one-line-python-solution-with-o-n-time",
                "content": "    return reduce(lambda x, y: x ^ y, nums)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    return reduce(lambda x, y: x ^ y, nums)",
                "codeTag": "Unknown"
            },
            {
                "id": 3197054,
                "title": "very-simple-and-easy-solution",
                "content": "# Intuition\\nThe sort method is called on the nums array, which modifies the original array in place to sort it in ascending order. This is not necessary for the solution, but it does make it easier to find the single number by grouping all of the duplicate numbers together.\\n\\nThe for loop iterates over the arr array by 2, comparing each pair of adjacent elements.\\n\\nIf a non-matching pair of adjacent elements is found, the first element in the pair is returned as the single number.\\n\\nIf no non-matching pair is found, the last element in the array is returned as the single number, since it must be the only element that does not have a matching pair.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar singleNumber = function (nums) {\\n  let arr = nums.sort((a, b) => a - b); // Create a copy of the array and sort it\\n\\n  for (let i = 0; i <= nums.length - 1; i += 2) { // Iterate by 2\\n    if (arr[i] !== arr[i + 1]) {\\n      return arr[i];\\n    }\\n  }\\n\\n  return arr[arr.length - 1];  // Return the first non-matching pair\\n};\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/19f45496-d52e-4b20-928b-3e16c79afc98_1676631777.988186.png)\\n\\n\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar singleNumber = function (nums) {\\n  let arr = nums.sort((a, b) => a - b); // Create a copy of the array and sort it\\n\\n  for (let i = 0; i <= nums.length - 1; i += 2) { // Iterate by 2\\n    if (arr[i] !== arr[i + 1]) {\\n      return arr[i];\\n    }\\n  }\\n\\n  return arr[arr.length - 1];  // Return the first non-matching pair\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2641351,
                "title": "python-3-easy-solution-in-one-line-without-using-xor",
                "content": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return sum(list(set(nums)) * 2) - sum(nums)\\n```\\n\\nIf you find XOR hard to understand, then maybe use this solution instead.\\n\\nGive me some upvote if you like the solution! Cheers!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return sum(list(set(nums)) * 2) - sum(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 396584,
                "title": "clean-javascript-solution",
                "content": "```\\n// time O(n)\\n// space O(n)\\nfunction singleNumber(nums) {\\n  const map = {};\\n  for (let n of nums) {\\n    if (map[n] == null) map[n] = 0;\\n    map[n]++;\\n  }\\n\\n  for (let n in map) {\\n    if (map[n] === 1) return Number(n);\\n  }\\n}\\n```\\n\\n```\\n// time O(n)\\n// space O(1)\\nfunction singleNumber(nums) {\\n  let num = 0;\\n  for (let n of nums) {\\n    num ^= n;\\n  }\\n  return num;\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// time O(n)\\n// space O(n)\\nfunction singleNumber(nums) {\\n  const map = {};\\n  for (let n of nums) {\\n    if (map[n] == null) map[n] = 0;\\n    map[n]++;\\n  }\\n\\n  for (let n in map) {\\n    if (map[n] === 1) return Number(n);\\n  }\\n}\\n```\n```\\n// time O(n)\\n// space O(1)\\nfunction singleNumber(nums) {\\n  let num = 0;\\n  for (let n of nums) {\\n    num ^= n;\\n  }\\n  return num;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1771869,
                "title": "python-simple-python-solution-with-two-approach",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Approach 1 with XOR Operation :-\\n# Runtime: 144 ms, faster than 64.43% of Python3 online submissions for Single Number.\\n# Memory Usage: 18.9 MB, less than 76.74% of Python3 online submissions for Single Number.\\n\\n# XOR Concept : -\\n\\t0 ^ 0 = 0\\n\\t0 ^ 1 = 1\\n\\t1 ^ 0 = 1\\n\\t1 ^ 1 = 0\\n\\n\\tclass Solution:\\n\\t\\tdef singleNumber(self, nums: List[int]) -> int:\\n\\n\\t\\t\\tresult = 0\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tresult = result ^ num\\n\\n\\t\\t\\treturn result \\n\\n# Approach 2 with Counting Frequency :-\\n# Runtime: 140 ms, faster than 79.48% of Python3 online submissions for Single Number.\\n# Memory Usage: 19 MB, less than 54.30% of Python3 online submissions for Single Number.\\n\\n\\tclass Solution:\\n\\t\\tdef singleNumber(self, nums: List[int]) -> int:\\n\\n\\t\\t\\tfrequency = {}\\n\\n\\t\\t\\tfor num in nums:\\n\\n\\t\\t\\t\\tif num not in frequency:\\n\\n\\t\\t\\t\\t\\tfrequency[num] = 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tfrequency[num] = frequency[num] + 1\\n\\n\\t\\t\\tfor key in frequency:\\n\\n\\t\\t\\t\\tif frequency[key] == 1:\\n\\n\\t\\t\\t\\t\\treturn key\\t\\t\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n\\t\\tdef singleNumber(self, nums: List[int]) -> int:\\n\\n\\t\\t\\tresult = 0\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tresult = result ^ num\\n\\n\\t\\t\\treturn result \\n\\n# Approach 2 with Counting Frequency :-\\n# Runtime: 140 ms, faster than 79.48% of Python3 online submissions for Single Number.\\n# Memory Usage: 19 MB, less than 54.30% of Python3 online submissions for Single Number.\\n\\n\\tclass Solution:\\n\\t\\tdef singleNumber(self, nums: List[int]) -> int:\\n\\n\\t\\t\\tfrequency = {}",
                "codeTag": "Java"
            },
            {
                "id": 43229,
                "title": "maybe-the-shortest-java-solution",
                "content": "    public class Solution {\\n        public int singleNumber(int[] A) {\\n            int a=0;\\n            for(int i:A)\\n                a^=i;\\n            return a;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int singleNumber(int[] A) {\\n            int a=0;\\n            for(int i:A)\\n                a^=i;\\n            return a;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 43154,
                "title": "easy-c-solution",
                "content": "\\n     int singleNumber(int* nums, int numsSize) {\\n     int x = 0;\\n     int i = 0;\\n     for (i = 0; i<numsSize;i++)\\n     {\\n       x=x^nums[i];\\n     }\\n     return x;\\n    }",
                "solutionTags": [],
                "code": "\\n     int singleNumber(int* nums, int numsSize) {\\n     int x = 0;\\n     int i = 0;\\n     for (i = 0; i<numsSize;i++)\\n     {\\n       x=x^nums[i];\\n     }\\n     return x;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 43052,
                "title": "strongly-recommended-support-scala-language",
                "content": "and here is the code for solve the single number, and using scala language is just only one line of code. With now, functional programming is very popular in big data area. So, I strongly recommended the leecode support the compiler compatible with scala. \\n\\n     def singleNumber(nums:Array[Int]): Int = {\\n        nums.foldLeft(0)(_^_)\\n      }\\n    \\n      val arr = Array(1,2,2,3,3,4,5,6,6,5,4,1,9)\\n      println(singleNumber(arr))\\n\\nAnd another example can directly show more message , and just needs a tuple. I show you with this is wish to tell you that scala can support more message and expressive.\\n\\n    def hummingWeight(n: Int): (Int, ArrayBuffer[Int]) = {\\n        val arrBuffer = ArrayBuffer[Int]()\\n        var alt_n = n\\n        var count = 0\\n        while (alt_n > 0) {\\n          if ((alt_n & 1) == 1){\\n            count+=1\\n            arrBuffer += 1\\n          } else {\\n            arrBuffer += 0\\n          }\\n          alt_n >>= 1\\n        }\\n        (count, arrBuffer.reverse)\\n      }\\n      println (hummingWeight(2147483647))\\n    }\\n\\nAnd the output like following\\n\\n    (31,ArrayBuffer(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1))",
                "solutionTags": [],
                "code": "and here is the code for solve the single number, and using scala language is just only one line of code. With now, functional programming is very popular in big data area. So, I strongly recommended the leecode support the compiler compatible with scala. \\n\\n     def singleNumber(nums:Array[Int]): Int = {\\n        nums.foldLeft(0)(_^_)\\n      }\\n    \\n      val arr = Array(1,2,2,3,3,4,5,6,6,5,4,1,9)\\n      println(singleNumber(arr))\\n\\nAnd another example can directly show more message , and just needs a tuple. I show you with this is wish to tell you that scala can support more message and expressive.\\n\\n    def hummingWeight(n: Int): (Int, ArrayBuffer[Int]) = {\\n        val arrBuffer = ArrayBuffer[Int]()\\n        var alt_n = n\\n        var count = 0\\n        while (alt_n > 0) {\\n          if ((alt_n & 1) == 1){\\n            count+=1\\n            arrBuffer += 1\\n          } else {\\n            arrBuffer += 0\\n          }\\n          alt_n >>= 1\\n        }\\n        (count, arrBuffer.reverse)\\n      }\\n      println (hummingWeight(2147483647))\\n    }\\n\\nAnd the output like following\\n\\n    (31,ArrayBuffer(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1))",
                "codeTag": "Python3"
            },
            {
                "id": 509005,
                "title": "my-javascript-solution-56ms",
                "content": "```\\nvar singleNumber = function(nums) {\\n    let hash = {}\\n    for(let val of nums){\\n        hash[val]?delete hash[val]:hash[val]=1;\\n    }\\n    return Object.keys(hash)[0]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar singleNumber = function(nums) {\\n    let hash = {}\\n    for(let val of nums){\\n        hash[val]?delete hash[val]:hash[val]=1;\\n    }\\n    return Object.keys(hash)[0]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43114,
                "title": "one-liner-in-js",
                "content": "```\\nvar singleNumber = function(nums) {\\n    return nums.reduce((a, b) => a^b);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar singleNumber = function(nums) {\\n    return nums.reduce((a, b) => a^b);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43197,
                "title": "o-n-using-xor-in-java-for-single-number-problem",
                "content": "    public class Solution {\\n        public int singleNumber(int[] nums) {\\n            int res = nums[0];\\n            for (int i = 1; i < nums.length; i++)\\n                res = res ^ nums[i];\\n    \\n            return res;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int singleNumber(int[] nums) {\\n            int res = nums[0];\\n            for (int i = 1; i < nums.length; i++)\\n                res = res ^ nums[i];\\n    \\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1771956,
                "title": "simple-3-approaches-easy-to-understand",
                "content": "**Approach 1 = Using HashSet  ==>   TC = O(n)   SC=O(n)**\\n\\n\\tclass Solution {\\n\\t\\tpublic int singleNumber(int[] nums) {\\n\\t\\t\\tHashSet<Integer> set = new HashSet<Integer>();\\n\\t\\t\\tfor(int i : nums) {\\n\\t\\t\\t\\tif(set.contains(i)) {\\n\\t\\t\\t\\t\\tset.remove(i);\\n\\t\\t\\t\\t} else{\\n\\t\\t\\t\\t\\tset.add(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i:set) {\\n\\t\\t\\t\\treturn i;\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t}\\n\\n**Approach 2 = Using Sorting  ==> TC: O(NlogN)    SC: O(1)** \\n\\n\\tclass Solution {\\n\\t\\tpublic int singleNumber(int[] nums) {\\n\\t\\t\\tArrays.sort(nums);\\n\\t\\t\\tfor(int i = 1; i < nums.length; i+=2) {\\n\\t\\t\\t\\tif(nums[i] != nums[i-1]) {\\n\\t\\t\\t\\t\\treturn nums[i-1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn nums[nums.length-1];\\n\\t\\t}\\n\\t}\\n\\t\\n\\t\\n**Approach 3 = Using XOR  ==>  TC: O(N)   SC: O(1)**\\n\\n\\tclass Solution {\\n\\t\\tpublic int singleNumber(int[] nums) {\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int x : nums)\\n\\t\\t\\t\\tans^=x;\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t}\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0\\uD83C\\uDF38), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\t\\tpublic int singleNumber(int[] nums) {\\n\\t\\t\\tHashSet<Integer> set = new HashSet<Integer>();\\n\\t\\t\\tfor(int i : nums) {\\n\\t\\t\\t\\tif(set.contains(i)) {\\n\\t\\t\\t\\t\\tset.remove(i);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 43081,
                "title": "simple-c-solution",
                "content": "class Solution \\n{public:\\n\\n    int singleNumber(vector<int>& nums) {\\n        \\n        for(int i = 1; i < nums.size(); ++i) nums[0] ^= nums[i];\\n        \\n        return nums[0];\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution \\n{public:\\n\\n    int singleNumber(vector<int>& nums) {\\n        \\n        for(int i = 1; i < nums.size(); ++i) nums[0] ^= nums[i];\\n        \\n        return nums[0];\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 43196,
                "title": "c-implementation-using-xor",
                "content": "    class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            // XOR (^) is both commutative and associative \\n            // The numbers which appear twice will be cancelled\\n            // Only the number that appear twice survive \\n            int value = 0;\\n            int i, n;\\n            n = nums.size();\\n            for(i=0; i<n; i++)\\n                value = value ^ nums[i];\\n            return value;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            // XOR (^) is both commutative and associative \\n            // The numbers which appear twice will be cancelled\\n            // Only the number that appear twice survive \\n            int value = 0;\\n            int i, n;\\n            n = nums.size();\\n            for(i=0; i<n; i++)\\n                value = value ^ nums[i];\\n            return value;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 43215,
                "title": "o-n-solution-using-bit-operation-only-22-characters",
                "content": "    def singleNumber(self, A):\\n        r = 0\\n        for i in A:\\n            r ^= i\\n        return r",
                "solutionTags": [],
                "code": "    def singleNumber(self, A):\\n        r = 0\\n        for i in A:\\n            r ^= i\\n        return r",
                "codeTag": "Python3"
            },
            {
                "id": 899031,
                "title": "easy-python-solution-o-n-time-and-o-1-space-explanation",
                "content": "The idea is when you XOR a number with itself (since it will appear TWICE only )it will result in a 0, so when you XOR all the elements the end result will be the element that is appearing once only\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        res=0\\n        for n in nums:\\n            res^=n\\n        return res    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        res=0\\n        for n in nums:\\n            res^=n\\n        return res    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 43185,
                "title": "my-c-solution-using-unordered-set-int",
                "content": "\\n        unordered_set<int> mySet;\\n        for(int i = 0;i < nums.size();++i){\\n            if(mySet.find(nums[i]) == mySet.end()) mySet.insert(nums[i]);\\n            else mySet.erase(nums[i]);\\n        }\\n        auto it = mySet.begin();\\n        return *it;",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n        unordered_set<int> mySet;\\n        for(int i = 0;i < nums.size();++i){\\n            if(mySet.find(nums[i]) == mySet.end()) mySet.insert(nums[i]);\\n            else mySet.erase(nums[i]);\\n        }\\n        auto it = mySet.begin();\\n        return *it;",
                "codeTag": "Unknown"
            },
            {
                "id": 43060,
                "title": "only-one-line-python-solution",
                "content": "reduce(func, A) means: func(func(A[0], A[1]), A[2])...\\n\\nSo the reduce function below just return all elements' XOR value, that is our single number.\\n\\n    class Solution:\\n    # @param A, a list of integer\\n    # @return an integer\\n    def singleNumber(self, A):\\n        return reduce(lambda x, y: x ^ y, A)",
                "solutionTags": [],
                "code": "reduce(func, A) means: func(func(A[0], A[1]), A[2])...\\n\\nSo the reduce function below just return all elements' XOR value, that is our single number.\\n\\n    class Solution:\\n    # @param A, a list of integer\\n    # @return an integer\\n    def singleNumber(self, A):\\n        return reduce(lambda x, y: x ^ y, A)",
                "codeTag": "Java"
            },
            {
                "id": 1938482,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the nums.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func singleNumber(_ nums: [Int]) -> Int {\\n        var ans = 0\\n        for num in nums { ans ^= num }\\n        return ans\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the nums.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func singleNumber(_ nums: [Int]) -> Int {\\n        var ans = 0\\n        for num in nums { ans ^= num }\\n        return ans\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075088,
                "title": "simplest-solution-for-beginners",
                "content": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if(nums.count(i) == 1):\\n                return(i)\\n```\\n**Please upvote if you like it**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if(nums.count(i) == 1):\\n                return(i)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43049,
                "title": "javascript-solution",
                "content": "Javascript Solution / 102ms Runtime\\n```\\nvar singleNumber = function(nums) {\\n    var result = nums[0];\\n    for(var i = 1; i < nums.length; i++) {\\n        result = result^nums[i];\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar singleNumber = function(nums) {\\n    var result = nums[0];\\n    for(var i = 1; i < nums.length; i++) {\\n        result = result^nums[i];\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43140,
                "title": "xor-java-solution",
                "content": "    public class Solution {\\n        public int singleNumber(int[] nums) {\\n            int result = 0;\\n            for(int i = 0;i<nums.length;i++){\\n            result = result ^ nums[i];\\n            }\\n            return result;\\n    }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int singleNumber(int[] nums) {\\n            int result = 0;\\n            for(int i = 0;i<nums.length;i++){\\n            result = result ^ nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 43222,
                "title": "java-solution-using-xor",
                "content": "    public int singleNumber(int[] nums) {\\n      int ans = 0;\\n            \\n      for (int i = 0; i < nums.length; i++)\\n        ans ^= nums[i];\\n            \\n      return ans;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int singleNumber(int[] nums) {\\n      int ans = 0;\\n            \\n      for (int i = 0; i < nums.length; i++)\\n        ans ^= nums[i];\\n            \\n      return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1772428,
                "title": "c-3-approaches-beginner-friendly-easy-and-intuitive-well-explained",
                "content": "## **Approach 1: Frequency Counting + Linear Traversal (Hashmap or Frequency Array)**\\nSo the very first brute force approach that comes to our mind after reading this question is that we can count the frequency of each element in the array and then find the element with frequency as 1.\\n\\n#### Example: \\n\\n![image](https://assets.leetcode.com/users/images/44b16506-49ab-4a4c-aeca-736b8b3c2f34_1644902604.556138.jpeg)\\n\\n\\n#### Code:\\n```cpp\\nint singleNumber(vector<int>& nums) {\\n        unordered_map<int, int> elementToFreqMap; //key=element of nums array, value=freq of that element in the nums array\\n        \\n        for(int num: nums){\\n            elementToFreqMap[num]++;\\n        }\\n        \\n        for(auto it: elementToFreqMap){\\n            if(it.second==1) return it.first;\\n        }\\n        \\n        return -1;\\n    }\\n```\\n\\n#### Complexity:\\n***TC* = O(n)**[traversal of whole array] **+ O(n/2 + 1)**[traversal of map, as all elements appear twice except 1, so there will be (n/2)+1 distinct keys int the map to traverse]  **=  O(n)**\\n***SC* = O(n/2 +1)**[space taken by the map] **= O(n)**\\n\\n**************************************************************************************\\n\\n## **Approach 2: Sorting + Linear traversal**\\nIt is essentially kind of counting for the frequency only, but here we will not be using extra space.\\n1. The idea is to sort the elements and then start traversing the array in a way that we check `every second element` in the array starting from index 1.\\n\\n2. If that element is similar to its previous element, then that is not our answer, so continue finding the answer.\\n\\n3. Else if the element if not equal to its previous element, then that means, the frequency of this element is 1 in the array, so this element is our ans. Therefore return this element.\\n\\n4. As the `array will always be odd` (let there be k elements in the array which occur twice and 1 element which occurs only once, that means the length of array will be 2k+1, which is always odd) therefore the `indices will range from 0 to 2k` (last index being even), and we are traversing every other element starting from index 1. So the indices we are looking at are 1, 3, 5, 7... (all odd indices). Now if we come out of loop with no answer as of now, then we can clearly say that the element at the last index is our answer because it is the only index we didnot look at and as it is sure that there is exactly one element which is our answer. So return the last element of the sorted array, if you didnot find the ans inside the loop. **[Hope you got this]**\\n\\n#### Example (Dry Run):\\n\\n![image](https://assets.leetcode.com/users/images/1cf30585-0e07-43a4-82fb-f7e8aaed7752_1644904686.652919.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/24510508-d5f5-4d42-b406-0b6f56e7d3ac_1644904700.7419345.jpeg)\\n\\n#### Code:\\n```cpp\\nint singleNumber(vector<int>& nums) { \\n       sort(nums.begin() ,nums.end());\\n        \\n        for(int i=1; i<nums.size(); i+=2){ //i+=2 as we want to check every other element\\n            if(nums[i]!=nums[i-1])\\n                return nums[i-1];\\n        }\\n        return nums[nums.size()-1]; //if we didnot find answer in the loop, so return the last element.\\n    }\\n```\\n\\n#### Complexity:\\n***TC*** **= O(nlogn)**[because of sorting] **+ O(n/2)**[traversing every other element of array] **= O(nlogn)**\\n***SC*** **= O(1)** [no extra space being used]\\n\\n*************************************************************************************\\n\\n## **Approach 3: Bit Manipulation (XOR)**\\nFirst let us look at the truth table for XOR :-\\n\\n![image](https://assets.leetcode.com/users/images/c15fc714-37a8-4c8d-9eb2-f7ad7ac5f37b_1644905576.1700804.jpeg)\\n\\nFrom the table we can conclude 2 things \\n`OBS1: If both the bits are same (either both 1 or both 0) then the result of XOR is 0, and if both the bits are different (one of them is 1 and other is 0) then the result of XOR is 1`\\n\\n`OBS2: Any bit \\'a\\' when xored with 0, gives the original bit itself. That means a^0 = 0^a = a.`\\n\\nAlso from OBS1 we can conclude one more thing that\\n\\n`OBS3: For any number \\'a\\', its xor with itself will result in 0. That means, a^a=0.`\\nWhy?? Look at this example\\n\\n![image](https://assets.leetcode.com/users/images/42916f13-104b-4643-90c2-9244f2b9b3e2_1644906064.9595697.jpeg)\\n\\nAs we can see that xoring a number with itself will result in same bits at every place, because of which in the ans there will be 0s at every place, making the answer as 0.\\n\\nSo till now we have made 2 observations which will help us building the logic for this approach:\\n\\n`a^a = 0      ...(i)`\\n`0^a = a^0 = a      ...(ii)`\\n\\nNow, let\\'s come to the question...\\nWe know that in the array all the elements appear twice except one element.\\n`So, if we xor all the elements of the array then the result will be the element which occurs only once!`\\nWhy??\\n\\nLook at this example:\\n\\n#### Example:\\n![image](https://assets.leetcode.com/users/images/ebbacfc8-57de-408e-a9c9-91c6e5246edd_1644908267.6280568.jpeg)\\n\\n`So, in simple layman terms we can say that all the elements which occur twice will cancel each other out, and hence we will be left with the element which doesn\\'t have its counter to cancel it. That means we will be left with the element which occurs only once. And this will be our answer.`\\n\\n#### Code:\\n```cpp\\nint singleNumber(vector<int>& nums) { \\n       int xorOfAllElements = 0;\\n        \\n        for(int num: nums)\\n            xorOfAllElements ^= num;\\n        \\n        return xorOfAllElements; //At the end this xor will be containing our answer.\\n    }\\n```\\n\\n#### Complexity:\\n***TC*** **= O(n)** [traversing all the elements of the array]\\n***SC*** **= O(1)** [no extra space used]\\n\\n\\n***Plz upvote the post, if you found it useful***\\n\\n\\n \\n\\n",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "```cpp\\nint singleNumber(vector<int>& nums) {\\n        unordered_map<int, int> elementToFreqMap; //key=element of nums array, value=freq of that element in the nums array\\n        \\n        for(int num: nums){\\n            elementToFreqMap[num]++;\\n        }\\n        \\n        for(auto it: elementToFreqMap){\\n            if(it.second==1) return it.first;\\n        }\\n        \\n        return -1;\\n    }\\n```\n```cpp\\nint singleNumber(vector<int>& nums) { \\n       sort(nums.begin() ,nums.end());\\n        \\n        for(int i=1; i<nums.size(); i+=2){ //i+=2 as we want to check every other element\\n            if(nums[i]!=nums[i-1])\\n                return nums[i-1];\\n        }\\n        return nums[nums.size()-1]; //if we didnot find answer in the loop, so return the last element.\\n    }\\n```\n```cpp\\nint singleNumber(vector<int>& nums) { \\n       int xorOfAllElements = 0;\\n        \\n        for(int num: nums)\\n            xorOfAllElements ^= num;\\n        \\n        return xorOfAllElements; //At the end this xor will be containing our answer.\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 834955,
                "title": "2-different-approach-xor-map-3-lines-code",
                "content": "Property of XOR (exclusive or) a^a=0 and a^0=a , based on this we can say XOR of any number which is occuring even number of times will give zero and after this if any number which is occuring single time will be the answer.\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans = 0;\\n        for(auto i : nums) ans = ans ^ i;\\n        return ans;\\n    }\\n};\\n```\\n* Using unordered map\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        for(auto i : nums) mp[i]++;\\n        \\n        for(auto i : mp)\\n            if(i.second == 1) return i.first;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans = 0;\\n        for(auto i : nums) ans = ans ^ i;\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        for(auto i : nums) mp[i]++;\\n        \\n        for(auto i : mp)\\n            if(i.second == 1) return i.first;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 114402,
                "title": "hashmap-in-java",
                "content": "XOR is cool. I solved this question with HashMap in JAVA.\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (!map.containsKey(nums[i])) {\\n                map.put(nums[i],1);\\n            }\\n            else {\\n                map.put(nums[i],map.get(nums[i]) + 1);\\n            }\\n        }\\n        for ( Map.Entry<Integer,Integer> entry : map.entrySet()) {\\n            Integer key = entry.getKey();\\n            Integer value = entry.getValue();\\n            if (map.get(key) == 1) {\\n                return key;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (!map.containsKey(nums[i])) {\\n                map.put(nums[i],1);\\n            }\\n            else {\\n                map.put(nums[i],map.get(nums[i]) + 1);\\n            }\\n        }\\n        for ( Map.Entry<Integer,Integer> entry : map.entrySet()) {\\n            Integer key = entry.getKey();\\n            Integer value = entry.getValue();\\n            if (map.get(key) == 1) {\\n                return key;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103877,
                "title": "java-simple-solution",
                "content": "> Please Upvote if this Solution Helps You\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            count = 0;\\n            for (int j = 0; j < nums.length; j++) {\\n                if (nums[i] == nums[j]) {\\n                    count++;\\n                }\\n            }\\n            if (count == 1) {\\n                return nums[i];\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            count = 0;\\n            for (int j = 0; j < nums.length; j++) {\\n                if (nums[i] == nums[j]) {\\n                    count++;\\n                }\\n            }\\n            if (count == 1) {\\n                return nums[i];\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1474244,
                "title": "c-o-1-space-o-n-time-easiest-explanation-3-lines-of-code",
                "content": "# **Logic ( XOR OPERATION )**\\n\\n- Before going into the solution, let\\'s recall some facts about the XOR operation. If you don\\'t understand any point down below, try to callibrate that point by yourself, and still don\\'t tell me in the comments section. I will try to help you out there. :)\\n- XOR operation of any number with 0 gives the number itself.\\n- XOR operation of same numbers appearing even number of times gives 0.\\n- Now let\\'s move to the solution part\\n    - As every number comes twice in the array the XOR of all those duplicates will boil down to 0.\\n    - As the result of all those duplicates values is 0, XOR of the result (0) with the only single element will give that number itself (SEE THE POINT Number 2 FROM TOP)\\n    - Bingo, you get that number, SEE it\\'s peaceful man :)\\n\\n```cpp\\nint singleNumber(vector<int>& nums) {\\n    int num=0;\\n    for(auto &i : nums) num ^= i;\\n    return num;\\n}\\n\\n```\\n\\n\\n\\n**Like it? please upvote...\\nHave any comments? I\\'d love to hear!**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nint singleNumber(vector<int>& nums) {\\n    int num=0;\\n    for(auto &i : nums) num ^= i;\\n    return num;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3353219,
                "title": "java-code-that-beat-100-of-the-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n        This can be easily solved with XOR. \\n        When a number is XORed by the same number, the result is 0. \\n        We can leverage this to solve this problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n        We just need loop through the elements, XOR them one by one \\n        and add them.\\n        At the end, only the non repeating number remains because it is \\n        the only non duplicate number.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        // easily solved with XOR; when the same number is XORed, the result is 0. \\n        // just loop through the elements and XOR them; the non repeating number remains.\\n        int ans =0;\\n        for(int i=0;i<nums.length;i++){\\n            ans=ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        // easily solved with XOR; when the same number is XORed, the result is 0. \\n        // just loop through the elements and XOR them; the non repeating number remains.\\n        int ans =0;\\n        for(int i=0;i<nums.length;i++){\\n            ans=ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43089,
                "title": "java-solution-in-3-lines-o-n-and-without-extra-space",
                "content": "A simple solution, using 2 properties of XOR: **A \\u2295 A = 0** and **B \\u2295 0 = B**\\nIn other words, **A \\u2295 A \\u2295 B = B**\\n\\n```\\npublic int singleNumber(int[] nums) {\\n  for(int i=0;i<nums.length-1;i++){\\n    nums[i+1] ^= nums[i];\\n  }\\n  return nums[nums.length-1];\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "A simple solution, using 2 properties of XOR: **A \\u2295 A = 0** and **B \\u2295 0 = B**\\nIn other words, **A \\u2295 A \\u2295 B = B**\\n\\n```\\npublic int singleNumber(int[] nums) {\\n  for(int i=0;i<nums.length-1;i++){\\n    nums[i+1] ^= nums[i];\\n  }\\n  return nums[nums.length-1];\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 43200,
                "title": "c-solution-using-xor",
                "content": "Duplicates will be 0 with xor operations. res xor num is num. The one left in the end is the unique one.\\n\\n    class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            int res = 0;\\n            for (int n : nums) res ^= n;\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            int res = 0;\\n            for (int n : nums) res ^= n;\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 43290,
                "title": "linear-but-uses-extra-spaces-accepted-but-needs-improvement-welcome-suggestions",
                "content": "Below is my code. I used a set to record a new element and add it to the sum; if the element shows up again, delete it from the set and subtract it from the sum. At the end, the sum will be the single element.\\nThanks for comments and suggestions.\\n\\n    public class Solution {\\n      public static int singleNumber(int[] A) {\\n        int single = 0;\\n        Set<Integer> s = new TreeSet<Integer>();\\n        for (int i : A) {\\n          if (s.contains(i)) {\\n            single = single - i;\\n            s.remove(i);\\n          } else {\\n            s.add(i);\\n            single = single + i;\\n          }\\n        }\\n      return single;\\n      }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n      public static int singleNumber(int[] A) {\\n        int single = 0;\\n        Set<Integer> s = new TreeSet<Integer>();\\n        for (int i : A) {\\n          if (s.contains(i)) {\\n            single = single - i;\\n            s.remove(i);\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 3524018,
                "title": "c-java-python-javascript-fully-explained-easy-to-understand",
                "content": "# Intuition:\\nThe given problem asks us to find the number that appears only once in the given vector of integers. We can solve this problem using the bitwise XOR operation.\\n\\n# Approach:\\n1. Initialize a variable `c` to 0. This variable will store the XOR of all the elements in the vector.\\n2. Iterate through each element `num` in the vector.\\n   - Update `c` by performing `c = c ^ num`. This XOR operation will cancel out the duplicate occurrences of the numbers, leaving only the number that appears only once.\\n3. After the loop, the value of `c` will be the number that appears only once.\\n4. Return `c` as the result.\\n\\n# Complexity:\\n- Time Complexity: O(n), where n is the size of the input vector `nums`. We iterate through each element once.\\n- Space Complexity: O(1), as we are using a constant amount of extra space.\\n\\n---\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            c= c^nums[i];\\n        }\\n            return c;\\n    }\\n};\\n```\\n\\n---\\n# Java\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int n = nums.length;\\n        int c = 0;\\n        for (int i = 0; i < n; i++) {\\n            c = c ^ nums[i];\\n        }\\n        return c;\\n    }\\n}\\n\\n```\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        n = len(nums)\\n        c = 0\\n        for i in range(n):\\n            c = c ^ nums[i]\\n        return c\\n\\n```\\n---\\n# JavaScript\\n```\\nvar singleNumber = function(nums) {\\n    let n = nums.length;\\n    let c = 0;\\n    for (let i = 0; i < n; i++) {\\n        c = c ^ nums[i];\\n    }\\n    return c; \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            c= c^nums[i];\\n        }\\n            return c;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int n = nums.length;\\n        int c = 0;\\n        for (int i = 0; i < n; i++) {\\n            c = c ^ nums[i];\\n        }\\n        return c;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        n = len(nums)\\n        c = 0\\n        for i in range(n):\\n            c = c ^ nums[i]\\n        return c\\n\\n```\n```\\nvar singleNumber = function(nums) {\\n    let n = nums.length;\\n    let c = 0;\\n    for (let i = 0; i < n; i++) {\\n        c = c ^ nums[i];\\n    }\\n    return c; \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795592,
                "title": "java-1-problem-5-solutions-easy",
                "content": "# Please Upvote :D\\n---\\n##### 1. Sorting:\\n``` java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        if (nums.length == 1) {\\n            return nums[0];\\n        }\\n\\n        for (int i = 1; i < nums.length; i += 2) {\\n            if (nums[i] != nums[i - 1]) {\\n                return nums[i - 1];\\n            }\\n        }\\n\\n        return nums[nums.length - 1];\\n    }\\n}\\n\\n// TC: O(n * logn) + O(n) => O(n * logn)\\n// SC: O(1)\\n```\\n---\\n##### 2. Bit-Manipulation (XOR):\\n* `0^a = a`\\n* `a^b`\\n* `a^b^a = (a^a)^b = 0^b`\\n* In this way only the number which is unique (lets say b) remains till the end.\\n``` java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans = 0;\\n        for (int n : nums) ans ^= n;\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```\\n---\\n\\n##### 3. Using HashMap:\\n``` java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int n : nums) {\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n        }\\n\\n        for (int n : map.keySet()) {\\n            if (map.get(n) == 1) {\\n                return n;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\\n---\\n##### 4. Using HashSet:\\nKeep removing elements when found to be already existing in the set.\\nThe one which is not duplicate will never be removed from the set.\\n``` java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int n : nums) {\\n            if (set.contains(n)) {\\n                set.remove(n);\\n            } else {\\n                set.add(n);\\n            }\\n        }\\n\\n        return set.iterator().next();\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\\n---\\n##### 5. Using ArrayList:\\nKeep removing elements when found to be already existing in the list.\\nThe one which is not duplicate will never be removed from the list.\\n``` java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int n : nums) {\\n            if (list.contains(n)) {\\n                list.remove(Integer.valueOf(n));\\n            } else {\\n                list.add(n);\\n            }\\n        }\\n\\n        return list.get(0);\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        if (nums.length == 1) {\\n            return nums[0];\\n        }\\n\\n        for (int i = 1; i < nums.length; i += 2) {\\n            if (nums[i] != nums[i - 1]) {\\n                return nums[i - 1];\\n            }\\n        }\\n\\n        return nums[nums.length - 1];\\n    }\\n}\\n\\n// TC: O(n * logn) + O(n) => O(n * logn)\\n// SC: O(1)\\n```\n``` java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans = 0;\\n        for (int n : nums) ans ^= n;\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```\n``` java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int n : nums) {\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n        }\\n\\n        for (int n : map.keySet()) {\\n            if (map.get(n) == 1) {\\n                return n;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\n``` java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int n : nums) {\\n            if (set.contains(n)) {\\n                set.remove(n);\\n            } else {\\n                set.add(n);\\n            }\\n        }\\n\\n        return set.iterator().next();\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\n``` java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int n : nums) {\\n            if (list.contains(n)) {\\n                list.remove(Integer.valueOf(n));\\n            } else {\\n                list.add(n);\\n            }\\n        }\\n\\n        return list.get(0);\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772481,
                "title": "python-oneliner-solution-explained",
                "content": "There is straightforward hash-table solution with `O(n)` memory and time. We can also use bit manipulation trick to evaluate XOR of all numbers, which is what we need.\\n\\n#### Complexity\\nTime is `O(n)`, space is `O(1)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def singleNumber(self, nums):\\n        return reduce(xor, nums)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def singleNumber(self, nums):\\n        return reduce(xor, nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43164,
                "title": "java-solution-using-hashset-instead-of-xor",
                "content": "    public int singleNumber(int[] nums) {\\n        HashSet<Integer> check = new HashSet<Integer>();\\n        for(int i = 0; i < nums.length; i++)\\n            if(!check.remove(nums[i]))\\n                check.add(nums[i]);\\n        return check.iterator().next();\\n    }",
                "solutionTags": [],
                "code": "    public int singleNumber(int[] nums) {\\n        HashSet<Integer> check = new HashSet<Integer>();\\n        for(int i = 0; i < nums.length; i++)\\n            if(!check.remove(nums[i]))\\n                check.add(nums[i]);\\n        return check.iterator().next();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 43240,
                "title": "four-lines-of-code-for-java",
                "content": "public class Solution {\\n    public int singleNumber(int[] A) {\\n        int result = 0;\\n        for (int i : A)\\n            result ^= i ;\\n        return result ;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int singleNumber(int[] A) {\\n        int result = 0;\\n        for (int i : A)\\n            result ^= i ;\\n        return result ;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1771894,
                "title": "c-3-lines-memory-99-time-92-3-in-place",
                "content": "We all know a solution using XOR operation, maintaining the answer in a varible and returning it, but do we even need to use that one extra variable? \\n\\nWell no, and here\\'s how we can acheive it:\\n\\n```\\nclass Solution {\\npublic:\\n  int singleNumber(vector<int>& nums) {\\n    for(int i=1;i<nums.size();i++)\\n      nums[i] = nums[i]^nums[i-1];\\n    return nums[nums.size()-1];\\n  }\\n};\\n```\\n\\nHave a good day :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  int singleNumber(vector<int>& nums) {\\n    for(int i=1;i<nums.size();i++)\\n      nums[i] = nums[i]^nums[i-1];\\n    return nums[nums.size()-1];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1570604,
                "title": "c-xor-solution-16-ms-17-mb",
                "content": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            ans ^= nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            ans ^= nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1133245,
                "title": "javascript-o-n-speed-and-o-n-space-solution-easy-to-read",
                "content": "```\\nfunction singleNumber (nums) {\\n  const memo = new Set();\\n\\n  for (let num of nums) {\\n    if (memo.has(num)) {\\n      memo.delete(num);\\n    } else {\\n      memo.add(num);\\n    }\\n  }\\n\\n  return [...memo][0];\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction singleNumber (nums) {\\n  const memo = new Set();\\n\\n  for (let num of nums) {\\n    if (memo.has(num)) {\\n      memo.delete(num);\\n    } else {\\n      memo.add(num);\\n    }\\n  }\\n\\n  return [...memo][0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 559971,
                "title": "python-js-java-go-c-o-n-by-xor-w-hint",
                "content": "[\\u4E2D\\u6587\\u89E3\\u984C\\u6587\\u7AE0](https://vocus.cc/article/651110b2fd89780001cb6c1d)\\n\\nPython O(n) sol by XOR. \\n\\n---\\n\\n**Hint**:\\n\\nUtilize the property of XOR, **A \\u2295 A = 0**, to cancel those elements which appeared twice.\\n\\n---\\n\\nPython:\\n\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        \\n        xor_result = 0\\n        for x in nums:\\n            xor_result ^= x\\n            \\n        return xor_result\\n```\\n\\nor\\n\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\n        return reduce( lambda x, y: x^y, nums, 0)\\n```\\n\\nor\\n\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\n        return reduce( operator.xor, nums, 0)\\n```\\n\\n---\\n\\nJava:\\n\\n```\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        int xorResult = 0;\\n        \\n        for( int number : nums ){\\n            xorResult ^= number;\\n        }\\n        \\n        return xorResult;\\n    }\\n}\\n\\n```\\n\\nor\\n\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        // Java supports reduce in data stream\\n        return Arrays.stream( nums ).reduce( 0, (x, y) -> (x^y) );\\n    }\\n}\\n```\\n\\n---\\n\\nJavaScript:\\n\\n```\\nvar singleNumber = function(nums) {\\n    \\n    let xor_result = 0; \\n\\t\\n    for(let number of nums){\\n        \\n        xor_result ^= number;    \\n    }\\n    \\n    return xor_result;\\n};\\n```\\n\\nor\\n\\n\\n```\\nvar singleNumber = function(nums) {\\n        \\n    return nums.reduce( (x, y,) =>( x ^ y ), 0 );\\n};\\n```\\n\\n---\\n\\nGolang:\\n\\n```\\nfunc singleNumber(nums []int) int {\\n    \\n    xor_result := 0\\n    \\n    for _, number := range nums{\\n        \\n        xor_result ^= number\\n    }\\n    \\n    return xor_result\\n}\\n```\\n\\n---\\n\\nC++:\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        int result = 0;\\n        \\n        for( const int& number : nums){\\n            result ^= number;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\nor\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        //C++ supports native bitwise xor operator \\n        return std::accumulate( nums.cbegin(), nums.cend(),0, std::bit_xor<int>() );\\n    }\\n};\\n```\\n\\nor\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n         \\n        return std::accumulate( nums.cbegin(), nums.cend(),0,  [](int x, int y){return x^y ;} );\\n    }\\n};\\n```\\n\\n---\\n\\n[Wiki: XOR operator](https://en.wikipedia.org/wiki/Exclusive_or)\\n\\n[Python official docs about XOR operator](https://docs.python.org/3/reference/expressions.html#binary-bitwise-operations)\\n\\n[MDN official doscs about JavaScript XOR operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_XOR)\\n\\n[Golang offical docs about XOR operator](https://go.dev/ref/spec#Arithmetic_operators)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Go",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        \\n        xor_result = 0\\n        for x in nums:\\n            xor_result ^= x\\n            \\n        return xor_result\\n```\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\n        return reduce( lambda x, y: x^y, nums, 0)\\n```\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\n        return reduce( operator.xor, nums, 0)\\n```\n```\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        int xorResult = 0;\\n        \\n        for( int number : nums ){\\n            xorResult ^= number;\\n        }\\n        \\n        return xorResult;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        // Java supports reduce in data stream\\n        return Arrays.stream( nums ).reduce( 0, (x, y) -> (x^y) );\\n    }\\n}\\n```\n```\\nvar singleNumber = function(nums) {\\n    \\n    let xor_result = 0; \\n\\t\\n    for(let number of nums){\\n        \\n        xor_result ^= number;    \\n    }\\n    \\n    return xor_result;\\n};\\n```\n```\\nvar singleNumber = function(nums) {\\n        \\n    return nums.reduce( (x, y,) =>( x ^ y ), 0 );\\n};\\n```\n```\\nfunc singleNumber(nums []int) int {\\n    \\n    xor_result := 0\\n    \\n    for _, number := range nums{\\n        \\n        xor_result ^= number\\n    }\\n    \\n    return xor_result\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        int result = 0;\\n        \\n        for( const int& number : nums){\\n            result ^= number;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        //C++ supports native bitwise xor operator \\n        return std::accumulate( nums.cbegin(), nums.cend(),0, std::bit_xor<int>() );\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n         \\n        return std::accumulate( nums.cbegin(), nums.cend(),0,  [](int x, int y){return x^y ;} );\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 288612,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public int SingleNumber(int[] nums) {\\n        var singleNumber = 0;\\n        foreach (var num in nums) {\\n            singleNumber ^= num;\\n        }\\n        return singleNumber;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int SingleNumber(int[] nums) {\\n        var singleNumber = 0;\\n        foreach (var num in nums) {\\n            singleNumber ^= num;\\n        }\\n        return singleNumber;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43190,
                "title": "4-simple-lines-of-java",
                "content": "    public class Solution {\\n    public int singleNumber(int[] nums) {\\n        int r = nums[0];\\n        for (int i=1; i<nums.length; i++)\\n            r ^= nums[i];\\n        return r;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int r = nums[0];\\n        for (int i=1; i<nums.length; i++)\\n            r ^= nums[i];\\n        return r;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3436371,
                "title": "easy-xor-soultion",
                "content": "# Intuition\\nI solved it via XOR bit operator\\n\\n# Approach\\nFor instance, I have an array [12, 1, 13, 1, 12]\\n1010\\n0001\\n\\n1011\\n1011\\n\\n0000\\n0001\\n\\n0001\\n1010\\n\\n1011 (bin) = 13 (dec)\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int mask = 0;\\n\\n        for(int num : nums) {\\n            mask ^= num;\\n        }\\n\\n        return mask;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Go"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int mask = 0;\\n\\n        for(int num : nums) {\\n            mask ^= num;\\n        }\\n\\n        return mask;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2500050,
                "title": "golang-without-auxiliary-variables",
                "content": "```\\nfunc singleNumber(nums []int) int {\\n\\tfor i := 1; i < len(nums); i++ {\\n\\t\\tnums[0] ^= nums[i]\\n\\t}\\n\\treturn nums[0]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc singleNumber(nums []int) int {\\n\\tfor i := 1; i < len(nums); i++ {\\n\\t\\tnums[0] ^= nums[i]\\n\\t}\\n\\treturn nums[0]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1541621,
                "title": "updated-python-xor-explained-resources",
                "content": "At first, recommend you to skim through the following resources:\\n1. https://www.interviewcake.com/table-of-contents#section_bit-manipulation_concept_not\\n2. https://leetcode.com/discuss/general-discussion/1073221/All-about-Bitwise-Operations-Beginner-Intermediate\\n\\n**Steps:**\\n\\ntake `[4,1,2,1,2]` as an example\\n\\n1. ^ will do addition in bitwise manner.\\n2. But why do we need `result=0`? Why not simply `result=nums[0]` and start iteration from the second? => As I mentioned in the beginning, it is an addition. So, taking 4 and 1, it will give 5. But with `result=0` it\\'ll give 4 at first,\\nthen we add 1 and 2.\\n3. But then, we find duplicates of 1 and 2 which will be subtracted. Why? ^ gives 0 when 2 similar numbers are applied:\\n* 8 ^ 8 = 0\\n\\nOkay, let me explain everything in more details.\\nTake binary representation: \\n0000: 0\\n0001: 1\\n0010: 2\\n0011: 3\\n0100: 4\\n0101: 5\\n0110: 6\\n0111: 7\\n1000: 8\\n1001: 9\\n1010: 10\\n\\nSo, let\\'s iterate over that array:\\n1. 0 ^ 4: we check bit by bit: 0 ^ 0 is 0 and 0 ^ 1 is 1, 1 ^ 1 is 0\\n\\t=> we get 0100 from it. To put it simply, 4\\n\\n2. 4 ^ 1: 0100 ^ 0001 => 0101 which is 5\\n3. 5 ^ 2:  0101 ^ 0010 => 0111 which is 7\\n4. 7 ^ 1: 0111 ^ 0001 => 0110 which is 6\\n5.  6 ^ 2: 0110 ^ 0010 => 0100 which is 4\\n\\nAnd 4 is our answer\\n\\t\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        result = 0\\n        for num in nums:\\n            result ^= num\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        result = 0\\n        for num in nums:\\n            result ^= num\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434725,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int result = 0;\\n        //even occurence will nullify\\n        for(int i=0;i<nums.length;i++){\\n            result ^= nums[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int result = 0;\\n        //even occurence will nullify\\n        for(int i=0;i<nums.length;i++){\\n            result ^= nums[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1279451,
                "title": "faster-than-100-00-bit-manipulation-explained",
                "content": "XOR operator is cumulative in nature i.e., say 5 ^ 3 ^ 5 is same as 5 ^ 5 ^ 3.\\nAlso XOR operation it return 0 for same operands : 1 ^ 1 = 0 and 0 ^ 0 = 0 then 5 ^ 5 = 0101 ^ 0101 = 0000.\\nEvery number repeats twice except the single number ,  so if we take the XOR of the entire array then all the duplicates would get cancelled out to 0 and the one that will be remaining will be our desired result. \\n\\n\\n```\\n public int singleNumber(int[] nums) {\\n    int single=0;\\n    for(int i=0;i<nums.length;i++)\\n        single=single^nums[i];\\n    return single;   \\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\n public int singleNumber(int[] nums) {\\n    int single=0;\\n    for(int i=0;i<nums.length;i++)\\n        single=single^nums[i];\\n    return single;   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 643075,
                "title": "3-swift-implementations",
                "content": "I wrote a blog post on how to solve this problem in Swift in 3 different ways: https://cocoaswiftly.com/leetcode-solutions/136-single-number/\\n\\n```\\nfunc singleNumber(_ nums: [Int]) -> Int {\\n    var numsSeen = Set<Int>()\\n\\n    for num in nums {\\n        // the insert operation returns a tuple, the first value of which is a bool,\\n        // indicating whether the insertion is successful\\n        if !numsSeen.insert(num).0 {\\n            numsSeen.remove(num)\\n        }\\n    }\\n    \\n    // it\\'s ok to force unwrap as a valid answer is guaranteed\\n    return numsSeen.first!\\n}\\n```\\n\\nor \\n\\n```\\nfunc singleNumber(_ nums: [Int]) -> Int {\\n    let distinctNums = Set(nums)\\n\\n    return distinctNums.reduce(0, +) * 2 - nums.reduce(0, +)\\n}\\n```\\n\\nor\\n\\n```\\nfunc singleNumber(_ nums: [Int]) -> Int {\\n    return nums.reduce(0, ^)\\n}\\n```\\n\\nCheckout the post for detailed explanations : https://cocoaswiftly.com/leetcode-solutions/136-single-number/",
                "solutionTags": [],
                "code": "```\\nfunc singleNumber(_ nums: [Int]) -> Int {\\n    var numsSeen = Set<Int>()\\n\\n    for num in nums {\\n        // the insert operation returns a tuple, the first value of which is a bool,\\n        // indicating whether the insertion is successful\\n        if !numsSeen.insert(num).0 {\\n            numsSeen.remove(num)\\n        }\\n    }\\n    \\n    // it\\'s ok to force unwrap as a valid answer is guaranteed\\n    return numsSeen.first!\\n}\\n```\n```\\nfunc singleNumber(_ nums: [Int]) -> Int {\\n    let distinctNums = Set(nums)\\n\\n    return distinctNums.reduce(0, +) * 2 - nums.reduce(0, +)\\n}\\n```\n```\\nfunc singleNumber(_ nums: [Int]) -> Int {\\n    return nums.reduce(0, ^)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43144,
                "title": "1-line-javascript-solution",
                "content": "    var singleNumber = function(nums) {\\n        return nums.reduce((a,b) => a^b);\\n    };",
                "solutionTags": [],
                "code": "    var singleNumber = function(nums) {\\n        return nums.reduce((a,b) => a^b);\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 3224500,
                "title": "explanation-of-thought-process-and-bitmask-solution-one-liner-solution",
                "content": "# Intuition\\nThe question stated some key things, my initial thoughts were:\\n1. Non-empty array of integers, -3 * 10^4 <= nums[i] <= 3 * 10^4, therefore numbers can be negative.\\n2. Every number appears 2 times, except one number. Maybe this piece of info has the key?\\n3. Time Complexity must be O(N).\\n4. Space Complexity must be O(1).\\n5. Therefore, Brute force solution (time complexity -> O(n^2)). Maps (space complexity -> O(n)) won\\'t cut it.\\n6. However, there must be something I can use to \\'**memorize**\\' or \\'**remember**\\' where each element is, or else, how will I identify/track my count of numbers.\\n\\n# Approach\\n1. I\\'m not gonna lie, the only reason I knew how to do this was because I read a similar solution before. The answer was using a bit manipulation of the numbers.\\n2. On a high level we can think of bits or bitmasks as able to \"store/remember\" information using the position of the bits.\\n3. In this case whenever 2 same numbers are XOR\\'ed with each other, they cancel out to form 0, on the other hand if 0 and any number are XOR\\'ed the output is the number itself. So,\\n\\n    7^7 = 0, simple?\\n\\n    7^7^7 =  what will this be? Well XOR\\'s are associative so let\\'s break it down.\\n\\n    7^7 will be 0\\n\\n    111 (7)\\n    111 (7)\\n    ^__\\n    000 (0)\\n\\n    so now it\\'s 0 ^ 7, which is\\n\\n    000 (0)\\n    111 (7)\\n    ^__\\n    111 (7)\\n\\n    So therefore 7^7^7 = 7, similarly 1^1^2 = 2, \\n\\n    4^1^2^1^2 = will be what?\\n\\n    In this case, the 1\\'s and 2\\'s cancel out and we\\'re left with 4^0 = 4, which is the only number with 1 occurrence and our answer in this case.\\n\\n# Complexity\\n- Time complexity: O(n), we\\'re iterating through the array once.\\n\\n- Space complexity: O(1), no extra space is used, we\\'re using the initial bitmask which is `0` and using XORs with the subsequent numbers/calculations.\\n\\n# Code\\n\\nTo anyone who doesn\\'t understand this code(JavaScript) when we use the `reduce` method of an array we pass a `function(callback)` to it, as the 1st argument and an `accumulator` as the 2nd argument(in this case 0).\\n\\nInside the callback, the first argument being passed is the `accumulator` and in the first iteration this will be `0` that we passed to `reduce`, for all subsequent iterations it will be the value passed by the `callback function`. The function is called for each element of the array and we also get the previous return value as `prev` to the function.\\n\\nSo, for nums = [4, 1, 2, 1, 2]. The function will calculate 0^4^1^2^1^2.\\n\\n```\\nfunction singleNumber(nums: number[]): number {\\n    return nums.reduce((prev, val) => prev ^ val, 0)\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Bit Manipulation"
                ],
                "code": "```\\nfunction singleNumber(nums: number[]): number {\\n    return nums.reduce((prev, val) => prev ^ val, 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2626069,
                "title": "easy-java-sol-by-xor-operation",
                "content": "//Xor operation\\n```\\n int res=0;\\n        for(int i : nums){\\n            res =res ^ i;\\n        }\\n        return res;\\n```\\n**Kindly upvote if you like sol**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n int res=0;\\n        for(int i : nums){\\n            res =res ^ i;\\n        }\\n        return res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1753472,
                "title": "easiest-java-solution-using-hashmap",
                "content": "```\\n#**Please upvote if you like the Solution\\nclass Solution {\\n    public int singleNumber(int[] nums) \\n    {\\n        Map<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(map.containsKey(nums[i]))\\n            {\\n                map.put(nums[i],map.get(nums[i])+1);\\n            }\\n            else\\n            {\\n                map.put(nums[i],1);\\n            }\\n        }\\n        int ans=0;\\n        for(int i:map.keySet())\\n        {\\n            if(map.get(i)==1)\\n            {\\n                ans=i;\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int singleNumber(int[] nums) \\n    {\\n        Map<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(map.containsKey(nums[i]))\\n            {\\n                map.put(nums[i],map.get(nums[i])+1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1682200,
                "title": "python-solution-using-xor-bits-116-ms-faster-than-99-54-with-comments",
                "content": "\\tdef singleNumber(self, nums: List[int]) -> int:\\n\\t\\t# This approach uses XOR bit operation\\n        # XOR with 0 will give that bit\\n        # XOR with same number will give 0\\n        # Hence in the end we will get the number which just occurs once in the array\\n        \\n        a = 0\\n        for i in nums:\\n            a ^= i\\n        return a\\n![image](https://assets.leetcode.com/users/images/36e97307-7867-4ac5-9bab-6c780ed39fe2_1641884096.3620715.png)\\n",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "\\tdef singleNumber(self, nums: List[int]) -> int:\\n\\t\\t# This approach uses XOR bit operation\\n        # XOR with 0 will give that bit\\n        # XOR with same number will give 0\\n        # Hence in the end we will get the number which just occurs once in the array\\n        \\n        a = 0\\n        for i in nums:\\n            a ^= i\\n        return a\\n![image](https://assets.leetcode.com/users/images/36e97307-7867-4ac5-9bab-6c780ed39fe2_1641884096.3620715.png)\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1547325,
                "title": "2-easy-approaches-explained-xor-and-hash-set-explained-with-example",
                "content": "*upvote and comment if you find this helpful*  <3\\n**Approach 1:**\\nThe function of XOR is to detect the presence of duplicate elements. XOR returns 0 if the elements are same else returns 1. \\nAccordingly,  \\n5^5 = 0, \\n5^0 = 5;\\n5^1 = negation(5)\\n\\nWhile traversing the array if the same element is encountered, the statement result = result ^ element will make dissolve the repeating element into zero. At the end of this iteration, only the unique element remains.\\nFor example,\\nnums = [2,3,1,1,2]\\nres = 0^2 \\nres =2^3^1^1 = 2^3^0 = 2^3\\nres =2^3^2 = 3^0 = 3\\nres =3 (answer)\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        \\n        //      1.\\n        /* USING BIT MANIPULATION - Constant space, optimized linear time */\\n       int result = 0;\\n        \\n        for (int element: nums)\\n        {\\n            result = result ^ element;\\n        }\\n        return result;\\n\\t\\t}\\n\\t}\\n```\\n\\n**Approach 2:**\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n    \\n        //      2.\\n        //USING COLLECTION FRAMEWORK- Linear time but extra space\\n    \\n        Set<Integer> setobj = new HashSet<Integer>();\\n        if (nums.length == 1)\\n            return nums[0];\\n        int ans=Integer.MIN_VALUE;\\n        \\n        for (int element: nums)\\n        {\\n            if (setobj.contains(element) == true)\\n            {\\n                setobj.remove(element);\\n            }\\n            \\n            else\\n                setobj.add(element);\\n        }\\n        \\n        for (int element: setobj)\\n        ans = element;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        \\n        //      1.\\n        /* USING BIT MANIPULATION - Constant space, optimized linear time */\\n       int result = 0;\\n        \\n        for (int element: nums)\\n        {\\n            result = result ^ element;\\n        }\\n        return result;\\n\\t\\t}\\n\\t}\\n```\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n    \\n        //      2.\\n        //USING COLLECTION FRAMEWORK- Linear time but extra space\\n    \\n        Set<Integer> setobj = new HashSet<Integer>();\\n        if (nums.length == 1)\\n            return nums[0];\\n        int ans=Integer.MIN_VALUE;\\n        \\n        for (int element: nums)\\n        {\\n            if (setobj.contains(element) == true)\\n            {\\n                setobj.remove(element);\\n            }\\n            \\n            else\\n                setobj.add(element);\\n        }\\n        \\n        for (int element: setobj)\\n        ans = element;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 558955,
                "title": "java-100-runtime-no-extra-space-and-o-n-complexity-using-xor-with-explaination",
                "content": "**XOR Properties**:\\n\\t\\t1.  n^n = 0 \\n\\t\\t2.  n^0 = n\\n\\nNow we use this property to iterate over the complete array and store it in the 0th index to save space\\neverything that is duplicated turns into 0 (using first property) and the single number left, that is unique is\\nremaining at 0 index because it has no duplicat, it is left.\\nTo understand this further try XOR over an array with all members having a pair. You would see that the final result would be 0. Therfore as the problem says there is one unique number which does not have a pair, remains as it is at the 0th index here.\\n\\n\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n      for(int i = 1; i < nums.length; i++) {\\n        nums[0] = nums[0] ^ nums[i];\\n      }\\n      return nums[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n      for(int i = 1; i < nums.length; i++) {\\n        nums[0] = nums[0] ^ nums[i];\\n      }\\n      return nums[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323132,
                "title": "c-code-12ms-faster-than-98-using-xor-vote-up-plz",
                "content": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int single_num = nums.at(0);\\n        for (int i = 1; i < nums.size(); i++) {\\n            single_num = single_num ^ nums.at(i);\\n        }\\n        return single_num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int single_num = nums.at(0);\\n        for (int i = 1; i < nums.size(); i++) {\\n            single_num = single_num ^ nums.at(i);\\n        }\\n        return single_num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 212520,
                "title": "xor-python",
                "content": "A number XOR itself will get result 0. And a number XOR 0 will get itself. For example,\\n```\\n>>> 1 ^ 1\\n0\\n>>> 0 ^ 2\\n2\\n```\\nIn this way, if we XOR numbers with each other: two identical numbers XOR to 0, the `standard` will be the single number finally.\\n> Version 1\\n```\\n    def singleNumber(self, nums):\\n        standard = 0\\n        for num in nums:\\n            standard = num ^ standard\\n        \\n        return standard\\n```\\n> Version 2\\n```\\nfrom functools import reduce\\n\\nclass Solution:\\n    def singleNumber(self, nums):\\n        return reduce(lambda a, b : a ^ b, nums)\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n>>> 1 ^ 1\\n0\\n>>> 0 ^ 2\\n2\\n```\n```\\n    def singleNumber(self, nums):\\n        standard = 0\\n        for num in nums:\\n            standard = num ^ standard\\n        \\n        return standard\\n```\n```\\nfrom functools import reduce\\n\\nclass Solution:\\n    def singleNumber(self, nums):\\n        return reduce(lambda a, b : a ^ b, nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43062,
                "title": "o-n-time-without-extra-space-java",
                "content": "```\\npublic int singleNumber(int[] nums) {\\n    if(nums.length == 1) {\\n        return nums[0];\\n    }\\n    for(int i = 1; i < nums.length; i++) {\\n        nums[0] ^= nums[i]; \\n    }\\n    return nums[0]; \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int singleNumber(int[] nums) {\\n    if(nums.length == 1) {\\n        return nums[0];\\n    }\\n    for(int i = 1; i < nums.length; i++) {\\n        nums[0] ^= nums[i]; \\n    }\\n    return nums[0]; \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43211,
                "title": "simple-20ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            int n = nums.size();\\n            int ans = 0;\\n            for(int i=0;i<n;i++){\\n                ans ^= nums[i];\\n            }\\n            return ans;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            int n = nums.size();\\n            int ans = 0;\\n            for(int i=0;i<n;i++){\\n                ans ^= nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3448433,
                "title": "best-three-solutions-in-java-in-runtime-6ms-and-beats-45-7",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code1\\nin Runtime 6ms and Beats 45.7%\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       Arrays.sort(nums);\\n\\n    for(int i=0; i<nums.length-1;i++)\\n    {\\n        if(nums[i]==nums[i+1]){\\n            i++;\\n        }else{\\n            return nums[i];\\n        }             \\n    }\\n        return nums[nums.length-1];\\n    }\\n}\\n```\\n\\n# Code2 \\nin Runtime 7ms and Beats 31.57%\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       Arrays.sort(nums);\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i == nums.length-1 ) return nums[i];\\n\\n                if (  nums[i] != nums[i+1]){\\n                    if (i == 0)\\n                    return nums[i];\\n                    \\n                    if (nums[i-1] != nums[i])\\n                        return nums[i];\\n\\n                }\\n\\n        }\\n\\n        return 0;\\n    }\\n}\\n```\\n\\n\\n# Code3\\n\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n         boolean cond = false;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            test1:for (int j = 0; j < nums.length; j++)\\n            {\\n                if (i != j && nums[i] == nums[j]){\\n                    cond = false;\\n                    break test1;\\n                }\\n                cond = true;\\n            }\\n\\n                if (cond)\\n                    return nums[i];\\n\\n        }\\n\\n        return 0;\\n    }\\n}\\n```\\n\\n\\n\\n![b0e5afaa-48ec-4dcc-bd96-e39aa7a524f8_1681948924.2890832.png](https://assets.leetcode.com/users/images/8b272e6c-3dd9-44e1-92d1-87a9a34fd04a_1682279216.3808486.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       Arrays.sort(nums);\\n\\n    for(int i=0; i<nums.length-1;i++)\\n    {\\n        if(nums[i]==nums[i+1]){\\n            i++;\\n        }else{\\n            return nums[i];\\n        }             \\n    }\\n        return nums[nums.length-1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       Arrays.sort(nums);\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i == nums.length-1 ) return nums[i];\\n\\n                if (  nums[i] != nums[i+1]){\\n                    if (i == 0)\\n                    return nums[i];\\n                    \\n                    if (nums[i-1] != nums[i])\\n                        return nums[i];\\n\\n                }\\n\\n        }\\n\\n        return 0;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n         boolean cond = false;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            test1:for (int j = 0; j < nums.length; j++)\\n            {\\n                if (i != j && nums[i] == nums[j]){\\n                    cond = false;\\n                    break test1;\\n                }\\n                cond = true;\\n            }\\n\\n                if (cond)\\n                    return nums[i];\\n\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040043,
                "title": "one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPick the odd one using XOR operator\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOne line solution\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nLinear Time Complexity\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nConstant Space Complexity\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar singleNumber = function(arr) {\\n\\n// SOLUTION I \\n\\n//    const count = arr.reduce((obj, curr)=>{\\n//        if(obj[curr] == undefined)\\n//        obj[curr] = 1\\n//        else\\n//        obj[curr]++\\n\\n//        return obj\\n//    }, {})\\n\\n\\n//     for(const[key, value] of Object.entries(count)){\\n//         if(value === 1){\\n//         return key;\\n//         }\\n//     }\\n    \\n// SOLUTION II\\n\\n    // let res = 0, i, n = arr.length;\\n    // for (i = 0; i < n; i++)\\n    //     res ^= arr[i];\\n    // return res;\\n\\n// SOLUTION III\\n\\n    return arr.reduce((prev, curr) => prev^curr)\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar singleNumber = function(arr) {\\n\\n// SOLUTION I \\n\\n//    const count = arr.reduce((obj, curr)=>{\\n//        if(obj[curr] == undefined)\\n//        obj[curr] = 1\\n//        else\\n//        obj[curr]++\\n\\n//        return obj\\n//    }, {})\\n\\n\\n//     for(const[key, value] of Object.entries(count)){\\n//         if(value === 1){\\n//         return key;\\n//         }\\n//     }\\n    \\n// SOLUTION II\\n\\n    // let res = 0, i, n = arr.length;\\n    // for (i = 0; i < n; i++)\\n    //     res ^= arr[i];\\n    // return res;\\n\\n// SOLUTION III\\n\\n    return arr.reduce((prev, curr) => prev^curr)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3035192,
                "title": "beats-99-31-memory-beginner-friendly-using-indexof-and-lastindexof",
                "content": "# Code\\n```\\nfunction singleNumber(nums: number[]): number {\\n   if(nums.length === 1) return nums[0];\\n   \\n   for(let i = 0; i < nums.length; i++){\\n       if(nums.indexOf(nums[i]) === nums.lastIndexOf(nums[i])){\\n           return nums[i]\\n       }\\n   }\\n   return null;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction singleNumber(nums: number[]): number {\\n   if(nums.length === 1) return nums[0];\\n   \\n   for(let i = 0; i < nums.length; i++){\\n       if(nums.indexOf(nums[i]) === nums.lastIndexOf(nums[i])){\\n           return nums[i]\\n       }\\n   }\\n   return null;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2812149,
                "title": "java-easy-fast-2-approaches-bit-manipulation-xor",
                "content": "**Approach 1 -Using hashmap**\\nMaintain Hashmap and check the count against array and return the elements if we found the one as a value, \\nSince there is only one unique element as soon as we get value as 1 we return that element.\\nTC - O(N)\\nSC- O(Min(n,m)) \\n\\n\\n    class Solution{\\n\\t\\tpublic int singleNumber(int[] nums){\\n\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n\\t\\n\\t\\tfor (int i : nums) {\\n\\t\\t  map.put(i, map.getOrDefault(i, 0) + 1);\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (int i : nums) {\\n\\t\\t\\t  if (map.get(i) == 1) {\\n\\t\\t\\t\\treturn i;\\n\\t\\t\\t  }\\n\\t\\t}\\n    return 0;\\n  }\\n}\\n\\n\\n**Approach 2 -Using BitManipulation**\\nProperties of XOR:\\n1. It returns the same number if weXOR with zero.\\n2. It return zero if we take XOR of two same numbers.\\n\\nSo We can XOR all the numbers in the given input, as per XOR properties; all the duplicate number will zero out each other and we will be left with single number.\\nTC - O(N)\\nSC- O(1) \\n\\n\\tclass Solution { \\n\\tpublic int singleNumber(int[] nums) {\\n\\t\\tint num = 0;\\n \\n\\t\\tfor (int i : nums) {\\n\\t\\t  num =num ^ i;\\n\\t\\t}\\n\\t\\treturn num;\\n\\t}\\n}\\n\\n\\n\\n\\t\\n",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution{\\n\\t\\tpublic int singleNumber(int[] nums){\\n\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n\\t\\n\\t\\tfor (int i : nums) {\\n\\t\\t  map.put(i, map.getOrDefault(i, 0) + 1);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1771850,
                "title": "easy-python-solution",
                "content": "```\\ndef singleNumber(self, nums: List[int]) -> int:\\n        c=Counter(nums)\\n        for i in nums:\\n            if c[i]==1:\\n                return i\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef singleNumber(self, nums: List[int]) -> int:\\n        c=Counter(nums)\\n        for i in nums:\\n            if c[i]==1:\\n                return i\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1753083,
                "title": "c-fastest-3-line-solution",
                "content": "**AN UPVOTE WOULD BE HIGHLY APPRECIATED**\\n\\n****Optimised Approach**\\n*  Since in XOR Operations 0^0 = 0 and 1^1 = 0.\\n* Hence here the same bits(numbers) will cancel out each other i.e result to zero and only the unique bit(number) will be left.!!!\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int c=0;\\n        for(auto cc:nums)c^=cc;\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int c=0;\\n        for(auto cc:nums)c^=cc;\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1423042,
                "title": "java-solution-o-n",
                "content": "Try to dry run the code for a sample input to understand what goes beneath! \\nRemember, \\n1. 0 XOR num = num\\n2. num XOR num = 0\\n\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            ans = ans^nums[i];\\n        }\\n     return ans;   \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            ans = ans^nums[i];\\n        }\\n     return ans;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1092980,
                "title": "2-simple-way-solution-with-explanation-cpp",
                "content": "First solution (by comparing elements):\\n```\\nint singleNumber(vector<int>& nums) {\\n        if (nums.size() > 1)\\n        {\\n            sort(nums.begin(), nums.end());\\n            for(int i = 0; i < nums.size()-1; i+=2)\\n            {\\n                if(nums[i] != nums[i+1])\\n                {\\n                    return nums[i];\\n                }\\n            }\\n        }\\n        return nums[nums.size()-1];\\n    }\\n```\\n\\nSecond solution (using bitwise XOR):\\n```\\nint singleNumber(vector<int>& nums) {\\n        int result = 0;\\n        for(int i : nums)\\n        {\\n            result ^= i;\\n        }\\n        return result;\\n    }\\n```\\nHow does it work? \\nfor example, we have input vector {4,1,2,1,2}\\nres = 0, next element = 4\\nres = 000 ^ 100 = 100\\n\\nres = 4, next element = 1\\nres = 100 ^ 001 = 101\\n\\nres = 5, next element = 2\\nres = 101 ^ 010 = 111\\n\\nres = 7, next element = 1\\nres = 111 ^ 001 = 110\\n\\nres = 6, next element = 2\\nres = 110 ^ 010 = 100\\n\\nfinally res = 4, as expected =)\\n\\n\\n**Please, upvote, if it was useful for you..**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint singleNumber(vector<int>& nums) {\\n        if (nums.size() > 1)\\n        {\\n            sort(nums.begin(), nums.end());\\n            for(int i = 0; i < nums.size()-1; i+=2)\\n            {\\n                if(nums[i] != nums[i+1])\\n                {\\n                    return nums[i];\\n                }\\n            }\\n        }\\n        return nums[nums.size()-1];\\n    }\\n```\n```\\nint singleNumber(vector<int>& nums) {\\n        int result = 0;\\n        for(int i : nums)\\n        {\\n            result ^= i;\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 225006,
                "title": "java-solutions",
                "content": "**Solution 1: Bit Manipulation - Using XOR**\\n\\n- If we take XOR of zero and some bit, it will return that bit\\n`a ^ 0 = a`\\n\\n- If we take XOR of two same bits, it will return 0\\n`a ^ a = 0`\\n\\n- XOR operator is commutative\\n`a ^ b ^ a = (a ^ a) ^ b = 0 ^ b = b`\\n\\nSo we can XOR all bits together to find the unique number.\\n\\nTime complexity: `O(n)`\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution \\n{\\n    public int singleNumber(int[] A)\\n    {\\n        int result = 0;\\n        \\n        for(int n : A)\\n            result ^= n;\\n        \\n        return result;\\n    }\\n}\\n```\\n\\n**Solution 2: General Solution for K**\\n\\nTime complexity: `O(n)`\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution\\n{\\n\\tpublic int singleNumber(int[] A)\\n\\t{\\n\\t\\tint result = 0;\\n\\t\\tint K = 2;\\t\\t\\t\\t\\t\\t// Every element appears twice except for one\\n\\t\\t\\n\\t\\tfor(int i = 0; i < 32; i++)\\n\\t\\t{\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor(int n: A)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif((n >> i & 1) == 1)\\n\\t\\t\\t\\t\\tsum++;\\n\\t\\t\\t}\\n\\t\\t\\tsum %= K;\\n\\t\\t\\tresult |= sum << i;\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n}\\n```\\n\\n**Solution 3: Using Set**\\n\\nTime complexity: `O(n)`\\nSpace complexity: `O(n)`\\n\\n```\\nclass Solution \\n{\\n    public int singleNumber(int[] A)\\n    {\\n        Set<Integer> set = new HashSet<>();\\n        \\n        for(int n : A)\\n        {\\n            if(set.contains(n))\\n                set.remove(n);\\n            else\\n                set.add(n);\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public int singleNumber(int[] A)\\n    {\\n        int result = 0;\\n        \\n        for(int n : A)\\n            result ^= n;\\n        \\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n\\tpublic int singleNumber(int[] A)\\n\\t{\\n\\t\\tint result = 0;\\n\\t\\tint K = 2;\\t\\t\\t\\t\\t\\t// Every element appears twice except for one\\n\\t\\t\\n\\t\\tfor(int i = 0; i < 32; i++)\\n\\t\\t{\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor(int n: A)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif((n >> i & 1) == 1)\\n\\t\\t\\t\\t\\tsum++;\\n\\t\\t\\t}\\n\\t\\t\\tsum %= K;\\n\\t\\t\\tresult |= sum << i;\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n}\\n```\n```\\nclass Solution \\n{\\n    public int singleNumber(int[] A)\\n    {\\n        Set<Integer> set = new HashSet<>();\\n        \\n        for(int n : A)\\n        {\\n            if(set.contains(n))\\n                set.remove(n);\\n            else\\n                set.add(n);\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43169,
                "title": "c-solution-using-xor",
                "content": "    class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            int res=0;\\n            for(auto num : nums)\\n                res ^= num;\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            int res=0;\\n            for(auto num : nums)\\n                res ^= num;\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 43181,
                "title": "share-my-c-solution-using-xor",
                "content": "***We can verify the associative law and the commutative law for XOR,and x^x = 0, x^0 = x***\\n\\n    class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            int n = nums.size(), i = 0, ret = 0;\\n            \\n            for (i = 0; i < n; ++i)\\n                ret ^= nums[i];\\n                \\n            return ret;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            int n = nums.size(), i = 0, ret = 0;\\n            \\n            for (i = 0; i < n; ++i)\\n                ret ^= nums[i];\\n                \\n            return ret;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 43226,
                "title": "1-line-c-shortest-solution",
                "content": "The whole idea is to XOR all the elements and the value that we get after XORing all the elements is the element which appears only once in the array. \\n\\nBy default, accumulate adds up every element in the range. Since, we want to XOR all the elements int he range and not add them, we can specify bit_xor function. This can be done in 1 line in C++ :\\n\\n    int singleNumber(vector<int>& nums) {\\n            \\n        return nums.size() == 0 ? 0 : accumulate(nums.begin(), nums.end(), 0, bit_xor<int>());\\n            \\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "The whole idea is to XOR all the elements and the value that we get after XORing all the elements is the element which appears only once in the array. \\n\\nBy default, accumulate adds up every element in the range. Since, we want to XOR all the elements int he range and not add them, we can specify bit_xor function. This can be done in 1 line in C++ :\\n\\n    int singleNumber(vector<int>& nums) {\\n            \\n        return nums.size() == 0 ? 0 : accumulate(nums.begin(), nums.end(), 0, bit_xor<int>());\\n            \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 43230,
                "title": "very-concise-java-solution-using-xor",
                "content": "    public class Solution {\\n        public int singleNumber(int[] A) {\\n            int result = 0;\\n            for (int i=0; i<A.length; i++){\\n                result = result ^ A[i];\\n            }\\n            return result;    \\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int singleNumber(int[] A) {\\n            int result = 0;\\n            for (int i=0; i<A.length; i++){\\n                result = result ^ A[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3205701,
                "title": "136-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this algorithm is O(n), where n is the length of the input array, since we loop through the entire array once.\\n\\n- Space complexity:\\nThe space complexity is O(1), since we only use a constant amount of extra space to store the result variable.\\n\\n# Code\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        \"\"\"\\n        Given a non-empty array of integers nums, every element appears twice except for one.\\n        Find that single one.\\n        \"\"\"\\n        # We\\'ll use the XOR operator to find the single number that appears only once\\n        # XORing a number with itself gives 0, so all the pairs will cancel each other out\\n        # The result will be the number that appears only once\\n        result = 0\\n    \\n        # XOR all the numbers in the list\\n        for num in nums:\\n            result ^= num\\n    \\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        \"\"\"\\n        Given a non-empty array of integers nums, every element appears twice except for one.\\n        Find that single one.\\n        \"\"\"\\n        # We\\'ll use the XOR operator to find the single number that appears only once\\n        # XORing a number with itself gives 0, so all the pairs will cancel each other out\\n        # The result will be the number that appears only once\\n        result = 0\\n    \\n        # XOR all the numbers in the list\\n        for num in nums:\\n            result ^= num\\n    \\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2538019,
                "title": "java-xor-solution-explained",
                "content": "-If we use XOR operator between two same values , it will return zero.\\n-If one of the value is zero, and the other is non-zero, it returns the non-zero value.\\n\\n***XOR\\nX^X = 0\\n0^X = X***\\n\\nConsider an array [1,2,1,3,3] -\\n-> (1^2^1^3^3) = 2, it doesn\\'t matter what the order is.\\n\\n```\\npublic int singleNumber(int[] nums) {\\n\\n        int n = nums.length;\\n        int ans = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            ans ^= nums[i]; \\n        }\\n        return ans;\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "-If we use XOR operator between two same values , it will return zero.\\n-If one of the value is zero, and the other is non-zero, it returns the non-zero value.\\n\\n***XOR\\nX^X = 0\\n0^X = X***\\n\\nConsider an array [1,2,1,3,3] -\\n-> (1^2^1^3^3) = 2, it doesn\\'t matter what the order is.\\n\\n```\\npublic int singleNumber(int[] nums) {\\n\\n        int n = nums.length;\\n        int ans = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            ans ^= nums[i]; \\n        }\\n        return ans;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2441785,
                "title": "solved-using-bitwise-xor-with-full-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/605f0c08-55a9-4446-a149-167a47bd69b7_1660786303.7149374.png)\\n\\nXOR Rules in simple terms:\\n\\t1. It returns zero if we take XOR of two same numbers.\\n\\t2. It returns the same number if we XOR with zero.\\n\\n```\\n// check for valid input\\nif (nums.length < 1) return 0;\\n\\t// initialize variable\\n    let num = 0;\\n\\t\\n\\t// iterate through the nums array and XOR all the numbers in the input, \\n\\t// As stated in the rule above, duplicate numbers will zero out each other and we will be left with the single number.\\n    for (let i = 0; i < nums.length; i++) {\\n        num ^= nums[i];\\n    }\\n\\n    return num;\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// check for valid input\\nif (nums.length < 1) return 0;\\n\\t// initialize variable\\n    let num = 0;\\n\\t\\n\\t// iterate through the nums array and XOR all the numbers in the input, \\n\\t// As stated in the rule above, duplicate numbers will zero out each other and we will be left with the single number.\\n    for (let i = 0; i < nums.length; i++) {\\n        num ^= nums[i];\\n    }\\n\\n    return num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1675221,
                "title": "c-accepted-100-more-xor-based-tricks",
                "content": "This post includes the solution to this problem and one more XOR based trick that you might find useful in future. \\nFirst things first, XOR can be a useful bitwise operation given the range of properties it offers. This question exploits 2 such properties, i.e, XOR of any 2 similar numbers will give us a 0 value and XOR of any number with 0 gives us the same number. \\n\\na^a =0;\\n0^a=a;\\n\\nSo, the very first thing that comes into our minds if we know these properties is we can simply XOR all elements in the array and store the value as we loop through, in an integer ans. \\nAs we find a copy of any value, our ans variable will be initialized back to 0 (a^a=0) and at last the only unique element will be left with us which we can return. \\n\\nCode: \\n```\\nint singleNumber(vector<int>& nums) {\\n        int ans=0; \\n        for(int x: nums){\\n            ans^=x;\\n        }\\n        return ans;\\n    }\\n```\\n\\nNow for another XOR property that might come in handy:\\n\\n- In-place swapping of 2 numbers:  We can swap 2 numbers in place by just 3 lines of a XOR code, that goes:\\n\\n```\\nvoid swapInplace(int x, int y){\\n\\tx ^= y\\n\\ty ^= x\\n\\tx ^= y\\n}\\n```\\n\\nThe logical explaination of the code aforementioned is something like:\\n```\\nx ^= y # =>                      (x ^ y, y)\\ny ^= x # => (x ^ y, y ^ x ^ y) = (x ^ y, x)\\nx ^= y # => (x ^ y ^ x, x)     = (y, x)\\n```\\n\\nAlthough all this can be done the conventional ways too, I think it is good to know how to solve a particular problem a few different ways. Hope it helps. \\n\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint singleNumber(vector<int>& nums) {\\n        int ans=0; \\n        for(int x: nums){\\n            ans^=x;\\n        }\\n        return ans;\\n    }\\n```\n```\\nvoid swapInplace(int x, int y){\\n\\tx ^= y\\n\\ty ^= x\\n\\tx ^= y\\n}\\n```\n```\\nx ^= y # =>                      (x ^ y, y)\\ny ^= x # => (x ^ y, y ^ x ^ y) = (x ^ y, x)\\nx ^= y # => (x ^ y ^ x, x)     = (y, x)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1360149,
                "title": "c-xor-o-1-space-time-explained",
                "content": "we use bitwise XOR to solve this problem :\\n\\nfirst , we have to know the bitwise XOR in java\\n\\n0 ^ N = N\\nN ^ N = 0\\nSo..... if N is the single number\\n\\nN1 ^ N1 ^ N2 ^ N2 ^..............^ Nx ^ Nx ^ N\\n(since XOR is associative thus the order doesn\\'t matter )\\n\\n= (N1^N1) ^ (N2^N2) ^..............^ (Nx^Nx) ^ N\\n\\n= 0 ^ 0 ^ ..........^ 0 ^ N\\n\\n= N\\n\\n\\n```\\n    int singleNumber(vector<int>& nums)\\n    {\\n        int temp=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            temp=temp^nums[i];\\n        }\\n        return temp;\\n    }\\n\\t\\n\\t\\n```\\n\\nIf you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo please do upvote and encourage me to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int singleNumber(vector<int>& nums)\\n    {\\n        int temp=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            temp=temp^nums[i];\\n        }\\n        return temp;\\n    }\\n\\t\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1346064,
                "title": "python-2-solutions-in-o-n-with-explanation-faster-than-94",
                "content": "# Solution 1:\\n# Using Map:-\\n\\nUsing map which will store the count of each element in the hashmap.\\n```\\ndef singleNumber(self, nums: List[int]) -> int:\\n         mp = [0]*100000\\n         for i in range(len(nums)):\\n             nums[i] += 30000\\n        \\n         for i in range(len(nums)):\\n             mp[nums[i]]+=1\\n            \\n         for j in range(len(mp)):\\n             if mp[j] ==1:\\n                 return j - 30000\\n         return -1\\n```\\n\\n# Solution2:\\n# Using maths :- \\nFormula: 2*(a+b+c) - (a+a+b+b+c) = c\\n\\n```\\ndef singleNumber(self, nums: List[int]) -> int:\\n\\treturn 2*sum(set(nums)) - sum(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef singleNumber(self, nums: List[int]) -> int:\\n         mp = [0]*100000\\n         for i in range(len(nums)):\\n             nums[i] += 30000\\n        \\n         for i in range(len(nums)):\\n             mp[nums[i]]+=1\\n            \\n         for j in range(len(mp)):\\n             if mp[j] ==1:\\n                 return j - 30000\\n         return -1\\n```\n```\\ndef singleNumber(self, nums: List[int]) -> int:\\n\\treturn 2*sum(set(nums)) - sum(nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1216856,
                "title": "python-solutions",
                "content": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        \\n        # Brute force version\\n        # T: O(N)\\n        # S: O(N)\\n        \\n        d = {}\\n        for i in nums:\\n            if i in d:\\n                d[i] += 1\\n            else:\\n                d[i] = 1\\n        \\n        for k,v in d.items():\\n            if v == 1:\\n                return k\\n            \\n    def singleNumber(self, nums: List[int]) -> int:\\n        \\n        # Brute force version 2.0, Using python library to build dictionary\\n        # T: O(N)\\n        # S: O(N)\\n        \\n        d = Counter(nums)\\n        \\n        for k,v in d.items():\\n            if v == 1:\\n                return k\\n            \\n    def singleNumber(self, nums: List[int]) -> int:\\n        \\n        # Bitwise operation\\n        # 1 xor 1 gives 0. 2 xor 2 gives 0\\n        # what it means 1 xor 1, 2 xor 2, 3 xor 3 will always give you 0\\n        # [4,1,2,1,2] - > [4] will stay as 4 [1,2,1,2] will cancel each other. \\n        # T: O(N)\\n        # S: O(1)\\n        \\n        combined = 0\\n        for i in nums:\\n            combined ^= i\\n        \\n        return combined\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        \\n        # Brute force version\\n        # T: O(N)\\n        # S: O(N)\\n        \\n        d = {}\\n        for i in nums:\\n            if i in d:\\n                d[i] += 1\\n            else:\\n                d[i] = 1\\n        \\n        for k,v in d.items():\\n            if v == 1:\\n                return k\\n            \\n    def singleNumber(self, nums: List[int]) -> int:\\n        \\n        # Brute force version 2.0, Using python library to build dictionary\\n        # T: O(N)\\n        # S: O(N)\\n        \\n        d = Counter(nums)\\n        \\n        for k,v in d.items():\\n            if v == 1:\\n                return k\\n            \\n    def singleNumber(self, nums: List[int]) -> int:\\n        \\n        # Bitwise operation\\n        # 1 xor 1 gives 0. 2 xor 2 gives 0\\n        # what it means 1 xor 1, 2 xor 2, 3 xor 3 will always give you 0\\n        # [4,1,2,1,2] - > [4] will stay as 4 [1,2,1,2] will cancel each other. \\n        # T: O(N)\\n        # S: O(1)\\n        \\n        combined = 0\\n        for i in nums:\\n            combined ^= i\\n        \\n        return combined\\n```",
                "codeTag": "Java"
            },
            {
                "id": 834478,
                "title": "java-c-c-super-simple-solution-0-ms-100-faster",
                "content": "**Like it? please upvote...**\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = nums[0];\\n        for (int i=1; i<nums.length; i++)\\n            res ^= nums[i];\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = nums[0];\\n        for (int i=1; i<nums.length; i++)\\n            res ^= nums[i];\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 579498,
                "title": "java-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ret = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            ret ^= nums[i];\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ret = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            ret ^= nums[i];\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 428189,
                "title": "php-1-line-beats-100-time-and-space",
                "content": "Independent bitwise xor function:\\n\\n\\tfunction singleNumber($A) {\\n\\t\\tfunction bitwise_xor($x, $y){\\n\\t\\t\\treturn $x ^ $y;\\n\\t\\t}\\n        return array_reduce($A, \"bitwise_xor\");\\n    }\\n\\nIn-line anonymous function:\\n\\n\\tfunction singleNumber($A) {\\n        return array_reduce($A, function($x, $y){ return $x ^ $y; });\\n    }",
                "solutionTags": [
                    "PHP"
                ],
                "code": "Independent bitwise xor function:\\n\\n\\tfunction singleNumber($A) {\\n\\t\\tfunction bitwise_xor($x, $y){\\n\\t\\t\\treturn $x ^ $y;\\n\\t\\t}\\n        return array_reduce($A, \"bitwise_xor\");\\n    }\\n\\nIn-line anonymous function:\\n\\n\\tfunction singleNumber($A) {\\n        return array_reduce($A, function($x, $y){ return $x ^ $y; });\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 314884,
                "title": "my-4-swift-solutions",
                "content": "```\\n\\n// Bit manipulation solution\\nfunc findSingleNumber(_ nums: [Int]) -> Int {\\n    var result = 0\\n    for number in nums {\\n        result ^= number\\n    }\\n    return result\\n}\\n\\nassert(findSingleNumber([2,2,1]) == 1, \"Failed\")\\nassert(findSingleNumber([4,1,2,1,2]) == 4, \"Failed\")\\n\\n// Time Limit Exceeded - Array Solution - O(n\\u02C62)\\nfunc findSingleNumber2(_ nums: [Int]) -> Int {\\n    var array: [Int] = []\\n    for number in nums {\\n        if let index = array.firstIndex(of: number) {\\n            array.remove(at: index)\\n        } else {\\n            array.append(number)\\n        }\\n    }\\n    return array.first ?? 0\\n}\\n\\nassert(findSingleNumber2([2,2,1]) == 1, \"Failed\")\\nassert(findSingleNumber2([4,1,2,1,2]) == 4, \"Failed\")\\n\\n// Hash Table Solution\\nfunc findSingleNumber3(_ nums: [Int]) -> Int {\\n    var table: [Int: Int] = [:]\\n    for number in nums {\\n        if table[number] != nil {\\n            table[number] = nil\\n        } else {\\n            table[number, default: 0] += 1\\n        }\\n    }\\n    return table.first?.key ?? 0\\n}\\n\\nassert(findSingleNumber3([2,2,1]) == 1, \"Failed\")\\nassert(findSingleNumber3([4,1,2,1,2]) == 4, \"Failed\")\\n\\n// Math Solution\\n// 1. Sum of all numbers: a + a + b + c + c = 2a + 2c + b\\n// 2. Sum of unique numbers: a + b + c\\n// 3. Multiply by 2 unique sum: 2a + 2b + 2c\\n// 4. Subtract: 2a + 2b + 2c - (2a + 2c + b) = b\\n// 5 Formula: singleNumber = 2 * Sum(Set(nums)) - sum(nums)\\n\\nfunc findSingleNumber4(_ nums: [Int]) -> Int {\\n    let setSum2 = 2 * Set(nums).reduce(0, +)\\n    let numsSum = nums.reduce(0, +)\\n    return setSum2 - numsSum\\n}\\n\\nassert(findSingleNumber4([2,2,1]) == 1, \"Failed\")\\nassert(findSingleNumber4([4,1,2,1,2]) == 4, \"Failed\")\\n\\n```",
                "solutionTags": [
                    "Swift",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\n// Bit manipulation solution\\nfunc findSingleNumber(_ nums: [Int]) -> Int {\\n    var result = 0\\n    for number in nums {\\n        result ^= number\\n    }\\n    return result\\n}\\n\\nassert(findSingleNumber([2,2,1]) == 1, \"Failed\")\\nassert(findSingleNumber([4,1,2,1,2]) == 4, \"Failed\")\\n\\n// Time Limit Exceeded - Array Solution - O(n\\u02C62)\\nfunc findSingleNumber2(_ nums: [Int]) -> Int {\\n    var array: [Int] = []\\n    for number in nums {\\n        if let index = array.firstIndex(of: number) {\\n            array.remove(at: index)\\n        } else {\\n            array.append(number)\\n        }\\n    }\\n    return array.first ?? 0\\n}\\n\\nassert(findSingleNumber2([2,2,1]) == 1, \"Failed\")\\nassert(findSingleNumber2([4,1,2,1,2]) == 4, \"Failed\")\\n\\n// Hash Table Solution\\nfunc findSingleNumber3(_ nums: [Int]) -> Int {\\n    var table: [Int: Int] = [:]\\n    for number in nums {\\n        if table[number] != nil {\\n            table[number] = nil\\n        } else {\\n            table[number, default: 0] += 1\\n        }\\n    }\\n    return table.first?.key ?? 0\\n}\\n\\nassert(findSingleNumber3([2,2,1]) == 1, \"Failed\")\\nassert(findSingleNumber3([4,1,2,1,2]) == 4, \"Failed\")\\n\\n// Math Solution\\n// 1. Sum of all numbers: a + a + b + c + c = 2a + 2c + b\\n// 2. Sum of unique numbers: a + b + c\\n// 3. Multiply by 2 unique sum: 2a + 2b + 2c\\n// 4. Subtract: 2a + 2b + 2c - (2a + 2c + b) = b\\n// 5 Formula: singleNumber = 2 * Sum(Set(nums)) - sum(nums)\\n\\nfunc findSingleNumber4(_ nums: [Int]) -> Int {\\n    let setSum2 = 2 * Set(nums).reduce(0, +)\\n    let numsSum = nums.reduce(0, +)\\n    return setSum2 - numsSum\\n}\\n\\nassert(findSingleNumber4([2,2,1]) == 1, \"Failed\")\\nassert(findSingleNumber4([4,1,2,1,2]) == 4, \"Failed\")\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 154920,
                "title": "five-line-javascript-solution",
                "content": "Compare indexOf and lastIndexOf each element, if equal, the number is single.\\n```\\nvar singleNumber = function(nums) {\\n    for(var i=0;i<nums.length;i++) {\\n        if(nums.indexOf(nums[i]) === nums.lastIndexOf(nums[i])) return nums[i];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar singleNumber = function(nums) {\\n    for(var i=0;i<nums.length;i++) {\\n        if(nums.indexOf(nums[i]) === nums.lastIndexOf(nums[i])) return nums[i];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43244,
                "title": "shortest-solution-with-c",
                "content": "     while (--n)\\n\\tA[n - 1] ^= A[n];\\n    return A[0];",
                "solutionTags": [],
                "code": "     while (--n)\\n\\tA[n - 1] ^= A[n];\\n    return A[0];",
                "codeTag": "Unknown"
            },
            {
                "id": 43275,
                "title": "my-linear-complexity-without-using-extra-memory-solution",
                "content": "Hi all,\\n\\nI have a different solution here which take no extra memory. This algorithm is based on the three way partition method. First, choose a element in the array as pivot. Second, split this array to three partition, less than pivot, equal to pivot and greater than pivot. Now we have three partitions and we also know the size of these three partitions too. If the single number in any partition, the size of this partition must be 2*n+1, and should not be divisible by 2. Last, we just recursively find the single number in the partition which size can not be divisible by 2.\\n\\nThis method can be easily modified to solve the single number 2 problem.\\n\\n\\n    void swap(int A[], int a, int b)\\n    {\\n        int t = A[a];\\n        A[a] = A[b];\\n        A[b] = t;\\n    }\\n    \\n    void threeWayPartition(int A[], int n, int&l, int&h)\\n    {\\n        int pivot = A[0];\\n        int j = -1;\\n        int k = n;\\n        \\n        for (int i=0; i<k;)\\n        {\\n            if (A[i] < pivot)\\n            {\\n                swap(A, i, ++j);\\n                i++;\\n            }\\n            else if (A[i] > pivot)\\n            {\\n                swap(A, i, --k);\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        \\n        l = j;\\n        h = k;\\n    }\\n    \\n    #define APPEAR_NUMBER (2)\\n    \\n    class Solution {\\n    public:\\n        int singleNumber(int A[], int n) {\\n            if (n==1)\\n            {\\n                return A[0];\\n            }\\n    \\n            int l=0;\\n            int h=0;\\n            threeWayPartition(A, n, l, h);\\n            \\n            int p = l+1;\\n    \\n            if (A[p] != A[p+1])\\n            {\\n                return A[p];\\n            }\\n            else if(p%APPEAR_NUMBER == 0)\\n            {\\n                return singleNumber(A+(p+APPEAR_NUMBER), n-(p+APPEAR_NUMBER));\\n            }\\n            else\\n            {\\n                return singleNumber(A, p);\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int singleNumber(int A[], int n) {\\n            if (n==1)\\n            {\\n                return A[0];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3349420,
                "title": "c-solution-using-maps-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere we have an array, where every single element is repeated twice, but there is one element which is occuring only one. we will need to count it and then print it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt can be solved using the bit manipulation technique as well as using the mapping technique. Here we have used the mapping technique. To keep track of the count of the number.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n          unordered_map<int,int> mp;\\n          for(int i=0;i<nums.size();i++){\\n              mp[nums[i]]++;\\n          }\\n\\n        //   for(auto it: mp){\\n        //       cout<<it.first<<\" \"<<it.second<<endl;\\n        //   }\\n          \\n          for(auto it: mp){\\n              if(it.second==1){ return it.first; break;}\\n          }\\n          return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n          unordered_map<int,int> mp;\\n          for(int i=0;i<nums.size();i++){\\n              mp[nums[i]]++;\\n          }\\n\\n        //   for(auto it: mp){\\n        //       cout<<it.first<<\" \"<<it.second<<endl;\\n        //   }\\n          \\n          for(auto it: mp){\\n              if(it.second==1){ return it.first; break;}\\n          }\\n          return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2788653,
                "title": "pythonic",
                "content": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        stack=[]\\n        if len(nums)==1:\\n            return nums[0]\\n        for i in range(len(nums)):\\n            if nums[i] not  in stack :\\n                stack.append(nums[i])\\n            else:\\n                stack.pop()\\n        return stack[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        stack=[]\\n        if len(nums)==1:\\n            return nums[0]\\n        for i in range(len(nums)):\\n            if nums[i] not  in stack :\\n                stack.append(nums[i])\\n            else:\\n                stack.pop()\\n        return stack[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678049,
                "title": "python-3-fastest-solution-faster-than-96-of-submissions",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def singleNumber(self, nums):\\n      a = dict(Counter(nums))\\n      b = [k for k, v in a.items() if v==1]\\n      return b[0]\\n\\t  \\n```\\n\\nUpvote if you like the solution. Feel free to ask any question",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def singleNumber(self, nums):\\n      a = dict(Counter(nums))\\n      b = [k for k, v in a.items() if v==1]\\n      return b[0]\\n\\t  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547758,
                "title": "easy-python3-solution",
                "content": "if it is helpful please ***upvote*** me\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        xor = 0\\n        for num in nums:\\n            xor ^= num\\n        return xor\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        xor = 0\\n        for num in nums:\\n            xor ^= num\\n        return xor\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1773553,
                "title": "java-simple-short-and-easy-solution-bit-manipulation-xor",
                "content": "```\\n//logic is very simple -> xor of two same number cancel each other( in simple word ) \\n//because xor of two same number equals zero\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int result = 0;\\n        for(int i : nums)\\n            result ^= i;\\n        \\n        return result;\\n    }\\n}\\n\\n//please upvote",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int result = 0;\\n        for(int i : nums)\\n            result ^= i;\\n        \\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1739614,
                "title": "solution-swift-single-number-test-cases",
                "content": "```swift\\nclass Solution {\\n    func singleNumber(_ nums: [Int]) -> Int {\\n        var result = nums[0]\\n        for n in nums[1...] { result ^= n }\\n        return result\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 3 tests, with 0 failures (0 unexpected) in 0.017 (0.019) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.singleNumber([2,2,1])\\n        XCTAssertEqual(value, 1)\\n    }\\n    \\n    func test1() {\\n        let value = solution.singleNumber([4,1,2,1,2])\\n        XCTAssertEqual(value, 4)\\n    }\\n    \\n    func test2() {\\n        let value = solution.singleNumber([1])\\n        XCTAssertEqual(value, 1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func singleNumber(_ nums: [Int]) -> Int {\\n        var result = nums[0]\\n        for n in nums[1...] { result ^= n }\\n        return result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.singleNumber([2,2,1])\\n        XCTAssertEqual(value, 1)\\n    }\\n    \\n    func test1() {\\n        let value = solution.singleNumber([4,1,2,1,2])\\n        XCTAssertEqual(value, 4)\\n    }\\n    \\n    func test2() {\\n        let value = solution.singleNumber([1])\\n        XCTAssertEqual(value, 1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523589,
                "title": "all-possible-solutions-by-ashay-nayak-best-solution-o-n",
                "content": "Please **upvote** if you find it helpful. Thank You.\\n**Purpose** - Practice of thinking all possible solution which help you in **interviews**.\\nFeel free to comment below if you don\\'t get anything. I will surely reply back **within 12 hours**.\\npossible solutions,\\nSee read the question twice that **every element appears twice except for one.**\\n1.) Using 2 for loops - TC - O(n^2) and SC - O(1)  -  please try to think by yourself and if you don\\'t get it then comment below.\\n\\n2.) Using HashMap - two iteration required - TC - O(n) and SC - O(n)  - Iterate through each element of nums array and increment it\\'s count in map. Here, key will be element present in nums and value will be the count. Now, iterate through map and return the element with count value 1. - please try to code by yourself and if you don\\'t get it then comment below\\n\\n3.) Using HashSet - one iteration required - TC - O(n) and SC - O(n) -  Iterate through each element of nums array. While iterating, check if element is present in set or not. If it is already present then remove that element from set and if it is not present then add the element to the set. Element which has appeared only for single time will remain in set and it will be the answer. - please try to code by yourself and if you don\\'t get it then comment below.\\n\\n4.) Using XOR - TC - O(n) and SC - O(1) -**best solution** - keep these two things in mind for xor. (a.) 0^x = x and (b.) x^x = 0 . Now initialize a variable say ans = 0 and iterate through nums elements. While iterate** take xor of all elements with ans**. Finally value of ans will be the element which appears only once. See this example, 3,4,3,1,1 - what I said that intitialize ans=0 and  **take xor of all elements with ans** so I will write - ans^3^4^3^1^1 - replace ans with 0 - 0^3^4^3^1^1 - same elements will become 0 as per x^x=0. So we will left with 0^4 which becomes 4 as per 0^x = x.\\n\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            ans^=nums[i];\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            ans^=nums[i];\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1190791,
                "title": "faster-than-99-95",
                "content": "```\\ndef singleNumber(self, nums: List[int]) -> int:\\n\\treturn 2*sum(list(set(nums))) - sum(nums)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef singleNumber(self, nums: List[int]) -> int:\\n\\treturn 2*sum(list(set(nums))) - sum(nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 643220,
                "title": "cpp-using-hash-table",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint singleNumber(vector<int>& nums) {\\n\\t\\t\\tunordered_map<int, int> hash;\\n\\t\\t\\tfor (auto num : nums) {\\n\\t\\t\\t\\tif (!hash[num])\\n\\t\\t\\t\\t\\thash[num] = 1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\thash.erase(num);\\n\\t\\t\\t}\\n\\t\\t\\treturn hash.begin()->first;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint singleNumber(vector<int>& nums) {\\n\\t\\t\\tunordered_map<int, int> hash;\\n\\t\\t\\tfor (auto num : nums) {\\n\\t\\t\\t\\tif (!hash[num])\\n\\t\\t\\t\\t\\thash[num] = 1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\thash.erase(num);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 515893,
                "title": "c-code-3-lines-solution-99-optimal-code",
                "content": "```\\nint singleNumber(int* nums, int numsSize){\\n    int val = 0;\\n    while(numsSize--) val ^= nums[numsSize];\\n    return val;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint singleNumber(int* nums, int numsSize){\\n    int val = 0;\\n    while(numsSize--) val ^= nums[numsSize];\\n    return val;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 515023,
                "title": "javascript-xor-linear-time-no-extra-space",
                "content": "```\\n// XOR is commutative, means- 1^2^1 = 1^1^2 (since a^a =0 hence 2 will be left)\\nvar singleNumber = function(nums) {\\n    let res = nums[0];\\n    for(let i = 1; i < nums.length; i++){\\n        res = res ^ nums[i]\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// XOR is commutative, means- 1^2^1 = 1^1^2 (since a^a =0 hence 2 will be left)\\nvar singleNumber = function(nums) {\\n    let res = nums[0];\\n    for(let i = 1; i < nums.length; i++){\\n        res = res ^ nums[i]\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 468420,
                "title": "python3-bitwise-and-non-bitwise-solutions-w-explanation",
                "content": "\\n# **Bitwise**\\n```\\ndef singleNumber(self, nums: List[int]) -> int:\\n\\tsol = 0\\n\\tfor n in nums:\\n\\t\\tsol ^= n\\n\\n\\treturn sol\\n```\\nExplanation:\\nThe key to this bitwise solution is understanding how XOR works. In this case we use this operator as a sort of do and undo. Let\\'s look at an example to see what I mean by that. \\n\\n```\\n>> x = 2  // 0010 in bits\\n>> x ^= 3 // 0010 ^ 0011 = 0001       (1) in bits\\n>> x ^= 3 // 0001 ^ 0011 = 0010       (2) in bits\\n>> x ^= 3 // 0010 ^ 0011 = 0001       (1) in bits\\n>> x ^= 3 // 0001 ^ 0011 = 0010       (2) in bits\\n...\\n``` \\nAs you see in the example, when we XOR `2` with `3` we get `1`, but if we do the operation again then we end up with our original `2`, essentially undoing what we just did. The same is true if we do this operation any even number of times. \\n\\nFor this problem since each number comes in pairs other than solution, XOR-ing our result by each number in our list will ultimately leave us with the the only number that occurs once which is the solution.\\n\\n# **Non Bitwise**\\n```\\n# Note this is not fast or memory efficient but it is readable\\ndef singleNumber(self, nums: List[int]) -> int:\\n\\tref = {}\\n\\tfor i in nums:\\n\\t\\tif i not in ref:\\n\\t\\t\\tref[i] = 1\\n\\t\\telse:\\n\\t\\t\\tref[i] += 1\\n\\n\\tfor k, v in ref.items():\\n\\t\\tif v == 1 :\\n\\t\\t\\treturn k\\n```\\n*Explanation:*\\nFor the non bitwise solution we are just using a map (dictionary in python terminology) to keep track of how many times each number occurs in the list. We iterate through and add the number to the map if it doesn\\'t exist and if it does we increment it by one. In the end we just go through each key value pair in the map and if any value is `1` (meaning there is only one instance of it) then we return the key to that value.\\n\\n**P.S** Feedback is always appreciated. Let me know what you think in the comments :)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\ndef singleNumber(self, nums: List[int]) -> int:\\n\\tsol = 0\\n\\tfor n in nums:\\n\\t\\tsol ^= n\\n\\n\\treturn sol\\n```\n```\\n>> x = 2  // 0010 in bits\\n>> x ^= 3 // 0010 ^ 0011 = 0001       (1) in bits\\n>> x ^= 3 // 0001 ^ 0011 = 0010       (2) in bits\\n>> x ^= 3 // 0010 ^ 0011 = 0001       (1) in bits\\n>> x ^= 3 // 0001 ^ 0011 = 0010       (2) in bits\\n...\\n```\n```\\n# Note this is not fast or memory efficient but it is readable\\ndef singleNumber(self, nums: List[int]) -> int:\\n\\tref = {}\\n\\tfor i in nums:\\n\\t\\tif i not in ref:\\n\\t\\t\\tref[i] = 1\\n\\t\\telse:\\n\\t\\t\\tref[i] += 1\\n\\n\\tfor k, v in ref.items():\\n\\t\\tif v == 1 :\\n\\t\\t\\treturn k\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 444555,
                "title": "4-different-solutions-in-go",
                "content": "### 1. Using a HashMap (Set) to find the single number\\n\\n> Runtime: 8 ms, faster than 95.97%\\n> Memory Usage: 5.4 MB, less than 14.29%\\n\\n```go\\nfunc singleNumber(nums []int) int {\\n  m := map[int]struct{}{}\\n  for _, num := range nums {\\n    if _, found := m[num]; found {\\n      delete(m, num)\\n    } else {\\n      m[num] = struct{}{}\\n    }\\n  }\\n  for k := range m {\\n    return k\\n  }\\n  return -1\\n}\\n```\\n\\n### 2. Using a HashMap (Set) to create a Set of numbers\\n\\n> Runtime: 8 ms, faster than 95.97%\\n> Memory Usage: 5.4 MB, less than 14.29%\\n\\n```go\\nfunc singleNumber(nums []int) int {\\n  m := map[int]struct{}{}\\n  var wholeSum int\\n  for _, num := range nums {\\n    m[num] = struct{}{}\\n    wholeSum += num\\n  }\\n  var uniqueSum int\\n  for num := range m {\\n    uniqueSum += num\\n  }\\n  return uniqueSum*2 - wholeSum\\n}\\n```\\n\\n### 3. Sorting the array\\n\\n> Runtime: 16 ms, faster than 15.99%\\n> Memory Usage: 4.7 MB, less than 100.00%\\n\\n```go\\nfunc singleNumber(nums []int) int {\\n  sort.Ints(nums)\\n  lastIndex := len(nums) - 1\\n  for i := 0; i < lastIndex; i += 2 {\\n    if nums[i] != nums[i+1] {\\n      return nums[i]\\n    }\\n  }\\n  return nums[lastIndex]\\n}\\n```\\n\\n### 4. Bit manipulation (XOR)\\n\\n> Runtime: 8 ms, faster than 95.94%\\n> Memory Usage: 4.7 MB, less than 100.00%\\n\\n```go\\nfunc singleNumber(nums []int) int {\\n  var result int\\n  for _, num := range nums {\\n    result ^= num\\n  }\\n  return result\\n}\\n```\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc singleNumber(nums []int) int {\\n  m := map[int]struct{}{}\\n  for _, num := range nums {\\n    if _, found := m[num]; found {\\n      delete(m, num)\\n    } else {\\n      m[num] = struct{}{}\\n    }\\n  }\\n  for k := range m {\\n    return k\\n  }\\n  return -1\\n}\\n```\n```go\\nfunc singleNumber(nums []int) int {\\n  m := map[int]struct{}{}\\n  var wholeSum int\\n  for _, num := range nums {\\n    m[num] = struct{}{}\\n    wholeSum += num\\n  }\\n  var uniqueSum int\\n  for num := range m {\\n    uniqueSum += num\\n  }\\n  return uniqueSum*2 - wholeSum\\n}\\n```\n```go\\nfunc singleNumber(nums []int) int {\\n  sort.Ints(nums)\\n  lastIndex := len(nums) - 1\\n  for i := 0; i < lastIndex; i += 2 {\\n    if nums[i] != nums[i+1] {\\n      return nums[i]\\n    }\\n  }\\n  return nums[lastIndex]\\n}\\n```\n```go\\nfunc singleNumber(nums []int) int {\\n  var result int\\n  for _, num := range nums {\\n    result ^= num\\n  }\\n  return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 254014,
                "title": "java-no-extra-memory",
                "content": "My solution, no extra memory.\\n```\\npublic int singleNumber(int[] nums) {\\n        for (int i = 1; i < nums.length; i++) {\\n            nums[0] = nums[0] ^ nums[i];\\n        }\\n        return nums[0];\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int singleNumber(int[] nums) {\\n        for (int i = 1; i < nums.length; i++) {\\n            nums[0] = nums[0] ^ nums[i];\\n        }\\n        return nums[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 132680,
                "title": "kotlin-reduce-and-xor-1-line",
                "content": "```fun singleNumber(data: IntArray) = data.reduce { acc, i -> acc.xor(i) }```",
                "solutionTags": [],
                "code": "```fun singleNumber(data: IntArray) = data.reduce { acc, i -> acc.xor(i) }```",
                "codeTag": "Unknown"
            },
            {
                "id": 3367818,
                "title": "beginner-friendly-javascript-bitwise-explanation-47ms-99-83-beats-6-lines-code",
                "content": "![Screenshot 2023-04-02 at 01.21.19.png](https://assets.leetcode.com/users/images/5f6d740d-c4be-4a28-b060-7f38fa574e1a_1680391459.988997.png)\\n\\n# What is XOR operation and how it works:\\n\\nXOR (Exclusive OR) is a logical operation that takes two operands and returns a result based on their boolean values. The operation returns true if and only if exactly one of the operands is true.\\n\\nIn the context of binary numbers, the XOR operation is applied bitwise to each pair of corresponding bits, and the result is a new binary number. The operation returns a 1 in each bit position where the corresponding bits of the operands are different, and a 0 where they are the same.\\n\\nHere\\'s an example of how XOR works on two binary numbers, *1010* and *1101*:\\n```\\n  1010\\nX 1101\\n-----\\n  0111\\n```\\nIn this example, the XOR operation was applied bitwise to each pair of bits in the two operands. The result is a new binary number, 0111, which is the XOR of 1010 and 1101.\\n\\nIn the context of the code we have been discussing, the XOR operation is used to find the single number in an array of numbers that does not have a duplicate. The properties of the XOR operation ensure that when the same number is XORed twice, it results in 0, effectively cancelling out any duplicates. The remaining number that is not cancelled out is the single number that we are looking for.\\n# Explanation\\n1. Check if the input array nums is empty. If it is empty, the function immediately returns 0.\\n2. Initialize a variable called num to 0.\\n3. Iterate through each element of the input array nums.\\n4. For each element, apply the XOR operation between the current value of num and the value of the element. Store the result back in num.\\n5. After all elements have been processed, return the value of num.\\n\\n\\n# Complexity\\n- Time complexity:\\nIt is O(n), where n is the length of the input array. This is because the code iterates through each element of the array exactly once to perform the XOR operation.\\n\\n- Space complexity:\\nIt is O(1), as it only uses a constant amount of extra space to store the num variable. This means that the space required by the code does not depend on the size of the input array.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar singleNumber = function(nums) {\\n    if(nums.length<0){\\n        return 0\\n    }\\n    let num = 0 ;\\n    for (let i = 0; i<nums.length; i++ ){\\n        num^=nums[i]\\n    }\\n    return num\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n  1010\\nX 1101\\n-----\\n  0111\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar singleNumber = function(nums) {\\n    if(nums.length<0){\\n        return 0\\n    }\\n    let num = 0 ;\\n    for (let i = 0; i<nums.length; i++ ){\\n        num^=nums[i]\\n    }\\n    return num\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3125796,
                "title": "python-simple-solution-linear-runtime-constant-space-explained",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        #go through each numbers\\n        for i in nums:\\n            #Using count method to check how many times current number appear in array\\n            if nums.count(i) == 1:\\n            #IF the current number appear 1 so return the answer\\n                return i\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        #go through each numbers\\n        for i in nums:\\n            #Using count method to check how many times current number appear in array\\n            if nums.count(i) == 1:\\n            #IF the current number appear 1 so return the answer\\n                return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045415,
                "title": "c-and-xor",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int SingleNumber(int[] nums) {\\n        var result = 0;\\n        for (int i = 0; i < nums.Length; i++){\\n            result ^= nums[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    public int SingleNumber(int[] nums) {\\n        var result = 0;\\n        for (int i = 0; i < nums.Length; i++){\\n            result ^= nums[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041411,
                "title": "swift-solution-using-xor-with-comments-beats-93",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we use the property of XOR operation, that is a^b^b = a. \\nSo, if we take XOR of all the elements, the duplicated ones will cancel out each other and we will be left with the single element.\\n\\n# Code\\n```\\nclass Solution {\\n    func singleNumber(_ nums: [Int]) -> Int {\\n        guard !nums.isEmpty else { return 0 }\\n        \\n        var result = 0\\n\\n        for num in nums {\\n            result ^= num\\n        }\\n        return result\\n    }\\n}\\n```\\n\\n# A little theory\\nThe XOR (exclusive OR) operation is a logical operation that compares two binary digits and returns 1 if they are different and 0 if they are the same. It is represented by the symbol \"^\".\\n\\nThe XOR operation has several properties that make it useful in various algorithms and problems. Some of the most important properties of XOR are:\\n\\nCommutative: The order of the operands does not affect the result, so a^b = b^a\\nAssociative: The grouping of the operands does not affect the result, so (a^b)^c = a^(b^c)\\nIdentity: a^0 = a\\nInverse: a^a = 0",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func singleNumber(_ nums: [Int]) -> Int {\\n        guard !nums.isEmpty else { return 0 }\\n        \\n        var result = 0\\n\\n        for num in nums {\\n            result ^= num\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3007305,
                "title": "java-easy-solution-beginner-friendly-beat-100",
                "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            ans=ans^nums[i];\\n            \\n        }\\n    \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            ans=ans^nums[i];\\n            \\n        }\\n    \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765242,
                "title": "simple-fast",
                "content": "```\\nclass Solution:\\n\\tdef singleNumber(self, nums: List[int]) -> int:\\n\\n\\t\\tresult = 0\\n\\n\\t\\tfor i in nums:\\n\\t\\t\\tresult = result ^ i\\n\\n\\t\\treturn result \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\tdef singleNumber(self, nums: List[int]) -> int:\\n\\n\\t\\tresult = 0\\n\\n\\t\\tfor i in nums:\\n\\t\\t\\tresult = result ^ i\\n\\n\\t\\treturn result \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2522877,
                "title": "java-solution-time-o-n-space-o-1-xor-explained",
                "content": "The property of XOR :-\\n\\n0 ^ 0 --> 0\\n0 ^ 1 --> 1\\n1 ^ 0 --> 1\\n1 ^ 1 --> 0\\nWe know every number is appears twice except a single number which appears only single time.\\n\\nSee, we already discuss a thing a that xor of a same number with itself is zero, i.e A ^ A = 0\\nNow, we will look some more property of xor-\\n\\n1) xor of a same number with itself is zero, i.e A ^ A = 0.\\n2) xor of any number with zero is the number itself i.e A ^ 0 = A.\\n\\nOur array is : {4,1,2,1,2}\\n                      4^1  \\n\\t\\t\\t\\t\\t  4^1^2\\n\\t\\t\\t\\t\\t  4^1^2^1   ->[1^1=0]\\n\\t\\t\\t\\t\\t  4^2\\n\\t\\t\\t\\t\\t  4^2^2    -> [2^2=0]\\n\\t\\t\\t\\t\\t  4\\n\\t\\t\\t\\t\\t  So, the element which we got as left should be our answer, so the answer is  \\'4\\'\\n\\t\\t\\t\\t\\t  \\n\\t\\t\\t\\t\\t  Time complexicity -> O(n)\\n\\t\\t\\t\\t\\t  Space complexicity -> O(1)\\n\\t\\t\\t\\tcode :-\\t  \\n\\t\\t\\t\\t\\t  class Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0; \\n      for(int i=0; i<nums.length; i++) {\\n          res = res ^ nums[i]; \\n      }\\n        return res;\\n    }\\n}\\nIf you find this useful, kindly consider to upvote.\\n\\t\\t\\t\\t\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0; \\n      for(int i=0; i<nums.length; i++) {\\n          res = res ^ nums[i]; \\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1645511,
                "title": "python-3-faster-than-92-98-one-liner",
                "content": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return sum(set(nums))*2 - sum(nums)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return sum(set(nums))*2 - sum(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1491449,
                "title": "js-xor-solution",
                "content": "```\\nvar singleNumber = function(nums) {\\n    let single = 0;\\n    for (let num of nums) {\\n        single ^= num\\n    }\\n    return single\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar singleNumber = function(nums) {\\n    let single = 0;\\n    for (let num of nums) {\\n        single ^= num\\n    }\\n    return single\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1468062,
                "title": "c-super-straight-forward-solution-using-xor",
                "content": "```\\n/*\\n    https://leetcode.com/problems/single-number/\\n    \\n    TC: O(N)\\n    SC: O(1)\\n*/\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int unique = 0;\\n        // XOR of A XOR A = 0, so all duplicates will cancel each other, \\n        // leaving the non duplicate \\n        for(int &num: nums)\\n            unique ^= num;\\n        return unique;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/single-number/\\n    \\n    TC: O(N)\\n    SC: O(1)\\n*/\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int unique = 0;\\n        // XOR of A XOR A = 0, so all duplicates will cancel each other, \\n        // leaving the non duplicate \\n        for(int &num: nums)\\n            unique ^= num;\\n        return unique;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 998258,
                "title": "rust-fold-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Rust online submissions for Single Number.\\nMemory Usage: 2.2 MB, less than 80.77% of Rust online submissions for Single Number.\\n```\\nimpl Solution {\\n    pub fn single_number(nums: Vec<i32>) -> i32 {\\n        nums.iter().fold(0, |acc, x| acc ^ x)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn single_number(nums: Vec<i32>) -> i32 {\\n        nums.iter().fold(0, |acc, x| acc ^ x)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 955161,
                "title": "python-1-liner-maths-logic-without-using-libraries-beats-97",
                "content": "![image](https://assets.leetcode.com/users/images/05f7734e-e9d1-48d7-9075-b3e307bb55af_1606775426.1568828.png)\\n\\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        return ((2*(sum(set(nums))))-(sum(nums)))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        return ((2*(sum(set(nums))))-(sum(nums)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 813225,
                "title": "simple-typescript-math-solution",
                "content": "```\\nconst singleNumber = (nums: number[]): number => {\\n  const set = new Set(nums);\\n  const setSum = [...set].reduce((acc, elem) => acc + elem);\\n  const numsSum = nums.reduce((acc, elem) => acc + elem);\\n\\n  return 2 * setSum - numsSum;\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Ordered Set"
                ],
                "code": "```\\nconst singleNumber = (nums: number[]): number => {\\n  const set = new Set(nums);\\n  const setSum = [...set].reduce((acc, elem) => acc + elem);\\n  const numsSum = nums.reduce((acc, elem) => acc + elem);\\n\\n  return 2 * setSum - numsSum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 562515,
                "title": "136-single-number-java-100-speed-with-notes-explaining-solution",
                "content": "```\\npublic int singleNumber(int[] nums) {\\n        // Count the number of integers in the array\\n        int size = nums.length;\\n        // Isolate the first number in the array\\n        int result = nums[0];\\n        \\n        // Traverse through the entire array starting from the second number\\n        for (int i = 1; i < size; i++)\\n            /**\\n             * Use an XOR gate to find the number without a match.\\n             *\\n             * XOR or Exclusive Or is a  logical operation that outputs\\n             * true only when inputs differ (one is true, the other is\\n             * false).\\n             *\\n             * In this case, the program will traverse through the array\\n             * adding each number to the result until it comes to a number\\n             * it has already added. Instead of adding a number again, the\\n             * program will subtract the number from result. When the\\n             * for-loop has completed, the result will be the number\\n             * that was added but not subtracted.\\n             * */\\n            result = result ^ nums[i];\\n            \\n        // Return the \"true\" integer that does not appear twice\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int singleNumber(int[] nums) {\\n        // Count the number of integers in the array\\n        int size = nums.length;\\n        // Isolate the first number in the array\\n        int result = nums[0];\\n        \\n        // Traverse through the entire array starting from the second number\\n        for (int i = 1; i < size; i++)\\n            /**\\n             * Use an XOR gate to find the number without a match.\\n             *\\n             * XOR or Exclusive Or is a  logical operation that outputs\\n             * true only when inputs differ (one is true, the other is\\n             * false).\\n             *\\n             * In this case, the program will traverse through the array\\n             * adding each number to the result until it comes to a number\\n             * it has already added. Instead of adding a number again, the\\n             * program will subtract the number from result. When the\\n             * for-loop has completed, the result will be the number\\n             * that was added but not subtracted.\\n             * */\\n            result = result ^ nums[i];\\n            \\n        // Return the \"true\" integer that does not appear twice\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 378036,
                "title": "java-hashset-solution",
                "content": "Time complexity: O(n)\\nSpace complexity: O(n)\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        //Sanity check\\n        if (nums == null || nums.length < 1) {\\n            return 0;\\n        }\\n        Set<Integer> set = new HashSet<>();\\n        for (int num : nums) {\\n            if (set.contains(num)) {\\n                set.remove(num);\\n            } else {\\n                set.add(num);\\n            }\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        //Sanity check\\n        if (nums == null || nums.length < 1) {\\n            return 0;\\n        }\\n        Set<Integer> set = new HashSet<>();\\n        for (int num : nums) {\\n            if (set.contains(num)) {\\n                set.remove(num);\\n            } else {\\n                set.add(num);\\n            }\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43085,
                "title": "my-simple-javascript-solution",
                "content": "var singleNumber = function(nums) {\\n            nums.sort();\\n            for (var i = 0; i < nums.length; i += 2) {\\n                if (nums[i] != nums[i + 1]) {\\n                    return nums[i];\\n                }\\n            }\\n        };",
                "solutionTags": [],
                "code": "var singleNumber = function(nums) {\\n            nums.sort();\\n            for (var i = 0; i < nums.length; i += 2) {\\n                if (nums[i] != nums[i + 1]) {\\n                    return nums[i];\\n                }\\n            }\\n        };",
                "codeTag": "Unknown"
            },
            {
                "id": 3545995,
                "title": "python-o-n-with-mathematical-explanation-and-comparison-xor",
                "content": "# Simple Math Explanation \\n\\nThis problem involves mathematics application to solve the problem. We are given a list of numbers which has single occurence of a number and the rest numbers occur twice.\\n\\nThe XOR (^) comes into picture to solve the problem.\\nThe XOR truth table:\\nA | B | A ^ B\\n ---| --- | ---\\n1 | 1 | 0\\n0 | 1 | 1\\n1 | 0 | 1\\n0 | 0 | 0\\n\\nTherefore, if an element(A) occurs twice, then A ^ A = 0\\nAlso, since, 0 ^ B = B, we reach the final stage where we get the odd one out.\\nWe also have to take in consideration on more math law([Rule of Association](https://www.javatpoint.com/laws-and-rules-of-boolean-algebra-in-digital-electronics)):\\n> (A ^ B) ^ C = A ^ (B ^ C)\\n\\n</br>\\nConsider the below number list:\\n> [1,2,1]\\nWe begin the operations from the left side (according to precedence of operations) <br>\\n\\n> (1 ^ 2) ^ 1\\n= 2 ^ (1 ^ 1)\\n=  2 ^ (False)\\n=  2\\n\\nThere, we have the single occuring element, 2.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n# Code\\nI have implemented the approach using loops and lambda for both beginner and advanced implementations.\\n\\n``` Python_Simple_Approach []\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        res = nums[0]\\n        for val in nums[1:]:\\n            res ^= val\\n        return res\\n```\\n```Python_Using_Reduce_and_Lambda []\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return reduce(lambda x, y: x ^ y, nums)\\n```\\nExecution time and memory for simple approach\\n![Image of Execution time and memory for simple approach](https://assets.leetcode.com/users/images/45ca0279-267d-493a-9213-cbed24396c0a_1679894667.6784487.png)\\n\\n<hr></hr>\\nExecution time and memory for simple approach\\n\\n![Image of Execution time and memory for simple approach](https://assets.leetcode.com/users/images/448edc17-d2bf-4991-b2bf-b4e74d495b8c_1679894709.117987.png)\\n\\n### Please upvote if you find it helpful",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "``` Python_Simple_Approach []\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        res = nums[0]\\n        for val in nums[1:]:\\n            res ^= val\\n        return res\\n```\n```Python_Using_Reduce_and_Lambda []\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return reduce(lambda x, y: x ^ y, nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464164,
                "title": "c-python-o-1-space",
                "content": "\\n# Using bitwise XOR\\na ^ 0 = a\\na ^ a = 0 , so every duplicate will become 0 and only the single no. will remain\\n\\neg : [ -1, 2, 3, -2, -1] now if we add all elements of this array then only 3 will remain , that\\'s how XOR also works ,order doesn\\'t matter, like 2 ^ 3 ^ 2 ^ 1 ^ 3 = 3 ^ 2 ^ 2 ^ 3 ^ 1 =  and so on ..\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int once = 0;\\n        for(auto i : nums) {\\n            once ^= i;\\n        }\\n        return once;\\n    }\\n};\\n```\\n\\n# Python / Python3\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        once = 0\\n        for i in nums:\\n            once ^= i\\n        return once\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int once = 0;\\n        for(auto i : nums) {\\n            once ^= i;\\n        }\\n        return once;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        once = 0\\n        for i in nums:\\n            once ^= i\\n        return once\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166006,
                "title": "best-c-solutions-bit-manipulation-xor-sorting-hash-table-optimized-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can Solved this question using multiple approaches.\\n\\n1. Using Sorting.\\n2. Using Hash Table.\\n3. Using Bit Manipulation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(NlogN). Since we are using sorting.\\n\\n    Space Complexity : O(1). Since we are not using any auxiliary space.\\n\\n    Using Array + Sorting.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        for(int i=1; i<n; i+=2){\\n            if(nums[i-1] != nums[i]){\\n                return nums[i-1];\\n            }\\n        }\\n        return nums[n-1];\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Where N is the size of nums. Here loop creates the times complexity.\\n    Space Complexity : O(N), Unordered map space.\\n\\n    Using Array + Hash Table.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map<int, int> map;\\n        for(auto it : nums){\\n            map[it]++;\\n        }\\n        for(auto it : map){\\n            if(it.second == 1){\\n                return it.first;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Where N is the size of Array(nums). Here loop creates the times complexity.\\n\\n    Space complexity: O(1), Constant Space.\\n\\n    Solved using Array + Bit Manipulation(Xor).\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int res = 0;\\n        for(auto it : nums){\\n            res ^= it;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(NlogN). Since we are using sorting.\\n\\n    Space Complexity : O(1). Since we are not using any auxiliary space.\\n\\n    Using Array + Sorting.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        for(int i=1; i<n; i+=2){\\n            if(nums[i-1] != nums[i]){\\n                return nums[i-1];\\n            }\\n        }\\n        return nums[n-1];\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Where N is the size of nums. Here loop creates the times complexity.\\n    Space Complexity : O(N), Unordered map space.\\n\\n    Using Array + Hash Table.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map<int, int> map;\\n        for(auto it : nums){\\n            map[it]++;\\n        }\\n        for(auto it : map){\\n            if(it.second == 1){\\n                return it.first;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Where N is the size of Array(nums). Here loop creates the times complexity.\\n\\n    Space complexity: O(1), Constant Space.\\n\\n    Solved using Array + Bit Manipulation(Xor).\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int res = 0;\\n        for(auto it : nums){\\n            res ^= it;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080343,
                "title": "3-easy-solution",
                "content": "# Approach 1\\nBrute-Force\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        bool flag;\\n        int i, j;\\n        int ans = 0;\\n        for (i = 0; i < nums.size(); i++) {\\n            flag = false;\\n            for (j = 0; j < nums.size(); j++) {\\n                if (nums[i] == nums[j] && i != j) {\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if (flag == false) {\\n                ans = nums[i];\\n                break;\\n            }\\n        }\\n        return ans;    \\n    }\\n};\\n```\\n# Approach 2\\nHashmap\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map <int, int> mp;\\n        int ans;\\n        for (int i = 0; i < nums.size(); i++)\\n            mp[nums[i]]++;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (mp[nums[i]] == 1) {\\n                ans = nums[i];\\n                break;\\n            }\\n        }\\n        return ans;      \\n    }\\n};\\n```\\n\\n# Approach 3\\nBit Magic\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans = 0;\\n        for (int i = 0; i < nums.size(); i++)\\n            ans = ans ^ nums[i];\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        bool flag;\\n        int i, j;\\n        int ans = 0;\\n        for (i = 0; i < nums.size(); i++) {\\n            flag = false;\\n            for (j = 0; j < nums.size(); j++) {\\n                if (nums[i] == nums[j] && i != j) {\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if (flag == false) {\\n                ans = nums[i];\\n                break;\\n            }\\n        }\\n        return ans;    \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map <int, int> mp;\\n        int ans;\\n        for (int i = 0; i < nums.size(); i++)\\n            mp[nums[i]]++;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (mp[nums[i]] == 1) {\\n                ans = nums[i];\\n                break;\\n            }\\n        }\\n        return ans;      \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans = 0;\\n        for (int i = 0; i < nums.size(); i++)\\n            ans = ans ^ nums[i];\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567884,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1720470,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1572607,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1565663,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1569469,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1938174,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1573009,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1566345,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1565420,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1565834,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1567884,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1720470,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1572607,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1565663,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1569469,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1938174,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1573009,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1566345,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1565420,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1565834,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1568956,
                "content": [
                    {
                        "username": "gn00437805",
                        "content": "public int SingleNumber(List<int> searchList)\\n       \\n {\\n            \\n  return searchList.Aggregate( (a, b) => a ^ b); \\n\\n }"
                    },
                    {
                        "username": "Felicia919",
                        "content": "\\'\\'\\'\\nreturn 2*sum(set(nums))-sum(nums)\\n\\'\\'\\'"
                    },
                    {
                        "username": "ericmcelyea",
                        "content": "Can we just generally agree it is a gimmicky question if there is only one workable solution that fits all the constraints?"
                    },
                    {
                        "username": "FerasBarahmeh",
                        "content": "\\nkeep in mind we will find a solution in one loop (linear runtime complexity)\\n\\nAsk yourself a question how i can abandon duplicate numbers ?\\n\\nIt may be dangerous for your mind tow solutions\\n\\n- subtraction the repated numbers\\n- using XOR operator (We Will solve problem in this way)\\n    in XOR operation the same number will give zero (in binary)\\n    for example :\\n        3 ^ 3 Three in binary equal 0 0 1 1\\n       let\\'s Go applay Xor operation :  3 ^ 3\\n        0 0 1 1\\n        0 0 1 1 ^\\n        -------\\n        0 0 0 0\\n\\n    I hope the explanation is clear at the this point\\n\\n    Now I think you can now imagine the solution\\n    if you applay xor for all elemnet in array all the appears    twice numbers will give zeros in the result you find just a single number Let tack example\\n\\n    array = [4,1,2,1,2]\\n    let sort array [1,1,2,2,4]\\n    1 ^ 1 = 0 \\n    0 ^ 2 ^ 2 = 0 ***(0 the result of 1 ^ 1 = 0)***\\n    0 ^ 4 = 4 \\n   (So The Result is 4)\\n\\n"
                    },
                    {
                        "username": "silentvoyager",
                        "content": "I didn\\'t realize I could use XOR so I came up with a tricky solution that used the fact the input numbers are in [-30000,30000] range so require 2 bytes each. I reused the upper 2 bytes of each element in the array to implement an open addressing hash set with linear probing. Basically the hash set ended up being in place in the same input array without using any additional memory. I realized this was overcomplicated but I was interested to see if I could make this work. I did."
                    },
                    {
                        "username": "ondeezesug",
                        "content": "[@1Hanif1](/1Hanif1) you need to attend your data structure classes lol \\n"
                    },
                    {
                        "username": "1Hanif1",
                        "content": "I\\'m 2 years late but can you explain what \"open addressing hash set with linear probing\" is please?"
                    },
                    {
                        "username": "yqzfm123",
                        "content": " return reduce(lambda a,b:a^b,nums)"
                    },
                    {
                        "username": "zhenf",
                        "content": "Most of the submissions of O(n) without extra space here use XOR. Is there any other possible solutions here?"
                    },
                    {
                        "username": "shourovkun",
                        "content": "[@srkr](/srkr) Doesn\\'t set_of_nums have linear space complexity?"
                    },
                    {
                        "username": "srkr",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        sum_of_nums=sum(nums)\\n        sum_of_set=sum(set(nums))\\n        single_number = 2*sum_of_set-sum_of_nums\\n        return single_number"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        from collections import Counter\\n        x=Counter(nums)\\n        t=min(x.values())\\n        for x1,y1 in x.items():\\n            if y1==t:\\n                return x1"
                    },
                    {
                        "username": "Niloofar.montazeri",
                        "content": "I can see how the xor solution works for an array like [1,2,1,3,2,4,3,...], where at most 2 numbers are combined with xor before one gets cancelled. But Let's say the array is arranged as [1,2,3,4,5  1,2,3,4,5,6]. Then the cumulative xor of the first five elements should be able to keep [the information] for all these five numbers, so that they get cancelled, one by one, after the 6th element. How is that possible?"
                    },
                    {
                        "username": "mikematar",
                        "content": "\\'\\'\\'\\nprint([k for k,v in Counter(nums).items() if v==1][0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "magiclin",
                        "content": "    def single_number(nums)\\n      nums.inject(&:^)\\n    end"
                    }
                ]
            },
            {
                "id": 1568606,
                "content": [
                    {
                        "username": "gn00437805",
                        "content": "public int SingleNumber(List<int> searchList)\\n       \\n {\\n            \\n  return searchList.Aggregate( (a, b) => a ^ b); \\n\\n }"
                    },
                    {
                        "username": "Felicia919",
                        "content": "\\'\\'\\'\\nreturn 2*sum(set(nums))-sum(nums)\\n\\'\\'\\'"
                    },
                    {
                        "username": "ericmcelyea",
                        "content": "Can we just generally agree it is a gimmicky question if there is only one workable solution that fits all the constraints?"
                    },
                    {
                        "username": "FerasBarahmeh",
                        "content": "\\nkeep in mind we will find a solution in one loop (linear runtime complexity)\\n\\nAsk yourself a question how i can abandon duplicate numbers ?\\n\\nIt may be dangerous for your mind tow solutions\\n\\n- subtraction the repated numbers\\n- using XOR operator (We Will solve problem in this way)\\n    in XOR operation the same number will give zero (in binary)\\n    for example :\\n        3 ^ 3 Three in binary equal 0 0 1 1\\n       let\\'s Go applay Xor operation :  3 ^ 3\\n        0 0 1 1\\n        0 0 1 1 ^\\n        -------\\n        0 0 0 0\\n\\n    I hope the explanation is clear at the this point\\n\\n    Now I think you can now imagine the solution\\n    if you applay xor for all elemnet in array all the appears    twice numbers will give zeros in the result you find just a single number Let tack example\\n\\n    array = [4,1,2,1,2]\\n    let sort array [1,1,2,2,4]\\n    1 ^ 1 = 0 \\n    0 ^ 2 ^ 2 = 0 ***(0 the result of 1 ^ 1 = 0)***\\n    0 ^ 4 = 4 \\n   (So The Result is 4)\\n\\n"
                    },
                    {
                        "username": "silentvoyager",
                        "content": "I didn\\'t realize I could use XOR so I came up with a tricky solution that used the fact the input numbers are in [-30000,30000] range so require 2 bytes each. I reused the upper 2 bytes of each element in the array to implement an open addressing hash set with linear probing. Basically the hash set ended up being in place in the same input array without using any additional memory. I realized this was overcomplicated but I was interested to see if I could make this work. I did."
                    },
                    {
                        "username": "ondeezesug",
                        "content": "[@1Hanif1](/1Hanif1) you need to attend your data structure classes lol \\n"
                    },
                    {
                        "username": "1Hanif1",
                        "content": "I\\'m 2 years late but can you explain what \"open addressing hash set with linear probing\" is please?"
                    },
                    {
                        "username": "yqzfm123",
                        "content": " return reduce(lambda a,b:a^b,nums)"
                    },
                    {
                        "username": "zhenf",
                        "content": "Most of the submissions of O(n) without extra space here use XOR. Is there any other possible solutions here?"
                    },
                    {
                        "username": "shourovkun",
                        "content": "[@srkr](/srkr) Doesn\\'t set_of_nums have linear space complexity?"
                    },
                    {
                        "username": "srkr",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        sum_of_nums=sum(nums)\\n        sum_of_set=sum(set(nums))\\n        single_number = 2*sum_of_set-sum_of_nums\\n        return single_number"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        from collections import Counter\\n        x=Counter(nums)\\n        t=min(x.values())\\n        for x1,y1 in x.items():\\n            if y1==t:\\n                return x1"
                    },
                    {
                        "username": "Niloofar.montazeri",
                        "content": "I can see how the xor solution works for an array like [1,2,1,3,2,4,3,...], where at most 2 numbers are combined with xor before one gets cancelled. But Let's say the array is arranged as [1,2,3,4,5  1,2,3,4,5,6]. Then the cumulative xor of the first five elements should be able to keep [the information] for all these five numbers, so that they get cancelled, one by one, after the 6th element. How is that possible?"
                    },
                    {
                        "username": "mikematar",
                        "content": "\\'\\'\\'\\nprint([k for k,v in Counter(nums).items() if v==1][0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "magiclin",
                        "content": "    def single_number(nums)\\n      nums.inject(&:^)\\n    end"
                    }
                ]
            },
            {
                "id": 1825606,
                "content": [
                    {
                        "username": "gn00437805",
                        "content": "public int SingleNumber(List<int> searchList)\\n       \\n {\\n            \\n  return searchList.Aggregate( (a, b) => a ^ b); \\n\\n }"
                    },
                    {
                        "username": "Felicia919",
                        "content": "\\'\\'\\'\\nreturn 2*sum(set(nums))-sum(nums)\\n\\'\\'\\'"
                    },
                    {
                        "username": "ericmcelyea",
                        "content": "Can we just generally agree it is a gimmicky question if there is only one workable solution that fits all the constraints?"
                    },
                    {
                        "username": "FerasBarahmeh",
                        "content": "\\nkeep in mind we will find a solution in one loop (linear runtime complexity)\\n\\nAsk yourself a question how i can abandon duplicate numbers ?\\n\\nIt may be dangerous for your mind tow solutions\\n\\n- subtraction the repated numbers\\n- using XOR operator (We Will solve problem in this way)\\n    in XOR operation the same number will give zero (in binary)\\n    for example :\\n        3 ^ 3 Three in binary equal 0 0 1 1\\n       let\\'s Go applay Xor operation :  3 ^ 3\\n        0 0 1 1\\n        0 0 1 1 ^\\n        -------\\n        0 0 0 0\\n\\n    I hope the explanation is clear at the this point\\n\\n    Now I think you can now imagine the solution\\n    if you applay xor for all elemnet in array all the appears    twice numbers will give zeros in the result you find just a single number Let tack example\\n\\n    array = [4,1,2,1,2]\\n    let sort array [1,1,2,2,4]\\n    1 ^ 1 = 0 \\n    0 ^ 2 ^ 2 = 0 ***(0 the result of 1 ^ 1 = 0)***\\n    0 ^ 4 = 4 \\n   (So The Result is 4)\\n\\n"
                    },
                    {
                        "username": "silentvoyager",
                        "content": "I didn\\'t realize I could use XOR so I came up with a tricky solution that used the fact the input numbers are in [-30000,30000] range so require 2 bytes each. I reused the upper 2 bytes of each element in the array to implement an open addressing hash set with linear probing. Basically the hash set ended up being in place in the same input array without using any additional memory. I realized this was overcomplicated but I was interested to see if I could make this work. I did."
                    },
                    {
                        "username": "ondeezesug",
                        "content": "[@1Hanif1](/1Hanif1) you need to attend your data structure classes lol \\n"
                    },
                    {
                        "username": "1Hanif1",
                        "content": "I\\'m 2 years late but can you explain what \"open addressing hash set with linear probing\" is please?"
                    },
                    {
                        "username": "yqzfm123",
                        "content": " return reduce(lambda a,b:a^b,nums)"
                    },
                    {
                        "username": "zhenf",
                        "content": "Most of the submissions of O(n) without extra space here use XOR. Is there any other possible solutions here?"
                    },
                    {
                        "username": "shourovkun",
                        "content": "[@srkr](/srkr) Doesn\\'t set_of_nums have linear space complexity?"
                    },
                    {
                        "username": "srkr",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        sum_of_nums=sum(nums)\\n        sum_of_set=sum(set(nums))\\n        single_number = 2*sum_of_set-sum_of_nums\\n        return single_number"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        from collections import Counter\\n        x=Counter(nums)\\n        t=min(x.values())\\n        for x1,y1 in x.items():\\n            if y1==t:\\n                return x1"
                    },
                    {
                        "username": "Niloofar.montazeri",
                        "content": "I can see how the xor solution works for an array like [1,2,1,3,2,4,3,...], where at most 2 numbers are combined with xor before one gets cancelled. But Let's say the array is arranged as [1,2,3,4,5  1,2,3,4,5,6]. Then the cumulative xor of the first five elements should be able to keep [the information] for all these five numbers, so that they get cancelled, one by one, after the 6th element. How is that possible?"
                    },
                    {
                        "username": "mikematar",
                        "content": "\\'\\'\\'\\nprint([k for k,v in Counter(nums).items() if v==1][0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "magiclin",
                        "content": "    def single_number(nums)\\n      nums.inject(&:^)\\n    end"
                    }
                ]
            },
            {
                "id": 1767548,
                "content": [
                    {
                        "username": "gn00437805",
                        "content": "public int SingleNumber(List<int> searchList)\\n       \\n {\\n            \\n  return searchList.Aggregate( (a, b) => a ^ b); \\n\\n }"
                    },
                    {
                        "username": "Felicia919",
                        "content": "\\'\\'\\'\\nreturn 2*sum(set(nums))-sum(nums)\\n\\'\\'\\'"
                    },
                    {
                        "username": "ericmcelyea",
                        "content": "Can we just generally agree it is a gimmicky question if there is only one workable solution that fits all the constraints?"
                    },
                    {
                        "username": "FerasBarahmeh",
                        "content": "\\nkeep in mind we will find a solution in one loop (linear runtime complexity)\\n\\nAsk yourself a question how i can abandon duplicate numbers ?\\n\\nIt may be dangerous for your mind tow solutions\\n\\n- subtraction the repated numbers\\n- using XOR operator (We Will solve problem in this way)\\n    in XOR operation the same number will give zero (in binary)\\n    for example :\\n        3 ^ 3 Three in binary equal 0 0 1 1\\n       let\\'s Go applay Xor operation :  3 ^ 3\\n        0 0 1 1\\n        0 0 1 1 ^\\n        -------\\n        0 0 0 0\\n\\n    I hope the explanation is clear at the this point\\n\\n    Now I think you can now imagine the solution\\n    if you applay xor for all elemnet in array all the appears    twice numbers will give zeros in the result you find just a single number Let tack example\\n\\n    array = [4,1,2,1,2]\\n    let sort array [1,1,2,2,4]\\n    1 ^ 1 = 0 \\n    0 ^ 2 ^ 2 = 0 ***(0 the result of 1 ^ 1 = 0)***\\n    0 ^ 4 = 4 \\n   (So The Result is 4)\\n\\n"
                    },
                    {
                        "username": "silentvoyager",
                        "content": "I didn\\'t realize I could use XOR so I came up with a tricky solution that used the fact the input numbers are in [-30000,30000] range so require 2 bytes each. I reused the upper 2 bytes of each element in the array to implement an open addressing hash set with linear probing. Basically the hash set ended up being in place in the same input array without using any additional memory. I realized this was overcomplicated but I was interested to see if I could make this work. I did."
                    },
                    {
                        "username": "ondeezesug",
                        "content": "[@1Hanif1](/1Hanif1) you need to attend your data structure classes lol \\n"
                    },
                    {
                        "username": "1Hanif1",
                        "content": "I\\'m 2 years late but can you explain what \"open addressing hash set with linear probing\" is please?"
                    },
                    {
                        "username": "yqzfm123",
                        "content": " return reduce(lambda a,b:a^b,nums)"
                    },
                    {
                        "username": "zhenf",
                        "content": "Most of the submissions of O(n) without extra space here use XOR. Is there any other possible solutions here?"
                    },
                    {
                        "username": "shourovkun",
                        "content": "[@srkr](/srkr) Doesn\\'t set_of_nums have linear space complexity?"
                    },
                    {
                        "username": "srkr",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        sum_of_nums=sum(nums)\\n        sum_of_set=sum(set(nums))\\n        single_number = 2*sum_of_set-sum_of_nums\\n        return single_number"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        from collections import Counter\\n        x=Counter(nums)\\n        t=min(x.values())\\n        for x1,y1 in x.items():\\n            if y1==t:\\n                return x1"
                    },
                    {
                        "username": "Niloofar.montazeri",
                        "content": "I can see how the xor solution works for an array like [1,2,1,3,2,4,3,...], where at most 2 numbers are combined with xor before one gets cancelled. But Let's say the array is arranged as [1,2,3,4,5  1,2,3,4,5,6]. Then the cumulative xor of the first five elements should be able to keep [the information] for all these five numbers, so that they get cancelled, one by one, after the 6th element. How is that possible?"
                    },
                    {
                        "username": "mikematar",
                        "content": "\\'\\'\\'\\nprint([k for k,v in Counter(nums).items() if v==1][0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "magiclin",
                        "content": "    def single_number(nums)\\n      nums.inject(&:^)\\n    end"
                    }
                ]
            },
            {
                "id": 1574573,
                "content": [
                    {
                        "username": "gn00437805",
                        "content": "public int SingleNumber(List<int> searchList)\\n       \\n {\\n            \\n  return searchList.Aggregate( (a, b) => a ^ b); \\n\\n }"
                    },
                    {
                        "username": "Felicia919",
                        "content": "\\'\\'\\'\\nreturn 2*sum(set(nums))-sum(nums)\\n\\'\\'\\'"
                    },
                    {
                        "username": "ericmcelyea",
                        "content": "Can we just generally agree it is a gimmicky question if there is only one workable solution that fits all the constraints?"
                    },
                    {
                        "username": "FerasBarahmeh",
                        "content": "\\nkeep in mind we will find a solution in one loop (linear runtime complexity)\\n\\nAsk yourself a question how i can abandon duplicate numbers ?\\n\\nIt may be dangerous for your mind tow solutions\\n\\n- subtraction the repated numbers\\n- using XOR operator (We Will solve problem in this way)\\n    in XOR operation the same number will give zero (in binary)\\n    for example :\\n        3 ^ 3 Three in binary equal 0 0 1 1\\n       let\\'s Go applay Xor operation :  3 ^ 3\\n        0 0 1 1\\n        0 0 1 1 ^\\n        -------\\n        0 0 0 0\\n\\n    I hope the explanation is clear at the this point\\n\\n    Now I think you can now imagine the solution\\n    if you applay xor for all elemnet in array all the appears    twice numbers will give zeros in the result you find just a single number Let tack example\\n\\n    array = [4,1,2,1,2]\\n    let sort array [1,1,2,2,4]\\n    1 ^ 1 = 0 \\n    0 ^ 2 ^ 2 = 0 ***(0 the result of 1 ^ 1 = 0)***\\n    0 ^ 4 = 4 \\n   (So The Result is 4)\\n\\n"
                    },
                    {
                        "username": "silentvoyager",
                        "content": "I didn\\'t realize I could use XOR so I came up with a tricky solution that used the fact the input numbers are in [-30000,30000] range so require 2 bytes each. I reused the upper 2 bytes of each element in the array to implement an open addressing hash set with linear probing. Basically the hash set ended up being in place in the same input array without using any additional memory. I realized this was overcomplicated but I was interested to see if I could make this work. I did."
                    },
                    {
                        "username": "ondeezesug",
                        "content": "[@1Hanif1](/1Hanif1) you need to attend your data structure classes lol \\n"
                    },
                    {
                        "username": "1Hanif1",
                        "content": "I\\'m 2 years late but can you explain what \"open addressing hash set with linear probing\" is please?"
                    },
                    {
                        "username": "yqzfm123",
                        "content": " return reduce(lambda a,b:a^b,nums)"
                    },
                    {
                        "username": "zhenf",
                        "content": "Most of the submissions of O(n) without extra space here use XOR. Is there any other possible solutions here?"
                    },
                    {
                        "username": "shourovkun",
                        "content": "[@srkr](/srkr) Doesn\\'t set_of_nums have linear space complexity?"
                    },
                    {
                        "username": "srkr",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        sum_of_nums=sum(nums)\\n        sum_of_set=sum(set(nums))\\n        single_number = 2*sum_of_set-sum_of_nums\\n        return single_number"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        from collections import Counter\\n        x=Counter(nums)\\n        t=min(x.values())\\n        for x1,y1 in x.items():\\n            if y1==t:\\n                return x1"
                    },
                    {
                        "username": "Niloofar.montazeri",
                        "content": "I can see how the xor solution works for an array like [1,2,1,3,2,4,3,...], where at most 2 numbers are combined with xor before one gets cancelled. But Let's say the array is arranged as [1,2,3,4,5  1,2,3,4,5,6]. Then the cumulative xor of the first five elements should be able to keep [the information] for all these five numbers, so that they get cancelled, one by one, after the 6th element. How is that possible?"
                    },
                    {
                        "username": "mikematar",
                        "content": "\\'\\'\\'\\nprint([k for k,v in Counter(nums).items() if v==1][0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "magiclin",
                        "content": "    def single_number(nums)\\n      nums.inject(&:^)\\n    end"
                    }
                ]
            },
            {
                "id": 1572235,
                "content": [
                    {
                        "username": "gn00437805",
                        "content": "public int SingleNumber(List<int> searchList)\\n       \\n {\\n            \\n  return searchList.Aggregate( (a, b) => a ^ b); \\n\\n }"
                    },
                    {
                        "username": "Felicia919",
                        "content": "\\'\\'\\'\\nreturn 2*sum(set(nums))-sum(nums)\\n\\'\\'\\'"
                    },
                    {
                        "username": "ericmcelyea",
                        "content": "Can we just generally agree it is a gimmicky question if there is only one workable solution that fits all the constraints?"
                    },
                    {
                        "username": "FerasBarahmeh",
                        "content": "\\nkeep in mind we will find a solution in one loop (linear runtime complexity)\\n\\nAsk yourself a question how i can abandon duplicate numbers ?\\n\\nIt may be dangerous for your mind tow solutions\\n\\n- subtraction the repated numbers\\n- using XOR operator (We Will solve problem in this way)\\n    in XOR operation the same number will give zero (in binary)\\n    for example :\\n        3 ^ 3 Three in binary equal 0 0 1 1\\n       let\\'s Go applay Xor operation :  3 ^ 3\\n        0 0 1 1\\n        0 0 1 1 ^\\n        -------\\n        0 0 0 0\\n\\n    I hope the explanation is clear at the this point\\n\\n    Now I think you can now imagine the solution\\n    if you applay xor for all elemnet in array all the appears    twice numbers will give zeros in the result you find just a single number Let tack example\\n\\n    array = [4,1,2,1,2]\\n    let sort array [1,1,2,2,4]\\n    1 ^ 1 = 0 \\n    0 ^ 2 ^ 2 = 0 ***(0 the result of 1 ^ 1 = 0)***\\n    0 ^ 4 = 4 \\n   (So The Result is 4)\\n\\n"
                    },
                    {
                        "username": "silentvoyager",
                        "content": "I didn\\'t realize I could use XOR so I came up with a tricky solution that used the fact the input numbers are in [-30000,30000] range so require 2 bytes each. I reused the upper 2 bytes of each element in the array to implement an open addressing hash set with linear probing. Basically the hash set ended up being in place in the same input array without using any additional memory. I realized this was overcomplicated but I was interested to see if I could make this work. I did."
                    },
                    {
                        "username": "ondeezesug",
                        "content": "[@1Hanif1](/1Hanif1) you need to attend your data structure classes lol \\n"
                    },
                    {
                        "username": "1Hanif1",
                        "content": "I\\'m 2 years late but can you explain what \"open addressing hash set with linear probing\" is please?"
                    },
                    {
                        "username": "yqzfm123",
                        "content": " return reduce(lambda a,b:a^b,nums)"
                    },
                    {
                        "username": "zhenf",
                        "content": "Most of the submissions of O(n) without extra space here use XOR. Is there any other possible solutions here?"
                    },
                    {
                        "username": "shourovkun",
                        "content": "[@srkr](/srkr) Doesn\\'t set_of_nums have linear space complexity?"
                    },
                    {
                        "username": "srkr",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        sum_of_nums=sum(nums)\\n        sum_of_set=sum(set(nums))\\n        single_number = 2*sum_of_set-sum_of_nums\\n        return single_number"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        from collections import Counter\\n        x=Counter(nums)\\n        t=min(x.values())\\n        for x1,y1 in x.items():\\n            if y1==t:\\n                return x1"
                    },
                    {
                        "username": "Niloofar.montazeri",
                        "content": "I can see how the xor solution works for an array like [1,2,1,3,2,4,3,...], where at most 2 numbers are combined with xor before one gets cancelled. But Let's say the array is arranged as [1,2,3,4,5  1,2,3,4,5,6]. Then the cumulative xor of the first five elements should be able to keep [the information] for all these five numbers, so that they get cancelled, one by one, after the 6th element. How is that possible?"
                    },
                    {
                        "username": "mikematar",
                        "content": "\\'\\'\\'\\nprint([k for k,v in Counter(nums).items() if v==1][0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "magiclin",
                        "content": "    def single_number(nums)\\n      nums.inject(&:^)\\n    end"
                    }
                ]
            },
            {
                "id": 1572058,
                "content": [
                    {
                        "username": "gn00437805",
                        "content": "public int SingleNumber(List<int> searchList)\\n       \\n {\\n            \\n  return searchList.Aggregate( (a, b) => a ^ b); \\n\\n }"
                    },
                    {
                        "username": "Felicia919",
                        "content": "\\'\\'\\'\\nreturn 2*sum(set(nums))-sum(nums)\\n\\'\\'\\'"
                    },
                    {
                        "username": "ericmcelyea",
                        "content": "Can we just generally agree it is a gimmicky question if there is only one workable solution that fits all the constraints?"
                    },
                    {
                        "username": "FerasBarahmeh",
                        "content": "\\nkeep in mind we will find a solution in one loop (linear runtime complexity)\\n\\nAsk yourself a question how i can abandon duplicate numbers ?\\n\\nIt may be dangerous for your mind tow solutions\\n\\n- subtraction the repated numbers\\n- using XOR operator (We Will solve problem in this way)\\n    in XOR operation the same number will give zero (in binary)\\n    for example :\\n        3 ^ 3 Three in binary equal 0 0 1 1\\n       let\\'s Go applay Xor operation :  3 ^ 3\\n        0 0 1 1\\n        0 0 1 1 ^\\n        -------\\n        0 0 0 0\\n\\n    I hope the explanation is clear at the this point\\n\\n    Now I think you can now imagine the solution\\n    if you applay xor for all elemnet in array all the appears    twice numbers will give zeros in the result you find just a single number Let tack example\\n\\n    array = [4,1,2,1,2]\\n    let sort array [1,1,2,2,4]\\n    1 ^ 1 = 0 \\n    0 ^ 2 ^ 2 = 0 ***(0 the result of 1 ^ 1 = 0)***\\n    0 ^ 4 = 4 \\n   (So The Result is 4)\\n\\n"
                    },
                    {
                        "username": "silentvoyager",
                        "content": "I didn\\'t realize I could use XOR so I came up with a tricky solution that used the fact the input numbers are in [-30000,30000] range so require 2 bytes each. I reused the upper 2 bytes of each element in the array to implement an open addressing hash set with linear probing. Basically the hash set ended up being in place in the same input array without using any additional memory. I realized this was overcomplicated but I was interested to see if I could make this work. I did."
                    },
                    {
                        "username": "ondeezesug",
                        "content": "[@1Hanif1](/1Hanif1) you need to attend your data structure classes lol \\n"
                    },
                    {
                        "username": "1Hanif1",
                        "content": "I\\'m 2 years late but can you explain what \"open addressing hash set with linear probing\" is please?"
                    },
                    {
                        "username": "yqzfm123",
                        "content": " return reduce(lambda a,b:a^b,nums)"
                    },
                    {
                        "username": "zhenf",
                        "content": "Most of the submissions of O(n) without extra space here use XOR. Is there any other possible solutions here?"
                    },
                    {
                        "username": "shourovkun",
                        "content": "[@srkr](/srkr) Doesn\\'t set_of_nums have linear space complexity?"
                    },
                    {
                        "username": "srkr",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        sum_of_nums=sum(nums)\\n        sum_of_set=sum(set(nums))\\n        single_number = 2*sum_of_set-sum_of_nums\\n        return single_number"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        from collections import Counter\\n        x=Counter(nums)\\n        t=min(x.values())\\n        for x1,y1 in x.items():\\n            if y1==t:\\n                return x1"
                    },
                    {
                        "username": "Niloofar.montazeri",
                        "content": "I can see how the xor solution works for an array like [1,2,1,3,2,4,3,...], where at most 2 numbers are combined with xor before one gets cancelled. But Let's say the array is arranged as [1,2,3,4,5  1,2,3,4,5,6]. Then the cumulative xor of the first five elements should be able to keep [the information] for all these five numbers, so that they get cancelled, one by one, after the 6th element. How is that possible?"
                    },
                    {
                        "username": "mikematar",
                        "content": "\\'\\'\\'\\nprint([k for k,v in Counter(nums).items() if v==1][0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "magiclin",
                        "content": "    def single_number(nums)\\n      nums.inject(&:^)\\n    end"
                    }
                ]
            },
            {
                "id": 1571294,
                "content": [
                    {
                        "username": "gn00437805",
                        "content": "public int SingleNumber(List<int> searchList)\\n       \\n {\\n            \\n  return searchList.Aggregate( (a, b) => a ^ b); \\n\\n }"
                    },
                    {
                        "username": "Felicia919",
                        "content": "\\'\\'\\'\\nreturn 2*sum(set(nums))-sum(nums)\\n\\'\\'\\'"
                    },
                    {
                        "username": "ericmcelyea",
                        "content": "Can we just generally agree it is a gimmicky question if there is only one workable solution that fits all the constraints?"
                    },
                    {
                        "username": "FerasBarahmeh",
                        "content": "\\nkeep in mind we will find a solution in one loop (linear runtime complexity)\\n\\nAsk yourself a question how i can abandon duplicate numbers ?\\n\\nIt may be dangerous for your mind tow solutions\\n\\n- subtraction the repated numbers\\n- using XOR operator (We Will solve problem in this way)\\n    in XOR operation the same number will give zero (in binary)\\n    for example :\\n        3 ^ 3 Three in binary equal 0 0 1 1\\n       let\\'s Go applay Xor operation :  3 ^ 3\\n        0 0 1 1\\n        0 0 1 1 ^\\n        -------\\n        0 0 0 0\\n\\n    I hope the explanation is clear at the this point\\n\\n    Now I think you can now imagine the solution\\n    if you applay xor for all elemnet in array all the appears    twice numbers will give zeros in the result you find just a single number Let tack example\\n\\n    array = [4,1,2,1,2]\\n    let sort array [1,1,2,2,4]\\n    1 ^ 1 = 0 \\n    0 ^ 2 ^ 2 = 0 ***(0 the result of 1 ^ 1 = 0)***\\n    0 ^ 4 = 4 \\n   (So The Result is 4)\\n\\n"
                    },
                    {
                        "username": "silentvoyager",
                        "content": "I didn\\'t realize I could use XOR so I came up with a tricky solution that used the fact the input numbers are in [-30000,30000] range so require 2 bytes each. I reused the upper 2 bytes of each element in the array to implement an open addressing hash set with linear probing. Basically the hash set ended up being in place in the same input array without using any additional memory. I realized this was overcomplicated but I was interested to see if I could make this work. I did."
                    },
                    {
                        "username": "ondeezesug",
                        "content": "[@1Hanif1](/1Hanif1) you need to attend your data structure classes lol \\n"
                    },
                    {
                        "username": "1Hanif1",
                        "content": "I\\'m 2 years late but can you explain what \"open addressing hash set with linear probing\" is please?"
                    },
                    {
                        "username": "yqzfm123",
                        "content": " return reduce(lambda a,b:a^b,nums)"
                    },
                    {
                        "username": "zhenf",
                        "content": "Most of the submissions of O(n) without extra space here use XOR. Is there any other possible solutions here?"
                    },
                    {
                        "username": "shourovkun",
                        "content": "[@srkr](/srkr) Doesn\\'t set_of_nums have linear space complexity?"
                    },
                    {
                        "username": "srkr",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        sum_of_nums=sum(nums)\\n        sum_of_set=sum(set(nums))\\n        single_number = 2*sum_of_set-sum_of_nums\\n        return single_number"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        from collections import Counter\\n        x=Counter(nums)\\n        t=min(x.values())\\n        for x1,y1 in x.items():\\n            if y1==t:\\n                return x1"
                    },
                    {
                        "username": "Niloofar.montazeri",
                        "content": "I can see how the xor solution works for an array like [1,2,1,3,2,4,3,...], where at most 2 numbers are combined with xor before one gets cancelled. But Let's say the array is arranged as [1,2,3,4,5  1,2,3,4,5,6]. Then the cumulative xor of the first five elements should be able to keep [the information] for all these five numbers, so that they get cancelled, one by one, after the 6th element. How is that possible?"
                    },
                    {
                        "username": "mikematar",
                        "content": "\\'\\'\\'\\nprint([k for k,v in Counter(nums).items() if v==1][0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "magiclin",
                        "content": "    def single_number(nums)\\n      nums.inject(&:^)\\n    end"
                    }
                ]
            },
            {
                "id": 1574851,
                "content": [
                    {
                        "username": "gn00437805",
                        "content": "public int SingleNumber(List<int> searchList)\\n       \\n {\\n            \\n  return searchList.Aggregate( (a, b) => a ^ b); \\n\\n }"
                    },
                    {
                        "username": "Felicia919",
                        "content": "\\'\\'\\'\\nreturn 2*sum(set(nums))-sum(nums)\\n\\'\\'\\'"
                    },
                    {
                        "username": "ericmcelyea",
                        "content": "Can we just generally agree it is a gimmicky question if there is only one workable solution that fits all the constraints?"
                    },
                    {
                        "username": "FerasBarahmeh",
                        "content": "\\nkeep in mind we will find a solution in one loop (linear runtime complexity)\\n\\nAsk yourself a question how i can abandon duplicate numbers ?\\n\\nIt may be dangerous for your mind tow solutions\\n\\n- subtraction the repated numbers\\n- using XOR operator (We Will solve problem in this way)\\n    in XOR operation the same number will give zero (in binary)\\n    for example :\\n        3 ^ 3 Three in binary equal 0 0 1 1\\n       let\\'s Go applay Xor operation :  3 ^ 3\\n        0 0 1 1\\n        0 0 1 1 ^\\n        -------\\n        0 0 0 0\\n\\n    I hope the explanation is clear at the this point\\n\\n    Now I think you can now imagine the solution\\n    if you applay xor for all elemnet in array all the appears    twice numbers will give zeros in the result you find just a single number Let tack example\\n\\n    array = [4,1,2,1,2]\\n    let sort array [1,1,2,2,4]\\n    1 ^ 1 = 0 \\n    0 ^ 2 ^ 2 = 0 ***(0 the result of 1 ^ 1 = 0)***\\n    0 ^ 4 = 4 \\n   (So The Result is 4)\\n\\n"
                    },
                    {
                        "username": "silentvoyager",
                        "content": "I didn\\'t realize I could use XOR so I came up with a tricky solution that used the fact the input numbers are in [-30000,30000] range so require 2 bytes each. I reused the upper 2 bytes of each element in the array to implement an open addressing hash set with linear probing. Basically the hash set ended up being in place in the same input array without using any additional memory. I realized this was overcomplicated but I was interested to see if I could make this work. I did."
                    },
                    {
                        "username": "ondeezesug",
                        "content": "[@1Hanif1](/1Hanif1) you need to attend your data structure classes lol \\n"
                    },
                    {
                        "username": "1Hanif1",
                        "content": "I\\'m 2 years late but can you explain what \"open addressing hash set with linear probing\" is please?"
                    },
                    {
                        "username": "yqzfm123",
                        "content": " return reduce(lambda a,b:a^b,nums)"
                    },
                    {
                        "username": "zhenf",
                        "content": "Most of the submissions of O(n) without extra space here use XOR. Is there any other possible solutions here?"
                    },
                    {
                        "username": "shourovkun",
                        "content": "[@srkr](/srkr) Doesn\\'t set_of_nums have linear space complexity?"
                    },
                    {
                        "username": "srkr",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        sum_of_nums=sum(nums)\\n        sum_of_set=sum(set(nums))\\n        single_number = 2*sum_of_set-sum_of_nums\\n        return single_number"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        from collections import Counter\\n        x=Counter(nums)\\n        t=min(x.values())\\n        for x1,y1 in x.items():\\n            if y1==t:\\n                return x1"
                    },
                    {
                        "username": "Niloofar.montazeri",
                        "content": "I can see how the xor solution works for an array like [1,2,1,3,2,4,3,...], where at most 2 numbers are combined with xor before one gets cancelled. But Let's say the array is arranged as [1,2,3,4,5  1,2,3,4,5,6]. Then the cumulative xor of the first five elements should be able to keep [the information] for all these five numbers, so that they get cancelled, one by one, after the 6th element. How is that possible?"
                    },
                    {
                        "username": "mikematar",
                        "content": "\\'\\'\\'\\nprint([k for k,v in Counter(nums).items() if v==1][0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "magiclin",
                        "content": "    def single_number(nums)\\n      nums.inject(&:^)\\n    end"
                    }
                ]
            },
            {
                "id": 1571293,
                "content": [
                    {
                        "username": "gn00437805",
                        "content": "public int SingleNumber(List<int> searchList)\\n       \\n {\\n            \\n  return searchList.Aggregate( (a, b) => a ^ b); \\n\\n }"
                    },
                    {
                        "username": "Felicia919",
                        "content": "\\'\\'\\'\\nreturn 2*sum(set(nums))-sum(nums)\\n\\'\\'\\'"
                    },
                    {
                        "username": "ericmcelyea",
                        "content": "Can we just generally agree it is a gimmicky question if there is only one workable solution that fits all the constraints?"
                    },
                    {
                        "username": "FerasBarahmeh",
                        "content": "\\nkeep in mind we will find a solution in one loop (linear runtime complexity)\\n\\nAsk yourself a question how i can abandon duplicate numbers ?\\n\\nIt may be dangerous for your mind tow solutions\\n\\n- subtraction the repated numbers\\n- using XOR operator (We Will solve problem in this way)\\n    in XOR operation the same number will give zero (in binary)\\n    for example :\\n        3 ^ 3 Three in binary equal 0 0 1 1\\n       let\\'s Go applay Xor operation :  3 ^ 3\\n        0 0 1 1\\n        0 0 1 1 ^\\n        -------\\n        0 0 0 0\\n\\n    I hope the explanation is clear at the this point\\n\\n    Now I think you can now imagine the solution\\n    if you applay xor for all elemnet in array all the appears    twice numbers will give zeros in the result you find just a single number Let tack example\\n\\n    array = [4,1,2,1,2]\\n    let sort array [1,1,2,2,4]\\n    1 ^ 1 = 0 \\n    0 ^ 2 ^ 2 = 0 ***(0 the result of 1 ^ 1 = 0)***\\n    0 ^ 4 = 4 \\n   (So The Result is 4)\\n\\n"
                    },
                    {
                        "username": "silentvoyager",
                        "content": "I didn\\'t realize I could use XOR so I came up with a tricky solution that used the fact the input numbers are in [-30000,30000] range so require 2 bytes each. I reused the upper 2 bytes of each element in the array to implement an open addressing hash set with linear probing. Basically the hash set ended up being in place in the same input array without using any additional memory. I realized this was overcomplicated but I was interested to see if I could make this work. I did."
                    },
                    {
                        "username": "ondeezesug",
                        "content": "[@1Hanif1](/1Hanif1) you need to attend your data structure classes lol \\n"
                    },
                    {
                        "username": "1Hanif1",
                        "content": "I\\'m 2 years late but can you explain what \"open addressing hash set with linear probing\" is please?"
                    },
                    {
                        "username": "yqzfm123",
                        "content": " return reduce(lambda a,b:a^b,nums)"
                    },
                    {
                        "username": "zhenf",
                        "content": "Most of the submissions of O(n) without extra space here use XOR. Is there any other possible solutions here?"
                    },
                    {
                        "username": "shourovkun",
                        "content": "[@srkr](/srkr) Doesn\\'t set_of_nums have linear space complexity?"
                    },
                    {
                        "username": "srkr",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        sum_of_nums=sum(nums)\\n        sum_of_set=sum(set(nums))\\n        single_number = 2*sum_of_set-sum_of_nums\\n        return single_number"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        from collections import Counter\\n        x=Counter(nums)\\n        t=min(x.values())\\n        for x1,y1 in x.items():\\n            if y1==t:\\n                return x1"
                    },
                    {
                        "username": "Niloofar.montazeri",
                        "content": "I can see how the xor solution works for an array like [1,2,1,3,2,4,3,...], where at most 2 numbers are combined with xor before one gets cancelled. But Let's say the array is arranged as [1,2,3,4,5  1,2,3,4,5,6]. Then the cumulative xor of the first five elements should be able to keep [the information] for all these five numbers, so that they get cancelled, one by one, after the 6th element. How is that possible?"
                    },
                    {
                        "username": "mikematar",
                        "content": "\\'\\'\\'\\nprint([k for k,v in Counter(nums).items() if v==1][0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "magiclin",
                        "content": "    def single_number(nums)\\n      nums.inject(&:^)\\n    end"
                    }
                ]
            },
            {
                "id": 1571295,
                "content": [
                    {
                        "username": "AnastasiiaL",
                        "content": "     x = nums[0]\\n        for i in 1...nums.size do x = x^nums[i] end\\n     x"
                    },
                    {
                        "username": "amrithaunni",
                        "content": "\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t\\t# Xoring the entire list will give the unique element\\n\\t\\treturn reduce(lambda x, y: x ^ y, nums)\\n"
                    },
                    {
                        "username": "sweetleaf",
                        "content": "Can we solve this problem by sorting the array and doing a binary search?"
                    },
                    {
                        "username": "hadinajafi",
                        "content": "Yes. you also can use Stack when you sort it. If stack is empty, just push, and if next element is as same as the head of stack, then pop the element.\\nAt the end, only the unique element will remain at stack."
                    },
                    {
                        "username": "chandrikabijore",
                        "content": "ask"
                    },
                    {
                        "username": "ShubhRajawat",
                        "content": "sort() method is allowed here\\n"
                    },
                    {
                        "username": "Shahwali_python",
                        "content": "can i use ` count ` function \\n"
                    },
                    {
                        "username": "eascgpq048",
                        "content": "Does anybody known which promble with this code?\\n\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        for i in range(len(nums)):\\n            found_match = False\\n            for j in range(i+1, len(nums)):\\n                if nums[i] == nums[j]:\\n                    found_match = True\\n                    break\\n            if not found_match and nums[i] not in nums[:i]:\\n                print(nums[i])"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "HINT: XOR is your friend here"
                    },
                    {
                        "username": "kundanpms527",
                        "content": "int singleNumber(vector<int>& nums)\\n     {\\n         int result = 0;\\n    for (int num : nums) {\\n        result ^= num;\\n    }\\n    return result;\\n     }"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number II](https://leetcode.com/problems/single-number-ii/description/) now. All the best \\u2728"
                    }
                ]
            },
            {
                "id": 1575362,
                "content": [
                    {
                        "username": "AnastasiiaL",
                        "content": "     x = nums[0]\\n        for i in 1...nums.size do x = x^nums[i] end\\n     x"
                    },
                    {
                        "username": "amrithaunni",
                        "content": "\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t\\t# Xoring the entire list will give the unique element\\n\\t\\treturn reduce(lambda x, y: x ^ y, nums)\\n"
                    },
                    {
                        "username": "sweetleaf",
                        "content": "Can we solve this problem by sorting the array and doing a binary search?"
                    },
                    {
                        "username": "hadinajafi",
                        "content": "Yes. you also can use Stack when you sort it. If stack is empty, just push, and if next element is as same as the head of stack, then pop the element.\\nAt the end, only the unique element will remain at stack."
                    },
                    {
                        "username": "chandrikabijore",
                        "content": "ask"
                    },
                    {
                        "username": "ShubhRajawat",
                        "content": "sort() method is allowed here\\n"
                    },
                    {
                        "username": "Shahwali_python",
                        "content": "can i use ` count ` function \\n"
                    },
                    {
                        "username": "eascgpq048",
                        "content": "Does anybody known which promble with this code?\\n\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        for i in range(len(nums)):\\n            found_match = False\\n            for j in range(i+1, len(nums)):\\n                if nums[i] == nums[j]:\\n                    found_match = True\\n                    break\\n            if not found_match and nums[i] not in nums[:i]:\\n                print(nums[i])"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "HINT: XOR is your friend here"
                    },
                    {
                        "username": "kundanpms527",
                        "content": "int singleNumber(vector<int>& nums)\\n     {\\n         int result = 0;\\n    for (int num : nums) {\\n        result ^= num;\\n    }\\n    return result;\\n     }"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number II](https://leetcode.com/problems/single-number-ii/description/) now. All the best \\u2728"
                    }
                ]
            },
            {
                "id": 1571928,
                "content": [
                    {
                        "username": "AnastasiiaL",
                        "content": "     x = nums[0]\\n        for i in 1...nums.size do x = x^nums[i] end\\n     x"
                    },
                    {
                        "username": "amrithaunni",
                        "content": "\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t\\t# Xoring the entire list will give the unique element\\n\\t\\treturn reduce(lambda x, y: x ^ y, nums)\\n"
                    },
                    {
                        "username": "sweetleaf",
                        "content": "Can we solve this problem by sorting the array and doing a binary search?"
                    },
                    {
                        "username": "hadinajafi",
                        "content": "Yes. you also can use Stack when you sort it. If stack is empty, just push, and if next element is as same as the head of stack, then pop the element.\\nAt the end, only the unique element will remain at stack."
                    },
                    {
                        "username": "chandrikabijore",
                        "content": "ask"
                    },
                    {
                        "username": "ShubhRajawat",
                        "content": "sort() method is allowed here\\n"
                    },
                    {
                        "username": "Shahwali_python",
                        "content": "can i use ` count ` function \\n"
                    },
                    {
                        "username": "eascgpq048",
                        "content": "Does anybody known which promble with this code?\\n\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        for i in range(len(nums)):\\n            found_match = False\\n            for j in range(i+1, len(nums)):\\n                if nums[i] == nums[j]:\\n                    found_match = True\\n                    break\\n            if not found_match and nums[i] not in nums[:i]:\\n                print(nums[i])"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "HINT: XOR is your friend here"
                    },
                    {
                        "username": "kundanpms527",
                        "content": "int singleNumber(vector<int>& nums)\\n     {\\n         int result = 0;\\n    for (int num : nums) {\\n        result ^= num;\\n    }\\n    return result;\\n     }"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number II](https://leetcode.com/problems/single-number-ii/description/) now. All the best \\u2728"
                    }
                ]
            },
            {
                "id": 2074267,
                "content": [
                    {
                        "username": "AnastasiiaL",
                        "content": "     x = nums[0]\\n        for i in 1...nums.size do x = x^nums[i] end\\n     x"
                    },
                    {
                        "username": "amrithaunni",
                        "content": "\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t\\t# Xoring the entire list will give the unique element\\n\\t\\treturn reduce(lambda x, y: x ^ y, nums)\\n"
                    },
                    {
                        "username": "sweetleaf",
                        "content": "Can we solve this problem by sorting the array and doing a binary search?"
                    },
                    {
                        "username": "hadinajafi",
                        "content": "Yes. you also can use Stack when you sort it. If stack is empty, just push, and if next element is as same as the head of stack, then pop the element.\\nAt the end, only the unique element will remain at stack."
                    },
                    {
                        "username": "chandrikabijore",
                        "content": "ask"
                    },
                    {
                        "username": "ShubhRajawat",
                        "content": "sort() method is allowed here\\n"
                    },
                    {
                        "username": "Shahwali_python",
                        "content": "can i use ` count ` function \\n"
                    },
                    {
                        "username": "eascgpq048",
                        "content": "Does anybody known which promble with this code?\\n\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        for i in range(len(nums)):\\n            found_match = False\\n            for j in range(i+1, len(nums)):\\n                if nums[i] == nums[j]:\\n                    found_match = True\\n                    break\\n            if not found_match and nums[i] not in nums[:i]:\\n                print(nums[i])"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "HINT: XOR is your friend here"
                    },
                    {
                        "username": "kundanpms527",
                        "content": "int singleNumber(vector<int>& nums)\\n     {\\n         int result = 0;\\n    for (int num : nums) {\\n        result ^= num;\\n    }\\n    return result;\\n     }"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number II](https://leetcode.com/problems/single-number-ii/description/) now. All the best \\u2728"
                    }
                ]
            },
            {
                "id": 2072776,
                "content": [
                    {
                        "username": "AnastasiiaL",
                        "content": "     x = nums[0]\\n        for i in 1...nums.size do x = x^nums[i] end\\n     x"
                    },
                    {
                        "username": "amrithaunni",
                        "content": "\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t\\t# Xoring the entire list will give the unique element\\n\\t\\treturn reduce(lambda x, y: x ^ y, nums)\\n"
                    },
                    {
                        "username": "sweetleaf",
                        "content": "Can we solve this problem by sorting the array and doing a binary search?"
                    },
                    {
                        "username": "hadinajafi",
                        "content": "Yes. you also can use Stack when you sort it. If stack is empty, just push, and if next element is as same as the head of stack, then pop the element.\\nAt the end, only the unique element will remain at stack."
                    },
                    {
                        "username": "chandrikabijore",
                        "content": "ask"
                    },
                    {
                        "username": "ShubhRajawat",
                        "content": "sort() method is allowed here\\n"
                    },
                    {
                        "username": "Shahwali_python",
                        "content": "can i use ` count ` function \\n"
                    },
                    {
                        "username": "eascgpq048",
                        "content": "Does anybody known which promble with this code?\\n\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        for i in range(len(nums)):\\n            found_match = False\\n            for j in range(i+1, len(nums)):\\n                if nums[i] == nums[j]:\\n                    found_match = True\\n                    break\\n            if not found_match and nums[i] not in nums[:i]:\\n                print(nums[i])"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "HINT: XOR is your friend here"
                    },
                    {
                        "username": "kundanpms527",
                        "content": "int singleNumber(vector<int>& nums)\\n     {\\n         int result = 0;\\n    for (int num : nums) {\\n        result ^= num;\\n    }\\n    return result;\\n     }"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number II](https://leetcode.com/problems/single-number-ii/description/) now. All the best \\u2728"
                    }
                ]
            },
            {
                "id": 2069067,
                "content": [
                    {
                        "username": "AnastasiiaL",
                        "content": "     x = nums[0]\\n        for i in 1...nums.size do x = x^nums[i] end\\n     x"
                    },
                    {
                        "username": "amrithaunni",
                        "content": "\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t\\t# Xoring the entire list will give the unique element\\n\\t\\treturn reduce(lambda x, y: x ^ y, nums)\\n"
                    },
                    {
                        "username": "sweetleaf",
                        "content": "Can we solve this problem by sorting the array and doing a binary search?"
                    },
                    {
                        "username": "hadinajafi",
                        "content": "Yes. you also can use Stack when you sort it. If stack is empty, just push, and if next element is as same as the head of stack, then pop the element.\\nAt the end, only the unique element will remain at stack."
                    },
                    {
                        "username": "chandrikabijore",
                        "content": "ask"
                    },
                    {
                        "username": "ShubhRajawat",
                        "content": "sort() method is allowed here\\n"
                    },
                    {
                        "username": "Shahwali_python",
                        "content": "can i use ` count ` function \\n"
                    },
                    {
                        "username": "eascgpq048",
                        "content": "Does anybody known which promble with this code?\\n\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        for i in range(len(nums)):\\n            found_match = False\\n            for j in range(i+1, len(nums)):\\n                if nums[i] == nums[j]:\\n                    found_match = True\\n                    break\\n            if not found_match and nums[i] not in nums[:i]:\\n                print(nums[i])"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "HINT: XOR is your friend here"
                    },
                    {
                        "username": "kundanpms527",
                        "content": "int singleNumber(vector<int>& nums)\\n     {\\n         int result = 0;\\n    for (int num : nums) {\\n        result ^= num;\\n    }\\n    return result;\\n     }"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number II](https://leetcode.com/problems/single-number-ii/description/) now. All the best \\u2728"
                    }
                ]
            },
            {
                "id": 2065678,
                "content": [
                    {
                        "username": "AnastasiiaL",
                        "content": "     x = nums[0]\\n        for i in 1...nums.size do x = x^nums[i] end\\n     x"
                    },
                    {
                        "username": "amrithaunni",
                        "content": "\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t\\t# Xoring the entire list will give the unique element\\n\\t\\treturn reduce(lambda x, y: x ^ y, nums)\\n"
                    },
                    {
                        "username": "sweetleaf",
                        "content": "Can we solve this problem by sorting the array and doing a binary search?"
                    },
                    {
                        "username": "hadinajafi",
                        "content": "Yes. you also can use Stack when you sort it. If stack is empty, just push, and if next element is as same as the head of stack, then pop the element.\\nAt the end, only the unique element will remain at stack."
                    },
                    {
                        "username": "chandrikabijore",
                        "content": "ask"
                    },
                    {
                        "username": "ShubhRajawat",
                        "content": "sort() method is allowed here\\n"
                    },
                    {
                        "username": "Shahwali_python",
                        "content": "can i use ` count ` function \\n"
                    },
                    {
                        "username": "eascgpq048",
                        "content": "Does anybody known which promble with this code?\\n\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        for i in range(len(nums)):\\n            found_match = False\\n            for j in range(i+1, len(nums)):\\n                if nums[i] == nums[j]:\\n                    found_match = True\\n                    break\\n            if not found_match and nums[i] not in nums[:i]:\\n                print(nums[i])"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "HINT: XOR is your friend here"
                    },
                    {
                        "username": "kundanpms527",
                        "content": "int singleNumber(vector<int>& nums)\\n     {\\n         int result = 0;\\n    for (int num : nums) {\\n        result ^= num;\\n    }\\n    return result;\\n     }"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number II](https://leetcode.com/problems/single-number-ii/description/) now. All the best \\u2728"
                    }
                ]
            },
            {
                "id": 2064320,
                "content": [
                    {
                        "username": "AnastasiiaL",
                        "content": "     x = nums[0]\\n        for i in 1...nums.size do x = x^nums[i] end\\n     x"
                    },
                    {
                        "username": "amrithaunni",
                        "content": "\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t\\t# Xoring the entire list will give the unique element\\n\\t\\treturn reduce(lambda x, y: x ^ y, nums)\\n"
                    },
                    {
                        "username": "sweetleaf",
                        "content": "Can we solve this problem by sorting the array and doing a binary search?"
                    },
                    {
                        "username": "hadinajafi",
                        "content": "Yes. you also can use Stack when you sort it. If stack is empty, just push, and if next element is as same as the head of stack, then pop the element.\\nAt the end, only the unique element will remain at stack."
                    },
                    {
                        "username": "chandrikabijore",
                        "content": "ask"
                    },
                    {
                        "username": "ShubhRajawat",
                        "content": "sort() method is allowed here\\n"
                    },
                    {
                        "username": "Shahwali_python",
                        "content": "can i use ` count ` function \\n"
                    },
                    {
                        "username": "eascgpq048",
                        "content": "Does anybody known which promble with this code?\\n\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        for i in range(len(nums)):\\n            found_match = False\\n            for j in range(i+1, len(nums)):\\n                if nums[i] == nums[j]:\\n                    found_match = True\\n                    break\\n            if not found_match and nums[i] not in nums[:i]:\\n                print(nums[i])"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "HINT: XOR is your friend here"
                    },
                    {
                        "username": "kundanpms527",
                        "content": "int singleNumber(vector<int>& nums)\\n     {\\n         int result = 0;\\n    for (int num : nums) {\\n        result ^= num;\\n    }\\n    return result;\\n     }"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number II](https://leetcode.com/problems/single-number-ii/description/) now. All the best \\u2728"
                    }
                ]
            },
            {
                "id": 2055747,
                "content": [
                    {
                        "username": "AnastasiiaL",
                        "content": "     x = nums[0]\\n        for i in 1...nums.size do x = x^nums[i] end\\n     x"
                    },
                    {
                        "username": "amrithaunni",
                        "content": "\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t\\t# Xoring the entire list will give the unique element\\n\\t\\treturn reduce(lambda x, y: x ^ y, nums)\\n"
                    },
                    {
                        "username": "sweetleaf",
                        "content": "Can we solve this problem by sorting the array and doing a binary search?"
                    },
                    {
                        "username": "hadinajafi",
                        "content": "Yes. you also can use Stack when you sort it. If stack is empty, just push, and if next element is as same as the head of stack, then pop the element.\\nAt the end, only the unique element will remain at stack."
                    },
                    {
                        "username": "chandrikabijore",
                        "content": "ask"
                    },
                    {
                        "username": "ShubhRajawat",
                        "content": "sort() method is allowed here\\n"
                    },
                    {
                        "username": "Shahwali_python",
                        "content": "can i use ` count ` function \\n"
                    },
                    {
                        "username": "eascgpq048",
                        "content": "Does anybody known which promble with this code?\\n\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        for i in range(len(nums)):\\n            found_match = False\\n            for j in range(i+1, len(nums)):\\n                if nums[i] == nums[j]:\\n                    found_match = True\\n                    break\\n            if not found_match and nums[i] not in nums[:i]:\\n                print(nums[i])"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "HINT: XOR is your friend here"
                    },
                    {
                        "username": "kundanpms527",
                        "content": "int singleNumber(vector<int>& nums)\\n     {\\n         int result = 0;\\n    for (int num : nums) {\\n        result ^= num;\\n    }\\n    return result;\\n     }"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number II](https://leetcode.com/problems/single-number-ii/description/) now. All the best \\u2728"
                    }
                ]
            },
            {
                "id": 2046328,
                "content": [
                    {
                        "username": "AnastasiiaL",
                        "content": "     x = nums[0]\\n        for i in 1...nums.size do x = x^nums[i] end\\n     x"
                    },
                    {
                        "username": "amrithaunni",
                        "content": "\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t\\t# Xoring the entire list will give the unique element\\n\\t\\treturn reduce(lambda x, y: x ^ y, nums)\\n"
                    },
                    {
                        "username": "sweetleaf",
                        "content": "Can we solve this problem by sorting the array and doing a binary search?"
                    },
                    {
                        "username": "hadinajafi",
                        "content": "Yes. you also can use Stack when you sort it. If stack is empty, just push, and if next element is as same as the head of stack, then pop the element.\\nAt the end, only the unique element will remain at stack."
                    },
                    {
                        "username": "chandrikabijore",
                        "content": "ask"
                    },
                    {
                        "username": "ShubhRajawat",
                        "content": "sort() method is allowed here\\n"
                    },
                    {
                        "username": "Shahwali_python",
                        "content": "can i use ` count ` function \\n"
                    },
                    {
                        "username": "eascgpq048",
                        "content": "Does anybody known which promble with this code?\\n\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        for i in range(len(nums)):\\n            found_match = False\\n            for j in range(i+1, len(nums)):\\n                if nums[i] == nums[j]:\\n                    found_match = True\\n                    break\\n            if not found_match and nums[i] not in nums[:i]:\\n                print(nums[i])"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "HINT: XOR is your friend here"
                    },
                    {
                        "username": "kundanpms527",
                        "content": "int singleNumber(vector<int>& nums)\\n     {\\n         int result = 0;\\n    for (int num : nums) {\\n        result ^= num;\\n    }\\n    return result;\\n     }"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number II](https://leetcode.com/problems/single-number-ii/description/) now. All the best \\u2728"
                    }
                ]
            },
            {
                "id": 2017201,
                "content": [
                    {
                        "username": "zurakatsura",
                        "content": "It can be solved without bitwise in O(1) as well right? Make a set of array, generate sum - sum of array values."
                    },
                    {
                        "username": "ysarath2022",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n       int n = nums.size();\\n     vector<int> count;\\n       for(int i=0;i < n; i++)\\n       {\\n           count[nums[i]]++;\\n       }\\n       for(int i = 0; i< n ; i++)\\n       {\\n           if(count[nums[i]] == 1)\\n           return nums[i];\\n        }\\n        return (-1);\\n\\n        \\n    }\\n}; why is my code not working"
                    },
                    {
                        "username": "Mohtashim_ali",
                        "content": "A simple question for all the people with sound knowledge of logic gates , bit manipulations etc "
                    },
                    {
                        "username": "TwilightVortex",
                        "content": "Hey I don\\'t know if this well help anyone or not, but here is a solution without XOR in C. It is certainly not very effecient, but it works so here it is:\\n\\n```\\nstruct pair {\\n    int num;\\n    bool paired;\\n};\\n\\nvoid addNum(struct pair *nums, int num, int *size) {\\n    for (int i = 0; i < *size; i++) {\\n        if (nums[i].num == num) {\\n            nums[i].paired = true;\\n        }\\n    }\\n    nums[size].num = num;\\n    nums[size].paired = false;\\n    *(size)++;\\n}\\n\\nint singleNumber(int* nums, int numsSize){\\n    int size = 0;\\n    struct pair *nums = malloc(sizeof(struct pair) * numsSize);\\n    for (int i = 0; i < numsSize; i++) {\\n           addNum(nums, num, &size);\\n    }\\n    for (int i = 0; i < size; i++) {\\n        if (nums[i].paired == false) {\\n            return nums[i].num;\\n        }\\n    }\\n    return 1;\\n} \\n```"
                    },
                    {
                        "username": "anilkumarhv",
                        "content": "Hi Guys, XOR operation giving wrong output for below input array\\nint[] nums= [4, 1, 2, 1, 2, 4, 7, 1]\\nexpected output: 7\\nbut actual output : 6"
                    },
                    {
                        "username": "himanshuone",
                        "content": "This Submission passed all the Test cases but, Why I\\'m getting Good Feelings with This?\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        dic=dict()\\n        for _ in nums:\\n            if _ not in dic:\\n                dic[_]=0\\n            else:\\n                dic[_]=dic.get(_)+1\\n        temp = min(dic.values())\\n        res = [key for key in dic if dic[key] == temp]\\n        return (res[0])"
                    },
                    {
                        "username": "user3594P",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int a=0;\\n        int [] fr =new int[nums.length];\\n        int v=-1;\\n        for(int i=0;i<nums.length;i++){\\n            int count=1;\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                    fr[j]=v;\\n                }\\n            }\\n            if (fr[i]!=v){\\n                fr[i]=count;\\n            }\\n             for(int x=0;x<fr.length;x++)\\n             {\\n                 if(fr[x]==1)\\n                 {\\n                     a=nums[i];\\n                 }\\n             }\\n\\n        }\\n        return a;\\n    }\\n} can anyone tell the error in code ?\\n"
                    },
                    {
                        "username": "kunalmahadule77",
                        "content": "Solution of the problem in Python\\n\\nclass Solution:\\n    def singleNumber(self, nums):\\n        # Initialize the result variable with 0\\n        result = 0\\n\\n        # XOR all the elements in the array\\n        for num in nums:\\n            result ^= num\\n\\n        return result\\n"
                    },
                    {
                        "username": "mg5050",
                        "content": "Bad problem description. For people who don\\'t know it\\'s a bit manipulation problem, they need to specify that all inputs are powers of 2. The expected solution does not work once you start throwing in non-power-of-2 numbers, and it\\'s not listed as a constraint anywhere.\\n\\nConstraints should be updated with:\\n\\nnums[i] == 2^X\\n\\nIt\\'s a trick question as far as I\\'m concerned."
                    },
                    {
                        "username": "hugjobk",
                        "content": "If you know how to swap 2 numbers without using a temporary variable then you will know the solution :))"
                    }
                ]
            },
            {
                "id": 2015335,
                "content": [
                    {
                        "username": "zurakatsura",
                        "content": "It can be solved without bitwise in O(1) as well right? Make a set of array, generate sum - sum of array values."
                    },
                    {
                        "username": "ysarath2022",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n       int n = nums.size();\\n     vector<int> count;\\n       for(int i=0;i < n; i++)\\n       {\\n           count[nums[i]]++;\\n       }\\n       for(int i = 0; i< n ; i++)\\n       {\\n           if(count[nums[i]] == 1)\\n           return nums[i];\\n        }\\n        return (-1);\\n\\n        \\n    }\\n}; why is my code not working"
                    },
                    {
                        "username": "Mohtashim_ali",
                        "content": "A simple question for all the people with sound knowledge of logic gates , bit manipulations etc "
                    },
                    {
                        "username": "TwilightVortex",
                        "content": "Hey I don\\'t know if this well help anyone or not, but here is a solution without XOR in C. It is certainly not very effecient, but it works so here it is:\\n\\n```\\nstruct pair {\\n    int num;\\n    bool paired;\\n};\\n\\nvoid addNum(struct pair *nums, int num, int *size) {\\n    for (int i = 0; i < *size; i++) {\\n        if (nums[i].num == num) {\\n            nums[i].paired = true;\\n        }\\n    }\\n    nums[size].num = num;\\n    nums[size].paired = false;\\n    *(size)++;\\n}\\n\\nint singleNumber(int* nums, int numsSize){\\n    int size = 0;\\n    struct pair *nums = malloc(sizeof(struct pair) * numsSize);\\n    for (int i = 0; i < numsSize; i++) {\\n           addNum(nums, num, &size);\\n    }\\n    for (int i = 0; i < size; i++) {\\n        if (nums[i].paired == false) {\\n            return nums[i].num;\\n        }\\n    }\\n    return 1;\\n} \\n```"
                    },
                    {
                        "username": "anilkumarhv",
                        "content": "Hi Guys, XOR operation giving wrong output for below input array\\nint[] nums= [4, 1, 2, 1, 2, 4, 7, 1]\\nexpected output: 7\\nbut actual output : 6"
                    },
                    {
                        "username": "himanshuone",
                        "content": "This Submission passed all the Test cases but, Why I\\'m getting Good Feelings with This?\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        dic=dict()\\n        for _ in nums:\\n            if _ not in dic:\\n                dic[_]=0\\n            else:\\n                dic[_]=dic.get(_)+1\\n        temp = min(dic.values())\\n        res = [key for key in dic if dic[key] == temp]\\n        return (res[0])"
                    },
                    {
                        "username": "user3594P",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int a=0;\\n        int [] fr =new int[nums.length];\\n        int v=-1;\\n        for(int i=0;i<nums.length;i++){\\n            int count=1;\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                    fr[j]=v;\\n                }\\n            }\\n            if (fr[i]!=v){\\n                fr[i]=count;\\n            }\\n             for(int x=0;x<fr.length;x++)\\n             {\\n                 if(fr[x]==1)\\n                 {\\n                     a=nums[i];\\n                 }\\n             }\\n\\n        }\\n        return a;\\n    }\\n} can anyone tell the error in code ?\\n"
                    },
                    {
                        "username": "kunalmahadule77",
                        "content": "Solution of the problem in Python\\n\\nclass Solution:\\n    def singleNumber(self, nums):\\n        # Initialize the result variable with 0\\n        result = 0\\n\\n        # XOR all the elements in the array\\n        for num in nums:\\n            result ^= num\\n\\n        return result\\n"
                    },
                    {
                        "username": "mg5050",
                        "content": "Bad problem description. For people who don\\'t know it\\'s a bit manipulation problem, they need to specify that all inputs are powers of 2. The expected solution does not work once you start throwing in non-power-of-2 numbers, and it\\'s not listed as a constraint anywhere.\\n\\nConstraints should be updated with:\\n\\nnums[i] == 2^X\\n\\nIt\\'s a trick question as far as I\\'m concerned."
                    },
                    {
                        "username": "hugjobk",
                        "content": "If you know how to swap 2 numbers without using a temporary variable then you will know the solution :))"
                    }
                ]
            },
            {
                "id": 2010807,
                "content": [
                    {
                        "username": "zurakatsura",
                        "content": "It can be solved without bitwise in O(1) as well right? Make a set of array, generate sum - sum of array values."
                    },
                    {
                        "username": "ysarath2022",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n       int n = nums.size();\\n     vector<int> count;\\n       for(int i=0;i < n; i++)\\n       {\\n           count[nums[i]]++;\\n       }\\n       for(int i = 0; i< n ; i++)\\n       {\\n           if(count[nums[i]] == 1)\\n           return nums[i];\\n        }\\n        return (-1);\\n\\n        \\n    }\\n}; why is my code not working"
                    },
                    {
                        "username": "Mohtashim_ali",
                        "content": "A simple question for all the people with sound knowledge of logic gates , bit manipulations etc "
                    },
                    {
                        "username": "TwilightVortex",
                        "content": "Hey I don\\'t know if this well help anyone or not, but here is a solution without XOR in C. It is certainly not very effecient, but it works so here it is:\\n\\n```\\nstruct pair {\\n    int num;\\n    bool paired;\\n};\\n\\nvoid addNum(struct pair *nums, int num, int *size) {\\n    for (int i = 0; i < *size; i++) {\\n        if (nums[i].num == num) {\\n            nums[i].paired = true;\\n        }\\n    }\\n    nums[size].num = num;\\n    nums[size].paired = false;\\n    *(size)++;\\n}\\n\\nint singleNumber(int* nums, int numsSize){\\n    int size = 0;\\n    struct pair *nums = malloc(sizeof(struct pair) * numsSize);\\n    for (int i = 0; i < numsSize; i++) {\\n           addNum(nums, num, &size);\\n    }\\n    for (int i = 0; i < size; i++) {\\n        if (nums[i].paired == false) {\\n            return nums[i].num;\\n        }\\n    }\\n    return 1;\\n} \\n```"
                    },
                    {
                        "username": "anilkumarhv",
                        "content": "Hi Guys, XOR operation giving wrong output for below input array\\nint[] nums= [4, 1, 2, 1, 2, 4, 7, 1]\\nexpected output: 7\\nbut actual output : 6"
                    },
                    {
                        "username": "himanshuone",
                        "content": "This Submission passed all the Test cases but, Why I\\'m getting Good Feelings with This?\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        dic=dict()\\n        for _ in nums:\\n            if _ not in dic:\\n                dic[_]=0\\n            else:\\n                dic[_]=dic.get(_)+1\\n        temp = min(dic.values())\\n        res = [key for key in dic if dic[key] == temp]\\n        return (res[0])"
                    },
                    {
                        "username": "user3594P",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int a=0;\\n        int [] fr =new int[nums.length];\\n        int v=-1;\\n        for(int i=0;i<nums.length;i++){\\n            int count=1;\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                    fr[j]=v;\\n                }\\n            }\\n            if (fr[i]!=v){\\n                fr[i]=count;\\n            }\\n             for(int x=0;x<fr.length;x++)\\n             {\\n                 if(fr[x]==1)\\n                 {\\n                     a=nums[i];\\n                 }\\n             }\\n\\n        }\\n        return a;\\n    }\\n} can anyone tell the error in code ?\\n"
                    },
                    {
                        "username": "kunalmahadule77",
                        "content": "Solution of the problem in Python\\n\\nclass Solution:\\n    def singleNumber(self, nums):\\n        # Initialize the result variable with 0\\n        result = 0\\n\\n        # XOR all the elements in the array\\n        for num in nums:\\n            result ^= num\\n\\n        return result\\n"
                    },
                    {
                        "username": "mg5050",
                        "content": "Bad problem description. For people who don\\'t know it\\'s a bit manipulation problem, they need to specify that all inputs are powers of 2. The expected solution does not work once you start throwing in non-power-of-2 numbers, and it\\'s not listed as a constraint anywhere.\\n\\nConstraints should be updated with:\\n\\nnums[i] == 2^X\\n\\nIt\\'s a trick question as far as I\\'m concerned."
                    },
                    {
                        "username": "hugjobk",
                        "content": "If you know how to swap 2 numbers without using a temporary variable then you will know the solution :))"
                    }
                ]
            },
            {
                "id": 2010338,
                "content": [
                    {
                        "username": "zurakatsura",
                        "content": "It can be solved without bitwise in O(1) as well right? Make a set of array, generate sum - sum of array values."
                    },
                    {
                        "username": "ysarath2022",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n       int n = nums.size();\\n     vector<int> count;\\n       for(int i=0;i < n; i++)\\n       {\\n           count[nums[i]]++;\\n       }\\n       for(int i = 0; i< n ; i++)\\n       {\\n           if(count[nums[i]] == 1)\\n           return nums[i];\\n        }\\n        return (-1);\\n\\n        \\n    }\\n}; why is my code not working"
                    },
                    {
                        "username": "Mohtashim_ali",
                        "content": "A simple question for all the people with sound knowledge of logic gates , bit manipulations etc "
                    },
                    {
                        "username": "TwilightVortex",
                        "content": "Hey I don\\'t know if this well help anyone or not, but here is a solution without XOR in C. It is certainly not very effecient, but it works so here it is:\\n\\n```\\nstruct pair {\\n    int num;\\n    bool paired;\\n};\\n\\nvoid addNum(struct pair *nums, int num, int *size) {\\n    for (int i = 0; i < *size; i++) {\\n        if (nums[i].num == num) {\\n            nums[i].paired = true;\\n        }\\n    }\\n    nums[size].num = num;\\n    nums[size].paired = false;\\n    *(size)++;\\n}\\n\\nint singleNumber(int* nums, int numsSize){\\n    int size = 0;\\n    struct pair *nums = malloc(sizeof(struct pair) * numsSize);\\n    for (int i = 0; i < numsSize; i++) {\\n           addNum(nums, num, &size);\\n    }\\n    for (int i = 0; i < size; i++) {\\n        if (nums[i].paired == false) {\\n            return nums[i].num;\\n        }\\n    }\\n    return 1;\\n} \\n```"
                    },
                    {
                        "username": "anilkumarhv",
                        "content": "Hi Guys, XOR operation giving wrong output for below input array\\nint[] nums= [4, 1, 2, 1, 2, 4, 7, 1]\\nexpected output: 7\\nbut actual output : 6"
                    },
                    {
                        "username": "himanshuone",
                        "content": "This Submission passed all the Test cases but, Why I\\'m getting Good Feelings with This?\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        dic=dict()\\n        for _ in nums:\\n            if _ not in dic:\\n                dic[_]=0\\n            else:\\n                dic[_]=dic.get(_)+1\\n        temp = min(dic.values())\\n        res = [key for key in dic if dic[key] == temp]\\n        return (res[0])"
                    },
                    {
                        "username": "user3594P",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int a=0;\\n        int [] fr =new int[nums.length];\\n        int v=-1;\\n        for(int i=0;i<nums.length;i++){\\n            int count=1;\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                    fr[j]=v;\\n                }\\n            }\\n            if (fr[i]!=v){\\n                fr[i]=count;\\n            }\\n             for(int x=0;x<fr.length;x++)\\n             {\\n                 if(fr[x]==1)\\n                 {\\n                     a=nums[i];\\n                 }\\n             }\\n\\n        }\\n        return a;\\n    }\\n} can anyone tell the error in code ?\\n"
                    },
                    {
                        "username": "kunalmahadule77",
                        "content": "Solution of the problem in Python\\n\\nclass Solution:\\n    def singleNumber(self, nums):\\n        # Initialize the result variable with 0\\n        result = 0\\n\\n        # XOR all the elements in the array\\n        for num in nums:\\n            result ^= num\\n\\n        return result\\n"
                    },
                    {
                        "username": "mg5050",
                        "content": "Bad problem description. For people who don\\'t know it\\'s a bit manipulation problem, they need to specify that all inputs are powers of 2. The expected solution does not work once you start throwing in non-power-of-2 numbers, and it\\'s not listed as a constraint anywhere.\\n\\nConstraints should be updated with:\\n\\nnums[i] == 2^X\\n\\nIt\\'s a trick question as far as I\\'m concerned."
                    },
                    {
                        "username": "hugjobk",
                        "content": "If you know how to swap 2 numbers without using a temporary variable then you will know the solution :))"
                    }
                ]
            },
            {
                "id": 2005921,
                "content": [
                    {
                        "username": "zurakatsura",
                        "content": "It can be solved without bitwise in O(1) as well right? Make a set of array, generate sum - sum of array values."
                    },
                    {
                        "username": "ysarath2022",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n       int n = nums.size();\\n     vector<int> count;\\n       for(int i=0;i < n; i++)\\n       {\\n           count[nums[i]]++;\\n       }\\n       for(int i = 0; i< n ; i++)\\n       {\\n           if(count[nums[i]] == 1)\\n           return nums[i];\\n        }\\n        return (-1);\\n\\n        \\n    }\\n}; why is my code not working"
                    },
                    {
                        "username": "Mohtashim_ali",
                        "content": "A simple question for all the people with sound knowledge of logic gates , bit manipulations etc "
                    },
                    {
                        "username": "TwilightVortex",
                        "content": "Hey I don\\'t know if this well help anyone or not, but here is a solution without XOR in C. It is certainly not very effecient, but it works so here it is:\\n\\n```\\nstruct pair {\\n    int num;\\n    bool paired;\\n};\\n\\nvoid addNum(struct pair *nums, int num, int *size) {\\n    for (int i = 0; i < *size; i++) {\\n        if (nums[i].num == num) {\\n            nums[i].paired = true;\\n        }\\n    }\\n    nums[size].num = num;\\n    nums[size].paired = false;\\n    *(size)++;\\n}\\n\\nint singleNumber(int* nums, int numsSize){\\n    int size = 0;\\n    struct pair *nums = malloc(sizeof(struct pair) * numsSize);\\n    for (int i = 0; i < numsSize; i++) {\\n           addNum(nums, num, &size);\\n    }\\n    for (int i = 0; i < size; i++) {\\n        if (nums[i].paired == false) {\\n            return nums[i].num;\\n        }\\n    }\\n    return 1;\\n} \\n```"
                    },
                    {
                        "username": "anilkumarhv",
                        "content": "Hi Guys, XOR operation giving wrong output for below input array\\nint[] nums= [4, 1, 2, 1, 2, 4, 7, 1]\\nexpected output: 7\\nbut actual output : 6"
                    },
                    {
                        "username": "himanshuone",
                        "content": "This Submission passed all the Test cases but, Why I\\'m getting Good Feelings with This?\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        dic=dict()\\n        for _ in nums:\\n            if _ not in dic:\\n                dic[_]=0\\n            else:\\n                dic[_]=dic.get(_)+1\\n        temp = min(dic.values())\\n        res = [key for key in dic if dic[key] == temp]\\n        return (res[0])"
                    },
                    {
                        "username": "user3594P",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int a=0;\\n        int [] fr =new int[nums.length];\\n        int v=-1;\\n        for(int i=0;i<nums.length;i++){\\n            int count=1;\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                    fr[j]=v;\\n                }\\n            }\\n            if (fr[i]!=v){\\n                fr[i]=count;\\n            }\\n             for(int x=0;x<fr.length;x++)\\n             {\\n                 if(fr[x]==1)\\n                 {\\n                     a=nums[i];\\n                 }\\n             }\\n\\n        }\\n        return a;\\n    }\\n} can anyone tell the error in code ?\\n"
                    },
                    {
                        "username": "kunalmahadule77",
                        "content": "Solution of the problem in Python\\n\\nclass Solution:\\n    def singleNumber(self, nums):\\n        # Initialize the result variable with 0\\n        result = 0\\n\\n        # XOR all the elements in the array\\n        for num in nums:\\n            result ^= num\\n\\n        return result\\n"
                    },
                    {
                        "username": "mg5050",
                        "content": "Bad problem description. For people who don\\'t know it\\'s a bit manipulation problem, they need to specify that all inputs are powers of 2. The expected solution does not work once you start throwing in non-power-of-2 numbers, and it\\'s not listed as a constraint anywhere.\\n\\nConstraints should be updated with:\\n\\nnums[i] == 2^X\\n\\nIt\\'s a trick question as far as I\\'m concerned."
                    },
                    {
                        "username": "hugjobk",
                        "content": "If you know how to swap 2 numbers without using a temporary variable then you will know the solution :))"
                    }
                ]
            },
            {
                "id": 2005890,
                "content": [
                    {
                        "username": "zurakatsura",
                        "content": "It can be solved without bitwise in O(1) as well right? Make a set of array, generate sum - sum of array values."
                    },
                    {
                        "username": "ysarath2022",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n       int n = nums.size();\\n     vector<int> count;\\n       for(int i=0;i < n; i++)\\n       {\\n           count[nums[i]]++;\\n       }\\n       for(int i = 0; i< n ; i++)\\n       {\\n           if(count[nums[i]] == 1)\\n           return nums[i];\\n        }\\n        return (-1);\\n\\n        \\n    }\\n}; why is my code not working"
                    },
                    {
                        "username": "Mohtashim_ali",
                        "content": "A simple question for all the people with sound knowledge of logic gates , bit manipulations etc "
                    },
                    {
                        "username": "TwilightVortex",
                        "content": "Hey I don\\'t know if this well help anyone or not, but here is a solution without XOR in C. It is certainly not very effecient, but it works so here it is:\\n\\n```\\nstruct pair {\\n    int num;\\n    bool paired;\\n};\\n\\nvoid addNum(struct pair *nums, int num, int *size) {\\n    for (int i = 0; i < *size; i++) {\\n        if (nums[i].num == num) {\\n            nums[i].paired = true;\\n        }\\n    }\\n    nums[size].num = num;\\n    nums[size].paired = false;\\n    *(size)++;\\n}\\n\\nint singleNumber(int* nums, int numsSize){\\n    int size = 0;\\n    struct pair *nums = malloc(sizeof(struct pair) * numsSize);\\n    for (int i = 0; i < numsSize; i++) {\\n           addNum(nums, num, &size);\\n    }\\n    for (int i = 0; i < size; i++) {\\n        if (nums[i].paired == false) {\\n            return nums[i].num;\\n        }\\n    }\\n    return 1;\\n} \\n```"
                    },
                    {
                        "username": "anilkumarhv",
                        "content": "Hi Guys, XOR operation giving wrong output for below input array\\nint[] nums= [4, 1, 2, 1, 2, 4, 7, 1]\\nexpected output: 7\\nbut actual output : 6"
                    },
                    {
                        "username": "himanshuone",
                        "content": "This Submission passed all the Test cases but, Why I\\'m getting Good Feelings with This?\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        dic=dict()\\n        for _ in nums:\\n            if _ not in dic:\\n                dic[_]=0\\n            else:\\n                dic[_]=dic.get(_)+1\\n        temp = min(dic.values())\\n        res = [key for key in dic if dic[key] == temp]\\n        return (res[0])"
                    },
                    {
                        "username": "user3594P",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int a=0;\\n        int [] fr =new int[nums.length];\\n        int v=-1;\\n        for(int i=0;i<nums.length;i++){\\n            int count=1;\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                    fr[j]=v;\\n                }\\n            }\\n            if (fr[i]!=v){\\n                fr[i]=count;\\n            }\\n             for(int x=0;x<fr.length;x++)\\n             {\\n                 if(fr[x]==1)\\n                 {\\n                     a=nums[i];\\n                 }\\n             }\\n\\n        }\\n        return a;\\n    }\\n} can anyone tell the error in code ?\\n"
                    },
                    {
                        "username": "kunalmahadule77",
                        "content": "Solution of the problem in Python\\n\\nclass Solution:\\n    def singleNumber(self, nums):\\n        # Initialize the result variable with 0\\n        result = 0\\n\\n        # XOR all the elements in the array\\n        for num in nums:\\n            result ^= num\\n\\n        return result\\n"
                    },
                    {
                        "username": "mg5050",
                        "content": "Bad problem description. For people who don\\'t know it\\'s a bit manipulation problem, they need to specify that all inputs are powers of 2. The expected solution does not work once you start throwing in non-power-of-2 numbers, and it\\'s not listed as a constraint anywhere.\\n\\nConstraints should be updated with:\\n\\nnums[i] == 2^X\\n\\nIt\\'s a trick question as far as I\\'m concerned."
                    },
                    {
                        "username": "hugjobk",
                        "content": "If you know how to swap 2 numbers without using a temporary variable then you will know the solution :))"
                    }
                ]
            },
            {
                "id": 1998202,
                "content": [
                    {
                        "username": "zurakatsura",
                        "content": "It can be solved without bitwise in O(1) as well right? Make a set of array, generate sum - sum of array values."
                    },
                    {
                        "username": "ysarath2022",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n       int n = nums.size();\\n     vector<int> count;\\n       for(int i=0;i < n; i++)\\n       {\\n           count[nums[i]]++;\\n       }\\n       for(int i = 0; i< n ; i++)\\n       {\\n           if(count[nums[i]] == 1)\\n           return nums[i];\\n        }\\n        return (-1);\\n\\n        \\n    }\\n}; why is my code not working"
                    },
                    {
                        "username": "Mohtashim_ali",
                        "content": "A simple question for all the people with sound knowledge of logic gates , bit manipulations etc "
                    },
                    {
                        "username": "TwilightVortex",
                        "content": "Hey I don\\'t know if this well help anyone or not, but here is a solution without XOR in C. It is certainly not very effecient, but it works so here it is:\\n\\n```\\nstruct pair {\\n    int num;\\n    bool paired;\\n};\\n\\nvoid addNum(struct pair *nums, int num, int *size) {\\n    for (int i = 0; i < *size; i++) {\\n        if (nums[i].num == num) {\\n            nums[i].paired = true;\\n        }\\n    }\\n    nums[size].num = num;\\n    nums[size].paired = false;\\n    *(size)++;\\n}\\n\\nint singleNumber(int* nums, int numsSize){\\n    int size = 0;\\n    struct pair *nums = malloc(sizeof(struct pair) * numsSize);\\n    for (int i = 0; i < numsSize; i++) {\\n           addNum(nums, num, &size);\\n    }\\n    for (int i = 0; i < size; i++) {\\n        if (nums[i].paired == false) {\\n            return nums[i].num;\\n        }\\n    }\\n    return 1;\\n} \\n```"
                    },
                    {
                        "username": "anilkumarhv",
                        "content": "Hi Guys, XOR operation giving wrong output for below input array\\nint[] nums= [4, 1, 2, 1, 2, 4, 7, 1]\\nexpected output: 7\\nbut actual output : 6"
                    },
                    {
                        "username": "himanshuone",
                        "content": "This Submission passed all the Test cases but, Why I\\'m getting Good Feelings with This?\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        dic=dict()\\n        for _ in nums:\\n            if _ not in dic:\\n                dic[_]=0\\n            else:\\n                dic[_]=dic.get(_)+1\\n        temp = min(dic.values())\\n        res = [key for key in dic if dic[key] == temp]\\n        return (res[0])"
                    },
                    {
                        "username": "user3594P",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int a=0;\\n        int [] fr =new int[nums.length];\\n        int v=-1;\\n        for(int i=0;i<nums.length;i++){\\n            int count=1;\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                    fr[j]=v;\\n                }\\n            }\\n            if (fr[i]!=v){\\n                fr[i]=count;\\n            }\\n             for(int x=0;x<fr.length;x++)\\n             {\\n                 if(fr[x]==1)\\n                 {\\n                     a=nums[i];\\n                 }\\n             }\\n\\n        }\\n        return a;\\n    }\\n} can anyone tell the error in code ?\\n"
                    },
                    {
                        "username": "kunalmahadule77",
                        "content": "Solution of the problem in Python\\n\\nclass Solution:\\n    def singleNumber(self, nums):\\n        # Initialize the result variable with 0\\n        result = 0\\n\\n        # XOR all the elements in the array\\n        for num in nums:\\n            result ^= num\\n\\n        return result\\n"
                    },
                    {
                        "username": "mg5050",
                        "content": "Bad problem description. For people who don\\'t know it\\'s a bit manipulation problem, they need to specify that all inputs are powers of 2. The expected solution does not work once you start throwing in non-power-of-2 numbers, and it\\'s not listed as a constraint anywhere.\\n\\nConstraints should be updated with:\\n\\nnums[i] == 2^X\\n\\nIt\\'s a trick question as far as I\\'m concerned."
                    },
                    {
                        "username": "hugjobk",
                        "content": "If you know how to swap 2 numbers without using a temporary variable then you will know the solution :))"
                    }
                ]
            },
            {
                "id": 1996606,
                "content": [
                    {
                        "username": "zurakatsura",
                        "content": "It can be solved without bitwise in O(1) as well right? Make a set of array, generate sum - sum of array values."
                    },
                    {
                        "username": "ysarath2022",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n       int n = nums.size();\\n     vector<int> count;\\n       for(int i=0;i < n; i++)\\n       {\\n           count[nums[i]]++;\\n       }\\n       for(int i = 0; i< n ; i++)\\n       {\\n           if(count[nums[i]] == 1)\\n           return nums[i];\\n        }\\n        return (-1);\\n\\n        \\n    }\\n}; why is my code not working"
                    },
                    {
                        "username": "Mohtashim_ali",
                        "content": "A simple question for all the people with sound knowledge of logic gates , bit manipulations etc "
                    },
                    {
                        "username": "TwilightVortex",
                        "content": "Hey I don\\'t know if this well help anyone or not, but here is a solution without XOR in C. It is certainly not very effecient, but it works so here it is:\\n\\n```\\nstruct pair {\\n    int num;\\n    bool paired;\\n};\\n\\nvoid addNum(struct pair *nums, int num, int *size) {\\n    for (int i = 0; i < *size; i++) {\\n        if (nums[i].num == num) {\\n            nums[i].paired = true;\\n        }\\n    }\\n    nums[size].num = num;\\n    nums[size].paired = false;\\n    *(size)++;\\n}\\n\\nint singleNumber(int* nums, int numsSize){\\n    int size = 0;\\n    struct pair *nums = malloc(sizeof(struct pair) * numsSize);\\n    for (int i = 0; i < numsSize; i++) {\\n           addNum(nums, num, &size);\\n    }\\n    for (int i = 0; i < size; i++) {\\n        if (nums[i].paired == false) {\\n            return nums[i].num;\\n        }\\n    }\\n    return 1;\\n} \\n```"
                    },
                    {
                        "username": "anilkumarhv",
                        "content": "Hi Guys, XOR operation giving wrong output for below input array\\nint[] nums= [4, 1, 2, 1, 2, 4, 7, 1]\\nexpected output: 7\\nbut actual output : 6"
                    },
                    {
                        "username": "himanshuone",
                        "content": "This Submission passed all the Test cases but, Why I\\'m getting Good Feelings with This?\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        dic=dict()\\n        for _ in nums:\\n            if _ not in dic:\\n                dic[_]=0\\n            else:\\n                dic[_]=dic.get(_)+1\\n        temp = min(dic.values())\\n        res = [key for key in dic if dic[key] == temp]\\n        return (res[0])"
                    },
                    {
                        "username": "user3594P",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int a=0;\\n        int [] fr =new int[nums.length];\\n        int v=-1;\\n        for(int i=0;i<nums.length;i++){\\n            int count=1;\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                    fr[j]=v;\\n                }\\n            }\\n            if (fr[i]!=v){\\n                fr[i]=count;\\n            }\\n             for(int x=0;x<fr.length;x++)\\n             {\\n                 if(fr[x]==1)\\n                 {\\n                     a=nums[i];\\n                 }\\n             }\\n\\n        }\\n        return a;\\n    }\\n} can anyone tell the error in code ?\\n"
                    },
                    {
                        "username": "kunalmahadule77",
                        "content": "Solution of the problem in Python\\n\\nclass Solution:\\n    def singleNumber(self, nums):\\n        # Initialize the result variable with 0\\n        result = 0\\n\\n        # XOR all the elements in the array\\n        for num in nums:\\n            result ^= num\\n\\n        return result\\n"
                    },
                    {
                        "username": "mg5050",
                        "content": "Bad problem description. For people who don\\'t know it\\'s a bit manipulation problem, they need to specify that all inputs are powers of 2. The expected solution does not work once you start throwing in non-power-of-2 numbers, and it\\'s not listed as a constraint anywhere.\\n\\nConstraints should be updated with:\\n\\nnums[i] == 2^X\\n\\nIt\\'s a trick question as far as I\\'m concerned."
                    },
                    {
                        "username": "hugjobk",
                        "content": "If you know how to swap 2 numbers without using a temporary variable then you will know the solution :))"
                    }
                ]
            },
            {
                "id": 1992220,
                "content": [
                    {
                        "username": "zurakatsura",
                        "content": "It can be solved without bitwise in O(1) as well right? Make a set of array, generate sum - sum of array values."
                    },
                    {
                        "username": "ysarath2022",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n       int n = nums.size();\\n     vector<int> count;\\n       for(int i=0;i < n; i++)\\n       {\\n           count[nums[i]]++;\\n       }\\n       for(int i = 0; i< n ; i++)\\n       {\\n           if(count[nums[i]] == 1)\\n           return nums[i];\\n        }\\n        return (-1);\\n\\n        \\n    }\\n}; why is my code not working"
                    },
                    {
                        "username": "Mohtashim_ali",
                        "content": "A simple question for all the people with sound knowledge of logic gates , bit manipulations etc "
                    },
                    {
                        "username": "TwilightVortex",
                        "content": "Hey I don\\'t know if this well help anyone or not, but here is a solution without XOR in C. It is certainly not very effecient, but it works so here it is:\\n\\n```\\nstruct pair {\\n    int num;\\n    bool paired;\\n};\\n\\nvoid addNum(struct pair *nums, int num, int *size) {\\n    for (int i = 0; i < *size; i++) {\\n        if (nums[i].num == num) {\\n            nums[i].paired = true;\\n        }\\n    }\\n    nums[size].num = num;\\n    nums[size].paired = false;\\n    *(size)++;\\n}\\n\\nint singleNumber(int* nums, int numsSize){\\n    int size = 0;\\n    struct pair *nums = malloc(sizeof(struct pair) * numsSize);\\n    for (int i = 0; i < numsSize; i++) {\\n           addNum(nums, num, &size);\\n    }\\n    for (int i = 0; i < size; i++) {\\n        if (nums[i].paired == false) {\\n            return nums[i].num;\\n        }\\n    }\\n    return 1;\\n} \\n```"
                    },
                    {
                        "username": "anilkumarhv",
                        "content": "Hi Guys, XOR operation giving wrong output for below input array\\nint[] nums= [4, 1, 2, 1, 2, 4, 7, 1]\\nexpected output: 7\\nbut actual output : 6"
                    },
                    {
                        "username": "himanshuone",
                        "content": "This Submission passed all the Test cases but, Why I\\'m getting Good Feelings with This?\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        dic=dict()\\n        for _ in nums:\\n            if _ not in dic:\\n                dic[_]=0\\n            else:\\n                dic[_]=dic.get(_)+1\\n        temp = min(dic.values())\\n        res = [key for key in dic if dic[key] == temp]\\n        return (res[0])"
                    },
                    {
                        "username": "user3594P",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int a=0;\\n        int [] fr =new int[nums.length];\\n        int v=-1;\\n        for(int i=0;i<nums.length;i++){\\n            int count=1;\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                    fr[j]=v;\\n                }\\n            }\\n            if (fr[i]!=v){\\n                fr[i]=count;\\n            }\\n             for(int x=0;x<fr.length;x++)\\n             {\\n                 if(fr[x]==1)\\n                 {\\n                     a=nums[i];\\n                 }\\n             }\\n\\n        }\\n        return a;\\n    }\\n} can anyone tell the error in code ?\\n"
                    },
                    {
                        "username": "kunalmahadule77",
                        "content": "Solution of the problem in Python\\n\\nclass Solution:\\n    def singleNumber(self, nums):\\n        # Initialize the result variable with 0\\n        result = 0\\n\\n        # XOR all the elements in the array\\n        for num in nums:\\n            result ^= num\\n\\n        return result\\n"
                    },
                    {
                        "username": "mg5050",
                        "content": "Bad problem description. For people who don\\'t know it\\'s a bit manipulation problem, they need to specify that all inputs are powers of 2. The expected solution does not work once you start throwing in non-power-of-2 numbers, and it\\'s not listed as a constraint anywhere.\\n\\nConstraints should be updated with:\\n\\nnums[i] == 2^X\\n\\nIt\\'s a trick question as far as I\\'m concerned."
                    },
                    {
                        "username": "hugjobk",
                        "content": "If you know how to swap 2 numbers without using a temporary variable then you will know the solution :))"
                    }
                ]
            },
            {
                "id": 1988819,
                "content": [
                    {
                        "username": "zurakatsura",
                        "content": "It can be solved without bitwise in O(1) as well right? Make a set of array, generate sum - sum of array values."
                    },
                    {
                        "username": "ysarath2022",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n       int n = nums.size();\\n     vector<int> count;\\n       for(int i=0;i < n; i++)\\n       {\\n           count[nums[i]]++;\\n       }\\n       for(int i = 0; i< n ; i++)\\n       {\\n           if(count[nums[i]] == 1)\\n           return nums[i];\\n        }\\n        return (-1);\\n\\n        \\n    }\\n}; why is my code not working"
                    },
                    {
                        "username": "Mohtashim_ali",
                        "content": "A simple question for all the people with sound knowledge of logic gates , bit manipulations etc "
                    },
                    {
                        "username": "TwilightVortex",
                        "content": "Hey I don\\'t know if this well help anyone or not, but here is a solution without XOR in C. It is certainly not very effecient, but it works so here it is:\\n\\n```\\nstruct pair {\\n    int num;\\n    bool paired;\\n};\\n\\nvoid addNum(struct pair *nums, int num, int *size) {\\n    for (int i = 0; i < *size; i++) {\\n        if (nums[i].num == num) {\\n            nums[i].paired = true;\\n        }\\n    }\\n    nums[size].num = num;\\n    nums[size].paired = false;\\n    *(size)++;\\n}\\n\\nint singleNumber(int* nums, int numsSize){\\n    int size = 0;\\n    struct pair *nums = malloc(sizeof(struct pair) * numsSize);\\n    for (int i = 0; i < numsSize; i++) {\\n           addNum(nums, num, &size);\\n    }\\n    for (int i = 0; i < size; i++) {\\n        if (nums[i].paired == false) {\\n            return nums[i].num;\\n        }\\n    }\\n    return 1;\\n} \\n```"
                    },
                    {
                        "username": "anilkumarhv",
                        "content": "Hi Guys, XOR operation giving wrong output for below input array\\nint[] nums= [4, 1, 2, 1, 2, 4, 7, 1]\\nexpected output: 7\\nbut actual output : 6"
                    },
                    {
                        "username": "himanshuone",
                        "content": "This Submission passed all the Test cases but, Why I\\'m getting Good Feelings with This?\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        dic=dict()\\n        for _ in nums:\\n            if _ not in dic:\\n                dic[_]=0\\n            else:\\n                dic[_]=dic.get(_)+1\\n        temp = min(dic.values())\\n        res = [key for key in dic if dic[key] == temp]\\n        return (res[0])"
                    },
                    {
                        "username": "user3594P",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int a=0;\\n        int [] fr =new int[nums.length];\\n        int v=-1;\\n        for(int i=0;i<nums.length;i++){\\n            int count=1;\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                    fr[j]=v;\\n                }\\n            }\\n            if (fr[i]!=v){\\n                fr[i]=count;\\n            }\\n             for(int x=0;x<fr.length;x++)\\n             {\\n                 if(fr[x]==1)\\n                 {\\n                     a=nums[i];\\n                 }\\n             }\\n\\n        }\\n        return a;\\n    }\\n} can anyone tell the error in code ?\\n"
                    },
                    {
                        "username": "kunalmahadule77",
                        "content": "Solution of the problem in Python\\n\\nclass Solution:\\n    def singleNumber(self, nums):\\n        # Initialize the result variable with 0\\n        result = 0\\n\\n        # XOR all the elements in the array\\n        for num in nums:\\n            result ^= num\\n\\n        return result\\n"
                    },
                    {
                        "username": "mg5050",
                        "content": "Bad problem description. For people who don\\'t know it\\'s a bit manipulation problem, they need to specify that all inputs are powers of 2. The expected solution does not work once you start throwing in non-power-of-2 numbers, and it\\'s not listed as a constraint anywhere.\\n\\nConstraints should be updated with:\\n\\nnums[i] == 2^X\\n\\nIt\\'s a trick question as far as I\\'m concerned."
                    },
                    {
                        "username": "hugjobk",
                        "content": "If you know how to swap 2 numbers without using a temporary variable then you will know the solution :))"
                    }
                ]
            },
            {
                "id": 1943007,
                "content": [
                    {
                        "username": "Pokemon_Margo",
                        "content": "At first I decided by the logical method that came to mind. I saw that the speed was too low. I read the comments. Learned the binary method - XOR :) "
                    },
                    {
                        "username": "user8257Am",
                        "content": "i was using hash array technique, but it is failing one testcase when array has -ve elements. i am not sure how can i take care of -ve element."
                    },
                    {
                        "username": "ArunSreekanth",
                        "content": "How do we get the idea to solve using XOR. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@ArunSreekanth](/ArunSreekanth)\\nThe following challenges requires you to find out which single number is only represented once in an array. The XOR operator is perfect for this. If you XOR every number in your array you will get the singled out number.\\n\\nHere is an example:\\nInput: nums = [4,1,2,1,2]\\n4 ^ 1 = 5  \\n5 ^ 2 = 7\\n7 ^ 1 = 6\\n6 ^ 2 = 4\\nOutput: 4\\n\\nIf you want to know more what XOR is: https://www.w3schools.com/js/js_bitwise.asp \\n"
                    },
                    {
                        "username": "vishalrana17",
                        "content": "when mums[-1]\\noutput is -1\\nand my output is 1\\ncan any one tell my right one\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       for(int i =0;i<nums.length-1;i++){\\n           int curr = nums[i];\\n           for(int j=i+1;j<nums.length;j++){\\n               if(curr!=nums[j]&&curr-1!=nums[j]){\\n              return curr;\\n               }\\n               }\\n           }\\n          return  1;\\n\\n       }\\n}"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "Bitwise XOR : if corresponding number is different it gives 1 else it shows 0."
                    },
                    {
                        "username": "harika_drona",
                        "content": "if i try to submit this code, i am getting output as time limit exceeded for the testcase 59\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(0,n):\\n            count =0\\n            for j in range(0,n):\\n                if(nums[i]==nums[j]):\\n                    count+=1\\n                    \\n            if(count==1):\\n                return nums[i]\\n\\nCan someone help me "
                    },
                    {
                        "username": "RipperPY",
                        "content": "SPOILER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Traverse the array and XOR  all the elements, if repeated then reduces to 0 else remain ,then return."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "XOR of equal numbers is 0 and XOR of 0 and any number is the number itself."
                    },
                    {
                        "username": "Mohd_Musaiyab",
                        "content": "Well the given problem can easily be solved using Bitwise Operators .Using the EX-OR operator will just give us the answer we need.\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans=nums[i] ^ ans;\\n        }\\n        return ans;\\n              }\\n};"
                    }
                ]
            },
            {
                "id": 1941832,
                "content": [
                    {
                        "username": "Pokemon_Margo",
                        "content": "At first I decided by the logical method that came to mind. I saw that the speed was too low. I read the comments. Learned the binary method - XOR :) "
                    },
                    {
                        "username": "user8257Am",
                        "content": "i was using hash array technique, but it is failing one testcase when array has -ve elements. i am not sure how can i take care of -ve element."
                    },
                    {
                        "username": "ArunSreekanth",
                        "content": "How do we get the idea to solve using XOR. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@ArunSreekanth](/ArunSreekanth)\\nThe following challenges requires you to find out which single number is only represented once in an array. The XOR operator is perfect for this. If you XOR every number in your array you will get the singled out number.\\n\\nHere is an example:\\nInput: nums = [4,1,2,1,2]\\n4 ^ 1 = 5  \\n5 ^ 2 = 7\\n7 ^ 1 = 6\\n6 ^ 2 = 4\\nOutput: 4\\n\\nIf you want to know more what XOR is: https://www.w3schools.com/js/js_bitwise.asp \\n"
                    },
                    {
                        "username": "vishalrana17",
                        "content": "when mums[-1]\\noutput is -1\\nand my output is 1\\ncan any one tell my right one\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       for(int i =0;i<nums.length-1;i++){\\n           int curr = nums[i];\\n           for(int j=i+1;j<nums.length;j++){\\n               if(curr!=nums[j]&&curr-1!=nums[j]){\\n              return curr;\\n               }\\n               }\\n           }\\n          return  1;\\n\\n       }\\n}"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "Bitwise XOR : if corresponding number is different it gives 1 else it shows 0."
                    },
                    {
                        "username": "harika_drona",
                        "content": "if i try to submit this code, i am getting output as time limit exceeded for the testcase 59\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(0,n):\\n            count =0\\n            for j in range(0,n):\\n                if(nums[i]==nums[j]):\\n                    count+=1\\n                    \\n            if(count==1):\\n                return nums[i]\\n\\nCan someone help me "
                    },
                    {
                        "username": "RipperPY",
                        "content": "SPOILER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Traverse the array and XOR  all the elements, if repeated then reduces to 0 else remain ,then return."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "XOR of equal numbers is 0 and XOR of 0 and any number is the number itself."
                    },
                    {
                        "username": "Mohd_Musaiyab",
                        "content": "Well the given problem can easily be solved using Bitwise Operators .Using the EX-OR operator will just give us the answer we need.\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans=nums[i] ^ ans;\\n        }\\n        return ans;\\n              }\\n};"
                    }
                ]
            },
            {
                "id": 1940387,
                "content": [
                    {
                        "username": "Pokemon_Margo",
                        "content": "At first I decided by the logical method that came to mind. I saw that the speed was too low. I read the comments. Learned the binary method - XOR :) "
                    },
                    {
                        "username": "user8257Am",
                        "content": "i was using hash array technique, but it is failing one testcase when array has -ve elements. i am not sure how can i take care of -ve element."
                    },
                    {
                        "username": "ArunSreekanth",
                        "content": "How do we get the idea to solve using XOR. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@ArunSreekanth](/ArunSreekanth)\\nThe following challenges requires you to find out which single number is only represented once in an array. The XOR operator is perfect for this. If you XOR every number in your array you will get the singled out number.\\n\\nHere is an example:\\nInput: nums = [4,1,2,1,2]\\n4 ^ 1 = 5  \\n5 ^ 2 = 7\\n7 ^ 1 = 6\\n6 ^ 2 = 4\\nOutput: 4\\n\\nIf you want to know more what XOR is: https://www.w3schools.com/js/js_bitwise.asp \\n"
                    },
                    {
                        "username": "vishalrana17",
                        "content": "when mums[-1]\\noutput is -1\\nand my output is 1\\ncan any one tell my right one\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       for(int i =0;i<nums.length-1;i++){\\n           int curr = nums[i];\\n           for(int j=i+1;j<nums.length;j++){\\n               if(curr!=nums[j]&&curr-1!=nums[j]){\\n              return curr;\\n               }\\n               }\\n           }\\n          return  1;\\n\\n       }\\n}"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "Bitwise XOR : if corresponding number is different it gives 1 else it shows 0."
                    },
                    {
                        "username": "harika_drona",
                        "content": "if i try to submit this code, i am getting output as time limit exceeded for the testcase 59\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(0,n):\\n            count =0\\n            for j in range(0,n):\\n                if(nums[i]==nums[j]):\\n                    count+=1\\n                    \\n            if(count==1):\\n                return nums[i]\\n\\nCan someone help me "
                    },
                    {
                        "username": "RipperPY",
                        "content": "SPOILER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Traverse the array and XOR  all the elements, if repeated then reduces to 0 else remain ,then return."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "XOR of equal numbers is 0 and XOR of 0 and any number is the number itself."
                    },
                    {
                        "username": "Mohd_Musaiyab",
                        "content": "Well the given problem can easily be solved using Bitwise Operators .Using the EX-OR operator will just give us the answer we need.\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans=nums[i] ^ ans;\\n        }\\n        return ans;\\n              }\\n};"
                    }
                ]
            },
            {
                "id": 1937163,
                "content": [
                    {
                        "username": "Pokemon_Margo",
                        "content": "At first I decided by the logical method that came to mind. I saw that the speed was too low. I read the comments. Learned the binary method - XOR :) "
                    },
                    {
                        "username": "user8257Am",
                        "content": "i was using hash array technique, but it is failing one testcase when array has -ve elements. i am not sure how can i take care of -ve element."
                    },
                    {
                        "username": "ArunSreekanth",
                        "content": "How do we get the idea to solve using XOR. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@ArunSreekanth](/ArunSreekanth)\\nThe following challenges requires you to find out which single number is only represented once in an array. The XOR operator is perfect for this. If you XOR every number in your array you will get the singled out number.\\n\\nHere is an example:\\nInput: nums = [4,1,2,1,2]\\n4 ^ 1 = 5  \\n5 ^ 2 = 7\\n7 ^ 1 = 6\\n6 ^ 2 = 4\\nOutput: 4\\n\\nIf you want to know more what XOR is: https://www.w3schools.com/js/js_bitwise.asp \\n"
                    },
                    {
                        "username": "vishalrana17",
                        "content": "when mums[-1]\\noutput is -1\\nand my output is 1\\ncan any one tell my right one\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       for(int i =0;i<nums.length-1;i++){\\n           int curr = nums[i];\\n           for(int j=i+1;j<nums.length;j++){\\n               if(curr!=nums[j]&&curr-1!=nums[j]){\\n              return curr;\\n               }\\n               }\\n           }\\n          return  1;\\n\\n       }\\n}"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "Bitwise XOR : if corresponding number is different it gives 1 else it shows 0."
                    },
                    {
                        "username": "harika_drona",
                        "content": "if i try to submit this code, i am getting output as time limit exceeded for the testcase 59\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(0,n):\\n            count =0\\n            for j in range(0,n):\\n                if(nums[i]==nums[j]):\\n                    count+=1\\n                    \\n            if(count==1):\\n                return nums[i]\\n\\nCan someone help me "
                    },
                    {
                        "username": "RipperPY",
                        "content": "SPOILER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Traverse the array and XOR  all the elements, if repeated then reduces to 0 else remain ,then return."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "XOR of equal numbers is 0 and XOR of 0 and any number is the number itself."
                    },
                    {
                        "username": "Mohd_Musaiyab",
                        "content": "Well the given problem can easily be solved using Bitwise Operators .Using the EX-OR operator will just give us the answer we need.\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans=nums[i] ^ ans;\\n        }\\n        return ans;\\n              }\\n};"
                    }
                ]
            },
            {
                "id": 1927862,
                "content": [
                    {
                        "username": "Pokemon_Margo",
                        "content": "At first I decided by the logical method that came to mind. I saw that the speed was too low. I read the comments. Learned the binary method - XOR :) "
                    },
                    {
                        "username": "user8257Am",
                        "content": "i was using hash array technique, but it is failing one testcase when array has -ve elements. i am not sure how can i take care of -ve element."
                    },
                    {
                        "username": "ArunSreekanth",
                        "content": "How do we get the idea to solve using XOR. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@ArunSreekanth](/ArunSreekanth)\\nThe following challenges requires you to find out which single number is only represented once in an array. The XOR operator is perfect for this. If you XOR every number in your array you will get the singled out number.\\n\\nHere is an example:\\nInput: nums = [4,1,2,1,2]\\n4 ^ 1 = 5  \\n5 ^ 2 = 7\\n7 ^ 1 = 6\\n6 ^ 2 = 4\\nOutput: 4\\n\\nIf you want to know more what XOR is: https://www.w3schools.com/js/js_bitwise.asp \\n"
                    },
                    {
                        "username": "vishalrana17",
                        "content": "when mums[-1]\\noutput is -1\\nand my output is 1\\ncan any one tell my right one\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       for(int i =0;i<nums.length-1;i++){\\n           int curr = nums[i];\\n           for(int j=i+1;j<nums.length;j++){\\n               if(curr!=nums[j]&&curr-1!=nums[j]){\\n              return curr;\\n               }\\n               }\\n           }\\n          return  1;\\n\\n       }\\n}"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "Bitwise XOR : if corresponding number is different it gives 1 else it shows 0."
                    },
                    {
                        "username": "harika_drona",
                        "content": "if i try to submit this code, i am getting output as time limit exceeded for the testcase 59\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(0,n):\\n            count =0\\n            for j in range(0,n):\\n                if(nums[i]==nums[j]):\\n                    count+=1\\n                    \\n            if(count==1):\\n                return nums[i]\\n\\nCan someone help me "
                    },
                    {
                        "username": "RipperPY",
                        "content": "SPOILER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Traverse the array and XOR  all the elements, if repeated then reduces to 0 else remain ,then return."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "XOR of equal numbers is 0 and XOR of 0 and any number is the number itself."
                    },
                    {
                        "username": "Mohd_Musaiyab",
                        "content": "Well the given problem can easily be solved using Bitwise Operators .Using the EX-OR operator will just give us the answer we need.\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans=nums[i] ^ ans;\\n        }\\n        return ans;\\n              }\\n};"
                    }
                ]
            },
            {
                "id": 1927126,
                "content": [
                    {
                        "username": "Pokemon_Margo",
                        "content": "At first I decided by the logical method that came to mind. I saw that the speed was too low. I read the comments. Learned the binary method - XOR :) "
                    },
                    {
                        "username": "user8257Am",
                        "content": "i was using hash array technique, but it is failing one testcase when array has -ve elements. i am not sure how can i take care of -ve element."
                    },
                    {
                        "username": "ArunSreekanth",
                        "content": "How do we get the idea to solve using XOR. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@ArunSreekanth](/ArunSreekanth)\\nThe following challenges requires you to find out which single number is only represented once in an array. The XOR operator is perfect for this. If you XOR every number in your array you will get the singled out number.\\n\\nHere is an example:\\nInput: nums = [4,1,2,1,2]\\n4 ^ 1 = 5  \\n5 ^ 2 = 7\\n7 ^ 1 = 6\\n6 ^ 2 = 4\\nOutput: 4\\n\\nIf you want to know more what XOR is: https://www.w3schools.com/js/js_bitwise.asp \\n"
                    },
                    {
                        "username": "vishalrana17",
                        "content": "when mums[-1]\\noutput is -1\\nand my output is 1\\ncan any one tell my right one\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       for(int i =0;i<nums.length-1;i++){\\n           int curr = nums[i];\\n           for(int j=i+1;j<nums.length;j++){\\n               if(curr!=nums[j]&&curr-1!=nums[j]){\\n              return curr;\\n               }\\n               }\\n           }\\n          return  1;\\n\\n       }\\n}"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "Bitwise XOR : if corresponding number is different it gives 1 else it shows 0."
                    },
                    {
                        "username": "harika_drona",
                        "content": "if i try to submit this code, i am getting output as time limit exceeded for the testcase 59\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(0,n):\\n            count =0\\n            for j in range(0,n):\\n                if(nums[i]==nums[j]):\\n                    count+=1\\n                    \\n            if(count==1):\\n                return nums[i]\\n\\nCan someone help me "
                    },
                    {
                        "username": "RipperPY",
                        "content": "SPOILER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Traverse the array and XOR  all the elements, if repeated then reduces to 0 else remain ,then return."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "XOR of equal numbers is 0 and XOR of 0 and any number is the number itself."
                    },
                    {
                        "username": "Mohd_Musaiyab",
                        "content": "Well the given problem can easily be solved using Bitwise Operators .Using the EX-OR operator will just give us the answer we need.\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans=nums[i] ^ ans;\\n        }\\n        return ans;\\n              }\\n};"
                    }
                ]
            },
            {
                "id": 1920226,
                "content": [
                    {
                        "username": "Pokemon_Margo",
                        "content": "At first I decided by the logical method that came to mind. I saw that the speed was too low. I read the comments. Learned the binary method - XOR :) "
                    },
                    {
                        "username": "user8257Am",
                        "content": "i was using hash array technique, but it is failing one testcase when array has -ve elements. i am not sure how can i take care of -ve element."
                    },
                    {
                        "username": "ArunSreekanth",
                        "content": "How do we get the idea to solve using XOR. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@ArunSreekanth](/ArunSreekanth)\\nThe following challenges requires you to find out which single number is only represented once in an array. The XOR operator is perfect for this. If you XOR every number in your array you will get the singled out number.\\n\\nHere is an example:\\nInput: nums = [4,1,2,1,2]\\n4 ^ 1 = 5  \\n5 ^ 2 = 7\\n7 ^ 1 = 6\\n6 ^ 2 = 4\\nOutput: 4\\n\\nIf you want to know more what XOR is: https://www.w3schools.com/js/js_bitwise.asp \\n"
                    },
                    {
                        "username": "vishalrana17",
                        "content": "when mums[-1]\\noutput is -1\\nand my output is 1\\ncan any one tell my right one\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       for(int i =0;i<nums.length-1;i++){\\n           int curr = nums[i];\\n           for(int j=i+1;j<nums.length;j++){\\n               if(curr!=nums[j]&&curr-1!=nums[j]){\\n              return curr;\\n               }\\n               }\\n           }\\n          return  1;\\n\\n       }\\n}"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "Bitwise XOR : if corresponding number is different it gives 1 else it shows 0."
                    },
                    {
                        "username": "harika_drona",
                        "content": "if i try to submit this code, i am getting output as time limit exceeded for the testcase 59\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(0,n):\\n            count =0\\n            for j in range(0,n):\\n                if(nums[i]==nums[j]):\\n                    count+=1\\n                    \\n            if(count==1):\\n                return nums[i]\\n\\nCan someone help me "
                    },
                    {
                        "username": "RipperPY",
                        "content": "SPOILER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Traverse the array and XOR  all the elements, if repeated then reduces to 0 else remain ,then return."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "XOR of equal numbers is 0 and XOR of 0 and any number is the number itself."
                    },
                    {
                        "username": "Mohd_Musaiyab",
                        "content": "Well the given problem can easily be solved using Bitwise Operators .Using the EX-OR operator will just give us the answer we need.\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans=nums[i] ^ ans;\\n        }\\n        return ans;\\n              }\\n};"
                    }
                ]
            },
            {
                "id": 1907192,
                "content": [
                    {
                        "username": "Pokemon_Margo",
                        "content": "At first I decided by the logical method that came to mind. I saw that the speed was too low. I read the comments. Learned the binary method - XOR :) "
                    },
                    {
                        "username": "user8257Am",
                        "content": "i was using hash array technique, but it is failing one testcase when array has -ve elements. i am not sure how can i take care of -ve element."
                    },
                    {
                        "username": "ArunSreekanth",
                        "content": "How do we get the idea to solve using XOR. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@ArunSreekanth](/ArunSreekanth)\\nThe following challenges requires you to find out which single number is only represented once in an array. The XOR operator is perfect for this. If you XOR every number in your array you will get the singled out number.\\n\\nHere is an example:\\nInput: nums = [4,1,2,1,2]\\n4 ^ 1 = 5  \\n5 ^ 2 = 7\\n7 ^ 1 = 6\\n6 ^ 2 = 4\\nOutput: 4\\n\\nIf you want to know more what XOR is: https://www.w3schools.com/js/js_bitwise.asp \\n"
                    },
                    {
                        "username": "vishalrana17",
                        "content": "when mums[-1]\\noutput is -1\\nand my output is 1\\ncan any one tell my right one\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       for(int i =0;i<nums.length-1;i++){\\n           int curr = nums[i];\\n           for(int j=i+1;j<nums.length;j++){\\n               if(curr!=nums[j]&&curr-1!=nums[j]){\\n              return curr;\\n               }\\n               }\\n           }\\n          return  1;\\n\\n       }\\n}"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "Bitwise XOR : if corresponding number is different it gives 1 else it shows 0."
                    },
                    {
                        "username": "harika_drona",
                        "content": "if i try to submit this code, i am getting output as time limit exceeded for the testcase 59\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(0,n):\\n            count =0\\n            for j in range(0,n):\\n                if(nums[i]==nums[j]):\\n                    count+=1\\n                    \\n            if(count==1):\\n                return nums[i]\\n\\nCan someone help me "
                    },
                    {
                        "username": "RipperPY",
                        "content": "SPOILER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Traverse the array and XOR  all the elements, if repeated then reduces to 0 else remain ,then return."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "XOR of equal numbers is 0 and XOR of 0 and any number is the number itself."
                    },
                    {
                        "username": "Mohd_Musaiyab",
                        "content": "Well the given problem can easily be solved using Bitwise Operators .Using the EX-OR operator will just give us the answer we need.\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans=nums[i] ^ ans;\\n        }\\n        return ans;\\n              }\\n};"
                    }
                ]
            },
            {
                "id": 1907190,
                "content": [
                    {
                        "username": "Pokemon_Margo",
                        "content": "At first I decided by the logical method that came to mind. I saw that the speed was too low. I read the comments. Learned the binary method - XOR :) "
                    },
                    {
                        "username": "user8257Am",
                        "content": "i was using hash array technique, but it is failing one testcase when array has -ve elements. i am not sure how can i take care of -ve element."
                    },
                    {
                        "username": "ArunSreekanth",
                        "content": "How do we get the idea to solve using XOR. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@ArunSreekanth](/ArunSreekanth)\\nThe following challenges requires you to find out which single number is only represented once in an array. The XOR operator is perfect for this. If you XOR every number in your array you will get the singled out number.\\n\\nHere is an example:\\nInput: nums = [4,1,2,1,2]\\n4 ^ 1 = 5  \\n5 ^ 2 = 7\\n7 ^ 1 = 6\\n6 ^ 2 = 4\\nOutput: 4\\n\\nIf you want to know more what XOR is: https://www.w3schools.com/js/js_bitwise.asp \\n"
                    },
                    {
                        "username": "vishalrana17",
                        "content": "when mums[-1]\\noutput is -1\\nand my output is 1\\ncan any one tell my right one\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       for(int i =0;i<nums.length-1;i++){\\n           int curr = nums[i];\\n           for(int j=i+1;j<nums.length;j++){\\n               if(curr!=nums[j]&&curr-1!=nums[j]){\\n              return curr;\\n               }\\n               }\\n           }\\n          return  1;\\n\\n       }\\n}"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "Bitwise XOR : if corresponding number is different it gives 1 else it shows 0."
                    },
                    {
                        "username": "harika_drona",
                        "content": "if i try to submit this code, i am getting output as time limit exceeded for the testcase 59\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(0,n):\\n            count =0\\n            for j in range(0,n):\\n                if(nums[i]==nums[j]):\\n                    count+=1\\n                    \\n            if(count==1):\\n                return nums[i]\\n\\nCan someone help me "
                    },
                    {
                        "username": "RipperPY",
                        "content": "SPOILER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Traverse the array and XOR  all the elements, if repeated then reduces to 0 else remain ,then return."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "XOR of equal numbers is 0 and XOR of 0 and any number is the number itself."
                    },
                    {
                        "username": "Mohd_Musaiyab",
                        "content": "Well the given problem can easily be solved using Bitwise Operators .Using the EX-OR operator will just give us the answer we need.\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans=nums[i] ^ ans;\\n        }\\n        return ans;\\n              }\\n};"
                    }
                ]
            },
            {
                "id": 1878150,
                "content": [
                    {
                        "username": "Pokemon_Margo",
                        "content": "At first I decided by the logical method that came to mind. I saw that the speed was too low. I read the comments. Learned the binary method - XOR :) "
                    },
                    {
                        "username": "user8257Am",
                        "content": "i was using hash array technique, but it is failing one testcase when array has -ve elements. i am not sure how can i take care of -ve element."
                    },
                    {
                        "username": "ArunSreekanth",
                        "content": "How do we get the idea to solve using XOR. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@ArunSreekanth](/ArunSreekanth)\\nThe following challenges requires you to find out which single number is only represented once in an array. The XOR operator is perfect for this. If you XOR every number in your array you will get the singled out number.\\n\\nHere is an example:\\nInput: nums = [4,1,2,1,2]\\n4 ^ 1 = 5  \\n5 ^ 2 = 7\\n7 ^ 1 = 6\\n6 ^ 2 = 4\\nOutput: 4\\n\\nIf you want to know more what XOR is: https://www.w3schools.com/js/js_bitwise.asp \\n"
                    },
                    {
                        "username": "vishalrana17",
                        "content": "when mums[-1]\\noutput is -1\\nand my output is 1\\ncan any one tell my right one\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       for(int i =0;i<nums.length-1;i++){\\n           int curr = nums[i];\\n           for(int j=i+1;j<nums.length;j++){\\n               if(curr!=nums[j]&&curr-1!=nums[j]){\\n              return curr;\\n               }\\n               }\\n           }\\n          return  1;\\n\\n       }\\n}"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "Bitwise XOR : if corresponding number is different it gives 1 else it shows 0."
                    },
                    {
                        "username": "harika_drona",
                        "content": "if i try to submit this code, i am getting output as time limit exceeded for the testcase 59\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(0,n):\\n            count =0\\n            for j in range(0,n):\\n                if(nums[i]==nums[j]):\\n                    count+=1\\n                    \\n            if(count==1):\\n                return nums[i]\\n\\nCan someone help me "
                    },
                    {
                        "username": "RipperPY",
                        "content": "SPOILER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Traverse the array and XOR  all the elements, if repeated then reduces to 0 else remain ,then return."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "XOR of equal numbers is 0 and XOR of 0 and any number is the number itself."
                    },
                    {
                        "username": "Mohd_Musaiyab",
                        "content": "Well the given problem can easily be solved using Bitwise Operators .Using the EX-OR operator will just give us the answer we need.\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans=nums[i] ^ ans;\\n        }\\n        return ans;\\n              }\\n};"
                    }
                ]
            },
            {
                "id": 1840988,
                "content": [
                    {
                        "username": "Sudhanshu145",
                        "content": "it is very easy if you know about bitwise operation and or or xor .. etc..\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "I have tried this but I don\\'t why i showing error\\n    def singleNumber(self, nums):\\n        if len(nums)<=1:\\n            return nums\\n        else:\\n            temp = Counter(nums)\\n            for i in temp:\\n                if temp[i] == 1:\\n                    return i"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "So, looking at the discussion section I understood that it has to do with bit manipulation. But guys I have a doubt by any chance can we use Moore\\'s voting algorithm? Like the element which will repeat will first be 1, 2, then 0 but the element which is appearing only once will go like 1 then 0. \\n\\nExample: [4,1, 2,1,2]\\nElement: 4\\nVotes: 1, 0\\n\\nGotcha it can\\'t be used as when I cancel 4 and go to 1 the votes too will become and 1 then 0 as the array is not sorted and we can\\'t even sort it as we need to solve it in linear time complexity. "
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n       from collections import Counter\\n       nums = Counter(nums)\\n       for key, val in nums.items():\\n\\n        if val == 1:\\n           return key"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n\\n        if(nums.size() < 1){\\n            return 0;\\n        }\\n        else if(nums.size() > 1){\\n             sort(nums.begin(),nums.end());\\n\\n             for(int i=0;i<nums.size();i++){\\n                 if(nums[i] != nums[i+1]){\\n                     return nums[i];\\n                 }\\n                 i++;\\n             }\\n        }\\n        return nums[0];\\n\\n    //     int ans = 0;\\n    //     for(int i = 0; i<nums.size();i++){\\n    //         ans = ans^nums[i];\\n    //     }\\n    //     return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Since in XOR Operations 0^0 = 0 and 1^1 = 0.\nHence here the same bits(numbers) will cancel out each other i.e result to zero and only the unique bit(number) will be left.!!!\n\nA^A=0\nA^B^A=B\n(A^A^B) = (B^A^A) = (A^B^A) = B This shows that position doesn't matter.\nSimilarly , if we see , a^a^a......... (even times)=0 and a^a^a........(odd times)=a\n\n\n\n\nclass Solution {\n  int singleNumber(List<int> nums) {\n    \n    int res = 0;\n    for(int i in nums){\n        res = res^i;\n    }\n      return res;\n  }\n}\n\n\n\n"
                    },
                    {
                        "username": "MrunalMania",
                        "content": "XOR and concept of reduce function in python , makes this problem one-liner."
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int j=0;\\n        for(int i=1;i<nums.length;i=i+2){\\n            if(nums[j]!=nums[i]){\\n                return nums[j];\\n            }\\n            j=j+2;\\n        }\\n\\n        return nums[j];\\n\\n    }\\n}`"
                    },
                    {
                        "username": "shivam08122001",
                        "content": "this solution is given by using c only\\ndeclare a int (suppose Ans) keep Ans=nums[0];\\nthen by using loop perform xor on the given array, start the index from 1\\nex:-for(int i=1; ..............................................)\\n{\\nans=ans+nums[i];\\n}\\n"
                    }
                ]
            },
            {
                "id": 1826599,
                "content": [
                    {
                        "username": "Sudhanshu145",
                        "content": "it is very easy if you know about bitwise operation and or or xor .. etc..\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "I have tried this but I don\\'t why i showing error\\n    def singleNumber(self, nums):\\n        if len(nums)<=1:\\n            return nums\\n        else:\\n            temp = Counter(nums)\\n            for i in temp:\\n                if temp[i] == 1:\\n                    return i"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "So, looking at the discussion section I understood that it has to do with bit manipulation. But guys I have a doubt by any chance can we use Moore\\'s voting algorithm? Like the element which will repeat will first be 1, 2, then 0 but the element which is appearing only once will go like 1 then 0. \\n\\nExample: [4,1, 2,1,2]\\nElement: 4\\nVotes: 1, 0\\n\\nGotcha it can\\'t be used as when I cancel 4 and go to 1 the votes too will become and 1 then 0 as the array is not sorted and we can\\'t even sort it as we need to solve it in linear time complexity. "
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n       from collections import Counter\\n       nums = Counter(nums)\\n       for key, val in nums.items():\\n\\n        if val == 1:\\n           return key"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n\\n        if(nums.size() < 1){\\n            return 0;\\n        }\\n        else if(nums.size() > 1){\\n             sort(nums.begin(),nums.end());\\n\\n             for(int i=0;i<nums.size();i++){\\n                 if(nums[i] != nums[i+1]){\\n                     return nums[i];\\n                 }\\n                 i++;\\n             }\\n        }\\n        return nums[0];\\n\\n    //     int ans = 0;\\n    //     for(int i = 0; i<nums.size();i++){\\n    //         ans = ans^nums[i];\\n    //     }\\n    //     return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Since in XOR Operations 0^0 = 0 and 1^1 = 0.\nHence here the same bits(numbers) will cancel out each other i.e result to zero and only the unique bit(number) will be left.!!!\n\nA^A=0\nA^B^A=B\n(A^A^B) = (B^A^A) = (A^B^A) = B This shows that position doesn't matter.\nSimilarly , if we see , a^a^a......... (even times)=0 and a^a^a........(odd times)=a\n\n\n\n\nclass Solution {\n  int singleNumber(List<int> nums) {\n    \n    int res = 0;\n    for(int i in nums){\n        res = res^i;\n    }\n      return res;\n  }\n}\n\n\n\n"
                    },
                    {
                        "username": "MrunalMania",
                        "content": "XOR and concept of reduce function in python , makes this problem one-liner."
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int j=0;\\n        for(int i=1;i<nums.length;i=i+2){\\n            if(nums[j]!=nums[i]){\\n                return nums[j];\\n            }\\n            j=j+2;\\n        }\\n\\n        return nums[j];\\n\\n    }\\n}`"
                    },
                    {
                        "username": "shivam08122001",
                        "content": "this solution is given by using c only\\ndeclare a int (suppose Ans) keep Ans=nums[0];\\nthen by using loop perform xor on the given array, start the index from 1\\nex:-for(int i=1; ..............................................)\\n{\\nans=ans+nums[i];\\n}\\n"
                    }
                ]
            },
            {
                "id": 1824907,
                "content": [
                    {
                        "username": "Sudhanshu145",
                        "content": "it is very easy if you know about bitwise operation and or or xor .. etc..\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "I have tried this but I don\\'t why i showing error\\n    def singleNumber(self, nums):\\n        if len(nums)<=1:\\n            return nums\\n        else:\\n            temp = Counter(nums)\\n            for i in temp:\\n                if temp[i] == 1:\\n                    return i"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "So, looking at the discussion section I understood that it has to do with bit manipulation. But guys I have a doubt by any chance can we use Moore\\'s voting algorithm? Like the element which will repeat will first be 1, 2, then 0 but the element which is appearing only once will go like 1 then 0. \\n\\nExample: [4,1, 2,1,2]\\nElement: 4\\nVotes: 1, 0\\n\\nGotcha it can\\'t be used as when I cancel 4 and go to 1 the votes too will become and 1 then 0 as the array is not sorted and we can\\'t even sort it as we need to solve it in linear time complexity. "
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n       from collections import Counter\\n       nums = Counter(nums)\\n       for key, val in nums.items():\\n\\n        if val == 1:\\n           return key"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n\\n        if(nums.size() < 1){\\n            return 0;\\n        }\\n        else if(nums.size() > 1){\\n             sort(nums.begin(),nums.end());\\n\\n             for(int i=0;i<nums.size();i++){\\n                 if(nums[i] != nums[i+1]){\\n                     return nums[i];\\n                 }\\n                 i++;\\n             }\\n        }\\n        return nums[0];\\n\\n    //     int ans = 0;\\n    //     for(int i = 0; i<nums.size();i++){\\n    //         ans = ans^nums[i];\\n    //     }\\n    //     return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Since in XOR Operations 0^0 = 0 and 1^1 = 0.\nHence here the same bits(numbers) will cancel out each other i.e result to zero and only the unique bit(number) will be left.!!!\n\nA^A=0\nA^B^A=B\n(A^A^B) = (B^A^A) = (A^B^A) = B This shows that position doesn't matter.\nSimilarly , if we see , a^a^a......... (even times)=0 and a^a^a........(odd times)=a\n\n\n\n\nclass Solution {\n  int singleNumber(List<int> nums) {\n    \n    int res = 0;\n    for(int i in nums){\n        res = res^i;\n    }\n      return res;\n  }\n}\n\n\n\n"
                    },
                    {
                        "username": "MrunalMania",
                        "content": "XOR and concept of reduce function in python , makes this problem one-liner."
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int j=0;\\n        for(int i=1;i<nums.length;i=i+2){\\n            if(nums[j]!=nums[i]){\\n                return nums[j];\\n            }\\n            j=j+2;\\n        }\\n\\n        return nums[j];\\n\\n    }\\n}`"
                    },
                    {
                        "username": "shivam08122001",
                        "content": "this solution is given by using c only\\ndeclare a int (suppose Ans) keep Ans=nums[0];\\nthen by using loop perform xor on the given array, start the index from 1\\nex:-for(int i=1; ..............................................)\\n{\\nans=ans+nums[i];\\n}\\n"
                    }
                ]
            },
            {
                "id": 1805259,
                "content": [
                    {
                        "username": "Sudhanshu145",
                        "content": "it is very easy if you know about bitwise operation and or or xor .. etc..\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "I have tried this but I don\\'t why i showing error\\n    def singleNumber(self, nums):\\n        if len(nums)<=1:\\n            return nums\\n        else:\\n            temp = Counter(nums)\\n            for i in temp:\\n                if temp[i] == 1:\\n                    return i"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "So, looking at the discussion section I understood that it has to do with bit manipulation. But guys I have a doubt by any chance can we use Moore\\'s voting algorithm? Like the element which will repeat will first be 1, 2, then 0 but the element which is appearing only once will go like 1 then 0. \\n\\nExample: [4,1, 2,1,2]\\nElement: 4\\nVotes: 1, 0\\n\\nGotcha it can\\'t be used as when I cancel 4 and go to 1 the votes too will become and 1 then 0 as the array is not sorted and we can\\'t even sort it as we need to solve it in linear time complexity. "
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n       from collections import Counter\\n       nums = Counter(nums)\\n       for key, val in nums.items():\\n\\n        if val == 1:\\n           return key"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n\\n        if(nums.size() < 1){\\n            return 0;\\n        }\\n        else if(nums.size() > 1){\\n             sort(nums.begin(),nums.end());\\n\\n             for(int i=0;i<nums.size();i++){\\n                 if(nums[i] != nums[i+1]){\\n                     return nums[i];\\n                 }\\n                 i++;\\n             }\\n        }\\n        return nums[0];\\n\\n    //     int ans = 0;\\n    //     for(int i = 0; i<nums.size();i++){\\n    //         ans = ans^nums[i];\\n    //     }\\n    //     return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Since in XOR Operations 0^0 = 0 and 1^1 = 0.\nHence here the same bits(numbers) will cancel out each other i.e result to zero and only the unique bit(number) will be left.!!!\n\nA^A=0\nA^B^A=B\n(A^A^B) = (B^A^A) = (A^B^A) = B This shows that position doesn't matter.\nSimilarly , if we see , a^a^a......... (even times)=0 and a^a^a........(odd times)=a\n\n\n\n\nclass Solution {\n  int singleNumber(List<int> nums) {\n    \n    int res = 0;\n    for(int i in nums){\n        res = res^i;\n    }\n      return res;\n  }\n}\n\n\n\n"
                    },
                    {
                        "username": "MrunalMania",
                        "content": "XOR and concept of reduce function in python , makes this problem one-liner."
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int j=0;\\n        for(int i=1;i<nums.length;i=i+2){\\n            if(nums[j]!=nums[i]){\\n                return nums[j];\\n            }\\n            j=j+2;\\n        }\\n\\n        return nums[j];\\n\\n    }\\n}`"
                    },
                    {
                        "username": "shivam08122001",
                        "content": "this solution is given by using c only\\ndeclare a int (suppose Ans) keep Ans=nums[0];\\nthen by using loop perform xor on the given array, start the index from 1\\nex:-for(int i=1; ..............................................)\\n{\\nans=ans+nums[i];\\n}\\n"
                    }
                ]
            },
            {
                "id": 1805248,
                "content": [
                    {
                        "username": "Sudhanshu145",
                        "content": "it is very easy if you know about bitwise operation and or or xor .. etc..\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "I have tried this but I don\\'t why i showing error\\n    def singleNumber(self, nums):\\n        if len(nums)<=1:\\n            return nums\\n        else:\\n            temp = Counter(nums)\\n            for i in temp:\\n                if temp[i] == 1:\\n                    return i"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "So, looking at the discussion section I understood that it has to do with bit manipulation. But guys I have a doubt by any chance can we use Moore\\'s voting algorithm? Like the element which will repeat will first be 1, 2, then 0 but the element which is appearing only once will go like 1 then 0. \\n\\nExample: [4,1, 2,1,2]\\nElement: 4\\nVotes: 1, 0\\n\\nGotcha it can\\'t be used as when I cancel 4 and go to 1 the votes too will become and 1 then 0 as the array is not sorted and we can\\'t even sort it as we need to solve it in linear time complexity. "
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n       from collections import Counter\\n       nums = Counter(nums)\\n       for key, val in nums.items():\\n\\n        if val == 1:\\n           return key"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n\\n        if(nums.size() < 1){\\n            return 0;\\n        }\\n        else if(nums.size() > 1){\\n             sort(nums.begin(),nums.end());\\n\\n             for(int i=0;i<nums.size();i++){\\n                 if(nums[i] != nums[i+1]){\\n                     return nums[i];\\n                 }\\n                 i++;\\n             }\\n        }\\n        return nums[0];\\n\\n    //     int ans = 0;\\n    //     for(int i = 0; i<nums.size();i++){\\n    //         ans = ans^nums[i];\\n    //     }\\n    //     return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Since in XOR Operations 0^0 = 0 and 1^1 = 0.\nHence here the same bits(numbers) will cancel out each other i.e result to zero and only the unique bit(number) will be left.!!!\n\nA^A=0\nA^B^A=B\n(A^A^B) = (B^A^A) = (A^B^A) = B This shows that position doesn't matter.\nSimilarly , if we see , a^a^a......... (even times)=0 and a^a^a........(odd times)=a\n\n\n\n\nclass Solution {\n  int singleNumber(List<int> nums) {\n    \n    int res = 0;\n    for(int i in nums){\n        res = res^i;\n    }\n      return res;\n  }\n}\n\n\n\n"
                    },
                    {
                        "username": "MrunalMania",
                        "content": "XOR and concept of reduce function in python , makes this problem one-liner."
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int j=0;\\n        for(int i=1;i<nums.length;i=i+2){\\n            if(nums[j]!=nums[i]){\\n                return nums[j];\\n            }\\n            j=j+2;\\n        }\\n\\n        return nums[j];\\n\\n    }\\n}`"
                    },
                    {
                        "username": "shivam08122001",
                        "content": "this solution is given by using c only\\ndeclare a int (suppose Ans) keep Ans=nums[0];\\nthen by using loop perform xor on the given array, start the index from 1\\nex:-for(int i=1; ..............................................)\\n{\\nans=ans+nums[i];\\n}\\n"
                    }
                ]
            },
            {
                "id": 1803246,
                "content": [
                    {
                        "username": "Sudhanshu145",
                        "content": "it is very easy if you know about bitwise operation and or or xor .. etc..\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "I have tried this but I don\\'t why i showing error\\n    def singleNumber(self, nums):\\n        if len(nums)<=1:\\n            return nums\\n        else:\\n            temp = Counter(nums)\\n            for i in temp:\\n                if temp[i] == 1:\\n                    return i"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "So, looking at the discussion section I understood that it has to do with bit manipulation. But guys I have a doubt by any chance can we use Moore\\'s voting algorithm? Like the element which will repeat will first be 1, 2, then 0 but the element which is appearing only once will go like 1 then 0. \\n\\nExample: [4,1, 2,1,2]\\nElement: 4\\nVotes: 1, 0\\n\\nGotcha it can\\'t be used as when I cancel 4 and go to 1 the votes too will become and 1 then 0 as the array is not sorted and we can\\'t even sort it as we need to solve it in linear time complexity. "
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n       from collections import Counter\\n       nums = Counter(nums)\\n       for key, val in nums.items():\\n\\n        if val == 1:\\n           return key"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n\\n        if(nums.size() < 1){\\n            return 0;\\n        }\\n        else if(nums.size() > 1){\\n             sort(nums.begin(),nums.end());\\n\\n             for(int i=0;i<nums.size();i++){\\n                 if(nums[i] != nums[i+1]){\\n                     return nums[i];\\n                 }\\n                 i++;\\n             }\\n        }\\n        return nums[0];\\n\\n    //     int ans = 0;\\n    //     for(int i = 0; i<nums.size();i++){\\n    //         ans = ans^nums[i];\\n    //     }\\n    //     return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Since in XOR Operations 0^0 = 0 and 1^1 = 0.\nHence here the same bits(numbers) will cancel out each other i.e result to zero and only the unique bit(number) will be left.!!!\n\nA^A=0\nA^B^A=B\n(A^A^B) = (B^A^A) = (A^B^A) = B This shows that position doesn't matter.\nSimilarly , if we see , a^a^a......... (even times)=0 and a^a^a........(odd times)=a\n\n\n\n\nclass Solution {\n  int singleNumber(List<int> nums) {\n    \n    int res = 0;\n    for(int i in nums){\n        res = res^i;\n    }\n      return res;\n  }\n}\n\n\n\n"
                    },
                    {
                        "username": "MrunalMania",
                        "content": "XOR and concept of reduce function in python , makes this problem one-liner."
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int j=0;\\n        for(int i=1;i<nums.length;i=i+2){\\n            if(nums[j]!=nums[i]){\\n                return nums[j];\\n            }\\n            j=j+2;\\n        }\\n\\n        return nums[j];\\n\\n    }\\n}`"
                    },
                    {
                        "username": "shivam08122001",
                        "content": "this solution is given by using c only\\ndeclare a int (suppose Ans) keep Ans=nums[0];\\nthen by using loop perform xor on the given array, start the index from 1\\nex:-for(int i=1; ..............................................)\\n{\\nans=ans+nums[i];\\n}\\n"
                    }
                ]
            },
            {
                "id": 1803217,
                "content": [
                    {
                        "username": "Sudhanshu145",
                        "content": "it is very easy if you know about bitwise operation and or or xor .. etc..\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "I have tried this but I don\\'t why i showing error\\n    def singleNumber(self, nums):\\n        if len(nums)<=1:\\n            return nums\\n        else:\\n            temp = Counter(nums)\\n            for i in temp:\\n                if temp[i] == 1:\\n                    return i"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "So, looking at the discussion section I understood that it has to do with bit manipulation. But guys I have a doubt by any chance can we use Moore\\'s voting algorithm? Like the element which will repeat will first be 1, 2, then 0 but the element which is appearing only once will go like 1 then 0. \\n\\nExample: [4,1, 2,1,2]\\nElement: 4\\nVotes: 1, 0\\n\\nGotcha it can\\'t be used as when I cancel 4 and go to 1 the votes too will become and 1 then 0 as the array is not sorted and we can\\'t even sort it as we need to solve it in linear time complexity. "
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n       from collections import Counter\\n       nums = Counter(nums)\\n       for key, val in nums.items():\\n\\n        if val == 1:\\n           return key"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n\\n        if(nums.size() < 1){\\n            return 0;\\n        }\\n        else if(nums.size() > 1){\\n             sort(nums.begin(),nums.end());\\n\\n             for(int i=0;i<nums.size();i++){\\n                 if(nums[i] != nums[i+1]){\\n                     return nums[i];\\n                 }\\n                 i++;\\n             }\\n        }\\n        return nums[0];\\n\\n    //     int ans = 0;\\n    //     for(int i = 0; i<nums.size();i++){\\n    //         ans = ans^nums[i];\\n    //     }\\n    //     return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Since in XOR Operations 0^0 = 0 and 1^1 = 0.\nHence here the same bits(numbers) will cancel out each other i.e result to zero and only the unique bit(number) will be left.!!!\n\nA^A=0\nA^B^A=B\n(A^A^B) = (B^A^A) = (A^B^A) = B This shows that position doesn't matter.\nSimilarly , if we see , a^a^a......... (even times)=0 and a^a^a........(odd times)=a\n\n\n\n\nclass Solution {\n  int singleNumber(List<int> nums) {\n    \n    int res = 0;\n    for(int i in nums){\n        res = res^i;\n    }\n      return res;\n  }\n}\n\n\n\n"
                    },
                    {
                        "username": "MrunalMania",
                        "content": "XOR and concept of reduce function in python , makes this problem one-liner."
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int j=0;\\n        for(int i=1;i<nums.length;i=i+2){\\n            if(nums[j]!=nums[i]){\\n                return nums[j];\\n            }\\n            j=j+2;\\n        }\\n\\n        return nums[j];\\n\\n    }\\n}`"
                    },
                    {
                        "username": "shivam08122001",
                        "content": "this solution is given by using c only\\ndeclare a int (suppose Ans) keep Ans=nums[0];\\nthen by using loop perform xor on the given array, start the index from 1\\nex:-for(int i=1; ..............................................)\\n{\\nans=ans+nums[i];\\n}\\n"
                    }
                ]
            },
            {
                "id": 1794956,
                "content": [
                    {
                        "username": "Sudhanshu145",
                        "content": "it is very easy if you know about bitwise operation and or or xor .. etc..\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "I have tried this but I don\\'t why i showing error\\n    def singleNumber(self, nums):\\n        if len(nums)<=1:\\n            return nums\\n        else:\\n            temp = Counter(nums)\\n            for i in temp:\\n                if temp[i] == 1:\\n                    return i"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "So, looking at the discussion section I understood that it has to do with bit manipulation. But guys I have a doubt by any chance can we use Moore\\'s voting algorithm? Like the element which will repeat will first be 1, 2, then 0 but the element which is appearing only once will go like 1 then 0. \\n\\nExample: [4,1, 2,1,2]\\nElement: 4\\nVotes: 1, 0\\n\\nGotcha it can\\'t be used as when I cancel 4 and go to 1 the votes too will become and 1 then 0 as the array is not sorted and we can\\'t even sort it as we need to solve it in linear time complexity. "
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n       from collections import Counter\\n       nums = Counter(nums)\\n       for key, val in nums.items():\\n\\n        if val == 1:\\n           return key"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n\\n        if(nums.size() < 1){\\n            return 0;\\n        }\\n        else if(nums.size() > 1){\\n             sort(nums.begin(),nums.end());\\n\\n             for(int i=0;i<nums.size();i++){\\n                 if(nums[i] != nums[i+1]){\\n                     return nums[i];\\n                 }\\n                 i++;\\n             }\\n        }\\n        return nums[0];\\n\\n    //     int ans = 0;\\n    //     for(int i = 0; i<nums.size();i++){\\n    //         ans = ans^nums[i];\\n    //     }\\n    //     return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Since in XOR Operations 0^0 = 0 and 1^1 = 0.\nHence here the same bits(numbers) will cancel out each other i.e result to zero and only the unique bit(number) will be left.!!!\n\nA^A=0\nA^B^A=B\n(A^A^B) = (B^A^A) = (A^B^A) = B This shows that position doesn't matter.\nSimilarly , if we see , a^a^a......... (even times)=0 and a^a^a........(odd times)=a\n\n\n\n\nclass Solution {\n  int singleNumber(List<int> nums) {\n    \n    int res = 0;\n    for(int i in nums){\n        res = res^i;\n    }\n      return res;\n  }\n}\n\n\n\n"
                    },
                    {
                        "username": "MrunalMania",
                        "content": "XOR and concept of reduce function in python , makes this problem one-liner."
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int j=0;\\n        for(int i=1;i<nums.length;i=i+2){\\n            if(nums[j]!=nums[i]){\\n                return nums[j];\\n            }\\n            j=j+2;\\n        }\\n\\n        return nums[j];\\n\\n    }\\n}`"
                    },
                    {
                        "username": "shivam08122001",
                        "content": "this solution is given by using c only\\ndeclare a int (suppose Ans) keep Ans=nums[0];\\nthen by using loop perform xor on the given array, start the index from 1\\nex:-for(int i=1; ..............................................)\\n{\\nans=ans+nums[i];\\n}\\n"
                    }
                ]
            },
            {
                "id": 1786805,
                "content": [
                    {
                        "username": "Sudhanshu145",
                        "content": "it is very easy if you know about bitwise operation and or or xor .. etc..\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "I have tried this but I don\\'t why i showing error\\n    def singleNumber(self, nums):\\n        if len(nums)<=1:\\n            return nums\\n        else:\\n            temp = Counter(nums)\\n            for i in temp:\\n                if temp[i] == 1:\\n                    return i"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "So, looking at the discussion section I understood that it has to do with bit manipulation. But guys I have a doubt by any chance can we use Moore\\'s voting algorithm? Like the element which will repeat will first be 1, 2, then 0 but the element which is appearing only once will go like 1 then 0. \\n\\nExample: [4,1, 2,1,2]\\nElement: 4\\nVotes: 1, 0\\n\\nGotcha it can\\'t be used as when I cancel 4 and go to 1 the votes too will become and 1 then 0 as the array is not sorted and we can\\'t even sort it as we need to solve it in linear time complexity. "
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n       from collections import Counter\\n       nums = Counter(nums)\\n       for key, val in nums.items():\\n\\n        if val == 1:\\n           return key"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n\\n        if(nums.size() < 1){\\n            return 0;\\n        }\\n        else if(nums.size() > 1){\\n             sort(nums.begin(),nums.end());\\n\\n             for(int i=0;i<nums.size();i++){\\n                 if(nums[i] != nums[i+1]){\\n                     return nums[i];\\n                 }\\n                 i++;\\n             }\\n        }\\n        return nums[0];\\n\\n    //     int ans = 0;\\n    //     for(int i = 0; i<nums.size();i++){\\n    //         ans = ans^nums[i];\\n    //     }\\n    //     return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Since in XOR Operations 0^0 = 0 and 1^1 = 0.\nHence here the same bits(numbers) will cancel out each other i.e result to zero and only the unique bit(number) will be left.!!!\n\nA^A=0\nA^B^A=B\n(A^A^B) = (B^A^A) = (A^B^A) = B This shows that position doesn't matter.\nSimilarly , if we see , a^a^a......... (even times)=0 and a^a^a........(odd times)=a\n\n\n\n\nclass Solution {\n  int singleNumber(List<int> nums) {\n    \n    int res = 0;\n    for(int i in nums){\n        res = res^i;\n    }\n      return res;\n  }\n}\n\n\n\n"
                    },
                    {
                        "username": "MrunalMania",
                        "content": "XOR and concept of reduce function in python , makes this problem one-liner."
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int j=0;\\n        for(int i=1;i<nums.length;i=i+2){\\n            if(nums[j]!=nums[i]){\\n                return nums[j];\\n            }\\n            j=j+2;\\n        }\\n\\n        return nums[j];\\n\\n    }\\n}`"
                    },
                    {
                        "username": "shivam08122001",
                        "content": "this solution is given by using c only\\ndeclare a int (suppose Ans) keep Ans=nums[0];\\nthen by using loop perform xor on the given array, start the index from 1\\nex:-for(int i=1; ..............................................)\\n{\\nans=ans+nums[i];\\n}\\n"
                    }
                ]
            },
            {
                "id": 1785569,
                "content": [
                    {
                        "username": "Sudhanshu145",
                        "content": "it is very easy if you know about bitwise operation and or or xor .. etc..\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "I have tried this but I don\\'t why i showing error\\n    def singleNumber(self, nums):\\n        if len(nums)<=1:\\n            return nums\\n        else:\\n            temp = Counter(nums)\\n            for i in temp:\\n                if temp[i] == 1:\\n                    return i"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "So, looking at the discussion section I understood that it has to do with bit manipulation. But guys I have a doubt by any chance can we use Moore\\'s voting algorithm? Like the element which will repeat will first be 1, 2, then 0 but the element which is appearing only once will go like 1 then 0. \\n\\nExample: [4,1, 2,1,2]\\nElement: 4\\nVotes: 1, 0\\n\\nGotcha it can\\'t be used as when I cancel 4 and go to 1 the votes too will become and 1 then 0 as the array is not sorted and we can\\'t even sort it as we need to solve it in linear time complexity. "
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n       from collections import Counter\\n       nums = Counter(nums)\\n       for key, val in nums.items():\\n\\n        if val == 1:\\n           return key"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n\\n        if(nums.size() < 1){\\n            return 0;\\n        }\\n        else if(nums.size() > 1){\\n             sort(nums.begin(),nums.end());\\n\\n             for(int i=0;i<nums.size();i++){\\n                 if(nums[i] != nums[i+1]){\\n                     return nums[i];\\n                 }\\n                 i++;\\n             }\\n        }\\n        return nums[0];\\n\\n    //     int ans = 0;\\n    //     for(int i = 0; i<nums.size();i++){\\n    //         ans = ans^nums[i];\\n    //     }\\n    //     return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Since in XOR Operations 0^0 = 0 and 1^1 = 0.\nHence here the same bits(numbers) will cancel out each other i.e result to zero and only the unique bit(number) will be left.!!!\n\nA^A=0\nA^B^A=B\n(A^A^B) = (B^A^A) = (A^B^A) = B This shows that position doesn't matter.\nSimilarly , if we see , a^a^a......... (even times)=0 and a^a^a........(odd times)=a\n\n\n\n\nclass Solution {\n  int singleNumber(List<int> nums) {\n    \n    int res = 0;\n    for(int i in nums){\n        res = res^i;\n    }\n      return res;\n  }\n}\n\n\n\n"
                    },
                    {
                        "username": "MrunalMania",
                        "content": "XOR and concept of reduce function in python , makes this problem one-liner."
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int j=0;\\n        for(int i=1;i<nums.length;i=i+2){\\n            if(nums[j]!=nums[i]){\\n                return nums[j];\\n            }\\n            j=j+2;\\n        }\\n\\n        return nums[j];\\n\\n    }\\n}`"
                    },
                    {
                        "username": "shivam08122001",
                        "content": "this solution is given by using c only\\ndeclare a int (suppose Ans) keep Ans=nums[0];\\nthen by using loop perform xor on the given array, start the index from 1\\nex:-for(int i=1; ..............................................)\\n{\\nans=ans+nums[i];\\n}\\n"
                    }
                ]
            },
            {
                "id": 1783051,
                "content": [
                    {
                        "username": "skcoder007",
                        "content": "Time Complexity = O(n)\nSpace Complexity = O(1) \n/* Bit Manipulation  using XOR\nn^n=0\n0^n=n\nso, 0^3^7^5^3^5 = 7\n\n``class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int n = nums.size();\n        int res =0;\n        for (int i=0;i<n;i++){\n            res=res^nums[i];\n        }\n        return res;\n    }\n};``\n"
                    },
                    {
                        "username": "natest77",
                        "content": "Go for  solving the problem using xor which gives 100% runtime,less code and easy to understand. Others solution may be there but solution using xor will be so intresting!!! . "
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Won\\'t be easy if You don\\'t know the concept of bitwise operator(XOR here)"
                    },
                    {
                        "username": "bravepoatotes",
                        "content": "Everytime I run the following code: \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            o = nums.count(i)\\n        for k in nums:\\n            if o<=0:\\n                return k\\n`\\nI get the following error\\n\\n TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 31 in _driver (Solution.py)\\n    _driver()\\nLine 38 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 29 in _driver (Solution.py)\\n\\nAnyone know why this is happening?"
                    },
                    {
                        "username": "ayush3105",
                        "content": "You can use property of XOR"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i\\n"
                    },
                    {
                        "username": "Snigdha_Reddy_Kathula",
                        "content": "It includes Arrays combines with Bit Manipulation. we can use XOR here,\\nTip: a^a=0\\n       a^0=a\\nby using this you can solve this easily, i think"
                    },
                    {
                        "username": "user9423V",
                        "content": "for i in set(nums):\\n            nums.remove(i)\\n            if i not in nums:\\n                return i\\n            else:\\n                nums.remove(i)\\n        return \"not found\""
                    },
                    {
                        "username": "clever_code",
                        "content": "Hello guys, can you find out the problem in my code\\n\\nimport java.util.Arrays;\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans = nums[0];\\n        for (int i = 0; i < n-1; i+=2){\\n            if (!(nums[i] == nums[i+1])){\\n                ans = nums[i];\\n                return nums[i];\\n            }\\n            else{\\n                ans = nums[n-1];\\n                return nums[n-1];\\n            }\\n        }\\n        return ans;\\n    }\\n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1781246,
                "content": [
                    {
                        "username": "skcoder007",
                        "content": "Time Complexity = O(n)\nSpace Complexity = O(1) \n/* Bit Manipulation  using XOR\nn^n=0\n0^n=n\nso, 0^3^7^5^3^5 = 7\n\n``class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int n = nums.size();\n        int res =0;\n        for (int i=0;i<n;i++){\n            res=res^nums[i];\n        }\n        return res;\n    }\n};``\n"
                    },
                    {
                        "username": "natest77",
                        "content": "Go for  solving the problem using xor which gives 100% runtime,less code and easy to understand. Others solution may be there but solution using xor will be so intresting!!! . "
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Won\\'t be easy if You don\\'t know the concept of bitwise operator(XOR here)"
                    },
                    {
                        "username": "bravepoatotes",
                        "content": "Everytime I run the following code: \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            o = nums.count(i)\\n        for k in nums:\\n            if o<=0:\\n                return k\\n`\\nI get the following error\\n\\n TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 31 in _driver (Solution.py)\\n    _driver()\\nLine 38 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 29 in _driver (Solution.py)\\n\\nAnyone know why this is happening?"
                    },
                    {
                        "username": "ayush3105",
                        "content": "You can use property of XOR"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i\\n"
                    },
                    {
                        "username": "Snigdha_Reddy_Kathula",
                        "content": "It includes Arrays combines with Bit Manipulation. we can use XOR here,\\nTip: a^a=0\\n       a^0=a\\nby using this you can solve this easily, i think"
                    },
                    {
                        "username": "user9423V",
                        "content": "for i in set(nums):\\n            nums.remove(i)\\n            if i not in nums:\\n                return i\\n            else:\\n                nums.remove(i)\\n        return \"not found\""
                    },
                    {
                        "username": "clever_code",
                        "content": "Hello guys, can you find out the problem in my code\\n\\nimport java.util.Arrays;\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans = nums[0];\\n        for (int i = 0; i < n-1; i+=2){\\n            if (!(nums[i] == nums[i+1])){\\n                ans = nums[i];\\n                return nums[i];\\n            }\\n            else{\\n                ans = nums[n-1];\\n                return nums[n-1];\\n            }\\n        }\\n        return ans;\\n    }\\n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1774418,
                "content": [
                    {
                        "username": "skcoder007",
                        "content": "Time Complexity = O(n)\nSpace Complexity = O(1) \n/* Bit Manipulation  using XOR\nn^n=0\n0^n=n\nso, 0^3^7^5^3^5 = 7\n\n``class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int n = nums.size();\n        int res =0;\n        for (int i=0;i<n;i++){\n            res=res^nums[i];\n        }\n        return res;\n    }\n};``\n"
                    },
                    {
                        "username": "natest77",
                        "content": "Go for  solving the problem using xor which gives 100% runtime,less code and easy to understand. Others solution may be there but solution using xor will be so intresting!!! . "
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Won\\'t be easy if You don\\'t know the concept of bitwise operator(XOR here)"
                    },
                    {
                        "username": "bravepoatotes",
                        "content": "Everytime I run the following code: \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            o = nums.count(i)\\n        for k in nums:\\n            if o<=0:\\n                return k\\n`\\nI get the following error\\n\\n TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 31 in _driver (Solution.py)\\n    _driver()\\nLine 38 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 29 in _driver (Solution.py)\\n\\nAnyone know why this is happening?"
                    },
                    {
                        "username": "ayush3105",
                        "content": "You can use property of XOR"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i\\n"
                    },
                    {
                        "username": "Snigdha_Reddy_Kathula",
                        "content": "It includes Arrays combines with Bit Manipulation. we can use XOR here,\\nTip: a^a=0\\n       a^0=a\\nby using this you can solve this easily, i think"
                    },
                    {
                        "username": "user9423V",
                        "content": "for i in set(nums):\\n            nums.remove(i)\\n            if i not in nums:\\n                return i\\n            else:\\n                nums.remove(i)\\n        return \"not found\""
                    },
                    {
                        "username": "clever_code",
                        "content": "Hello guys, can you find out the problem in my code\\n\\nimport java.util.Arrays;\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans = nums[0];\\n        for (int i = 0; i < n-1; i+=2){\\n            if (!(nums[i] == nums[i+1])){\\n                ans = nums[i];\\n                return nums[i];\\n            }\\n            else{\\n                ans = nums[n-1];\\n                return nums[n-1];\\n            }\\n        }\\n        return ans;\\n    }\\n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1768168,
                "content": [
                    {
                        "username": "skcoder007",
                        "content": "Time Complexity = O(n)\nSpace Complexity = O(1) \n/* Bit Manipulation  using XOR\nn^n=0\n0^n=n\nso, 0^3^7^5^3^5 = 7\n\n``class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int n = nums.size();\n        int res =0;\n        for (int i=0;i<n;i++){\n            res=res^nums[i];\n        }\n        return res;\n    }\n};``\n"
                    },
                    {
                        "username": "natest77",
                        "content": "Go for  solving the problem using xor which gives 100% runtime,less code and easy to understand. Others solution may be there but solution using xor will be so intresting!!! . "
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Won\\'t be easy if You don\\'t know the concept of bitwise operator(XOR here)"
                    },
                    {
                        "username": "bravepoatotes",
                        "content": "Everytime I run the following code: \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            o = nums.count(i)\\n        for k in nums:\\n            if o<=0:\\n                return k\\n`\\nI get the following error\\n\\n TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 31 in _driver (Solution.py)\\n    _driver()\\nLine 38 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 29 in _driver (Solution.py)\\n\\nAnyone know why this is happening?"
                    },
                    {
                        "username": "ayush3105",
                        "content": "You can use property of XOR"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i\\n"
                    },
                    {
                        "username": "Snigdha_Reddy_Kathula",
                        "content": "It includes Arrays combines with Bit Manipulation. we can use XOR here,\\nTip: a^a=0\\n       a^0=a\\nby using this you can solve this easily, i think"
                    },
                    {
                        "username": "user9423V",
                        "content": "for i in set(nums):\\n            nums.remove(i)\\n            if i not in nums:\\n                return i\\n            else:\\n                nums.remove(i)\\n        return \"not found\""
                    },
                    {
                        "username": "clever_code",
                        "content": "Hello guys, can you find out the problem in my code\\n\\nimport java.util.Arrays;\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans = nums[0];\\n        for (int i = 0; i < n-1; i+=2){\\n            if (!(nums[i] == nums[i+1])){\\n                ans = nums[i];\\n                return nums[i];\\n            }\\n            else{\\n                ans = nums[n-1];\\n                return nums[n-1];\\n            }\\n        }\\n        return ans;\\n    }\\n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1767664,
                "content": [
                    {
                        "username": "skcoder007",
                        "content": "Time Complexity = O(n)\nSpace Complexity = O(1) \n/* Bit Manipulation  using XOR\nn^n=0\n0^n=n\nso, 0^3^7^5^3^5 = 7\n\n``class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int n = nums.size();\n        int res =0;\n        for (int i=0;i<n;i++){\n            res=res^nums[i];\n        }\n        return res;\n    }\n};``\n"
                    },
                    {
                        "username": "natest77",
                        "content": "Go for  solving the problem using xor which gives 100% runtime,less code and easy to understand. Others solution may be there but solution using xor will be so intresting!!! . "
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Won\\'t be easy if You don\\'t know the concept of bitwise operator(XOR here)"
                    },
                    {
                        "username": "bravepoatotes",
                        "content": "Everytime I run the following code: \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            o = nums.count(i)\\n        for k in nums:\\n            if o<=0:\\n                return k\\n`\\nI get the following error\\n\\n TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 31 in _driver (Solution.py)\\n    _driver()\\nLine 38 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 29 in _driver (Solution.py)\\n\\nAnyone know why this is happening?"
                    },
                    {
                        "username": "ayush3105",
                        "content": "You can use property of XOR"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i\\n"
                    },
                    {
                        "username": "Snigdha_Reddy_Kathula",
                        "content": "It includes Arrays combines with Bit Manipulation. we can use XOR here,\\nTip: a^a=0\\n       a^0=a\\nby using this you can solve this easily, i think"
                    },
                    {
                        "username": "user9423V",
                        "content": "for i in set(nums):\\n            nums.remove(i)\\n            if i not in nums:\\n                return i\\n            else:\\n                nums.remove(i)\\n        return \"not found\""
                    },
                    {
                        "username": "clever_code",
                        "content": "Hello guys, can you find out the problem in my code\\n\\nimport java.util.Arrays;\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans = nums[0];\\n        for (int i = 0; i < n-1; i+=2){\\n            if (!(nums[i] == nums[i+1])){\\n                ans = nums[i];\\n                return nums[i];\\n            }\\n            else{\\n                ans = nums[n-1];\\n                return nums[n-1];\\n            }\\n        }\\n        return ans;\\n    }\\n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1764748,
                "content": [
                    {
                        "username": "skcoder007",
                        "content": "Time Complexity = O(n)\nSpace Complexity = O(1) \n/* Bit Manipulation  using XOR\nn^n=0\n0^n=n\nso, 0^3^7^5^3^5 = 7\n\n``class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int n = nums.size();\n        int res =0;\n        for (int i=0;i<n;i++){\n            res=res^nums[i];\n        }\n        return res;\n    }\n};``\n"
                    },
                    {
                        "username": "natest77",
                        "content": "Go for  solving the problem using xor which gives 100% runtime,less code and easy to understand. Others solution may be there but solution using xor will be so intresting!!! . "
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Won\\'t be easy if You don\\'t know the concept of bitwise operator(XOR here)"
                    },
                    {
                        "username": "bravepoatotes",
                        "content": "Everytime I run the following code: \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            o = nums.count(i)\\n        for k in nums:\\n            if o<=0:\\n                return k\\n`\\nI get the following error\\n\\n TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 31 in _driver (Solution.py)\\n    _driver()\\nLine 38 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 29 in _driver (Solution.py)\\n\\nAnyone know why this is happening?"
                    },
                    {
                        "username": "ayush3105",
                        "content": "You can use property of XOR"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i\\n"
                    },
                    {
                        "username": "Snigdha_Reddy_Kathula",
                        "content": "It includes Arrays combines with Bit Manipulation. we can use XOR here,\\nTip: a^a=0\\n       a^0=a\\nby using this you can solve this easily, i think"
                    },
                    {
                        "username": "user9423V",
                        "content": "for i in set(nums):\\n            nums.remove(i)\\n            if i not in nums:\\n                return i\\n            else:\\n                nums.remove(i)\\n        return \"not found\""
                    },
                    {
                        "username": "clever_code",
                        "content": "Hello guys, can you find out the problem in my code\\n\\nimport java.util.Arrays;\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans = nums[0];\\n        for (int i = 0; i < n-1; i+=2){\\n            if (!(nums[i] == nums[i+1])){\\n                ans = nums[i];\\n                return nums[i];\\n            }\\n            else{\\n                ans = nums[n-1];\\n                return nums[n-1];\\n            }\\n        }\\n        return ans;\\n    }\\n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1760643,
                "content": [
                    {
                        "username": "skcoder007",
                        "content": "Time Complexity = O(n)\nSpace Complexity = O(1) \n/* Bit Manipulation  using XOR\nn^n=0\n0^n=n\nso, 0^3^7^5^3^5 = 7\n\n``class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int n = nums.size();\n        int res =0;\n        for (int i=0;i<n;i++){\n            res=res^nums[i];\n        }\n        return res;\n    }\n};``\n"
                    },
                    {
                        "username": "natest77",
                        "content": "Go for  solving the problem using xor which gives 100% runtime,less code and easy to understand. Others solution may be there but solution using xor will be so intresting!!! . "
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Won\\'t be easy if You don\\'t know the concept of bitwise operator(XOR here)"
                    },
                    {
                        "username": "bravepoatotes",
                        "content": "Everytime I run the following code: \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            o = nums.count(i)\\n        for k in nums:\\n            if o<=0:\\n                return k\\n`\\nI get the following error\\n\\n TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 31 in _driver (Solution.py)\\n    _driver()\\nLine 38 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 29 in _driver (Solution.py)\\n\\nAnyone know why this is happening?"
                    },
                    {
                        "username": "ayush3105",
                        "content": "You can use property of XOR"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i\\n"
                    },
                    {
                        "username": "Snigdha_Reddy_Kathula",
                        "content": "It includes Arrays combines with Bit Manipulation. we can use XOR here,\\nTip: a^a=0\\n       a^0=a\\nby using this you can solve this easily, i think"
                    },
                    {
                        "username": "user9423V",
                        "content": "for i in set(nums):\\n            nums.remove(i)\\n            if i not in nums:\\n                return i\\n            else:\\n                nums.remove(i)\\n        return \"not found\""
                    },
                    {
                        "username": "clever_code",
                        "content": "Hello guys, can you find out the problem in my code\\n\\nimport java.util.Arrays;\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans = nums[0];\\n        for (int i = 0; i < n-1; i+=2){\\n            if (!(nums[i] == nums[i+1])){\\n                ans = nums[i];\\n                return nums[i];\\n            }\\n            else{\\n                ans = nums[n-1];\\n                return nums[n-1];\\n            }\\n        }\\n        return ans;\\n    }\\n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1758411,
                "content": [
                    {
                        "username": "skcoder007",
                        "content": "Time Complexity = O(n)\nSpace Complexity = O(1) \n/* Bit Manipulation  using XOR\nn^n=0\n0^n=n\nso, 0^3^7^5^3^5 = 7\n\n``class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int n = nums.size();\n        int res =0;\n        for (int i=0;i<n;i++){\n            res=res^nums[i];\n        }\n        return res;\n    }\n};``\n"
                    },
                    {
                        "username": "natest77",
                        "content": "Go for  solving the problem using xor which gives 100% runtime,less code and easy to understand. Others solution may be there but solution using xor will be so intresting!!! . "
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Won\\'t be easy if You don\\'t know the concept of bitwise operator(XOR here)"
                    },
                    {
                        "username": "bravepoatotes",
                        "content": "Everytime I run the following code: \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            o = nums.count(i)\\n        for k in nums:\\n            if o<=0:\\n                return k\\n`\\nI get the following error\\n\\n TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 31 in _driver (Solution.py)\\n    _driver()\\nLine 38 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 29 in _driver (Solution.py)\\n\\nAnyone know why this is happening?"
                    },
                    {
                        "username": "ayush3105",
                        "content": "You can use property of XOR"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i\\n"
                    },
                    {
                        "username": "Snigdha_Reddy_Kathula",
                        "content": "It includes Arrays combines with Bit Manipulation. we can use XOR here,\\nTip: a^a=0\\n       a^0=a\\nby using this you can solve this easily, i think"
                    },
                    {
                        "username": "user9423V",
                        "content": "for i in set(nums):\\n            nums.remove(i)\\n            if i not in nums:\\n                return i\\n            else:\\n                nums.remove(i)\\n        return \"not found\""
                    },
                    {
                        "username": "clever_code",
                        "content": "Hello guys, can you find out the problem in my code\\n\\nimport java.util.Arrays;\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans = nums[0];\\n        for (int i = 0; i < n-1; i+=2){\\n            if (!(nums[i] == nums[i+1])){\\n                ans = nums[i];\\n                return nums[i];\\n            }\\n            else{\\n                ans = nums[n-1];\\n                return nums[n-1];\\n            }\\n        }\\n        return ans;\\n    }\\n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1757341,
                "content": [
                    {
                        "username": "skcoder007",
                        "content": "Time Complexity = O(n)\nSpace Complexity = O(1) \n/* Bit Manipulation  using XOR\nn^n=0\n0^n=n\nso, 0^3^7^5^3^5 = 7\n\n``class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int n = nums.size();\n        int res =0;\n        for (int i=0;i<n;i++){\n            res=res^nums[i];\n        }\n        return res;\n    }\n};``\n"
                    },
                    {
                        "username": "natest77",
                        "content": "Go for  solving the problem using xor which gives 100% runtime,less code and easy to understand. Others solution may be there but solution using xor will be so intresting!!! . "
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Won\\'t be easy if You don\\'t know the concept of bitwise operator(XOR here)"
                    },
                    {
                        "username": "bravepoatotes",
                        "content": "Everytime I run the following code: \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            o = nums.count(i)\\n        for k in nums:\\n            if o<=0:\\n                return k\\n`\\nI get the following error\\n\\n TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 31 in _driver (Solution.py)\\n    _driver()\\nLine 38 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 29 in _driver (Solution.py)\\n\\nAnyone know why this is happening?"
                    },
                    {
                        "username": "ayush3105",
                        "content": "You can use property of XOR"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i\\n"
                    },
                    {
                        "username": "Snigdha_Reddy_Kathula",
                        "content": "It includes Arrays combines with Bit Manipulation. we can use XOR here,\\nTip: a^a=0\\n       a^0=a\\nby using this you can solve this easily, i think"
                    },
                    {
                        "username": "user9423V",
                        "content": "for i in set(nums):\\n            nums.remove(i)\\n            if i not in nums:\\n                return i\\n            else:\\n                nums.remove(i)\\n        return \"not found\""
                    },
                    {
                        "username": "clever_code",
                        "content": "Hello guys, can you find out the problem in my code\\n\\nimport java.util.Arrays;\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans = nums[0];\\n        for (int i = 0; i < n-1; i+=2){\\n            if (!(nums[i] == nums[i+1])){\\n                ans = nums[i];\\n                return nums[i];\\n            }\\n            else{\\n                ans = nums[n-1];\\n                return nums[n-1];\\n            }\\n        }\\n        return ans;\\n    }\\n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1756357,
                "content": [
                    {
                        "username": "skcoder007",
                        "content": "Time Complexity = O(n)\nSpace Complexity = O(1) \n/* Bit Manipulation  using XOR\nn^n=0\n0^n=n\nso, 0^3^7^5^3^5 = 7\n\n``class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int n = nums.size();\n        int res =0;\n        for (int i=0;i<n;i++){\n            res=res^nums[i];\n        }\n        return res;\n    }\n};``\n"
                    },
                    {
                        "username": "natest77",
                        "content": "Go for  solving the problem using xor which gives 100% runtime,less code and easy to understand. Others solution may be there but solution using xor will be so intresting!!! . "
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Won\\'t be easy if You don\\'t know the concept of bitwise operator(XOR here)"
                    },
                    {
                        "username": "bravepoatotes",
                        "content": "Everytime I run the following code: \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            o = nums.count(i)\\n        for k in nums:\\n            if o<=0:\\n                return k\\n`\\nI get the following error\\n\\n TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 31 in _driver (Solution.py)\\n    _driver()\\nLine 38 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 29 in _driver (Solution.py)\\n\\nAnyone know why this is happening?"
                    },
                    {
                        "username": "ayush3105",
                        "content": "You can use property of XOR"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i\\n"
                    },
                    {
                        "username": "Snigdha_Reddy_Kathula",
                        "content": "It includes Arrays combines with Bit Manipulation. we can use XOR here,\\nTip: a^a=0\\n       a^0=a\\nby using this you can solve this easily, i think"
                    },
                    {
                        "username": "user9423V",
                        "content": "for i in set(nums):\\n            nums.remove(i)\\n            if i not in nums:\\n                return i\\n            else:\\n                nums.remove(i)\\n        return \"not found\""
                    },
                    {
                        "username": "clever_code",
                        "content": "Hello guys, can you find out the problem in my code\\n\\nimport java.util.Arrays;\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans = nums[0];\\n        for (int i = 0; i < n-1; i+=2){\\n            if (!(nums[i] == nums[i+1])){\\n                ans = nums[i];\\n                return nums[i];\\n            }\\n            else{\\n                ans = nums[n-1];\\n                return nums[n-1];\\n            }\\n        }\\n        return ans;\\n    }\\n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1754996,
                "content": [
                    {
                        "username": "jamesschreiner03",
                        "content": "Using this code \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums.count(nums[i]) == 1:\\n                print(nums[i])\\n                break\\n            else:\\n                continue\\n`\\nThere a TypeError that only occurs while in the LeetCode IDE. In a local IDE the arrays output the correct answers.\\nThis is the error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 32 in _driver (Solution.py)\\n    _driver()\\nLine 39 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 30 in _driver (Solution.py)`"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "What if I use a HashMap and store all elements along with the frequency so that would take O(N) time and then for O(N) for finding the element in HashMap with frequency as 1\\nWorks in O(N).\\n"
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "wouldn\\'t be constant space, which was specified"
                    },
                    {
                        "username": "Pratham2000",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int single = nums[0];\\n        for(int i =0;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                i=+1;              \\n            }\\n            else if(nums[i]!=nums[i+1]){\\n                single = nums[i];\\n            }\\n        }\\n        return single;\\n        \\n    }\\n}\\n\\nIs my solution right? If there is no Time Limit."
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "sort is N log N not linear time"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            ans=ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n//SC: O(1), TC:O(1)"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        HashSet<Integer> set=new HashSet<>();\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(set.contains(nums[i])){\\n                set.remove(nums[i]);\\n            }else{\\n                set.add(nums[i]);\\n            }\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n//TC: O(n) SC: O(n)"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/125_valid_pallindrome.cpp"
                    },
                    {
                        "username": "tppatil910",
                        "content": "// Easy Solution in java\\n  int unique = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            unique ^= nums[i];\\n        }   \\n        return unique;"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "God bless JavaScript\\'s objects!"
                    },
                    {
                        "username": "RANJANSINGH9900",
                        "content": "int n=(int)nums.size();\\n        int a=0;\\n        for(int i=0;i<n;i++){\\n            a^=nums[i];\\n        }\\n        return a;"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for (int n : nums) {\\n            res ^= n;\\n        }\\n        return res;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1746239,
                "content": [
                    {
                        "username": "jamesschreiner03",
                        "content": "Using this code \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums.count(nums[i]) == 1:\\n                print(nums[i])\\n                break\\n            else:\\n                continue\\n`\\nThere a TypeError that only occurs while in the LeetCode IDE. In a local IDE the arrays output the correct answers.\\nThis is the error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 32 in _driver (Solution.py)\\n    _driver()\\nLine 39 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 30 in _driver (Solution.py)`"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "What if I use a HashMap and store all elements along with the frequency so that would take O(N) time and then for O(N) for finding the element in HashMap with frequency as 1\\nWorks in O(N).\\n"
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "wouldn\\'t be constant space, which was specified"
                    },
                    {
                        "username": "Pratham2000",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int single = nums[0];\\n        for(int i =0;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                i=+1;              \\n            }\\n            else if(nums[i]!=nums[i+1]){\\n                single = nums[i];\\n            }\\n        }\\n        return single;\\n        \\n    }\\n}\\n\\nIs my solution right? If there is no Time Limit."
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "sort is N log N not linear time"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            ans=ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n//SC: O(1), TC:O(1)"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        HashSet<Integer> set=new HashSet<>();\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(set.contains(nums[i])){\\n                set.remove(nums[i]);\\n            }else{\\n                set.add(nums[i]);\\n            }\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n//TC: O(n) SC: O(n)"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/125_valid_pallindrome.cpp"
                    },
                    {
                        "username": "tppatil910",
                        "content": "// Easy Solution in java\\n  int unique = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            unique ^= nums[i];\\n        }   \\n        return unique;"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "God bless JavaScript\\'s objects!"
                    },
                    {
                        "username": "RANJANSINGH9900",
                        "content": "int n=(int)nums.size();\\n        int a=0;\\n        for(int i=0;i<n;i++){\\n            a^=nums[i];\\n        }\\n        return a;"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for (int n : nums) {\\n            res ^= n;\\n        }\\n        return res;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1739414,
                "content": [
                    {
                        "username": "jamesschreiner03",
                        "content": "Using this code \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums.count(nums[i]) == 1:\\n                print(nums[i])\\n                break\\n            else:\\n                continue\\n`\\nThere a TypeError that only occurs while in the LeetCode IDE. In a local IDE the arrays output the correct answers.\\nThis is the error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 32 in _driver (Solution.py)\\n    _driver()\\nLine 39 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 30 in _driver (Solution.py)`"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "What if I use a HashMap and store all elements along with the frequency so that would take O(N) time and then for O(N) for finding the element in HashMap with frequency as 1\\nWorks in O(N).\\n"
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "wouldn\\'t be constant space, which was specified"
                    },
                    {
                        "username": "Pratham2000",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int single = nums[0];\\n        for(int i =0;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                i=+1;              \\n            }\\n            else if(nums[i]!=nums[i+1]){\\n                single = nums[i];\\n            }\\n        }\\n        return single;\\n        \\n    }\\n}\\n\\nIs my solution right? If there is no Time Limit."
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "sort is N log N not linear time"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            ans=ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n//SC: O(1), TC:O(1)"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        HashSet<Integer> set=new HashSet<>();\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(set.contains(nums[i])){\\n                set.remove(nums[i]);\\n            }else{\\n                set.add(nums[i]);\\n            }\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n//TC: O(n) SC: O(n)"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/125_valid_pallindrome.cpp"
                    },
                    {
                        "username": "tppatil910",
                        "content": "// Easy Solution in java\\n  int unique = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            unique ^= nums[i];\\n        }   \\n        return unique;"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "God bless JavaScript\\'s objects!"
                    },
                    {
                        "username": "RANJANSINGH9900",
                        "content": "int n=(int)nums.size();\\n        int a=0;\\n        for(int i=0;i<n;i++){\\n            a^=nums[i];\\n        }\\n        return a;"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for (int n : nums) {\\n            res ^= n;\\n        }\\n        return res;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1736284,
                "content": [
                    {
                        "username": "jamesschreiner03",
                        "content": "Using this code \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums.count(nums[i]) == 1:\\n                print(nums[i])\\n                break\\n            else:\\n                continue\\n`\\nThere a TypeError that only occurs while in the LeetCode IDE. In a local IDE the arrays output the correct answers.\\nThis is the error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 32 in _driver (Solution.py)\\n    _driver()\\nLine 39 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 30 in _driver (Solution.py)`"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "What if I use a HashMap and store all elements along with the frequency so that would take O(N) time and then for O(N) for finding the element in HashMap with frequency as 1\\nWorks in O(N).\\n"
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "wouldn\\'t be constant space, which was specified"
                    },
                    {
                        "username": "Pratham2000",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int single = nums[0];\\n        for(int i =0;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                i=+1;              \\n            }\\n            else if(nums[i]!=nums[i+1]){\\n                single = nums[i];\\n            }\\n        }\\n        return single;\\n        \\n    }\\n}\\n\\nIs my solution right? If there is no Time Limit."
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "sort is N log N not linear time"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            ans=ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n//SC: O(1), TC:O(1)"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        HashSet<Integer> set=new HashSet<>();\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(set.contains(nums[i])){\\n                set.remove(nums[i]);\\n            }else{\\n                set.add(nums[i]);\\n            }\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n//TC: O(n) SC: O(n)"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/125_valid_pallindrome.cpp"
                    },
                    {
                        "username": "tppatil910",
                        "content": "// Easy Solution in java\\n  int unique = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            unique ^= nums[i];\\n        }   \\n        return unique;"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "God bless JavaScript\\'s objects!"
                    },
                    {
                        "username": "RANJANSINGH9900",
                        "content": "int n=(int)nums.size();\\n        int a=0;\\n        for(int i=0;i<n;i++){\\n            a^=nums[i];\\n        }\\n        return a;"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for (int n : nums) {\\n            res ^= n;\\n        }\\n        return res;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1736277,
                "content": [
                    {
                        "username": "jamesschreiner03",
                        "content": "Using this code \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums.count(nums[i]) == 1:\\n                print(nums[i])\\n                break\\n            else:\\n                continue\\n`\\nThere a TypeError that only occurs while in the LeetCode IDE. In a local IDE the arrays output the correct answers.\\nThis is the error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 32 in _driver (Solution.py)\\n    _driver()\\nLine 39 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 30 in _driver (Solution.py)`"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "What if I use a HashMap and store all elements along with the frequency so that would take O(N) time and then for O(N) for finding the element in HashMap with frequency as 1\\nWorks in O(N).\\n"
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "wouldn\\'t be constant space, which was specified"
                    },
                    {
                        "username": "Pratham2000",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int single = nums[0];\\n        for(int i =0;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                i=+1;              \\n            }\\n            else if(nums[i]!=nums[i+1]){\\n                single = nums[i];\\n            }\\n        }\\n        return single;\\n        \\n    }\\n}\\n\\nIs my solution right? If there is no Time Limit."
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "sort is N log N not linear time"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            ans=ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n//SC: O(1), TC:O(1)"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        HashSet<Integer> set=new HashSet<>();\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(set.contains(nums[i])){\\n                set.remove(nums[i]);\\n            }else{\\n                set.add(nums[i]);\\n            }\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n//TC: O(n) SC: O(n)"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/125_valid_pallindrome.cpp"
                    },
                    {
                        "username": "tppatil910",
                        "content": "// Easy Solution in java\\n  int unique = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            unique ^= nums[i];\\n        }   \\n        return unique;"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "God bless JavaScript\\'s objects!"
                    },
                    {
                        "username": "RANJANSINGH9900",
                        "content": "int n=(int)nums.size();\\n        int a=0;\\n        for(int i=0;i<n;i++){\\n            a^=nums[i];\\n        }\\n        return a;"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for (int n : nums) {\\n            res ^= n;\\n        }\\n        return res;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1728891,
                "content": [
                    {
                        "username": "jamesschreiner03",
                        "content": "Using this code \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums.count(nums[i]) == 1:\\n                print(nums[i])\\n                break\\n            else:\\n                continue\\n`\\nThere a TypeError that only occurs while in the LeetCode IDE. In a local IDE the arrays output the correct answers.\\nThis is the error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 32 in _driver (Solution.py)\\n    _driver()\\nLine 39 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 30 in _driver (Solution.py)`"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "What if I use a HashMap and store all elements along with the frequency so that would take O(N) time and then for O(N) for finding the element in HashMap with frequency as 1\\nWorks in O(N).\\n"
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "wouldn\\'t be constant space, which was specified"
                    },
                    {
                        "username": "Pratham2000",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int single = nums[0];\\n        for(int i =0;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                i=+1;              \\n            }\\n            else if(nums[i]!=nums[i+1]){\\n                single = nums[i];\\n            }\\n        }\\n        return single;\\n        \\n    }\\n}\\n\\nIs my solution right? If there is no Time Limit."
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "sort is N log N not linear time"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            ans=ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n//SC: O(1), TC:O(1)"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        HashSet<Integer> set=new HashSet<>();\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(set.contains(nums[i])){\\n                set.remove(nums[i]);\\n            }else{\\n                set.add(nums[i]);\\n            }\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n//TC: O(n) SC: O(n)"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/125_valid_pallindrome.cpp"
                    },
                    {
                        "username": "tppatil910",
                        "content": "// Easy Solution in java\\n  int unique = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            unique ^= nums[i];\\n        }   \\n        return unique;"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "God bless JavaScript\\'s objects!"
                    },
                    {
                        "username": "RANJANSINGH9900",
                        "content": "int n=(int)nums.size();\\n        int a=0;\\n        for(int i=0;i<n;i++){\\n            a^=nums[i];\\n        }\\n        return a;"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for (int n : nums) {\\n            res ^= n;\\n        }\\n        return res;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1727538,
                "content": [
                    {
                        "username": "jamesschreiner03",
                        "content": "Using this code \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums.count(nums[i]) == 1:\\n                print(nums[i])\\n                break\\n            else:\\n                continue\\n`\\nThere a TypeError that only occurs while in the LeetCode IDE. In a local IDE the arrays output the correct answers.\\nThis is the error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 32 in _driver (Solution.py)\\n    _driver()\\nLine 39 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 30 in _driver (Solution.py)`"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "What if I use a HashMap and store all elements along with the frequency so that would take O(N) time and then for O(N) for finding the element in HashMap with frequency as 1\\nWorks in O(N).\\n"
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "wouldn\\'t be constant space, which was specified"
                    },
                    {
                        "username": "Pratham2000",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int single = nums[0];\\n        for(int i =0;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                i=+1;              \\n            }\\n            else if(nums[i]!=nums[i+1]){\\n                single = nums[i];\\n            }\\n        }\\n        return single;\\n        \\n    }\\n}\\n\\nIs my solution right? If there is no Time Limit."
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "sort is N log N not linear time"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            ans=ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n//SC: O(1), TC:O(1)"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        HashSet<Integer> set=new HashSet<>();\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(set.contains(nums[i])){\\n                set.remove(nums[i]);\\n            }else{\\n                set.add(nums[i]);\\n            }\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n//TC: O(n) SC: O(n)"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/125_valid_pallindrome.cpp"
                    },
                    {
                        "username": "tppatil910",
                        "content": "// Easy Solution in java\\n  int unique = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            unique ^= nums[i];\\n        }   \\n        return unique;"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "God bless JavaScript\\'s objects!"
                    },
                    {
                        "username": "RANJANSINGH9900",
                        "content": "int n=(int)nums.size();\\n        int a=0;\\n        for(int i=0;i<n;i++){\\n            a^=nums[i];\\n        }\\n        return a;"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for (int n : nums) {\\n            res ^= n;\\n        }\\n        return res;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1726490,
                "content": [
                    {
                        "username": "jamesschreiner03",
                        "content": "Using this code \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums.count(nums[i]) == 1:\\n                print(nums[i])\\n                break\\n            else:\\n                continue\\n`\\nThere a TypeError that only occurs while in the LeetCode IDE. In a local IDE the arrays output the correct answers.\\nThis is the error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 32 in _driver (Solution.py)\\n    _driver()\\nLine 39 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 30 in _driver (Solution.py)`"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "What if I use a HashMap and store all elements along with the frequency so that would take O(N) time and then for O(N) for finding the element in HashMap with frequency as 1\\nWorks in O(N).\\n"
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "wouldn\\'t be constant space, which was specified"
                    },
                    {
                        "username": "Pratham2000",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int single = nums[0];\\n        for(int i =0;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                i=+1;              \\n            }\\n            else if(nums[i]!=nums[i+1]){\\n                single = nums[i];\\n            }\\n        }\\n        return single;\\n        \\n    }\\n}\\n\\nIs my solution right? If there is no Time Limit."
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "sort is N log N not linear time"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            ans=ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n//SC: O(1), TC:O(1)"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        HashSet<Integer> set=new HashSet<>();\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(set.contains(nums[i])){\\n                set.remove(nums[i]);\\n            }else{\\n                set.add(nums[i]);\\n            }\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n//TC: O(n) SC: O(n)"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/125_valid_pallindrome.cpp"
                    },
                    {
                        "username": "tppatil910",
                        "content": "// Easy Solution in java\\n  int unique = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            unique ^= nums[i];\\n        }   \\n        return unique;"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "God bless JavaScript\\'s objects!"
                    },
                    {
                        "username": "RANJANSINGH9900",
                        "content": "int n=(int)nums.size();\\n        int a=0;\\n        for(int i=0;i<n;i++){\\n            a^=nums[i];\\n        }\\n        return a;"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for (int n : nums) {\\n            res ^= n;\\n        }\\n        return res;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1726224,
                "content": [
                    {
                        "username": "jamesschreiner03",
                        "content": "Using this code \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums.count(nums[i]) == 1:\\n                print(nums[i])\\n                break\\n            else:\\n                continue\\n`\\nThere a TypeError that only occurs while in the LeetCode IDE. In a local IDE the arrays output the correct answers.\\nThis is the error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 32 in _driver (Solution.py)\\n    _driver()\\nLine 39 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 30 in _driver (Solution.py)`"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "What if I use a HashMap and store all elements along with the frequency so that would take O(N) time and then for O(N) for finding the element in HashMap with frequency as 1\\nWorks in O(N).\\n"
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "wouldn\\'t be constant space, which was specified"
                    },
                    {
                        "username": "Pratham2000",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int single = nums[0];\\n        for(int i =0;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                i=+1;              \\n            }\\n            else if(nums[i]!=nums[i+1]){\\n                single = nums[i];\\n            }\\n        }\\n        return single;\\n        \\n    }\\n}\\n\\nIs my solution right? If there is no Time Limit."
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "sort is N log N not linear time"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            ans=ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n//SC: O(1), TC:O(1)"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        HashSet<Integer> set=new HashSet<>();\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(set.contains(nums[i])){\\n                set.remove(nums[i]);\\n            }else{\\n                set.add(nums[i]);\\n            }\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n//TC: O(n) SC: O(n)"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/125_valid_pallindrome.cpp"
                    },
                    {
                        "username": "tppatil910",
                        "content": "// Easy Solution in java\\n  int unique = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            unique ^= nums[i];\\n        }   \\n        return unique;"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "God bless JavaScript\\'s objects!"
                    },
                    {
                        "username": "RANJANSINGH9900",
                        "content": "int n=(int)nums.size();\\n        int a=0;\\n        for(int i=0;i<n;i++){\\n            a^=nums[i];\\n        }\\n        return a;"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for (int n : nums) {\\n            res ^= n;\\n        }\\n        return res;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1724071,
                "content": [
                    {
                        "username": "jamesschreiner03",
                        "content": "Using this code \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums.count(nums[i]) == 1:\\n                print(nums[i])\\n                break\\n            else:\\n                continue\\n`\\nThere a TypeError that only occurs while in the LeetCode IDE. In a local IDE the arrays output the correct answers.\\nThis is the error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 32 in _driver (Solution.py)\\n    _driver()\\nLine 39 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 30 in _driver (Solution.py)`"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "What if I use a HashMap and store all elements along with the frequency so that would take O(N) time and then for O(N) for finding the element in HashMap with frequency as 1\\nWorks in O(N).\\n"
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "wouldn\\'t be constant space, which was specified"
                    },
                    {
                        "username": "Pratham2000",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int single = nums[0];\\n        for(int i =0;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                i=+1;              \\n            }\\n            else if(nums[i]!=nums[i+1]){\\n                single = nums[i];\\n            }\\n        }\\n        return single;\\n        \\n    }\\n}\\n\\nIs my solution right? If there is no Time Limit."
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "sort is N log N not linear time"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            ans=ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n//SC: O(1), TC:O(1)"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        HashSet<Integer> set=new HashSet<>();\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(set.contains(nums[i])){\\n                set.remove(nums[i]);\\n            }else{\\n                set.add(nums[i]);\\n            }\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n//TC: O(n) SC: O(n)"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/125_valid_pallindrome.cpp"
                    },
                    {
                        "username": "tppatil910",
                        "content": "// Easy Solution in java\\n  int unique = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            unique ^= nums[i];\\n        }   \\n        return unique;"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "God bless JavaScript\\'s objects!"
                    },
                    {
                        "username": "RANJANSINGH9900",
                        "content": "int n=(int)nums.size();\\n        int a=0;\\n        for(int i=0;i<n;i++){\\n            a^=nums[i];\\n        }\\n        return a;"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for (int n : nums) {\\n            res ^= n;\\n        }\\n        return res;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1723961,
                "content": [
                    {
                        "username": "thanyaniinnocent20",
                        "content": "I\\'ve a question : I used a hash Map to count every number from array using a for loop, which I believe it\\'s O(n). Then I loop through dict keys when I find a value which a value is 1, I returned the key. It\\'s also O(n) thus O(2n) which is equivalent to O(n). Is this solution fine or maybe I\\'m wrong with my BigO? "
                    },
                    {
                        "username": "_hopa_",
                        "content": "hello guys, how to solve this problem by Map stls in Cpp"
                    },
                    {
                        "username": "user2891YF",
                        "content": "You can use a set. Go through the numbers, if the number is already in the set, remove it, otherwise add it. At the end of the loop, you\\'ll have exactly one number left in your set so you can just return the front iterator."
                    },
                    {
                        "username": "ak_r_a_m_7",
                        "content": "XOR approach is well efficient"
                    },
                    {
                        "username": "shank9931",
                        "content": "I am going to ask a very newbie question here, please bear with me.\n\nQuestion1: Why did my code not work ?\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n       int ans;\n       sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               ans=nums[i-1];\n               break;\n                  }\n           else{\n              ans=nums[nums.size()-1];\n                 }\n       }\n       return ans;\n    }\n};\n```\nas opposed to this\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ans;\n        sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               return nums[i-1];\n           }\n       }\n       return nums[nums.size()-1];\n    }\n};\n```\n\nPlease do not be harsh to the noob.\n\nQuestion 2: \nTestcase 3: nums=[1]\n\nhow nums[1]!=nums[0] is compared as there are no elements for nums[1]? Or why isn't there an error?"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "SIMPLE 3LINE CODE EASY TO UNDERSTAND\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n      int a=0;\\n      for(int i =0; i<nums.size();i++)\\n      {\\n          a = a^nums[i];\\n      }\\n      return a;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "shank9931",
                        "content": "nice work vansh. \\nCould you checkout my question above and help me with it?"
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t    return reduce(lambda total, el: total ^ el, nums)"
                    },
                    {
                        "username": "hawkeye1806",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       unordered_map<int,int> a;\\n\\t   for(auto x: nums)\\n\\t\\t   a[x]++;\\n\\t   for(auto z:a)\\n\\t\\t   if(z.second==1)\\n\\t\\t\\t   return z.first;\\n\\t   return -1;\\n    }\\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "shank9931",
                        "content": "Hey Aditya could you help me with my question posted here? Thanks in advance."
                    },
                    {
                        "username": "mascomen4",
                        "content": "They key idea I think is that you try to apply XOR to more than two operands..."
                    },
                    {
                        "username": "harishkhope89",
                        "content": "easy approach | hashmap implementation| faster than 60%  of submissions\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        unordered_map<int, int >mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto i: mp){\\n            if (i.second==1){\\n                return i.first;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}; \\n```"
                    }
                ]
            },
            {
                "id": 1715611,
                "content": [
                    {
                        "username": "thanyaniinnocent20",
                        "content": "I\\'ve a question : I used a hash Map to count every number from array using a for loop, which I believe it\\'s O(n). Then I loop through dict keys when I find a value which a value is 1, I returned the key. It\\'s also O(n) thus O(2n) which is equivalent to O(n). Is this solution fine or maybe I\\'m wrong with my BigO? "
                    },
                    {
                        "username": "_hopa_",
                        "content": "hello guys, how to solve this problem by Map stls in Cpp"
                    },
                    {
                        "username": "user2891YF",
                        "content": "You can use a set. Go through the numbers, if the number is already in the set, remove it, otherwise add it. At the end of the loop, you\\'ll have exactly one number left in your set so you can just return the front iterator."
                    },
                    {
                        "username": "ak_r_a_m_7",
                        "content": "XOR approach is well efficient"
                    },
                    {
                        "username": "shank9931",
                        "content": "I am going to ask a very newbie question here, please bear with me.\n\nQuestion1: Why did my code not work ?\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n       int ans;\n       sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               ans=nums[i-1];\n               break;\n                  }\n           else{\n              ans=nums[nums.size()-1];\n                 }\n       }\n       return ans;\n    }\n};\n```\nas opposed to this\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ans;\n        sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               return nums[i-1];\n           }\n       }\n       return nums[nums.size()-1];\n    }\n};\n```\n\nPlease do not be harsh to the noob.\n\nQuestion 2: \nTestcase 3: nums=[1]\n\nhow nums[1]!=nums[0] is compared as there are no elements for nums[1]? Or why isn't there an error?"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "SIMPLE 3LINE CODE EASY TO UNDERSTAND\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n      int a=0;\\n      for(int i =0; i<nums.size();i++)\\n      {\\n          a = a^nums[i];\\n      }\\n      return a;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "shank9931",
                        "content": "nice work vansh. \\nCould you checkout my question above and help me with it?"
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t    return reduce(lambda total, el: total ^ el, nums)"
                    },
                    {
                        "username": "hawkeye1806",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       unordered_map<int,int> a;\\n\\t   for(auto x: nums)\\n\\t\\t   a[x]++;\\n\\t   for(auto z:a)\\n\\t\\t   if(z.second==1)\\n\\t\\t\\t   return z.first;\\n\\t   return -1;\\n    }\\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "shank9931",
                        "content": "Hey Aditya could you help me with my question posted here? Thanks in advance."
                    },
                    {
                        "username": "mascomen4",
                        "content": "They key idea I think is that you try to apply XOR to more than two operands..."
                    },
                    {
                        "username": "harishkhope89",
                        "content": "easy approach | hashmap implementation| faster than 60%  of submissions\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        unordered_map<int, int >mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto i: mp){\\n            if (i.second==1){\\n                return i.first;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}; \\n```"
                    }
                ]
            },
            {
                "id": 1711607,
                "content": [
                    {
                        "username": "thanyaniinnocent20",
                        "content": "I\\'ve a question : I used a hash Map to count every number from array using a for loop, which I believe it\\'s O(n). Then I loop through dict keys when I find a value which a value is 1, I returned the key. It\\'s also O(n) thus O(2n) which is equivalent to O(n). Is this solution fine or maybe I\\'m wrong with my BigO? "
                    },
                    {
                        "username": "_hopa_",
                        "content": "hello guys, how to solve this problem by Map stls in Cpp"
                    },
                    {
                        "username": "user2891YF",
                        "content": "You can use a set. Go through the numbers, if the number is already in the set, remove it, otherwise add it. At the end of the loop, you\\'ll have exactly one number left in your set so you can just return the front iterator."
                    },
                    {
                        "username": "ak_r_a_m_7",
                        "content": "XOR approach is well efficient"
                    },
                    {
                        "username": "shank9931",
                        "content": "I am going to ask a very newbie question here, please bear with me.\n\nQuestion1: Why did my code not work ?\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n       int ans;\n       sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               ans=nums[i-1];\n               break;\n                  }\n           else{\n              ans=nums[nums.size()-1];\n                 }\n       }\n       return ans;\n    }\n};\n```\nas opposed to this\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ans;\n        sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               return nums[i-1];\n           }\n       }\n       return nums[nums.size()-1];\n    }\n};\n```\n\nPlease do not be harsh to the noob.\n\nQuestion 2: \nTestcase 3: nums=[1]\n\nhow nums[1]!=nums[0] is compared as there are no elements for nums[1]? Or why isn't there an error?"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "SIMPLE 3LINE CODE EASY TO UNDERSTAND\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n      int a=0;\\n      for(int i =0; i<nums.size();i++)\\n      {\\n          a = a^nums[i];\\n      }\\n      return a;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "shank9931",
                        "content": "nice work vansh. \\nCould you checkout my question above and help me with it?"
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t    return reduce(lambda total, el: total ^ el, nums)"
                    },
                    {
                        "username": "hawkeye1806",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       unordered_map<int,int> a;\\n\\t   for(auto x: nums)\\n\\t\\t   a[x]++;\\n\\t   for(auto z:a)\\n\\t\\t   if(z.second==1)\\n\\t\\t\\t   return z.first;\\n\\t   return -1;\\n    }\\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "shank9931",
                        "content": "Hey Aditya could you help me with my question posted here? Thanks in advance."
                    },
                    {
                        "username": "mascomen4",
                        "content": "They key idea I think is that you try to apply XOR to more than two operands..."
                    },
                    {
                        "username": "harishkhope89",
                        "content": "easy approach | hashmap implementation| faster than 60%  of submissions\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        unordered_map<int, int >mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto i: mp){\\n            if (i.second==1){\\n                return i.first;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}; \\n```"
                    }
                ]
            },
            {
                "id": 1710369,
                "content": [
                    {
                        "username": "thanyaniinnocent20",
                        "content": "I\\'ve a question : I used a hash Map to count every number from array using a for loop, which I believe it\\'s O(n). Then I loop through dict keys when I find a value which a value is 1, I returned the key. It\\'s also O(n) thus O(2n) which is equivalent to O(n). Is this solution fine or maybe I\\'m wrong with my BigO? "
                    },
                    {
                        "username": "_hopa_",
                        "content": "hello guys, how to solve this problem by Map stls in Cpp"
                    },
                    {
                        "username": "user2891YF",
                        "content": "You can use a set. Go through the numbers, if the number is already in the set, remove it, otherwise add it. At the end of the loop, you\\'ll have exactly one number left in your set so you can just return the front iterator."
                    },
                    {
                        "username": "ak_r_a_m_7",
                        "content": "XOR approach is well efficient"
                    },
                    {
                        "username": "shank9931",
                        "content": "I am going to ask a very newbie question here, please bear with me.\n\nQuestion1: Why did my code not work ?\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n       int ans;\n       sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               ans=nums[i-1];\n               break;\n                  }\n           else{\n              ans=nums[nums.size()-1];\n                 }\n       }\n       return ans;\n    }\n};\n```\nas opposed to this\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ans;\n        sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               return nums[i-1];\n           }\n       }\n       return nums[nums.size()-1];\n    }\n};\n```\n\nPlease do not be harsh to the noob.\n\nQuestion 2: \nTestcase 3: nums=[1]\n\nhow nums[1]!=nums[0] is compared as there are no elements for nums[1]? Or why isn't there an error?"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "SIMPLE 3LINE CODE EASY TO UNDERSTAND\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n      int a=0;\\n      for(int i =0; i<nums.size();i++)\\n      {\\n          a = a^nums[i];\\n      }\\n      return a;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "shank9931",
                        "content": "nice work vansh. \\nCould you checkout my question above and help me with it?"
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t    return reduce(lambda total, el: total ^ el, nums)"
                    },
                    {
                        "username": "hawkeye1806",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       unordered_map<int,int> a;\\n\\t   for(auto x: nums)\\n\\t\\t   a[x]++;\\n\\t   for(auto z:a)\\n\\t\\t   if(z.second==1)\\n\\t\\t\\t   return z.first;\\n\\t   return -1;\\n    }\\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "shank9931",
                        "content": "Hey Aditya could you help me with my question posted here? Thanks in advance."
                    },
                    {
                        "username": "mascomen4",
                        "content": "They key idea I think is that you try to apply XOR to more than two operands..."
                    },
                    {
                        "username": "harishkhope89",
                        "content": "easy approach | hashmap implementation| faster than 60%  of submissions\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        unordered_map<int, int >mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto i: mp){\\n            if (i.second==1){\\n                return i.first;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}; \\n```"
                    }
                ]
            },
            {
                "id": 1708943,
                "content": [
                    {
                        "username": "thanyaniinnocent20",
                        "content": "I\\'ve a question : I used a hash Map to count every number from array using a for loop, which I believe it\\'s O(n). Then I loop through dict keys when I find a value which a value is 1, I returned the key. It\\'s also O(n) thus O(2n) which is equivalent to O(n). Is this solution fine or maybe I\\'m wrong with my BigO? "
                    },
                    {
                        "username": "_hopa_",
                        "content": "hello guys, how to solve this problem by Map stls in Cpp"
                    },
                    {
                        "username": "user2891YF",
                        "content": "You can use a set. Go through the numbers, if the number is already in the set, remove it, otherwise add it. At the end of the loop, you\\'ll have exactly one number left in your set so you can just return the front iterator."
                    },
                    {
                        "username": "ak_r_a_m_7",
                        "content": "XOR approach is well efficient"
                    },
                    {
                        "username": "shank9931",
                        "content": "I am going to ask a very newbie question here, please bear with me.\n\nQuestion1: Why did my code not work ?\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n       int ans;\n       sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               ans=nums[i-1];\n               break;\n                  }\n           else{\n              ans=nums[nums.size()-1];\n                 }\n       }\n       return ans;\n    }\n};\n```\nas opposed to this\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ans;\n        sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               return nums[i-1];\n           }\n       }\n       return nums[nums.size()-1];\n    }\n};\n```\n\nPlease do not be harsh to the noob.\n\nQuestion 2: \nTestcase 3: nums=[1]\n\nhow nums[1]!=nums[0] is compared as there are no elements for nums[1]? Or why isn't there an error?"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "SIMPLE 3LINE CODE EASY TO UNDERSTAND\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n      int a=0;\\n      for(int i =0; i<nums.size();i++)\\n      {\\n          a = a^nums[i];\\n      }\\n      return a;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "shank9931",
                        "content": "nice work vansh. \\nCould you checkout my question above and help me with it?"
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t    return reduce(lambda total, el: total ^ el, nums)"
                    },
                    {
                        "username": "hawkeye1806",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       unordered_map<int,int> a;\\n\\t   for(auto x: nums)\\n\\t\\t   a[x]++;\\n\\t   for(auto z:a)\\n\\t\\t   if(z.second==1)\\n\\t\\t\\t   return z.first;\\n\\t   return -1;\\n    }\\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "shank9931",
                        "content": "Hey Aditya could you help me with my question posted here? Thanks in advance."
                    },
                    {
                        "username": "mascomen4",
                        "content": "They key idea I think is that you try to apply XOR to more than two operands..."
                    },
                    {
                        "username": "harishkhope89",
                        "content": "easy approach | hashmap implementation| faster than 60%  of submissions\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        unordered_map<int, int >mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto i: mp){\\n            if (i.second==1){\\n                return i.first;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}; \\n```"
                    }
                ]
            },
            {
                "id": 1706927,
                "content": [
                    {
                        "username": "thanyaniinnocent20",
                        "content": "I\\'ve a question : I used a hash Map to count every number from array using a for loop, which I believe it\\'s O(n). Then I loop through dict keys when I find a value which a value is 1, I returned the key. It\\'s also O(n) thus O(2n) which is equivalent to O(n). Is this solution fine or maybe I\\'m wrong with my BigO? "
                    },
                    {
                        "username": "_hopa_",
                        "content": "hello guys, how to solve this problem by Map stls in Cpp"
                    },
                    {
                        "username": "user2891YF",
                        "content": "You can use a set. Go through the numbers, if the number is already in the set, remove it, otherwise add it. At the end of the loop, you\\'ll have exactly one number left in your set so you can just return the front iterator."
                    },
                    {
                        "username": "ak_r_a_m_7",
                        "content": "XOR approach is well efficient"
                    },
                    {
                        "username": "shank9931",
                        "content": "I am going to ask a very newbie question here, please bear with me.\n\nQuestion1: Why did my code not work ?\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n       int ans;\n       sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               ans=nums[i-1];\n               break;\n                  }\n           else{\n              ans=nums[nums.size()-1];\n                 }\n       }\n       return ans;\n    }\n};\n```\nas opposed to this\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ans;\n        sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               return nums[i-1];\n           }\n       }\n       return nums[nums.size()-1];\n    }\n};\n```\n\nPlease do not be harsh to the noob.\n\nQuestion 2: \nTestcase 3: nums=[1]\n\nhow nums[1]!=nums[0] is compared as there are no elements for nums[1]? Or why isn't there an error?"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "SIMPLE 3LINE CODE EASY TO UNDERSTAND\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n      int a=0;\\n      for(int i =0; i<nums.size();i++)\\n      {\\n          a = a^nums[i];\\n      }\\n      return a;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "shank9931",
                        "content": "nice work vansh. \\nCould you checkout my question above and help me with it?"
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t    return reduce(lambda total, el: total ^ el, nums)"
                    },
                    {
                        "username": "hawkeye1806",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       unordered_map<int,int> a;\\n\\t   for(auto x: nums)\\n\\t\\t   a[x]++;\\n\\t   for(auto z:a)\\n\\t\\t   if(z.second==1)\\n\\t\\t\\t   return z.first;\\n\\t   return -1;\\n    }\\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "shank9931",
                        "content": "Hey Aditya could you help me with my question posted here? Thanks in advance."
                    },
                    {
                        "username": "mascomen4",
                        "content": "They key idea I think is that you try to apply XOR to more than two operands..."
                    },
                    {
                        "username": "harishkhope89",
                        "content": "easy approach | hashmap implementation| faster than 60%  of submissions\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        unordered_map<int, int >mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto i: mp){\\n            if (i.second==1){\\n                return i.first;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}; \\n```"
                    }
                ]
            },
            {
                "id": 1684179,
                "content": [
                    {
                        "username": "thanyaniinnocent20",
                        "content": "I\\'ve a question : I used a hash Map to count every number from array using a for loop, which I believe it\\'s O(n). Then I loop through dict keys when I find a value which a value is 1, I returned the key. It\\'s also O(n) thus O(2n) which is equivalent to O(n). Is this solution fine or maybe I\\'m wrong with my BigO? "
                    },
                    {
                        "username": "_hopa_",
                        "content": "hello guys, how to solve this problem by Map stls in Cpp"
                    },
                    {
                        "username": "user2891YF",
                        "content": "You can use a set. Go through the numbers, if the number is already in the set, remove it, otherwise add it. At the end of the loop, you\\'ll have exactly one number left in your set so you can just return the front iterator."
                    },
                    {
                        "username": "ak_r_a_m_7",
                        "content": "XOR approach is well efficient"
                    },
                    {
                        "username": "shank9931",
                        "content": "I am going to ask a very newbie question here, please bear with me.\n\nQuestion1: Why did my code not work ?\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n       int ans;\n       sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               ans=nums[i-1];\n               break;\n                  }\n           else{\n              ans=nums[nums.size()-1];\n                 }\n       }\n       return ans;\n    }\n};\n```\nas opposed to this\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ans;\n        sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               return nums[i-1];\n           }\n       }\n       return nums[nums.size()-1];\n    }\n};\n```\n\nPlease do not be harsh to the noob.\n\nQuestion 2: \nTestcase 3: nums=[1]\n\nhow nums[1]!=nums[0] is compared as there are no elements for nums[1]? Or why isn't there an error?"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "SIMPLE 3LINE CODE EASY TO UNDERSTAND\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n      int a=0;\\n      for(int i =0; i<nums.size();i++)\\n      {\\n          a = a^nums[i];\\n      }\\n      return a;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "shank9931",
                        "content": "nice work vansh. \\nCould you checkout my question above and help me with it?"
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t    return reduce(lambda total, el: total ^ el, nums)"
                    },
                    {
                        "username": "hawkeye1806",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       unordered_map<int,int> a;\\n\\t   for(auto x: nums)\\n\\t\\t   a[x]++;\\n\\t   for(auto z:a)\\n\\t\\t   if(z.second==1)\\n\\t\\t\\t   return z.first;\\n\\t   return -1;\\n    }\\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "shank9931",
                        "content": "Hey Aditya could you help me with my question posted here? Thanks in advance."
                    },
                    {
                        "username": "mascomen4",
                        "content": "They key idea I think is that you try to apply XOR to more than two operands..."
                    },
                    {
                        "username": "harishkhope89",
                        "content": "easy approach | hashmap implementation| faster than 60%  of submissions\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        unordered_map<int, int >mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto i: mp){\\n            if (i.second==1){\\n                return i.first;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}; \\n```"
                    }
                ]
            },
            {
                "id": 1680317,
                "content": [
                    {
                        "username": "thanyaniinnocent20",
                        "content": "I\\'ve a question : I used a hash Map to count every number from array using a for loop, which I believe it\\'s O(n). Then I loop through dict keys when I find a value which a value is 1, I returned the key. It\\'s also O(n) thus O(2n) which is equivalent to O(n). Is this solution fine or maybe I\\'m wrong with my BigO? "
                    },
                    {
                        "username": "_hopa_",
                        "content": "hello guys, how to solve this problem by Map stls in Cpp"
                    },
                    {
                        "username": "user2891YF",
                        "content": "You can use a set. Go through the numbers, if the number is already in the set, remove it, otherwise add it. At the end of the loop, you\\'ll have exactly one number left in your set so you can just return the front iterator."
                    },
                    {
                        "username": "ak_r_a_m_7",
                        "content": "XOR approach is well efficient"
                    },
                    {
                        "username": "shank9931",
                        "content": "I am going to ask a very newbie question here, please bear with me.\n\nQuestion1: Why did my code not work ?\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n       int ans;\n       sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               ans=nums[i-1];\n               break;\n                  }\n           else{\n              ans=nums[nums.size()-1];\n                 }\n       }\n       return ans;\n    }\n};\n```\nas opposed to this\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ans;\n        sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               return nums[i-1];\n           }\n       }\n       return nums[nums.size()-1];\n    }\n};\n```\n\nPlease do not be harsh to the noob.\n\nQuestion 2: \nTestcase 3: nums=[1]\n\nhow nums[1]!=nums[0] is compared as there are no elements for nums[1]? Or why isn't there an error?"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "SIMPLE 3LINE CODE EASY TO UNDERSTAND\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n      int a=0;\\n      for(int i =0; i<nums.size();i++)\\n      {\\n          a = a^nums[i];\\n      }\\n      return a;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "shank9931",
                        "content": "nice work vansh. \\nCould you checkout my question above and help me with it?"
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t    return reduce(lambda total, el: total ^ el, nums)"
                    },
                    {
                        "username": "hawkeye1806",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       unordered_map<int,int> a;\\n\\t   for(auto x: nums)\\n\\t\\t   a[x]++;\\n\\t   for(auto z:a)\\n\\t\\t   if(z.second==1)\\n\\t\\t\\t   return z.first;\\n\\t   return -1;\\n    }\\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "shank9931",
                        "content": "Hey Aditya could you help me with my question posted here? Thanks in advance."
                    },
                    {
                        "username": "mascomen4",
                        "content": "They key idea I think is that you try to apply XOR to more than two operands..."
                    },
                    {
                        "username": "harishkhope89",
                        "content": "easy approach | hashmap implementation| faster than 60%  of submissions\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        unordered_map<int, int >mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto i: mp){\\n            if (i.second==1){\\n                return i.first;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}; \\n```"
                    }
                ]
            },
            {
                "id": 1671026,
                "content": [
                    {
                        "username": "thanyaniinnocent20",
                        "content": "I\\'ve a question : I used a hash Map to count every number from array using a for loop, which I believe it\\'s O(n). Then I loop through dict keys when I find a value which a value is 1, I returned the key. It\\'s also O(n) thus O(2n) which is equivalent to O(n). Is this solution fine or maybe I\\'m wrong with my BigO? "
                    },
                    {
                        "username": "_hopa_",
                        "content": "hello guys, how to solve this problem by Map stls in Cpp"
                    },
                    {
                        "username": "user2891YF",
                        "content": "You can use a set. Go through the numbers, if the number is already in the set, remove it, otherwise add it. At the end of the loop, you\\'ll have exactly one number left in your set so you can just return the front iterator."
                    },
                    {
                        "username": "ak_r_a_m_7",
                        "content": "XOR approach is well efficient"
                    },
                    {
                        "username": "shank9931",
                        "content": "I am going to ask a very newbie question here, please bear with me.\n\nQuestion1: Why did my code not work ?\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n       int ans;\n       sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               ans=nums[i-1];\n               break;\n                  }\n           else{\n              ans=nums[nums.size()-1];\n                 }\n       }\n       return ans;\n    }\n};\n```\nas opposed to this\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ans;\n        sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               return nums[i-1];\n           }\n       }\n       return nums[nums.size()-1];\n    }\n};\n```\n\nPlease do not be harsh to the noob.\n\nQuestion 2: \nTestcase 3: nums=[1]\n\nhow nums[1]!=nums[0] is compared as there are no elements for nums[1]? Or why isn't there an error?"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "SIMPLE 3LINE CODE EASY TO UNDERSTAND\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n      int a=0;\\n      for(int i =0; i<nums.size();i++)\\n      {\\n          a = a^nums[i];\\n      }\\n      return a;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "shank9931",
                        "content": "nice work vansh. \\nCould you checkout my question above and help me with it?"
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t    return reduce(lambda total, el: total ^ el, nums)"
                    },
                    {
                        "username": "hawkeye1806",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       unordered_map<int,int> a;\\n\\t   for(auto x: nums)\\n\\t\\t   a[x]++;\\n\\t   for(auto z:a)\\n\\t\\t   if(z.second==1)\\n\\t\\t\\t   return z.first;\\n\\t   return -1;\\n    }\\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "shank9931",
                        "content": "Hey Aditya could you help me with my question posted here? Thanks in advance."
                    },
                    {
                        "username": "mascomen4",
                        "content": "They key idea I think is that you try to apply XOR to more than two operands..."
                    },
                    {
                        "username": "harishkhope89",
                        "content": "easy approach | hashmap implementation| faster than 60%  of submissions\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        unordered_map<int, int >mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto i: mp){\\n            if (i.second==1){\\n                return i.first;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}; \\n```"
                    }
                ]
            },
            {
                "id": 1670516,
                "content": [
                    {
                        "username": "thanyaniinnocent20",
                        "content": "I\\'ve a question : I used a hash Map to count every number from array using a for loop, which I believe it\\'s O(n). Then I loop through dict keys when I find a value which a value is 1, I returned the key. It\\'s also O(n) thus O(2n) which is equivalent to O(n). Is this solution fine or maybe I\\'m wrong with my BigO? "
                    },
                    {
                        "username": "_hopa_",
                        "content": "hello guys, how to solve this problem by Map stls in Cpp"
                    },
                    {
                        "username": "user2891YF",
                        "content": "You can use a set. Go through the numbers, if the number is already in the set, remove it, otherwise add it. At the end of the loop, you\\'ll have exactly one number left in your set so you can just return the front iterator."
                    },
                    {
                        "username": "ak_r_a_m_7",
                        "content": "XOR approach is well efficient"
                    },
                    {
                        "username": "shank9931",
                        "content": "I am going to ask a very newbie question here, please bear with me.\n\nQuestion1: Why did my code not work ?\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n       int ans;\n       sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               ans=nums[i-1];\n               break;\n                  }\n           else{\n              ans=nums[nums.size()-1];\n                 }\n       }\n       return ans;\n    }\n};\n```\nas opposed to this\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ans;\n        sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               return nums[i-1];\n           }\n       }\n       return nums[nums.size()-1];\n    }\n};\n```\n\nPlease do not be harsh to the noob.\n\nQuestion 2: \nTestcase 3: nums=[1]\n\nhow nums[1]!=nums[0] is compared as there are no elements for nums[1]? Or why isn't there an error?"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "SIMPLE 3LINE CODE EASY TO UNDERSTAND\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n      int a=0;\\n      for(int i =0; i<nums.size();i++)\\n      {\\n          a = a^nums[i];\\n      }\\n      return a;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "shank9931",
                        "content": "nice work vansh. \\nCould you checkout my question above and help me with it?"
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t    return reduce(lambda total, el: total ^ el, nums)"
                    },
                    {
                        "username": "hawkeye1806",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       unordered_map<int,int> a;\\n\\t   for(auto x: nums)\\n\\t\\t   a[x]++;\\n\\t   for(auto z:a)\\n\\t\\t   if(z.second==1)\\n\\t\\t\\t   return z.first;\\n\\t   return -1;\\n    }\\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "shank9931",
                        "content": "Hey Aditya could you help me with my question posted here? Thanks in advance."
                    },
                    {
                        "username": "mascomen4",
                        "content": "They key idea I think is that you try to apply XOR to more than two operands..."
                    },
                    {
                        "username": "harishkhope89",
                        "content": "easy approach | hashmap implementation| faster than 60%  of submissions\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        unordered_map<int, int >mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto i: mp){\\n            if (i.second==1){\\n                return i.first;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}; \\n```"
                    }
                ]
            }
        ]
    },
    {
        "title": "Lowest Common Ancestor of a Binary Tree",
        "question_content": "<p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>\n\n<p>According to the <a href=\"https://en.wikipedia.org/wiki/Lowest_common_ancestor\" target=\"_blank\">definition of LCA on Wikipedia</a>: &ldquo;The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <b>a node to be a descendant of itself</b>).&rdquo;</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style=\"width: 200px; height: 190px;\" />\n<pre>\n<strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The LCA of nodes 5 and 1 is 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style=\"width: 200px; height: 190px;\" />\n<pre>\n<strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1,2], p = 1, q = 2\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[2, 10<sup>5</sup>]</code>.</li>\n\t<li><code>-10<sup>9</sup> &lt;= Node.val &lt;= 10<sup>9</sup></code></li>\n\t<li>All <code>Node.val</code> are <strong>unique</strong>.</li>\n\t<li><code>p != q</code></li>\n\t<li><code>p</code> and <code>q</code> will exist in the tree.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 65225,
                "title": "4-lines-c-java-python-ruby",
                "content": "Same solution in several languages. It\\'s recursive and expands the meaning of the function. If the current (sub)tree contains both p and q, then the function result is their LCA. If only one of them is in that subtree, then the result is that one of them. If neither are in that subtree, the result is null/None/nil.\\n\\nUpdate: I also wrote [two iterative solutions](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/65245/Iterative-Solutions-in-PythonC%2B%2B) now, one of them being a version of the solution here. They\\'re more complicated than this simple recursive solution, but I do find them interesting.\\n\\n---\\n\\n**C++**\\n\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (!root || root == p || root == q) return root;\\n        TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n        return !left ? right : !right ? left : root;\\n    }\\n\\n---\\n\\n**Python**\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        if root in (None, p, q): return root\\n        left, right = (self.lowestCommonAncestor(kid, p, q)\\n                       for kid in (root.left, root.right))\\n        return root if left and right else left or right\\n\\nOr using that `None` is considered smaller than any node:\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        if root in (None, p, q): return root\\n        subs = [self.lowestCommonAncestor(kid, p, q)\\n                for kid in (root.left, root.right)]\\n        return root if all(subs) else max(subs)\\n\\n---\\n\\n**Ruby**\\n\\n    def lowest_common_ancestor(root, p, q)\\n        return root if [nil, p, q].index root\\n        left = lowest_common_ancestor(root.left, p, q)\\n        right = lowest_common_ancestor(root.right, p, q)\\n        left && right ? root : left || right\\n    end\\n\\n---\\n\\n**Java**\\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null || root == p || root == q) return root;\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n        return left == null ? right : right == null ? left : root;\\n    }",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Ruby"
                ],
                "code": "Same solution in several languages. It\\'s recursive and expands the meaning of the function. If the current (sub)tree contains both p and q, then the function result is their LCA. If only one of them is in that subtree, then the result is that one of them. If neither are in that subtree, the result is null/None/nil.\\n\\nUpdate: I also wrote [two iterative solutions](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/65245/Iterative-Solutions-in-PythonC%2B%2B) now, one of them being a version of the solution here. They\\'re more complicated than this simple recursive solution, but I do find them interesting.\\n\\n---\\n\\n**C++**\\n\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (!root || root == p || root == q) return root;\\n        TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n        return !left ? right : !right ? left : root;\\n    }\\n\\n---\\n\\n**Python**\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        if root in (None, p, q): return root\\n        left, right = (self.lowestCommonAncestor(kid, p, q)\\n                       for kid in (root.left, root.right))\\n        return root if left and right else left or right\\n\\nOr using that `None` is considered smaller than any node:\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        if root in (None, p, q): return root\\n        subs = [self.lowestCommonAncestor(kid, p, q)\\n                for kid in (root.left, root.right)]\\n        return root if all(subs) else max(subs)\\n\\n---\\n\\n**Ruby**\\n\\n    def lowest_common_ancestor(root, p, q)\\n        return root if [nil, p, q].index root\\n        left = lowest_common_ancestor(root.left, p, q)\\n        right = lowest_common_ancestor(root.right, p, q)\\n        left && right ? root : left || right\\n    end\\n\\n---\\n\\n**Java**\\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null || root == p || root == q) return root;\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n        return left == null ? right : right == null ? left : root;\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 65226,
                "title": "my-java-solution-which-is-easy-to-understand",
                "content": "    public class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            if(root == null || root == p || root == q)  return root;\\n            TreeNode left = lowestCommonAncestor(root.left, p, q);\\n            TreeNode right = lowestCommonAncestor(root.right, p, q);\\n            if(left != null && right != null)   return root;\\n            return left != null ? left : right;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            if(root == null || root == p || root == q)  return root;\\n            TreeNode left = lowestCommonAncestor(root.left, p, q);\\n            TreeNode right = lowestCommonAncestor(root.right, p, q);\\n            if(left != null && right != null)   return root;\\n            return left != null ? left : right;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 152682,
                "title": "python-simple-recursive-solution-with-detailed-explanation",
                "content": "```\\ndef lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n\\t\\t\\t\\t# If looking for me, return myself\\n        if root == p or root == q:\\n            return root\\n        \\n        left = right = None\\n        # else look in left and right child\\n        if root.left:\\n            left = self.lowestCommonAncestor(root.left, p, q)\\n        if root.right:\\n            right = self.lowestCommonAncestor(root.right, p, q)\\n\\n        # if both children returned a node, means\\n        # both p and q found so parent is LCA\\n        if left and right:\\n            return root\\n        else:\\n        # either one of the chidren returned a node, meaning either p or q found on left or right branch.\\n        # Example: assuming \\'p\\' found in left child, right child returned \\'None\\'. This means \\'q\\' is\\n        # somewhere below node where \\'p\\' was found we dont need to search all the way, \\n        # because in such scenarios, node where \\'p\\' found is LCA\\n            return left or right\\n```",
                "solutionTags": [],
                "code": "```\\ndef lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n\\t\\t\\t\\t# If looking for me, return myself\\n        if root == p or root == q:\\n            return root\\n        \\n        left = right = None\\n        # else look in left and right child\\n        if root.left:\\n            left = self.lowestCommonAncestor(root.left, p, q)\\n        if root.right:\\n            right = self.lowestCommonAncestor(root.right, p, q)\\n\\n        # if both children returned a node, means\\n        # both p and q found so parent is LCA\\n        if left and right:\\n            return root\\n        else:\\n        # either one of the chidren returned a node, meaning either p or q found on left or right branch.\\n        # Example: assuming \\'p\\' found in left child, right child returned \\'None\\'. This means \\'q\\' is\\n        # somewhere below node where \\'p\\' was found we dont need to search all the way, \\n        # because in such scenarios, node where \\'p\\' found is LCA\\n            return left or right\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 65236,
                "title": "java-python-iterative-solution",
                "content": "**Python**\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        stack = [root]\\n        parent = {root: None}\\n        while p not in parent or q not in parent:\\n            node = stack.pop()\\n            if node.left:\\n                parent[node.left] = node\\n                stack.append(node.left)\\n            if node.right:\\n                parent[node.right] = node\\n                stack.append(node.right)\\n        ancestors = set()\\n        while p:\\n            ancestors.add(p)\\n            p = parent[p]\\n        while q not in ancestors:\\n            q = parent[q]\\n        return q\\n\\n    # 31 / 31 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 108 ms\\n    # 99.14%\\n\\n\\n**Java**\\n\\n    public class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            Map<TreeNode, TreeNode> parent = new HashMap<>();\\n            Deque<TreeNode> stack = new ArrayDeque<>();\\n            parent.put(root, null);\\n            stack.push(root);\\n    \\n            while (!parent.containsKey(p) || !parent.containsKey(q)) {\\n                TreeNode node = stack.pop();\\n                if (node.left != null) {\\n                    parent.put(node.left, node);\\n                    stack.push(node.left);\\n                }\\n                if (node.right != null) {\\n                    parent.put(node.right, node);\\n                    stack.push(node.right);\\n                }\\n            }\\n            Set<TreeNode> ancestors = new HashSet<>();\\n            while (p != null) {\\n                ancestors.add(p);\\n                p = parent.get(p);\\n            }\\n            while (!ancestors.contains(q))\\n                q = parent.get(q);\\n            return q;\\n        }\\n    }\\n\\nTo find the lowest common ancestor, we need to find where is `p` and `q` and a way to track their ancestors. A `parent` pointer for each node found is good for the job. After we found both `p` and `q`, we create a set of `p`'s `ancestors`. Then we travel through `q`'s `ancestors`, the first one appears in `p`'s is our answer.",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            Map<TreeNode, TreeNode> parent = new HashMap<>();\\n            Deque<TreeNode> stack = new ArrayDeque<>();\\n            parent.put(root, null);\\n            stack.push(root);\\n    \\n            while (!parent.containsKey(p) || !parent.containsKey(q)) {\\n                TreeNode node = stack.pop();\\n                if (node.left != null) {\\n                    parent.put(node.left, node);\\n                    stack.push(node.left);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1306476,
                "title": "c-python-2-solutions-clean-concise-o-n",
                "content": "**\\u2714\\uFE0F Solution 1: Depth First Search**\\n- Please note that `p` and `q` always exist in the tree.\\n- Since we `dfs` from the root down to its children, if current `root == p` or `root == q` then current `root` must be their LCA.\\n- If `left` subtree contains one of descendant (`p` or `q`) and `right` subtree contains the remaining descendant (`q` or `p`) then the `root` is their LCA.\\n- If `left` subtree contains both `p` and `q` then return `left` as their LCA.\\n- If `right` subtree contains both `p` and `q` then return `right` as their LCA.\\n\\nFor a clear explanation, you can check video title \"Lowest Common Ancestor Binary Tree\" by \"Tushar Roy\" on Youtube.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if root == None or root == p or root == q: return root\\n        left = self.lowestCommonAncestor(root.left, p, q)\\n        right = self.lowestCommonAncestor(root.right, p, q)\\n        if left != None and right != None: return root\\n        if left != None: return left\\n        return right\\n```\\n\\n**C++**\\n```c++\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (root == nullptr || root == p || root == q) return root;\\n        TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n        if (left != nullptr && right != nullptr) return root;\\n        if (left != nullptr) return left;\\n        return right;\\n    }\\n};\\n```\\n\\nComplexity:\\n- Time: `O(N)`, where `N` is number of nodes in the Binary Tree.\\n- Space: `O(H)`, where `H` is the heigh of Binary Tree.\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: Find Parent and Level of nodes**\\n- Using `dfs` to find `parent` and `level` of nodes.\\n- Make `p` and `q` go to the same level that is if `level[p] < level[q]` then jump `q` to parents `level[q] - level[p]` times else jump `p`.\\n- Jump both `p` and `q` util they meet at thier LCA.\\n- Return their LCA.\\n```python\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        def jumpParent(u, steps):\\n            while steps > 0:\\n                u = parent[u]\\n                steps -= 1\\n            return u\\n\\n        def dfs(u, p, depth):\\n            if u == None: return\\n            parent[u] = p\\n            level[u] = depth\\n            dfs(u.left, u, depth + 1)\\n            dfs(u.right, u, depth + 1)\\n\\n        parent = dict()\\n        level = dict()\\n        dfs(root, None, 0)\\n        if level[p] < level[q]:  # Make node p and node q the same level\\n            q = jumpParent(q, level[q] - level[p])\\n        else:\\n            p = jumpParent(p, level[p] - level[q])\\n        while q != p:  # Jump util their LCA\\n            q = parent[q]\\n            p = parent[p]\\n        return q\\n```\\nComplexity:\\n- Time & Space: `O(N)`, where `N` is number of nodes in the Binary Tree.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if root == None or root == p or root == q: return root\\n        left = self.lowestCommonAncestor(root.left, p, q)\\n        right = self.lowestCommonAncestor(root.right, p, q)\\n        if left != None and right != None: return root\\n        if left != None: return left\\n        return right\\n```\n```c++\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (root == nullptr || root == p || root == q) return root;\\n        TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n        if (left != nullptr && right != nullptr) return root;\\n        if (left != nullptr) return left;\\n        return right;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        def jumpParent(u, steps):\\n            while steps > 0:\\n                u = parent[u]\\n                steps -= 1\\n            return u\\n\\n        def dfs(u, p, depth):\\n            if u == None: return\\n            parent[u] = p\\n            level[u] = depth\\n            dfs(u.left, u, depth + 1)\\n            dfs(u.right, u, depth + 1)\\n\\n        parent = dict()\\n        level = dict()\\n        dfs(root, None, 0)\\n        if level[p] < level[q]:  # Make node p and node q the same level\\n            q = jumpParent(q, level[q] - level[p])\\n        else:\\n            p = jumpParent(p, level[p] - level[q])\\n        while q != p:  # Jump util their LCA\\n            q = parent[q]\\n            p = parent[p]\\n        return q\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65375,
                "title": "very-simple-dfs-c-solution-only-10-lines",
                "content": "    TreeNode * dfsTraverse(TreeNode * root, TreeNode * p , TreeNode * q)\\n    {\\n        if( root == p || root == q || root == NULL)\\n            return root;\\n        TreeNode * parent1 = dfsTraverse(root->left, p, q);\\n        TreeNode * parent2 = dfsTraverse(root->right, p, q);\\n        if( parent1 && parent2)\\n            return root;\\n        else\\n            return parent1 ? parent1:parent2;\\n    }\\n    TreeNode * lowestCommonAncestor(TreeNode * root, TreeNode * p, TreeNode * q)\\n    {\\n        return dfsTraverse(root, p, q);\\n    }",
                "solutionTags": [],
                "code": "    TreeNode * dfsTraverse(TreeNode * root, TreeNode * p , TreeNode * q)\\n    {\\n        if( root == p || root == q || root == NULL)\\n            return root;\\n        TreeNode * parent1 = dfsTraverse(root->left, p, q);\\n        TreeNode * parent2 = dfsTraverse(root->right, p, q);\\n        if( parent1 && parent2)\\n            return root;\\n        else\\n            return parent1 ? parent1:parent2;\\n    }\\n    TreeNode * lowestCommonAncestor(TreeNode * root, TreeNode * p, TreeNode * q)\\n    {\\n        return dfsTraverse(root, p, q);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1037162,
                "title": "python-easy-to-understand",
                "content": "```\\ndef lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if root == None or root == p or root == q:\\n            return root\\n        \\n\\t\\t# Find p/q in left subtree\\n        l = self.lowestCommonAncestor(root.left, p, q)\\n\\t\\t\\n\\t\\t# Find p/q in right subtree\\n        r = self.lowestCommonAncestor(root.right, p, q)\\n        \\n\\t\\t# If p and q found in left and right subtree of this node, then this node is LCA\\n        if l and r:\\n            return root\\n        \\n\\t\\t# Else return the node which returned a node from it\\'s subtree such that one of it\\'s ancestor will be LCA\\n        return l if l else r\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ndef lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if root == None or root == p or root == q:\\n            return root\\n        \\n\\t\\t# Find p/q in left subtree\\n        l = self.lowestCommonAncestor(root.left, p, q)\\n\\t\\t\\n\\t\\t# Find p/q in right subtree\\n        r = self.lowestCommonAncestor(root.right, p, q)\\n        \\n\\t\\t# If p and q found in left and right subtree of this node, then this node is LCA\\n        if l and r:\\n            return root\\n        \\n\\t\\t# Else return the node which returned a node from it\\'s subtree such that one of it\\'s ancestor will be LCA\\n        return l if l else r\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 65245,
                "title": "iterative-solutions-in-python-c",
                "content": "**Solution 1**\\n\\nSame algorithm as [my recursive solution](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/65225/4-lines-C%2B%2BJavaPythonRuby) (look there if you want some explanation), but iterative. I do a post-order traversal with a stack. Each stack element at first is a [node, parent] pair, where parent is the stack element of the node\\'s parent node. When the children of a parent get finished, their results are appended to their parent\\'s stack element. So when a parent gets finished, we have the results of its children/subtrees available (its stack element at that point is [node, parent, resultForLeftSubtree, resultForRightSubtree]).\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        answer = []\\n        stack = [[root, answer]]\\n        while stack:\\n            top = stack.pop()\\n            (node, parent), subs = top[:2], top[2:]\\n            if node in (None, p, q):\\n                parent += node,\\n            elif not subs:\\n                stack += top, [node.right, top], [node.left, top]\\n            else:\\n                parent += node if all(subs) else max(subs),\\n        return answer[0]\\n\\n---\\n\\n**Solution 2**\\n\\nHere I find the paths to p and q and then find the last node where the paths match. I just came up with the path-building technique for this, and I find it quite neat and maybe it could be useful elsewhere.\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        def path(root, goal):\\n            path, stack = [], [root]\\n            while True:\\n                node = stack.pop()\\n                if node:\\n                    if node not in path[-1:]:\\n                        path += node,\\n                        if node == goal:\\n                            return path\\n                        stack += node, node.right, node.left\\n                    else:\\n                        path.pop()\\n        return next(a for a, b in zip(path(root, p), path(root, q))[::-1] if a == b)\\n\\n---\\n\\n**C++ version of Solution 1**\\n\\nI don\\'t use C++ much, so maybe there\\'s room for improvement with stuff that I don\\'t know.\\n\\n    class Solution {\\n        struct Frame {\\n            TreeNode* node;\\n            Frame* parent;\\n            vector<TreeNode*> subs;\\n        };\\n    public:\\n        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            Frame answer;\\n            stack<Frame> stack;\\n            stack.push({root, &answer});\\n            while (stack.size()) {\\n                Frame *top = &stack.top(), *parent = top->parent;\\n                TreeNode *node = top->node;\\n                if (!node || node == p || node == q) {\\n                    parent->subs.push_back(node);\\n                    stack.pop();\\n                } else if (top->subs.empty()) {\\n                    stack.push({node->right, top});\\n                    stack.push({node->left, top});\\n                } else {\\n                    TreeNode *left = top->subs[0], *right = top->subs[1];\\n                    parent->subs.push_back(!left ? right : !right ? left : node);\\n                    stack.pop();\\n                }\\n            }\\n            return answer.subs[0];\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Iterator"
                ],
                "code": "class Solution {\\n        struct Frame {\\n            TreeNode* node;\\n            Frame* parent;\\n            vector<TreeNode*> subs;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 65372,
                "title": "javascript-solution",
                "content": "    function lowestCommonAncestor(root, p, q) {\\n      if (!root || root === p || root === q) return root;\\n      var resL = lowestCommonAncestor(root.left, p, q);\\n      var resR = lowestCommonAncestor(root.right, p, q);\\n      return (resL && resR) ? root : (resL || resR);\\n    }",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    function lowestCommonAncestor(root, p, q) {\\n      if (!root || root === p || root === q) return root;\\n      var resL = lowestCommonAncestor(root.left, p, q);\\n      var resR = lowestCommonAncestor(root.right, p, q);\\n      return (resL && resR) ? root : (resL || resR);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1405170,
                "title": "4-steps-solution-easy-heavily-explained-with-complexities",
                "content": "* **I FOUND MY SOLUTION EASIER & MORE INTUITIVE THAN LEETCODE OFFICIAL SOLUTION / MANY OTHER SOLUTIONS TOO !!! : }**\\n* ``A VERY CLASSICAL PROBLEM OF BINARY TREE / GRAPH``\\n#### **EXPLANATION**\\n\\n* **`We\\'ll do just normal tree traversal of the given binary tree recursivly`.**  \\n* **`For finding LCA (lowest common ancestor) we\\'ve following conditions for every node in the tree,`**\\n* **`But before that, this solutions works under the assumption that both Node \\'p\\' & Node \\'q\\' will present in the tree...`**\\n* **`if single one of the node is present in the tree, it\\'ll not work or simply return null`.**\\n\\n#### **CONDITIONS: -**\\t\\t\\t\\t\\t\\t\\t\\t\\n1. **`if current node is same as \\'p\\' OR \\'q\\'.`**\\n2. **`if one of it\\'s subtrees contains \\'p\\' and other \\'q\\' (subtrees means, left_sub_tree and right_sub_tree).`**\\n3. **`if one of it\\'s subtree contains both \\'p\\' & \\'q\\'.`**\\n4. **`if none of it\\'s subtrees contains any of \\'p\\' & \\'q\\'.`**\\n\\n* **`Note: that\\'s a tricky implementation, but works well under the assumption that \\'p\\' & \\'q\\' will be definitely present`.**\\n\\n**EFFICIENT SOLUTION**\\n* **Runtime: 15ms [C++]**\\n```\\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\tif(root == NULL) return NULL;\\n\\tif(root->val == p->val || root->val == q->val) return root;       // \\uD83D\\uDC49 FIRST CONDITION...\\n\\n\\tTreeNode* lca1 = lowestCommonAncestor(root->left, p, q);          // traverse on the left part of the tree\\n\\tTreeNode* lca2 = lowestCommonAncestor(root->right, p, q);         // traverse on the right part of the tree\\n\\n\\tif(lca1 != NULL && lca2 != NULL) return root;                     // \\uD83D\\uDC49 SECOND CONDITION... (IF BOTH SUB-TREE CONTAINS \\'p\\' & \\'q\\' RESPECTIVELY)\\n\\tif(lca1 != NULL) return lca1;                                     // \\uD83D\\uDC49 THIRD CONDITION...\\n\\treturn lca2;                                                      // \\uD83D\\uDC49 FOURTH CONDITION...\\n}\\n```\\n**TIME COMPLEXITY : `O(N), `Where N : total number of nodes in the BT\\nSPACE COMPLEXITY :` O(H) or O(N) (Worse Case)`, Where H : total height of tree for recursion stack**\\n\\n**(Found mistakes || Share something) ? Please** drop a comment :  **Please Upvote `(If it makes any sense)` ; }**\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\tif(root == NULL) return NULL;\\n\\tif(root->val == p->val || root->val == q->val) return root;       // \\uD83D\\uDC49 FIRST CONDITION...\\n\\n\\tTreeNode* lca1 = lowestCommonAncestor(root->left, p, q);          // traverse on the left part of the tree\\n\\tTreeNode* lca2 = lowestCommonAncestor(root->right, p, q);         // traverse on the right part of the tree\\n\\n\\tif(lca1 != NULL && lca2 != NULL) return root;                     // \\uD83D\\uDC49 SECOND CONDITION... (IF BOTH SUB-TREE CONTAINS \\'p\\' & \\'q\\' RESPECTIVELY)\\n\\tif(lca1 != NULL) return lca1;                                     // \\uD83D\\uDC49 THIRD CONDITION...\\n\\treturn lca2;                                                      // \\uD83D\\uDC49 FOURTH CONDITION...\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 777296,
                "title": "faster-than-98-09-c-recursive",
                "content": "\\n     class Solution {\\n     public:\\n         TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n             if(root==NULL) return NULL;\\n        \\n             if(root==p || root==q) return root;\\n        \\n             TreeNode* left=lowestCommonAncestor(root->left,p,q);\\n             TreeNode* right=lowestCommonAncestor(root->right,p,q);\\n        \\n             if(left!=NULL and right!=NULL) return root;\\n        \\n             return left!=NULL? left : right;\\n         }\\n     };\\n\\t \\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n     public:\\n         TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n             if(root==NULL) return NULL;\\n        \\n             if(root==p || root==q) return root;\\n        \\n             TreeNode* left=lowestCommonAncestor(root->left,p,q);\\n             TreeNode* right=lowestCommonAncestor(root->right,p,q);\\n        \\n             if(left!=NULL and right!=NULL) return root;\\n        \\n             return left!=NULL? left : right;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 65251,
                "title": "clear-javascript-solution",
                "content": "```\\nconst lowestCommonAncestor = (root, p, q) => {\\n    if (!root || root === p || root === q) return root\\n    const left = lowestCommonAncestor(root.left, p, q)\\n    const right = lowestCommonAncestor(root.right, p, q)\\n    if (!left) return right  // p and q are in the right subtree\\n    if (!right) return left  // p and q are in the left subtree\\n    return root              // p is in one side and q is in the other\\n};\\n```\\nThe basic algorithm has been posted by many, but hopefully these commented lines will help someone.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst lowestCommonAncestor = (root, p, q) => {\\n    if (!root || root === p || root === q) return root\\n    const left = lowestCommonAncestor(root.left, p, q)\\n    const right = lowestCommonAncestor(root.right, p, q)\\n    if (!left) return right  // p and q are in the right subtree\\n    if (!right) return left  // p and q are in the left subtree\\n    return root              // p is in one side and q is in the other\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3231708,
                "title": "236-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. The function lowestCommonAncestor takes in three parameters: the root of a binary tree (root) and two nodes of the binary tree (p and q).\\n\\n2. The first if statement checks if the root is None or if it is equal to either p or q. If either of these conditions is true, it means that we have found one of the nodes we are looking for, and we return the root.\\n\\n3. Next, we recursively call the lowestCommonAncestor function on the left and right subtrees of the root, passing in the same nodes p and q. We store the results of these recursive calls in variables l and r, respectively.\\n\\n4. The second if statement checks if both l and r are not None. If this condition is true, it means that we have found both p and q in different subtrees of the current root, and therefore the current root is the lowest common ancestor. We return the current root.\\n\\n5. If the second if statement is not satisfied, we return either l or r, depending on which one is not None. This is because if only one of l and r is not None, it means that the other node is not in the subtree of the current root, so we return the node that is in the subtree.\\n\\n6. If none of the previous conditions is satisfied, it means that both l and r are None, so we return None. This happens when we have reached the end of a branch of the binary tree without finding either p or q.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n    if not root or root == p or root == q:\\n      return root\\n\\n    l = self.lowestCommonAncestor(root.left, p, q)\\n    r = self.lowestCommonAncestor(root.right, p, q)\\n\\n    if l and r:\\n      return root\\n    return l or r\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n  def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n    if not root or root == p or root == q:\\n      return root\\n\\n    l = self.lowestCommonAncestor(root.left, p, q)\\n    r = self.lowestCommonAncestor(root.right, p, q)\\n\\n    if l and r:\\n      return root\\n    return l or r\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65335,
                "title": "java-iterative-and-recursive-solutions",
                "content": "        \\n    // iteratively \\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        Map<TreeNode, TreeNode> parent = new HashMap<>();\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        parent.put(root, null);\\n        queue.add(root);\\n        while (!parent.containsKey(p) || !parent.containsKey(q)) {\\n            TreeNode node = queue.poll();\\n            if (node != null) {\\n                parent.put(node.left, node);\\n                parent.put(node.right, node);\\n                queue.add(node.left);\\n                queue.add(node.right);\\n            }\\n        }\\n        Set<TreeNode> set = new HashSet<>();\\n        while (p != null) {\\n            set.add(p);\\n            p = parent.get(p);\\n        }\\n        while (!set.contains(q)) {\\n            q = parent.get(q);\\n        }\\n        return q;\\n    }\\n    \\n    // recursively\\n    public TreeNode lowestCommonAncestor1(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null || root == p || root == q) {\\n            return root;\\n        }\\n        TreeNode l = lowestCommonAncestor(root.left, p, q);\\n        TreeNode r = lowestCommonAncestor(root.right, p, q);\\n        return l != null && r != null?root : l == null?r: l;\\n    }\\n    \\n    public TreeNode lowestCommonAncestor2(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == p || root == q) {\\n            return root;\\n        }\\n        int count = leftCount(root.left, p, q);\\n        if (count == 0) {\\n            return lowestCommonAncestor(root.right, p, q);\\n        } else if (count == 2) {\\n            return lowestCommonAncestor(root.left, p, q);\\n        } else {\\n            return root;\\n        }\\n    }\\n    \\n    private int leftCount(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        if (root == p && root == q) {\\n            return 2;\\n        }\\n        if (root == p || root == q) {\\n            return 1 + leftCount(root.left, p, q) + leftCount(root.right, p, q);\\n        }\\n        return leftCount(root.left, p, q) + leftCount(root.right, p, q);\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "        \\n    // iteratively \\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        Map<TreeNode, TreeNode> parent = new HashMap<>();\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        parent.put(root, null);\\n        queue.add(root);\\n        while (!parent.containsKey(p) || !parent.containsKey(q)) {\\n            TreeNode node = queue.poll();\\n            if (node != null) {\\n                parent.put(node.left, node);\\n                parent.put(node.right, node);\\n                queue.add(node.left);\\n                queue.add(node.right);\\n            }\\n        }\\n        Set<TreeNode> set = new HashSet<>();\\n        while (p != null) {\\n            set.add(p);\\n            p = parent.get(p);\\n        }\\n        while (!set.contains(q)) {\\n            q = parent.get(q);\\n        }\\n        return q;\\n    }\\n    \\n    // recursively\\n    public TreeNode lowestCommonAncestor1(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null || root == p || root == q) {\\n            return root;\\n        }\\n        TreeNode l = lowestCommonAncestor(root.left, p, q);\\n        TreeNode r = lowestCommonAncestor(root.right, p, q);\\n        return l != null && r != null?root : l == null?r: l;\\n    }\\n    \\n    public TreeNode lowestCommonAncestor2(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == p || root == q) {\\n            return root;\\n        }\\n        int count = leftCount(root.left, p, q);\\n        if (count == 0) {\\n            return lowestCommonAncestor(root.right, p, q);\\n        } else if (count == 2) {\\n            return lowestCommonAncestor(root.left, p, q);\\n        } else {\\n            return root;\\n        }\\n    }\\n    \\n    private int leftCount(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        if (root == p && root == q) {\\n            return 2;\\n        }\\n        if (root == p || root == q) {\\n            return 1 + leftCount(root.left, p, q) + leftCount(root.right, p, q);\\n        }\\n        return leftCount(root.left, p, q) + leftCount(root.right, p, q);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3649508,
                "title": "c-easy-method",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(!root){\\n            return NULL;\\n        }\\n        if(root==p || root==q)return root;\\n        TreeNode* l,*r;\\n        l = lowestCommonAncestor(root->left,p,q);\\n        r= lowestCommonAncestor(root->right,p,q);\\n        if(l && r)return root;\\n        if(l)return l;\\n        if(r) return r;\\n        return NULL;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/a795b7d2-14fe-46fa-951b-0297c789a792_1687025691.7140567.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(!root){\\n            return NULL;\\n        }\\n        if(root==p || root==q)return root;\\n        TreeNode* l,*r;\\n        l = lowestCommonAncestor(root->left,p,q);\\n        r= lowestCommonAncestor(root->right,p,q);\\n        if(l && r)return root;\\n        if(l)return l;\\n        if(r) return r;\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65228,
                "title": "5-lines-java-solution",
                "content": "    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null) return null;\\n        if(root == p || root == q) return root;\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n        return left != null && right != null ? root : left == null ? right : left; \\n    }",
                "solutionTags": [],
                "code": "    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null) return null;\\n        if(root == p || root == q) return root;\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n        return left != null && right != null ? root : left == null ? right : left; \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 65369,
                "title": "short-and-clean-c-solution",
                "content": "Want to share my solution.\\n\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        \\n        if (!root || !p || !q) {\\n            return NULL;\\n        }\\n        \\n        if (root == p || root == q) {\\n            return root;\\n        }\\n        \\n        TreeNode* l = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* r = lowestCommonAncestor(root->right, p, q);\\n        \\n        if (l && r) {\\n            return root;\\n        }\\n        \\n        return l? l : r;\\n    }",
                "solutionTags": [],
                "code": "Want to share my solution.\\n\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        \\n        if (!root || !p || !q) {\\n            return NULL;\\n        }\\n        \\n        if (root == p || root == q) {\\n            return root;\\n        }\\n        \\n        TreeNode* l = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* r = lowestCommonAncestor(root->right, p, q);\\n        \\n        if (l && r) {\\n            return root;\\n        }\\n        \\n        return l? l : r;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 65417,
                "title": "share-my-very-concise-python-solution",
                "content": "Not quite fast (around 300 ms), but very short.\\n\\n    class Solution:\\n        # @param {TreeNode} root\\n        # @param {TreeNode} p\\n        # @param {TreeNode} q\\n        # @return {TreeNode}\\n        def lowestCommonAncestor(self, root, p, q):\\n            # escape condition\\n            if (not root) or (root == p) or (root == q):\\n                return root\\n            # search left and right subtree\\n            left = self.lowestCommonAncestor(root.left, p, q)\\n            right = self.lowestCommonAncestor(root.right, p, q)\\n            if left and right:\\n                # both found, root is the LCA\\n                return root\\n            return left or right\\n\\nWell, I just found that it is essentially the same as [this one][1] \\n\\n\\n  [1]: https://leetcode.com/discuss/45386/4-lines-c-java-python-ruby",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {TreeNode}",
                "codeTag": "Java"
            },
            {
                "id": 65452,
                "title": "clean-java-solution-with-explanation",
                "content": "    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n      if (root == null || root == p || root == q)\\n        // found p or q or touch the ground\\n        return root;\\n            \\n      // search p and q from left and right\\n      TreeNode left = lowestCommonAncestor(root.left, p, q);\\n      TreeNode right = lowestCommonAncestor(root.right, p, q);\\n      \\n      if (left != null && right != null)\\n        // from root's left & right we found both p and q, so root is the LCA\\n        return root;\\n      else\\n        // left is not null means from left's left & right we found both q and q\\n        // so left is the LCA, otherwise, right is the answer\\n        return left != null ? left : right;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n      if (root == null || root == p || root == q)\\n        // found p or q or touch the ground\\n        return root;\\n            \\n      // search p and q from left and right\\n      TreeNode left = lowestCommonAncestor(root.left, p, q);\\n      TreeNode right = lowestCommonAncestor(root.right, p, q);\\n      \\n      if (left != null && right != null)\\n        // from root's left & right we found both p and q, so root is the LCA\\n        return root;\\n      else\\n        // left is not null means from left's left & right we found both q and q\\n        // so left is the LCA, otherwise, right is the answer\\n        return left != null ? left : right;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2335047,
                "title": "c-100-faster-recursive-code",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) \\n    {\\n        if (!root)\\n            return root;\\n        \\n\\t\\t// If p or q if found, return the root.\\n        if (root == p || root == q)\\n            return root;\\n        \\n\\t\\t// Save the root found at left and right recursively\\n        TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n        \\n\\t\\t// If both the nodes are found, return parent of that node. That will be root.\\n        if (left && right)\\n            return root;\\n        // If left is found, and right is not found.\\n\\t\\t// It is given that both the p and q will exist for sure.\\n\\t\\t// If left present then right will be a decendent of left, or vice versa.\\n        return left? left: right;\\n    }\\n};\\n```\\n**Note**\\nTry to dry run on the given test cases for better understanding.\\nHope you like it.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) \\n    {\\n        if (!root)\\n            return root;\\n        \\n\\t\\t// If p or q if found, return the root.\\n        if (root == p || root == q)\\n            return root;\\n        \\n\\t\\t// Save the root found at left and right recursively\\n        TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n        \\n\\t\\t// If both the nodes are found, return parent of that node. That will be root.\\n        if (left && right)\\n            return root;\\n        // If left is found, and right is not found.\\n\\t\\t// It is given that both the p and q will exist for sure.\\n\\t\\t// If left present then right will be a decendent of left, or vice versa.\\n        return left? left: right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2334071,
                "title": "c-java-full-explanations-bits-99-87",
                "content": "The very first thing we can observe from the question is that we can find the LCA of 2 given nodes from \\n\\n        i) Left subtree or in\\n\\n       ii) Right subtree, if not in both the subtrees then root will be the  LCA.\\n\\n**Approach:**\\n* If root is null or if root is x or if root is y then return root\\n* Made a recursion call for both on Left subtree and Right subtree\\n* If the left subtree recursive call gives a null value that means we haven\\u2019t found LCA in the left subtree, which means we found LCA on the right subtree. So we will return right.\\n* If the right subtree recursive call gives null value, that means we haven\\u2019t found LCA on the right subtree, which means we found LCA on the left subtree. So we will return left .\\n*  If both left & right calls give values (not null)  that means the root is the LCA.\\n\\n**For a better understanding of the above example (LCA OF 4,5) :**\\n![image](https://assets.leetcode.com/users/images/e6c0c5f8-0561-4012-80da-a8ff448761d5_1658794730.2941885.png)\\n\\n**Time complexity:** `O(N)` where n is the number of nodes.\\n\\n**Space complexity:** `O(N)`, auxiliary space.\\n\\n**If you like please upvote**\\n\\n**C++ Code:-**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        //base case\\n        if (root == NULL || root == p || root == q) {\\n            return root;\\n        }\\n        TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n\\n        //result\\n        if(left == NULL) {\\n            return right;\\n        }\\n        else if(right == NULL) {\\n            return left;\\n        }\\n        else { //both left and right are not null, we found our result\\n            return root;\\n        }\\n    }\\n};\\n```\\n\\n**Java Code:-**\\n```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        //base case\\n        if (root == null || root == p || root == q) {\\n            return root;\\n        }\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n\\n        //result\\n        if(left == null) {\\n            return right;\\n        }\\n        else if(right == null) {\\n            return left;\\n        }\\n        else { //both left and right are not null, we found our result\\n            return root;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        //base case\\n        if (root == NULL || root == p || root == q) {\\n            return root;\\n        }\\n        TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n\\n        //result\\n        if(left == NULL) {\\n            return right;\\n        }\\n        else if(right == NULL) {\\n            return left;\\n        }\\n        else { //both left and right are not null, we found our result\\n            return root;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        //base case\\n        if (root == null || root == p || root == q) {\\n            return root;\\n        }\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n\\n        //result\\n        if(left == null) {\\n            return right;\\n        }\\n        else if(right == null) {\\n            return left;\\n        }\\n        else { //both left and right are not null, we found our result\\n            return root;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1306449,
                "title": "lowest-common-ancestor-of-a-binary-tree-recursive-solution-w-explanation",
                "content": "***\\u2705 Solution 1(Recursion-Accepted):***\\n```\\n# Approach:\\nWe will use recursion to expand and extract out all the subtree possibilities,\\n\\nCases To Consider:\\n1) If the current subtree contains both the nodes then return the root node of current subtree as answer.\\n2) If the current subtree does not contain both the nodes then return NULL, as this cannot be the LCA,\\n3) If the current subtree contain only one node , then result will be itself that node.\\n\\n# Note:\\nIt is mentioned that both the nodes exist in the tree.\\n```\\n\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) \\n    {\\n        if(!root)\\n            return NULL;\\n//         If root is itself one of the node\\n        if(root==p or root==q)\\n            return root;\\n//         Traverse the left of current subtree \\n        TreeNode* left=lowestCommonAncestor(root->left,p,q);\\n//         Traverse the right of current subtree\\n        TreeNode* right=lowestCommonAncestor(root->right,p,q);\\n//         Both the nodes exist under current subtree\\n        if(left and right)\\n            return root;\\n//         Both the nodes don\\'t exist under current subtree\\n        if(!left and !right)\\n            return NULL;\\n//         One node is present in right of current subtree\\n        if(!left)\\n            return right;\\n//         One node is present in left of current subtree\\n        return left;\\n    }\\n};\\n```\\n**Time Complexity : O(N)**\\n**N - The number of nodes in the tree**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n# Approach:\\nWe will use recursion to expand and extract out all the subtree possibilities,\\n\\nCases To Consider:\\n1) If the current subtree contains both the nodes then return the root node of current subtree as answer.\\n2) If the current subtree does not contain both the nodes then return NULL, as this cannot be the LCA,\\n3) If the current subtree contain only one node , then result will be itself that node.\\n\\n# Note:\\nIt is mentioned that both the nodes exist in the tree.\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) \\n    {\\n        if(!root)\\n            return NULL;\\n//         If root is itself one of the node\\n        if(root==p or root==q)\\n            return root;\\n//         Traverse the left of current subtree \\n        TreeNode* left=lowestCommonAncestor(root->left,p,q);\\n//         Traverse the right of current subtree\\n        TreeNode* right=lowestCommonAncestor(root->right,p,q);\\n//         Both the nodes exist under current subtree\\n        if(left and right)\\n            return root;\\n//         Both the nodes don\\'t exist under current subtree\\n        if(!left and !right)\\n            return NULL;\\n//         One node is present in right of current subtree\\n        if(!left)\\n            return right;\\n//         One node is present in left of current subtree\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65227,
                "title": "10-line-java-solution-solved-in-one-traversal",
                "content": "    public class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null){\\n            return null;\\n        }\\n        \\n        if(root == p || root == q){\\n            return root;\\n        }\\n        \\n        TreeNode l = lowestCommonAncestor(root.left,p,q);\\n        TreeNode r = lowestCommonAncestor(root.right,p,q);\\n        \\n        if(l != null && r != null){\\n            return root;\\n        }\\n        \\n        return l != null ? l:r;\\n \\n    }\\n}\\n\\n\\n\\nA modified version of pre-order traversal. The point to understand this is, once a sub-branch has a possible ancestor, all its super branches will have the same one.",
                "solutionTags": [],
                "code": "class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null){\\n            return null;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 168798,
                "title": "python-solution",
                "content": "Recursive:\\n```\\nclass Solution:\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not root:\\n            return\\n        elif root.val == p.val or root.val == q.val:\\n            return root\\n        l = self.lowestCommonAncestor(root.left, p, q)\\n        r = self.lowestCommonAncestor(root.right, p, q)\\n        if l and r:\\n            return root\\n        else:\\n            return l or r\\n```\\nIterative:\\n```\\nclass Solution:\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if root.val == p.val or root.val == q.val:\\n            return root\\n        queue = collections.deque([root])\\n        parent = {}\\n        while not (p in parent and q in parent):\\n            u = queue.popleft()\\n            if u.left:\\n                parent[u.left] = u\\n                queue.append(u.left)\\n            if u.right:\\n                parent[u.right] = u\\n                queue.append(u.right)\\n        \\n        res = set()\\n        trav = p\\n        while trav in parent:\\n            res.add(trav)\\n            trav = parent[trav]\\n        res.add(root)\\n        trav = q\\n        while not trav in res:\\n            trav = parent[trav]\\n        return trav\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not root:\\n            return\\n        elif root.val == p.val or root.val == q.val:\\n            return root\\n        l = self.lowestCommonAncestor(root.left, p, q)\\n        r = self.lowestCommonAncestor(root.right, p, q)\\n        if l and r:\\n            return root\\n        else:\\n            return l or r\\n```\n```\\nclass Solution:\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if root.val == p.val or root.val == q.val:\\n            return root\\n        queue = collections.deque([root])\\n        parent = {}\\n        while not (p in parent and q in parent):\\n            u = queue.popleft()\\n            if u.left:\\n                parent[u.left] = u\\n                queue.append(u.left)\\n            if u.right:\\n                parent[u.right] = u\\n                queue.append(u.right)\\n        \\n        res = set()\\n        trav = p\\n        while trav in parent:\\n            res.add(trav)\\n            trav = parent[trav]\\n        res.add(root)\\n        trav = q\\n        while not trav in res:\\n            trav = parent[trav]\\n        return trav\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65404,
                "title": "accepted-24ms-dfs-c-solution-only-3-lines",
                "content": "    class Solution {\\n    public:\\n\\t    TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q) {\\n\\t\\t    if (root == p || root == q || root == NULL) return root;\\n\\t\\t    TreeNode *left = lowestCommonAncestor(root->left, p, q), *right = lowestCommonAncestor(root->right, p, q);\\n\\t\\t    return left && right ? root : left ? left : right;\\n\\t    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n\\t    TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q) {\\n\\t\\t    if (root == p || root == q || root == NULL) return root;\\n\\t\\t    TreeNode *left = lowestCommonAncestor(root->left, p, q), *right = lowestCommonAncestor(root->right, p, q);\\n\\t\\t    return left && right ? root : left ? left : right;\\n\\t    }",
                "codeTag": "Java"
            },
            {
                "id": 1326597,
                "title": "java-o-n-easy-approach-with-explanation",
                "content": "```\\nclass Solution \\n{\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) \\n    {\\n        if(root == null)//base case when we reach to the null node \\n            return null;//returning back \\n        \\n        if(root == p || root == q)//when we are founding the desired node we are returning it and deleting the current activation record \\n            return root;\\n        \\n        TreeNode left= lowestCommonAncestor(root.left,p,q);//we are traversing the left subbtree \\n        TreeNode right= lowestCommonAncestor(root.right,p,q);//and then the right subtree is trsversed \\n        \\n        if(left != null && right != null)//when we got the lowest commont node from left and rigt subtree \\n            return root;\\n        \\n        if(left == null && right == null)//when both(left,right) are null we return null as there is no chance of getting our desired node\\n            return null;\\n        \\n        return (left != null)?left: right;//when one of the node is null it returns the node without null in order to compare with the next node \\n    }\\n}//Please do Upvote, it helps a lot\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution \\n{\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) \\n    {\\n        if(root == null)//base case when we reach to the null node \\n            return null;//returning back \\n        \\n        if(root == p || root == q)//when we are founding the desired node we are returning it and deleting the current activation record \\n            return root;\\n        \\n        TreeNode left= lowestCommonAncestor(root.left,p,q);//we are traversing the left subbtree \\n        TreeNode right= lowestCommonAncestor(root.right,p,q);//and then the right subtree is trsversed \\n        \\n        if(left != null && right != null)//when we got the lowest commont node from left and rigt subtree \\n            return root;\\n        \\n        if(left == null && right == null)//when both(left,right) are null we return null as there is no chance of getting our desired node\\n            return null;\\n        \\n        return (left != null)?left: right;//when one of the node is null it returns the node without null in order to compare with the next node \\n    }\\n}//Please do Upvote, it helps a lot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 309491,
                "title": "different-heavily-commented-javascript-solution",
                "content": "Most people have the same smart solution, but I have to admit, that one did not come naturally to me. That\\'s why I worked out this idea. It\\'s slightly less efficient and and uses some more memory, but on the other hand does not require recursion and is easy to understand.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n\\n/**\\n * @param {TreeNode} root\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {TreeNode}\\n */\\nvar lowestCommonAncestor = function(root, p, q) {\\n    var pNode;\\n    var qNode;\\n    \\n    // Search for the nodes, and add a parent chain while doing that\\n    // After finding both, go up each node\\'s parent chain till we find the\\n    // the same common ancestor for both nodes.\\n    \\n    // we will keep track of level, see why later\\n    root.level = 0;\\n    let stack = [root];\\n\\n    // while we have nodes to consider and we haven\\'t found p and q nodes yet\\n    while (stack.length && !(pNode && qNode)) {\\n        \\n        let node = stack.pop();\\n        \\n        if (node) {\\n            \\n            // check if we found the p node\\n            if (node.val === p.val) {\\n                pNode = node;\\n            }\\n            \\n            // check if we found the q node\\n            if (node.val === q.val) {\\n                qNode = node;\\n            }\\n    \\n            // consider the children. Set the level and set the node as parent\\n            if (node.right) {\\n                node.right.level = node.level + 1;\\n                node.right.parent = node;\\n                stack.push(node.right);\\n            }\\n            if (node.left) {\\n                node.left.level = node.level + 1;\\n                node.left.parent = node;\\n                stack.push(node.left);\\n            }\\n        }\\n    }\\n    \\n    // Now, for both p and q nodes we know the parent chain,\\n    // we move up the chain until it\\'s the same node. That is the LCA\\n    // To make sure we move up in the right order, we use the level property added during the dfs\\n    \\n    while (pNode.val !== qNode.val) {\\n        \\n        if (pNode.level > qNode.level) {\\n            pNode = pNode.parent;\\n        } else if (pNode.level < qNode.level) {\\n            qNode = qNode.parent;\\n        } else {\\n            qNode = qNode.parent;\\n            pNode = pNode.parent;\\n        }\\n    }\\n    \\n    return pNode;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n\\n/**\\n * @param {TreeNode} root\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {TreeNode}\\n */\\nvar lowestCommonAncestor = function(root, p, q) {\\n    var pNode;\\n    var qNode;\\n    \\n    // Search for the nodes, and add a parent chain while doing that\\n    // After finding both, go up each node\\'s parent chain till we find the\\n    // the same common ancestor for both nodes.\\n    \\n    // we will keep track of level, see why later\\n    root.level = 0;\\n    let stack = [root];\\n\\n    // while we have nodes to consider and we haven\\'t found p and q nodes yet\\n    while (stack.length && !(pNode && qNode)) {\\n        \\n        let node = stack.pop();\\n        \\n        if (node) {\\n            \\n            // check if we found the p node\\n            if (node.val === p.val) {\\n                pNode = node;\\n            }\\n            \\n            // check if we found the q node\\n            if (node.val === q.val) {\\n                qNode = node;\\n            }\\n    \\n            // consider the children. Set the level and set the node as parent\\n            if (node.right) {\\n                node.right.level = node.level + 1;\\n                node.right.parent = node;\\n                stack.push(node.right);\\n            }\\n            if (node.left) {\\n                node.left.level = node.level + 1;\\n                node.left.parent = node;\\n                stack.push(node.left);\\n            }\\n        }\\n    }\\n    \\n    // Now, for both p and q nodes we know the parent chain,\\n    // we move up the chain until it\\'s the same node. That is the LCA\\n    // To make sure we move up in the right order, we use the level property added during the dfs\\n    \\n    while (pNode.val !== qNode.val) {\\n        \\n        if (pNode.level > qNode.level) {\\n            pNode = pNode.parent;\\n        } else if (pNode.level < qNode.level) {\\n            qNode = qNode.parent;\\n        } else {\\n            qNode = qNode.parent;\\n            pNode = pNode.parent;\\n        }\\n    }\\n    \\n    return pNode;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 875568,
                "title": "python-commented-and-explained",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \\n        LCA in a binary tree..\\n        Think of it like a single node, we need to find the p and q\\n        our search will be over when we find p in our right and q in our left\\n        or vice versa, at that point, the root is the answer!\\n        \\n        \"\"\"\\n        # I have reached a dead end, I didn\\'t find anything here\\n        if not root:\\n            return None\\n        \\n        # I see one of the targets! I will inform my caller!\\n        if root == q or root == p: return root\\n        \\n        # Look in the left, if you find p or q , return yourself\\n        foundInLeft = self.lowestCommonAncestor(root.left, p, q)\\n        \\n        # Look in the right, if you find p or q , return yourself\\n        foundInRight = self.lowestCommonAncestor(root.right, p, q)\\n        \\n        # Didnt find anything in the left, must be in right\\n        if not foundInLeft: return foundInRight\\n        \\n        # Didnt find anything in the right, must be in the left\\n        if not foundInRight: return foundInLeft\\n        \\n        # Found something in both! Hence this is the one!\\n        return root\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \\n        LCA in a binary tree..\\n        Think of it like a single node, we need to find the p and q\\n        our search will be over when we find p in our right and q in our left\\n        or vice versa, at that point, the root is the answer!\\n        \\n        \"\"\"\\n        # I have reached a dead end, I didn\\'t find anything here\\n        if not root:\\n            return None\\n        \\n        # I see one of the targets! I will inform my caller!\\n        if root == q or root == p: return root\\n        \\n        # Look in the left, if you find p or q , return yourself\\n        foundInLeft = self.lowestCommonAncestor(root.left, p, q)\\n        \\n        # Look in the right, if you find p or q , return yourself\\n        foundInRight = self.lowestCommonAncestor(root.right, p, q)\\n        \\n        # Didnt find anything in the left, must be in right\\n        if not foundInLeft: return foundInRight\\n        \\n        # Didnt find anything in the right, must be in the left\\n        if not foundInRight: return foundInLeft\\n        \\n        # Found something in both! Hence this is the one!\\n        return root\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1306574,
                "title": "python-postorder-dfs-explained",
                "content": "The idea is to traverse our tree and keep auxilary function `dfs(node)`, which returns `0` if subtree do not have desired nodes and `1` if it has (one or two of them). For given `node`, we calculate information about:\\n1. `lft` is `dfs(node.left)`, that is answer for left subtree.\\n2. `rgh` is `dfs(node.right)`, that is answer for right subtree.\\n3. `mid` is true if current node is either `p` or `q`.\\n\\nThen what we need to find is such node, for which at least `2` out of these `3` values are true. Why? If `p` is parent of `q`, then the answer is `p` and we have `mid = 1` and one of the `lft` and `rgh` equal to `1`. If `q` is parent of `p`, it is similar. If we have `h` which is LCA of `p` and `q`, then for `h` we have `lft = rgh = 1` and `mid = 0`.\\n\\n#### Complexity\\n Complexity is `O(n)`, both time and space.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def lowestCommonAncestor(self, root, p, q):\\n        def dfs(node):\\n            if not node: return 0\\n\\n            lft = dfs(node.left)\\n            rgh = dfs(node.right)\\n            mid = node in [p, q]\\n            if lft + rgh + mid >= 2:\\n                self.Found = node\\n\\n            return max(lft, mid, rgh)\\n        \\n        self.Found = None\\n        dfs(root)\\n        return self.Found\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def lowestCommonAncestor(self, root, p, q):\\n        def dfs(node):\\n            if not node: return 0\\n\\n            lft = dfs(node.left)\\n            rgh = dfs(node.right)\\n            mid = node in [p, q]\\n            if lft + rgh + mid >= 2:\\n                self.Found = node\\n\\n            return max(lft, mid, rgh)\\n        \\n        self.Found = None\\n        dfs(root)\\n        return self.Found\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65341,
                "title": "share-my-5-line-java-code-with-brief-explanation",
                "content": "    /*\\n        -- \\u4ece\\u4e0a\\u5411\\u4e0b\\u641c\\u7d22, \\u9047\\u5230p\\u6216q\\u6216null, return\\u4e4b\\n        -- \\u56de\\u6eaf\\u8fc7\\u7a0b\\u4e2d, (1).\\u5de6return != null\\u4e14\\u53f3return != null (\\u5373\\u5de6p\\u53f3q\\u6216\\u5de6q\\u53f3p), \\u8bf4\\u660ecurrent root\\u662fLCA, return\\u4e4b;\\n                      (2).\\u5de6\\u53f3\\u8c01\\u4e0d\\u4e3anull\\u5c31\\u5411\\u4e0areturn\\u8c01 (\\u5373p\\u6216q, \\u6216null).\\n    */ \\n    public class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            if (root==null || root==p || root==q) { return root; }\\n            TreeNode left = lowestCommonAncestor(root.left, p, q);\\n            TreeNode right = lowestCommonAncestor(root.right, p, q);\\n            if (left!=null && right!=null) { return root; }\\n            return left!=null ? left : right;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            if (root==null || root==p || root==q) { return root; }",
                "codeTag": "Java"
            },
            {
                "id": 3628698,
                "title": "lowest-common-ancestor-of-a-binary-tree-i-ii-iii-iv-solution",
                "content": "\\n\\n# [236. Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/)\\n```\\nclass Solution {\\npublic:\\n    TreeNode* LCA(TreeNode* root, TreeNode* p, TreeNode* q){\\n        if(root == NULL || root == p || root == q)\\n            return root;\\n\\n        TreeNode* left = LCA(root->left, p, q);\\n        TreeNode* right = LCA(root->right, p, q);\\n\\n        if(left == NULL)\\n            return right;\\n        if(right == NULL)\\n            return left;\\n        else // both left and right are non NULL\\n            return root;\\n    }\\n\\n    // Both p and q exist in the tree\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        return LCA(root, p, q);\\n    }\\n};\\n```\\n\\n# [1644. Lowest Common Ancestor of a Binary Tree II](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii/description/)\\n```\\nclass Solution {\\npublic:\\n    bool find(TreeNode* root, TreeNode* x){\\n        if(root == NULL)\\n            return false;\\n        if(root == x)\\n            return true;\\n\\n        bool left = find(root->left, x);\\n        bool right = find(root->right, x);\\n\\n        if(left == true or right == true)\\n            return true;\\n        else\\n            return false;\\n    }\\n\\n    TreeNode* LCA(TreeNode* root, TreeNode* p, TreeNode* q){\\n        if(root == NULL || root == p || root == q)\\n            return root;\\n\\n        TreeNode* left = LCA(root->left, p, q);\\n        TreeNode* right = LCA(root->right, p, q);\\n\\n        if(left == NULL)\\n            return right;\\n        if(right == NULL)\\n            return left;\\n        else // both left and right are non NULL\\n            return root;\\n    }\\n\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\n        bool first = find(root, p); // finding if p exist in binary tree or not\\n        bool second = find(root, q); // finding if q exist in binary tree or not\\n\\n        if(first == false or second == false) // if one of p or q not exist in binary tree\\n            return NULL;\\n\\n        return LCA(root, p, q);    \\n    }\\n};\\n```\\n# [1650. Lowest Common Ancestor of a Binary Tree III](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/)\\n```\\nclass Solution {\\npublic:\\n    Node* lowestCommonAncestor(Node* p, Node * q) {\\n        \\n        Node* a = p;\\n        int a_depth = 0;\\n        Node* b = q;\\n        int b_depth = 0;\\n\\n        // find distance of a from the root\\n        while(a->parent){\\n            a = a->parent;\\n            a_depth++;\\n        }\\n\\n        // find distance of b from the root\\n        while(b->parent){\\n            b = b->parent;\\n            b_depth++;\\n        }\\n\\n        // if a_depth > b_depth\\n        while(a_depth > b_depth){\\n            p = p->parent;\\n            a_depth--;\\n        }\\n\\n        // if b_depth > a_depth\\n        while(b_depth > a_depth){\\n            q = q->parent;\\n            b_depth--;\\n        }\\n\\n        // now p and q are at same depth\\n        // while loop executes, only if different elements at same depth\\n        while(p != q){\\n            p = p->parent;\\n            q = q->parent;\\n        }\\n        return p;\\n    }\\n};\\n```\\n# [1676. Lowest Common Ancestor of a Binary Tree IV](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iv/description/)\\n```\\nclass Solution {\\npublic:\\n    TreeNode* LCA(TreeNode* root, TreeNode* p, TreeNode* q){\\n        if(root == NULL || root == p || root == q)\\n            return root;\\n\\n        TreeNode* left = LCA(root->left, p, q);\\n        TreeNode* right = LCA(root->right, p, q);\\n\\n        if(left == NULL)\\n            return right;\\n        if(right == NULL)\\n            return left;\\n        else // both left and right are non NULL\\n            return root;\\n    }\\n\\n    // All nodes exist in the tree\\n    TreeNode* lowestCommonAncestor(TreeNode* root, vector<TreeNode*> &nodes) {\\n        int n = nodes.size();\\n        if(nodes.size() == 1)\\n            return nodes[0];\\n        \\n        TreeNode* prev = nodes[0];\\n\\n        // finding LCA of two nodes at a time\\n        for(int i=1; i<n; i++){\\n            prev = LCA(root, prev, nodes[i]);\\n        }\\n        return prev;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* LCA(TreeNode* root, TreeNode* p, TreeNode* q){\\n        if(root == NULL || root == p || root == q)\\n            return root;\\n\\n        TreeNode* left = LCA(root->left, p, q);\\n        TreeNode* right = LCA(root->right, p, q);\\n\\n        if(left == NULL)\\n            return right;\\n        if(right == NULL)\\n            return left;\\n        else // both left and right are non NULL\\n            return root;\\n    }\\n\\n    // Both p and q exist in the tree\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        return LCA(root, p, q);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool find(TreeNode* root, TreeNode* x){\\n        if(root == NULL)\\n            return false;\\n        if(root == x)\\n            return true;\\n\\n        bool left = find(root->left, x);\\n        bool right = find(root->right, x);\\n\\n        if(left == true or right == true)\\n            return true;\\n        else\\n            return false;\\n    }\\n\\n    TreeNode* LCA(TreeNode* root, TreeNode* p, TreeNode* q){\\n        if(root == NULL || root == p || root == q)\\n            return root;\\n\\n        TreeNode* left = LCA(root->left, p, q);\\n        TreeNode* right = LCA(root->right, p, q);\\n\\n        if(left == NULL)\\n            return right;\\n        if(right == NULL)\\n            return left;\\n        else // both left and right are non NULL\\n            return root;\\n    }\\n\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\n        bool first = find(root, p); // finding if p exist in binary tree or not\\n        bool second = find(root, q); // finding if q exist in binary tree or not\\n\\n        if(first == false or second == false) // if one of p or q not exist in binary tree\\n            return NULL;\\n\\n        return LCA(root, p, q);    \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    Node* lowestCommonAncestor(Node* p, Node * q) {\\n        \\n        Node* a = p;\\n        int a_depth = 0;\\n        Node* b = q;\\n        int b_depth = 0;\\n\\n        // find distance of a from the root\\n        while(a->parent){\\n            a = a->parent;\\n            a_depth++;\\n        }\\n\\n        // find distance of b from the root\\n        while(b->parent){\\n            b = b->parent;\\n            b_depth++;\\n        }\\n\\n        // if a_depth > b_depth\\n        while(a_depth > b_depth){\\n            p = p->parent;\\n            a_depth--;\\n        }\\n\\n        // if b_depth > a_depth\\n        while(b_depth > a_depth){\\n            q = q->parent;\\n            b_depth--;\\n        }\\n\\n        // now p and q are at same depth\\n        // while loop executes, only if different elements at same depth\\n        while(p != q){\\n            p = p->parent;\\n            q = q->parent;\\n        }\\n        return p;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* LCA(TreeNode* root, TreeNode* p, TreeNode* q){\\n        if(root == NULL || root == p || root == q)\\n            return root;\\n\\n        TreeNode* left = LCA(root->left, p, q);\\n        TreeNode* right = LCA(root->right, p, q);\\n\\n        if(left == NULL)\\n            return right;\\n        if(right == NULL)\\n            return left;\\n        else // both left and right are non NULL\\n            return root;\\n    }\\n\\n    // All nodes exist in the tree\\n    TreeNode* lowestCommonAncestor(TreeNode* root, vector<TreeNode*> &nodes) {\\n        int n = nodes.size();\\n        if(nodes.size() == 1)\\n            return nodes[0];\\n        \\n        TreeNode* prev = nodes[0];\\n\\n        // finding LCA of two nodes at a time\\n        for(int i=1; i<n; i++){\\n            prev = LCA(root, prev, nodes[i]);\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 401044,
                "title": "python-solution-recursion",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n            if not root:\\n                return None\\n            if root.val==p.val or root.val==q.val:\\n                return root\\n            left= self.lowestCommonAncestor(root.left,p,q)\\n            right= self.lowestCommonAncestor(root.right,p,q)\\n            if not left:\\n                return right\\n            if not right:\\n                return left\\n            return root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n            if not root:\\n                return None\\n            if root.val==p.val or root.val==q.val:\\n                return root\\n            left= self.lowestCommonAncestor(root.left,p,q)\\n            right= self.lowestCommonAncestor(root.right,p,q)\\n            if not left:\\n                return right\\n            if not right:\\n                return left\\n            return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 285513,
                "title": "simple-c-solution-o-n-time-complexity-speed-95",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if( root == nullptr or root == p or root == q )\\n        {\\n            return root;\\n        }\\n        TreeNode* left = lowestCommonAncestor( root->left, p, q );\\n        TreeNode* right = lowestCommonAncestor( root->right, p, q );\\n        \\n        if( left == nullptr )\\n        {\\n            return right;\\n        }\\n        \\n        if( right == nullptr )\\n        {\\n            return left;\\n        }\\n        \\n        return root;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if( root == nullptr or root == p or root == q )\\n        {\\n            return root;\\n        }\\n        TreeNode* left = lowestCommonAncestor( root->left, p, q );\\n        TreeNode* right = lowestCommonAncestor( root->right, p, q );\\n        \\n        if( left == nullptr )\\n        {\\n            return right;\\n        }\\n        \\n        if( right == nullptr )\\n        {\\n            return left;\\n        }\\n        \\n        return root;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65345,
                "title": "concise-4-line-c",
                "content": "This problem only has three possible return values, root, p or q. The answer depends on whether p and q on the same subtree or not.\\n\\nFor those who find it hard to understand this solution, here is a little enlightenment: \\nThe last line of code only be executed one time in the end, we search left sub tree recursively try to find p or q whichever comes the first, if not we'll reach null and return null, same thing for the right subtree. and we compare the result in the last line of code.\\n\\n    class Solution {\\n    public:\\n        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            if (!root || root == p || root == q) return root;\\n            TreeNode* l = lowestCommonAncestor(root->left, p, q);\\n            TreeNode* r = lowestCommonAncestor(root->right, p, q);\\n            return l && r ? root : l ? l : r;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            if (!root || root == p || root == q) return root;\\n            TreeNode* l = lowestCommonAncestor(root->left, p, q);\\n            TreeNode* r = lowestCommonAncestor(root->right, p, q);\\n            return l && r ? root : l ? l : r;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2334098,
                "title": "python-lightweight-dfs-solution",
                "content": "If you ffed a node, then just return the ffed node. Otherwise, you ff the left and ff the right. It\\'s either (ffed both), or (ffed left or ffed right).\\n```python\\n        def ff(n):\\n            if n in (None, p, q): return n\\n            l, r = ff(n.left), ff(n.right)\\n            if l and r: return n\\n            else: return l or r\\n        return ff(root)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n        def ff(n):\\n            if n in (None, p, q): return n\\n            l, r = ff(n.left), ff(n.right)\\n            if l and r: return n\\n            else: return l or r\\n        return ff(root)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 859735,
                "title": "javascript-fast-and-simple",
                "content": "```\\nvar lowestCommonAncestor = function(root, p, q) {\\n  const dfs = (node) => {\\n    if (node === null) {\\n      return null;\\n    }\\n  \\n    if (node === p || node === q) {\\n      return node \\n      \\n    }\\n    \\n    const left = dfs(node.left);\\n    const right = dfs(node.right);\\n    \\n    return left && right ? node : left || right;\\n  }\\n  \\n  return dfs(root);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar lowestCommonAncestor = function(root, p, q) {\\n  const dfs = (node) => {\\n    if (node === null) {\\n      return null;\\n    }\\n  \\n    if (node === p || node === q) {\\n      return node \\n      \\n    }\\n    \\n    const left = dfs(node.left);\\n    const right = dfs(node.right);\\n    \\n    return left && right ? node : left || right;\\n  }\\n  \\n  return dfs(root);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 296984,
                "title": "c-dfs",
                "content": "```\\npublic class Solution {\\n    public TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null) return null;\\n        if (root == p || root == q) return root;\\n\\n        var left = LowestCommonAncestor(root.left, p, q);\\n        var right = LowestCommonAncestor(root.right, p, q);\\n        \\n        if (left != null && right != null) return root;\\n\\n        if (left != null) return left;\\n        if (right != null) return right;\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null) return null;\\n        if (root == p || root == q) return root;\\n\\n        var left = LowestCommonAncestor(root.left, p, q);\\n        var right = LowestCommonAncestor(root.right, p, q);\\n        \\n        if (left != null && right != null) return root;\\n\\n        if (left != null) return left;\\n        if (right != null) return right;\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65401,
                "title": "share-c-c-24ms-recursive-solution",
                "content": "C++ version\\n    \\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            if(!root)\\n                return NULL;\\n            if(root == p || root == q)\\n                return root;\\n            // Check if left contains p or q\\n            TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n            // Check if right contains p or q\\n            TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n            // if left and right containsp or q the it'sthe LCA\\n            if(left && right)\\n                return root;\\n            return left ? left : right;        \\n        }\\n\\nC#version\\n\\n    public TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null)\\n            return null;\\n        if(root == p || root == q)\\n            return root;\\n        var left = LowestCommonAncestor(root.left, p, q);\\n        var right = LowestCommonAncestor(root.right, p, q);\\n        if(left != null && right != null)\\n            return root;\\n        return left ?? right;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "C++ version\\n    \\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            if(!root)\\n                return NULL;\\n            if(root == p || root == q)\\n                return root;\\n            // Check if left contains p or q\\n            TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n            // Check if right contains p or q\\n            TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n            // if left and right containsp or q the it'sthe LCA\\n            if(left && right)\\n                return root;\\n            return left ? left : right;        \\n        }\\n\\nC#version\\n\\n    public TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null)\\n            return null;\\n        if(root == p || root == q)\\n            return root;\\n        var left = LowestCommonAncestor(root.left, p, q);\\n        var right = LowestCommonAncestor(root.right, p, q);\\n        if(left != null && right != null)\\n            return root;\\n        return left ?? right;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1636280,
                "title": "java-a-summary-on-binary-lifting-to-find-lca",
                "content": "This specific problem can be solved in `O(n)` time (where `n` is the number of TreeNodes) using parent pointers. However a potential follow-up in an interview setting can be optimizing for `m` queries. A technique called Binary Lifting can be used for this - it requires us to build a DP array in `n*log(n)` time however once that is done, each LCA query can be done in `log(n)` time.\\n\\n-----------\\n\\n**Pre-requisites**\\n\\nTo use this technique we need the following information:\\n\\n1. A unique identifier for each node (this will help with DP array computation)\\n2. The direct parent of each node\\n3. The depth/level/height of each node\\n\\nFirst, let\\'s assign a unique id for each node. I will declare two HashMaps `Map<Integer, TreeNode> map`  maps a unique id to a TreeNode and `Map<TreeNode, Integer> map2` is its inverse. We can then do a simple dfs based tree traversal and fill in labels.\\n\\n```\\nclass Solution {\\n    Map<Integer, TreeNode> map = new HashMap<>();\\n    Map<TreeNode, Integer> map2 = new HashMap<>();\\n\\tint id = 0;\\n\\t\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        fillLabels(root);\\n        // TODO\\n    }\\n\\n    // Labels each node from 0...n\\n    private void fillLabels(TreeNode root) {\\n        map2.put(root, id);\\n        map.put(id, root);\\n        id++;\\n        \\n        if(root.left != null) {\\n            fillLabels(root.left);\\n        }\\n        if(root.right != null) {\\n            fillLabels(root.right);\\n        }\\n    }\\n}\\n```\\n\\nOnce this is done, we can fill in the following by doing another dfs based traversal: \\n1. The direct parent of each node - this will be stored in an array `parent[i]` that gives the direct parent of node i.\\n2. The level/height/depth of a node\\n\\n```\\nclass Solution {\\n    Map<Integer, TreeNode> map = new HashMap<>();\\n    Map<TreeNode, Integer> map2 = new HashMap<>();\\n    \\n    Map<Integer, Integer> levels = new HashMap<>();\\n    int id = 0;\\n    int[] parent;\\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        fillLabels(root);\\n        \\n        parent = new int[map.size()];\\n        parent[0] = -1;\\n        levels.put(0, 0);\\n        fillLevelsAndParent(root);\\n\\t\\t// TODO\\n    }\\n\\t\\n    // Record level information and fill parent array\\n    private void fillLevelsAndParent(TreeNode root) {\\n        int rootVal = map2.get(root);\\n        int nextLevel = levels.get(rootVal) + 1;\\n        \\n        if(root.left != null) {\\n            int leftVal = map2.get(root.left);\\n            parent[leftVal] = rootVal;\\n            levels.put(leftVal, nextLevel);\\n            fillLevelsAndParent(root.left);\\n        }\\n        \\n        if(root.right != null) {\\n            int rightVal = map2.get(root.right);\\n            parent[rightVal] = rootVal;\\n            levels.put(rightVal, nextLevel);\\n            fillLevelsAndParent(root.right);\\n        }\\n    }\\n    \\n    // Labels each node from 0...n\\n    private void fillLabels(TreeNode root) { ... }\\n```\\n\\n-----\\n\\n**Kth ancestor of a TreeNode**\\n\\nOur next objective is to find the Kth ancestor of a TreeNode - this is a separate problem on Leetcode (LC-1483) linked [here](https://leetcode.com/problems/kth-ancestor-of-a-tree-node/). \\n\\nSimilar to the LCA problem, you can solve this in `O(n)` if there is just one query however if there are `m` queries, you need to do this in a better way. The idea is using a DP table to pre-compute ancestors of a node. There are a couple of different ways to approach this problem.\\n\\n**Method 1:** If the number of nodes are small you can define a function `f(i, j)` that returns the `ith` ancestor of a node with id `j`. The recurrence relation is as follows:\\n\\n```\\nf(i, j) = -1 // if parent[j] = -1\\nf(i, j) = parent[j] // if i == 1\\nf(i, j) = f(i-1, parent[j]) // otherwise\\n```\\n\\nUsing this recurrence we can construct a DP array in `O(n^2)` time and space. Once constructed, queries are extremely fast and can be done in constant time. However if the number of nodes are large and `n^2` is too much, this will not work - hence we use method 2.\\n\\n**Method 2:**  Here we re-define our function as follows: Define `f(i, j)` as a function that returns the `2^jth` parent of node `i`. The recurrence relation is as follows:\\n\\n```\\nf(j, i) = parent[i] // if j = 0\\nf(j, i) = f(j-1, f(j-1, i)) // otherwise (assuming f(j-1, i) is not -1)\\n```\\n\\nNow since there exist only `n` nodes, we can make at most `n` jumps. Since we are storing ancestors in powers of 2, we can make at most `log(n)` jumps in the worst case.\\n \\nThe dp array can be initialized as follows:\\n\\n```\\n    private void initializeCache() {\\n        int n = parent.length;\\n        int logN =  (int) (Math.log(n)/Math.log(2))+1;\\n        dp =  new int[logN][n];\\n        \\n        for(int i = 0; i<logN; i++) {\\n            for(int j = 0; j<n; j++) {\\n                if(i == 0)\\n                    dp[i][j] = parent[j];\\n                else if(dp[i-1][j] == -1)\\n                    dp[i][j] = -1;\\n                else\\n                    dp[i][j] = dp[i-1][dp[i-1][j]];\\n            }\\n        }\\n    }\\n```\\n\\nThe idea here is to use the binary value of `k` to make jumps and get the `kth` ancestor. Let\\'s say you want to get the 13th ancestor of a node `x`. Any number can be represented in binary form so 13 is: `1101`. This is the equivalent of the following: \\n\\n13 = `1* 2^3 + 1* 2^2 + 0* 2^1 + 1* 2^0`\\n\\nSo to find the 13th ancestor of k, we can do the following: \\n- get the `2^0th` ancestor of `k` stored in `dp[0][k]` let\\'s call this `k1`\\n- get the `2^2th` ancestor of `k1` stored in `dp[2][k1]` let\\'s call this `k2`\\n-  get the `3^3th` ancestor of `k2` stored in `dp[3][k2]` let\\'s call this `k3`\\n\\nAnd we are done.\\n\\n```\\n    private int kthAncestor(int node, int k) {\\n        String binaryString = Integer.toBinaryString(k);\\n        int currentNode = node;\\n        int powerOfTwo = 0;\\n        \\n        for(int i = binaryString.length()-1; i>=0; i--) {\\n            if(binaryString.charAt(i) == \\'1\\')\\n                currentNode = dp[powerOfTwo][currentNode];\\n            if(currentNode == -1)\\n                return -1;\\n            powerOfTwo++;\\n        }\\n        return currentNode;\\n    }\\n```\\n\\n---------\\n\\n**Getting the LCA of two Nodes**\\n\\nFinally we have everything we need to get the LCA.\\n\\n**Step 1:** Ensure both nodes are on the same level. We can do this in `log(n)` time - get the height/depth of the two nodes. Find the levelDifference between the 2. Then use the `kthAncestor(node, levelDifference)` to move the lower node to the same level.\\n\\n```\\n    private void normalizeLevels(int p, int q) {\\n        if(levels.get(p) == levels.get(q)) {\\n            node1 = p;\\n            node2 = q;\\n            return;\\n        }\\n        if(levels.get(p) < levels.get(q)) {\\n            normalizeLevels(q, p);\\n            return;\\n        }\\n        \\n        int levelDifference = levels.get(p) - levels.get(q);\\n        p = kthAncestor(p, levelDifference);\\n        node1 = p;\\n        node2 = q;\\n    }\\n```\\n\\nThe end result of this function is that two nodes with ids `node1` and `node2` are on the same level of the tree. This has been done in `log(n)` time.\\n\\n**Step 2:** Find the LCA of `node1` and `node2`. The challenge is doing this in log(n) complexity. To do this we need to think about what happens when we make a jump.\\n\\nLet\\'s say I make an arbitrary size jump and update the values the values of `node1` and `node2` accordingly. Assuming the LCA is `nodeX`, if I made a jump directly to `nodeX` or a jump greater than that to something above `nodeX`, then `node1 == node2`. However if I made a smaller jump then `node1 != node2`.\\n\\nThe idea is to make the largest jumps possible such that `node1 != node2` in a loop until we cannot make any more jumps.\\n\\n- The largest jump posible is a jump of size `n` which is `2^(log(n))`\\n\\t-  If we overshoot (which we will), dont make the jump.\\n\\t-  Otherwise make the jump\\n- Next make a jump of size `2^(log(n)-1)`\\n\\t- If we overshoot, do not make the jump. Else make the jump.\\n- Keep doing this until `2^0`\\n\\nIn the end the direct parent of any of the nodes is the LCA.\\n\\n```\\n    private void getLca() {\\n        if(node1 == node2)\\n            return;\\n        int n = map.size();\\n        int start = (int) (Math.log(n)/Math.log(2));\\n        \\n        for(int i = start; i>=0; i--) {\\n            int pNode1 = kthAncestor(node1, i);\\n            int pNode2 = kthAncestor(node2, i);\\n            \\n            if(pNode1 == pNode2) {\\n                continue;           // do not do the jump\\n            } else {                // do the jump\\n                node1 = pNode1;\\n                node2 = pNode2;\\n            }\\n        }\\n    }\\n```\\n\\nAnd we are done!\\n\\n------------\\n\\n**Full code**\\n\\nPutting it all together we have the following solution:\\n\\n- Time Complexity: n* log(n) to build the DP array and log(n) for each query\\n- Spacr Complxity: n* log(n) for the DP array\\n\\nCode:\\n\\n```\\nclass Solution {\\n    Map<Integer, TreeNode> map = new HashMap<>();\\n    Map<TreeNode, Integer> map2 = new HashMap<>();\\n    \\n    Map<Integer, Integer> levels = new HashMap<>();\\n    int id = 0;\\n    int[] parent;\\n    int[][] dp;\\n    \\n    int node1;\\n    int node2;\\n    \\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        fillLabels(root);\\n        \\n        parent = new int[map.size()];\\n        parent[0] = -1;\\n        levels.put(0, 0);\\n        fillLevelsAndParent(root);\\n        \\n        initializeCache();        \\n        normalizeLevels(map2.get(p), map2.get(q));\\n        getLca();\\n        \\n        if(node1 == node2)\\n            return map.get(node1);\\n        else\\n            return map.get(parent[node1]);\\n    }\\n    \\n    private void getLca() {\\n        if(node1 == node2)\\n            return;\\n        int n = map.size();\\n        int start = (int) (Math.log(n)/Math.log(2));\\n        \\n        for(int i = start; i>=0; i--) {\\n            int pNode1 = kthAncestor(node1, i);\\n            int pNode2 = kthAncestor(node2, i);\\n            \\n            if(pNode1 == pNode2) {\\n                continue;           // do not do the jump\\n            } else {                // do the jump\\n                node1 = pNode1;\\n                node2 = pNode2;\\n            }\\n        }\\n    }\\n    \\n    private void normalizeLevels(int p, int q) {\\n        if(levels.get(p) == levels.get(q)) {\\n            node1 = p;\\n            node2 = q;\\n            return;\\n        }\\n        if(levels.get(p) < levels.get(q)) {\\n            normalizeLevels(q, p);\\n            return;\\n        }\\n        \\n        int levelDifference = levels.get(p) - levels.get(q);\\n        p = kthAncestor(p, levelDifference);\\n        node1 = p;\\n        node2 = q;\\n    }\\n    \\n    private int kthAncestor(int node, int k) {\\n        String binaryString = Integer.toBinaryString(k);\\n        int currentNode = node;\\n        int powerOfTwo = 0;\\n        \\n        for(int i = binaryString.length()-1; i>=0; i--) {\\n            if(binaryString.charAt(i) == \\'1\\')\\n                currentNode = dp[powerOfTwo][currentNode];\\n            if(currentNode == -1)\\n                return -1;\\n            powerOfTwo++;\\n        }\\n        return currentNode;\\n    }\\n    \\n    /*\\n        Let f(i, j) return 2^ith ancestor of node j\\n            f(i, j) = parent[j]         // if i = 0\\n            f(i, j) = f(i-1, f(i-1, j)) // otherwise (assuming f(i-1, j) != -1)\\n    */\\n    private void initializeCache() {\\n        int n = parent.length;\\n        int logN =  (int) (Math.log(n)/Math.log(2))+1;\\n        dp =  new int[logN][n];\\n        \\n        for(int i = 0; i<logN; i++) {\\n            for(int j = 0; j<n; j++) {\\n                if(i == 0)\\n                    dp[i][j] = parent[j];\\n                else if(dp[i-1][j] == -1)\\n                    dp[i][j] = -1;\\n                else\\n                    dp[i][j] = dp[i-1][dp[i-1][j]];\\n            }\\n        }\\n    }\\n    \\n    // Record level information and fill parent array\\n    private void fillLevelsAndParent(TreeNode root) {\\n        int rootVal = map2.get(root);\\n        int nextLevel = levels.get(rootVal) + 1;\\n        \\n        if(root.left != null) {\\n            int leftVal = map2.get(root.left);\\n            parent[leftVal] = rootVal;\\n            levels.put(leftVal, nextLevel);\\n            fillLevelsAndParent(root.left);\\n        }\\n        \\n        if(root.right != null) {\\n            int rightVal = map2.get(root.right);\\n            parent[rightVal] = rootVal;\\n            levels.put(rightVal, nextLevel);\\n            fillLevelsAndParent(root.right);\\n        }\\n    }\\n    \\n    // Labels each node from 0...n\\n    private void fillLabels(TreeNode root) {\\n        map2.put(root, id);\\n        map.put(id, root);\\n        id++;\\n        \\n        if(root.left != null) {\\n            fillLabels(root.left);\\n        }\\n        if(root.right != null) {\\n            fillLabels(root.right);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Map<Integer, TreeNode> map = new HashMap<>();\\n    Map<TreeNode, Integer> map2 = new HashMap<>();\\n\\tint id = 0;\\n\\t\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        fillLabels(root);\\n        // TODO\\n    }\\n\\n    // Labels each node from 0...n\\n    private void fillLabels(TreeNode root) {\\n        map2.put(root, id);\\n        map.put(id, root);\\n        id++;\\n        \\n        if(root.left != null) {\\n            fillLabels(root.left);\\n        }\\n        if(root.right != null) {\\n            fillLabels(root.right);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    Map<Integer, TreeNode> map = new HashMap<>();\\n    Map<TreeNode, Integer> map2 = new HashMap<>();\\n    \\n    Map<Integer, Integer> levels = new HashMap<>();\\n    int id = 0;\\n    int[] parent;\\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        fillLabels(root);\\n        \\n        parent = new int[map.size()];\\n        parent[0] = -1;\\n        levels.put(0, 0);\\n        fillLevelsAndParent(root);\\n\\t\\t// TODO\\n    }\\n\\t\\n    // Record level information and fill parent array\\n    private void fillLevelsAndParent(TreeNode root) {\\n        int rootVal = map2.get(root);\\n        int nextLevel = levels.get(rootVal) + 1;\\n        \\n        if(root.left != null) {\\n            int leftVal = map2.get(root.left);\\n            parent[leftVal] = rootVal;\\n            levels.put(leftVal, nextLevel);\\n            fillLevelsAndParent(root.left);\\n        }\\n        \\n        if(root.right != null) {\\n            int rightVal = map2.get(root.right);\\n            parent[rightVal] = rootVal;\\n            levels.put(rightVal, nextLevel);\\n            fillLevelsAndParent(root.right);\\n        }\\n    }\\n    \\n    // Labels each node from 0...n\\n    private void fillLabels(TreeNode root) { ... }\\n```\n```\\nf(i, j) = -1 // if parent[j] = -1\\nf(i, j) = parent[j] // if i == 1\\nf(i, j) = f(i-1, parent[j]) // otherwise\\n```\n```\\nf(j, i) = parent[i] // if j = 0\\nf(j, i) = f(j-1, f(j-1, i)) // otherwise (assuming f(j-1, i) is not -1)\\n```\n```\\n    private void initializeCache() {\\n        int n = parent.length;\\n        int logN =  (int) (Math.log(n)/Math.log(2))+1;\\n        dp =  new int[logN][n];\\n        \\n        for(int i = 0; i<logN; i++) {\\n            for(int j = 0; j<n; j++) {\\n                if(i == 0)\\n                    dp[i][j] = parent[j];\\n                else if(dp[i-1][j] == -1)\\n                    dp[i][j] = -1;\\n                else\\n                    dp[i][j] = dp[i-1][dp[i-1][j]];\\n            }\\n        }\\n    }\\n```\n```\\n    private int kthAncestor(int node, int k) {\\n        String binaryString = Integer.toBinaryString(k);\\n        int currentNode = node;\\n        int powerOfTwo = 0;\\n        \\n        for(int i = binaryString.length()-1; i>=0; i--) {\\n            if(binaryString.charAt(i) == \\'1\\')\\n                currentNode = dp[powerOfTwo][currentNode];\\n            if(currentNode == -1)\\n                return -1;\\n            powerOfTwo++;\\n        }\\n        return currentNode;\\n    }\\n```\n```\\n    private void normalizeLevels(int p, int q) {\\n        if(levels.get(p) == levels.get(q)) {\\n            node1 = p;\\n            node2 = q;\\n            return;\\n        }\\n        if(levels.get(p) < levels.get(q)) {\\n            normalizeLevels(q, p);\\n            return;\\n        }\\n        \\n        int levelDifference = levels.get(p) - levels.get(q);\\n        p = kthAncestor(p, levelDifference);\\n        node1 = p;\\n        node2 = q;\\n    }\\n```\n```\\n    private void getLca() {\\n        if(node1 == node2)\\n            return;\\n        int n = map.size();\\n        int start = (int) (Math.log(n)/Math.log(2));\\n        \\n        for(int i = start; i>=0; i--) {\\n            int pNode1 = kthAncestor(node1, i);\\n            int pNode2 = kthAncestor(node2, i);\\n            \\n            if(pNode1 == pNode2) {\\n                continue;           // do not do the jump\\n            } else {                // do the jump\\n                node1 = pNode1;\\n                node2 = pNode2;\\n            }\\n        }\\n    }\\n```\n```\\nclass Solution {\\n    Map<Integer, TreeNode> map = new HashMap<>();\\n    Map<TreeNode, Integer> map2 = new HashMap<>();\\n    \\n    Map<Integer, Integer> levels = new HashMap<>();\\n    int id = 0;\\n    int[] parent;\\n    int[][] dp;\\n    \\n    int node1;\\n    int node2;\\n    \\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        fillLabels(root);\\n        \\n        parent = new int[map.size()];\\n        parent[0] = -1;\\n        levels.put(0, 0);\\n        fillLevelsAndParent(root);\\n        \\n        initializeCache();        \\n        normalizeLevels(map2.get(p), map2.get(q));\\n        getLca();\\n        \\n        if(node1 == node2)\\n            return map.get(node1);\\n        else\\n            return map.get(parent[node1]);\\n    }\\n    \\n    private void getLca() {\\n        if(node1 == node2)\\n            return;\\n        int n = map.size();\\n        int start = (int) (Math.log(n)/Math.log(2));\\n        \\n        for(int i = start; i>=0; i--) {\\n            int pNode1 = kthAncestor(node1, i);\\n            int pNode2 = kthAncestor(node2, i);\\n            \\n            if(pNode1 == pNode2) {\\n                continue;           // do not do the jump\\n            } else {                // do the jump\\n                node1 = pNode1;\\n                node2 = pNode2;\\n            }\\n        }\\n    }\\n    \\n    private void normalizeLevels(int p, int q) {\\n        if(levels.get(p) == levels.get(q)) {\\n            node1 = p;\\n            node2 = q;\\n            return;\\n        }\\n        if(levels.get(p) < levels.get(q)) {\\n            normalizeLevels(q, p);\\n            return;\\n        }\\n        \\n        int levelDifference = levels.get(p) - levels.get(q);\\n        p = kthAncestor(p, levelDifference);\\n        node1 = p;\\n        node2 = q;\\n    }\\n    \\n    private int kthAncestor(int node, int k) {\\n        String binaryString = Integer.toBinaryString(k);\\n        int currentNode = node;\\n        int powerOfTwo = 0;\\n        \\n        for(int i = binaryString.length()-1; i>=0; i--) {\\n            if(binaryString.charAt(i) == \\'1\\')\\n                currentNode = dp[powerOfTwo][currentNode];\\n            if(currentNode == -1)\\n                return -1;\\n            powerOfTwo++;\\n        }\\n        return currentNode;\\n    }\\n    \\n    /*\\n        Let f(i, j) return 2^ith ancestor of node j\\n            f(i, j) = parent[j]         // if i = 0\\n            f(i, j) = f(i-1, f(i-1, j)) // otherwise (assuming f(i-1, j) != -1)\\n    */\\n    private void initializeCache() {\\n        int n = parent.length;\\n        int logN =  (int) (Math.log(n)/Math.log(2))+1;\\n        dp =  new int[logN][n];\\n        \\n        for(int i = 0; i<logN; i++) {\\n            for(int j = 0; j<n; j++) {\\n                if(i == 0)\\n                    dp[i][j] = parent[j];\\n                else if(dp[i-1][j] == -1)\\n                    dp[i][j] = -1;\\n                else\\n                    dp[i][j] = dp[i-1][dp[i-1][j]];\\n            }\\n        }\\n    }\\n    \\n    // Record level information and fill parent array\\n    private void fillLevelsAndParent(TreeNode root) {\\n        int rootVal = map2.get(root);\\n        int nextLevel = levels.get(rootVal) + 1;\\n        \\n        if(root.left != null) {\\n            int leftVal = map2.get(root.left);\\n            parent[leftVal] = rootVal;\\n            levels.put(leftVal, nextLevel);\\n            fillLevelsAndParent(root.left);\\n        }\\n        \\n        if(root.right != null) {\\n            int rightVal = map2.get(root.right);\\n            parent[rightVal] = rootVal;\\n            levels.put(rightVal, nextLevel);\\n            fillLevelsAndParent(root.right);\\n        }\\n    }\\n    \\n    // Labels each node from 0...n\\n    private void fillLabels(TreeNode root) {\\n        map2.put(root, id);\\n        map.put(id, root);\\n        id++;\\n        \\n        if(root.left != null) {\\n            fillLabels(root.left);\\n        }\\n        if(root.right != null) {\\n            fillLabels(root.right);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65304,
                "title": "java-iterative-solution-with-1-stack",
                "content": "The idea is when finding p or q the first time current stack must contain LCA. So when stack size is decreased the pop node could be the LCA if another node (p or q) is found under it.\\n```\\npublic class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null|| root == p || root == q) return root;\\n\\n        TreeNode n = root;\\n        TreeNode res = null;\\n        int size = -1;\\n        Stack<TreeNode> s = new Stack<TreeNode>();\\n        while (n!=null || !s.empty()) {\\n            while (n!=null) {\\n                s.push(n);\\n                if (n == p || n == q) {\\n                    if (res == null) { //find p or q the first time\\n                        res = n;\\n                        size = s.size();\\n                    } else return res; //find both p and q\\n                }\\n                n = n.left;\\n            }\\n            n = s.pop();\\n            if (s.size() < size) {\\n                size = s.size();\\n                res = n;\\n            }\\n            n = n.right;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null|| root == p || root == q) return root;\\n\\n        TreeNode n = root;\\n        TreeNode res = null;\\n        int size = -1;\\n        Stack<TreeNode> s = new Stack<TreeNode>();\\n        while (n!=null || !s.empty()) {\\n            while (n!=null) {\\n                s.push(n);\\n                if (n == p || n == q) {\\n                    if (res == null) { //find p or q the first time\\n                        res = n;\\n                        size = s.size();\\n                    } else return res; //find both p and q\\n                }\\n                n = n.left;\\n            }\\n            n = s.pop();\\n            if (s.size() < size) {\\n                size = s.size();\\n                res = n;\\n            }\\n            n = n.right;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65319,
                "title": "my-4-lines-java-solution",
                "content": "Just blind try left and right. Then if we find in both left and right side return root, otherwise return the one we got.\\n\\n        if (root == p || root == q || root == null) { return root; }\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n        return (left != null && right != null) ? root : (left != null ? left : right);",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "Just blind try left and right. Then if we find in both left and right side return root, otherwise return the one we got.\\n\\n        if (root == p || root == q || root == null) { return root; }\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n        return (left != null && right != null) ? root : (left != null ? left : right);",
                "codeTag": "Unknown"
            },
            {
                "id": 1222599,
                "title": "c-intuition-for-building-the-optimal-solution-step-by-step",
                "content": "## Basic Idea\\nAs described in the problem, the Lowest Common Ancestor of a two nodes in a tree is the last common node on the path from the root to p and q. Basically, there can be three cases for a particular node of the tree, depending on the position of p and q relative to it:\\n1. If p and q are in different subtrees of the node. (For eg p is in left subtree and q is in right subtree, and vice versa).\\n2. If either of p and q is equal to the node.\\n3. If p and q are in the same subtree of the current node. (For eg both p and q are in left subtree, or right subtree).\\n\\nWe will return the current node as the LCA for cases 1 and 2, and recursively call the LCA function on the corresponding subtree for case 3.\\n\\nSo for implementing the solution, we need two functions, one main function for finding the LCA, and one auxiliary function for finding the positions of p and q in the subtrees.\\n<br>\\n## Approach 1: Full Recursion (Accepted but very slow)\\nThe most naive approach would be to go full recursion on this, from the find function to the LCA function.\\n```\\nbool find(TreeNode *root, TreeNode *toFind) {\\n\\tif(!root) return false;\\n\\tif(root != toFind) {\\n\\t\\treturn find(root->left, toFind) || find(root->right, toFind);\\n\\t}\\n\\telse {\\n\\t\\treturn root;\\n\\t}\\n}\\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\tif(!root) return nullptr;\\n\\t// four cases\\n\\tif(find(root->left, p)) {\\n\\t\\tif(find(root->right, q)) {\\n\\t\\t\\t//root is LCA\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t\\telse if(find(root->left, q)){\\n\\t\\t\\t//both are in one subtree\\n\\t\\t\\treturn lowestCommonAncestor(root->left, p, q);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t//root is q;\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t}\\n\\telse if(find(root->right, p)){\\n\\t\\tif(find(root->left, q)) {\\n\\t\\t\\t//root is LCA\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t\\telse if(find(root->right, q)){\\n\\t\\t\\t//both are in same subtree\\n\\t\\t\\treturn lowestCommonAncestor(root->right, p, q);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t//q is root\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t}\\n\\telse {\\n\\t\\t//p is root;\\n\\t\\t//no matter where q is, p is LCA\\n\\t\\treturn p;\\n\\t}\\n}\\n```\\n![Runtime and Memory usage: Approach 1](https://assets.leetcode.com/users/images/63373146-7220-447c-bb62-50f528dfc4a2_1621654422.2065408.png)\\n\\n**Complexity**\\n\\nTime: O(n) (proved at the end)\\nSpace: O(n)\\nAs you can see, this solution barely passed, so it will certainly not cut it.\\n<br>\\n\\n## Approach 2: Optimize Most Called Recursive Function\\n\\nThe next step would be to optimise our most called recursive function (i.e find()).\\nAs the recursion of find() is not tail recursion (i.e only one recursive call per function call), we can\\'t eliminate the stack completely, hence we still have to use a stack to keep track of the roots of the subtrees being processed. However, we save a little on space by using this approach (although not asymptotically) by eliminating the program stack from the picture.\\n\\n```\\nbool find(TreeNode *root, TreeNode *toFind) {\\n\\tif(!root) return false;\\n\\tstack<TreeNode *> nodes;\\n\\tnodes.push(root);\\n\\twhile(!nodes.empty()) {\\n\\t\\tTreeNode *curr = nodes.top();\\n\\t\\tnodes.pop();\\n\\t\\tif(curr == toFind) return true;\\n\\t\\tif(curr->left) nodes.push(curr->left);\\n\\t\\tif(curr->right) nodes.push(curr->right);\\n\\t}\\n\\treturn false;\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/ba239023-ff4b-4c99-95b9-98967c04f95c_1621655084.0239727.png)\\n\\n**Complexity**\\nSame as previous solution\\n<br>\\n\\n## Approach 3: Some Observations and Complete Iteration\\nWe can clearly see that the recursion in our main LCA function is tail recursion, since there is only one recursive call from the function per run. Hence it can be easily converted to iteration, without even using a stack, we just modify the root variable directly for each subcall.\\nAlso, some optimizations we can make are:\\n1. Check if p or q is the root first, then we don\\'t even need to call the find() function, and the answer is root, no matter what.\\n2. Make subcases based on whether the left and right subtree of the current node exist, to avoid making calls to find() with an empty subtree.\\n\\nThis way, we can minimize the number of calls to our costly function (O(n)) and thus save on runtime a little (again, not asymptotically).\\nHence the worst case for this algorithm would be very difficult to reach, and the average case performance would be good.\\n\\n```\\nbool find(TreeNode *root, TreeNode *toFind) {\\n\\tif(!root) return false;\\n\\tstack<TreeNode *> nodes;\\n\\tnodes.push(root);\\n\\twhile(!nodes.empty()) {\\n\\t\\tTreeNode *curr = nodes.top();\\n\\t\\tnodes.pop();\\n\\t\\tif(curr == toFind) return true;\\n\\t\\tif(curr->left) nodes.push(curr->left);\\n\\t\\tif(curr->right) nodes.push(curr->right);\\n\\t}\\n\\treturn false;\\n}\\nTreeNode* lowestCommonAncestor(TreeNode* r, TreeNode* p, TreeNode* q) {\\n\\tTreeNode *root = r;\\n\\twhile(root) {\\n\\t\\t// four cases\\n\\t\\tif(root == p) return p;\\n\\t\\telse if(root == q) return q;\\n\\t\\tif(root->left) {\\n\\t\\t\\tif(root->right) {\\n\\t\\t\\t\\tif(find(root->left, p)) {\\n\\t\\t\\t\\t\\tif(find(root->left, q)) {\\n\\t\\t\\t\\t\\t\\troot = root->left;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\treturn root;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tif(find(root->right, q)) {\\n\\t\\t\\t\\t\\t\\troot = root->right;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\treturn root;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\t//no right child\\n\\t\\t\\t\\troot = root->left;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t//no left child\\n\\t\\t\\tif(root->right) {\\n\\t\\t\\t\\troot = root->right;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\t//error\\n\\t\\t\\t\\treturn nullptr;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn nullptr;\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/6b5bf1ef-2316-4aab-b715-ab8a34761c52_1621655611.5542002.png)\\n\\n**Complexity**\\nTime:  O(n) (proved below)\\nSpace: O(n)\\n\\n**Upvote** if you liked this post, and feel free to ask any doubts, or suggest any corrections/improvements in the comments.\\nI\\'m also a learner like everyone here, so if you find a mistake in this post, please point it out.\\n\\n**Edit:**\\nI just did a thorough analysis of the time complexity of my solution, and found out that it should be O(n), not O(nlogn) (:D). Sorry for any confusion caused by this. :(\\n\\nHere is the proof for the same:\\nStarting from the root, we make two calls of find (one for each subtree) so a total of O(n) operations here. Then we either return the result, or in the worst case, have to recurse further, to either the left or right subtree (only one of those). So the number of nodes is halved on average.\\nHence the next step costs O(n/2) and so on.\\nThus in the case of a mostly balanced tree, the total complexity is:\\n```n + n/2 + n/4 + .... + 1 = n (2 - 1/n) ``` (by Geometric Progression)\\n i.e O(2n - 1) ~ **O(n)**.\\n \\n Now for the case of skewed trees. Let\\'s assume that the tree is reduced to a linked list on the right. (i.e no nodes have left child). \\n In this case, we don\\'t even call find function, because we are bound to reach a situation where either of p or q is the root and the other is its right child.\\n Hence the complexity in this case is similar to that of traversing a linked list i.e **O(n)**.\\n \\n Since all possible cases fall between these two extremes, the complexity is **O(n)**\\n \\n Hence the time and space complexity of the same is O(n).",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool find(TreeNode *root, TreeNode *toFind) {\\n\\tif(!root) return false;\\n\\tif(root != toFind) {\\n\\t\\treturn find(root->left, toFind) || find(root->right, toFind);\\n\\t}\\n\\telse {\\n\\t\\treturn root;\\n\\t}\\n}\\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\tif(!root) return nullptr;\\n\\t// four cases\\n\\tif(find(root->left, p)) {\\n\\t\\tif(find(root->right, q)) {\\n\\t\\t\\t//root is LCA\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t\\telse if(find(root->left, q)){\\n\\t\\t\\t//both are in one subtree\\n\\t\\t\\treturn lowestCommonAncestor(root->left, p, q);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t//root is q;\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t}\\n\\telse if(find(root->right, p)){\\n\\t\\tif(find(root->left, q)) {\\n\\t\\t\\t//root is LCA\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t\\telse if(find(root->right, q)){\\n\\t\\t\\t//both are in same subtree\\n\\t\\t\\treturn lowestCommonAncestor(root->right, p, q);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t//q is root\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t}\\n\\telse {\\n\\t\\t//p is root;\\n\\t\\t//no matter where q is, p is LCA\\n\\t\\treturn p;\\n\\t}\\n}\\n```\n```\\nbool find(TreeNode *root, TreeNode *toFind) {\\n\\tif(!root) return false;\\n\\tstack<TreeNode *> nodes;\\n\\tnodes.push(root);\\n\\twhile(!nodes.empty()) {\\n\\t\\tTreeNode *curr = nodes.top();\\n\\t\\tnodes.pop();\\n\\t\\tif(curr == toFind) return true;\\n\\t\\tif(curr->left) nodes.push(curr->left);\\n\\t\\tif(curr->right) nodes.push(curr->right);\\n\\t}\\n\\treturn false;\\n}\\n```\n```\\nbool find(TreeNode *root, TreeNode *toFind) {\\n\\tif(!root) return false;\\n\\tstack<TreeNode *> nodes;\\n\\tnodes.push(root);\\n\\twhile(!nodes.empty()) {\\n\\t\\tTreeNode *curr = nodes.top();\\n\\t\\tnodes.pop();\\n\\t\\tif(curr == toFind) return true;\\n\\t\\tif(curr->left) nodes.push(curr->left);\\n\\t\\tif(curr->right) nodes.push(curr->right);\\n\\t}\\n\\treturn false;\\n}\\nTreeNode* lowestCommonAncestor(TreeNode* r, TreeNode* p, TreeNode* q) {\\n\\tTreeNode *root = r;\\n\\twhile(root) {\\n\\t\\t// four cases\\n\\t\\tif(root == p) return p;\\n\\t\\telse if(root == q) return q;\\n\\t\\tif(root->left) {\\n\\t\\t\\tif(root->right) {\\n\\t\\t\\t\\tif(find(root->left, p)) {\\n\\t\\t\\t\\t\\tif(find(root->left, q)) {\\n\\t\\t\\t\\t\\t\\troot = root->left;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\treturn root;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tif(find(root->right, q)) {\\n\\t\\t\\t\\t\\t\\troot = root->right;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\treturn root;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\t//no right child\\n\\t\\t\\t\\troot = root->left;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t//no left child\\n\\t\\t\\tif(root->right) {\\n\\t\\t\\t\\troot = root->right;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\t//error\\n\\t\\t\\t\\treturn nullptr;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn nullptr;\\n}\\n```\n```n + n/2 + n/4 + .... + 1 = n (2 - 1/n) ```",
                "codeTag": "Unknown"
            },
            {
                "id": 133665,
                "title": "generic-solution-find-common-ancestor-of-k-nodes-in-an-n-ary-tree",
                "content": "```java\\nclass Solution {\\n    \\n    public List<TreeNode> children(TreeNode node) {\\n        List<TreeNode> list = new ArrayList<>();\\n        list.add(node.left);\\n        list.add(node.right);\\n        //list.add(node.child3);\\n        //list.add(node.child4);\\n        //....\\n        return list;\\n    }\\n    \\n    public TreeNode find(TreeNode root, Set<TreeNode> toFind) {\\n        \\n        if (toFind.isEmpty() || root == null) return null;\\n        \\n        boolean matchingNode = false;\\n        if (toFind.contains(root)) {\\n            toFind.remove(root);\\n            if (toFind.isEmpty()) return root;\\n            matchingNode = true;\\n        }\\n        \\n        for (TreeNode child: children(root)) {\\n            int matched = toFind.size();\\n            TreeNode node = find(child, toFind);\\n            if (toFind.isEmpty()) {\\n                if(matchingNode) return root;\\n                else return node;\\n            } else if (matched != toFind.size()) {\\n                matchingNode = true;\\n            }\\n        }\\n        \\n        return null;\\n    }\\n    \\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        Set<TreeNode> toFind = new HashSet<>(); \\n        toFind.add(p);\\n        toFind.add(q);\\n        //toFind.add(r);\\n        //.....\\n        return find(root, toFind);\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    \\n    public List<TreeNode> children(TreeNode node) {\\n        List<TreeNode> list = new ArrayList<>();\\n        list.add(node.left);\\n        list.add(node.right);\\n        //list.add(node.child3);\\n        //list.add(node.child4);\\n        //....\\n        return list;\\n    }\\n    \\n    public TreeNode find(TreeNode root, Set<TreeNode> toFind) {\\n        \\n        if (toFind.isEmpty() || root == null) return null;\\n        \\n        boolean matchingNode = false;\\n        if (toFind.contains(root)) {\\n            toFind.remove(root);\\n            if (toFind.isEmpty()) return root;\\n            matchingNode = true;\\n        }\\n        \\n        for (TreeNode child: children(root)) {\\n            int matched = toFind.size();\\n            TreeNode node = find(child, toFind);\\n            if (toFind.isEmpty()) {\\n                if(matchingNode) return root;\\n                else return node;\\n            } else if (matched != toFind.size()) {\\n                matchingNode = true;\\n            }\\n        }\\n        \\n        return null;\\n    }\\n    \\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        Set<TreeNode> toFind = new HashSet<>(); \\n        toFind.add(p);\\n        toFind.add(q);\\n        //toFind.add(r);\\n        //.....\\n        return find(root, toFind);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1307685,
                "title": "lca-of-a-binary-tree-1-2-and-4-same-code-c-explained",
                "content": "This code will help for three questions:\\n* [Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)\\n* [Lowest Common Ancestor of a Binary Tree II](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii/)\\n* [Lowest Common Ancestor of a Binary Tree IV](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iv/)\\n\\n**The Idea**\\n\\nFor all these questions, we are supposed to find the Lowest Common Ancestors for a number of given nodes. \\n1. [**I**](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/) and [**II**](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii/) require you to find the LCA for a total of 2 given nodes (both of them will surely exist in **I** but might not exist in **II**)\\n2. [**IV**](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iv/) gives you a array of nodes to find LCA for, so will have some array.length() number of nodes.\\n\\nIf we traverse the tree recursively and try to find the existence of these nodes, then while moving up the recursive tree, we can find the ancestor.\\n\\nLets see how this works.\\n* Create a function which returns the number of nodes found in the current tree starting from the given root.\\n* In the function definition, we find the number of nodes found in the left subtree, `leftNodesFoun` and number of nodes in the right subtree, `leftNodesFound` and store it in `ans = leftNodesFound + rightNodesFound`\\n* If the current root is the one to be found, we increment the ans, `ans++`. To access the current root in O(1) we will store the required nodes in a map or a set (This makes more sense for **IV** where n number of nodes are given)\\n* Finally, if the ans is equal to the number of nodes found, the current root will be our LCA. (Since, we are moving up the tree, as soon as we find all the required nodes, that particular root has to be the LCA)\\n* This code is common for all the three variations of the LCA mentioned above.\\n\\nThe Code for the above defined function:\\n```\\n    TreeNode* parent = NULL;\\n    unordered_map<TreeNode*, bool> mp;\\n    int helper(TreeNode* root, int totalNodes){\\n        if (!root){\\n            return 0;\\n        }\\n        \\n        int leftNodesFound = helper(root->left, totalNodes);\\n        int rightNodesFound = helper(root->right, totalNodes);\\n        \\n        int ans = leftNodesFound + rightNodesFound;\\n        \\n        if (mp[root]){\\n            ans++;\\n        }\\n        \\n        if (ans == totalNodes){\\n\\t\\t\\t//We only want to store the first root when all the nodes are found\\n            if(!parent){\\n                parent = root;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\n\\n**Caller Functions for each of the questions:**\\n1. [Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/) and [Lowest Common Ancestor of a Binary Tree II](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii/)\\n\\nHere, the number of nodes is 2 and we store the nodes p and q in a map defined in the snippet above.\\n\\n```\\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        mp[p] = true;\\n        mp[q] = true;\\n        helper(root, 2);\\n        return parent;\\n    }\\n```\\n\\n2. [Lowest Common Ancestor of a Binary Tree IV](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iv/)\\n\\nHere, the number of nodes will be equal to `nodes.size()` and we store each node in the map.\\n\\n```\\nTreeNode* lowestCommonAncestor(TreeNode* root, vector<TreeNode*> &nodes) {\\n        for (auto node: nodes){\\n            mp[node] = true;\\n        }\\n        helper(root, nodes.size());\\n        return parent;\\n    }\\n```\\n\\nThe same code will help you solve 3 Medium quesions, Please Upvote!!!\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n    TreeNode* parent = NULL;\\n    unordered_map<TreeNode*, bool> mp;\\n    int helper(TreeNode* root, int totalNodes){\\n        if (!root){\\n            return 0;\\n        }\\n        \\n        int leftNodesFound = helper(root->left, totalNodes);\\n        int rightNodesFound = helper(root->right, totalNodes);\\n        \\n        int ans = leftNodesFound + rightNodesFound;\\n        \\n        if (mp[root]){\\n            ans++;\\n        }\\n        \\n        if (ans == totalNodes){\\n\\t\\t\\t//We only want to store the first root when all the nodes are found\\n            if(!parent){\\n                parent = root;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```\n```\\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        mp[p] = true;\\n        mp[q] = true;\\n        helper(root, 2);\\n        return parent;\\n    }\\n```\n```\\nTreeNode* lowestCommonAncestor(TreeNode* root, vector<TreeNode*> &nodes) {\\n        for (auto node: nodes){\\n            mp[node] = true;\\n        }\\n        helper(root, nodes.size());\\n        return parent;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 65364,
                "title": "my-python-recursion-and-iteration-solution-easy-and-fast",
                "content": "Iteration:\\n\\n    enter code hereclass Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        while root:\\n            if not root or root==p or root==q:\\n                return root\\n            if self.isnode(p,q):\\n                return p\\n            if self.isnode(q,p):\\n                return q\\n            if self.isnode(root.left,p) and self.isnode(root.left,q):\\n                root=root.left\\n            if self.isnode(root.right,p) and self.isnode(root.right,q):\\n                root=root.right\\n            else:\\n                return root\\n                \\n        \\n    def isnode(self,mother,child):\\n        if mother:\\n            if mother==child:\\n                return True\\n            else:\\n                return self.isnode(mother.left,child) or self.isnode(mother.right,child)\\n        return False        \\n\\nrecursion:\\n\\n    enter code hereclass Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        \\n        if not root or root==p or root==q:\\n            return root\\n            \\n        if self.isnode(p,q):\\n            return p\\n        if self.isnode(q,p):\\n            return q\\n            \\n        if self.isnode(root.left,p) and self.isnode(root.left,q):\\n            return self.lowestCommonAncestor(root.left, p, q)\\n        elif self.isnode(root.right,p) and self.isnode(root.right,q):\\n            return self.lowestCommonAncestor(root.right, p, q)\\n        else:\\n            return root\\n                \\n        \\n    def isnode(self,mother,child):\\n        if mother:\\n            if mother==child:\\n                return True\\n            else:\\n                return self.isnode(mother.left,child) or self.isnode(mother.right,child)\\n        return False",
                "solutionTags": [],
                "code": "Iteration:\\n\\n    enter code hereclass Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        while root:\\n            if not root or root==p or root==q:\\n                return root\\n            if self.isnode(p,q):\\n                return p\\n            if self.isnode(q,p):\\n                return q\\n            if self.isnode(root.left,p) and self.isnode(root.left,q):\\n                root=root.left\\n            if self.isnode(root.right,p) and self.isnode(root.right,q):\\n                root=root.right\\n            else:\\n                return root\\n                \\n        \\n    def isnode(self,mother,child):\\n        if mother:\\n            if mother==child:\\n                return True\\n            else:\\n                return self.isnode(mother.left,child) or self.isnode(mother.right,child)\\n        return False        \\n\\nrecursion:\\n\\n    enter code hereclass Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        \\n        if not root or root==p or root==q:\\n            return root\\n            \\n        if self.isnode(p,q):\\n            return p\\n        if self.isnode(q,p):\\n            return q\\n            \\n        if self.isnode(root.left,p) and self.isnode(root.left,q):\\n            return self.lowestCommonAncestor(root.left, p, q)\\n        elif self.isnode(root.right,p) and self.isnode(root.right,q):\\n            return self.lowestCommonAncestor(root.right, p, q)\\n        else:\\n            return root\\n                \\n        \\n    def isnode(self,mother,child):\\n        if mother:\\n            if mother==child:\\n                return True\\n            else:\\n                return self.isnode(mother.left,child) or self.isnode(mother.right,child)\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 65387,
                "title": "java-build-the-paths-in-stacks-from-nodes-to-root-with-dfs-return-the-first-crossing-point-on-paths",
                "content": "    public class Solution {\\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n    \\tStack<TreeNode> pStack = new Stack<TreeNode>();\\n    \\tStack<TreeNode> qStack = new Stack<TreeNode>();\\n    \\tTreeNode target = null;\\n    \\tif (findPath(root, p, pStack) && findPath(root, q, qStack)) {\\n     \\t\\twhile (!pStack.isEmpty()) {\\n     \\t\\t\\tTreeNode pNode = pStack.pop();\\n    \\t\\t\\tif (qStack.contains(pNode))\\n    \\t\\t\\t\\ttarget = pNode;\\n    \\t\\t}\\n    \\t} \\n    \\treturn target;\\n    }\\n\\n\\tprivate boolean findPath(TreeNode root, TreeNode node, Stack<TreeNode> stack) {\\n\\t\\tif (root == null)\\n\\t\\t\\treturn false;\\n\\t\\tif (root == node) {\\n\\t\\t\\tstack.push(root);\\n\\t\\t\\treturn true;\\n\\t\\t} else {\\n\\t\\t\\tif (findPath(root.left, node, stack) ||  findPath(root.right, node, stack)) {\\n\\t\\t\\t    stack.push(root);\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n    \\tStack<TreeNode> pStack = new Stack<TreeNode>();\\n    \\tStack<TreeNode> qStack = new Stack<TreeNode>();\\n    \\tTreeNode target = null;\\n    \\tif (findPath(root, p, pStack) && findPath(root, q, qStack)) {\\n     \\t\\twhile (!pStack.isEmpty()) {\\n     \\t\\t\\tTreeNode pNode = pStack.pop();\\n    \\t\\t\\tif (qStack.contains(pNode))\\n    \\t\\t\\t\\ttarget = pNode;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1817260,
                "title": "simple-python-recursive-solution-with-explanation",
                "content": "The logic here is to check for every node, whether p or q belong to that root\\'s subtree. \\nIf the root val is equal to either p or q, we know that the root is definitely one of it\\'s ancestors. We simply return it.\\nOne important point to note is that for a given root, if p or q are part of subtree, we return root, implying that that is an ancestor. If not, we return ```null```.  \\nWe do this recursively on the left and right subtrees of a given root.\\nIf both left and right return a non null value, we know that\\'s the lowest common ancestor. \\nIf left returns null and right returns non null, we know that the answer lies within the right subtree.\\n\\n```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if not root:\\n            return None\\n        \\n        if root.val == p.val or root.val == q.val:\\n            return root\\n        \\n        left = self.lowestCommonAncestor(root.left, p, q)\\n        right = self.lowestCommonAncestor(root.right, p, q)\\n        \\n        if left and right:\\n            return root\\n        if not left and not right:\\n            return None\\n        \\n        return left if left else right\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```null```",
                "codeTag": "Unknown"
            },
            {
                "id": 1614047,
                "title": "beginner-friendly-java-javascript-python-solution-explanation-with-examples",
                "content": "**Explanation :**\\n**Eg - 1**\\n![image](https://assets.leetcode.com/users/images/ca40fd95-4b47-4607-ac1f-73d32e9bd6b0_1658796345.975119.png)\\n\\n**Eg-2**\\n![image](https://assets.leetcode.com/users/images/0f24f084-61b1-4180-998a-77d02a3be449_1658796439.1572185.png)\\n\\n**Java**\\n```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null || root == p || root == q)  return root;\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n        return left == null ? right : right == null ? left : root;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar lowestCommonAncestor = function(root, p, q) {\\n    if(!root || root == p || root == q)  return root\\n    let left = lowestCommonAncestor(root.left, p, q)\\n    let right = lowestCommonAncestor(root.right, p, q)\\n    return left && right ? root : left || right\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        if not root or root == p or root == q:\\n            return root\\n        left = self.lowestCommonAncestor(root.left, p, q)\\n        right = self.lowestCommonAncestor(root.right, p, q)\\n        return root if left and right else left or right\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null || root == p || root == q)  return root;\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n        return left == null ? right : right == null ? left : root;\\n    }\\n}\\n```\n```\\nvar lowestCommonAncestor = function(root, p, q) {\\n    if(!root || root == p || root == q)  return root\\n    let left = lowestCommonAncestor(root.left, p, q)\\n    let right = lowestCommonAncestor(root.right, p, q)\\n    return left && right ? root : left || right\\n};\\n```\n```\\nclass Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        if not root or root == p or root == q:\\n            return root\\n        left = self.lowestCommonAncestor(root.left, p, q)\\n        right = self.lowestCommonAncestor(root.right, p, q)\\n        return root if left and right else left or right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140471,
                "title": "literal-recursion-in-python",
                "content": "```\\ndef lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        \\n        def dfs(node):\\n            if node in (None, p, q):\\n                return node\\n            \\n            llca, rlca = dfs(node.left), dfs(node.right)\\n            return node if llca and rlca else llca or rlca\\n        \\n        return dfs(root)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\ndef lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        \\n        def dfs(node):\\n            if node in (None, p, q):\\n                return node\\n            \\n            llca, rlca = dfs(node.left), dfs(node.right)\\n            return node if llca and rlca else llca or rlca\\n        \\n        return dfs(root)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 65334,
                "title": "simple-c-solution-easy-to-understand",
                "content": "    vector<TreeNode*> path, path1, path2;\\n\\n    void find_in_tree(TreeNode *root, TreeNode *p, TreeNode *q) {\\n        if (!root) return;\\n        path.push_back(root);\\n        if (root == p) {\\n            path1 = path;\\n        } else if (root == q) {\\n            path2 = path;\\n        }\\n        find_in_tree(root->left, p, q);\\n        find_in_tree(root->right, p, q);\\n        path.pop_back();\\n    }\\n\\n    TreeNode* lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q) {\\n        find_in_tree(root, p, q);\\n        int min_size = min(path1.size(), path2.size());\\n        for (int i = 0; i < min_size; i++) {\\n            if (path1[i] != path2[i]) return path1[i - 1]; \\n        }\\n        return path1[min_size - 1];\\n    }",
                "solutionTags": [],
                "code": "    vector<TreeNode*> path, path1, path2;\\n\\n    void find_in_tree(TreeNode *root, TreeNode *p, TreeNode *q) {\\n        if (!root) return;\\n        path.push_back(root);\\n        if (root == p) {\\n            path1 = path;\\n        } else if (root == q) {\\n            path2 = path;\\n        }\\n        find_in_tree(root->left, p, q);\\n        find_in_tree(root->right, p, q);\\n        path.pop_back();\\n    }\\n\\n    TreeNode* lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q) {\\n        find_in_tree(root, p, q);\\n        int min_size = min(path1.size(), path2.size());\\n        for (int i = 0; i < min_size; i++) {\\n            if (path1[i] != path2[i]) return path1[i - 1]; \\n        }\\n        return path1[min_size - 1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 65397,
                "title": "simple-recursive-solution-in-c-no-helper-func-needed",
                "content": "    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root == NULL){\\n            return NULL;\\n        }\\n        if(root == p || root == q)\\n        {\\n            return root;\\n        }\\n        \\n        TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n\\n        if(left != NULL && right != NULL)\\n        {\\n            return root;\\n        }\\n        else if(left == NULL && right == NULL)\\n        {\\n            return NULL;\\n        }\\n        \\n        return left != NULL ? left : right;\\n    }",
                "solutionTags": [],
                "code": "    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root == NULL){\\n            return NULL;\\n        }\\n        if(root == p || root == q)\\n        {\\n            return root;\\n        }\\n        \\n        TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n\\n        if(left != NULL && right != NULL)\\n        {\\n            return root;\\n        }\\n        else if(left == NULL && right == NULL)\\n        {\\n            return NULL;\\n        }\\n        \\n        return left != NULL ? left : right;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2339073,
                "title": "js-intuitive-dfs-recursion-in-4-lines",
                "content": "```\\nvar lowestCommonAncestor = function(root, p, q) {\\n    if(!root || root.val == p.val || root.val == q.val) return root;\\n    \\n    let left = lowestCommonAncestor(root.left, p, q);\\n    let right = lowestCommonAncestor(root.right, p, q);\\n\\n    return (left && right) ? root : left || right;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar lowestCommonAncestor = function(root, p, q) {\\n    if(!root || root.val == p.val || root.val == q.val) return root;\\n    \\n    let left = lowestCommonAncestor(root.left, p, q);\\n    let right = lowestCommonAncestor(root.right, p, q);\\n\\n    return (left && right) ? root : left || right;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2286878,
                "title": "java-soln-6-lines-dfs",
                "content": "## Approach\\nWe can do a DFS search in the tree to locate our two nodes, the node which receives some kind of non-null result from its left and right searches will be the lowest ancestor of the required nodes. If we don\\'t get non-null response from both left & right subtree then we just return the result as it is.\\n\\n## Complexities\\n**Time: O(n)\\nSpace: O(h)**\\n\\n## Code\\n```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null) return null;\\n        if(root == p || root == q) return root;\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n        if(left != null && right != null) return root;\\n        return left == null ? right : left;\\n    }\\n}\\n```\\n\\nPlease **upvote** if this helped, thanks!",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null) return null;\\n        if(root == p || root == q) return root;\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n        if(left != null && right != null) return root;\\n        return left == null ? right : left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1404818,
                "title": "efficient-naive-approach-explained-logic",
                "content": "# Naive Approach:\\nTo find the LCA we store the root to Node path using path function in a ArrayList, we run this func. for both p and q. Once we\\'ve stored the path into an ArrayList, we can traverse over all the nodes in both the lists and the last common element would be the LCA.  \\n```\\nclass Solution {\\n    \\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        ArrayList<TreeNode> p1 = new ArrayList<>();\\n        ArrayList<TreeNode> p2 = new ArrayList<>();\\n        path(root, p, p1);\\n        path(root, q, p2);\\n        int i = 0;\\n        while(i<p1.size() && i<p2.size() && p1.get(i) == p2.get(i)){\\n            i++;\\n        }\\n        return p1.get(i-1);\\n    }\\n    public boolean path(TreeNode root, TreeNode node, ArrayList<TreeNode> list){\\n        if(root == null) return false;\\n        list.add(root);\\n        if(root == node) return true;\\n        if(path(root.left, node, list) || path(root.right, node, list)){\\n            return true;\\n        }\\n        list.remove(list.size()-1);//Taaki faltu chars na store ho :P\\n        return false;\\n    }   \\n}\\n```\\nBut this isn\\'t space optimized. Let\\'s look at a space optimized approach.\\n# Efficient Approach:\\nLooking at this problem, might seem hard at first. Now to solve it lets consider a node, and breakdown the problem into few cases:\\nCase 1: The node we\\'re considering is null, now obviously we won\\'t be able to reach anywhere with null node, so just return null;\\nCase 2: if the node we\\'re holding is either p or q, if we have found p, Now this is the case \"where we allow a node to be a descendant of itself\". this node is the LCA here\\nCase 3: Now if the above two cases do not work let\\'s try considering the left and right subtree of this node, here if LeftSubtree(l in the code) returns any of p or q (definitely not null) and right subtree provides returns any of p or q (opposite to left subtree and definitely not null), the node would be the LCA.\\nCase 4: when if either of subtree returns a not null value and other provides a null value, our problem reduces to that tree only, hence just return the root of the subtree).\\n\\n```\\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null) return null; // Case 1\\n        if(root == p || root == q) return root; // Case 2\\n        TreeNode l = lowestCommonAncestor(root.left, p, q);\\n        TreeNode r = lowestCommonAncestor(root.right, p, q);\\n\\n        if(l!=null && r!=null) return root; // Case 3\\n        else // Case 4\\n        {\\n            if(l!=null) return l;\\n            else return r;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        ArrayList<TreeNode> p1 = new ArrayList<>();\\n        ArrayList<TreeNode> p2 = new ArrayList<>();\\n        path(root, p, p1);\\n        path(root, q, p2);\\n        int i = 0;\\n        while(i<p1.size() && i<p2.size() && p1.get(i) == p2.get(i)){\\n            i++;\\n        }\\n        return p1.get(i-1);\\n    }\\n    public boolean path(TreeNode root, TreeNode node, ArrayList<TreeNode> list){\\n        if(root == null) return false;\\n        list.add(root);\\n        if(root == node) return true;\\n        if(path(root.left, node, list) || path(root.right, node, list)){\\n            return true;\\n        }\\n        list.remove(list.size()-1);//Taaki faltu chars na store ho :P\\n        return false;\\n    }   \\n}\\n```\n```\\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null) return null; // Case 1\\n        if(root == p || root == q) return root; // Case 2\\n        TreeNode l = lowestCommonAncestor(root.left, p, q);\\n        TreeNode r = lowestCommonAncestor(root.right, p, q);\\n\\n        if(l!=null && r!=null) return root; // Case 3\\n        else // Case 4\\n        {\\n            if(l!=null) return l;\\n            else return r;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1306524,
                "title": "c-simple-and-easy-clean-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool rec(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (!root) return false;\\n        \\n        int in_left = rec(root->left, p, q);\\n        int in_right = rec(root->right, p, q);\\n        int curr = (root == p) || (root == q);\\n        \\n        if ((in_left && in_right) || (in_left && curr) || (in_right && curr))\\n            res = root;\\n        \\n        return in_left || in_right || curr;\\n    }\\n    \\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        rec(root, p, q);\\n        return res;\\n    }\\n    \\nprivate:\\n    TreeNode* res;\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool rec(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (!root) return false;\\n        \\n        int in_left = rec(root->left, p, q);\\n        int in_right = rec(root->right, p, q);\\n        int curr = (root == p) || (root == q);\\n        \\n        if ((in_left && in_right) || (in_left && curr) || (in_right && curr))\\n            res = root;\\n        \\n        return in_left || in_right || curr;\\n    }\\n    \\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        rec(root, p, q);\\n        return res;\\n    }\\n    \\nprivate:\\n    TreeNode* res;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65340,
                "title": "java-easy-solution-beats-72",
                "content": "    /**\\n     * Definition for a binary tree node.\\n     * public class TreeNode {\\n     *     int val;\\n     *     TreeNode left;\\n     *     TreeNode right;\\n     *     TreeNode(int x) { val = x; }\\n     * }\\n     */\\n    public class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            if(root==null) return null;\\n            if(root==p) return root;\\n            if(root==q) return root;\\n            TreeNode left = lowestCommonAncestor(root.left, p, q);\\n            TreeNode right = lowestCommonAncestor(root.right, p, q);\\n            if(left!=null&&right!=null){\\n                return root;\\n            }else{\\n                return left==null?right:left;\\n            }\\n        }\\n        \\n        \\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            if(root==null) return null;\\n            if(root==p) return root;\\n            if(root==q) return root;\\n            TreeNode left = lowestCommonAncestor(root.left, p, q);\\n            TreeNode right = lowestCommonAncestor(root.right, p, q);\\n            if(left!=null&&right!=null){\\n                return root;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 65278,
                "title": "my-solution-may-be-not-so-good-but-clear",
                "content": "First, we use a map to save the node  and its parent for all nodes.\\nThis saves all the path from leaves to the root.\\nSecond, from Node p ,we climb to the root to form a Route of Nodes \\nFinally , let the q goes up until it touches the route.\\n\\n    public class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        HashMap<TreeNode,TreeNode> m = new HashMap<TreeNode,TreeNode>();\\n        // bfs walking tree\\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n        queue.offer(root);\\n        while(queue.peek()!=null){\\n            TreeNode t = queue.poll();\\n            if(t.left!=null){\\n                m.put(t.left,t);\\n                queue.offer(t.left);\\n            }\\n            if(t.right!=null){\\n                m.put(t.right,t);\\n                queue.offer(t.right);\\n            }\\n        }\\n        // build route\\n        Set<TreeNode> l = new HashSet<TreeNode>();\\n        TreeNode pp = p;\\n        while(pp!=root){\\n            l.add(pp);\\n            pp = m.get(pp);\\n        }\\n        l.add(root);\\n        TreeNode qq = q;\\n        while(!l.contains(qq)){\\n            qq = m.get(qq);\\n        }\\n        return qq;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        HashMap<TreeNode,TreeNode> m = new HashMap<TreeNode,TreeNode>();\\n        // bfs walking tree\\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n        queue.offer(root);\\n        while(queue.peek()!=null){\\n            TreeNode t = queue.poll();\\n            if(t.left!=null){\\n                m.put(t.left,t);\\n                queue.offer(t.left);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 65451,
                "title": "my-c-solution-using-dfs",
                "content": "To get the LCA(Lowest Common Ancestor) of TreeNode p and q, the algorithm works as following:  \\n1. Use dfs to calculate the depth and parent for each TreeNode;  \\n2. Suppose depth[p] > depth[q], then let d = depth[p]-depth[q], first move p upwards d times and then move both p and q upwards until p and q point to the same node, which is the LCA of p and q;\\n\\n    class Solution {\\n    public:\\n        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            unordered_map<TreeNode*, int> depth;\\n            unordered_map<TreeNode*, TreeNode*> parent;\\n            dfs(root, NULL, 0, depth, parent);\\n            if (depth[p] < depth[q])\\n                swap(p, q);\\n            int d = depth[p]-depth[q];\\n            for (int i=0; i<d; i++)\\n                p = parent[p];\\n            while (p != q) {\\n                q = parent[q];\\n                p = parent[p];\\n            }\\n            return p;\\n        }\\n        void dfs(TreeNode* node, TreeNode* p, int d, \\n            unordered_map<TreeNode*, int>& depth, \\n            unordered_map<TreeNode*, TreeNode*>& parent) {\\n            if (!node) return;\\n            depth[node] = d;\\n            parent[node] = p;\\n            dfs(node->left, node, d+1, depth, parent);\\n            dfs(node->right, node, d+1, depth, parent);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            unordered_map<TreeNode*, int> depth;\\n            unordered_map<TreeNode*, TreeNode*> parent;\\n            dfs(root, NULL, 0, depth, parent);\\n            if (depth[p] < depth[q])\\n                swap(p, q);\\n            int d = depth[p]-depth[q];\\n            for (int i=0; i<d; i++)\\n                p = parent[p];\\n            while (p != q) {\\n                q = parent[q];\\n                p = parent[p];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2228778,
                "title": "clean-simple-c-solution-beats-80-submissions",
                "content": "Steps -\\n1. Start from root node and for each node, do the following steps\\n2. Return NULL if the node is NULL (base case).\\n2. Return the node itself when it is equal to anyone of the node to be found out.\\n3. Recursively call the function for left and right children of each node.\\n4. If the returned node from both left and right children are not NULL, then our current node is the Lowest Common Ancestor and so we return current node\\n5. Else the Lowest Common Ancestor is the that node which is not NULL (from left and right children)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) \\n    {\\n        if (root==NULL)\\n            return NULL;\\n        \\n        if (root == p || root == q)\\n            return root;\\n        \\n        TreeNode * l = lowestCommonAncestor (root->left, p, q);\\n        TreeNode * r = lowestCommonAncestor (root->right, p, q);\\n        \\n        if (l && r)\\n            return root;\\n        \\n        if (l)\\n            return l;\\n        \\n        else\\n            return r;\\n    }\\n};\\n```\\n\\nFeel free to ask any question in the comment section.\\nI hope that you found the solution useful.\\nIf so, please do upvote and encourage me. \\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) \\n    {\\n        if (root==NULL)\\n            return NULL;\\n        \\n        if (root == p || root == q)\\n            return root;\\n        \\n        TreeNode * l = lowestCommonAncestor (root->left, p, q);\\n        TreeNode * r = lowestCommonAncestor (root->right, p, q);\\n        \\n        if (l && r)\\n            return root;\\n        \\n        if (l)\\n            return l;\\n        \\n        else\\n            return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1554869,
                "title": "c-recursive-one-pass-solution-code-commented",
                "content": "**Time: O(n)\\nSpace: O(n)**\\n\\n**upvote if you find this helpful. Thanks:)**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        // if root == null or current node is equal to either p or q \\n        if(!root || (root->val == p->val) || (root->val==q->val)){\\n            return root;\\n        }\\n        \\n        // search in left and right subtree, basically postorder traversal\\n        TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n        \\n        // check condition\\n        if(left==nullptr && right==nullptr){// if left and right subtree doesn\\'t contain p or q\\n            return nullptr; \\n        }\\n        if(left && right){// if p and q are present in left and right subtree\\n            return root;\\n        }\\n        \\n        // if left subtree contains both p and q return the LCA node returned from left subtree\\n        // else it is present in right subtree\\n        return (left!=nullptr)?left:right;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        // if root == null or current node is equal to either p or q \\n        if(!root || (root->val == p->val) || (root->val==q->val)){\\n            return root;\\n        }\\n        \\n        // search in left and right subtree, basically postorder traversal\\n        TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n        \\n        // check condition\\n        if(left==nullptr && right==nullptr){// if left and right subtree doesn\\'t contain p or q\\n            return nullptr; \\n        }\\n        if(left && right){// if p and q are present in left and right subtree\\n            return root;\\n        }\\n        \\n        // if left subtree contains both p and q return the LCA node returned from left subtree\\n        // else it is present in right subtree\\n        return (left!=nullptr)?left:right;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1376667,
                "title": "c-solution-recursive-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* solve(TreeNode* root, TreeNode* p, TreeNode* q){\\n        if(root == NULL) return NULL;\\n        if(root->val  == p->val || root->val == q->val){\\n            return root;\\n        }\\n        TreeNode* l = lowestCommonAncestor(root->left, p, q);\\n         TreeNode* r = lowestCommonAncestor(root->right, p, q);\\n        if(l != NULL && r != NULL){\\n            return root;\\n        }\\n        else if(l != NULL){\\n            return l;\\n        }\\n        else{\\n            return r;\\n        }\\n    }\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        return solve(root, p, q);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* solve(TreeNode* root, TreeNode* p, TreeNode* q){\\n        if(root == NULL) return NULL;\\n        if(root->val  == p->val || root->val == q->val){\\n            return root;\\n        }\\n        TreeNode* l = lowestCommonAncestor(root->left, p, q);\\n         TreeNode* r = lowestCommonAncestor(root->right, p, q);\\n        if(l != NULL && r != NULL){\\n            return root;\\n        }\\n        else if(l != NULL){\\n            return l;\\n        }\\n        else{\\n            return r;\\n        }\\n    }\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        return solve(root, p, q);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1259151,
                "title": "explained-solution-asked-by-microsoft-amazon-twitter-with-complexities",
                "content": "```\\n// \\t\\t\\t\\t\\t*** EXPLANATION ***:\\n// We\\'ll do just normal tree traversal of the given binary tree recursivly.  \\n// To finding LCA (lowest common ancestor) we\\'ve following conditions for every node in the tree that...\\n// But before that, this solutions works under the assumption that both Node \\'p\\' & Node \\'q\\' will present in the tree...\\n//  if only one of the node is present in the tree it\\'ll not work or simply return null... \\n\\n// CONDITIONS: -\\t\\t\\t\\t\\t\\t\\t\\t\\n// 1. if current node is same as \\'p\\' OR \\'q\\'.\\n// 2. if one of it\\'s subtrees contains \\'p\\' and other \\'q\\' (subtrees means, left_sub_tree and right_sub_tree).\\n// 3. if one of it\\'s subtree contains both \\'p\\' & \\'q\\'.\\n// 4. if none of it\\'s subtrees contains any of \\'p\\' & \\'q\\'.\\n\\n// however, that\\'s a tricky implementation, but works well under the assumption that \\'p\\' & \\'q\\' will definitely present.\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\t\\t\\n\\t\\tif(root == NULL)\\n\\t\\t\\treturn NULL;\\n\\n\\t\\tif(root->val == p->val || root->val == q->val)       // \\uD83D\\uDC49 FIRST CONDITION...\\n\\t\\t\\treturn root;\\n\\n\\t\\tTreeNode* lca1 = lowestCommonAncestor(root->left, p, q);    // traverse on the left part of the tree\\n\\t\\tTreeNode* lca2 = lowestCommonAncestor(root->right, p, q);   // traverse on the right part of the tree\\n\\n\\t\\tif(lca1 != NULL && lca2 != NULL)                    // \\uD83D\\uDC49 SECOND CONDITION... (IF BOTH SUB-TREE CONTAINS \\'p\\' & \\'q\\' RESPECTIVELY)\\n\\t\\t\\treturn root;\\n\\t\\t\\n\\t\\tif(lca1 != NULL)                                   // \\uD83D\\uDC49 THIRD CONDITION...\\n\\t\\t\\treturn lca1;\\n\\t\\telse\\n\\t\\t\\treturn lca2;\\t\\t\\t\\t\\t\\t\\t\\t\\t// \\uD83D\\uDC49 FOURTH CONDITION...\\n    }\\n};\\n```\\n\\n**TIME COMPLEXITY : O(N), Where N, total number of nodes in the tree\\nSPACE COMPLEXITY : O(H) , Where H, total height of tree for recursion stack**\\n\\nif you **find any mistakes pls**, drop a comment\\nif it makes any sense don\\'t forget to **Upvote**",
                "solutionTags": [],
                "code": "```\\n// \\t\\t\\t\\t\\t*** EXPLANATION ***:\\n// We\\'ll do just normal tree traversal of the given binary tree recursivly.  \\n// To finding LCA (lowest common ancestor) we\\'ve following conditions for every node in the tree that...\\n// But before that, this solutions works under the assumption that both Node \\'p\\' & Node \\'q\\' will present in the tree...\\n//  if only one of the node is present in the tree it\\'ll not work or simply return null... \\n\\n// CONDITIONS: -\\t\\t\\t\\t\\t\\t\\t\\t\\n// 1. if current node is same as \\'p\\' OR \\'q\\'.\\n// 2. if one of it\\'s subtrees contains \\'p\\' and other \\'q\\' (subtrees means, left_sub_tree and right_sub_tree).\\n// 3. if one of it\\'s subtree contains both \\'p\\' & \\'q\\'.\\n// 4. if none of it\\'s subtrees contains any of \\'p\\' & \\'q\\'.\\n\\n// however, that\\'s a tricky implementation, but works well under the assumption that \\'p\\' & \\'q\\' will definitely present.\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\t\\t\\n\\t\\tif(root == NULL)\\n\\t\\t\\treturn NULL;\\n\\n\\t\\tif(root->val == p->val || root->val == q->val)       // \\uD83D\\uDC49 FIRST CONDITION...\\n\\t\\t\\treturn root;\\n\\n\\t\\tTreeNode* lca1 = lowestCommonAncestor(root->left, p, q);    // traverse on the left part of the tree\\n\\t\\tTreeNode* lca2 = lowestCommonAncestor(root->right, p, q);   // traverse on the right part of the tree\\n\\n\\t\\tif(lca1 != NULL && lca2 != NULL)                    // \\uD83D\\uDC49 SECOND CONDITION... (IF BOTH SUB-TREE CONTAINS \\'p\\' & \\'q\\' RESPECTIVELY)\\n\\t\\t\\treturn root;\\n\\t\\t\\n\\t\\tif(lca1 != NULL)                                   // \\uD83D\\uDC49 THIRD CONDITION...\\n\\t\\t\\treturn lca1;\\n\\t\\telse\\n\\t\\t\\treturn lca2;\\t\\t\\t\\t\\t\\t\\t\\t\\t// \\uD83D\\uDC49 FOURTH CONDITION...\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 395340,
                "title": "python-iterative-dfs-beats-98-94-in-time-and-100-in-space",
                "content": "Simply use DFS to search for `p` and `q`, and record their paths once hit, then just compare the two paths and you will find the lowest common ancestor!\\n```python\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        stack, p_trace, q_trace = [], [], []\\n\\t\\t\\n        while True:\\n            if root.left:\\n                stack.append(root)\\n                root.left, root = None, root.left\\n            elif root.right:\\n                stack.append(root)\\n                root.right, root = None, root.right\\n            else:\\n                if root is p:\\n                    p_trace = stack[:]\\n                    p_trace.append(root)\\n                if root is q:\\n                    q_trace = stack[:]\\n                    q_trace.append(root)\\n                if p_trace and q_trace:\\n                    break\\n                root = stack.pop()\\n\\t\\t\\t\\t\\n        i, m = 0, min(len(p_trace), len(q_trace))\\n        while i < m and p_trace[i] is q_trace[i]:\\n            ans = p_trace[i]\\n            i += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```python\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        stack, p_trace, q_trace = [], [], []\\n\\t\\t\\n        while True:\\n            if root.left:\\n                stack.append(root)\\n                root.left, root = None, root.left\\n            elif root.right:\\n                stack.append(root)\\n                root.right, root = None, root.right\\n            else:\\n                if root is p:\\n                    p_trace = stack[:]\\n                    p_trace.append(root)\\n                if root is q:\\n                    q_trace = stack[:]\\n                    q_trace.append(root)\\n                if p_trace and q_trace:\\n                    break\\n                root = stack.pop()\\n\\t\\t\\t\\t\\n        i, m = 0, min(len(p_trace), len(q_trace))\\n        while i < m and p_trace[i] is q_trace[i]:\\n            ans = p_trace[i]\\n            i += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 146935,
                "title": "intuitive-post-order",
                "content": "Relative positions of p and q help divide the problem.\\n\\nThere are three relative positions of p and q to root:\\n- Both p and q are to the right of root, then the LCA exists in root\\'s right subtree.\\n- Both p and q are to the left of root, then the LCA exists in root\\'s left subtree.\\n- p and q are one to the left, the other to the right of root, then the LCA is root.\\n\\nHowever, we can\\'t tell relative postitions of p and q at first, so postorder traversal is needed. Meanwhile, one more base case is needed: when we exhaust the tree, i.e. when root is null.\\n\\n****\\n```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if root is None or root == p or root == q:\\n            return root\\n        \\n        left = self.lowestCommonAncestor(root.left, p, q)\\n        right = self.lowestCommonAncestor(root.right, p, q)\\n        \\n        if left is not None and right is not None:\\n            return root\\n        elif left is not None:\\n            return left\\n        elif right is not None:\\n            return right\\n        else:\\n            return None\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if root is None or root == p or root == q:\\n            return root\\n        \\n        left = self.lowestCommonAncestor(root.left, p, q)\\n        right = self.lowestCommonAncestor(root.right, p, q)\\n        \\n        if left is not None and right is not None:\\n            return root\\n        elif left is not None:\\n            return left\\n        elif right is not None:\\n            return right\\n        else:\\n            return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65310,
                "title": "o-nlgn-preprocessing-o-1-query-time-utilizing-rmq-reduction",
                "content": "First convert LCA problem to RMQ (range minimum query) problem by generating Euler tour. LCA must occur in between the two query nodes in the Euler tour, and LCA has the smallest level (distance to root). Therefore LCA problem is reduced to finding smallest element in an array with specified range.\\n\\nReference: Bender, Michael A., and Martin Farach-Colton. \"The LCA problem revisited.\" Latin American Symposium on Theoretical Informatics. Springer Berlin Heidelberg, 2000.\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        LinearLCA lca = new LinearLCA(root);\\n        return lca.query(p, q);\\n    }\\n\\n    public static class TreeNodeUtils {     \\n        /**\\n         * return Euler Tour in an array. An Euler Tour\\n         * traverses every edge of a directed graph\\n         * exactly once and records which nodes are visited.\\n         * each undirected edge consists of two directed \\n         * edges of opposite directions.\\n         * \\n         * @param root\\n         * @return\\n         */\\n        public static TreeNode[] EulerTour(TreeNode root) {\\n            ArrayList<TreeNode> tour = new ArrayList<TreeNode>();\\n            EulerTour(tour, root);\\n            return tour.toArray(new TreeNode[0]);\\n        }\\n        private static void EulerTour(ArrayList<TreeNode> tour, TreeNode root) {\\n            if (root == null) {\\n                return;\\n            }\\n            tour.add(root);\\n            EulerTour(tour, root.left);\\n            if (root.left != null) {\\n                tour.add(root);\\n            }\\n            EulerTour(tour, root.right);\\n            if (root.right != null) {\\n                tour.add(root);\\n            }\\n        }\\n        /**\\n         * output levels (distance from root) in Euler tour order\\n         * @return\\n         */\\n        public static int[] getLevels(TreeNode root, TreeNode[] euler) {\\n            if (root == null || euler == null || euler.length == 0) {\\n                throw new IllegalArgumentException();\\n            }\\n            Map<TreeNode, Integer> node2levels = TreeNodeUtils.getLevels(root);\\n            int[] levels = new int[euler.length];\\n            for (int i = 0; i < euler.length; i++) {\\n                levels[i] = node2levels.get(euler[i]);            \\n            }\\n            return levels;\\n        }\\n        /**\\n         * output levels in a Map with key as nodes\\n         * and values as levels. Use BFS (level-order\\n         * traversal) to find all levels.\\n         */\\n        public static Map<TreeNode, Integer> getLevels(TreeNode root) {\\n            Queue<TreeNode> toVisit = new LinkedList<TreeNode>();\\n            Map<TreeNode, Integer> node2level = new HashMap<TreeNode, Integer>();\\n            int currentLevel = 0;\\n            toVisit.offer(root);\\n            while(!toVisit.isEmpty()) {\\n                int currentLevelSize = toVisit.size();\\n                for (int i = 0; i < currentLevelSize; i++) {\\n                    TreeNode current = toVisit.poll();\\n                    if(current.left != null) {\\n                        toVisit.add(current.left);\\n                    }\\n                    if (current.right != null) {\\n                        toVisit.add(current.right);\\n                    }\\n                    node2level.put(current, currentLevel);\\n                }\\n                currentLevel++;\\n            }\\n            return node2level;\\n        }\\n    }\\n\\n    public interface LCA {\\n        public TreeNode query(TreeNode p, TreeNode q);\\n    }\\n    public class LinearLCA implements LCA {\\n        private TreeNode[] euler;\\n        private Map<TreeNode, Integer> node2representatives;\\n        private int[] levels;\\n        private RMQ rmq;\\n\\n        /**\\n         * initialize Euler tour, representatives, levels\\n         * and RMQ object\\n         * @param root\\n         */\\n        public LinearLCA(TreeNode root) {\\n            euler = TreeNodeUtils.EulerTour(root);\\n            node2representatives = getRepresentatives(euler);      \\n            levels = TreeNodeUtils.getLevels(root, euler);\\n            this.rmq = new SparseTableRMQ(this.levels);\\n        }\\n        private Map<TreeNode, Integer> getRepresentatives(TreeNode[] euler) {\\n            Map<TreeNode, Integer> representatives = new HashMap<TreeNode, Integer>();\\n            for (int i = 0; i < euler.length; i++) {\\n                if (!representatives.containsKey(euler[i])) {\\n                    representatives.put(euler[i], i);\\n                }\\n            }\\n            return representatives;\\n        }\\n        public TreeNode query(TreeNode u, TreeNode v) {\\n            if (!node2representatives.containsKey(u) || !node2representatives.containsKey(v)) {\\n                throw new IllegalArgumentException();\\n            }\\n            int firstU = node2representatives.get(u);\\n            int firstV = node2representatives.get(v);\\n            return euler[rmq.min(Math.min(firstU, firstV), Math.max(firstU,firstV))];        \\n        }\\n    }\\n\\n    /*\\n     * interface for range minimum query problem\\n     * \\n     */\\n    public interface RMQ {\\n        public int min(int i, int j);\\n    }\\n\\n    public class SparseTableRMQ implements RMQ{\\n        private int[][] st;\\n        private int[] pow;\\n        private int[] a;\\n        private int N;\\n        public SparseTableRMQ(int[] a) {\\n            this.a = a;\\n            N = a.length;\\n            if (N <= 1) {\\n                return;\\n            }\\n            //we get floor of lgN because\\n            //2*2^lgN is enough for query from 0 to N-1\\n            int lgN = (int) (Math.log(N)/Math.log(2));\\n            //pre-calculate powers of 2 to save time\\n            pow = pow2(lgN);\\n            st = new int[N][lgN + 1];\\n            //initialize first column\\n            for (int i = 0; i < N; i++) {\\n                st[i][0] = i;\\n            }\\n            for (int j = 1; j <= lgN; j++) {\\n                for (int i = 0; i < N; i++) {\\n                    //not all rows have lgN columns\\n                    //note that i is inclusive\\n                    if (i + pow[j] - 1 >= N) {\\n                        continue;\\n                    }\\n                    int leftMin = st[i][j-1];\\n                    int rightMin = st[i + pow[j-1]][j - 1];\\n                    //when there are ties, return smallest index\\n                    st[i][j] = a[leftMin] <= a[rightMin] ? leftMin : rightMin;\\n                }\\n            }\\n        }\\n        private int[] pow2(int n) {\\n            int[] pow = new int[n + 1];\\n            pow[0] = 1;\\n            for (int i = 1; i <= n; i++) {\\n                pow[i] = pow[i - 1] * 2;\\n            }\\n            return pow;\\n        }\\n        public int min(int i, int j) {\\n            if (i > j || i < 0 || j >= N) {\\n                throw new IllegalArgumentException();\\n            }\\n            if (N == 0) {\\n                return -1;\\n            }\\n            if (i == j || N == 1) {\\n                return i;\\n            }\\n            //find the step where 2*2^step >= j - i + 1\\n            int stepSize = (int) (Math.log(j - i + 1)/Math.log(2));\\n            if (pow[stepSize] == (j - i + 1)) {\\n                stepSize--;\\n            }\\n            /*\\n             * i------------------j\\n             * i--------i+step-1\\n             *     j-step+1-------j\\n             */\\n            int leftMin = st[i][stepSize];\\n            int rightMin = st[j - pow[stepSize] + 1][stepSize];\\n\\n            return a[leftMin] <= a[rightMin] ? leftMin : rightMin;\\n        }\\n\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        LinearLCA lca = new LinearLCA(root);\\n        return lca.query(p, q);\\n    }\\n\\n    public static class TreeNodeUtils {     \\n        /**\\n         * return Euler Tour in an array. An Euler Tour\\n         * traverses every edge of a directed graph\\n         * exactly once and records which nodes are visited.\\n         * each undirected edge consists of two directed \\n         * edges of opposite directions.\\n         * \\n         * @param root\\n         * @return\\n         */\\n        public static TreeNode[] EulerTour(TreeNode root) {\\n            ArrayList<TreeNode> tour = new ArrayList<TreeNode>();\\n            EulerTour(tour, root);\\n            return tour.toArray(new TreeNode[0]);\\n        }\\n        private static void EulerTour(ArrayList<TreeNode> tour, TreeNode root) {\\n            if (root == null) {\\n                return;\\n            }\\n            tour.add(root);\\n            EulerTour(tour, root.left);\\n            if (root.left != null) {\\n                tour.add(root);\\n            }\\n            EulerTour(tour, root.right);\\n            if (root.right != null) {\\n                tour.add(root);\\n            }\\n        }\\n        /**\\n         * output levels (distance from root) in Euler tour order\\n         * @return\\n         */\\n        public static int[] getLevels(TreeNode root, TreeNode[] euler) {\\n            if (root == null || euler == null || euler.length == 0) {\\n                throw new IllegalArgumentException();\\n            }\\n            Map<TreeNode, Integer> node2levels = TreeNodeUtils.getLevels(root);\\n            int[] levels = new int[euler.length];\\n            for (int i = 0; i < euler.length; i++) {\\n                levels[i] = node2levels.get(euler[i]);            \\n            }\\n            return levels;\\n        }\\n        /**\\n         * output levels in a Map with key as nodes\\n         * and values as levels. Use BFS (level-order\\n         * traversal) to find all levels.\\n         */\\n        public static Map<TreeNode, Integer> getLevels(TreeNode root) {\\n            Queue<TreeNode> toVisit = new LinkedList<TreeNode>();\\n            Map<TreeNode, Integer> node2level = new HashMap<TreeNode, Integer>();\\n            int currentLevel = 0;\\n            toVisit.offer(root);\\n            while(!toVisit.isEmpty()) {\\n                int currentLevelSize = toVisit.size();\\n                for (int i = 0; i < currentLevelSize; i++) {\\n                    TreeNode current = toVisit.poll();\\n                    if(current.left != null) {\\n                        toVisit.add(current.left);\\n                    }\\n                    if (current.right != null) {\\n                        toVisit.add(current.right);\\n                    }\\n                    node2level.put(current, currentLevel);\\n                }\\n                currentLevel++;\\n            }\\n            return node2level;\\n        }\\n    }\\n\\n    public interface LCA {\\n        public TreeNode query(TreeNode p, TreeNode q);\\n    }\\n    public class LinearLCA implements LCA {\\n        private TreeNode[] euler;\\n        private Map<TreeNode, Integer> node2representatives;\\n        private int[] levels;\\n        private RMQ rmq;\\n\\n        /**\\n         * initialize Euler tour, representatives, levels\\n         * and RMQ object\\n         * @param root\\n         */\\n        public LinearLCA(TreeNode root) {\\n            euler = TreeNodeUtils.EulerTour(root);\\n            node2representatives = getRepresentatives(euler);      \\n            levels = TreeNodeUtils.getLevels(root, euler);\\n            this.rmq = new SparseTableRMQ(this.levels);\\n        }\\n        private Map<TreeNode, Integer> getRepresentatives(TreeNode[] euler) {\\n            Map<TreeNode, Integer> representatives = new HashMap<TreeNode, Integer>();\\n            for (int i = 0; i < euler.length; i++) {\\n                if (!representatives.containsKey(euler[i])) {\\n                    representatives.put(euler[i], i);\\n                }\\n            }\\n            return representatives;\\n        }\\n        public TreeNode query(TreeNode u, TreeNode v) {\\n            if (!node2representatives.containsKey(u) || !node2representatives.containsKey(v)) {\\n                throw new IllegalArgumentException();\\n            }\\n            int firstU = node2representatives.get(u);\\n            int firstV = node2representatives.get(v);\\n            return euler[rmq.min(Math.min(firstU, firstV), Math.max(firstU,firstV))];        \\n        }\\n    }\\n\\n    /*\\n     * interface for range minimum query problem\\n     * \\n     */\\n    public interface RMQ {\\n        public int min(int i, int j);\\n    }\\n\\n    public class SparseTableRMQ implements RMQ{\\n        private int[][] st;\\n        private int[] pow;\\n        private int[] a;\\n        private int N;\\n        public SparseTableRMQ(int[] a) {\\n            this.a = a;\\n            N = a.length;\\n            if (N <= 1) {\\n                return;\\n            }\\n            //we get floor of lgN because\\n            //2*2^lgN is enough for query from 0 to N-1\\n            int lgN = (int) (Math.log(N)/Math.log(2));\\n            //pre-calculate powers of 2 to save time\\n            pow = pow2(lgN);\\n            st = new int[N][lgN + 1];\\n            //initialize first column\\n            for (int i = 0; i < N; i++) {\\n                st[i][0] = i;\\n            }\\n            for (int j = 1; j <= lgN; j++) {\\n                for (int i = 0; i < N; i++) {\\n                    //not all rows have lgN columns\\n                    //note that i is inclusive\\n                    if (i + pow[j] - 1 >= N) {\\n                        continue;\\n                    }\\n                    int leftMin = st[i][j-1];\\n                    int rightMin = st[i + pow[j-1]][j - 1];\\n                    //when there are ties, return smallest index\\n                    st[i][j] = a[leftMin] <= a[rightMin] ? leftMin : rightMin;\\n                }\\n            }\\n        }\\n        private int[] pow2(int n) {\\n            int[] pow = new int[n + 1];\\n            pow[0] = 1;\\n            for (int i = 1; i <= n; i++) {\\n                pow[i] = pow[i - 1] * 2;\\n            }\\n            return pow;\\n        }\\n        public int min(int i, int j) {\\n            if (i > j || i < 0 || j >= N) {\\n                throw new IllegalArgumentException();\\n            }\\n            if (N == 0) {\\n                return -1;\\n            }\\n            if (i == j || N == 1) {\\n                return i;\\n            }\\n            //find the step where 2*2^step >= j - i + 1\\n            int stepSize = (int) (Math.log(j - i + 1)/Math.log(2));\\n            if (pow[stepSize] == (j - i + 1)) {\\n                stepSize--;\\n            }\\n            /*\\n             * i------------------j\\n             * i--------i+step-1\\n             *     j-step+1-------j\\n             */\\n            int leftMin = st[i][stepSize];\\n            int rightMin = st[j - pow[stepSize] + 1][stepSize];\\n\\n            return a[leftMin] <= a[rightMin] ? leftMin : rightMin;\\n        }\\n\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65324,
                "title": "morris-traversal-solving-it-using-o-1-extra-space-o-n-time",
                "content": "The algorithm used Morris traversal, and the reduction from LCA to RMQ. For the reduction, see  [Reduction from LCA to RMQ](https://www.topcoder.com/community/data-science/data-science-tutorials/range-minimum-query-and-lowest-common-ancestor/#Reduction%20from%20LCA%20to%20RMQ) (Topcoder's tutorial for RMQ and LCA)\\n\\nThe actual running time is longer than most recursive solutions. I posted it as it uses O(1) extra space. So some people might be interested in it.\\nThe idea is not hard to understand if you understand Morris traversal. Here, the traversal is the in-order traversal of binary tree. Wish it helpful.\\n```\\n\\n\\n\\tprivate TreeNode w;\\n\\tprivate boolean gathering;\\n\\tprivate int minLevel;\\n\\n\\tpublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n\\t\\tw = null;\\n\\t\\tgathering = false;\\n\\t\\tminLevel = -1;\\n\\n\\t\\tTreeNode u = root;\\n\\t\\tint level = 0;\\n\\n\\t\\twhile (u != null) {\\n\\t\\t\\tif (u.left == null) {\\n\\t\\t\\t\\tif (visit(u, level, p, q))\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tu = u.right;\\n\\t\\t\\t\\t\\tlevel++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tint delta = 1;\\n\\t\\t\\t\\tTreeNode v = u.left;\\n\\n\\t\\t\\t\\twhile (v.right != null && v.right != u) {\\n\\t\\t\\t\\t\\tv = v.right;\\n\\t\\t\\t\\t\\tdelta++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (v.right == null) {\\n\\t\\t\\t\\t\\tv.right = u;\\n\\t\\t\\t\\t\\tu = u.left;\\n\\t\\t\\t\\t\\tlevel++;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tv.right = null;\\n\\t\\t\\t\\t\\tlevel -= delta + 1;\\n\\t\\t\\t\\t\\tif (visit(u, level, p, q))\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\tu = u.right;\\n\\t\\t\\t\\t\\t\\tlevel++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn w;\\n\\t}\\n\\n\\tprivate void restoreTree(TreeNode u) {\\n\\t\\tu = u.right;\\n\\t\\twhile (u != null) {\\n\\t\\t\\tif (u.left == null)\\n\\t\\t\\t\\tu = u.right;\\n\\t\\t\\telse {\\n\\t\\t\\t\\tTreeNode v = u.left;\\n\\t\\t\\t\\twhile (v.right != null && v.right != u)\\n\\t\\t\\t\\t\\tv = v.right;\\n\\t\\t\\t\\tif (v.right == u)\\n\\t\\t\\t\\t\\tv.right = null;\\n\\t\\t\\t\\tu = u.right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tprivate boolean visit(TreeNode u, int level, TreeNode p, TreeNode q) {\\n\\t\\tif (u == p || u == q) {\\n\\t\\t\\tif (!gathering) {\\n\\t\\t\\t\\tgathering = true;\\n\\t\\t\\t\\tw = u;\\n\\t\\t\\t\\tminLevel = level;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (level < minLevel) {\\n\\t\\t\\t\\t\\tw = u;\\n\\t\\t\\t\\t\\tminLevel = level;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\trestoreTree(u);\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tif (gathering) {\\n\\t\\t\\t\\tif (level < minLevel) {\\n\\t\\t\\t\\t\\tw = u;\\n\\t\\t\\t\\t\\tminLevel = level;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\n\\tprivate TreeNode w;\\n\\tprivate boolean gathering;\\n\\tprivate int minLevel;\\n\\n\\tpublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n\\t\\tw = null;\\n\\t\\tgathering = false;\\n\\t\\tminLevel = -1;\\n\\n\\t\\tTreeNode u = root;\\n\\t\\tint level = 0;\\n\\n\\t\\twhile (u != null) {\\n\\t\\t\\tif (u.left == null) {\\n\\t\\t\\t\\tif (visit(u, level, p, q))\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tu = u.right;\\n\\t\\t\\t\\t\\tlevel++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tint delta = 1;\\n\\t\\t\\t\\tTreeNode v = u.left;\\n\\n\\t\\t\\t\\twhile (v.right != null && v.right != u) {\\n\\t\\t\\t\\t\\tv = v.right;\\n\\t\\t\\t\\t\\tdelta++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (v.right == null) {\\n\\t\\t\\t\\t\\tv.right = u;\\n\\t\\t\\t\\t\\tu = u.left;\\n\\t\\t\\t\\t\\tlevel++;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tv.right = null;\\n\\t\\t\\t\\t\\tlevel -= delta + 1;\\n\\t\\t\\t\\t\\tif (visit(u, level, p, q))\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\tu = u.right;\\n\\t\\t\\t\\t\\t\\tlevel++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn w;\\n\\t}\\n\\n\\tprivate void restoreTree(TreeNode u) {\\n\\t\\tu = u.right;\\n\\t\\twhile (u != null) {\\n\\t\\t\\tif (u.left == null)\\n\\t\\t\\t\\tu = u.right;\\n\\t\\t\\telse {\\n\\t\\t\\t\\tTreeNode v = u.left;\\n\\t\\t\\t\\twhile (v.right != null && v.right != u)\\n\\t\\t\\t\\t\\tv = v.right;\\n\\t\\t\\t\\tif (v.right == u)\\n\\t\\t\\t\\t\\tv.right = null;\\n\\t\\t\\t\\tu = u.right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tprivate boolean visit(TreeNode u, int level, TreeNode p, TreeNode q) {\\n\\t\\tif (u == p || u == q) {\\n\\t\\t\\tif (!gathering) {\\n\\t\\t\\t\\tgathering = true;\\n\\t\\t\\t\\tw = u;\\n\\t\\t\\t\\tminLevel = level;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (level < minLevel) {\\n\\t\\t\\t\\t\\tw = u;\\n\\t\\t\\t\\t\\tminLevel = level;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\trestoreTree(u);\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tif (gathering) {\\n\\t\\t\\t\\tif (level < minLevel) {\\n\\t\\t\\t\\t\\tw = u;\\n\\t\\t\\t\\t\\tminLevel = level;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 65339,
                "title": "java-dfs-solution",
                "content": "    public class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            if (root == null) return null;\\n            List<TreeNode> pathTop = new ArrayList<>();\\n            List<TreeNode> pathToq = new ArrayList<>();\\n            if (!pathToNode(pathTop, root, p) || !pathToNode(pathToq,root,q)) return null;\\n            int min = Math.min(pathTop.size(), pathToq.size());\\n            int pointer = min;\\n            for (int i = 0; i < min; i++) {\\n                if (pathTop.get(i).val != pathToq.get(i).val) {\\n                    pointer = i;\\n                    break;\\n                }\\n            }\\n            return pathTop.get(pointer - 1);  \\n        }\\n        \\n        public boolean pathToNode(List<TreeNode> path, TreeNode root, TreeNode n) {\\n            if (root == null) return false;\\n            path.add(root);\\n            if (root == n) {// use root == n instead of root.val == n.val\\n                return true;\\n            }\\n            if (pathToNode(path, root.left, n)) return true;\\n            if (pathToNode(path, root.right, n)) return true;\\n            path.remove(path.size() - 1);\\n            return false;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            if (root == null) return null;\\n            List<TreeNode> pathTop = new ArrayList<>();\\n            List<TreeNode> pathToq = new ArrayList<>();\\n            if (!pathToNode(pathTop, root, p) || !pathToNode(pathToq,root,q)) return null;\\n            int min = Math.min(pathTop.size(), pathToq.size());\\n            int pointer = min;\\n            for (int i = 0; i < min; i++) {\\n                if (pathTop.get(i).val != pathToq.get(i).val) {\\n                    pointer = i;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 65354,
                "title": "short-easy-to-understand-java-solution",
                "content": "    public class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            if (root == p || root == q || root == null) return root;\\n            TreeNode left = lowestCommonAncestor(root.left, p, q);\\n            TreeNode right = lowestCommonAncestor(root.right, p, q);\\n            if (left != null && right != null) return root;\\n            return left != null ? left : right;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            if (root == p || root == q || root == null) return root;\\n            TreeNode left = lowestCommonAncestor(root.left, p, q);\\n            TreeNode right = lowestCommonAncestor(root.right, p, q);\\n            if (left != null && right != null) return root;\\n            return left != null ? left : right;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3649506,
                "title": "c-easy-path-method",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool f(TreeNode* root,vector<TreeNode*>&v,TreeNode*x){\\n        if(!root)return false;\\n        v.push_back(root);\\n        if(root==x)return true;\\n        if(f(root->left,v,x) || f(root->right,v,x)){\\n            return true;\\n        }\\n        v.pop_back();\\n        return false;\\n    }\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(!root)return NULL;\\n        vector<TreeNode*>p1,p2;\\n        f(root,p1,p);\\n        f(root,p2,q);\\n        for(int i=0;i<min(p1.size(),p2.size());i++){\\n            cout<<p2[i]->val<<\" \";\\n            if(p1[i]!=p2[i]){\\n                return p1[i-1];\\n            }\\n        }\\n        int x= min(p1.size(),p2.size());\\n        return p1[x-1];\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/70d58217-d9f4-4a05-b73f-c1ef51096ff1_1687025655.7606018.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool f(TreeNode* root,vector<TreeNode*>&v,TreeNode*x){\\n        if(!root)return false;\\n        v.push_back(root);\\n        if(root==x)return true;\\n        if(f(root->left,v,x) || f(root->right,v,x)){\\n            return true;\\n        }\\n        v.pop_back();\\n        return false;\\n    }\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(!root)return NULL;\\n        vector<TreeNode*>p1,p2;\\n        f(root,p1,p);\\n        f(root,p2,q);\\n        for(int i=0;i<min(p1.size(),p2.size());i++){\\n            cout<<p2[i]->val<<\" \";\\n            if(p1[i]!=p2[i]){\\n                return p1[i-1];\\n            }\\n        }\\n        int x= min(p1.size(),p2.size());\\n        return p1[x-1];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3523892,
                "title": "python-easy-o-n-recursive-solution",
                "content": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if root==None or root==p or root==q:\\n            return root\\n        left=self.lowestCommonAncestor(root.left,p,q)\\n        right=self.lowestCommonAncestor(root.right,p,q)\\n        if left==None:\\n            return right\\n        elif right==None:\\n            return left\\n        else:\\n            return root\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if root==None or root==p or root==q:\\n            return root\\n        left=self.lowestCommonAncestor(root.left,p,q)\\n        right=self.lowestCommonAncestor(root.right,p,q)\\n        if left==None:\\n            return right\\n        elif right==None:\\n            return left\\n        else:\\n            return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131553,
                "title": "c-easy-to-understand-easy-to-code-binary-tree-tree",
                "content": "# Please upvote if you like this solution, it meant a lot to me.\\n\\n# Complexity\\n- Time complexity:\\nO(N) where N is the number of nodes.\\n\\n- Space complexity:\\nO(N) where N is the auxillary space.\\n\\n# Code\\n```\\nTreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q)\\n{\\n    if (root == NULL || root == p || root == q)\\n        return root;\\n\\n    TreeNode *left = lowestCommonAncestor(root->left, p, q);\\n    TreeNode *right = lowestCommonAncestor(root->right, p, q);\\n\\n    if (left == NULL)\\n        return right;\\n\\n    if (right == NULL)\\n        return left;\\n\\n    else\\n        return root;\\n}\\n```\\n### Let\\'s connect on :-\\n### https://www.linkedin.com/in/mann-chandarana-115255230/\\n\\n\\n![Upvote.png](https://assets.leetcode.com/users/images/5c72057e-5aa8-4b49-aea3-26bdd3475b63_1675341668.6139731.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Tree",
                    "Suffix Array",
                    "Binary Tree"
                ],
                "code": "```\\nTreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q)\\n{\\n    if (root == NULL || root == p || root == q)\\n        return root;\\n\\n    TreeNode *left = lowestCommonAncestor(root->left, p, q);\\n    TreeNode *right = lowestCommonAncestor(root->right, p, q);\\n\\n    if (left == NULL)\\n        return right;\\n\\n    if (right == NULL)\\n        return left;\\n\\n    else\\n        return root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2962578,
                "title": "recursive-iterative-approach-explained-in-detailed-easy-to-understand-c",
                "content": "\\n# Recursive Approach\\nUsing single Traversal \\n \\n# Complexity\\n- Time complexity:\\n  $$O(n)$$ \\n\\n- Space complexity:\\n  $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root==NULL) return NULL ; \\n        //if i get p i will return it \\n        if(root==p) return p ;\\n        //if i get q i will return it \\n        if(root==q) return q ;\\n \\n      //make left call \\n      TreeNode*leftcall = lowestCommonAncestor(root->left,p,q) ; \\n      //make right call \\n     TreeNode*rightcall = lowestCommonAncestor(root->right,p,q) ;\\n\\n         //if at a node both leftcall and rightcall returned NULL--> return NULL\\n         if(leftcall==NULL and rightcall==NULL)  return NULL ; \\n\\n\\n         //if at a node leftcall returns found node and rightcall returned NULL--> return leftcall\\n         if(leftcall!=NULL and rightcall==NULL)  return leftcall ; \\n\\n      //if at a node leftcall returned NULL and rightcall returned found node--> return rightcall\\n         if(leftcall==NULL and rightcall!=NULL)  return rightcall ; \\n\\n      //if at a node both leftcall and rightcall returned found node--> return current node\\n         if(leftcall!=NULL and rightcall!=NULL)  return root ;\\n\\n      return root;\\n    }\\n};\\n```\\n\\n# Iterative  Approach\\nUsing Double Traversal and finding path for node p and q respectively than comparing there path to find LCA.\\n \\n# Complexity\\n- Time complexity:\\n  $$O(n) + O(n) $$ \\n\\n- Space complexity:\\n  $$O(n) + O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//find path of both p and q \\nbool findPath(TreeNode*root , vector<int>&path,TreeNode*toSearch){\\n\\n    if(root==NULL){\\n        return 0;\\n    }\\n   \\n   //Always store current node when moving from one path to other later we will remove if coming back with false \\n    path.push_back(root->val);\\n   \\n   //if found\\n     if(root->val == toSearch->val){\\n         return true;\\n     }\\n\\n    //see if toSearch for is found in any path return true\\n   bool leftSearch =  findPath(root->left,path,toSearch);\\n   bool rightSearch =  findPath(root->right,path,toSearch);\\n\\n   if(leftSearch==true || rightSearch==true){\\n         return true;\\n     }\\n\\n    //return false and remove last added node \\n    path.pop_back();\\n    return false;\\n}\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root==NULL){\\n            return NULL;\\n        }\\n          TreeNode*node = root;\\n        vector<int>pathforp , pathforq ; \\n\\n        bool resultLeft = findPath(root,pathforp,p);\\n        bool resultRight =findPath(root,pathforq,q);\\n        \\n      //  for(auto it : pathforp) cout<<it<<\" \";\\n      //  cout<<\"\\\\n\";\\n       // for(auto itr : pathforq) cout<<itr<<\" \";\\n      // cout<<\"\\\\n\";\\n\\n        //if any p or q not found \\n        if(resultLeft == false || resultRight==false) {\\n            return NULL;\\n        }\\n   \\n        //else path is present  \\n        bool check = 0;\\n        for(int i=0; i<pathforp.size() and i<pathforq.size() ; i++){\\n              if(pathforp[i]!=pathforq[i]){\\n                  //i.e just previous value is answer \\n                  node->val = pathforp[i-1];\\n                  check=1;\\n                    break;\\n                     }\\n        }\\n       if(!check){\\n           int mini = min(pathforp.size() , pathforq.size()) ;\\n         node->val = pathforp[mini-1]; //i.e both p and q were equal so return last value of smaller path as check=0\\n         /* [1,2] , p=2 , q=1\\n        pathforp ->  1 2 \\n        pathforq ->  1\\n        ans = 1\\n         */\\n       }  \\n        return node; //we can also return root\\n    }\\n};\\n```\\n\\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root==NULL) return NULL ; \\n        //if i get p i will return it \\n        if(root==p) return p ;\\n        //if i get q i will return it \\n        if(root==q) return q ;\\n \\n      //make left call \\n      TreeNode*leftcall = lowestCommonAncestor(root->left,p,q) ; \\n      //make right call \\n     TreeNode*rightcall = lowestCommonAncestor(root->right,p,q) ;\\n\\n         //if at a node both leftcall and rightcall returned NULL--> return NULL\\n         if(leftcall==NULL and rightcall==NULL)  return NULL ; \\n\\n\\n         //if at a node leftcall returns found node and rightcall returned NULL--> return leftcall\\n         if(leftcall!=NULL and rightcall==NULL)  return leftcall ; \\n\\n      //if at a node leftcall returned NULL and rightcall returned found node--> return rightcall\\n         if(leftcall==NULL and rightcall!=NULL)  return rightcall ; \\n\\n      //if at a node both leftcall and rightcall returned found node--> return current node\\n         if(leftcall!=NULL and rightcall!=NULL)  return root ;\\n\\n      return root;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n//find path of both p and q \\nbool findPath(TreeNode*root , vector<int>&path,TreeNode*toSearch){\\n\\n    if(root==NULL){\\n        return 0;\\n    }\\n   \\n   //Always store current node when moving from one path to other later we will remove if coming back with false \\n    path.push_back(root->val);\\n   \\n   //if found\\n     if(root->val == toSearch->val){\\n         return true;\\n     }\\n\\n    //see if toSearch for is found in any path return true\\n   bool leftSearch =  findPath(root->left,path,toSearch);\\n   bool rightSearch =  findPath(root->right,path,toSearch);\\n\\n   if(leftSearch==true || rightSearch==true){\\n         return true;\\n     }\\n\\n    //return false and remove last added node \\n    path.pop_back();\\n    return false;\\n}\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root==NULL){\\n            return NULL;\\n        }\\n          TreeNode*node = root;\\n        vector<int>pathforp , pathforq ; \\n\\n        bool resultLeft = findPath(root,pathforp,p);\\n        bool resultRight =findPath(root,pathforq,q);\\n        \\n      //  for(auto it : pathforp) cout<<it<<\" \";\\n      //  cout<<\"\\\\n\";\\n       // for(auto itr : pathforq) cout<<itr<<\" \";\\n      // cout<<\"\\\\n\";\\n\\n        //if any p or q not found \\n        if(resultLeft == false || resultRight==false) {\\n            return NULL;\\n        }\\n   \\n        //else path is present  \\n        bool check = 0;\\n        for(int i=0; i<pathforp.size() and i<pathforq.size() ; i++){\\n              if(pathforp[i]!=pathforq[i]){\\n                  //i.e just previous value is answer \\n                  node->val = pathforp[i-1];\\n                  check=1;\\n                    break;\\n                     }\\n        }\\n       if(!check){\\n           int mini = min(pathforp.size() , pathforq.size()) ;\\n         node->val = pathforp[mini-1]; //i.e both p and q were equal so return last value of smaller path as check=0\\n         /* [1,2] , p=2 , q=1\\n        pathforp ->  1 2 \\n        pathforq ->  1\\n        ans = 1\\n         */\\n       }  \\n        return node; //we can also return root\\n    }\\n};\\n```\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2539410,
                "title": "python3-simple-solution",
                "content": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if root==None or root.val==p.val or root.val==q.val:\\n            return root\\n        left=self.lowestCommonAncestor(root.left,p,q)\\n        right=self.lowestCommonAncestor(root.right,p,q)\\n        if left!=None and right!=None:\\n            return root\\n        elif left!=None:\\n            return left\\n        else:\\n            return right",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if root==None or root.val==p.val or root.val==q.val:\\n            return root\\n        left=self.lowestCommonAncestor(root.left,p,q)\\n        right=self.lowestCommonAncestor(root.right,p,q)\\n        if left!=None and right!=None:\\n            return root\\n        elif left!=None:\\n            return left\\n        else:\\n            return right",
                "codeTag": "Java"
            },
            {
                "id": 2335189,
                "title": "java-best-solution-using-recursion",
                "content": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n      if(root == null || p == root || q == root)        //base case\\n        return root;\\n      \\n      TreeNode right = lowestCommonAncestor(root.right , p , q);\\n      TreeNode left = lowestCommonAncestor(root.left , p , q); \\n      \\n      if(right == null) return left;                   //results\\n      if(left == null) return right;\\n      \\n      else return root;                                //both left and right are not null, we found our result\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n      if(root == null || p == root || q == root)        //base case\\n        return root;\\n      \\n      TreeNode right = lowestCommonAncestor(root.right , p , q);\\n      TreeNode left = lowestCommonAncestor(root.left , p , q); \\n      \\n      if(right == null) return left;                   //results\\n      if(left == null) return right;\\n      \\n      else return root;                                //both left and right are not null, we found our result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2334049,
                "title": "daily-leetcoding-challenge-july-day-26",
                "content": "This problem is the Daily LeetCoding Challenge for July, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative using parent pointers\n\n  \n**Approach 3:** Iterative without parent pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2153818,
                "title": "recursive-o-n-time-if-values-are-given-instead-of-nodes",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\n\\tbool foundone= false,foundtwo = false;\\n\\n\\t// function returns the element found on subtree, if both elements are found returns lca\\n\\tTreeNode* findelement(TreeNode* root,int a,int b){\\n\\t\\tif(!root) return NULL;\\n\\n\\t\\t// flags for checking whether both values are found \\n\\t\\tif(root->val == a) foundone = true;\\n\\t\\tif(root->val == b) foundtwo = true;\\n\\n\\t\\tTreeNode* left = findelement(root->left,a,b);\\n\\t\\tTreeNode* right = findelement(root->right,a,b);\\n\\n\\t\\tif(left && right) return root;\\n\\t\\t// return the node which has a desired value\\n\\t\\tif(!left && right || !right && left){\\n\\t\\t\\tif(root->val == a || root->val==b)\\n\\t\\t\\t\\treturn root;\\n\\t\\t\\tif(right)\\n\\t\\t\\t\\treturn right;\\n\\t\\t\\tif(left)\\n\\t\\t\\t\\treturn left;\\n\\t\\t}\\n\\n\\t\\tif(root->val == a || root->val==b)\\n\\t\\t\\t\\treturn root;\\n\\n\\t\\treturn NULL;\\n\\n\\n\\t}\\n\\n\\n\\t\\tTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\t\\t\\tfoundone= false;\\n\\t\\t   foundtwo = false;\\n\\t\\t   TreeNode *anc = findelement(root,p->val,q->val);\\n\\t\\t   // anc contains node which is found in subtree , \\n\\t\\t   // if one of these doesn\\'t exist, it\\'ll return the element which is found in tree\\n\\t\\t   if(foundone && foundtwo)\\n\\t\\t\\treturn anc;\\n\\n\\t\\t   return NULL;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\tbool foundone= false,foundtwo = false;\\n\\n\\t// function returns the element found on subtree, if both elements are found returns lca\\n\\tTreeNode* findelement(TreeNode* root,int a,int b){\\n\\t\\tif(!root) return NULL;\\n\\n\\t\\t// flags for checking whether both values are found \\n\\t\\tif(root->val == a) foundone = true;\\n\\t\\tif(root->val == b) foundtwo = true;\\n\\n\\t\\tTreeNode* left = findelement(root->left,a,b);\\n\\t\\tTreeNode* right = findelement(root->right,a,b);\\n\\n\\t\\tif(left && right) return root;\\n\\t\\t// return the node which has a desired value\\n\\t\\tif(!left && right || !right && left){\\n\\t\\t\\tif(root->val == a || root->val==b)\\n\\t\\t\\t\\treturn root;\\n\\t\\t\\tif(right)\\n\\t\\t\\t\\treturn right;\\n\\t\\t\\tif(left)\\n\\t\\t\\t\\treturn left;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 937741,
                "title": "c-7-lines-of-code-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) \\n    {\\n        if(!root || root==p || root==q)\\n            return root;\\n        TreeNode* left = lowestCommonAncestor(root->left,p,q);\\n        TreeNode* right = lowestCommonAncestor(root->right,p,q);\\n        if(left && right)\\n            return root;\\n        return left ? left : right;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) \\n    {\\n        if(!root || root==p || root==q)\\n            return root;\\n        TreeNode* left = lowestCommonAncestor(root->left,p,q);\\n        TreeNode* right = lowestCommonAncestor(root->right,p,q);\\n        if(left && right)\\n            return root;\\n        return left ? left : right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 862349,
                "title": "easy-to-understand",
                "content": "```\\n\\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\\n\\tif root == nil || root == p || root == q {\\n\\t\\treturn root\\n\\t}\\n\\n\\tleft := lowestCommonAncestor(root.Left, p, q)\\n\\tright := lowestCommonAncestor(root.Right, p, q)\\n\\tif left != nil && right != nil {\\n\\t\\treturn root\\n\\t}\\n\\tif left != nil {\\n\\t\\treturn left\\n\\t}\\n\\treturn right\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n\\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\\n\\tif root == nil || root == p || root == q {\\n\\t\\treturn root\\n\\t}\\n\\n\\tleft := lowestCommonAncestor(root.Left, p, q)\\n\\tright := lowestCommonAncestor(root.Right, p, q)\\n\\tif left != nil && right != nil {\\n\\t\\treturn root\\n\\t}\\n\\tif left != nil {\\n\\t\\treturn left\\n\\t}\\n\\treturn right\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 613657,
                "title": "4-lines-in-javascript-recursive-solution",
                "content": "4 lines in javaScript\\n\\n```js\\nvar lowestCommonAncestor = function(root, p, q) {\\n  if(!root || root === p || root === q) return root;\\n  const left = lowestCommonAncestor(root.left, p, q);\\n  const right = lowestCommonAncestor(root.right, p, q);\\n  return left && right ? root : left || right;\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar lowestCommonAncestor = function(root, p, q) {\\n  if(!root || root === p || root === q) return root;\\n  const left = lowestCommonAncestor(root.left, p, q);\\n  const right = lowestCommonAncestor(root.right, p, q);\\n  return left && right ? root : left || right;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 229545,
                "title": "concise-and-easy-to-understand-divide-and-conquer-solution-in-java-javascript",
                "content": "Java:\\n```java\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        // in case root is null (empty tree) return null\\n        if (root == null) return null;\\n        // in case current root is either p or q, just return it\\n        if (root == p || root == q) return root;\\n\\n        // divide\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n\\n        // in case both left and right are not null, meaning that\\n        // 1) p exists in the left subtree and q exists in the right subtree\\n        // 2) q exists in the left subtree and p exists in the left subtree\\n        // then current root is the LCA in both cases\\n        if (left != null && right != null) return root;\\n\\n        // else if only one of left or right is not null\\n        // which mean that we only find one of p and q in one subtree\\n        // in that case we are returning it\\n        if (left != null) return left;\\n        if (right != null) return right;\\n\\n        // if left and right are both null, meaning that p, q cannot be found\\n        // in the current subtree, then we should return null to indicate that\\n        return null;\\n    }\\n}\\n```\\n\\nJavaScript:\\n```js\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {TreeNode}\\n */\\nvar lowestCommonAncestor = function(root, p, q) {\\n    // deal with the base case, where current node is null\\n    if (!root) return null;\\n    // in case current node is either p or q, just return it\\n    if (root === p || root === q) return root;\\n\\n    // DIVIDE\\n    const left = lowestCommonAncestor(root.left, p, q);\\n    const right = lowestCommonAncestor(root.right, p, q);\\n\\n    // in case that both left and right are not null, which mean that p and q\\n    // are located in both left and right subtree, so current node will be the\\n    // LCA\\n    if (left && right) return root;\\n\\n    // else if in case that one of the p and q exists in one of the subtree,\\n    // then we still return it\\n    if (left) return left;\\n    if (right) return right;\\n\\n    // in case none of p and q exists, return null\\n    return null;\\n};\\n```\\nHappy Coding~",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        // in case root is null (empty tree) return null\\n        if (root == null) return null;\\n        // in case current root is either p or q, just return it\\n        if (root == p || root == q) return root;\\n\\n        // divide\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n\\n        // in case both left and right are not null, meaning that\\n        // 1) p exists in the left subtree and q exists in the right subtree\\n        // 2) q exists in the left subtree and p exists in the left subtree\\n        // then current root is the LCA in both cases\\n        if (left != null && right != null) return root;\\n\\n        // else if only one of left or right is not null\\n        // which mean that we only find one of p and q in one subtree\\n        // in that case we are returning it\\n        if (left != null) return left;\\n        if (right != null) return right;\\n\\n        // if left and right are both null, meaning that p, q cannot be found\\n        // in the current subtree, then we should return null to indicate that\\n        return null;\\n    }\\n}\\n```\n```js\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {TreeNode}\\n */\\nvar lowestCommonAncestor = function(root, p, q) {\\n    // deal with the base case, where current node is null\\n    if (!root) return null;\\n    // in case current node is either p or q, just return it\\n    if (root === p || root === q) return root;\\n\\n    // DIVIDE\\n    const left = lowestCommonAncestor(root.left, p, q);\\n    const right = lowestCommonAncestor(root.right, p, q);\\n\\n    // in case that both left and right are not null, which mean that p and q\\n    // are located in both left and right subtree, so current node will be the\\n    // LCA\\n    if (left && right) return root;\\n\\n    // else if in case that one of the p and q exists in one of the subtree,\\n    // then we still return it\\n    if (left) return left;\\n    if (right) return right;\\n\\n    // in case none of p and q exists, return null\\n    return null;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65306,
                "title": "java-solution-17ms",
                "content": "I am using the same function call to check if the subtree contains one of the nodes and to return the result.\\n\\n    public static TreeNode lowestCommonAncestor(TreeNode root, TreeNode node1, TreeNode node2) {\\n\\n\\t\\tif (root == null || root == node1 || root == node2)\\n\\t\\t\\treturn root;\\n\\n\\t\\tTreeNode leftSearch = lowestCommonAncestor(root.left, node1, node2);\\n\\t\\tTreeNode rightSearch = lowestCommonAncestor(root.right, node1, node2);\\n\\n\\t\\tif (leftSearch != null && rightSearch != null) {\\n\\t\\t\\treturn root;\\n\\t\\t} else if (leftSearch != null && rightSearch == null) {\\n\\t\\t\\treturn leftSearch;\\n\\t\\t} else if (leftSearch == null && rightSearch != null) {\\n\\t\\t\\treturn rightSearch;\\n\\t\\t} else {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "I am using the same function call to check if the subtree contains one of the nodes and to return the result.\\n\\n    public static TreeNode lowestCommonAncestor(TreeNode root, TreeNode node1, TreeNode node2) {\\n\\n\\t\\tif (root == null || root == node1 || root == node2)\\n\\t\\t\\treturn root;\\n\\n\\t\\tTreeNode leftSearch = lowestCommonAncestor(root.left, node1, node2);\\n\\t\\tTreeNode rightSearch = lowestCommonAncestor(root.right, node1, node2);\\n\\n\\t\\tif (leftSearch != null && rightSearch != null) {\\n\\t\\t\\treturn root;\\n\\t\\t} else if (leftSearch != null && rightSearch == null) {\\n\\t\\t\\treturn leftSearch;\\n\\t\\t} else if (leftSearch == null && rightSearch != null) {\\n\\t\\t\\treturn rightSearch;\\n\\t\\t} else {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 65355,
                "title": "rainbowsecret-c-solution",
                "content": "Refering the post from G4G, we can know that we can construct path from root to p and q seperately.\\n\\nAnd compare the path TreeNode one by one.\\n\\nAlso, a better solution is to find the p and q , return the parent node of the p and q recusively.\\n\\nSo , in the final, we check whether they appear in the same tree or different tree.\\n\\n    class Solution {\\n    public:\\n        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            if(!root || root==p || root==q)  return root;\\n            TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n            TreeNode* right=lowestCommonAncestor(root->right, p, q);\\n            \\n            /** find the LCA lowest parent **/\\n            if(left && right)  return root;\\n            /** this ensures that the LCA is the lowest **/\\n            /** as we just pass the LCA result back-track **/\\n            if(!left)  return right;\\n            if(!right)  return left;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            if(!root || root==p || root==q)  return root;\\n            TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n            TreeNode* right=lowestCommonAncestor(root->right, p, q);\\n            \\n            /** find the LCA lowest parent **/\\n            if(left && right)  return root;\\n            /** this ensures that the LCA is the lowest **/\\n            /** as we just pass the LCA result back-track **/\\n            if(!left)  return right;\\n            if(!right)  return left;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 65388,
                "title": "clean-java-ac-solution-13ms-with-explanation",
                "content": "    if(root == null)\\n\\t\\t\\treturn null ;\\n\\t\\tTreeNode left = lowestCommonAncestor(root.left, p, q);\\n\\t\\tTreeNode right = lowestCommonAncestor(root.right, p, q);\\n\\t\\t\\t\\n\\t\\tif(root == p || root == q)\\n\\t\\t\\treturn root;\\n\\t\\t\\n\\t\\tif(left != null && right == null)\\n\\t\\t\\treturn left;\\n\\t\\telse if(left == null && right != null)\\n\\t\\t\\treturn right;\\n\\t\\telse if(left == null && right == null)\\n\\t\\t\\treturn null;\\n\\t\\telse\\n\\t\\t\\treturn root;\\n\\n\\nUse Post Order Traversal to loop through the tree. Find the left and right child contains tree node p and q and return current node as result.",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "    if(root == null)\\n\\t\\t\\treturn null ;\\n\\t\\tTreeNode left = lowestCommonAncestor(root.left, p, q);\\n\\t\\tTreeNode right = lowestCommonAncestor(root.right, p, q);\\n\\t\\t\\t\\n\\t\\tif(root == p || root == q)\\n\\t\\t\\treturn root;\\n\\t\\t\\n\\t\\tif(left != null && right == null)\\n\\t\\t\\treturn left;\\n\\t\\telse if(left == null && right != null)\\n\\t\\t\\treturn right;\\n\\t\\telse if(left == null && right == null)\\n\\t\\t\\treturn null;\\n\\t\\telse\\n\\t\\t\\treturn root;\\n\\n\\nUse Post Order Traversal to loop through the tree. Find the left and right child contains tree node p and q and return current node as result.",
                "codeTag": "Unknown"
            },
            {
                "id": 65394,
                "title": "my-python-solution-116ms",
                "content": "    class Solution(object):\\n        def lowestCommonAncestor(self, root, p, q):\\n            if root is None:\\n                return root\\n        \\n            if root == p or root == q:\\n                return root\\n        \\n            left = self.lowestCommonAncestor(root.left, p, q)\\n            right = self.lowestCommonAncestor(root.right, p, q)\\n        \\n            if left is not None and right is not None:\\n                return root\\n            elif left is not None:\\n                return left\\n            elif right is not None:\\n                return right",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def lowestCommonAncestor(self, root, p, q):\\n            if root is None:\\n                return root\\n        \\n            if root == p or root == q:\\n                return root\\n        \\n            left = self.lowestCommonAncestor(root.left, p, q)\\n            right = self.lowestCommonAncestor(root.right, p, q)\\n        \\n            if left is not None and right is not None:\\n                return root\\n            elif left is not None:\\n                return left\\n            elif right is not None:\\n                return right",
                "codeTag": "Java"
            },
            {
                "id": 65353,
                "title": "dfs-java-solution",
                "content": "First find treepath for p. Next find treepath for q.  Finally compare tree pathes for common ancestor.\\n\\n    public class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            List<TreeNode> pAns = new ArrayList<TreeNode>();\\n            List<TreeNode> qAns = new ArrayList<TreeNode>();\\n            findAncestors(p, root, pAns);\\n            findAncestors(q, root, qAns);\\n    \\n            TreeNode anc = root;\\n            int i = 1;\\n            while (i<pAns.size() && i<qAns.size()){\\n                if (pAns.get(i) == qAns.get(i)){\\n                    anc = pAns.get(i);\\n                }\\n                else{\\n                    break;\\n                }\\n                i++;\\n            }\\n            return anc;\\n        }\\n        \\n        private boolean findAncestors(TreeNode toFind, TreeNode parent, List<TreeNode> ans){\\n            if (parent == null){\\n                return false;\\n            }\\n            if (toFind == parent){\\n                ans.add(parent);\\n                return true;\\n            }\\n            ans.add(parent);\\n            if (findAncestors(toFind,parent.left,ans)){\\n                return true;\\n            }\\n            if (findAncestors(toFind,parent.right,ans)){\\n                return true;\\n            }\\n            ans.remove(ans.size()-1);\\n            return false;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            List<TreeNode> pAns = new ArrayList<TreeNode>();\\n            List<TreeNode> qAns = new ArrayList<TreeNode>();\\n            findAncestors(p, root, pAns);\\n            findAncestors(q, root, qAns);\\n    \\n            TreeNode anc = root;\\n            int i = 1;\\n            while (i<pAns.size() && i<qAns.size()){\\n                if (pAns.get(i) == qAns.get(i)){\\n                    anc = pAns.get(i);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3755804,
                "title": "python-3-o-n-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere are 3 possible cases:\\n        1. p and q on opposite side of tree\\n        2. p desc of q\\n        3. q desc of p\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOnce we have found either p or q, search the other side for q or p\\nIf the other side contains p or q, its case 1 since they\\'re on opposite sides of the tree, return root\\nOtherwise return p or q depending on which appears first\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$, where n is number of nodes, since each node at most visited once\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(h)$$, where h is the height of the tree, since in worst case (e.g. completely skewed tree) each node along the height is visited once. Space complexity determined by height of recursion tree which is at most $$O(h)$$ \\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        def traverse(node): \\n            # Node does not exist here\\n            if node == None: \\n                return None\\n             # Return once we find either p or q\\n            if node == p or node == q:\\n                return node\\n            left = traverse(node.left) # LCA of p or q on left side\\n            right = traverse(node.right) # LCA of p or q on right side\\n            # LCA of p and q on opposite sides, return the parent\\n            if left and right: \\n                return node\\n            return left or right # Return whichever is the ancestor\\n        return traverse(root)\\n            \\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        def traverse(node): \\n            # Node does not exist here\\n            if node == None: \\n                return None\\n             # Return once we find either p or q\\n            if node == p or node == q:\\n                return node\\n            left = traverse(node.left) # LCA of p or q on left side\\n            right = traverse(node.right) # LCA of p or q on right side\\n            # LCA of p and q on opposite sides, return the parent\\n            if left and right: \\n                return node\\n            return left or right # Return whichever is the ancestor\\n        return traverse(root)\\n            \\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580248,
                "title": "c-2-approaches-brute-force-best-approach-easy-to-understand",
                "content": "# Approach\\n2 approaches - Brute Force + Best Approach\\n\\n# Method - 1 : Brute Force\\n\\n## Complexity\\n- Time complexity: $$O(3n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(2n + h)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n```\\nclass Solution {\\n    public:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root == NULL) return root;\\n\\n        if(root == p || root == q) return root;\\n\\n        TreeNode* leftAns = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* rightAns = lowestCommonAncestor(root->right, p, q);\\n\\n        if(leftAns != NULL && rightAns != NULL) return root;\\n        else if(leftAns != NULL && rightAns == NULL) return leftAns;\\n        else if(leftAns == NULL && rightAns != NULL) return rightAns;\\n        else return NULL;\\n    }\\n};\\n```\\n\\n# Method - 2 : Best Approach\\n\\n## Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(h)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n```\\nclass Solution {\\n    bool getPath(TreeNode* root, TreeNode* x, vector<TreeNode*> &ans) {\\n        if(root == NULL) return false;\\n\\n        ans.push_back(root);\\n\\n        if(root == x) return true;\\n\\n        if(getPath(root->left, x, ans) || getPath(root->right, x, ans)) return true;\\n\\n        ans.pop_back();\\n        return false;\\n    }\\n\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        TreeNode* ans;\\n        if(root == NULL) return ans;\\n\\n        vector<TreeNode*> path1;\\n        getPath(root, p, path1);\\n        vector<TreeNode*> path2;\\n        getPath(root, q, path2);\\n\\n        int i = 0, j = 0;\\n        while(i < path1.size() && j < path2.size()) {\\n            if(path1[i] == path2[j]) {\\n                ans = path1[i];\\n            }\\n            else {\\n                return ans;\\n            }\\n            i++; j++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root == NULL) return root;\\n\\n        if(root == p || root == q) return root;\\n\\n        TreeNode* leftAns = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* rightAns = lowestCommonAncestor(root->right, p, q);\\n\\n        if(leftAns != NULL && rightAns != NULL) return root;\\n        else if(leftAns != NULL && rightAns == NULL) return leftAns;\\n        else if(leftAns == NULL && rightAns != NULL) return rightAns;\\n        else return NULL;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    bool getPath(TreeNode* root, TreeNode* x, vector<TreeNode*> &ans) {\\n        if(root == NULL) return false;\\n\\n        ans.push_back(root);\\n\\n        if(root == x) return true;\\n\\n        if(getPath(root->left, x, ans) || getPath(root->right, x, ans)) return true;\\n\\n        ans.pop_back();\\n        return false;\\n    }\\n\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        TreeNode* ans;\\n        if(root == NULL) return ans;\\n\\n        vector<TreeNode*> path1;\\n        getPath(root, p, path1);\\n        vector<TreeNode*> path2;\\n        getPath(root, q, path2);\\n\\n        int i = 0, j = 0;\\n        while(i < path1.size() && j < path2.size()) {\\n            if(path1[i] == path2[j]) {\\n                ans = path1[i];\\n            }\\n            else {\\n                return ans;\\n            }\\n            i++; j++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228612,
                "title": "best-o-n-solution",
                "content": "# Approach 1\\nBrute-Force\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        vector <TreeNode* > pathOfP;\\n        vector <TreeNode* > pathOfQ;\\n        getPath(root, p, pathOfP);\\n        getPath(root, q, pathOfQ);\\n        int index = 0;\\n        for (auto v: pathOfP) {\\n            auto it = find(pathOfQ.begin(), pathOfQ.end(), v);\\n            if (it != pathOfQ.end()) \\n                index = it - pathOfQ.begin();\\n        }\\n        return pathOfQ[index];\\n    }    \\nprivate:\\n    bool getPath(TreeNode* root, TreeNode* x, vector <TreeNode* >& path) {\\n        if (root == NULL)\\n            return false;\\n        path.push_back(root);\\n        if (root == x)\\n            return true;\\n        if (getPath(root->left, x, path) || getPath(root->right, x, path))\\n            return true;\\n        path.pop_back();    \\n        return false;\\n    }    \\n};\\n```\\n\\n# Approach 2\\nOptimal\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (root == NULL || root == p || root == q)\\n            return root;\\n        TreeNode* left = lowestCommonAncestor(root->left, p, q); \\n        TreeNode* right = lowestCommonAncestor(root->right, p, q); \\n        if (left == NULL)\\n            return right;\\n        else if (right == NULL)\\n            return left;\\n        else\\n            return root;\\n    }    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        vector <TreeNode* > pathOfP;\\n        vector <TreeNode* > pathOfQ;\\n        getPath(root, p, pathOfP);\\n        getPath(root, q, pathOfQ);\\n        int index = 0;\\n        for (auto v: pathOfP) {\\n            auto it = find(pathOfQ.begin(), pathOfQ.end(), v);\\n            if (it != pathOfQ.end()) \\n                index = it - pathOfQ.begin();\\n        }\\n        return pathOfQ[index];\\n    }    \\nprivate:\\n    bool getPath(TreeNode* root, TreeNode* x, vector <TreeNode* >& path) {\\n        if (root == NULL)\\n            return false;\\n        path.push_back(root);\\n        if (root == x)\\n            return true;\\n        if (getPath(root->left, x, path) || getPath(root->right, x, path))\\n            return true;\\n        path.pop_back();    \\n        return false;\\n    }    \\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (root == NULL || root == p || root == q)\\n            return root;\\n        TreeNode* left = lowestCommonAncestor(root->left, p, q); \\n        TreeNode* right = lowestCommonAncestor(root->right, p, q); \\n        if (left == NULL)\\n            return right;\\n        else if (right == NULL)\\n            return left;\\n        else\\n            return root;\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059790,
                "title": "java-99-explained-recursive-dfs",
                "content": "# Intuition\\nIf root is null or if root is x or if root is y then return root\\nMade a recursion call for both\\ni) Left subtree \\nii)Right subtree\\n\\nBecause we would find LCA in the left or right subtree only.\\n\\nIf the left subtree recursive call gives a null value that means we haven\\u2019t found LCA in the left subtree, which means we found LCA on the right subtree. So we will return right.\\nIf the right subtree recursive call gives null value, that means we haven\\u2019t found LCA on the right subtree, which means we found LCA on the left subtree. So we will return left .\\n If both left & right calls give values (not null)  that means the root is the LCA.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n          if (root==null || root==p || root==q){\\n            return root;\\n        }\\n\\n        TreeNode left=lowestCommonAncestor(root.left,p,q);\\n        TreeNode right=lowestCommonAncestor(root.right,p,q);\\n        //- Result\\n        if (left==null){\\n            return right;\\n        }\\n        if (right==null){\\n            return left;\\n        }\\n        //- If both are not null that means we have find out our answer\\n        else{\\n            return root;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n          if (root==null || root==p || root==q){\\n            return root;\\n        }\\n\\n        TreeNode left=lowestCommonAncestor(root.left,p,q);\\n        TreeNode right=lowestCommonAncestor(root.right,p,q);\\n        //- Result\\n        if (left==null){\\n            return right;\\n        }\\n        if (right==null){\\n            return left;\\n        }\\n        //- If both are not null that means we have find out our answer\\n        else{\\n            return root;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2335620,
                "title": "c-solution-easy-6-lines-recursion-fast-than-89",
                "content": "```\\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\tif(root==NULL || root==p || root==q)\\t\\treturn root;\\n\\tTreeNode* left = lowestCommonAncestor(root->left, p, q);\\n\\tTreeNode* right = lowestCommonAncestor(root->right, p, q);\\n\\n\\tif(left==NULL)\\t\\treturn right;\\n\\telse if(right==NULL)\\t\\treturn left;\\n\\telse\\t\\treturn root;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\tif(root==NULL || root==p || root==q)\\t\\treturn root;\\n\\tTreeNode* left = lowestCommonAncestor(root->left, p, q);\\n\\tTreeNode* right = lowestCommonAncestor(root->right, p, q);\\n\\n\\tif(left==NULL)\\t\\treturn right;\\n\\telse if(right==NULL)\\t\\treturn left;\\n\\telse\\t\\treturn root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2335465,
                "title": "binary-tree-recursion-masterclass-full-intuition-explained-with-image",
                "content": "If you found this post helpful, please upvote <3\\n\\nThis post is a little longer than usual, but it\\'s a great read if you want to learn :)\\n\\n<hr />\\n\\nWe are given a binary tree, and we need to find the `lowest common ancestor (LCA)` for 2 given nodes `p` and `q`.\\n\\nLet\\'s look at an example\\n![image](https://assets.leetcode.com/users/images/a58b2eb4-6408-429b-948e-4830db327c5d_1658821225.671219.png)\\n\\nWhen working with binary trees, we need to break the given problem into smaller \"tree problems\", this means recursively look at sub trees and try to find some properties.\\n\\nIf we observe carefully, we can see that the `node = 5, which is the LCA` has both p and q as it\\'s descendants.\\n\\nIf we were to recuse the binary tree bottom-up, when we would get to node=5, we would already find nodes `q` and `p` since **head first recursion** puts all the recursion calls in the call stack, and then processes them bottom-up.\\n\\nAlso node=5 is the first node that would be reached after finding both `q` and `p`.\\n\\n![image](https://assets.leetcode.com/users/images/1d813f01-bfd0-43aa-9b82-2fd457b13d7f_1658821645.661032.png)\\n\\n\\n# Algorithm\\nOur algorithm will search the tree head first, meaning recursing into `left` and `right` childs before doing any checks on the current node.\\n\\nIf we find either `q` or `p` we mark it.\\n\\nWhenever we find both `q` and `p` we know that we found the lowest common ancestor.\\n\\nNote that the current node can be one of `q` or `p` and also form the lowest common ancestor, so we check for that also.\\n\\nI\\'ve created a class `RecursionOutput` to communicate clearly between the recursions, since the recursions communicate with the return values.\\n\\n**Optimization**: If we already found the LCA in the sub trees below, we short circuit return to stop further processing the tree.\\n\\n# Code\\nThe code is readable and commented, just go through it.\\n\\nYou can make the code smaller by cleaning up the extra class, and avoiding some checks. But the idea is to make the code clean, since the performance is the same.\\n\\n```\\nclass RecursionOutput:\\n    def __init__(self, q_found: bool, p_found: bool, lowest_common_ancestor: \\'TreeNode\\' = None):\\n        self.q_found = q_found\\n        self.p_found = p_found\\n        self.lowest_common_ancestor = lowest_common_ancestor\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        \\n        def search(node: \\'TreeNode\\'):\\n            if not node: return RecursionOutput(False, False)\\n            \\n            # Initial values\\n            is_q_found = False\\n            is_p_found = False\\n            \\n            # Search on left side\\n            left_output = search(node.left)\\n            \\n            # Already found LCA on left side -> short circuit return\\n            if left_output.lowest_common_ancestor is not None:\\n                return left_output\\n            \\n            # Search on right side\\n            right_output = search(node.right)\\n            \\n            # Found LCA on right side -> short circuit return\\n            if right_output.lowest_common_ancestor is not None:\\n                return right_output\\n            \\n            # Check if we found q in either left or right side\\n            if left_output.q_found or right_output.q_found:\\n                is_q_found = True\\n            \\n\\t\\t\\t # Check if we found p in either left or right side\\n            if left_output.p_found or right_output.p_found:\\n                is_p_found = True\\n            \\n            \\n            # Check if current node is either q or p\\n            if node == q:\\n                is_q_found = True\\n            if node == p:\\n                is_p_found = True\\n             \\n            # Prepare the output\\n            output = RecursionOutput(is_q_found, is_p_found)\\n            \\n            # if found LCA\\n            if is_q_found and is_p_found:\\n                output.lowest_common_ancestor = node\\n            \\n            return output\\n                \\n        \\n        search_result = search(root)\\n        return search_result.lowest_common_ancestor\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass RecursionOutput:\\n    def __init__(self, q_found: bool, p_found: bool, lowest_common_ancestor: \\'TreeNode\\' = None):\\n        self.q_found = q_found\\n        self.p_found = p_found\\n        self.lowest_common_ancestor = lowest_common_ancestor\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        \\n        def search(node: \\'TreeNode\\'):\\n            if not node: return RecursionOutput(False, False)\\n            \\n            # Initial values\\n            is_q_found = False\\n            is_p_found = False\\n            \\n            # Search on left side\\n            left_output = search(node.left)\\n            \\n            # Already found LCA on left side -> short circuit return\\n            if left_output.lowest_common_ancestor is not None:\\n                return left_output\\n            \\n            # Search on right side\\n            right_output = search(node.right)\\n            \\n            # Found LCA on right side -> short circuit return\\n            if right_output.lowest_common_ancestor is not None:\\n                return right_output\\n            \\n            # Check if we found q in either left or right side\\n            if left_output.q_found or right_output.q_found:\\n                is_q_found = True\\n            \\n\\t\\t\\t # Check if we found p in either left or right side\\n            if left_output.p_found or right_output.p_found:\\n                is_p_found = True\\n            \\n            \\n            # Check if current node is either q or p\\n            if node == q:\\n                is_q_found = True\\n            if node == p:\\n                is_p_found = True\\n             \\n            # Prepare the output\\n            output = RecursionOutput(is_q_found, is_p_found)\\n            \\n            # if found LCA\\n            if is_q_found and is_p_found:\\n                output.lowest_common_ancestor = node\\n            \\n            return output\\n                \\n        \\n        search_result = search(root)\\n        return search_result.lowest_common_ancestor\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2334147,
                "title": "java-easy-solution-100-faster-code",
                "content": "```\\nclass Solution {\\n    TreeNode ans=null;\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        helper(root,p,q);\\n        return this.ans;\\n    }\\n    \\n    public TreeNode helper(TreeNode node,TreeNode p, TreeNode q){\\n        if(node==null){\\n            return null;\\n        }\\n        \\n        TreeNode leftNode=helper(node.left,p,q);\\n        TreeNode rightNode=helper(node.right,p,q);\\n        if(((node==p || node==q)&&(leftNode!=null || rightNode!=null))||(leftNode!=null &&rightNode!=null)){\\n            this.ans=node;\\n            return node;\\n        }else if((leftNode!=null || rightNode!=null)||(node==p || node==q)){\\n            return node;\\n        }else{\\n            return null;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode ans=null;\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        helper(root,p,q);\\n        return this.ans;\\n    }\\n    \\n    public TreeNode helper(TreeNode node,TreeNode p, TreeNode q){\\n        if(node==null){\\n            return null;\\n        }\\n        \\n        TreeNode leftNode=helper(node.left,p,q);\\n        TreeNode rightNode=helper(node.right,p,q);\\n        if(((node==p || node==q)&&(leftNode!=null || rightNode!=null))||(leftNode!=null &&rightNode!=null)){\\n            this.ans=node;\\n            return node;\\n        }else if((leftNode!=null || rightNode!=null)||(node==p || node==q)){\\n            return node;\\n        }else{\\n            return null;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1916670,
                "title": "easiest-c-solution-ever-recursive-approach",
                "content": "Here is my complete code explained with comments at each step. Just go through the code and you will easily get this.\\nAlso do upvote if this helps.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        // base cases of recursion\\n        // base case 1\\n        if(root==NULL)\\n        {\\n            return NULL;\\n        }\\n        \\n        // base case 2\\n        if(root==p || root==q)\\n        {\\n            return root;\\n        }\\n        \\n        // now sending the recursion in left and right\\n        TreeNode* left=lowestCommonAncestor(root->left,p,q);\\n        TreeNode* right=lowestCommonAncestor(root->right,p,q);\\n        \\n        \\n        // if we get the value from both left and right of a node then that node is the LCA and simply return it\\n        if(left!=NULL && right!=NULL)\\n        {\\n            return root;\\n        }\\n        // if we only get value from left side , then return left node \\n        if(left!=NULL)\\n        {\\n            return left;\\n        }\\n        // else if we only get value from right side, then return right node\\n        else\\n        {\\n            return right;\\n        }\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        // base cases of recursion\\n        // base case 1\\n        if(root==NULL)\\n        {\\n            return NULL;\\n        }\\n        \\n        // base case 2\\n        if(root==p || root==q)\\n        {\\n            return root;\\n        }\\n        \\n        // now sending the recursion in left and right\\n        TreeNode* left=lowestCommonAncestor(root->left,p,q);\\n        TreeNode* right=lowestCommonAncestor(root->right,p,q);\\n        \\n        \\n        // if we get the value from both left and right of a node then that node is the LCA and simply return it\\n        if(left!=NULL && right!=NULL)\\n        {\\n            return root;\\n        }\\n        // if we only get value from left side , then return left node \\n        if(left!=NULL)\\n        {\\n            return left;\\n        }\\n        // else if we only get value from right side, then return right node\\n        else\\n        {\\n            return right;\\n        }\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777094,
                "title": "c-clean-easy-o-1-space",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\t\\t\\tif(root==NULL || root==p || root==q)\\n\\t\\t\\t\\treturn root;\\n\\t\\t\\tTreeNode* left=lowestCommonAncestor(root->left,p,q);\\n\\t\\t\\tTreeNode* right=lowestCommonAncestor(root->right,p,q);\\n\\n\\t\\t\\tif(left==NULL)\\n\\t\\t\\t\\treturn right;\\n\\t\\t\\telse if(right==NULL)\\n\\t\\t\\t\\treturn left;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn root;\\n\\t\\t}\\n\\t};\\n\\n\\tfeel free to ask your doubts :)\\n\\tand pls upvote if it was helpful :)",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\t\\t\\tif(root==NULL || root==p || root==q)\\n\\t\\t\\t\\treturn root;\\n\\t\\t\\tTreeNode* left=lowestCommonAncestor(root->left,p,q);\\n\\t\\t\\tTreeNode* right=lowestCommonAncestor(root->right,p,q);\\n\\n\\t\\t\\tif(left==NULL)\\n\\t\\t\\t\\treturn right;\\n\\t\\t\\telse if(right==NULL)\\n\\t\\t\\t\\treturn left;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn root;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1307277,
                "title": "lowest-common-ancestor-python-recursive-approach-easy",
                "content": "# upvote  if useful \\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if root is None or root is p or root is q:\\n            return root\\n        l = self.lowestCommonAncestor(root.left,p,q)\\n        r = self.lowestCommonAncestor(root.right,p,q)\\n        if l and r:\\n            return root\\n        if l:\\n            return l\\n        else:\\n            return r",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Recursion"
                ],
                "code": "# upvote  if useful \\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if root is None or root is p or root is q:\\n            return root\\n        l = self.lowestCommonAncestor(root.left,p,q)\\n        r = self.lowestCommonAncestor(root.right,p,q)\\n        if l and r:\\n            return root\\n        if l:\\n            return l\\n        else:\\n            return r",
                "codeTag": "Java"
            },
            {
                "id": 1300355,
                "title": "clean-java-recursive-solution-without-changing-the-signature-of-the-question",
                "content": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        \\n        if (root == null)\\n            return null;\\n        \\n        TreeNode checkLeft = lowestCommonAncestor(root.left, p, q);\\n        TreeNode checkRight = lowestCommonAncestor(root.right, p, q);\\n        \\n        if (root == p || root == q)\\n            return root;\\n            \\n        else if (checkLeft == null && checkRight == null)\\n            return null;\\n        \\n        else if (checkLeft == null)\\n            return checkRight;\\n        \\n        else if (checkRight == null)\\n            return checkLeft;\\n        \\n        else\\n            return root;\\n            \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        \\n        if (root == null)\\n            return null;\\n        \\n        TreeNode checkLeft = lowestCommonAncestor(root.left, p, q);\\n        TreeNode checkRight = lowestCommonAncestor(root.right, p, q);\\n        \\n        if (root == p || root == q)\\n            return root;\\n            \\n        else if (checkLeft == null && checkRight == null)\\n            return null;\\n        \\n        else if (checkLeft == null)\\n            return checkRight;\\n        \\n        else if (checkRight == null)\\n            return checkLeft;\\n        \\n        else\\n            return root;\\n            \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842459,
                "title": "easy-recursive-do-upvote-if-like-the-solution",
                "content": "16 ms, faster than 98.04% of C++ online submissions for Lowest Common Ancestor of a Binary Tree\\n14.2 MB, less than 95.01% of C++ online submissions for Lowest Common Ancestor of a Binary Tree\\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        \\n        if(root==NULL) return NULL;\\n        if(root==p || root==q) return root;\\n        \\n        TreeNode* left_node=lowestCommonAncestor(root->left,p,q);\\n        TreeNode* right_node=lowestCommonAncestor(root->right,p,q);\\n        \\n        if(left_node!=NULL && right_node!=NULL) return root;\\n        if(left_node==NULL && right_node==NULL) return NULL;\\n        \\n        if(left_node!=NULL) return left_node;\\n        return right_node;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        \\n        if(root==NULL) return NULL;\\n        if(root==p || root==q) return root;\\n        \\n        TreeNode* left_node=lowestCommonAncestor(root->left,p,q);\\n        TreeNode* right_node=lowestCommonAncestor(root->right,p,q);\\n        \\n        if(left_node!=NULL && right_node!=NULL) return root;\\n        if(left_node==NULL && right_node==NULL) return NULL;\\n        \\n        if(left_node!=NULL) return left_node;\\n        return right_node;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 783009,
                "title": "python-divide-and-conquer-with-explanation",
                "content": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        \\n        # found p and q?\\n        if not root or root == p or root == q:\\n            return root\\n        \\n        \\n        left = self.lowestCommonAncestor(root.left, p, q)\\n        right = self.lowestCommonAncestor(root.right, p, q)\\n        \\n        # p and q appears in left and right respectively, then their ancestor is root\\n        if left is not None and right is not None:\\n            return root\\n        \\n        # p and q not in left, then it must be in right, otherwise left\\n        if left is None:\\n            return right\\n        \\n        if right is None:\\n            return left\\n```",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        \\n        # found p and q?\\n        if not root or root == p or root == q:\\n            return root\\n        \\n        \\n        left = self.lowestCommonAncestor(root.left, p, q)\\n        right = self.lowestCommonAncestor(root.right, p, q)\\n        \\n        # p and q appears in left and right respectively, then their ancestor is root\\n        if left is not None and right is not None:\\n            return root\\n        \\n        # p and q not in left, then it must be in right, otherwise left\\n        if left is None:\\n            return right\\n        \\n        if right is None:\\n            return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 527218,
                "title": "readable-javascript-solution-explained-99-time-100-space",
                "content": "The main thing to understand in this problem is that you are essentially checking each subtree to see is q and q exist starting from a new root with each call of recursion. if you see that both p and q exist in the subtree you return. \\nMost of the soutions I saw were written in a way tricky to understand so I wrote out as simple as possible.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {TreeNode}\\n */\\nvar lowestCommonAncestor = function(root, p, q) {\\n    \\n    return dfs(root);\\n    \\n    function dfs(node){\\n        if(!node){\\n            return null;\\n        }\\n\\t\\t\\n\\t\\t//if you see that the current node is p or q return the current node\\n        if(node === p || node === q){\\n            return node;\\n        }\\n\\t\\t\\n\\t\\t//check the left subtree for p or q, at the bottom level of the recursive stack it returns p or q, but at the highest level it returns the lowest common ancestor\\n        let left = dfs(node.left);\\n\\t\\t\\n\\t\\t//same as what you did for left\\n        let right = dfs(node.right);\\n        \\n\\t\\t//if you found both p and q in the left and right subtree return this node\\n        if(left && right){\\n            return node;\\n        }\\n\\t\\t\\n\\t\\t//if you found both p and q in the left subtree\\n        if(left){\\n            return left;\\n        }\\n        \\n\\t\\t//if you found both p and q in the right subtree\\n        if(right){\\n            return right;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {TreeNode}\\n */\\nvar lowestCommonAncestor = function(root, p, q) {\\n    \\n    return dfs(root);\\n    \\n    function dfs(node){\\n        if(!node){\\n            return null;\\n        }\\n\\t\\t\\n\\t\\t//if you see that the current node is p or q return the current node\\n        if(node === p || node === q){\\n            return node;\\n        }\\n\\t\\t\\n\\t\\t//check the left subtree for p or q, at the bottom level of the recursive stack it returns p or q, but at the highest level it returns the lowest common ancestor\\n        let left = dfs(node.left);\\n\\t\\t\\n\\t\\t//same as what you did for left\\n        let right = dfs(node.right);\\n        \\n\\t\\t//if you found both p and q in the left and right subtree return this node\\n        if(left && right){\\n            return node;\\n        }\\n\\t\\t\\n\\t\\t//if you found both p and q in the left subtree\\n        if(left){\\n            return left;\\n        }\\n        \\n\\t\\t//if you found both p and q in the right subtree\\n        if(right){\\n            return right;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 448292,
                "title": "c-iterative-post-order-traversal-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        std::stack<TreeNode *> txStk;\\n        TreeNode *prev = NULL; /* previous node visisted in Post-order traversal */\\n        TreeNode *curr = NULL; \\n        TreeNode *parent = NULL; /* placeholder for LCA */\\n        \\n        \\n        int p_found = 0;\\n        int q_found = 0;\\n\\n        if (!root) return NULL;\\n        if (p == q) return p;\\n\\n        /* Process left child of root */\\n        for (TreeNode *tmp = root; tmp; tmp = tmp->left) \\n            txStk.push(tmp);\\n        \\n        while (!txStk.empty()) {\\n            curr = txStk.top();\\n            \\n            /*\\n             * If prev was marked as a probable ancestor, then it would either be one of\\n             * (p,q) or their ancestor. Now that prev has been visited and we found only\\n             * one of (p, q), we\\'ll go to its ancestor to find next. Update ancestor while we do that.\\n             */\\n            if (parent && prev == parent) parent = curr;\\n            \\n            \\n            /*\\n             * 1. Left tree has already been processed. If last node we\\n             * processed was not right child, process right child\\n             */\\n            if (curr->right && prev != curr->right) {\\n                /* 2. Process left chlid of this node */\\n                for (TreeNode *tmp = curr->right; tmp; tmp = tmp->left)\\n                    txStk.push(tmp);\\n                continue;\\n            }\\n            \\n            txStk.pop();\\n            \\n            /* \\n             * Because we\\'re doing a ordered traversal, the left most node will be found first\\n             * or the child node if one is ancestor of other. When we\\'ve found second node,\\n             * the ancestor is already captured correctly in parent.\\n             */\\n            if (curr == p) {\\n                if (q_found) return parent;\\n                p_found = 1;\\n                parent = curr;\\n            }\\n            \\n            if (curr == q) {\\n                if (p_found) return parent;\\n                q_found = 1;\\n                parent = curr;\\n            }\\n            \\n            /* Remember last node we visited in the traversal */\\n            prev = curr;\\n        }\\n        \\n        return NULL;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        std::stack<TreeNode *> txStk;\\n        TreeNode *prev = NULL; /* previous node visisted in Post-order traversal */\\n        TreeNode *curr = NULL; \\n        TreeNode *parent = NULL; /* placeholder for LCA */\\n        \\n        \\n        int p_found = 0;\\n        int q_found = 0;\\n\\n        if (!root) return NULL;\\n        if (p == q) return p;\\n\\n        /* Process left child of root */\\n        for (TreeNode *tmp = root; tmp; tmp = tmp->left) \\n            txStk.push(tmp);\\n        \\n        while (!txStk.empty()) {\\n            curr = txStk.top();\\n            \\n            /*\\n             * If prev was marked as a probable ancestor, then it would either be one of\\n             * (p,q) or their ancestor. Now that prev has been visited and we found only\\n             * one of (p, q), we\\'ll go to its ancestor to find next. Update ancestor while we do that.\\n             */\\n            if (parent && prev == parent) parent = curr;\\n            \\n            \\n            /*\\n             * 1. Left tree has already been processed. If last node we\\n             * processed was not right child, process right child\\n             */\\n            if (curr->right && prev != curr->right) {\\n                /* 2. Process left chlid of this node */\\n                for (TreeNode *tmp = curr->right; tmp; tmp = tmp->left)\\n                    txStk.push(tmp);\\n                continue;\\n            }\\n            \\n            txStk.pop();\\n            \\n            /* \\n             * Because we\\'re doing a ordered traversal, the left most node will be found first\\n             * or the child node if one is ancestor of other. When we\\'ve found second node,\\n             * the ancestor is already captured correctly in parent.\\n             */\\n            if (curr == p) {\\n                if (q_found) return parent;\\n                p_found = 1;\\n                parent = curr;\\n            }\\n            \\n            if (curr == q) {\\n                if (p_found) return parent;\\n                q_found = 1;\\n                parent = curr;\\n            }\\n            \\n            /* Remember last node we visited in the traversal */\\n            prev = curr;\\n        }\\n        \\n        return NULL;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 341420,
                "title": "strange-attribute-error",
                "content": "I am getting a strange attribute error sometimes. Specifically, whenever I try and return something I get\\n*Line 80: AttributeError: \\'int\\' object has no attribute \\'val\\'*\\n\\nI have no line 80 so I am a little confused where this could be coming from. Furthermore, the error only happens if I try and return something. If I just print the result, there are no issues. Any help would be greatly appreciated!\\n\\nCode, if that helps:\\n\\n```# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    \\n    #function for finding all ancestors\\n    def findAncestors(self, ancestors, current, goal):\\n        if current.val == goal:\\n            return ancestors\\n        else:\\n            if current.left:\\n                leftTree = Solution.findAncestors(self, ancestors + [current.left.val], current.left, goal)\\n            else:\\n                leftTree = []\\n            if current.right:\\n                rightTree = Solution.findAncestors(self, ancestors + [current.right.val], current.right, goal)\\n            else:\\n                rightTree = []\\n            return leftTree or rightTree\\n    \\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not root:\\n            return root\\n        pAncs = Solution.findAncestors(self, [root.val], root, p.val)\\n        qAncs = Solution.findAncestors(self, [root.val], root, q.val)\\n        \\n        for i in range(len(pAncs)):\\n            if pAncs[i]==qAncs[i]:\\n                return pAncs[i]\\n```",
                "solutionTags": [],
                "code": "```# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    \\n    #function for finding all ancestors\\n    def findAncestors(self, ancestors, current, goal):\\n        if current.val == goal:\\n            return ancestors\\n        else:\\n            if current.left:\\n                leftTree = Solution.findAncestors(self, ancestors + [current.left.val], current.left, goal)\\n            else:\\n                leftTree = []\\n            if current.right:\\n                rightTree = Solution.findAncestors(self, ancestors + [current.right.val], current.right, goal)\\n            else:\\n                rightTree = []\\n            return leftTree or rightTree\\n    \\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not root:\\n            return root\\n        pAncs = Solution.findAncestors(self, [root.val], root, p.val)\\n        qAncs = Solution.findAncestors(self, [root.val], root, q.val)\\n        \\n        for i in range(len(pAncs)):\\n            if pAncs[i]==qAncs[i]:\\n                return pAncs[i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 303992,
                "title": "java-iterative-and-recursive-with-detailed-explanation",
                "content": "```\\nprivate static TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null) {\\n            return null;\\n        }\\n        if (root == p || root == q) {\\n            return root;\\n        }\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n\\n        if (left != null && right != null) {\\n            return root;\\n        }\\n        return left != null ? left : right;\\n    }\\n\\n    // Non Recursive BFS Approach: TC - O(n)\\n    // Step 1: traverse all the tree and save the node-parent pairs (in a hash map) for all the nodes in the tree (till the point we encounter BOTH p and q)\\n    // Step 2: start from p and save all the parents of p till root (including p and root) in a hash set\\n    // Step 3: start from q and and navigate through all the parents till root and whenever you see a parent that is present in the set (common ancestor for p and q), that is LCA\\n    private static TreeNode lowestCommonAncestorIterative(TreeNode root, TreeNode p, TreeNode q) {\\n        Map<TreeNode, TreeNode> parentMap = new HashMap<>(); // look up map for the node and its immediate parent\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        parentMap.put(root, null);\\n        queue.add(root);\\n        while (!parentMap.containsKey(p) || !parentMap.containsKey(q)) {\\n            TreeNode node = queue.poll();\\n            parentMap.put(node.left, node);  // save the node and its parentMap\\n            parentMap.put(node.right, node); // save the node and its parentMap\\n\\n            if (node.left != null) {\\n                queue.add(node.left);\\n            }\\n            if (node.right != null) {\\n                queue.add(node.right);\\n            }\\n        }\\n        Set<TreeNode> set = new HashSet<>();\\n        while (p != null) {   // get all the parents of p till the root\\n            set.add(p);\\n            p = parentMap.get(p);\\n        }\\n        while (!set.contains(q)) {   // starting q, get all its parents till the root and in the process, whenever you see the parentMap that is already present in the set, that\\'s the first common parentMap (which is LCA)\\n            q = parentMap.get(q);\\n        }\\n        return q;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nprivate static TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null) {\\n            return null;\\n        }\\n        if (root == p || root == q) {\\n            return root;\\n        }\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n\\n        if (left != null && right != null) {\\n            return root;\\n        }\\n        return left != null ? left : right;\\n    }\\n\\n    // Non Recursive BFS Approach: TC - O(n)\\n    // Step 1: traverse all the tree and save the node-parent pairs (in a hash map) for all the nodes in the tree (till the point we encounter BOTH p and q)\\n    // Step 2: start from p and save all the parents of p till root (including p and root) in a hash set\\n    // Step 3: start from q and and navigate through all the parents till root and whenever you see a parent that is present in the set (common ancestor for p and q), that is LCA\\n    private static TreeNode lowestCommonAncestorIterative(TreeNode root, TreeNode p, TreeNode q) {\\n        Map<TreeNode, TreeNode> parentMap = new HashMap<>(); // look up map for the node and its immediate parent\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        parentMap.put(root, null);\\n        queue.add(root);\\n        while (!parentMap.containsKey(p) || !parentMap.containsKey(q)) {\\n            TreeNode node = queue.poll();\\n            parentMap.put(node.left, node);  // save the node and its parentMap\\n            parentMap.put(node.right, node); // save the node and its parentMap\\n\\n            if (node.left != null) {\\n                queue.add(node.left);\\n            }\\n            if (node.right != null) {\\n                queue.add(node.right);\\n            }\\n        }\\n        Set<TreeNode> set = new HashSet<>();\\n        while (p != null) {   // get all the parents of p till the root\\n            set.add(p);\\n            p = parentMap.get(p);\\n        }\\n        while (!set.contains(q)) {   // starting q, get all its parents till the root and in the process, whenever you see the parentMap that is already present in the set, that\\'s the first common parentMap (which is LCA)\\n            q = parentMap.get(q);\\n        }\\n        return q;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 65362,
                "title": "easy-9-line-java-solution-o-n-time-using-recursion",
                "content": "    public class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null) return null;\\n        if(root == p) return p;\\n        if(root == q) return q;\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n        if(left == null && right == null) return null;\\n        if(left != null && right == null) return left;\\n        if(left == null && right != null) return right;\\n        return root;\\n    }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null) return null;\\n        if(root == p) return p;\\n        if(root == q) return q;\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n        if(left == null && right == null) return null;\\n        if(left != null && right == null) return left;\\n        if(left == null && right != null) return right;\\n        return root;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 65396,
                "title": "3-solutions-with-explanation",
                "content": "The first one is straightforward but slow. The second one is also not difficult to come up with. The 3rd is neat and but it was hard for me to get my head around it at the first time.\\n  \\n    \\n    \\n       /**\\n         * Definition for a binary tree node.\\n         * struct TreeNode {\\n         *     int val;\\n         *     TreeNode *left;\\n         *     TreeNode *right;\\n         *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n         * };\\n         */\\n        class Solution {\\n        public:\\n            TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n                  return sol1(root,p,q);\\n                //return sol2(root,p,q);\\n                //return sol3(root,p,q);\\n            }\\n            \\n            // 23ms\\n            TreeNode* sol3(TreeNode* root, TreeNode* p, TreeNode* q) {\\n                 // no p and q\\n                 if (!root) return NULL;\\n                 // find either p or q\\n                 if (root == p || root == q) return root;\\n                 TreeNode *left = sol3(root->left,p, q);\\n                 TreeNode *right = sol3(root->right,p,q);\\n                 \\n                 // p and q are in different subtrees\\n                 if(left && right) return root;\\n                 // p and q are in the same subtree\\n                 return left ? left : right;\\n            }\\n            \\n            // 23ms   the lowest cross of the paths \\n            TreeNode* sol2(TreeNode* root, TreeNode* p, TreeNode* q) {\\n                vector<TreeNode*> p1, p2;\\n                pathTo(root,p,p1);\\n                // if q in the path\\n                for (auto a : p1) {\\n                    if (q == a) return q;\\n                }\\n                pathTo(root,q,p2);\\n                for (auto a : p2) {\\n                    if (p == a) return p;\\n                }\\n                // if p in the path\\n                int N = p1.size();\\n                int M = p2.size();\\n                \\n                for (int i = N -1; i >= 0 ; i--) {\\n                    for (int j = M -1; j >=0 ;j--) {\\n                        if (p1[i] == p2[j]) {\\n                            return p1[i];\\n                        }\\n                    }\\n                }\\n                \\n                // should never come here\\n                return NULL;\\n            }\\n            \\n            bool pathTo(TreeNode* root, TreeNode* n, vector<TreeNode*> &path) {\\n                if (!root) return false;\\n                if (root == n) {\\n                    path.push_back(n);\\n                    return true;\\n                }\\n                \\n                path.push_back(root);\\n                if (pathTo(root->left, n, path)) return true;\\n                if (pathTo(root->right,n, path)) return true;\\n                path.pop_back();\\n                return false;\\n            }\\n        \\n            //slow....\\n            TreeNode* sol1(TreeNode* root, TreeNode* p, TreeNode* q) {\\n                if (p == root || q == root) return root;\\n                // 1 in left, 2 in right\\n                int lp = dfsFind(root->left,p) ? 1 : 2;\\n                int lq = dfsFind(root->left,q) ? 1 : 2;\\n                \\n                if (lp != lq) return root;\\n                if (lp == 1) return lowestCommonAncestor(root->left,p,q);\\n                return lowestCommonAncestor(root->right, p, q);\\n            }\\n            \\n            bool dfsFind(TreeNode *root, TreeNode *t) {\\n                if (!root) return false;\\n                if (root == t) return true;\\n                if (dfsFind(root->left,t)) return true;\\n                return dfsFind(root->right,t);\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n                  return sol1(root,p,q);\\n                //return sol2(root,p,q);\\n                //return sol3(root,p,q);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 65358,
                "title": "non-recursive-c-code-with-considering-not-both-p-and-q-are-all-in-the-tree-return-null",
                "content": "Non-recursive implement, return NULL if p, q or both are not in the three.\\n\\nC++\\n    \\n    class Solution {\\n    public:\\n        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            vector<TreeNode*> left_stack;\\n            vector<TreeNode*> right_stack;\\n            TreeNode* node = root;\\n            TreeNode* lca = NULL;\\n            while(node)\\n            {\\n                if(node == p || node == q)\\n                    if(lca == NULL)\\n                        lca = node;\\n                    else\\n                        return lca;\\n                left_stack.push_back(node);\\n                node = node->left;\\n            }\\n            while(left_stack.size() > 0)\\n            {\\n                node = left_stack.back();\\n                if(node->right == NULL)\\n                {\\n                    left_stack.pop_back();\\n                    if(node->left != NULL && node->left == lca)\\n                        lca = node;\\n                    continue;\\n                }\\n                if(right_stack.size() > 0 && node == right_stack.back())\\n                {\\n                    left_stack.pop_back();\\n                    right_stack.pop_back();\\n                    if(lca != NULL && (node->left == lca || node->right == lca))\\n                        lca = node;\\n                    continue;\\n                }\\n                if(lca != NULL && (node->left == lca || node->right == lca))\\n                    lca = node;\\n                right_stack.push_back(node);\\n                node = node->right;\\n                while(node)\\n                {\\n                    if(node == p || node == q)\\n                        if(lca == NULL)\\n                            lca = node;\\n                        else\\n                            return lca;\\n                    left_stack.push_back(node);\\n                    node = node->left;\\n                }\\n            }\\n            return NULL;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            vector<TreeNode*> left_stack;\\n            vector<TreeNode*> right_stack;\\n            TreeNode* node = root;\\n            TreeNode* lca = NULL;\\n            while(node)\\n            {\\n                if(node == p || node == q)\\n                    if(lca == NULL)\\n                        lca = node;\\n                    else\\n                        return lca;\\n                left_stack.push_back(node);\\n                node = node->left;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 65430,
                "title": "accepted-java-solution",
                "content": "    /**\\n     * Definition for a binary tree node.\\n     * public class TreeNode {\\n     *     int val;\\n     *     TreeNode left;\\n     *     TreeNode right;\\n     *     TreeNode(int x) { val = x; }\\n     * }\\n     */\\n    public class Solution\\n    {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q)\\n        {\\n            if(root == null)\\n                return null;\\n            if(root == p || root == q)\\n                return root; // if find at root, no need to continue, this is before branching\\n            TreeNode left = lowestCommonAncestor(root.left,p,q);\\n            TreeNode right = lowestCommonAncestor(root.right,p,q);\\n            if(left != null && right != null) //after branching\\n                return root;\\n            return left == null?right:left;//one branch null or branch not null, the brach without null automatically becomes the lca\\n                                            //both null and root doesn't match, then return null\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution\\n    {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q)\\n        {\\n            if(root == null)\\n                return null;\\n            if(root == p || root == q)\\n                return root; // if find at root, no need to continue, this is before branching\\n            TreeNode left = lowestCommonAncestor(root.left,p,q);\\n            TreeNode right = lowestCommonAncestor(root.right,p,q);\\n            if(left != null && right != null) //after branching\\n                return root;\\n            return left == null?right:left;//one branch null or branch not null, the brach without null automatically becomes the lca\\n                                            //both null and root doesn't match, then return null\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3947122,
                "title": "easy-iterative-dfs-solution-in-python",
                "content": "# Code\\n```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        stack=[]\\n        parent=defaultdict(TreeNode)\\n        res=[]\\n        stack.append([root,0])\\n        while(stack):\\n            t=stack.pop()\\n            node=t[0]\\n            level=t[1]\\n            if node.val in [p.val,q.val]:\\n                res.append([node,level])\\n            if node.right:\\n                stack.append([node.right,level+1])\\n                parent[node.right]=node\\n            if node.left:\\n                stack.append([node.left,level+1])\\n                parent[node.left]=node\\n        p,pl=res[0][0],res[0][1]\\n        q,ql=res[1][0],res[1][1]\\n        if pl>ql:\\n            for i in range(pl-ql):\\n                p=parent[p]\\n                print(p.val)\\n        elif pl<ql:\\n            for i in range(ql-pl):\\n                q=parent[q]\\n                print(q.val)\\n        while(p.val!=q.val):\\n            p=parent[p]\\n            q=parent[q]\\n        return p\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        stack=[]\\n        parent=defaultdict(TreeNode)\\n        res=[]\\n        stack.append([root,0])\\n        while(stack):\\n            t=stack.pop()\\n            node=t[0]\\n            level=t[1]\\n            if node.val in [p.val,q.val]:\\n                res.append([node,level])\\n            if node.right:\\n                stack.append([node.right,level+1])\\n                parent[node.right]=node\\n            if node.left:\\n                stack.append([node.left,level+1])\\n                parent[node.left]=node\\n        p,pl=res[0][0],res[0][1]\\n        q,ql=res[1][0],res[1][1]\\n        if pl>ql:\\n            for i in range(pl-ql):\\n                p=parent[p]\\n                print(p.val)\\n        elif pl<ql:\\n            for i in range(ql-pl):\\n                q=parent[q]\\n                print(q.val)\\n        while(p.val!=q.val):\\n            p=parent[p]\\n            q=parent[q]\\n        return p\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502560,
                "title": "5-6-lines-c-solution-very-easy-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStart !\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.check if root is null or not ,if null return null;\\n2.if found q then return q;\\n3.if found p then return p;\\n4.now search in Left side of the tree ;\\n5.Now search in right side of the tree;\\n6.if not found i both side then return null;\\n7.if not found in right and found in left return left;\\n8.if not found in left and found in right return right;\\n9.if found in both return root ;\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root==NULL) return NULL;\\n        if(root->val==q->val) return q;\\n        if(root->val==p->val) return p;\\n        TreeNode* left=lowestCommonAncestor(root->left,p,q);\\n        TreeNode* right=lowestCommonAncestor(root->right,p,q);\\n        if(left==NULL&&right==NULL)return NULL;\\n        if(left!=NULL&&right==NULL)return left;\\n        if(left==NULL&&right!=NULL)return right;\\n        else return root;\\n\\n        \\n    }\\n};\\n```\\n![7abc56.jpg](https://assets.leetcode.com/users/images/1dcb2545-6c4e-4717-bd0d-ecfe570bc1cf_1683588444.5812426.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root==NULL) return NULL;\\n        if(root->val==q->val) return q;\\n        if(root->val==p->val) return p;\\n        TreeNode* left=lowestCommonAncestor(root->left,p,q);\\n        TreeNode* right=lowestCommonAncestor(root->right,p,q);\\n        if(left==NULL&&right==NULL)return NULL;\\n        if(left!=NULL&&right==NULL)return left;\\n        if(left==NULL&&right!=NULL)return right;\\n        else return root;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449442,
                "title": "c-easy-to-understand",
                "content": "````\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root == NULL)return NULL;\\n        if(root==p||root==q){\\n            return root;\\n        }\\n        TreeNode* l = lowestCommonAncestor(root->left,p,q);\\n        TreeNode* r = lowestCommonAncestor(root->right,p,q);\\n        if(l&&r)return root;\\n        if(l)return l;\\n        if(r)return r;\\n        return NULL;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root == NULL)return NULL;\\n        if(root==p||root==q){\\n            return root;\\n        }\\n        TreeNode* l = lowestCommonAncestor(root->left,p,q);\\n        TreeNode* r = lowestCommonAncestor(root->right,p,q);\\n        if(l&&r)return root;\\n        if(l)return l;\\n        if(r)return r;\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281391,
                "title": "lowest-common-ancestor-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null) return root;\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n        if (root == p || root == q) return root;\\n        if (left == null) return right;\\n        if (right == null) return left;\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null) return root;\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n        if (root == p || root == q) return root;\\n        if (left == null) return right;\\n        if (right == null) return left;\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222257,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(!root)\\n            return root;\\n        if(root == p || root == q)\\n            return root;\\n        TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n        if(left && right)\\n            return root;\\n        return left?left:right;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(!root)\\n            return root;\\n        if(root == p || root == q)\\n            return root;\\n        TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n        if(left && right)\\n            return root;\\n        return left?left:right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3178718,
                "title": "go-golang-solution-using-recursion",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\n func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\\n    // First base case, if root is null, return null\\n    if root == nil {\\n\\t\\treturn nil\\n\\t}\\n\\n    // Second base case, if root is equal to p or q, return root because, we found the LCA at root only\\n\\tif root == p || root == q {\\n\\t\\treturn root\\n\\t}\\n\\n    // Process left and then right nodes\\n\\tleft := lowestCommonAncestor(root.Left, p, q)\\n\\tright := lowestCommonAncestor(root.Right, p, q)\\n\\n    // if both left and right aren\\'t null, that means we found the targets on both sides of trees, means we need to return root\\n\\tif left != nil && right != nil {\\n\\t\\treturn root\\n\\t}\\n\\t// if we find in left, return left\\n\\tif left != nil {\\n\\t\\treturn left\\n\\t}\\n    // else right\\n\\treturn right\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\n func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\\n    // First base case, if root is null, return null\\n    if root == nil {\\n\\t\\treturn nil\\n\\t}\\n\\n    // Second base case, if root is equal to p or q, return root because, we found the LCA at root only\\n\\tif root == p || root == q {\\n\\t\\treturn root\\n\\t}\\n\\n    // Process left and then right nodes\\n\\tleft := lowestCommonAncestor(root.Left, p, q)\\n\\tright := lowestCommonAncestor(root.Right, p, q)\\n\\n    // if both left and right aren\\'t null, that means we found the targets on both sides of trees, means we need to return root\\n\\tif left != nil && right != nil {\\n\\t\\treturn root\\n\\t}\\n\\t// if we find in left, return left\\n\\tif left != nil {\\n\\t\\treturn left\\n\\t}\\n    // else right\\n\\treturn right\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3090423,
                "title": "java-super-easy-solution-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root==null) return null;\\n        if(root==p || root==q) return root;\\n\\n        TreeNode left=lowestCommonAncestor(root.left,p,q);\\n        TreeNode right=lowestCommonAncestor(root.right,p,q);\\n\\n        if(left==null) return right;\\n        if(right==null) return left;\\n\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root==null) return null;\\n        if(root==p || root==q) return root;\\n\\n        TreeNode left=lowestCommonAncestor(root.left,p,q);\\n        TreeNode right=lowestCommonAncestor(root.right,p,q);\\n\\n        if(left==null) return right;\\n        if(right==null) return left;\\n\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042264,
                "title": "java-simple-easy-and-fast-solution",
                "content": "This is a followup question of Node root Path here we will calculate the Node root path from root to p and root to q and after filling both the lists we will traverse in both the list and to find the common node in the extreme right and that will be our answer .\\n\\nPlease upvote if understood \\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        ArrayList<TreeNode> path1 = new ArrayList<>();\\n        ArrayList<TreeNode> path2 = new ArrayList<>();\\n        \\n\\t\\t// This will fill both path1 and path2 list \\n         NodeRootPath(root,p,path1);\\n         NodeRootPath(root,q,path2);\\n        \\n        TreeNode common = root;\\n        for(int i=0 ;i<Math.min(path1.size(),path2.size());i++){\\n            if(path1.get(i)==path2.get(i)){\\n                common = path1.get(i);\\n            }\\n        }\\n        return common;\\n    }\\n    \\n    public boolean NodeRootPath(TreeNode root , TreeNode tar , ArrayList<TreeNode> path){\\n        if(root == null){\\n            return false ;\\n        }\\n        path.add(root);\\n        if(root == tar){\\n            return true ;\\n        }\\n        \\n        if(NodeRootPath(root.left,tar,path) || NodeRootPath(root.right,tar,path)){\\n            return true  ;\\n        }\\n        path.remove(path.size()-1);\\n        return false ;\\n    }\\n",
                "solutionTags": [
                    "Array",
                    "Backtracking",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "This is a followup question of Node root Path here we will calculate the Node root path from root to p and root to q and after filling both the lists we will traverse in both the list and to find the common node in the extreme right and that will be our answer .\\n\\nPlease upvote if understood \\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        ArrayList<TreeNode> path1 = new ArrayList<>();\\n        ArrayList<TreeNode> path2 = new ArrayList<>();\\n        \\n\\t\\t// This will fill both path1 and path2 list \\n         NodeRootPath(root,p,path1);\\n         NodeRootPath(root,q,path2);\\n        \\n        TreeNode common = root;\\n        for(int i=0 ;i<Math.min(path1.size(),path2.size());i++){\\n            if(path1.get(i)==path2.get(i)){\\n                common = path1.get(i);\\n            }\\n        }\\n        return common;\\n    }\\n    \\n    public boolean NodeRootPath(TreeNode root , TreeNode tar , ArrayList<TreeNode> path){\\n        if(root == null){\\n            return false ;\\n        }\\n        path.add(root);\\n        if(root == tar){\\n            return true ;\\n        }\\n        \\n        if(NodeRootPath(root.left,tar,path) || NodeRootPath(root.right,tar,path)){\\n            return true  ;\\n        }\\n        path.remove(path.size()-1);\\n        return false ;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2984604,
                "title": "java-and-python-3-explained-and-commented",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to find p and q in the tree, and move upward until we discover where the two paths meet. This goes bottom to top, which means we need to do some bookkeeping. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a map from each node\\'s value to that node\\'s parent. Call this map **parents**. It will be populated depth first.\\n2. Follow the line of parents from **p**, and insert each of them into the set **p_ancestors**.\\n3. Follow the line of parents from **q**, until one is a member of **p_ancestors**. Return this node.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) for an n-node tree. We traverse the entire tree to find each node and record its parents. We use this information to trace the path from **p** to root (O(1) lookup per node), and then from **q** to the lowest common ancestor node (also O(1) lookup per node).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) for an n-node tree. We create the **parents** map with n entries; we also create the set **pAncestors**, with a maximum of n members.\\n# Code (Java)\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n        Map<Integer, TreeNode> parents;     // Parent node, by current node\\'s value\\n        Set<Integer> pAncestors;            // A set for p\\'s ancestors\\n    \\n    /**\\n        The constructor sets up parents and pAncestors.\\n     */\\n    public Solution() {\\n        parents = new HashMap<Integer, TreeNode>();\\n        pAncestors = new HashSet<Integer>();\\n    }\\n\\n    /**\\n      Traverse the tree depth-first, finding the parent of each node and\\n      saving it to parents, recursively.\\n\\n      @param node the starting node\\n     */\\n    private void findAllParents(TreeNode node) {\\n        if (node.left != null) {\\n            parents.put(node.left.val, node);\\n            findAllParents(node.left);\\n        }\\n        if (node.right != null) {\\n            parents.put(node.right.val, node);\\n            findAllParents(node.right);\\n        }\\n    }\\n\\n    /**\\n        Traverse tree, depth first:\\n            At each node record its parent to the parents dictionary\\n        Follow the line of parents from p, and insert all into the set p_ancestors\\n        Follow the line of parents from q, until one is a member of p_ancestors\\n\\n        @param root     the root node of the tree\\n        @param p        first node to check\\n        @param q        second node to check\\n        @return the node that is the lowest common ancestor of p and q\\n     */\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        parents.put(root.val, null);\\n        findAllParents(root);\\n        while (p != null) {\\n            pAncestors.add(p.val);\\n            p = parents.get(p.val);\\n        }\\n        while (q != root && !pAncestors.contains(q.val))\\n            q = parents.get(q.val);\\n        return q;\\n    }\\n}\\n```\\n# Code (Python 3)\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        \\'\\'\\'\\n        Traverse tree, depth first:\\n            At each node record its parent to the parents dictionary\\n        Follow the line of parents from p, and insert all into the set p_ancestors\\n        Follow the line of parents from q, until one is a member of p_ancestors\\n        \\'\\'\\'\\n        parents = {root.val: None}      # Parent node, by current node\\'s value\\n        p_ancestors = set()             # A set for p\\'s ancestors\\n\\n        def find_all_parents(node: TreeNode) -> None:\\n            # Depth-first traversal to identify the parent of each node\\n            if node.left:\\n                parents[node.left.val] = node\\n                find_all_parents(node.left)\\n            if node.right:\\n                parents[node.right.val] = node\\n                find_all_parents(node.right)\\n    \\n        find_all_parents(root)\\n        while p is not None:\\n            p_ancestors.add(p.val)\\n            p = parents[p.val]\\n        while q != root and q.val not in p_ancestors:\\n            q = parents[q.val]\\n        return q\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n        Map<Integer, TreeNode> parents;     // Parent node, by current node\\'s value\\n        Set<Integer> pAncestors;            // A set for p\\'s ancestors\\n    \\n    /**\\n        The constructor sets up parents and pAncestors.\\n     */\\n    public Solution() {\\n        parents = new HashMap<Integer, TreeNode>();\\n        pAncestors = new HashSet<Integer>();\\n    }\\n\\n    /**\\n      Traverse the tree depth-first, finding the parent of each node and\\n      saving it to parents, recursively.\\n\\n      @param node the starting node\\n     */\\n    private void findAllParents(TreeNode node) {\\n        if (node.left != null) {\\n            parents.put(node.left.val, node);\\n            findAllParents(node.left);\\n        }\\n        if (node.right != null) {\\n            parents.put(node.right.val, node);\\n            findAllParents(node.right);\\n        }\\n    }\\n\\n    /**\\n        Traverse tree, depth first:\\n            At each node record its parent to the parents dictionary\\n        Follow the line of parents from p, and insert all into the set p_ancestors\\n        Follow the line of parents from q, until one is a member of p_ancestors\\n\\n        @param root     the root node of the tree\\n        @param p        first node to check\\n        @param q        second node to check\\n        @return the node that is the lowest common ancestor of p and q\\n     */\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        parents.put(root.val, null);\\n        findAllParents(root);\\n        while (p != null) {\\n            pAncestors.add(p.val);\\n            p = parents.get(p.val);\\n        }\\n        while (q != root && !pAncestors.contains(q.val))\\n            q = parents.get(q.val);\\n        return q;\\n    }\\n}\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        \\'\\'\\'\\n        Traverse tree, depth first:\\n            At each node record its parent to the parents dictionary\\n        Follow the line of parents from p, and insert all into the set p_ancestors\\n        Follow the line of parents from q, until one is a member of p_ancestors\\n        \\'\\'\\'\\n        parents = {root.val: None}      # Parent node, by current node\\'s value\\n        p_ancestors = set()             # A set for p\\'s ancestors\\n\\n        def find_all_parents(node: TreeNode) -> None:\\n            # Depth-first traversal to identify the parent of each node\\n            if node.left:\\n                parents[node.left.val] = node\\n                find_all_parents(node.left)\\n            if node.right:\\n                parents[node.right.val] = node\\n                find_all_parents(node.right)\\n    \\n        find_all_parents(root)\\n        while p is not None:\\n            p_ancestors.add(p.val)\\n            p = parents[p.val]\\n        while q != root and q.val not in p_ancestors:\\n            q = parents[q.val]\\n        return q\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830397,
                "title": "java-easy-to-understand-anuj-bhaiyya-working-code",
                "content": "Eaxact same code you can use in-> **235. Lowest Common Ancestor of a Binary Search Tree**\\n[https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree]()\\n\\n---\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root==p || root==q) return root;\\n        if(root==null) return null;\\n        TreeNode left=lowestCommonAncestor(root.left, p, q);\\n        TreeNode right=lowestCommonAncestor(root.right, p, q);\\n        if(left==null) return right;\\n        if(right==null) return left;\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root==p || root==q) return root;\\n        if(root==null) return null;\\n        TreeNode left=lowestCommonAncestor(root.left, p, q);\\n        TreeNode right=lowestCommonAncestor(root.right, p, q);\\n        if(left==null) return right;\\n        if(right==null) return left;\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792209,
                "title": "easiest-approach-shortest-solution-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root==NULL or root == p or root == q)return root;\\n        auto left = lowestCommonAncestor(root->left,p,q);\\n        auto right = lowestCommonAncestor(root->right,p,q);\\n        if(left == NULL)return right;\\n        else if(right == NULL)return left;\\n        else return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root==NULL or root == p or root == q)return root;\\n        auto left = lowestCommonAncestor(root->left,p,q);\\n        auto right = lowestCommonAncestor(root->right,p,q);\\n        if(left == NULL)return right;\\n        else if(right == NULL)return left;\\n        else return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336498,
                "title": "kotlin-dfs-easy-recursive-approach",
                "content": "```\\n\\n/*\\n    if leftSubtree and rightSubtree includes the nodes searched then it means we can easily\\n    return the root of those the left and right subtrees, \\n    \\n    In case of one of them is null, then the right one (itself) will be our lowest common ancestor\\n\\n*/\\nclass Solution {\\n    fun lowestCommonAncestor(root: TreeNode?, p: TreeNode?, q: TreeNode?): TreeNode? {\\n        \\n        if(root == null || p == root || q == root) return root\\n        \\n        val left = lowestCommonAncestor(root?.left, p,q)\\n        val right = lowestCommonAncestor(root?.right, p,q)\\n        \\n        if(left != null && right != null) {\\n            return root;\\n        }\\n        \\n        return if(left == null) right else left\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Depth-First Search"
                ],
                "code": "```\\n\\n/*\\n    if leftSubtree and rightSubtree includes the nodes searched then it means we can easily\\n    return the root of those the left and right subtrees, \\n    \\n    In case of one of them is null, then the right one (itself) will be our lowest common ancestor\\n\\n*/\\nclass Solution {\\n    fun lowestCommonAncestor(root: TreeNode?, p: TreeNode?, q: TreeNode?): TreeNode? {\\n        \\n        if(root == null || p == root || q == root) return root\\n        \\n        val left = lowestCommonAncestor(root?.left, p,q)\\n        val right = lowestCommonAncestor(root?.right, p,q)\\n        \\n        if(left != null && right != null) {\\n            return root;\\n        }\\n        \\n        return if(left == null) right else left\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2335739,
                "title": "beats-100-other-s-solutions",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        res = None\\n        def helper(node):\\n            nonlocal res\\n            if not node:\\n                return False\\n            l = helper(node.left)\\n            r = helper(node.right)\\n            mid = node == p or node == q\\n            if mid + l + r >= 2:\\n                res = node\\n            return mid or l or r\\n        helper(root)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        res = None\\n        def helper(node):\\n            nonlocal res\\n            if not node:\\n                return False\\n            l = helper(node.left)\\n            r = helper(node.right)\\n            mid = node == p or node == q\\n            if mid + l + r >= 2:\\n                res = node\\n            return mid or l or r\\n        helper(root)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2334632,
                "title": "easy-c-sol-naive-efficient-approaches-time-o-n",
                "content": "```\\n\\nAuthor : https://github.com/RajaKunalPandit1\\n\\n// Naive Solution :: Time : O(N) :: Aux_Space : O(N)\\n\\n  /**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    bool getPath(TreeNode *root,vector<TreeNode *> &res, int x){\\n\\n        if(root == NULL){\\n            return false;\\n        }\\n\\n        res.push_back(root);\\n\\n        if(root->val == x) return true;\\n\\n        if(getPath(root->left,res,x) || getPath(root->right,res,x)) return true;\\n\\n        res.pop_back();\\n        return false;\\n    }\\n\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\n        TreeNode *res;\\n\\n        if(!root){\\n            return {};\\n        }\\n\\n        vector<TreeNode *> v1;\\n        vector<TreeNode *> v2;\\n\\n        getPath(root,v1,p->val);\\n        getPath(root,v2,q->val);\\n\\n        int n = min(v1.size(),v2.size());\\n\\n        for(int i=0;i<n;i++){\\n            if(v1[i] == v2[i]){\\n                res = v1[i];\\n            }else{\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n// Efficient Solution :: Time : O(N) :: Aux_Space : O(N) [N cuz of Skew Trees]\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\n        if(root == NULL || root == q || root == p) return root;\\n\\n        TreeNode *left = lowestCommonAncestor(root->left,p,q);\\n        TreeNode *right = lowestCommonAncestor(root->right,p,q);\\n\\n        if(left == NULL){\\n            return right;\\n        }else if(right == NULL){\\n            return left;\\n        }else{\\n            return root;\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool getPath(TreeNode *root,vector<TreeNode *> &res, int x){\\n\\n        if(root == NULL){\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2334433,
                "title": "python-recursive-solution",
                "content": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if root == None or root == p or root == q:\\n            return root\\n        left = self.lowestCommonAncestor(root.left,p,q)\\n        right = self.lowestCommonAncestor(root.right,p,q)        \\n        if left != None and right != None:\\n            return root\\n        elif left != None:\\n            return left\\n        elif right != None:\\n            return right\\n```",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if root == None or root == p or root == q:\\n            return root\\n        left = self.lowestCommonAncestor(root.left,p,q)\\n        right = self.lowestCommonAncestor(root.right,p,q)        \\n        if left != None and right != None:\\n            return root\\n        elif left != None:\\n            return left\\n        elif right != None:\\n            return right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2334341,
                "title": "python-dfs-clear-and-simple-code-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        \\n        #DFS solution\\n        if (root == p or root == q or not root): return root  #found what we want or there is nothing\\n        \\n        left, right = self.lowestCommonAncestor(root.left, p, q), self.lowestCommonAncestor(root.right, p, q)\\n        \\n        if left and right:  #common ancestor\\n            return root\\n        elif left:\\n            return left\\n        elif right:\\n            return right\\n        \\n        return None\\n```\\nPlease UPVOTE if you like !!",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        \\n        #DFS solution\\n        if (root == p or root == q or not root): return root  #found what we want or there is nothing\\n        \\n        left, right = self.lowestCommonAncestor(root.left, p, q), self.lowestCommonAncestor(root.right, p, q)\\n        \\n        if left and right:  #common ancestor\\n            return root\\n        elif left:\\n            return left\\n        elif right:\\n            return right\\n        \\n        return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2334234,
                "title": "python3-easy-to-understand-iterative-solution",
                "content": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':    \\n        que = deque([root])\\n        parent = {root: None}\\n        \\n        while que:\\n            node = que.popleft()\\n            \\n            if node.left:\\n                que.append(node.left)\\n                parent[node.left] = node\\n            \\n            if node.right:\\n                que.append(node.right)\\n                parent[node.right] = node\\n            \\n            if p in parent and q in parent:\\n                break\\n        \\n        ancestors = set()\\n        while p:\\n            ancestors.add(p)\\n            p = parent[p]\\n        \\n        while q:\\n            if q in ancestors:\\n                return q\\n            q = parent[q]\\n```\\n\\nWhile we have many recursive solution in discussion, here\\'s iterative one. Please **upvote** if you find it helpful.",
                "solutionTags": [
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':    \\n        que = deque([root])\\n        parent = {root: None}\\n        \\n        while que:\\n            node = que.popleft()\\n            \\n            if node.left:\\n                que.append(node.left)\\n                parent[node.left] = node\\n            \\n            if node.right:\\n                que.append(node.right)\\n                parent[node.right] = node\\n            \\n            if p in parent and q in parent:\\n                break\\n        \\n        ancestors = set()\\n        while p:\\n            ancestors.add(p)\\n            p = parent[p]\\n        \\n        while q:\\n            if q in ancestors:\\n                return q\\n            q = parent[q]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292270,
                "title": "java-recursive-easy",
                "content": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        //base case\\n        if (root == null || root == p || root == q) {\\n            return root;\\n        }\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n\\n        //result\\n        if(left == null) {\\n            return right;\\n        }\\n        else if(right == null) {\\n            return left;\\n        }\\n        else { //both left and right are not null, we found our result\\n            return root;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        //base case\\n        if (root == null || root == p || root == q) {\\n            return root;\\n        }\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n\\n        //result\\n        if(left == null) {\\n            return right;\\n        }\\n        else if(right == null) {\\n            return left;\\n        }\\n        else { //both left and right are not null, we found our result\\n            return root;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219891,
                "title": "i-think-it-is-easy-to-understand-python-dfs",
                "content": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        \\n        path_p=[]; path_q=[]\\n        \\n        def DFS(r,path,t):\\n            if not r:\\n                return False\\n            path.append(r)\\n            if r.val==t.val:\\n                return True\\n            \\n            if (DFS(r.left , path , t) or DFS(r.right , path , t)):\\n                return True\\n            path.pop(-1)\\n            \\n            \\n        DFS(root,path_p,p)\\n        DFS(root,path_q,q)\\n        \\n        for n in range(min(len(path_q) , len(path_p))):\\n            if path_q[n] == path_p[n] :\\n                continue\\n            else:\\n                return path_q[n-1]\\n        return path_q[n]",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        \\n        path_p=[]; path_q=[]\\n        \\n        def DFS(r,path,t):\\n            if not r:\\n                return False\\n            path.append(r)\\n            if r.val==t.val:\\n                return True\\n            \\n            if (DFS(r.left , path , t) or DFS(r.right , path , t)):\\n                return True\\n            path.pop(-1)\\n            \\n            \\n        DFS(root,path_p,p)\\n        DFS(root,path_q,q)\\n        \\n        for n in range(min(len(path_q) , len(path_p))):\\n            if path_q[n] == path_p[n] :\\n                continue\\n            else:\\n                return path_q[n-1]\\n        return path_q[n]",
                "codeTag": "Java"
            },
            {
                "id": 2204505,
                "title": "c-recursion-5-lines",
                "content": "```\\npublic TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n\\tif (root == null || root == p || root == q) return root;\\n\\tTreeNode right = LowestCommonAncestor(root.right, p, q);\\n\\tTreeNode left = LowestCommonAncestor(root.left, p, q);\\n\\tif (left != null && right != null) return root;\\n\\treturn right != null ? right : left;\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\npublic TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n\\tif (root == null || root == p || root == q) return root;\\n\\tTreeNode right = LowestCommonAncestor(root.right, p, q);\\n\\tTreeNode left = LowestCommonAncestor(root.left, p, q);\\n\\tif (left != null && right != null) return root;\\n\\treturn right != null ? right : left;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1968868,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "\\n\\tclass Solution {\\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root==null || root==p || root==q) return root;\\n        TreeNode l = lowestCommonAncestor(root.left, p, q);\\n        TreeNode r = lowestCommonAncestor(root.right, p, q);\\n        \\n\\t\\t// If both p & q were found in sub-trees of root.\\n\\t\\tif(l!=null && r!=null) return root;\\n        \\n\\t\\t// if only either of them was found, then return the one which is not null.  This logic covers side cases.\\n\\t\\treturn l==null ? r : l;\\n    }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root==null || root==p || root==q) return root;\\n        TreeNode l = lowestCommonAncestor(root.left, p, q);\\n        TreeNode r = lowestCommonAncestor(root.right, p, q);\\n        \\n\\t\\t// If both p & q were found in sub-trees of root.\\n\\t\\tif(l!=null && r!=null) return root;\\n        \\n\\t\\t// if only either of them was found, then return the one which is not null.  This logic covers side cases.\\n\\t\\treturn l==null ? r : l;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1863672,
                "title": "simple-intuitive-c-solution-o-n-time",
                "content": "The algorithm can be understand  as:\\n1.  If the root is itself p or q than it is LCA.\\n2.  Else search for lca in left and right subtree\\n3.  Now suppose both left and right are not null, this implies one node (p or q) found in left subtree and the other node is found on the right subtree. This implies root is LCA.\\n4.  If left is Null this implies that both the the node must be present in right hence the answer is right otherwise the answer is left.\\n\\n Node* lca(Node* root, Node* p, Node* q) {\\n        \\n        if(!root) return NULL;\\n        \\n        if(root==p or root==q) return root; \\n        \\n        Node *left=lca(root->left,p,q);\\n        Node* right=lca(root->right,p,q);\\n        if(!left) return right;\\n        if(!right) return left;\\n        return root;\\n    }",
                "solutionTags": [
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "The algorithm can be understand  as:\\n1.  If the root is itself p or q than it is LCA.\\n2.  Else search for lca in left and right subtree\\n3.  Now suppose both left and right are not null, this implies one node (p or q) found in left subtree and the other node is found on the right subtree. This implies root is LCA.\\n4.  If left is Null this implies that both the the node must be present in right hence the answer is right otherwise the answer is left.\\n\\n Node* lca(Node* root, Node* p, Node* q) {\\n        \\n        if(!root) return NULL;\\n        \\n        if(root==p or root==q) return root; \\n        \\n        Node *left=lca(root->left,p,q);\\n        Node* right=lca(root->right,p,q);\\n        if(!left) return right;\\n        if(!right) return left;\\n        return root;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1602926,
                "title": "python-easy-to-understand-recursive",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        return self.helper(root, p, q)\\n        \\n    def helper(self, node, p, q):\\n        if node is None:\\n            return None\\n        \\n        if node.val == p.val or node.val == q.val:\\n            return node\\n        \\n        left_sub = self.helper(node.left, p, q)\\n        right_sub = self.helper(node.right, p, q)\\n        \\n        if left_sub is None:\\n            return right_sub\\n        if right_sub is None:\\n            return left_sub\\n\\n        return node\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        return self.helper(root, p, q)\\n        \\n    def helper(self, node, p, q):\\n        if node is None:\\n            return None\\n        \\n        if node.val == p.val or node.val == q.val:\\n            return node\\n        \\n        left_sub = self.helper(node.left, p, q)\\n        right_sub = self.helper(node.right, p, q)\\n        \\n        if left_sub is None:\\n            return right_sub\\n        if right_sub is None:\\n            return left_sub\\n\\n        return node\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1490384,
                "title": "2-approaches-path-array-s-dfs-c-o-n",
                "content": "Implementation\\n\\n**1st Approach Using path arrays**\\n**Time Complexity = O(N), Space Complexity = O(H) where H is the height of the Binary Tree**\\n**In this solution we require three traversal of binary tree (0(N)+0(N)+0(N)) => 3(0(N)) => 0(N).**\\n\\n```\\nclass Solution {\\npublic:\\n    bool findPath(TreeNode* root, vector<TreeNode*> &path, TreeNode* node){\\n        if(root == NULL) return false;\\n        path.push_back(root);\\n        if(root == node) return true;\\n        if(findPath(root->left, path, node) || findPath(root->right, path, node)) return true;\\n        path.pop_back();\\n        return false;\\n    }\\n    \\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        vector<TreeNode*> path1, path2;\\n        if(findPath(root, path1, p) == false || findPath(root, path2, q) == false) return NULL;\\n        int itr = 0;\\n        for(itr; itr < min(path1.size(), path2.size()); itr++){\\n            if(path1[itr] != path2[itr]) break;\\n        }\\n        return path1[itr-1];\\n    }\\n};\\n```\\n\\n\\n**2nd Approach Using DFS\\nTime Complexity = O(N), Space Complexity = O(H) where H is the height of the Binary Tree\\nIn this solution we require only one traversal of binary tree.\\nBut in this approach both given key should be present.**\\n\\nclass Solution {\\n```\\npublic:    \\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root == NULL) return NULL;\\n        if(root == p || root == q) return root;\\n        TreeNode* lcaLeft = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* lcaRight = lowestCommonAncestor(root->right, p, q);\\n        if(lcaLeft && lcaRight) return root;        \\n        return lcaLeft ? lcaLeft : lcaRight;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findPath(TreeNode* root, vector<TreeNode*> &path, TreeNode* node){\\n        if(root == NULL) return false;\\n        path.push_back(root);\\n        if(root == node) return true;\\n        if(findPath(root->left, path, node) || findPath(root->right, path, node)) return true;\\n        path.pop_back();\\n        return false;\\n    }\\n    \\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        vector<TreeNode*> path1, path2;\\n        if(findPath(root, path1, p) == false || findPath(root, path2, q) == false) return NULL;\\n        int itr = 0;\\n        for(itr; itr < min(path1.size(), path2.size()); itr++){\\n            if(path1[itr] != path2[itr]) break;\\n        }\\n        return path1[itr-1];\\n    }\\n};\\n```\n```\\npublic:    \\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root == NULL) return NULL;\\n        if(root == p || root == q) return root;\\n        TreeNode* lcaLeft = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* lcaRight = lowestCommonAncestor(root->right, p, q);\\n        if(lcaLeft && lcaRight) return root;        \\n        return lcaLeft ? lcaLeft : lcaRight;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1476396,
                "title": "java-100-faster-recursion-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root==null || root==p || root==q) return root;\\n        TreeNode l = lowestCommonAncestor(root.left, p, q);\\n        TreeNode r = lowestCommonAncestor(root.right, p, q);\\n        \\n\\t\\t// If both p & q were found in sub-trees of root.\\n\\t\\tif(l!=null && r!=null) return root;\\n        \\n\\t\\t// if only either of them was found, then return the one which is not null.  This logic covers side cases.\\n\\t\\treturn l==null ? r : l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root==null || root==p || root==q) return root;\\n        TreeNode l = lowestCommonAncestor(root.left, p, q);\\n        TreeNode r = lowestCommonAncestor(root.right, p, q);\\n        \\n\\t\\t// If both p & q were found in sub-trees of root.\\n\\t\\tif(l!=null && r!=null) return root;\\n        \\n\\t\\t// if only either of them was found, then return the one which is not null.  This logic covers side cases.\\n\\t\\treturn l==null ? r : l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1476209,
                "title": "python3-recursive-clean-code-faster-than-80",
                "content": "\\n    def lowestCommonAncestor(self, root, p, q):\\n\\t\\n        if not root: return None\\n\\t\\t\\n        if root == p or root == q: return root\\n\\t\\t\\n        l = self.lowestCommonAncestor(root.left, p, q)\\n        r = self.lowestCommonAncestor(root.right, p, q)\\n\\t\\t\\n        if l and r:\\n            return root\\n        else: return l if l else r",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "\\n    def lowestCommonAncestor(self, root, p, q):\\n\\t\\n        if not root: return None\\n\\t\\t\\n        if root == p or root == q: return root\\n\\t\\t\\n        l = self.lowestCommonAncestor(root.left, p, q)\\n        r = self.lowestCommonAncestor(root.right, p, q)\\n\\t\\t\\n        if l and r:\\n            return root\\n        else: return l if l else r",
                "codeTag": "Python3"
            },
            {
                "id": 1432959,
                "title": "js-o-n-time-and-space",
                "content": "Approach: Recursively go to the left and right child of each node and check if the value equals either of `p` or `q`. If the value matches, return the node. For each parent node, check if eboth left and right child returns a node and not null. If both returns node, that means the parent node is the LCA of the two nodes, so return that node.\\n\\n```\\nvar lowestCommonAncestor = function(root, p, q) {\\n    if(!root) {\\n        return null;\\n    }\\n\\t// recursive call to left and right child of each node\\n    const left = lowestCommonAncestor(root.left, p, q),\\n          right = lowestCommonAncestor(root.right, p, q);\\n    \\n\\t// if either both left and right child return a node or the root node value matches p or q node value,\\n\\t// return the node\\n    if((left && right) || root.val === p.val || root.val === q.val) {\\n        return root;\\n    } else if(left) {    // if only one of the p or q node is found at the left child, return that\\n        return left;\\n    } else if(right) {    // if only one of the p or q node is found at the right child, return that\\n        return right;\\n    }\\n    return null;    // none of the nodes is found when this node is processed completely, so return null\\n};\\n```\\n\\nTime Complexity = O(n)\\nSpace Complexity = O(n) [call stack - O(h) but O(n) in case of skewed tree]",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar lowestCommonAncestor = function(root, p, q) {\\n    if(!root) {\\n        return null;\\n    }\\n\\t// recursive call to left and right child of each node\\n    const left = lowestCommonAncestor(root.left, p, q),\\n          right = lowestCommonAncestor(root.right, p, q);\\n    \\n\\t// if either both left and right child return a node or the root node value matches p or q node value,\\n\\t// return the node\\n    if((left && right) || root.val === p.val || root.val === q.val) {\\n        return root;\\n    } else if(left) {    // if only one of the p or q node is found at the left child, return that\\n        return left;\\n    } else if(right) {    // if only one of the p or q node is found at the right child, return that\\n        return right;\\n    }\\n    return null;    // none of the nodes is found when this node is processed completely, so return null\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1367273,
                "title": "n-ary-tree-for-lca",
                "content": "I was asked this question in today\\'s Microsoft VO.  \\nN-ary Tree and two TreeNode\\'s LCA\\n\\n```\\npublic class Solution {\\n    \\n    public static TreeNode firstCommonAncester(TreeNode root, TreeNode n1, TreeNode n2) {\\n        if (root == null || root == n1 || root == n2) return root;\\n        if (root.children == null || root.children.size() == 0) return null;\\n        int count = 0;\\n        TreeNode res = null;\\n        for (TreeNode child : root.children) {\\n            TreeNode cur = firstCommonAncester(child, n1, n2);\\n            if (cur != null) {\\n                count++;\\n                res = cur;\\n            }\\n        }\\n        if (count == 2) return root;\\n        return res;\\n    }\\n    \\n    public static void main(String[] args) {\\n        //System.out.println(\"Hello World!\");\\n        TreeNode r1 = new TreeNode(5);\\n        TreeNode r2 = new TreeNode(1);\\n        TreeNode r3 = new TreeNode(2);\\n        List<TreeNode> c1 = Arrays.asList(new TreeNode[]{r2, r3});\\n        r1.children = c1;\\n        \\n        TreeNode r4 = new TreeNode(6);\\n        TreeNode r5 = new TreeNode(8);\\n        TreeNode r6 = new TreeNode(18);\\n        List<TreeNode> c3 = Arrays.asList(new TreeNode[]{r4, r5, r6});\\n        r3.children = c3;\\n        \\n        TreeNode r7 = new TreeNode(10);\\n        List<TreeNode> c4 =  Arrays.asList(new TreeNode[]{r7});\\n        r4.children = c4;\\n        TreeNode res = firstCommonAncester(r1, r5, r2);\\n        System.out.println(res.val);\\n    }\\n}\\n\\nclass TreeNode {\\n    int val;\\n    List<TreeNode> children;\\n    TreeNode(int val) {\\n        this.val = val;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    \\n    public static TreeNode firstCommonAncester(TreeNode root, TreeNode n1, TreeNode n2) {\\n        if (root == null || root == n1 || root == n2) return root;\\n        if (root.children == null || root.children.size() == 0) return null;\\n        int count = 0;\\n        TreeNode res = null;\\n        for (TreeNode child : root.children) {\\n            TreeNode cur = firstCommonAncester(child, n1, n2);\\n            if (cur != null) {\\n                count++;\\n                res = cur;\\n            }\\n        }\\n        if (count == 2) return root;\\n        return res;\\n    }\\n    \\n    public static void main(String[] args) {\\n        //System.out.println(\"Hello World!\");\\n        TreeNode r1 = new TreeNode(5);\\n        TreeNode r2 = new TreeNode(1);\\n        TreeNode r3 = new TreeNode(2);\\n        List<TreeNode> c1 = Arrays.asList(new TreeNode[]{r2, r3});\\n        r1.children = c1;\\n        \\n        TreeNode r4 = new TreeNode(6);\\n        TreeNode r5 = new TreeNode(8);\\n        TreeNode r6 = new TreeNode(18);\\n        List<TreeNode> c3 = Arrays.asList(new TreeNode[]{r4, r5, r6});\\n        r3.children = c3;\\n        \\n        TreeNode r7 = new TreeNode(10);\\n        List<TreeNode> c4 =  Arrays.asList(new TreeNode[]{r7});\\n        r4.children = c4;\\n        TreeNode res = firstCommonAncester(r1, r5, r2);\\n        System.out.println(res.val);\\n    }\\n}\\n\\nclass TreeNode {\\n    int val;\\n    List<TreeNode> children;\\n    TreeNode(int val) {\\n        this.val = val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1349073,
                "title": "simple-c-iterative-approach",
                "content": "```\\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        stack<TreeNode*> s;\\n        unordered_map<TreeNode*,TreeNode*> mp;\\n        mp[root]=NULL;\\n        s.push(root);\\n        while(mp.find(p)==mp.end() || mp.find(q)==mp.end()){\\n            TreeNode *t=s.top();\\n            s.pop();\\n            if(t->left){\\n                mp[t->left]=t;\\n                s.push(t->left);\\n            }\\n            if(t->right){\\n                mp[t->right]=t;\\n                s.push(t->right);\\n            }\\n        }\\n        set<TreeNode*> sett;\\n        while(p!=NULL){\\n            sett.insert(p);\\n            p=mp[p];\\n        }\\n        while(sett.find(q)==sett.end()){\\n            q=mp[q];\\n        }\\n        return q;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        stack<TreeNode*> s;\\n        unordered_map<TreeNode*,TreeNode*> mp;\\n        mp[root]=NULL;\\n        s.push(root);\\n        while(mp.find(p)==mp.end() || mp.find(q)==mp.end()){\\n            TreeNode *t=s.top();\\n            s.pop();\\n            if(t->left){\\n                mp[t->left]=t;\\n                s.push(t->left);\\n            }\\n            if(t->right){\\n                mp[t->right]=t;\\n                s.push(t->right);\\n            }\\n        }\\n        set<TreeNode*> sett;\\n        while(p!=NULL){\\n            sett.insert(p);\\n            p=mp[p];\\n        }\\n        while(sett.find(q)==sett.end()){\\n            q=mp[q];\\n        }\\n        return q;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1307284,
                "title": "c-4-liner-code",
                "content": "Require one traversal and theta(h) space for the recursive traversal.\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        \\n        if(root == NULL || root == p || root == q) return root;\\n        TreeNode* leftlca = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* rightlca = lowestCommonAncestor(root->right, p, q);\\n        return (leftlca == NULL ? rightlca : (rightlca==NULL) ?  leftlca :  root); \\n          \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        \\n        if(root == NULL || root == p || root == q) return root;\\n        TreeNode* leftlca = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* rightlca = lowestCommonAncestor(root->right, p, q);\\n        return (leftlca == NULL ? rightlca : (rightlca==NULL) ?  leftlca :  root); \\n          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113932,
                "title": "4-liner-explained",
                "content": "```\\n// JS\\nvar lowestCommonAncestor = function (root, p, q) {\\n  if (!root || root === p || root === q) return root; // edge case or found p or q: return root\\n  const left = lowestCommonAncestor(root.left, p, q); // look if left child has p or q\\n  const right = lowestCommonAncestor(root.right, p, q); // look if right child has p or q\\n  return left && right ? root : left || right; // if both children returned a node, then current is an ancestor of p and q (LCA)\\n};\\n```\\n\\n```\\n// TS\\nfunction lowestCommonAncestor(\\n  root: TreeNode | null,\\n  p: TreeNode | null,\\n  q: TreeNode | null\\n): TreeNode | null {\\n  if (!root || root === p || root === q) return root;\\n  const left = lowestCommonAncestor(root.left, p, q);\\n  const right = lowestCommonAncestor(root.right, p, q);\\n  return left && right ? root : left || right;\\n}\\n```\\n\\nMore leetcode TypeScript solutions at https://github.com/eddyhdzg/leetcode-typescript-solutions\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n// JS\\nvar lowestCommonAncestor = function (root, p, q) {\\n  if (!root || root === p || root === q) return root; // edge case or found p or q: return root\\n  const left = lowestCommonAncestor(root.left, p, q); // look if left child has p or q\\n  const right = lowestCommonAncestor(root.right, p, q); // look if right child has p or q\\n  return left && right ? root : left || right; // if both children returned a node, then current is an ancestor of p and q (LCA)\\n};\\n```\n```\\n// TS\\nfunction lowestCommonAncestor(\\n  root: TreeNode | null,\\n  p: TreeNode | null,\\n  q: TreeNode | null\\n): TreeNode | null {\\n  if (!root || root === p || root === q) return root;\\n  const left = lowestCommonAncestor(root.left, p, q);\\n  const right = lowestCommonAncestor(root.right, p, q);\\n  return left && right ? root : left || right;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1013223,
                "title": "faster-than-99-10-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root==NULL) return NULL;\\n        if(root==p || root==q)\\n            return root;\\n        TreeNode*l=lowestCommonAncestor(root->left,p,q);\\n        TreeNode*r=lowestCommonAncestor(root->right,p,q);\\n        if(l!=NULL && r!=NULL)\\n            return root;\\n        return (l?l:r);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root==NULL) return NULL;\\n        if(root==p || root==q)\\n            return root;\\n        TreeNode*l=lowestCommonAncestor(root->left,p,q);\\n        TreeNode*r=lowestCommonAncestor(root->right,p,q);\\n        if(l!=NULL && r!=NULL)\\n            return root;\\n        return (l?l:r);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 632922,
                "title": "simple-java-solution-no-extra-variable-100-faster",
                "content": "```\\n public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n       if(root==null) {\\n           return null;\\n       } \\n       if(root.val==p.val ||root.val==q.val) {\\n           return root;\\n       }\\n       TreeNode l = lowestCommonAncestor(root.left,p,q);\\n       TreeNode r =  lowestCommonAncestor(root.right,p,q);\\n       if(l!=null && r!=null){\\n          return root;\\n       }\\n       return l!=null?l:r; \\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n       if(root==null) {\\n           return null;\\n       } \\n       if(root.val==p.val ||root.val==q.val) {\\n           return root;\\n       }\\n       TreeNode l = lowestCommonAncestor(root.left,p,q);\\n       TreeNode r =  lowestCommonAncestor(root.right,p,q);\\n       if(l!=null && r!=null){\\n          return root;\\n       }\\n       return l!=null?l:r; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 353652,
                "title": "beats-100-java-simple-solution",
                "content": "```\\n  public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null) {\\n            return null;\\n        } \\n        if(root == p || root == q) {\\n            return root;\\n        }\\n        \\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n        if(left != null && right != null) {\\n            return root;\\n        }\\n        else if(left != null && right == null) {\\n            return left;\\n        } \\n        else if (left == null && right != null) {\\n            return right;\\n        } \\n        else { \\n            return null;\\n        }\\n        \\n     }\\n```",
                "solutionTags": [],
                "code": "```\\n  public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null) {\\n            return null;\\n        } \\n        if(root == p || root == q) {\\n            return root;\\n        }\\n        \\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n        if(left != null && right != null) {\\n            return root;\\n        }\\n        else if(left != null && right == null) {\\n            return left;\\n        } \\n        else if (left == null && right != null) {\\n            return right;\\n        } \\n        else { \\n            return null;\\n        }\\n        \\n     }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 338294,
                "title": "simple-python-readable-solution-beats-99-89",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if root:\\n            if root== p  or root==q:\\n                return root            \\n            else:\\n                left = root.left and self.lowestCommonAncestor(root.left, p,q)\\n                right  = root.right and self.lowestCommonAncestor(root.right , p,q)\\n                if left and right:\\n                    return root\\n                return left or right\\n        return None\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if root:\\n            if root== p  or root==q:\\n                return root            \\n            else:\\n                left = root.left and self.lowestCommonAncestor(root.left, p,q)\\n                right  = root.right and self.lowestCommonAncestor(root.right , p,q)\\n                if left and right:\\n                    return root\\n                return left or right\\n        return None\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 319631,
                "title": "java-straightforward-solution-6-lines",
                "content": "```\\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null || root.val == p.val || root.val == q.val) {\\n            return root;\\n        }\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n        if (left != null && right != null) {\\n            return root;\\n        }\\n        return left != null ? left : right;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null || root.val == p.val || root.val == q.val) {\\n            return root;\\n        }\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n        if (left != null && right != null) {\\n            return root;\\n        }\\n        return left != null ? left : right;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 213243,
                "title": "simple-and-efficent-golang-100",
                "content": "Simple dfs, runtime 16ms, faster than 100% of Golang submissions.\\n\\n```\\n func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\\n     if root == nil {\\n         return nil\\n     } else if root == p {\\n         return p\\n     } else if root == q {\\n         return q\\n     }\\n     \\n     lc := lowestCommonAncestor(root.Left, p, q)\\n     rc := lowestCommonAncestor(root.Right, p, q)\\n     \\n     if lc != nil && rc != nil {\\n         return root\\n     } else if lc != nil {\\n         return lc\\n     } else {\\n         return rc\\n     }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\\n     if root == nil {\\n         return nil\\n     } else if root == p {\\n         return p\\n     } else if root == q {\\n         return q\\n     }\\n     \\n     lc := lowestCommonAncestor(root.Left, p, q)\\n     rc := lowestCommonAncestor(root.Right, p, q)\\n     \\n     if lc != nil && rc != nil {\\n         return root\\n     } else if lc != nil {\\n         return lc\\n     } else {\\n         return rc\\n     }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 181505,
                "title": "python-recursive",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not root:\\n            return None\\n        if root.val == p.val or root.val == q.val:\\n            return root\\n        \\n        left_lca = self.lowestCommonAncestor(root.left, p, q)\\n        right_lca = self.lowestCommonAncestor(root.right, p, q)\\n        \\n        if left_lca and right_lca:\\n            return root\\n        elif left_lca:\\n            return left_lca\\n        else:\\n            return right_lca\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not root:\\n            return None\\n        if root.val == p.val or root.val == q.val:\\n            return root\\n        \\n        left_lca = self.lowestCommonAncestor(root.left, p, q)\\n        right_lca = self.lowestCommonAncestor(root.right, p, q)\\n        \\n        if left_lca and right_lca:\\n            return root\\n        elif left_lca:\\n            return left_lca\\n        else:\\n            return right_lca\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 65371,
                "title": "java-solution-by-finding-the-path-for-each-node",
                "content": "Find the path for each node.\\nCompare each path to find the LCA\\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q){\\n        if(root==null) return null;\\n        if(p==null || q==null)  return null;\\n        ArrayList<TreeNode> p_path = new ArrayList<TreeNode>();\\n        ArrayList<TreeNode> q_path = new ArrayList<TreeNode>();\\n        findPath(root, p, p_path);\\n        findPath(root, q, q_path);\\n        int min_len = Math.min(p_path.size(), q_path.size());\\n        int LCA = 0;\\n        for(int i=0; i<min_len; i++){\\n            if(p_path.get(i)==q_path.get(i))\\n                LCA = i;\\n        }return p_path.get(LCA);\\n        \\n    }\\n    public static boolean findPath(TreeNode root, TreeNode n1, List<TreeNode> path){\\n\\t\\tif(root == null)\\n\\t\\t\\treturn false;\\n\\t\\tpath.add(root);\\n\\t\\tif(root == n1)\\n\\t\\t\\treturn true;\\n\\t\\tif(findPath (root.left, n1, path) || findPath(root.right, n1, path))\\n\\t\\t\\treturn true;\\n\\t\\tpath.remove(path.size() - 1);\\n\\t\\treturn false;\\n\\t}",
                "solutionTags": [],
                "code": "Find the path for each node.\\nCompare each path to find the LCA\\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q){\\n        if(root==null) return null;\\n        if(p==null || q==null)  return null;\\n        ArrayList<TreeNode> p_path = new ArrayList<TreeNode>();\\n        ArrayList<TreeNode> q_path = new ArrayList<TreeNode>();\\n        findPath(root, p, p_path);\\n        findPath(root, q, q_path);\\n        int min_len = Math.min(p_path.size(), q_path.size());\\n        int LCA = 0;\\n        for(int i=0; i<min_len; i++){\\n            if(p_path.get(i)==q_path.get(i))\\n                LCA = i;\\n        }return p_path.get(LCA);\\n        \\n    }\\n    public static boolean findPath(TreeNode root, TreeNode n1, List<TreeNode> path){\\n\\t\\tif(root == null)\\n\\t\\t\\treturn false;\\n\\t\\tpath.add(root);\\n\\t\\tif(root == n1)\\n\\t\\t\\treturn true;\\n\\t\\tif(findPath (root.left, n1, path) || findPath(root.right, n1, path))\\n\\t\\t\\treturn true;\\n\\t\\tpath.remove(path.size() - 1);\\n\\t\\treturn false;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 65392,
                "title": "120ms-python-solution",
                "content": "I don't know what's going on. I'll admit if my solution is 100% correct, then the test cases might be too easy...\\n\\n    class Solution(object):\\n        def lowestCommonAncestor(self, root, p, q):\\n            \"\"\"\\n            :type root: TreeNode\\n            :type p: TreeNode\\n            :type q: TreeNode\\n            :rtype: TreeNode\\n            \"\"\"\\n            if not root:\\n                return root\\n                \\n            left = self.lowestCommonAncestor(root.left, p, q)\\n            right = self.lowestCommonAncestor(root.right, p, q)\\n            \\n            if (p == root or q == root) or (left and right):\\n                return root\\n            else:\\n                return left if left else right",
                "solutionTags": [
                    "Python"
                ],
                "code": "I don't know what's going on. I'll admit if my solution is 100% correct, then the test cases might be too easy...\\n\\n    class Solution(object):\\n        def lowestCommonAncestor(self, root, p, q):\\n            \"\"\"\\n            :type root: TreeNode\\n            :type p: TreeNode\\n            :type q: TreeNode\\n            :rtype: TreeNode\\n            \"\"\"\\n            if not root:\\n                return root\\n                \\n            left = self.lowestCommonAncestor(root.left, p, q)\\n            right = self.lowestCommonAncestor(root.right, p, q)\\n            \\n            if (p == root or q == root) or (left and right):\\n                return root\\n            else:\\n                return left if left else right",
                "codeTag": "Java"
            },
            {
                "id": 3959105,
                "title": "2-easy-c-solutions-recursive-and-iterative-approach-beats-100",
                "content": "# Code\\n```\\n// Recursive solution\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root == NULL || root == p || root == q)\\n            return root;\\n        \\n        TreeNode *leftAns = lowestCommonAncestor(root->left, p, q);\\n        TreeNode *rightAns = lowestCommonAncestor(root->right, p, q);\\n\\n        if(leftAns != NULL && rightAns != NULL)\\n            return root;\\n        else if(leftAns != NULL && rightAns == NULL)\\n            return leftAns;\\n        return rightAns;\\n    }\\n};\\n\\n// Iterative solution\\nclass Solution{\\npublic: \\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (root == NULL || root == p || root == q) \\n            return root;\\n\\n        unordered_map<TreeNode*, TreeNode*> parent;\\n        parent[root] = NULL;\\n\\n        stack<TreeNode*> stk;\\n        stk.push(root);\\n        \\n        while (parent[p] != NULL || parent[q] != NULL) {\\n            TreeNode* node = stk.top(); \\n            stk.pop();\\n            \\n            if (node->left != NULL) {\\n                parent[node->left] = node;\\n                stk.push(node->left);\\n            } \\n            if (node->right != NULL) {\\n                parent[node->right] = node;\\n                stk.push(node->right);\\n            }\\n        }\\n        \\n        set<TreeNode*> ancestor;\\n        while (p) {\\n            ancestor.insert(p);\\n            p = parent[p];\\n        }\\n        while (ancestor.find(q) == ancestor.end()) {\\n            q = parent[q];\\n        }\\n        return q;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n// Recursive solution\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root == NULL || root == p || root == q)\\n            return root;\\n        \\n        TreeNode *leftAns = lowestCommonAncestor(root->left, p, q);\\n        TreeNode *rightAns = lowestCommonAncestor(root->right, p, q);\\n\\n        if(leftAns != NULL && rightAns != NULL)\\n            return root;\\n        else if(leftAns != NULL && rightAns == NULL)\\n            return leftAns;\\n        return rightAns;\\n    }\\n};\\n\\n// Iterative solution\\nclass Solution{\\npublic: \\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (root == NULL || root == p || root == q) \\n            return root;\\n\\n        unordered_map<TreeNode*, TreeNode*> parent;\\n        parent[root] = NULL;\\n\\n        stack<TreeNode*> stk;\\n        stk.push(root);\\n        \\n        while (parent[p] != NULL || parent[q] != NULL) {\\n            TreeNode* node = stk.top(); \\n            stk.pop();\\n            \\n            if (node->left != NULL) {\\n                parent[node->left] = node;\\n                stk.push(node->left);\\n            } \\n            if (node->right != NULL) {\\n                parent[node->right] = node;\\n                stk.push(node->right);\\n            }\\n        }\\n        \\n        set<TreeNode*> ancestor;\\n        while (p) {\\n            ancestor.insert(p);\\n            p = parent[p];\\n        }\\n        while (ancestor.find(q) == ancestor.end()) {\\n            q = parent[q];\\n        }\\n        return q;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935711,
                "title": "c-simple-recursive-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to return in bottom-up manner to avoid searching the same subtree multiple times\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAt each root we make recursive calls to the left and right subtree and return on the basis of follwoing criteria\\nReturn root if its equal to p or q\\nReturn p if only p is present\\nReturn q if only q is present\\nReturn LCA if already found\\nReturn NULL if none are present\\nReturn root if LST and RST each have p/q \\n# Complexity\\n- Time complexity: O(number of nodes)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(height) due to recursion\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(!root) return nullptr;\\n        if(root->val == p->val || root->val == q->val) return root;\\n\\n        TreeNode* lst = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* rst = lowestCommonAncestor(root->right, p, q);\\n        if(!lst) return rst; //always return the non NULL value\\n        if(!rst) return lst; // if both are NULL we return NULL only\\n\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(!root) return nullptr;\\n        if(root->val == p->val || root->val == q->val) return root;\\n\\n        TreeNode* lst = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* rst = lowestCommonAncestor(root->right, p, q);\\n        if(!lst) return rst; //always return the non NULL value\\n        if(!rst) return lst; // if both are NULL we return NULL only\\n\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732751,
                "title": "dfs-approach-for-lca-beats-100-best-optimized",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse depth first search approach,\\n1. Go to left, if it matches one of the values then return the node else return null.\\n2. Then go right and do the same.\\n3. If both returns null then that particular node is our LCA.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null || root == p || root == q) return root;\\n\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n\\n        if(left == null){\\n            return right;\\n        }\\n        else if(right == null){\\n            return left;\\n        }\\n        else{\\n            return root;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null || root == p || root == q) return root;\\n\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n\\n        if(left == null){\\n            return right;\\n        }\\n        else if(right == null){\\n            return left;\\n        }\\n        else{\\n            return root;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682917,
                "title": "easy-c-solution-beat-97-5",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* &root, TreeNode* p, TreeNode* q) {\\n        if(root==NULL)\\n            return NULL;\\n        \\n        if(root->val==p->val)\\n            return p;\\n        if(root->val==q->val)\\n            return q;\\n        TreeNode* leftans=lowestCommonAncestor(root->left,p,q);\\n        TreeNode* rightans=lowestCommonAncestor(root->right,p,q);\\n        \\n        if(leftans==NULL&&rightans==NULL)\\n            return NULL;\\n        if(leftans!=NULL&&rightans==NULL)\\n            return leftans;\\n        if(leftans==NULL&&rightans!=NULL)\\n            return rightans;\\n        else\\n            return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* &root, TreeNode* p, TreeNode* q) {\\n        if(root==NULL)\\n            return NULL;\\n        \\n        if(root->val==p->val)\\n            return p;\\n        if(root->val==q->val)\\n            return q;\\n        TreeNode* leftans=lowestCommonAncestor(root->left,p,q);\\n        TreeNode* rightans=lowestCommonAncestor(root->right,p,q);\\n        \\n        if(leftans==NULL&&rightans==NULL)\\n            return NULL;\\n        if(leftans!=NULL&&rightans==NULL)\\n            return leftans;\\n        if(leftans==NULL&&rightans!=NULL)\\n            return rightans;\\n        else\\n            return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564871,
                "content": [
                    {
                        "username": "jack76",
                        "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS(preOrder).. Easy solution\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three parameters: `root` (the current node), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n2. Check if the current node `root` is null or if it is either `p` or `q`. If any of these conditions is true, return the current node `root` as the lowest common ancestor.\\n\\n3. Recursively call the `rec` function for the left subtree of the current node and assign the result to a variable `l`.\\n\\n4. Recursively call the `rec` function for the right subtree of the current node and assign the result to a variable `r`.\\n\\n5. Check if both `l` and `r` are not null. If so, it means that `p` and `q` are found on different subtrees of the current node, and the current node `root` is their lowest common ancestor. Return the current node `root`.\\n\\n6. If `l` is null, it means that both `p` and `q` are on the right subtree (or not present in the tree). Return `r`.\\n\\n7. If none of the above conditions are met, it means that both `p` and `q` are on the left subtree (or not present in the tree). Return `l`.\\n\\n8. Define a function `lowestCommonAncestor` that takes three parameters: `root` (the root node of the tree), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n9. Return the result of calling the `rec` function with the parameters `root`, `p`, and `q`. This will find and return the lowest common ancestor of nodes `p` and `q` in the given binary tree.\\n\\n-------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n). All node have to visit in worst case.\\n\\n- Space complexity:\\nS.C=O(n) in worst case skewed tree. recursive stack take O(n).\\n--------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3702977/c-dfs-preorder-easy-solution/"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "Update: The bug is already fixed! Thanks LC\\n\\nIt may be due to how OJ parses the test case: every time I tried to run the testcase, it spat `5 is not a valid value of type TreeNode`. \\nI also tried to enclose 5 and 1 in `[]`but no lucky there.\\nCould someone fix this, or let me know if there is a temporary fix on my end, thanks!"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "When I checked some others solutions committed and passed, I found that, they all miss the checking step,which means we need to check if there are both p and q in this tree.\\n\\nfor example,there is a question name called Share C++/C# 24ms recursive solution , the solution it shows doesn't check wether TreeNode p and TreeNode q exist when it returns.\\n\\nSo what do you guys think??"
                    },
                    {
                        "username": "GUTTTS",
                        "content": "[@mochiball](/mochiball) bro he wrote that in 2015 maybe that time there wasnt anything mentioned in the constraints\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Please read the question constraints. It tells you that p and q are in the tree. No need to check if they exist "
                    },
                    {
                        "username": "harsha335",
                        "content": "in constraints they mentioned both p and q will be present in tree and they are unique and not equal."
                    },
                    {
                        "username": "gepo",
                        "content": "Something is going wrong.\\nLine 41: TypeError: object of type \\'int\\' has no len()"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020 \\n\\nIt is important for me to train myself to get familar with C# data structure and also think better what to choose in design process. There are more than five solutions I like to share using C# data struture: List, Stack, Queue, Dictionary (HashMap), HashSet, Tuple. \\n\\nHere are my highlights:\\n1. First and most important, it is to learn and get familiar using List<TreeNode>, and understand tree traversal, use one path as List variable to solve backtracking issue; \\n2. Next it is important to learn how to solve the algorithm using recursive function without any data structure;\\n3. Advanced topic is to try ideas using Tuple<TreeNode, int> and experience how efficient it is to design and remove ambiguity in design, follow Single Responsiblity Principle SRP. \\n4. Try other options like Stack, HashSet if you have time to practice. \\n\\n**Data structure is the tool to get organized**\\n\\nLet us get started. First one is combination of Queue, Dictionary, HashSet\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is data structure C# List<TreeNode> \\n\\n\\nC# **List** is enough to solve the problem - topics: backtracking, space optimization\\n\\n**No 2 combinations: C# Data structure: List**\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# HashSet<TreeNode>\\n\\n\\n**No 3 combinations: C# Data structure: HashSet**\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\nJune 25, 2019\\n\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Stack<TreeNode>\\n\\n\\n**Stack** is perfect to maintain the order in last in first out order. \\n\\n**No 4 combinations: C# Data structure: Stack**\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Tuple<TreeNode, int><br>\\n\\n\\n**Tuple** is so powerful and time-efficient, good at strong type definition to avoid run time errors. Give it a try! \\n\\n**No 4 combinations:  C# Data structure: Tuple**\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\nIt is time for me to learn to review my own code. Track my progress and I was so surprised to learn that I need to practice backtracking in 2019, 53 year old. \\n\\n**Extra topic: backtracking, List<TreeNode>**\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sai_manoj_kumar",
                        "content": "Input for the testcase is not being parsed correctly. Where do I report this?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "From May to July 2019\\nIt is my practice for busy season from March to May for two online code assessments and one more phone screen. One of ideas is to finish another 100 algorithm on Leetcode, and pace myself sometimes to work on one algorithm with various approaches. It is for potential phone screen, I may get invited any time. So I like to learn how to prepare more carefully through practice.\\n\\nHere are various topic I cover in my practice, and I also like to share the discussion post for each idea. Some of ideas are just to study code on existing discussion post. \\n\\nI also use the algorithm to interview people on interviewing dot io. It is important for me to learn various solutions first in order to be a good interviewer, and also learn from interview experience through a lot of interviewees. \\n\\nIf you have advice for adding more topics on this algorithm as an interviewer, please leave in the comments. I will add them one by one. \\n\\n**Topics**\\n\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[Post order traversal (May 27, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\n**Recursive function design, why mix return will lead to lowest common ancestor?**\\n[recursive function - Confused and more work later (May 8, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288320/C-Work-on-the-algorithm-in-mock-interview)\\n[recursive function - mix returns, final one is lowest common ancestor (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302311/C-recursive-function-design-step-by-step-illustration)\\n[C# post order traversal and return p or q in recursive function](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/315272/C-post-order-traversal-and-return-p-or-q-in-recursive-function) case study mock interview on June 18, 2019\\n\\n**Return type**\\n**Return bool or TreeNode?**\\n[Recursive solution Easy to understand - return bool (May 15, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n[Recursive solution Easy to understand - return TreeNode (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302301/C-recursive-function-with-return-TreeNode-Easy-to-understand)\\n\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n\\n[C# recursive function to find lowest common ancestor given p and q are in the binary tree (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301664/C-recursive-function-to-find-lowest-common-ancestor-given-p-and-q-are-in-the-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301686/C-Find-lowest-common-ancestor-given-two-nodes-p-and-q-may-not-in-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (June 14, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311875/C-Lowest-common-ancestor-given-node-p-and-q-in-binary-tree)\\n\\n**Naive solution with Timeout and Complicated function**\\n[Timeout challenge (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288284/C-time-out-need-help-using-List-preorder-traversal)\\n[Timeout challenge - using a string to store path (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288289/C-time-out-need-help-using-string-preorder-traversal)\\n[Fix naive solution timeout with complicated function (May 13, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290656/C-Fix-timeout-bug-but-still-keep-the-code-on-purpose-complicated)\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nJune 25, 2019\\nThree practice for three ideas; I like to be a master of the lowest common ancestor! I started again from May 8, 2019, met a lot of talent in Sillicon Valley, Seattle, Toronto area on *** on this algorithm.\\n\\nDare to be a master! Self-claim first!\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\nJuly 4, 2019\\nTwo node\\'s distance in binary tree, the post is [here](https://leetcode.com/discuss/interview-question/125084/Amazon-Distance-between-2-nodes). \\nMy solution is written [here](https://leetcode.com/discuss/interview-question/125084/Amazon-or-Distance-between-2-nodes/300089). The idea is to find lowest common ancestor, and then calculate the distance between two nodes indirectly both to lowest common ancestor.\\n[C# Lowest common ancestor -> two node\\'s distance practice (upward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327282/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(uperward))\\n[C# Lowest common ancestor -> two node\\'s distance practice (downward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327278/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(downward))\\n\\n**Common mistakes in mock interview**\\n\\n1. Preorder traversal vs postorder traversal, early return when p or q is found, the rest of nodes in the tree is not traversed;\\n2. Redundant code in the recursive function;\\n"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "my code is pretty much the same as everyone else's, but I changed the comparison\\nfrom\\n\\n    if (root == p || root == q) then return root;\\n\\nto \\n\\n    if (root.val == p.val || root.val == q.val) then return root;\\n\\nthen I got errors, I'm really confused, if the former conditions are satisfied, the latter must be true too."
                    },
                    {
                        "username": "user3971c",
                        "content": "[@ayushanand18](/ayushanand18) I can\\'t speak for 2015, but as of now the constraints state that All Node.val are unique. "
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@ayushanand18](/ayushanand18) are you there suggesting him right after 8 years....wonder what he is doing now."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "there might also be some nodes which have the same values but not the one we are concerned about. i.e. duplicate value nodes."
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020\\n\\nI continue to ask the algorithm question in my interviewing dot io mock interviews as an interviewer in 2020, and then I was surprised to learn more about recursive function design, strong type, backtracking, and expedite the tree problem solving process. \\n\\nTo work on my C# crafting skills, I also practice the idea after each mock interview. \\n\\nApril 19, 2020\\n[C# backtracking practice after mock interview on April 19, 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655605/C-backtracking-practice-after-mock-interview-on-April-19-2020)\\n\\nMay 1, 2020\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nStatistics:\\n1. 40 mock interviews as an interviewer, ask lowest common ancestor in binary tree algorithm in 2019;\\n2. Work on recursive function design over 10 times;\\n3. Work on backtracking practice over 10 times;\\n4. All engineers over 40 engineers in two months I met in 2019 cannot beat performance I met in 2020, an ex-facebook engineer. \\n\\n"
                    }
                ]
            },
            {
                "id": 1951292,
                "content": [
                    {
                        "username": "jack76",
                        "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS(preOrder).. Easy solution\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three parameters: `root` (the current node), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n2. Check if the current node `root` is null or if it is either `p` or `q`. If any of these conditions is true, return the current node `root` as the lowest common ancestor.\\n\\n3. Recursively call the `rec` function for the left subtree of the current node and assign the result to a variable `l`.\\n\\n4. Recursively call the `rec` function for the right subtree of the current node and assign the result to a variable `r`.\\n\\n5. Check if both `l` and `r` are not null. If so, it means that `p` and `q` are found on different subtrees of the current node, and the current node `root` is their lowest common ancestor. Return the current node `root`.\\n\\n6. If `l` is null, it means that both `p` and `q` are on the right subtree (or not present in the tree). Return `r`.\\n\\n7. If none of the above conditions are met, it means that both `p` and `q` are on the left subtree (or not present in the tree). Return `l`.\\n\\n8. Define a function `lowestCommonAncestor` that takes three parameters: `root` (the root node of the tree), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n9. Return the result of calling the `rec` function with the parameters `root`, `p`, and `q`. This will find and return the lowest common ancestor of nodes `p` and `q` in the given binary tree.\\n\\n-------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n). All node have to visit in worst case.\\n\\n- Space complexity:\\nS.C=O(n) in worst case skewed tree. recursive stack take O(n).\\n--------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3702977/c-dfs-preorder-easy-solution/"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "Update: The bug is already fixed! Thanks LC\\n\\nIt may be due to how OJ parses the test case: every time I tried to run the testcase, it spat `5 is not a valid value of type TreeNode`. \\nI also tried to enclose 5 and 1 in `[]`but no lucky there.\\nCould someone fix this, or let me know if there is a temporary fix on my end, thanks!"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "When I checked some others solutions committed and passed, I found that, they all miss the checking step,which means we need to check if there are both p and q in this tree.\\n\\nfor example,there is a question name called Share C++/C# 24ms recursive solution , the solution it shows doesn't check wether TreeNode p and TreeNode q exist when it returns.\\n\\nSo what do you guys think??"
                    },
                    {
                        "username": "GUTTTS",
                        "content": "[@mochiball](/mochiball) bro he wrote that in 2015 maybe that time there wasnt anything mentioned in the constraints\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Please read the question constraints. It tells you that p and q are in the tree. No need to check if they exist "
                    },
                    {
                        "username": "harsha335",
                        "content": "in constraints they mentioned both p and q will be present in tree and they are unique and not equal."
                    },
                    {
                        "username": "gepo",
                        "content": "Something is going wrong.\\nLine 41: TypeError: object of type \\'int\\' has no len()"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020 \\n\\nIt is important for me to train myself to get familar with C# data structure and also think better what to choose in design process. There are more than five solutions I like to share using C# data struture: List, Stack, Queue, Dictionary (HashMap), HashSet, Tuple. \\n\\nHere are my highlights:\\n1. First and most important, it is to learn and get familiar using List<TreeNode>, and understand tree traversal, use one path as List variable to solve backtracking issue; \\n2. Next it is important to learn how to solve the algorithm using recursive function without any data structure;\\n3. Advanced topic is to try ideas using Tuple<TreeNode, int> and experience how efficient it is to design and remove ambiguity in design, follow Single Responsiblity Principle SRP. \\n4. Try other options like Stack, HashSet if you have time to practice. \\n\\n**Data structure is the tool to get organized**\\n\\nLet us get started. First one is combination of Queue, Dictionary, HashSet\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is data structure C# List<TreeNode> \\n\\n\\nC# **List** is enough to solve the problem - topics: backtracking, space optimization\\n\\n**No 2 combinations: C# Data structure: List**\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# HashSet<TreeNode>\\n\\n\\n**No 3 combinations: C# Data structure: HashSet**\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\nJune 25, 2019\\n\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Stack<TreeNode>\\n\\n\\n**Stack** is perfect to maintain the order in last in first out order. \\n\\n**No 4 combinations: C# Data structure: Stack**\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Tuple<TreeNode, int><br>\\n\\n\\n**Tuple** is so powerful and time-efficient, good at strong type definition to avoid run time errors. Give it a try! \\n\\n**No 4 combinations:  C# Data structure: Tuple**\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\nIt is time for me to learn to review my own code. Track my progress and I was so surprised to learn that I need to practice backtracking in 2019, 53 year old. \\n\\n**Extra topic: backtracking, List<TreeNode>**\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sai_manoj_kumar",
                        "content": "Input for the testcase is not being parsed correctly. Where do I report this?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "From May to July 2019\\nIt is my practice for busy season from March to May for two online code assessments and one more phone screen. One of ideas is to finish another 100 algorithm on Leetcode, and pace myself sometimes to work on one algorithm with various approaches. It is for potential phone screen, I may get invited any time. So I like to learn how to prepare more carefully through practice.\\n\\nHere are various topic I cover in my practice, and I also like to share the discussion post for each idea. Some of ideas are just to study code on existing discussion post. \\n\\nI also use the algorithm to interview people on interviewing dot io. It is important for me to learn various solutions first in order to be a good interviewer, and also learn from interview experience through a lot of interviewees. \\n\\nIf you have advice for adding more topics on this algorithm as an interviewer, please leave in the comments. I will add them one by one. \\n\\n**Topics**\\n\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[Post order traversal (May 27, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\n**Recursive function design, why mix return will lead to lowest common ancestor?**\\n[recursive function - Confused and more work later (May 8, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288320/C-Work-on-the-algorithm-in-mock-interview)\\n[recursive function - mix returns, final one is lowest common ancestor (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302311/C-recursive-function-design-step-by-step-illustration)\\n[C# post order traversal and return p or q in recursive function](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/315272/C-post-order-traversal-and-return-p-or-q-in-recursive-function) case study mock interview on June 18, 2019\\n\\n**Return type**\\n**Return bool or TreeNode?**\\n[Recursive solution Easy to understand - return bool (May 15, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n[Recursive solution Easy to understand - return TreeNode (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302301/C-recursive-function-with-return-TreeNode-Easy-to-understand)\\n\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n\\n[C# recursive function to find lowest common ancestor given p and q are in the binary tree (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301664/C-recursive-function-to-find-lowest-common-ancestor-given-p-and-q-are-in-the-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301686/C-Find-lowest-common-ancestor-given-two-nodes-p-and-q-may-not-in-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (June 14, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311875/C-Lowest-common-ancestor-given-node-p-and-q-in-binary-tree)\\n\\n**Naive solution with Timeout and Complicated function**\\n[Timeout challenge (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288284/C-time-out-need-help-using-List-preorder-traversal)\\n[Timeout challenge - using a string to store path (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288289/C-time-out-need-help-using-string-preorder-traversal)\\n[Fix naive solution timeout with complicated function (May 13, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290656/C-Fix-timeout-bug-but-still-keep-the-code-on-purpose-complicated)\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nJune 25, 2019\\nThree practice for three ideas; I like to be a master of the lowest common ancestor! I started again from May 8, 2019, met a lot of talent in Sillicon Valley, Seattle, Toronto area on *** on this algorithm.\\n\\nDare to be a master! Self-claim first!\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\nJuly 4, 2019\\nTwo node\\'s distance in binary tree, the post is [here](https://leetcode.com/discuss/interview-question/125084/Amazon-Distance-between-2-nodes). \\nMy solution is written [here](https://leetcode.com/discuss/interview-question/125084/Amazon-or-Distance-between-2-nodes/300089). The idea is to find lowest common ancestor, and then calculate the distance between two nodes indirectly both to lowest common ancestor.\\n[C# Lowest common ancestor -> two node\\'s distance practice (upward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327282/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(uperward))\\n[C# Lowest common ancestor -> two node\\'s distance practice (downward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327278/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(downward))\\n\\n**Common mistakes in mock interview**\\n\\n1. Preorder traversal vs postorder traversal, early return when p or q is found, the rest of nodes in the tree is not traversed;\\n2. Redundant code in the recursive function;\\n"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "my code is pretty much the same as everyone else's, but I changed the comparison\\nfrom\\n\\n    if (root == p || root == q) then return root;\\n\\nto \\n\\n    if (root.val == p.val || root.val == q.val) then return root;\\n\\nthen I got errors, I'm really confused, if the former conditions are satisfied, the latter must be true too."
                    },
                    {
                        "username": "user3971c",
                        "content": "[@ayushanand18](/ayushanand18) I can\\'t speak for 2015, but as of now the constraints state that All Node.val are unique. "
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@ayushanand18](/ayushanand18) are you there suggesting him right after 8 years....wonder what he is doing now."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "there might also be some nodes which have the same values but not the one we are concerned about. i.e. duplicate value nodes."
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020\\n\\nI continue to ask the algorithm question in my interviewing dot io mock interviews as an interviewer in 2020, and then I was surprised to learn more about recursive function design, strong type, backtracking, and expedite the tree problem solving process. \\n\\nTo work on my C# crafting skills, I also practice the idea after each mock interview. \\n\\nApril 19, 2020\\n[C# backtracking practice after mock interview on April 19, 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655605/C-backtracking-practice-after-mock-interview-on-April-19-2020)\\n\\nMay 1, 2020\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nStatistics:\\n1. 40 mock interviews as an interviewer, ask lowest common ancestor in binary tree algorithm in 2019;\\n2. Work on recursive function design over 10 times;\\n3. Work on backtracking practice over 10 times;\\n4. All engineers over 40 engineers in two months I met in 2019 cannot beat performance I met in 2020, an ex-facebook engineer. \\n\\n"
                    }
                ]
            },
            {
                "id": 1566904,
                "content": [
                    {
                        "username": "jack76",
                        "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS(preOrder).. Easy solution\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three parameters: `root` (the current node), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n2. Check if the current node `root` is null or if it is either `p` or `q`. If any of these conditions is true, return the current node `root` as the lowest common ancestor.\\n\\n3. Recursively call the `rec` function for the left subtree of the current node and assign the result to a variable `l`.\\n\\n4. Recursively call the `rec` function for the right subtree of the current node and assign the result to a variable `r`.\\n\\n5. Check if both `l` and `r` are not null. If so, it means that `p` and `q` are found on different subtrees of the current node, and the current node `root` is their lowest common ancestor. Return the current node `root`.\\n\\n6. If `l` is null, it means that both `p` and `q` are on the right subtree (or not present in the tree). Return `r`.\\n\\n7. If none of the above conditions are met, it means that both `p` and `q` are on the left subtree (or not present in the tree). Return `l`.\\n\\n8. Define a function `lowestCommonAncestor` that takes three parameters: `root` (the root node of the tree), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n9. Return the result of calling the `rec` function with the parameters `root`, `p`, and `q`. This will find and return the lowest common ancestor of nodes `p` and `q` in the given binary tree.\\n\\n-------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n). All node have to visit in worst case.\\n\\n- Space complexity:\\nS.C=O(n) in worst case skewed tree. recursive stack take O(n).\\n--------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3702977/c-dfs-preorder-easy-solution/"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "Update: The bug is already fixed! Thanks LC\\n\\nIt may be due to how OJ parses the test case: every time I tried to run the testcase, it spat `5 is not a valid value of type TreeNode`. \\nI also tried to enclose 5 and 1 in `[]`but no lucky there.\\nCould someone fix this, or let me know if there is a temporary fix on my end, thanks!"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "When I checked some others solutions committed and passed, I found that, they all miss the checking step,which means we need to check if there are both p and q in this tree.\\n\\nfor example,there is a question name called Share C++/C# 24ms recursive solution , the solution it shows doesn't check wether TreeNode p and TreeNode q exist when it returns.\\n\\nSo what do you guys think??"
                    },
                    {
                        "username": "GUTTTS",
                        "content": "[@mochiball](/mochiball) bro he wrote that in 2015 maybe that time there wasnt anything mentioned in the constraints\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Please read the question constraints. It tells you that p and q are in the tree. No need to check if they exist "
                    },
                    {
                        "username": "harsha335",
                        "content": "in constraints they mentioned both p and q will be present in tree and they are unique and not equal."
                    },
                    {
                        "username": "gepo",
                        "content": "Something is going wrong.\\nLine 41: TypeError: object of type \\'int\\' has no len()"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020 \\n\\nIt is important for me to train myself to get familar with C# data structure and also think better what to choose in design process. There are more than five solutions I like to share using C# data struture: List, Stack, Queue, Dictionary (HashMap), HashSet, Tuple. \\n\\nHere are my highlights:\\n1. First and most important, it is to learn and get familiar using List<TreeNode>, and understand tree traversal, use one path as List variable to solve backtracking issue; \\n2. Next it is important to learn how to solve the algorithm using recursive function without any data structure;\\n3. Advanced topic is to try ideas using Tuple<TreeNode, int> and experience how efficient it is to design and remove ambiguity in design, follow Single Responsiblity Principle SRP. \\n4. Try other options like Stack, HashSet if you have time to practice. \\n\\n**Data structure is the tool to get organized**\\n\\nLet us get started. First one is combination of Queue, Dictionary, HashSet\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is data structure C# List<TreeNode> \\n\\n\\nC# **List** is enough to solve the problem - topics: backtracking, space optimization\\n\\n**No 2 combinations: C# Data structure: List**\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# HashSet<TreeNode>\\n\\n\\n**No 3 combinations: C# Data structure: HashSet**\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\nJune 25, 2019\\n\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Stack<TreeNode>\\n\\n\\n**Stack** is perfect to maintain the order in last in first out order. \\n\\n**No 4 combinations: C# Data structure: Stack**\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Tuple<TreeNode, int><br>\\n\\n\\n**Tuple** is so powerful and time-efficient, good at strong type definition to avoid run time errors. Give it a try! \\n\\n**No 4 combinations:  C# Data structure: Tuple**\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\nIt is time for me to learn to review my own code. Track my progress and I was so surprised to learn that I need to practice backtracking in 2019, 53 year old. \\n\\n**Extra topic: backtracking, List<TreeNode>**\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sai_manoj_kumar",
                        "content": "Input for the testcase is not being parsed correctly. Where do I report this?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "From May to July 2019\\nIt is my practice for busy season from March to May for two online code assessments and one more phone screen. One of ideas is to finish another 100 algorithm on Leetcode, and pace myself sometimes to work on one algorithm with various approaches. It is for potential phone screen, I may get invited any time. So I like to learn how to prepare more carefully through practice.\\n\\nHere are various topic I cover in my practice, and I also like to share the discussion post for each idea. Some of ideas are just to study code on existing discussion post. \\n\\nI also use the algorithm to interview people on interviewing dot io. It is important for me to learn various solutions first in order to be a good interviewer, and also learn from interview experience through a lot of interviewees. \\n\\nIf you have advice for adding more topics on this algorithm as an interviewer, please leave in the comments. I will add them one by one. \\n\\n**Topics**\\n\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[Post order traversal (May 27, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\n**Recursive function design, why mix return will lead to lowest common ancestor?**\\n[recursive function - Confused and more work later (May 8, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288320/C-Work-on-the-algorithm-in-mock-interview)\\n[recursive function - mix returns, final one is lowest common ancestor (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302311/C-recursive-function-design-step-by-step-illustration)\\n[C# post order traversal and return p or q in recursive function](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/315272/C-post-order-traversal-and-return-p-or-q-in-recursive-function) case study mock interview on June 18, 2019\\n\\n**Return type**\\n**Return bool or TreeNode?**\\n[Recursive solution Easy to understand - return bool (May 15, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n[Recursive solution Easy to understand - return TreeNode (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302301/C-recursive-function-with-return-TreeNode-Easy-to-understand)\\n\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n\\n[C# recursive function to find lowest common ancestor given p and q are in the binary tree (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301664/C-recursive-function-to-find-lowest-common-ancestor-given-p-and-q-are-in-the-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301686/C-Find-lowest-common-ancestor-given-two-nodes-p-and-q-may-not-in-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (June 14, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311875/C-Lowest-common-ancestor-given-node-p-and-q-in-binary-tree)\\n\\n**Naive solution with Timeout and Complicated function**\\n[Timeout challenge (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288284/C-time-out-need-help-using-List-preorder-traversal)\\n[Timeout challenge - using a string to store path (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288289/C-time-out-need-help-using-string-preorder-traversal)\\n[Fix naive solution timeout with complicated function (May 13, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290656/C-Fix-timeout-bug-but-still-keep-the-code-on-purpose-complicated)\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nJune 25, 2019\\nThree practice for three ideas; I like to be a master of the lowest common ancestor! I started again from May 8, 2019, met a lot of talent in Sillicon Valley, Seattle, Toronto area on *** on this algorithm.\\n\\nDare to be a master! Self-claim first!\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\nJuly 4, 2019\\nTwo node\\'s distance in binary tree, the post is [here](https://leetcode.com/discuss/interview-question/125084/Amazon-Distance-between-2-nodes). \\nMy solution is written [here](https://leetcode.com/discuss/interview-question/125084/Amazon-or-Distance-between-2-nodes/300089). The idea is to find lowest common ancestor, and then calculate the distance between two nodes indirectly both to lowest common ancestor.\\n[C# Lowest common ancestor -> two node\\'s distance practice (upward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327282/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(uperward))\\n[C# Lowest common ancestor -> two node\\'s distance practice (downward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327278/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(downward))\\n\\n**Common mistakes in mock interview**\\n\\n1. Preorder traversal vs postorder traversal, early return when p or q is found, the rest of nodes in the tree is not traversed;\\n2. Redundant code in the recursive function;\\n"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "my code is pretty much the same as everyone else's, but I changed the comparison\\nfrom\\n\\n    if (root == p || root == q) then return root;\\n\\nto \\n\\n    if (root.val == p.val || root.val == q.val) then return root;\\n\\nthen I got errors, I'm really confused, if the former conditions are satisfied, the latter must be true too."
                    },
                    {
                        "username": "user3971c",
                        "content": "[@ayushanand18](/ayushanand18) I can\\'t speak for 2015, but as of now the constraints state that All Node.val are unique. "
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@ayushanand18](/ayushanand18) are you there suggesting him right after 8 years....wonder what he is doing now."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "there might also be some nodes which have the same values but not the one we are concerned about. i.e. duplicate value nodes."
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020\\n\\nI continue to ask the algorithm question in my interviewing dot io mock interviews as an interviewer in 2020, and then I was surprised to learn more about recursive function design, strong type, backtracking, and expedite the tree problem solving process. \\n\\nTo work on my C# crafting skills, I also practice the idea after each mock interview. \\n\\nApril 19, 2020\\n[C# backtracking practice after mock interview on April 19, 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655605/C-backtracking-practice-after-mock-interview-on-April-19-2020)\\n\\nMay 1, 2020\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nStatistics:\\n1. 40 mock interviews as an interviewer, ask lowest common ancestor in binary tree algorithm in 2019;\\n2. Work on recursive function design over 10 times;\\n3. Work on backtracking practice over 10 times;\\n4. All engineers over 40 engineers in two months I met in 2019 cannot beat performance I met in 2020, an ex-facebook engineer. \\n\\n"
                    }
                ]
            },
            {
                "id": 1567232,
                "content": [
                    {
                        "username": "jack76",
                        "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS(preOrder).. Easy solution\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three parameters: `root` (the current node), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n2. Check if the current node `root` is null or if it is either `p` or `q`. If any of these conditions is true, return the current node `root` as the lowest common ancestor.\\n\\n3. Recursively call the `rec` function for the left subtree of the current node and assign the result to a variable `l`.\\n\\n4. Recursively call the `rec` function for the right subtree of the current node and assign the result to a variable `r`.\\n\\n5. Check if both `l` and `r` are not null. If so, it means that `p` and `q` are found on different subtrees of the current node, and the current node `root` is their lowest common ancestor. Return the current node `root`.\\n\\n6. If `l` is null, it means that both `p` and `q` are on the right subtree (or not present in the tree). Return `r`.\\n\\n7. If none of the above conditions are met, it means that both `p` and `q` are on the left subtree (or not present in the tree). Return `l`.\\n\\n8. Define a function `lowestCommonAncestor` that takes three parameters: `root` (the root node of the tree), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n9. Return the result of calling the `rec` function with the parameters `root`, `p`, and `q`. This will find and return the lowest common ancestor of nodes `p` and `q` in the given binary tree.\\n\\n-------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n). All node have to visit in worst case.\\n\\n- Space complexity:\\nS.C=O(n) in worst case skewed tree. recursive stack take O(n).\\n--------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3702977/c-dfs-preorder-easy-solution/"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "Update: The bug is already fixed! Thanks LC\\n\\nIt may be due to how OJ parses the test case: every time I tried to run the testcase, it spat `5 is not a valid value of type TreeNode`. \\nI also tried to enclose 5 and 1 in `[]`but no lucky there.\\nCould someone fix this, or let me know if there is a temporary fix on my end, thanks!"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "When I checked some others solutions committed and passed, I found that, they all miss the checking step,which means we need to check if there are both p and q in this tree.\\n\\nfor example,there is a question name called Share C++/C# 24ms recursive solution , the solution it shows doesn't check wether TreeNode p and TreeNode q exist when it returns.\\n\\nSo what do you guys think??"
                    },
                    {
                        "username": "GUTTTS",
                        "content": "[@mochiball](/mochiball) bro he wrote that in 2015 maybe that time there wasnt anything mentioned in the constraints\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Please read the question constraints. It tells you that p and q are in the tree. No need to check if they exist "
                    },
                    {
                        "username": "harsha335",
                        "content": "in constraints they mentioned both p and q will be present in tree and they are unique and not equal."
                    },
                    {
                        "username": "gepo",
                        "content": "Something is going wrong.\\nLine 41: TypeError: object of type \\'int\\' has no len()"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020 \\n\\nIt is important for me to train myself to get familar with C# data structure and also think better what to choose in design process. There are more than five solutions I like to share using C# data struture: List, Stack, Queue, Dictionary (HashMap), HashSet, Tuple. \\n\\nHere are my highlights:\\n1. First and most important, it is to learn and get familiar using List<TreeNode>, and understand tree traversal, use one path as List variable to solve backtracking issue; \\n2. Next it is important to learn how to solve the algorithm using recursive function without any data structure;\\n3. Advanced topic is to try ideas using Tuple<TreeNode, int> and experience how efficient it is to design and remove ambiguity in design, follow Single Responsiblity Principle SRP. \\n4. Try other options like Stack, HashSet if you have time to practice. \\n\\n**Data structure is the tool to get organized**\\n\\nLet us get started. First one is combination of Queue, Dictionary, HashSet\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is data structure C# List<TreeNode> \\n\\n\\nC# **List** is enough to solve the problem - topics: backtracking, space optimization\\n\\n**No 2 combinations: C# Data structure: List**\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# HashSet<TreeNode>\\n\\n\\n**No 3 combinations: C# Data structure: HashSet**\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\nJune 25, 2019\\n\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Stack<TreeNode>\\n\\n\\n**Stack** is perfect to maintain the order in last in first out order. \\n\\n**No 4 combinations: C# Data structure: Stack**\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Tuple<TreeNode, int><br>\\n\\n\\n**Tuple** is so powerful and time-efficient, good at strong type definition to avoid run time errors. Give it a try! \\n\\n**No 4 combinations:  C# Data structure: Tuple**\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\nIt is time for me to learn to review my own code. Track my progress and I was so surprised to learn that I need to practice backtracking in 2019, 53 year old. \\n\\n**Extra topic: backtracking, List<TreeNode>**\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sai_manoj_kumar",
                        "content": "Input for the testcase is not being parsed correctly. Where do I report this?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "From May to July 2019\\nIt is my practice for busy season from March to May for two online code assessments and one more phone screen. One of ideas is to finish another 100 algorithm on Leetcode, and pace myself sometimes to work on one algorithm with various approaches. It is for potential phone screen, I may get invited any time. So I like to learn how to prepare more carefully through practice.\\n\\nHere are various topic I cover in my practice, and I also like to share the discussion post for each idea. Some of ideas are just to study code on existing discussion post. \\n\\nI also use the algorithm to interview people on interviewing dot io. It is important for me to learn various solutions first in order to be a good interviewer, and also learn from interview experience through a lot of interviewees. \\n\\nIf you have advice for adding more topics on this algorithm as an interviewer, please leave in the comments. I will add them one by one. \\n\\n**Topics**\\n\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[Post order traversal (May 27, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\n**Recursive function design, why mix return will lead to lowest common ancestor?**\\n[recursive function - Confused and more work later (May 8, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288320/C-Work-on-the-algorithm-in-mock-interview)\\n[recursive function - mix returns, final one is lowest common ancestor (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302311/C-recursive-function-design-step-by-step-illustration)\\n[C# post order traversal and return p or q in recursive function](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/315272/C-post-order-traversal-and-return-p-or-q-in-recursive-function) case study mock interview on June 18, 2019\\n\\n**Return type**\\n**Return bool or TreeNode?**\\n[Recursive solution Easy to understand - return bool (May 15, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n[Recursive solution Easy to understand - return TreeNode (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302301/C-recursive-function-with-return-TreeNode-Easy-to-understand)\\n\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n\\n[C# recursive function to find lowest common ancestor given p and q are in the binary tree (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301664/C-recursive-function-to-find-lowest-common-ancestor-given-p-and-q-are-in-the-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301686/C-Find-lowest-common-ancestor-given-two-nodes-p-and-q-may-not-in-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (June 14, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311875/C-Lowest-common-ancestor-given-node-p-and-q-in-binary-tree)\\n\\n**Naive solution with Timeout and Complicated function**\\n[Timeout challenge (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288284/C-time-out-need-help-using-List-preorder-traversal)\\n[Timeout challenge - using a string to store path (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288289/C-time-out-need-help-using-string-preorder-traversal)\\n[Fix naive solution timeout with complicated function (May 13, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290656/C-Fix-timeout-bug-but-still-keep-the-code-on-purpose-complicated)\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nJune 25, 2019\\nThree practice for three ideas; I like to be a master of the lowest common ancestor! I started again from May 8, 2019, met a lot of talent in Sillicon Valley, Seattle, Toronto area on *** on this algorithm.\\n\\nDare to be a master! Self-claim first!\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\nJuly 4, 2019\\nTwo node\\'s distance in binary tree, the post is [here](https://leetcode.com/discuss/interview-question/125084/Amazon-Distance-between-2-nodes). \\nMy solution is written [here](https://leetcode.com/discuss/interview-question/125084/Amazon-or-Distance-between-2-nodes/300089). The idea is to find lowest common ancestor, and then calculate the distance between two nodes indirectly both to lowest common ancestor.\\n[C# Lowest common ancestor -> two node\\'s distance practice (upward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327282/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(uperward))\\n[C# Lowest common ancestor -> two node\\'s distance practice (downward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327278/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(downward))\\n\\n**Common mistakes in mock interview**\\n\\n1. Preorder traversal vs postorder traversal, early return when p or q is found, the rest of nodes in the tree is not traversed;\\n2. Redundant code in the recursive function;\\n"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "my code is pretty much the same as everyone else's, but I changed the comparison\\nfrom\\n\\n    if (root == p || root == q) then return root;\\n\\nto \\n\\n    if (root.val == p.val || root.val == q.val) then return root;\\n\\nthen I got errors, I'm really confused, if the former conditions are satisfied, the latter must be true too."
                    },
                    {
                        "username": "user3971c",
                        "content": "[@ayushanand18](/ayushanand18) I can\\'t speak for 2015, but as of now the constraints state that All Node.val are unique. "
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@ayushanand18](/ayushanand18) are you there suggesting him right after 8 years....wonder what he is doing now."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "there might also be some nodes which have the same values but not the one we are concerned about. i.e. duplicate value nodes."
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020\\n\\nI continue to ask the algorithm question in my interviewing dot io mock interviews as an interviewer in 2020, and then I was surprised to learn more about recursive function design, strong type, backtracking, and expedite the tree problem solving process. \\n\\nTo work on my C# crafting skills, I also practice the idea after each mock interview. \\n\\nApril 19, 2020\\n[C# backtracking practice after mock interview on April 19, 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655605/C-backtracking-practice-after-mock-interview-on-April-19-2020)\\n\\nMay 1, 2020\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nStatistics:\\n1. 40 mock interviews as an interviewer, ask lowest common ancestor in binary tree algorithm in 2019;\\n2. Work on recursive function design over 10 times;\\n3. Work on backtracking practice over 10 times;\\n4. All engineers over 40 engineers in two months I met in 2019 cannot beat performance I met in 2020, an ex-facebook engineer. \\n\\n"
                    }
                ]
            },
            {
                "id": 1566119,
                "content": [
                    {
                        "username": "jack76",
                        "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS(preOrder).. Easy solution\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three parameters: `root` (the current node), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n2. Check if the current node `root` is null or if it is either `p` or `q`. If any of these conditions is true, return the current node `root` as the lowest common ancestor.\\n\\n3. Recursively call the `rec` function for the left subtree of the current node and assign the result to a variable `l`.\\n\\n4. Recursively call the `rec` function for the right subtree of the current node and assign the result to a variable `r`.\\n\\n5. Check if both `l` and `r` are not null. If so, it means that `p` and `q` are found on different subtrees of the current node, and the current node `root` is their lowest common ancestor. Return the current node `root`.\\n\\n6. If `l` is null, it means that both `p` and `q` are on the right subtree (or not present in the tree). Return `r`.\\n\\n7. If none of the above conditions are met, it means that both `p` and `q` are on the left subtree (or not present in the tree). Return `l`.\\n\\n8. Define a function `lowestCommonAncestor` that takes three parameters: `root` (the root node of the tree), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n9. Return the result of calling the `rec` function with the parameters `root`, `p`, and `q`. This will find and return the lowest common ancestor of nodes `p` and `q` in the given binary tree.\\n\\n-------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n). All node have to visit in worst case.\\n\\n- Space complexity:\\nS.C=O(n) in worst case skewed tree. recursive stack take O(n).\\n--------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3702977/c-dfs-preorder-easy-solution/"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "Update: The bug is already fixed! Thanks LC\\n\\nIt may be due to how OJ parses the test case: every time I tried to run the testcase, it spat `5 is not a valid value of type TreeNode`. \\nI also tried to enclose 5 and 1 in `[]`but no lucky there.\\nCould someone fix this, or let me know if there is a temporary fix on my end, thanks!"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "When I checked some others solutions committed and passed, I found that, they all miss the checking step,which means we need to check if there are both p and q in this tree.\\n\\nfor example,there is a question name called Share C++/C# 24ms recursive solution , the solution it shows doesn't check wether TreeNode p and TreeNode q exist when it returns.\\n\\nSo what do you guys think??"
                    },
                    {
                        "username": "GUTTTS",
                        "content": "[@mochiball](/mochiball) bro he wrote that in 2015 maybe that time there wasnt anything mentioned in the constraints\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Please read the question constraints. It tells you that p and q are in the tree. No need to check if they exist "
                    },
                    {
                        "username": "harsha335",
                        "content": "in constraints they mentioned both p and q will be present in tree and they are unique and not equal."
                    },
                    {
                        "username": "gepo",
                        "content": "Something is going wrong.\\nLine 41: TypeError: object of type \\'int\\' has no len()"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020 \\n\\nIt is important for me to train myself to get familar with C# data structure and also think better what to choose in design process. There are more than five solutions I like to share using C# data struture: List, Stack, Queue, Dictionary (HashMap), HashSet, Tuple. \\n\\nHere are my highlights:\\n1. First and most important, it is to learn and get familiar using List<TreeNode>, and understand tree traversal, use one path as List variable to solve backtracking issue; \\n2. Next it is important to learn how to solve the algorithm using recursive function without any data structure;\\n3. Advanced topic is to try ideas using Tuple<TreeNode, int> and experience how efficient it is to design and remove ambiguity in design, follow Single Responsiblity Principle SRP. \\n4. Try other options like Stack, HashSet if you have time to practice. \\n\\n**Data structure is the tool to get organized**\\n\\nLet us get started. First one is combination of Queue, Dictionary, HashSet\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is data structure C# List<TreeNode> \\n\\n\\nC# **List** is enough to solve the problem - topics: backtracking, space optimization\\n\\n**No 2 combinations: C# Data structure: List**\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# HashSet<TreeNode>\\n\\n\\n**No 3 combinations: C# Data structure: HashSet**\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\nJune 25, 2019\\n\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Stack<TreeNode>\\n\\n\\n**Stack** is perfect to maintain the order in last in first out order. \\n\\n**No 4 combinations: C# Data structure: Stack**\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Tuple<TreeNode, int><br>\\n\\n\\n**Tuple** is so powerful and time-efficient, good at strong type definition to avoid run time errors. Give it a try! \\n\\n**No 4 combinations:  C# Data structure: Tuple**\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\nIt is time for me to learn to review my own code. Track my progress and I was so surprised to learn that I need to practice backtracking in 2019, 53 year old. \\n\\n**Extra topic: backtracking, List<TreeNode>**\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sai_manoj_kumar",
                        "content": "Input for the testcase is not being parsed correctly. Where do I report this?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "From May to July 2019\\nIt is my practice for busy season from March to May for two online code assessments and one more phone screen. One of ideas is to finish another 100 algorithm on Leetcode, and pace myself sometimes to work on one algorithm with various approaches. It is for potential phone screen, I may get invited any time. So I like to learn how to prepare more carefully through practice.\\n\\nHere are various topic I cover in my practice, and I also like to share the discussion post for each idea. Some of ideas are just to study code on existing discussion post. \\n\\nI also use the algorithm to interview people on interviewing dot io. It is important for me to learn various solutions first in order to be a good interviewer, and also learn from interview experience through a lot of interviewees. \\n\\nIf you have advice for adding more topics on this algorithm as an interviewer, please leave in the comments. I will add them one by one. \\n\\n**Topics**\\n\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[Post order traversal (May 27, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\n**Recursive function design, why mix return will lead to lowest common ancestor?**\\n[recursive function - Confused and more work later (May 8, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288320/C-Work-on-the-algorithm-in-mock-interview)\\n[recursive function - mix returns, final one is lowest common ancestor (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302311/C-recursive-function-design-step-by-step-illustration)\\n[C# post order traversal and return p or q in recursive function](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/315272/C-post-order-traversal-and-return-p-or-q-in-recursive-function) case study mock interview on June 18, 2019\\n\\n**Return type**\\n**Return bool or TreeNode?**\\n[Recursive solution Easy to understand - return bool (May 15, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n[Recursive solution Easy to understand - return TreeNode (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302301/C-recursive-function-with-return-TreeNode-Easy-to-understand)\\n\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n\\n[C# recursive function to find lowest common ancestor given p and q are in the binary tree (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301664/C-recursive-function-to-find-lowest-common-ancestor-given-p-and-q-are-in-the-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301686/C-Find-lowest-common-ancestor-given-two-nodes-p-and-q-may-not-in-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (June 14, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311875/C-Lowest-common-ancestor-given-node-p-and-q-in-binary-tree)\\n\\n**Naive solution with Timeout and Complicated function**\\n[Timeout challenge (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288284/C-time-out-need-help-using-List-preorder-traversal)\\n[Timeout challenge - using a string to store path (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288289/C-time-out-need-help-using-string-preorder-traversal)\\n[Fix naive solution timeout with complicated function (May 13, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290656/C-Fix-timeout-bug-but-still-keep-the-code-on-purpose-complicated)\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nJune 25, 2019\\nThree practice for three ideas; I like to be a master of the lowest common ancestor! I started again from May 8, 2019, met a lot of talent in Sillicon Valley, Seattle, Toronto area on *** on this algorithm.\\n\\nDare to be a master! Self-claim first!\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\nJuly 4, 2019\\nTwo node\\'s distance in binary tree, the post is [here](https://leetcode.com/discuss/interview-question/125084/Amazon-Distance-between-2-nodes). \\nMy solution is written [here](https://leetcode.com/discuss/interview-question/125084/Amazon-or-Distance-between-2-nodes/300089). The idea is to find lowest common ancestor, and then calculate the distance between two nodes indirectly both to lowest common ancestor.\\n[C# Lowest common ancestor -> two node\\'s distance practice (upward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327282/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(uperward))\\n[C# Lowest common ancestor -> two node\\'s distance practice (downward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327278/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(downward))\\n\\n**Common mistakes in mock interview**\\n\\n1. Preorder traversal vs postorder traversal, early return when p or q is found, the rest of nodes in the tree is not traversed;\\n2. Redundant code in the recursive function;\\n"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "my code is pretty much the same as everyone else's, but I changed the comparison\\nfrom\\n\\n    if (root == p || root == q) then return root;\\n\\nto \\n\\n    if (root.val == p.val || root.val == q.val) then return root;\\n\\nthen I got errors, I'm really confused, if the former conditions are satisfied, the latter must be true too."
                    },
                    {
                        "username": "user3971c",
                        "content": "[@ayushanand18](/ayushanand18) I can\\'t speak for 2015, but as of now the constraints state that All Node.val are unique. "
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@ayushanand18](/ayushanand18) are you there suggesting him right after 8 years....wonder what he is doing now."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "there might also be some nodes which have the same values but not the one we are concerned about. i.e. duplicate value nodes."
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020\\n\\nI continue to ask the algorithm question in my interviewing dot io mock interviews as an interviewer in 2020, and then I was surprised to learn more about recursive function design, strong type, backtracking, and expedite the tree problem solving process. \\n\\nTo work on my C# crafting skills, I also practice the idea after each mock interview. \\n\\nApril 19, 2020\\n[C# backtracking practice after mock interview on April 19, 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655605/C-backtracking-practice-after-mock-interview-on-April-19-2020)\\n\\nMay 1, 2020\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nStatistics:\\n1. 40 mock interviews as an interviewer, ask lowest common ancestor in binary tree algorithm in 2019;\\n2. Work on recursive function design over 10 times;\\n3. Work on backtracking practice over 10 times;\\n4. All engineers over 40 engineers in two months I met in 2019 cannot beat performance I met in 2020, an ex-facebook engineer. \\n\\n"
                    }
                ]
            },
            {
                "id": 1568338,
                "content": [
                    {
                        "username": "jack76",
                        "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS(preOrder).. Easy solution\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three parameters: `root` (the current node), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n2. Check if the current node `root` is null or if it is either `p` or `q`. If any of these conditions is true, return the current node `root` as the lowest common ancestor.\\n\\n3. Recursively call the `rec` function for the left subtree of the current node and assign the result to a variable `l`.\\n\\n4. Recursively call the `rec` function for the right subtree of the current node and assign the result to a variable `r`.\\n\\n5. Check if both `l` and `r` are not null. If so, it means that `p` and `q` are found on different subtrees of the current node, and the current node `root` is their lowest common ancestor. Return the current node `root`.\\n\\n6. If `l` is null, it means that both `p` and `q` are on the right subtree (or not present in the tree). Return `r`.\\n\\n7. If none of the above conditions are met, it means that both `p` and `q` are on the left subtree (or not present in the tree). Return `l`.\\n\\n8. Define a function `lowestCommonAncestor` that takes three parameters: `root` (the root node of the tree), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n9. Return the result of calling the `rec` function with the parameters `root`, `p`, and `q`. This will find and return the lowest common ancestor of nodes `p` and `q` in the given binary tree.\\n\\n-------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n). All node have to visit in worst case.\\n\\n- Space complexity:\\nS.C=O(n) in worst case skewed tree. recursive stack take O(n).\\n--------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3702977/c-dfs-preorder-easy-solution/"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "Update: The bug is already fixed! Thanks LC\\n\\nIt may be due to how OJ parses the test case: every time I tried to run the testcase, it spat `5 is not a valid value of type TreeNode`. \\nI also tried to enclose 5 and 1 in `[]`but no lucky there.\\nCould someone fix this, or let me know if there is a temporary fix on my end, thanks!"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "When I checked some others solutions committed and passed, I found that, they all miss the checking step,which means we need to check if there are both p and q in this tree.\\n\\nfor example,there is a question name called Share C++/C# 24ms recursive solution , the solution it shows doesn't check wether TreeNode p and TreeNode q exist when it returns.\\n\\nSo what do you guys think??"
                    },
                    {
                        "username": "GUTTTS",
                        "content": "[@mochiball](/mochiball) bro he wrote that in 2015 maybe that time there wasnt anything mentioned in the constraints\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Please read the question constraints. It tells you that p and q are in the tree. No need to check if they exist "
                    },
                    {
                        "username": "harsha335",
                        "content": "in constraints they mentioned both p and q will be present in tree and they are unique and not equal."
                    },
                    {
                        "username": "gepo",
                        "content": "Something is going wrong.\\nLine 41: TypeError: object of type \\'int\\' has no len()"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020 \\n\\nIt is important for me to train myself to get familar with C# data structure and also think better what to choose in design process. There are more than five solutions I like to share using C# data struture: List, Stack, Queue, Dictionary (HashMap), HashSet, Tuple. \\n\\nHere are my highlights:\\n1. First and most important, it is to learn and get familiar using List<TreeNode>, and understand tree traversal, use one path as List variable to solve backtracking issue; \\n2. Next it is important to learn how to solve the algorithm using recursive function without any data structure;\\n3. Advanced topic is to try ideas using Tuple<TreeNode, int> and experience how efficient it is to design and remove ambiguity in design, follow Single Responsiblity Principle SRP. \\n4. Try other options like Stack, HashSet if you have time to practice. \\n\\n**Data structure is the tool to get organized**\\n\\nLet us get started. First one is combination of Queue, Dictionary, HashSet\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is data structure C# List<TreeNode> \\n\\n\\nC# **List** is enough to solve the problem - topics: backtracking, space optimization\\n\\n**No 2 combinations: C# Data structure: List**\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# HashSet<TreeNode>\\n\\n\\n**No 3 combinations: C# Data structure: HashSet**\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\nJune 25, 2019\\n\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Stack<TreeNode>\\n\\n\\n**Stack** is perfect to maintain the order in last in first out order. \\n\\n**No 4 combinations: C# Data structure: Stack**\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Tuple<TreeNode, int><br>\\n\\n\\n**Tuple** is so powerful and time-efficient, good at strong type definition to avoid run time errors. Give it a try! \\n\\n**No 4 combinations:  C# Data structure: Tuple**\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\nIt is time for me to learn to review my own code. Track my progress and I was so surprised to learn that I need to practice backtracking in 2019, 53 year old. \\n\\n**Extra topic: backtracking, List<TreeNode>**\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sai_manoj_kumar",
                        "content": "Input for the testcase is not being parsed correctly. Where do I report this?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "From May to July 2019\\nIt is my practice for busy season from March to May for two online code assessments and one more phone screen. One of ideas is to finish another 100 algorithm on Leetcode, and pace myself sometimes to work on one algorithm with various approaches. It is for potential phone screen, I may get invited any time. So I like to learn how to prepare more carefully through practice.\\n\\nHere are various topic I cover in my practice, and I also like to share the discussion post for each idea. Some of ideas are just to study code on existing discussion post. \\n\\nI also use the algorithm to interview people on interviewing dot io. It is important for me to learn various solutions first in order to be a good interviewer, and also learn from interview experience through a lot of interviewees. \\n\\nIf you have advice for adding more topics on this algorithm as an interviewer, please leave in the comments. I will add them one by one. \\n\\n**Topics**\\n\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[Post order traversal (May 27, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\n**Recursive function design, why mix return will lead to lowest common ancestor?**\\n[recursive function - Confused and more work later (May 8, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288320/C-Work-on-the-algorithm-in-mock-interview)\\n[recursive function - mix returns, final one is lowest common ancestor (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302311/C-recursive-function-design-step-by-step-illustration)\\n[C# post order traversal and return p or q in recursive function](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/315272/C-post-order-traversal-and-return-p-or-q-in-recursive-function) case study mock interview on June 18, 2019\\n\\n**Return type**\\n**Return bool or TreeNode?**\\n[Recursive solution Easy to understand - return bool (May 15, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n[Recursive solution Easy to understand - return TreeNode (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302301/C-recursive-function-with-return-TreeNode-Easy-to-understand)\\n\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n\\n[C# recursive function to find lowest common ancestor given p and q are in the binary tree (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301664/C-recursive-function-to-find-lowest-common-ancestor-given-p-and-q-are-in-the-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301686/C-Find-lowest-common-ancestor-given-two-nodes-p-and-q-may-not-in-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (June 14, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311875/C-Lowest-common-ancestor-given-node-p-and-q-in-binary-tree)\\n\\n**Naive solution with Timeout and Complicated function**\\n[Timeout challenge (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288284/C-time-out-need-help-using-List-preorder-traversal)\\n[Timeout challenge - using a string to store path (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288289/C-time-out-need-help-using-string-preorder-traversal)\\n[Fix naive solution timeout with complicated function (May 13, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290656/C-Fix-timeout-bug-but-still-keep-the-code-on-purpose-complicated)\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nJune 25, 2019\\nThree practice for three ideas; I like to be a master of the lowest common ancestor! I started again from May 8, 2019, met a lot of talent in Sillicon Valley, Seattle, Toronto area on *** on this algorithm.\\n\\nDare to be a master! Self-claim first!\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\nJuly 4, 2019\\nTwo node\\'s distance in binary tree, the post is [here](https://leetcode.com/discuss/interview-question/125084/Amazon-Distance-between-2-nodes). \\nMy solution is written [here](https://leetcode.com/discuss/interview-question/125084/Amazon-or-Distance-between-2-nodes/300089). The idea is to find lowest common ancestor, and then calculate the distance between two nodes indirectly both to lowest common ancestor.\\n[C# Lowest common ancestor -> two node\\'s distance practice (upward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327282/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(uperward))\\n[C# Lowest common ancestor -> two node\\'s distance practice (downward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327278/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(downward))\\n\\n**Common mistakes in mock interview**\\n\\n1. Preorder traversal vs postorder traversal, early return when p or q is found, the rest of nodes in the tree is not traversed;\\n2. Redundant code in the recursive function;\\n"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "my code is pretty much the same as everyone else's, but I changed the comparison\\nfrom\\n\\n    if (root == p || root == q) then return root;\\n\\nto \\n\\n    if (root.val == p.val || root.val == q.val) then return root;\\n\\nthen I got errors, I'm really confused, if the former conditions are satisfied, the latter must be true too."
                    },
                    {
                        "username": "user3971c",
                        "content": "[@ayushanand18](/ayushanand18) I can\\'t speak for 2015, but as of now the constraints state that All Node.val are unique. "
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@ayushanand18](/ayushanand18) are you there suggesting him right after 8 years....wonder what he is doing now."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "there might also be some nodes which have the same values but not the one we are concerned about. i.e. duplicate value nodes."
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020\\n\\nI continue to ask the algorithm question in my interviewing dot io mock interviews as an interviewer in 2020, and then I was surprised to learn more about recursive function design, strong type, backtracking, and expedite the tree problem solving process. \\n\\nTo work on my C# crafting skills, I also practice the idea after each mock interview. \\n\\nApril 19, 2020\\n[C# backtracking practice after mock interview on April 19, 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655605/C-backtracking-practice-after-mock-interview-on-April-19-2020)\\n\\nMay 1, 2020\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nStatistics:\\n1. 40 mock interviews as an interviewer, ask lowest common ancestor in binary tree algorithm in 2019;\\n2. Work on recursive function design over 10 times;\\n3. Work on backtracking practice over 10 times;\\n4. All engineers over 40 engineers in two months I met in 2019 cannot beat performance I met in 2020, an ex-facebook engineer. \\n\\n"
                    }
                ]
            },
            {
                "id": 1569544,
                "content": [
                    {
                        "username": "jack76",
                        "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS(preOrder).. Easy solution\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three parameters: `root` (the current node), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n2. Check if the current node `root` is null or if it is either `p` or `q`. If any of these conditions is true, return the current node `root` as the lowest common ancestor.\\n\\n3. Recursively call the `rec` function for the left subtree of the current node and assign the result to a variable `l`.\\n\\n4. Recursively call the `rec` function for the right subtree of the current node and assign the result to a variable `r`.\\n\\n5. Check if both `l` and `r` are not null. If so, it means that `p` and `q` are found on different subtrees of the current node, and the current node `root` is their lowest common ancestor. Return the current node `root`.\\n\\n6. If `l` is null, it means that both `p` and `q` are on the right subtree (or not present in the tree). Return `r`.\\n\\n7. If none of the above conditions are met, it means that both `p` and `q` are on the left subtree (or not present in the tree). Return `l`.\\n\\n8. Define a function `lowestCommonAncestor` that takes three parameters: `root` (the root node of the tree), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n9. Return the result of calling the `rec` function with the parameters `root`, `p`, and `q`. This will find and return the lowest common ancestor of nodes `p` and `q` in the given binary tree.\\n\\n-------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n). All node have to visit in worst case.\\n\\n- Space complexity:\\nS.C=O(n) in worst case skewed tree. recursive stack take O(n).\\n--------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3702977/c-dfs-preorder-easy-solution/"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "Update: The bug is already fixed! Thanks LC\\n\\nIt may be due to how OJ parses the test case: every time I tried to run the testcase, it spat `5 is not a valid value of type TreeNode`. \\nI also tried to enclose 5 and 1 in `[]`but no lucky there.\\nCould someone fix this, or let me know if there is a temporary fix on my end, thanks!"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "When I checked some others solutions committed and passed, I found that, they all miss the checking step,which means we need to check if there are both p and q in this tree.\\n\\nfor example,there is a question name called Share C++/C# 24ms recursive solution , the solution it shows doesn't check wether TreeNode p and TreeNode q exist when it returns.\\n\\nSo what do you guys think??"
                    },
                    {
                        "username": "GUTTTS",
                        "content": "[@mochiball](/mochiball) bro he wrote that in 2015 maybe that time there wasnt anything mentioned in the constraints\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Please read the question constraints. It tells you that p and q are in the tree. No need to check if they exist "
                    },
                    {
                        "username": "harsha335",
                        "content": "in constraints they mentioned both p and q will be present in tree and they are unique and not equal."
                    },
                    {
                        "username": "gepo",
                        "content": "Something is going wrong.\\nLine 41: TypeError: object of type \\'int\\' has no len()"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020 \\n\\nIt is important for me to train myself to get familar with C# data structure and also think better what to choose in design process. There are more than five solutions I like to share using C# data struture: List, Stack, Queue, Dictionary (HashMap), HashSet, Tuple. \\n\\nHere are my highlights:\\n1. First and most important, it is to learn and get familiar using List<TreeNode>, and understand tree traversal, use one path as List variable to solve backtracking issue; \\n2. Next it is important to learn how to solve the algorithm using recursive function without any data structure;\\n3. Advanced topic is to try ideas using Tuple<TreeNode, int> and experience how efficient it is to design and remove ambiguity in design, follow Single Responsiblity Principle SRP. \\n4. Try other options like Stack, HashSet if you have time to practice. \\n\\n**Data structure is the tool to get organized**\\n\\nLet us get started. First one is combination of Queue, Dictionary, HashSet\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is data structure C# List<TreeNode> \\n\\n\\nC# **List** is enough to solve the problem - topics: backtracking, space optimization\\n\\n**No 2 combinations: C# Data structure: List**\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# HashSet<TreeNode>\\n\\n\\n**No 3 combinations: C# Data structure: HashSet**\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\nJune 25, 2019\\n\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Stack<TreeNode>\\n\\n\\n**Stack** is perfect to maintain the order in last in first out order. \\n\\n**No 4 combinations: C# Data structure: Stack**\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Tuple<TreeNode, int><br>\\n\\n\\n**Tuple** is so powerful and time-efficient, good at strong type definition to avoid run time errors. Give it a try! \\n\\n**No 4 combinations:  C# Data structure: Tuple**\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\nIt is time for me to learn to review my own code. Track my progress and I was so surprised to learn that I need to practice backtracking in 2019, 53 year old. \\n\\n**Extra topic: backtracking, List<TreeNode>**\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sai_manoj_kumar",
                        "content": "Input for the testcase is not being parsed correctly. Where do I report this?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "From May to July 2019\\nIt is my practice for busy season from March to May for two online code assessments and one more phone screen. One of ideas is to finish another 100 algorithm on Leetcode, and pace myself sometimes to work on one algorithm with various approaches. It is for potential phone screen, I may get invited any time. So I like to learn how to prepare more carefully through practice.\\n\\nHere are various topic I cover in my practice, and I also like to share the discussion post for each idea. Some of ideas are just to study code on existing discussion post. \\n\\nI also use the algorithm to interview people on interviewing dot io. It is important for me to learn various solutions first in order to be a good interviewer, and also learn from interview experience through a lot of interviewees. \\n\\nIf you have advice for adding more topics on this algorithm as an interviewer, please leave in the comments. I will add them one by one. \\n\\n**Topics**\\n\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[Post order traversal (May 27, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\n**Recursive function design, why mix return will lead to lowest common ancestor?**\\n[recursive function - Confused and more work later (May 8, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288320/C-Work-on-the-algorithm-in-mock-interview)\\n[recursive function - mix returns, final one is lowest common ancestor (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302311/C-recursive-function-design-step-by-step-illustration)\\n[C# post order traversal and return p or q in recursive function](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/315272/C-post-order-traversal-and-return-p-or-q-in-recursive-function) case study mock interview on June 18, 2019\\n\\n**Return type**\\n**Return bool or TreeNode?**\\n[Recursive solution Easy to understand - return bool (May 15, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n[Recursive solution Easy to understand - return TreeNode (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302301/C-recursive-function-with-return-TreeNode-Easy-to-understand)\\n\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n\\n[C# recursive function to find lowest common ancestor given p and q are in the binary tree (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301664/C-recursive-function-to-find-lowest-common-ancestor-given-p-and-q-are-in-the-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301686/C-Find-lowest-common-ancestor-given-two-nodes-p-and-q-may-not-in-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (June 14, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311875/C-Lowest-common-ancestor-given-node-p-and-q-in-binary-tree)\\n\\n**Naive solution with Timeout and Complicated function**\\n[Timeout challenge (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288284/C-time-out-need-help-using-List-preorder-traversal)\\n[Timeout challenge - using a string to store path (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288289/C-time-out-need-help-using-string-preorder-traversal)\\n[Fix naive solution timeout with complicated function (May 13, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290656/C-Fix-timeout-bug-but-still-keep-the-code-on-purpose-complicated)\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nJune 25, 2019\\nThree practice for three ideas; I like to be a master of the lowest common ancestor! I started again from May 8, 2019, met a lot of talent in Sillicon Valley, Seattle, Toronto area on *** on this algorithm.\\n\\nDare to be a master! Self-claim first!\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\nJuly 4, 2019\\nTwo node\\'s distance in binary tree, the post is [here](https://leetcode.com/discuss/interview-question/125084/Amazon-Distance-between-2-nodes). \\nMy solution is written [here](https://leetcode.com/discuss/interview-question/125084/Amazon-or-Distance-between-2-nodes/300089). The idea is to find lowest common ancestor, and then calculate the distance between two nodes indirectly both to lowest common ancestor.\\n[C# Lowest common ancestor -> two node\\'s distance practice (upward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327282/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(uperward))\\n[C# Lowest common ancestor -> two node\\'s distance practice (downward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327278/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(downward))\\n\\n**Common mistakes in mock interview**\\n\\n1. Preorder traversal vs postorder traversal, early return when p or q is found, the rest of nodes in the tree is not traversed;\\n2. Redundant code in the recursive function;\\n"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "my code is pretty much the same as everyone else's, but I changed the comparison\\nfrom\\n\\n    if (root == p || root == q) then return root;\\n\\nto \\n\\n    if (root.val == p.val || root.val == q.val) then return root;\\n\\nthen I got errors, I'm really confused, if the former conditions are satisfied, the latter must be true too."
                    },
                    {
                        "username": "user3971c",
                        "content": "[@ayushanand18](/ayushanand18) I can\\'t speak for 2015, but as of now the constraints state that All Node.val are unique. "
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@ayushanand18](/ayushanand18) are you there suggesting him right after 8 years....wonder what he is doing now."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "there might also be some nodes which have the same values but not the one we are concerned about. i.e. duplicate value nodes."
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020\\n\\nI continue to ask the algorithm question in my interviewing dot io mock interviews as an interviewer in 2020, and then I was surprised to learn more about recursive function design, strong type, backtracking, and expedite the tree problem solving process. \\n\\nTo work on my C# crafting skills, I also practice the idea after each mock interview. \\n\\nApril 19, 2020\\n[C# backtracking practice after mock interview on April 19, 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655605/C-backtracking-practice-after-mock-interview-on-April-19-2020)\\n\\nMay 1, 2020\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nStatistics:\\n1. 40 mock interviews as an interviewer, ask lowest common ancestor in binary tree algorithm in 2019;\\n2. Work on recursive function design over 10 times;\\n3. Work on backtracking practice over 10 times;\\n4. All engineers over 40 engineers in two months I met in 2019 cannot beat performance I met in 2020, an ex-facebook engineer. \\n\\n"
                    }
                ]
            },
            {
                "id": 1568138,
                "content": [
                    {
                        "username": "jack76",
                        "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS(preOrder).. Easy solution\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three parameters: `root` (the current node), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n2. Check if the current node `root` is null or if it is either `p` or `q`. If any of these conditions is true, return the current node `root` as the lowest common ancestor.\\n\\n3. Recursively call the `rec` function for the left subtree of the current node and assign the result to a variable `l`.\\n\\n4. Recursively call the `rec` function for the right subtree of the current node and assign the result to a variable `r`.\\n\\n5. Check if both `l` and `r` are not null. If so, it means that `p` and `q` are found on different subtrees of the current node, and the current node `root` is their lowest common ancestor. Return the current node `root`.\\n\\n6. If `l` is null, it means that both `p` and `q` are on the right subtree (or not present in the tree). Return `r`.\\n\\n7. If none of the above conditions are met, it means that both `p` and `q` are on the left subtree (or not present in the tree). Return `l`.\\n\\n8. Define a function `lowestCommonAncestor` that takes three parameters: `root` (the root node of the tree), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n9. Return the result of calling the `rec` function with the parameters `root`, `p`, and `q`. This will find and return the lowest common ancestor of nodes `p` and `q` in the given binary tree.\\n\\n-------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n). All node have to visit in worst case.\\n\\n- Space complexity:\\nS.C=O(n) in worst case skewed tree. recursive stack take O(n).\\n--------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3702977/c-dfs-preorder-easy-solution/"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "Update: The bug is already fixed! Thanks LC\\n\\nIt may be due to how OJ parses the test case: every time I tried to run the testcase, it spat `5 is not a valid value of type TreeNode`. \\nI also tried to enclose 5 and 1 in `[]`but no lucky there.\\nCould someone fix this, or let me know if there is a temporary fix on my end, thanks!"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "When I checked some others solutions committed and passed, I found that, they all miss the checking step,which means we need to check if there are both p and q in this tree.\\n\\nfor example,there is a question name called Share C++/C# 24ms recursive solution , the solution it shows doesn't check wether TreeNode p and TreeNode q exist when it returns.\\n\\nSo what do you guys think??"
                    },
                    {
                        "username": "GUTTTS",
                        "content": "[@mochiball](/mochiball) bro he wrote that in 2015 maybe that time there wasnt anything mentioned in the constraints\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Please read the question constraints. It tells you that p and q are in the tree. No need to check if they exist "
                    },
                    {
                        "username": "harsha335",
                        "content": "in constraints they mentioned both p and q will be present in tree and they are unique and not equal."
                    },
                    {
                        "username": "gepo",
                        "content": "Something is going wrong.\\nLine 41: TypeError: object of type \\'int\\' has no len()"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020 \\n\\nIt is important for me to train myself to get familar with C# data structure and also think better what to choose in design process. There are more than five solutions I like to share using C# data struture: List, Stack, Queue, Dictionary (HashMap), HashSet, Tuple. \\n\\nHere are my highlights:\\n1. First and most important, it is to learn and get familiar using List<TreeNode>, and understand tree traversal, use one path as List variable to solve backtracking issue; \\n2. Next it is important to learn how to solve the algorithm using recursive function without any data structure;\\n3. Advanced topic is to try ideas using Tuple<TreeNode, int> and experience how efficient it is to design and remove ambiguity in design, follow Single Responsiblity Principle SRP. \\n4. Try other options like Stack, HashSet if you have time to practice. \\n\\n**Data structure is the tool to get organized**\\n\\nLet us get started. First one is combination of Queue, Dictionary, HashSet\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is data structure C# List<TreeNode> \\n\\n\\nC# **List** is enough to solve the problem - topics: backtracking, space optimization\\n\\n**No 2 combinations: C# Data structure: List**\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# HashSet<TreeNode>\\n\\n\\n**No 3 combinations: C# Data structure: HashSet**\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\nJune 25, 2019\\n\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Stack<TreeNode>\\n\\n\\n**Stack** is perfect to maintain the order in last in first out order. \\n\\n**No 4 combinations: C# Data structure: Stack**\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Tuple<TreeNode, int><br>\\n\\n\\n**Tuple** is so powerful and time-efficient, good at strong type definition to avoid run time errors. Give it a try! \\n\\n**No 4 combinations:  C# Data structure: Tuple**\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\nIt is time for me to learn to review my own code. Track my progress and I was so surprised to learn that I need to practice backtracking in 2019, 53 year old. \\n\\n**Extra topic: backtracking, List<TreeNode>**\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sai_manoj_kumar",
                        "content": "Input for the testcase is not being parsed correctly. Where do I report this?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "From May to July 2019\\nIt is my practice for busy season from March to May for two online code assessments and one more phone screen. One of ideas is to finish another 100 algorithm on Leetcode, and pace myself sometimes to work on one algorithm with various approaches. It is for potential phone screen, I may get invited any time. So I like to learn how to prepare more carefully through practice.\\n\\nHere are various topic I cover in my practice, and I also like to share the discussion post for each idea. Some of ideas are just to study code on existing discussion post. \\n\\nI also use the algorithm to interview people on interviewing dot io. It is important for me to learn various solutions first in order to be a good interviewer, and also learn from interview experience through a lot of interviewees. \\n\\nIf you have advice for adding more topics on this algorithm as an interviewer, please leave in the comments. I will add them one by one. \\n\\n**Topics**\\n\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[Post order traversal (May 27, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\n**Recursive function design, why mix return will lead to lowest common ancestor?**\\n[recursive function - Confused and more work later (May 8, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288320/C-Work-on-the-algorithm-in-mock-interview)\\n[recursive function - mix returns, final one is lowest common ancestor (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302311/C-recursive-function-design-step-by-step-illustration)\\n[C# post order traversal and return p or q in recursive function](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/315272/C-post-order-traversal-and-return-p-or-q-in-recursive-function) case study mock interview on June 18, 2019\\n\\n**Return type**\\n**Return bool or TreeNode?**\\n[Recursive solution Easy to understand - return bool (May 15, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n[Recursive solution Easy to understand - return TreeNode (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302301/C-recursive-function-with-return-TreeNode-Easy-to-understand)\\n\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n\\n[C# recursive function to find lowest common ancestor given p and q are in the binary tree (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301664/C-recursive-function-to-find-lowest-common-ancestor-given-p-and-q-are-in-the-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301686/C-Find-lowest-common-ancestor-given-two-nodes-p-and-q-may-not-in-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (June 14, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311875/C-Lowest-common-ancestor-given-node-p-and-q-in-binary-tree)\\n\\n**Naive solution with Timeout and Complicated function**\\n[Timeout challenge (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288284/C-time-out-need-help-using-List-preorder-traversal)\\n[Timeout challenge - using a string to store path (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288289/C-time-out-need-help-using-string-preorder-traversal)\\n[Fix naive solution timeout with complicated function (May 13, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290656/C-Fix-timeout-bug-but-still-keep-the-code-on-purpose-complicated)\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nJune 25, 2019\\nThree practice for three ideas; I like to be a master of the lowest common ancestor! I started again from May 8, 2019, met a lot of talent in Sillicon Valley, Seattle, Toronto area on *** on this algorithm.\\n\\nDare to be a master! Self-claim first!\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\nJuly 4, 2019\\nTwo node\\'s distance in binary tree, the post is [here](https://leetcode.com/discuss/interview-question/125084/Amazon-Distance-between-2-nodes). \\nMy solution is written [here](https://leetcode.com/discuss/interview-question/125084/Amazon-or-Distance-between-2-nodes/300089). The idea is to find lowest common ancestor, and then calculate the distance between two nodes indirectly both to lowest common ancestor.\\n[C# Lowest common ancestor -> two node\\'s distance practice (upward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327282/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(uperward))\\n[C# Lowest common ancestor -> two node\\'s distance practice (downward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327278/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(downward))\\n\\n**Common mistakes in mock interview**\\n\\n1. Preorder traversal vs postorder traversal, early return when p or q is found, the rest of nodes in the tree is not traversed;\\n2. Redundant code in the recursive function;\\n"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "my code is pretty much the same as everyone else's, but I changed the comparison\\nfrom\\n\\n    if (root == p || root == q) then return root;\\n\\nto \\n\\n    if (root.val == p.val || root.val == q.val) then return root;\\n\\nthen I got errors, I'm really confused, if the former conditions are satisfied, the latter must be true too."
                    },
                    {
                        "username": "user3971c",
                        "content": "[@ayushanand18](/ayushanand18) I can\\'t speak for 2015, but as of now the constraints state that All Node.val are unique. "
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@ayushanand18](/ayushanand18) are you there suggesting him right after 8 years....wonder what he is doing now."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "there might also be some nodes which have the same values but not the one we are concerned about. i.e. duplicate value nodes."
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020\\n\\nI continue to ask the algorithm question in my interviewing dot io mock interviews as an interviewer in 2020, and then I was surprised to learn more about recursive function design, strong type, backtracking, and expedite the tree problem solving process. \\n\\nTo work on my C# crafting skills, I also practice the idea after each mock interview. \\n\\nApril 19, 2020\\n[C# backtracking practice after mock interview on April 19, 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655605/C-backtracking-practice-after-mock-interview-on-April-19-2020)\\n\\nMay 1, 2020\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nStatistics:\\n1. 40 mock interviews as an interviewer, ask lowest common ancestor in binary tree algorithm in 2019;\\n2. Work on recursive function design over 10 times;\\n3. Work on backtracking practice over 10 times;\\n4. All engineers over 40 engineers in two months I met in 2019 cannot beat performance I met in 2020, an ex-facebook engineer. \\n\\n"
                    }
                ]
            },
            {
                "id": 1567925,
                "content": [
                    {
                        "username": "jack76",
                        "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS(preOrder).. Easy solution\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three parameters: `root` (the current node), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n2. Check if the current node `root` is null or if it is either `p` or `q`. If any of these conditions is true, return the current node `root` as the lowest common ancestor.\\n\\n3. Recursively call the `rec` function for the left subtree of the current node and assign the result to a variable `l`.\\n\\n4. Recursively call the `rec` function for the right subtree of the current node and assign the result to a variable `r`.\\n\\n5. Check if both `l` and `r` are not null. If so, it means that `p` and `q` are found on different subtrees of the current node, and the current node `root` is their lowest common ancestor. Return the current node `root`.\\n\\n6. If `l` is null, it means that both `p` and `q` are on the right subtree (or not present in the tree). Return `r`.\\n\\n7. If none of the above conditions are met, it means that both `p` and `q` are on the left subtree (or not present in the tree). Return `l`.\\n\\n8. Define a function `lowestCommonAncestor` that takes three parameters: `root` (the root node of the tree), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n9. Return the result of calling the `rec` function with the parameters `root`, `p`, and `q`. This will find and return the lowest common ancestor of nodes `p` and `q` in the given binary tree.\\n\\n-------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n). All node have to visit in worst case.\\n\\n- Space complexity:\\nS.C=O(n) in worst case skewed tree. recursive stack take O(n).\\n--------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3702977/c-dfs-preorder-easy-solution/"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "Update: The bug is already fixed! Thanks LC\\n\\nIt may be due to how OJ parses the test case: every time I tried to run the testcase, it spat `5 is not a valid value of type TreeNode`. \\nI also tried to enclose 5 and 1 in `[]`but no lucky there.\\nCould someone fix this, or let me know if there is a temporary fix on my end, thanks!"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "When I checked some others solutions committed and passed, I found that, they all miss the checking step,which means we need to check if there are both p and q in this tree.\\n\\nfor example,there is a question name called Share C++/C# 24ms recursive solution , the solution it shows doesn't check wether TreeNode p and TreeNode q exist when it returns.\\n\\nSo what do you guys think??"
                    },
                    {
                        "username": "GUTTTS",
                        "content": "[@mochiball](/mochiball) bro he wrote that in 2015 maybe that time there wasnt anything mentioned in the constraints\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Please read the question constraints. It tells you that p and q are in the tree. No need to check if they exist "
                    },
                    {
                        "username": "harsha335",
                        "content": "in constraints they mentioned both p and q will be present in tree and they are unique and not equal."
                    },
                    {
                        "username": "gepo",
                        "content": "Something is going wrong.\\nLine 41: TypeError: object of type \\'int\\' has no len()"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020 \\n\\nIt is important for me to train myself to get familar with C# data structure and also think better what to choose in design process. There are more than five solutions I like to share using C# data struture: List, Stack, Queue, Dictionary (HashMap), HashSet, Tuple. \\n\\nHere are my highlights:\\n1. First and most important, it is to learn and get familiar using List<TreeNode>, and understand tree traversal, use one path as List variable to solve backtracking issue; \\n2. Next it is important to learn how to solve the algorithm using recursive function without any data structure;\\n3. Advanced topic is to try ideas using Tuple<TreeNode, int> and experience how efficient it is to design and remove ambiguity in design, follow Single Responsiblity Principle SRP. \\n4. Try other options like Stack, HashSet if you have time to practice. \\n\\n**Data structure is the tool to get organized**\\n\\nLet us get started. First one is combination of Queue, Dictionary, HashSet\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is data structure C# List<TreeNode> \\n\\n\\nC# **List** is enough to solve the problem - topics: backtracking, space optimization\\n\\n**No 2 combinations: C# Data structure: List**\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# HashSet<TreeNode>\\n\\n\\n**No 3 combinations: C# Data structure: HashSet**\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\nJune 25, 2019\\n\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Stack<TreeNode>\\n\\n\\n**Stack** is perfect to maintain the order in last in first out order. \\n\\n**No 4 combinations: C# Data structure: Stack**\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Tuple<TreeNode, int><br>\\n\\n\\n**Tuple** is so powerful and time-efficient, good at strong type definition to avoid run time errors. Give it a try! \\n\\n**No 4 combinations:  C# Data structure: Tuple**\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\nIt is time for me to learn to review my own code. Track my progress and I was so surprised to learn that I need to practice backtracking in 2019, 53 year old. \\n\\n**Extra topic: backtracking, List<TreeNode>**\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sai_manoj_kumar",
                        "content": "Input for the testcase is not being parsed correctly. Where do I report this?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "From May to July 2019\\nIt is my practice for busy season from March to May for two online code assessments and one more phone screen. One of ideas is to finish another 100 algorithm on Leetcode, and pace myself sometimes to work on one algorithm with various approaches. It is for potential phone screen, I may get invited any time. So I like to learn how to prepare more carefully through practice.\\n\\nHere are various topic I cover in my practice, and I also like to share the discussion post for each idea. Some of ideas are just to study code on existing discussion post. \\n\\nI also use the algorithm to interview people on interviewing dot io. It is important for me to learn various solutions first in order to be a good interviewer, and also learn from interview experience through a lot of interviewees. \\n\\nIf you have advice for adding more topics on this algorithm as an interviewer, please leave in the comments. I will add them one by one. \\n\\n**Topics**\\n\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[Post order traversal (May 27, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\n**Recursive function design, why mix return will lead to lowest common ancestor?**\\n[recursive function - Confused and more work later (May 8, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288320/C-Work-on-the-algorithm-in-mock-interview)\\n[recursive function - mix returns, final one is lowest common ancestor (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302311/C-recursive-function-design-step-by-step-illustration)\\n[C# post order traversal and return p or q in recursive function](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/315272/C-post-order-traversal-and-return-p-or-q-in-recursive-function) case study mock interview on June 18, 2019\\n\\n**Return type**\\n**Return bool or TreeNode?**\\n[Recursive solution Easy to understand - return bool (May 15, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n[Recursive solution Easy to understand - return TreeNode (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302301/C-recursive-function-with-return-TreeNode-Easy-to-understand)\\n\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n\\n[C# recursive function to find lowest common ancestor given p and q are in the binary tree (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301664/C-recursive-function-to-find-lowest-common-ancestor-given-p-and-q-are-in-the-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301686/C-Find-lowest-common-ancestor-given-two-nodes-p-and-q-may-not-in-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (June 14, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311875/C-Lowest-common-ancestor-given-node-p-and-q-in-binary-tree)\\n\\n**Naive solution with Timeout and Complicated function**\\n[Timeout challenge (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288284/C-time-out-need-help-using-List-preorder-traversal)\\n[Timeout challenge - using a string to store path (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288289/C-time-out-need-help-using-string-preorder-traversal)\\n[Fix naive solution timeout with complicated function (May 13, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290656/C-Fix-timeout-bug-but-still-keep-the-code-on-purpose-complicated)\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nJune 25, 2019\\nThree practice for three ideas; I like to be a master of the lowest common ancestor! I started again from May 8, 2019, met a lot of talent in Sillicon Valley, Seattle, Toronto area on *** on this algorithm.\\n\\nDare to be a master! Self-claim first!\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\nJuly 4, 2019\\nTwo node\\'s distance in binary tree, the post is [here](https://leetcode.com/discuss/interview-question/125084/Amazon-Distance-between-2-nodes). \\nMy solution is written [here](https://leetcode.com/discuss/interview-question/125084/Amazon-or-Distance-between-2-nodes/300089). The idea is to find lowest common ancestor, and then calculate the distance between two nodes indirectly both to lowest common ancestor.\\n[C# Lowest common ancestor -> two node\\'s distance practice (upward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327282/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(uperward))\\n[C# Lowest common ancestor -> two node\\'s distance practice (downward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327278/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(downward))\\n\\n**Common mistakes in mock interview**\\n\\n1. Preorder traversal vs postorder traversal, early return when p or q is found, the rest of nodes in the tree is not traversed;\\n2. Redundant code in the recursive function;\\n"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "my code is pretty much the same as everyone else's, but I changed the comparison\\nfrom\\n\\n    if (root == p || root == q) then return root;\\n\\nto \\n\\n    if (root.val == p.val || root.val == q.val) then return root;\\n\\nthen I got errors, I'm really confused, if the former conditions are satisfied, the latter must be true too."
                    },
                    {
                        "username": "user3971c",
                        "content": "[@ayushanand18](/ayushanand18) I can\\'t speak for 2015, but as of now the constraints state that All Node.val are unique. "
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@ayushanand18](/ayushanand18) are you there suggesting him right after 8 years....wonder what he is doing now."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "there might also be some nodes which have the same values but not the one we are concerned about. i.e. duplicate value nodes."
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020\\n\\nI continue to ask the algorithm question in my interviewing dot io mock interviews as an interviewer in 2020, and then I was surprised to learn more about recursive function design, strong type, backtracking, and expedite the tree problem solving process. \\n\\nTo work on my C# crafting skills, I also practice the idea after each mock interview. \\n\\nApril 19, 2020\\n[C# backtracking practice after mock interview on April 19, 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655605/C-backtracking-practice-after-mock-interview-on-April-19-2020)\\n\\nMay 1, 2020\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nStatistics:\\n1. 40 mock interviews as an interviewer, ask lowest common ancestor in binary tree algorithm in 2019;\\n2. Work on recursive function design over 10 times;\\n3. Work on backtracking practice over 10 times;\\n4. All engineers over 40 engineers in two months I met in 2019 cannot beat performance I met in 2020, an ex-facebook engineer. \\n\\n"
                    }
                ]
            },
            {
                "id": 1573825,
                "content": [
                    {
                        "username": "jack76",
                        "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS(preOrder).. Easy solution\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three parameters: `root` (the current node), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n2. Check if the current node `root` is null or if it is either `p` or `q`. If any of these conditions is true, return the current node `root` as the lowest common ancestor.\\n\\n3. Recursively call the `rec` function for the left subtree of the current node and assign the result to a variable `l`.\\n\\n4. Recursively call the `rec` function for the right subtree of the current node and assign the result to a variable `r`.\\n\\n5. Check if both `l` and `r` are not null. If so, it means that `p` and `q` are found on different subtrees of the current node, and the current node `root` is their lowest common ancestor. Return the current node `root`.\\n\\n6. If `l` is null, it means that both `p` and `q` are on the right subtree (or not present in the tree). Return `r`.\\n\\n7. If none of the above conditions are met, it means that both `p` and `q` are on the left subtree (or not present in the tree). Return `l`.\\n\\n8. Define a function `lowestCommonAncestor` that takes three parameters: `root` (the root node of the tree), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n9. Return the result of calling the `rec` function with the parameters `root`, `p`, and `q`. This will find and return the lowest common ancestor of nodes `p` and `q` in the given binary tree.\\n\\n-------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n). All node have to visit in worst case.\\n\\n- Space complexity:\\nS.C=O(n) in worst case skewed tree. recursive stack take O(n).\\n--------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3702977/c-dfs-preorder-easy-solution/"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "Update: The bug is already fixed! Thanks LC\\n\\nIt may be due to how OJ parses the test case: every time I tried to run the testcase, it spat `5 is not a valid value of type TreeNode`. \\nI also tried to enclose 5 and 1 in `[]`but no lucky there.\\nCould someone fix this, or let me know if there is a temporary fix on my end, thanks!"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "When I checked some others solutions committed and passed, I found that, they all miss the checking step,which means we need to check if there are both p and q in this tree.\\n\\nfor example,there is a question name called Share C++/C# 24ms recursive solution , the solution it shows doesn't check wether TreeNode p and TreeNode q exist when it returns.\\n\\nSo what do you guys think??"
                    },
                    {
                        "username": "GUTTTS",
                        "content": "[@mochiball](/mochiball) bro he wrote that in 2015 maybe that time there wasnt anything mentioned in the constraints\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Please read the question constraints. It tells you that p and q are in the tree. No need to check if they exist "
                    },
                    {
                        "username": "harsha335",
                        "content": "in constraints they mentioned both p and q will be present in tree and they are unique and not equal."
                    },
                    {
                        "username": "gepo",
                        "content": "Something is going wrong.\\nLine 41: TypeError: object of type \\'int\\' has no len()"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020 \\n\\nIt is important for me to train myself to get familar with C# data structure and also think better what to choose in design process. There are more than five solutions I like to share using C# data struture: List, Stack, Queue, Dictionary (HashMap), HashSet, Tuple. \\n\\nHere are my highlights:\\n1. First and most important, it is to learn and get familiar using List<TreeNode>, and understand tree traversal, use one path as List variable to solve backtracking issue; \\n2. Next it is important to learn how to solve the algorithm using recursive function without any data structure;\\n3. Advanced topic is to try ideas using Tuple<TreeNode, int> and experience how efficient it is to design and remove ambiguity in design, follow Single Responsiblity Principle SRP. \\n4. Try other options like Stack, HashSet if you have time to practice. \\n\\n**Data structure is the tool to get organized**\\n\\nLet us get started. First one is combination of Queue, Dictionary, HashSet\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is data structure C# List<TreeNode> \\n\\n\\nC# **List** is enough to solve the problem - topics: backtracking, space optimization\\n\\n**No 2 combinations: C# Data structure: List**\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# HashSet<TreeNode>\\n\\n\\n**No 3 combinations: C# Data structure: HashSet**\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\nJune 25, 2019\\n\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Stack<TreeNode>\\n\\n\\n**Stack** is perfect to maintain the order in last in first out order. \\n\\n**No 4 combinations: C# Data structure: Stack**\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Tuple<TreeNode, int><br>\\n\\n\\n**Tuple** is so powerful and time-efficient, good at strong type definition to avoid run time errors. Give it a try! \\n\\n**No 4 combinations:  C# Data structure: Tuple**\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\nIt is time for me to learn to review my own code. Track my progress and I was so surprised to learn that I need to practice backtracking in 2019, 53 year old. \\n\\n**Extra topic: backtracking, List<TreeNode>**\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sai_manoj_kumar",
                        "content": "Input for the testcase is not being parsed correctly. Where do I report this?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "From May to July 2019\\nIt is my practice for busy season from March to May for two online code assessments and one more phone screen. One of ideas is to finish another 100 algorithm on Leetcode, and pace myself sometimes to work on one algorithm with various approaches. It is for potential phone screen, I may get invited any time. So I like to learn how to prepare more carefully through practice.\\n\\nHere are various topic I cover in my practice, and I also like to share the discussion post for each idea. Some of ideas are just to study code on existing discussion post. \\n\\nI also use the algorithm to interview people on interviewing dot io. It is important for me to learn various solutions first in order to be a good interviewer, and also learn from interview experience through a lot of interviewees. \\n\\nIf you have advice for adding more topics on this algorithm as an interviewer, please leave in the comments. I will add them one by one. \\n\\n**Topics**\\n\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[Post order traversal (May 27, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\n**Recursive function design, why mix return will lead to lowest common ancestor?**\\n[recursive function - Confused and more work later (May 8, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288320/C-Work-on-the-algorithm-in-mock-interview)\\n[recursive function - mix returns, final one is lowest common ancestor (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302311/C-recursive-function-design-step-by-step-illustration)\\n[C# post order traversal and return p or q in recursive function](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/315272/C-post-order-traversal-and-return-p-or-q-in-recursive-function) case study mock interview on June 18, 2019\\n\\n**Return type**\\n**Return bool or TreeNode?**\\n[Recursive solution Easy to understand - return bool (May 15, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n[Recursive solution Easy to understand - return TreeNode (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302301/C-recursive-function-with-return-TreeNode-Easy-to-understand)\\n\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n\\n[C# recursive function to find lowest common ancestor given p and q are in the binary tree (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301664/C-recursive-function-to-find-lowest-common-ancestor-given-p-and-q-are-in-the-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301686/C-Find-lowest-common-ancestor-given-two-nodes-p-and-q-may-not-in-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (June 14, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311875/C-Lowest-common-ancestor-given-node-p-and-q-in-binary-tree)\\n\\n**Naive solution with Timeout and Complicated function**\\n[Timeout challenge (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288284/C-time-out-need-help-using-List-preorder-traversal)\\n[Timeout challenge - using a string to store path (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288289/C-time-out-need-help-using-string-preorder-traversal)\\n[Fix naive solution timeout with complicated function (May 13, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290656/C-Fix-timeout-bug-but-still-keep-the-code-on-purpose-complicated)\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nJune 25, 2019\\nThree practice for three ideas; I like to be a master of the lowest common ancestor! I started again from May 8, 2019, met a lot of talent in Sillicon Valley, Seattle, Toronto area on *** on this algorithm.\\n\\nDare to be a master! Self-claim first!\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\nJuly 4, 2019\\nTwo node\\'s distance in binary tree, the post is [here](https://leetcode.com/discuss/interview-question/125084/Amazon-Distance-between-2-nodes). \\nMy solution is written [here](https://leetcode.com/discuss/interview-question/125084/Amazon-or-Distance-between-2-nodes/300089). The idea is to find lowest common ancestor, and then calculate the distance between two nodes indirectly both to lowest common ancestor.\\n[C# Lowest common ancestor -> two node\\'s distance practice (upward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327282/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(uperward))\\n[C# Lowest common ancestor -> two node\\'s distance practice (downward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327278/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(downward))\\n\\n**Common mistakes in mock interview**\\n\\n1. Preorder traversal vs postorder traversal, early return when p or q is found, the rest of nodes in the tree is not traversed;\\n2. Redundant code in the recursive function;\\n"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "my code is pretty much the same as everyone else's, but I changed the comparison\\nfrom\\n\\n    if (root == p || root == q) then return root;\\n\\nto \\n\\n    if (root.val == p.val || root.val == q.val) then return root;\\n\\nthen I got errors, I'm really confused, if the former conditions are satisfied, the latter must be true too."
                    },
                    {
                        "username": "user3971c",
                        "content": "[@ayushanand18](/ayushanand18) I can\\'t speak for 2015, but as of now the constraints state that All Node.val are unique. "
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@ayushanand18](/ayushanand18) are you there suggesting him right after 8 years....wonder what he is doing now."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "there might also be some nodes which have the same values but not the one we are concerned about. i.e. duplicate value nodes."
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020\\n\\nI continue to ask the algorithm question in my interviewing dot io mock interviews as an interviewer in 2020, and then I was surprised to learn more about recursive function design, strong type, backtracking, and expedite the tree problem solving process. \\n\\nTo work on my C# crafting skills, I also practice the idea after each mock interview. \\n\\nApril 19, 2020\\n[C# backtracking practice after mock interview on April 19, 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655605/C-backtracking-practice-after-mock-interview-on-April-19-2020)\\n\\nMay 1, 2020\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nStatistics:\\n1. 40 mock interviews as an interviewer, ask lowest common ancestor in binary tree algorithm in 2019;\\n2. Work on recursive function design over 10 times;\\n3. Work on backtracking practice over 10 times;\\n4. All engineers over 40 engineers in two months I met in 2019 cannot beat performance I met in 2020, an ex-facebook engineer. \\n\\n"
                    }
                ]
            },
            {
                "id": 1564871,
                "content": [
                    {
                        "username": "jack76",
                        "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS(preOrder).. Easy solution\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three parameters: `root` (the current node), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n2. Check if the current node `root` is null or if it is either `p` or `q`. If any of these conditions is true, return the current node `root` as the lowest common ancestor.\\n\\n3. Recursively call the `rec` function for the left subtree of the current node and assign the result to a variable `l`.\\n\\n4. Recursively call the `rec` function for the right subtree of the current node and assign the result to a variable `r`.\\n\\n5. Check if both `l` and `r` are not null. If so, it means that `p` and `q` are found on different subtrees of the current node, and the current node `root` is their lowest common ancestor. Return the current node `root`.\\n\\n6. If `l` is null, it means that both `p` and `q` are on the right subtree (or not present in the tree). Return `r`.\\n\\n7. If none of the above conditions are met, it means that both `p` and `q` are on the left subtree (or not present in the tree). Return `l`.\\n\\n8. Define a function `lowestCommonAncestor` that takes three parameters: `root` (the root node of the tree), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n9. Return the result of calling the `rec` function with the parameters `root`, `p`, and `q`. This will find and return the lowest common ancestor of nodes `p` and `q` in the given binary tree.\\n\\n-------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n). All node have to visit in worst case.\\n\\n- Space complexity:\\nS.C=O(n) in worst case skewed tree. recursive stack take O(n).\\n--------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3702977/c-dfs-preorder-easy-solution/"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "Update: The bug is already fixed! Thanks LC\\n\\nIt may be due to how OJ parses the test case: every time I tried to run the testcase, it spat `5 is not a valid value of type TreeNode`. \\nI also tried to enclose 5 and 1 in `[]`but no lucky there.\\nCould someone fix this, or let me know if there is a temporary fix on my end, thanks!"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "When I checked some others solutions committed and passed, I found that, they all miss the checking step,which means we need to check if there are both p and q in this tree.\\n\\nfor example,there is a question name called Share C++/C# 24ms recursive solution , the solution it shows doesn't check wether TreeNode p and TreeNode q exist when it returns.\\n\\nSo what do you guys think??"
                    },
                    {
                        "username": "GUTTTS",
                        "content": "[@mochiball](/mochiball) bro he wrote that in 2015 maybe that time there wasnt anything mentioned in the constraints\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Please read the question constraints. It tells you that p and q are in the tree. No need to check if they exist "
                    },
                    {
                        "username": "harsha335",
                        "content": "in constraints they mentioned both p and q will be present in tree and they are unique and not equal."
                    },
                    {
                        "username": "gepo",
                        "content": "Something is going wrong.\\nLine 41: TypeError: object of type \\'int\\' has no len()"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020 \\n\\nIt is important for me to train myself to get familar with C# data structure and also think better what to choose in design process. There are more than five solutions I like to share using C# data struture: List, Stack, Queue, Dictionary (HashMap), HashSet, Tuple. \\n\\nHere are my highlights:\\n1. First and most important, it is to learn and get familiar using List<TreeNode>, and understand tree traversal, use one path as List variable to solve backtracking issue; \\n2. Next it is important to learn how to solve the algorithm using recursive function without any data structure;\\n3. Advanced topic is to try ideas using Tuple<TreeNode, int> and experience how efficient it is to design and remove ambiguity in design, follow Single Responsiblity Principle SRP. \\n4. Try other options like Stack, HashSet if you have time to practice. \\n\\n**Data structure is the tool to get organized**\\n\\nLet us get started. First one is combination of Queue, Dictionary, HashSet\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is data structure C# List<TreeNode> \\n\\n\\nC# **List** is enough to solve the problem - topics: backtracking, space optimization\\n\\n**No 2 combinations: C# Data structure: List**\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# HashSet<TreeNode>\\n\\n\\n**No 3 combinations: C# Data structure: HashSet**\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\nJune 25, 2019\\n\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Stack<TreeNode>\\n\\n\\n**Stack** is perfect to maintain the order in last in first out order. \\n\\n**No 4 combinations: C# Data structure: Stack**\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Tuple<TreeNode, int><br>\\n\\n\\n**Tuple** is so powerful and time-efficient, good at strong type definition to avoid run time errors. Give it a try! \\n\\n**No 4 combinations:  C# Data structure: Tuple**\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\nIt is time for me to learn to review my own code. Track my progress and I was so surprised to learn that I need to practice backtracking in 2019, 53 year old. \\n\\n**Extra topic: backtracking, List<TreeNode>**\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sai_manoj_kumar",
                        "content": "Input for the testcase is not being parsed correctly. Where do I report this?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "From May to July 2019\\nIt is my practice for busy season from March to May for two online code assessments and one more phone screen. One of ideas is to finish another 100 algorithm on Leetcode, and pace myself sometimes to work on one algorithm with various approaches. It is for potential phone screen, I may get invited any time. So I like to learn how to prepare more carefully through practice.\\n\\nHere are various topic I cover in my practice, and I also like to share the discussion post for each idea. Some of ideas are just to study code on existing discussion post. \\n\\nI also use the algorithm to interview people on interviewing dot io. It is important for me to learn various solutions first in order to be a good interviewer, and also learn from interview experience through a lot of interviewees. \\n\\nIf you have advice for adding more topics on this algorithm as an interviewer, please leave in the comments. I will add them one by one. \\n\\n**Topics**\\n\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[Post order traversal (May 27, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\n**Recursive function design, why mix return will lead to lowest common ancestor?**\\n[recursive function - Confused and more work later (May 8, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288320/C-Work-on-the-algorithm-in-mock-interview)\\n[recursive function - mix returns, final one is lowest common ancestor (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302311/C-recursive-function-design-step-by-step-illustration)\\n[C# post order traversal and return p or q in recursive function](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/315272/C-post-order-traversal-and-return-p-or-q-in-recursive-function) case study mock interview on June 18, 2019\\n\\n**Return type**\\n**Return bool or TreeNode?**\\n[Recursive solution Easy to understand - return bool (May 15, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n[Recursive solution Easy to understand - return TreeNode (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302301/C-recursive-function-with-return-TreeNode-Easy-to-understand)\\n\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n\\n[C# recursive function to find lowest common ancestor given p and q are in the binary tree (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301664/C-recursive-function-to-find-lowest-common-ancestor-given-p-and-q-are-in-the-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301686/C-Find-lowest-common-ancestor-given-two-nodes-p-and-q-may-not-in-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (June 14, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311875/C-Lowest-common-ancestor-given-node-p-and-q-in-binary-tree)\\n\\n**Naive solution with Timeout and Complicated function**\\n[Timeout challenge (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288284/C-time-out-need-help-using-List-preorder-traversal)\\n[Timeout challenge - using a string to store path (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288289/C-time-out-need-help-using-string-preorder-traversal)\\n[Fix naive solution timeout with complicated function (May 13, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290656/C-Fix-timeout-bug-but-still-keep-the-code-on-purpose-complicated)\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nJune 25, 2019\\nThree practice for three ideas; I like to be a master of the lowest common ancestor! I started again from May 8, 2019, met a lot of talent in Sillicon Valley, Seattle, Toronto area on *** on this algorithm.\\n\\nDare to be a master! Self-claim first!\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\nJuly 4, 2019\\nTwo node\\'s distance in binary tree, the post is [here](https://leetcode.com/discuss/interview-question/125084/Amazon-Distance-between-2-nodes). \\nMy solution is written [here](https://leetcode.com/discuss/interview-question/125084/Amazon-or-Distance-between-2-nodes/300089). The idea is to find lowest common ancestor, and then calculate the distance between two nodes indirectly both to lowest common ancestor.\\n[C# Lowest common ancestor -> two node\\'s distance practice (upward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327282/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(uperward))\\n[C# Lowest common ancestor -> two node\\'s distance practice (downward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327278/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(downward))\\n\\n**Common mistakes in mock interview**\\n\\n1. Preorder traversal vs postorder traversal, early return when p or q is found, the rest of nodes in the tree is not traversed;\\n2. Redundant code in the recursive function;\\n"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "my code is pretty much the same as everyone else's, but I changed the comparison\\nfrom\\n\\n    if (root == p || root == q) then return root;\\n\\nto \\n\\n    if (root.val == p.val || root.val == q.val) then return root;\\n\\nthen I got errors, I'm really confused, if the former conditions are satisfied, the latter must be true too."
                    },
                    {
                        "username": "user3971c",
                        "content": "[@ayushanand18](/ayushanand18) I can\\'t speak for 2015, but as of now the constraints state that All Node.val are unique. "
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@ayushanand18](/ayushanand18) are you there suggesting him right after 8 years....wonder what he is doing now."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "there might also be some nodes which have the same values but not the one we are concerned about. i.e. duplicate value nodes."
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020\\n\\nI continue to ask the algorithm question in my interviewing dot io mock interviews as an interviewer in 2020, and then I was surprised to learn more about recursive function design, strong type, backtracking, and expedite the tree problem solving process. \\n\\nTo work on my C# crafting skills, I also practice the idea after each mock interview. \\n\\nApril 19, 2020\\n[C# backtracking practice after mock interview on April 19, 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655605/C-backtracking-practice-after-mock-interview-on-April-19-2020)\\n\\nMay 1, 2020\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nStatistics:\\n1. 40 mock interviews as an interviewer, ask lowest common ancestor in binary tree algorithm in 2019;\\n2. Work on recursive function design over 10 times;\\n3. Work on backtracking practice over 10 times;\\n4. All engineers over 40 engineers in two months I met in 2019 cannot beat performance I met in 2020, an ex-facebook engineer. \\n\\n"
                    }
                ]
            },
            {
                "id": 1951292,
                "content": [
                    {
                        "username": "jack76",
                        "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS(preOrder).. Easy solution\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three parameters: `root` (the current node), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n2. Check if the current node `root` is null or if it is either `p` or `q`. If any of these conditions is true, return the current node `root` as the lowest common ancestor.\\n\\n3. Recursively call the `rec` function for the left subtree of the current node and assign the result to a variable `l`.\\n\\n4. Recursively call the `rec` function for the right subtree of the current node and assign the result to a variable `r`.\\n\\n5. Check if both `l` and `r` are not null. If so, it means that `p` and `q` are found on different subtrees of the current node, and the current node `root` is their lowest common ancestor. Return the current node `root`.\\n\\n6. If `l` is null, it means that both `p` and `q` are on the right subtree (or not present in the tree). Return `r`.\\n\\n7. If none of the above conditions are met, it means that both `p` and `q` are on the left subtree (or not present in the tree). Return `l`.\\n\\n8. Define a function `lowestCommonAncestor` that takes three parameters: `root` (the root node of the tree), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n9. Return the result of calling the `rec` function with the parameters `root`, `p`, and `q`. This will find and return the lowest common ancestor of nodes `p` and `q` in the given binary tree.\\n\\n-------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n). All node have to visit in worst case.\\n\\n- Space complexity:\\nS.C=O(n) in worst case skewed tree. recursive stack take O(n).\\n--------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3702977/c-dfs-preorder-easy-solution/"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "Update: The bug is already fixed! Thanks LC\\n\\nIt may be due to how OJ parses the test case: every time I tried to run the testcase, it spat `5 is not a valid value of type TreeNode`. \\nI also tried to enclose 5 and 1 in `[]`but no lucky there.\\nCould someone fix this, or let me know if there is a temporary fix on my end, thanks!"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "When I checked some others solutions committed and passed, I found that, they all miss the checking step,which means we need to check if there are both p and q in this tree.\\n\\nfor example,there is a question name called Share C++/C# 24ms recursive solution , the solution it shows doesn't check wether TreeNode p and TreeNode q exist when it returns.\\n\\nSo what do you guys think??"
                    },
                    {
                        "username": "GUTTTS",
                        "content": "[@mochiball](/mochiball) bro he wrote that in 2015 maybe that time there wasnt anything mentioned in the constraints\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Please read the question constraints. It tells you that p and q are in the tree. No need to check if they exist "
                    },
                    {
                        "username": "harsha335",
                        "content": "in constraints they mentioned both p and q will be present in tree and they are unique and not equal."
                    },
                    {
                        "username": "gepo",
                        "content": "Something is going wrong.\\nLine 41: TypeError: object of type \\'int\\' has no len()"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020 \\n\\nIt is important for me to train myself to get familar with C# data structure and also think better what to choose in design process. There are more than five solutions I like to share using C# data struture: List, Stack, Queue, Dictionary (HashMap), HashSet, Tuple. \\n\\nHere are my highlights:\\n1. First and most important, it is to learn and get familiar using List<TreeNode>, and understand tree traversal, use one path as List variable to solve backtracking issue; \\n2. Next it is important to learn how to solve the algorithm using recursive function without any data structure;\\n3. Advanced topic is to try ideas using Tuple<TreeNode, int> and experience how efficient it is to design and remove ambiguity in design, follow Single Responsiblity Principle SRP. \\n4. Try other options like Stack, HashSet if you have time to practice. \\n\\n**Data structure is the tool to get organized**\\n\\nLet us get started. First one is combination of Queue, Dictionary, HashSet\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is data structure C# List<TreeNode> \\n\\n\\nC# **List** is enough to solve the problem - topics: backtracking, space optimization\\n\\n**No 2 combinations: C# Data structure: List**\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# HashSet<TreeNode>\\n\\n\\n**No 3 combinations: C# Data structure: HashSet**\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\nJune 25, 2019\\n\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Stack<TreeNode>\\n\\n\\n**Stack** is perfect to maintain the order in last in first out order. \\n\\n**No 4 combinations: C# Data structure: Stack**\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Tuple<TreeNode, int><br>\\n\\n\\n**Tuple** is so powerful and time-efficient, good at strong type definition to avoid run time errors. Give it a try! \\n\\n**No 4 combinations:  C# Data structure: Tuple**\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\nIt is time for me to learn to review my own code. Track my progress and I was so surprised to learn that I need to practice backtracking in 2019, 53 year old. \\n\\n**Extra topic: backtracking, List<TreeNode>**\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sai_manoj_kumar",
                        "content": "Input for the testcase is not being parsed correctly. Where do I report this?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "From May to July 2019\\nIt is my practice for busy season from March to May for two online code assessments and one more phone screen. One of ideas is to finish another 100 algorithm on Leetcode, and pace myself sometimes to work on one algorithm with various approaches. It is for potential phone screen, I may get invited any time. So I like to learn how to prepare more carefully through practice.\\n\\nHere are various topic I cover in my practice, and I also like to share the discussion post for each idea. Some of ideas are just to study code on existing discussion post. \\n\\nI also use the algorithm to interview people on interviewing dot io. It is important for me to learn various solutions first in order to be a good interviewer, and also learn from interview experience through a lot of interviewees. \\n\\nIf you have advice for adding more topics on this algorithm as an interviewer, please leave in the comments. I will add them one by one. \\n\\n**Topics**\\n\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[Post order traversal (May 27, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\n**Recursive function design, why mix return will lead to lowest common ancestor?**\\n[recursive function - Confused and more work later (May 8, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288320/C-Work-on-the-algorithm-in-mock-interview)\\n[recursive function - mix returns, final one is lowest common ancestor (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302311/C-recursive-function-design-step-by-step-illustration)\\n[C# post order traversal and return p or q in recursive function](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/315272/C-post-order-traversal-and-return-p-or-q-in-recursive-function) case study mock interview on June 18, 2019\\n\\n**Return type**\\n**Return bool or TreeNode?**\\n[Recursive solution Easy to understand - return bool (May 15, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n[Recursive solution Easy to understand - return TreeNode (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302301/C-recursive-function-with-return-TreeNode-Easy-to-understand)\\n\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n\\n[C# recursive function to find lowest common ancestor given p and q are in the binary tree (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301664/C-recursive-function-to-find-lowest-common-ancestor-given-p-and-q-are-in-the-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301686/C-Find-lowest-common-ancestor-given-two-nodes-p-and-q-may-not-in-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (June 14, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311875/C-Lowest-common-ancestor-given-node-p-and-q-in-binary-tree)\\n\\n**Naive solution with Timeout and Complicated function**\\n[Timeout challenge (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288284/C-time-out-need-help-using-List-preorder-traversal)\\n[Timeout challenge - using a string to store path (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288289/C-time-out-need-help-using-string-preorder-traversal)\\n[Fix naive solution timeout with complicated function (May 13, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290656/C-Fix-timeout-bug-but-still-keep-the-code-on-purpose-complicated)\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nJune 25, 2019\\nThree practice for three ideas; I like to be a master of the lowest common ancestor! I started again from May 8, 2019, met a lot of talent in Sillicon Valley, Seattle, Toronto area on *** on this algorithm.\\n\\nDare to be a master! Self-claim first!\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\nJuly 4, 2019\\nTwo node\\'s distance in binary tree, the post is [here](https://leetcode.com/discuss/interview-question/125084/Amazon-Distance-between-2-nodes). \\nMy solution is written [here](https://leetcode.com/discuss/interview-question/125084/Amazon-or-Distance-between-2-nodes/300089). The idea is to find lowest common ancestor, and then calculate the distance between two nodes indirectly both to lowest common ancestor.\\n[C# Lowest common ancestor -> two node\\'s distance practice (upward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327282/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(uperward))\\n[C# Lowest common ancestor -> two node\\'s distance practice (downward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327278/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(downward))\\n\\n**Common mistakes in mock interview**\\n\\n1. Preorder traversal vs postorder traversal, early return when p or q is found, the rest of nodes in the tree is not traversed;\\n2. Redundant code in the recursive function;\\n"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "my code is pretty much the same as everyone else's, but I changed the comparison\\nfrom\\n\\n    if (root == p || root == q) then return root;\\n\\nto \\n\\n    if (root.val == p.val || root.val == q.val) then return root;\\n\\nthen I got errors, I'm really confused, if the former conditions are satisfied, the latter must be true too."
                    },
                    {
                        "username": "user3971c",
                        "content": "[@ayushanand18](/ayushanand18) I can\\'t speak for 2015, but as of now the constraints state that All Node.val are unique. "
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@ayushanand18](/ayushanand18) are you there suggesting him right after 8 years....wonder what he is doing now."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "there might also be some nodes which have the same values but not the one we are concerned about. i.e. duplicate value nodes."
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020\\n\\nI continue to ask the algorithm question in my interviewing dot io mock interviews as an interviewer in 2020, and then I was surprised to learn more about recursive function design, strong type, backtracking, and expedite the tree problem solving process. \\n\\nTo work on my C# crafting skills, I also practice the idea after each mock interview. \\n\\nApril 19, 2020\\n[C# backtracking practice after mock interview on April 19, 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655605/C-backtracking-practice-after-mock-interview-on-April-19-2020)\\n\\nMay 1, 2020\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nStatistics:\\n1. 40 mock interviews as an interviewer, ask lowest common ancestor in binary tree algorithm in 2019;\\n2. Work on recursive function design over 10 times;\\n3. Work on backtracking practice over 10 times;\\n4. All engineers over 40 engineers in two months I met in 2019 cannot beat performance I met in 2020, an ex-facebook engineer. \\n\\n"
                    }
                ]
            },
            {
                "id": 1566904,
                "content": [
                    {
                        "username": "jack76",
                        "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS(preOrder).. Easy solution\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three parameters: `root` (the current node), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n2. Check if the current node `root` is null or if it is either `p` or `q`. If any of these conditions is true, return the current node `root` as the lowest common ancestor.\\n\\n3. Recursively call the `rec` function for the left subtree of the current node and assign the result to a variable `l`.\\n\\n4. Recursively call the `rec` function for the right subtree of the current node and assign the result to a variable `r`.\\n\\n5. Check if both `l` and `r` are not null. If so, it means that `p` and `q` are found on different subtrees of the current node, and the current node `root` is their lowest common ancestor. Return the current node `root`.\\n\\n6. If `l` is null, it means that both `p` and `q` are on the right subtree (or not present in the tree). Return `r`.\\n\\n7. If none of the above conditions are met, it means that both `p` and `q` are on the left subtree (or not present in the tree). Return `l`.\\n\\n8. Define a function `lowestCommonAncestor` that takes three parameters: `root` (the root node of the tree), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n9. Return the result of calling the `rec` function with the parameters `root`, `p`, and `q`. This will find and return the lowest common ancestor of nodes `p` and `q` in the given binary tree.\\n\\n-------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n). All node have to visit in worst case.\\n\\n- Space complexity:\\nS.C=O(n) in worst case skewed tree. recursive stack take O(n).\\n--------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3702977/c-dfs-preorder-easy-solution/"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "Update: The bug is already fixed! Thanks LC\\n\\nIt may be due to how OJ parses the test case: every time I tried to run the testcase, it spat `5 is not a valid value of type TreeNode`. \\nI also tried to enclose 5 and 1 in `[]`but no lucky there.\\nCould someone fix this, or let me know if there is a temporary fix on my end, thanks!"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "When I checked some others solutions committed and passed, I found that, they all miss the checking step,which means we need to check if there are both p and q in this tree.\\n\\nfor example,there is a question name called Share C++/C# 24ms recursive solution , the solution it shows doesn't check wether TreeNode p and TreeNode q exist when it returns.\\n\\nSo what do you guys think??"
                    },
                    {
                        "username": "GUTTTS",
                        "content": "[@mochiball](/mochiball) bro he wrote that in 2015 maybe that time there wasnt anything mentioned in the constraints\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Please read the question constraints. It tells you that p and q are in the tree. No need to check if they exist "
                    },
                    {
                        "username": "harsha335",
                        "content": "in constraints they mentioned both p and q will be present in tree and they are unique and not equal."
                    },
                    {
                        "username": "gepo",
                        "content": "Something is going wrong.\\nLine 41: TypeError: object of type \\'int\\' has no len()"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020 \\n\\nIt is important for me to train myself to get familar with C# data structure and also think better what to choose in design process. There are more than five solutions I like to share using C# data struture: List, Stack, Queue, Dictionary (HashMap), HashSet, Tuple. \\n\\nHere are my highlights:\\n1. First and most important, it is to learn and get familiar using List<TreeNode>, and understand tree traversal, use one path as List variable to solve backtracking issue; \\n2. Next it is important to learn how to solve the algorithm using recursive function without any data structure;\\n3. Advanced topic is to try ideas using Tuple<TreeNode, int> and experience how efficient it is to design and remove ambiguity in design, follow Single Responsiblity Principle SRP. \\n4. Try other options like Stack, HashSet if you have time to practice. \\n\\n**Data structure is the tool to get organized**\\n\\nLet us get started. First one is combination of Queue, Dictionary, HashSet\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is data structure C# List<TreeNode> \\n\\n\\nC# **List** is enough to solve the problem - topics: backtracking, space optimization\\n\\n**No 2 combinations: C# Data structure: List**\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# HashSet<TreeNode>\\n\\n\\n**No 3 combinations: C# Data structure: HashSet**\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\nJune 25, 2019\\n\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Stack<TreeNode>\\n\\n\\n**Stack** is perfect to maintain the order in last in first out order. \\n\\n**No 4 combinations: C# Data structure: Stack**\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Tuple<TreeNode, int><br>\\n\\n\\n**Tuple** is so powerful and time-efficient, good at strong type definition to avoid run time errors. Give it a try! \\n\\n**No 4 combinations:  C# Data structure: Tuple**\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\nIt is time for me to learn to review my own code. Track my progress and I was so surprised to learn that I need to practice backtracking in 2019, 53 year old. \\n\\n**Extra topic: backtracking, List<TreeNode>**\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sai_manoj_kumar",
                        "content": "Input for the testcase is not being parsed correctly. Where do I report this?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "From May to July 2019\\nIt is my practice for busy season from March to May for two online code assessments and one more phone screen. One of ideas is to finish another 100 algorithm on Leetcode, and pace myself sometimes to work on one algorithm with various approaches. It is for potential phone screen, I may get invited any time. So I like to learn how to prepare more carefully through practice.\\n\\nHere are various topic I cover in my practice, and I also like to share the discussion post for each idea. Some of ideas are just to study code on existing discussion post. \\n\\nI also use the algorithm to interview people on interviewing dot io. It is important for me to learn various solutions first in order to be a good interviewer, and also learn from interview experience through a lot of interviewees. \\n\\nIf you have advice for adding more topics on this algorithm as an interviewer, please leave in the comments. I will add them one by one. \\n\\n**Topics**\\n\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[Post order traversal (May 27, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\n**Recursive function design, why mix return will lead to lowest common ancestor?**\\n[recursive function - Confused and more work later (May 8, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288320/C-Work-on-the-algorithm-in-mock-interview)\\n[recursive function - mix returns, final one is lowest common ancestor (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302311/C-recursive-function-design-step-by-step-illustration)\\n[C# post order traversal and return p or q in recursive function](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/315272/C-post-order-traversal-and-return-p-or-q-in-recursive-function) case study mock interview on June 18, 2019\\n\\n**Return type**\\n**Return bool or TreeNode?**\\n[Recursive solution Easy to understand - return bool (May 15, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n[Recursive solution Easy to understand - return TreeNode (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302301/C-recursive-function-with-return-TreeNode-Easy-to-understand)\\n\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n\\n[C# recursive function to find lowest common ancestor given p and q are in the binary tree (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301664/C-recursive-function-to-find-lowest-common-ancestor-given-p-and-q-are-in-the-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301686/C-Find-lowest-common-ancestor-given-two-nodes-p-and-q-may-not-in-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (June 14, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311875/C-Lowest-common-ancestor-given-node-p-and-q-in-binary-tree)\\n\\n**Naive solution with Timeout and Complicated function**\\n[Timeout challenge (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288284/C-time-out-need-help-using-List-preorder-traversal)\\n[Timeout challenge - using a string to store path (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288289/C-time-out-need-help-using-string-preorder-traversal)\\n[Fix naive solution timeout with complicated function (May 13, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290656/C-Fix-timeout-bug-but-still-keep-the-code-on-purpose-complicated)\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nJune 25, 2019\\nThree practice for three ideas; I like to be a master of the lowest common ancestor! I started again from May 8, 2019, met a lot of talent in Sillicon Valley, Seattle, Toronto area on *** on this algorithm.\\n\\nDare to be a master! Self-claim first!\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\nJuly 4, 2019\\nTwo node\\'s distance in binary tree, the post is [here](https://leetcode.com/discuss/interview-question/125084/Amazon-Distance-between-2-nodes). \\nMy solution is written [here](https://leetcode.com/discuss/interview-question/125084/Amazon-or-Distance-between-2-nodes/300089). The idea is to find lowest common ancestor, and then calculate the distance between two nodes indirectly both to lowest common ancestor.\\n[C# Lowest common ancestor -> two node\\'s distance practice (upward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327282/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(uperward))\\n[C# Lowest common ancestor -> two node\\'s distance practice (downward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327278/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(downward))\\n\\n**Common mistakes in mock interview**\\n\\n1. Preorder traversal vs postorder traversal, early return when p or q is found, the rest of nodes in the tree is not traversed;\\n2. Redundant code in the recursive function;\\n"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "my code is pretty much the same as everyone else's, but I changed the comparison\\nfrom\\n\\n    if (root == p || root == q) then return root;\\n\\nto \\n\\n    if (root.val == p.val || root.val == q.val) then return root;\\n\\nthen I got errors, I'm really confused, if the former conditions are satisfied, the latter must be true too."
                    },
                    {
                        "username": "user3971c",
                        "content": "[@ayushanand18](/ayushanand18) I can\\'t speak for 2015, but as of now the constraints state that All Node.val are unique. "
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@ayushanand18](/ayushanand18) are you there suggesting him right after 8 years....wonder what he is doing now."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "there might also be some nodes which have the same values but not the one we are concerned about. i.e. duplicate value nodes."
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020\\n\\nI continue to ask the algorithm question in my interviewing dot io mock interviews as an interviewer in 2020, and then I was surprised to learn more about recursive function design, strong type, backtracking, and expedite the tree problem solving process. \\n\\nTo work on my C# crafting skills, I also practice the idea after each mock interview. \\n\\nApril 19, 2020\\n[C# backtracking practice after mock interview on April 19, 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655605/C-backtracking-practice-after-mock-interview-on-April-19-2020)\\n\\nMay 1, 2020\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nStatistics:\\n1. 40 mock interviews as an interviewer, ask lowest common ancestor in binary tree algorithm in 2019;\\n2. Work on recursive function design over 10 times;\\n3. Work on backtracking practice over 10 times;\\n4. All engineers over 40 engineers in two months I met in 2019 cannot beat performance I met in 2020, an ex-facebook engineer. \\n\\n"
                    }
                ]
            },
            {
                "id": 1567232,
                "content": [
                    {
                        "username": "jack76",
                        "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS(preOrder).. Easy solution\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three parameters: `root` (the current node), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n2. Check if the current node `root` is null or if it is either `p` or `q`. If any of these conditions is true, return the current node `root` as the lowest common ancestor.\\n\\n3. Recursively call the `rec` function for the left subtree of the current node and assign the result to a variable `l`.\\n\\n4. Recursively call the `rec` function for the right subtree of the current node and assign the result to a variable `r`.\\n\\n5. Check if both `l` and `r` are not null. If so, it means that `p` and `q` are found on different subtrees of the current node, and the current node `root` is their lowest common ancestor. Return the current node `root`.\\n\\n6. If `l` is null, it means that both `p` and `q` are on the right subtree (or not present in the tree). Return `r`.\\n\\n7. If none of the above conditions are met, it means that both `p` and `q` are on the left subtree (or not present in the tree). Return `l`.\\n\\n8. Define a function `lowestCommonAncestor` that takes three parameters: `root` (the root node of the tree), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n9. Return the result of calling the `rec` function with the parameters `root`, `p`, and `q`. This will find and return the lowest common ancestor of nodes `p` and `q` in the given binary tree.\\n\\n-------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n). All node have to visit in worst case.\\n\\n- Space complexity:\\nS.C=O(n) in worst case skewed tree. recursive stack take O(n).\\n--------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3702977/c-dfs-preorder-easy-solution/"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "Update: The bug is already fixed! Thanks LC\\n\\nIt may be due to how OJ parses the test case: every time I tried to run the testcase, it spat `5 is not a valid value of type TreeNode`. \\nI also tried to enclose 5 and 1 in `[]`but no lucky there.\\nCould someone fix this, or let me know if there is a temporary fix on my end, thanks!"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "When I checked some others solutions committed and passed, I found that, they all miss the checking step,which means we need to check if there are both p and q in this tree.\\n\\nfor example,there is a question name called Share C++/C# 24ms recursive solution , the solution it shows doesn't check wether TreeNode p and TreeNode q exist when it returns.\\n\\nSo what do you guys think??"
                    },
                    {
                        "username": "GUTTTS",
                        "content": "[@mochiball](/mochiball) bro he wrote that in 2015 maybe that time there wasnt anything mentioned in the constraints\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Please read the question constraints. It tells you that p and q are in the tree. No need to check if they exist "
                    },
                    {
                        "username": "harsha335",
                        "content": "in constraints they mentioned both p and q will be present in tree and they are unique and not equal."
                    },
                    {
                        "username": "gepo",
                        "content": "Something is going wrong.\\nLine 41: TypeError: object of type \\'int\\' has no len()"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020 \\n\\nIt is important for me to train myself to get familar with C# data structure and also think better what to choose in design process. There are more than five solutions I like to share using C# data struture: List, Stack, Queue, Dictionary (HashMap), HashSet, Tuple. \\n\\nHere are my highlights:\\n1. First and most important, it is to learn and get familiar using List<TreeNode>, and understand tree traversal, use one path as List variable to solve backtracking issue; \\n2. Next it is important to learn how to solve the algorithm using recursive function without any data structure;\\n3. Advanced topic is to try ideas using Tuple<TreeNode, int> and experience how efficient it is to design and remove ambiguity in design, follow Single Responsiblity Principle SRP. \\n4. Try other options like Stack, HashSet if you have time to practice. \\n\\n**Data structure is the tool to get organized**\\n\\nLet us get started. First one is combination of Queue, Dictionary, HashSet\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is data structure C# List<TreeNode> \\n\\n\\nC# **List** is enough to solve the problem - topics: backtracking, space optimization\\n\\n**No 2 combinations: C# Data structure: List**\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# HashSet<TreeNode>\\n\\n\\n**No 3 combinations: C# Data structure: HashSet**\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\nJune 25, 2019\\n\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Stack<TreeNode>\\n\\n\\n**Stack** is perfect to maintain the order in last in first out order. \\n\\n**No 4 combinations: C# Data structure: Stack**\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Tuple<TreeNode, int><br>\\n\\n\\n**Tuple** is so powerful and time-efficient, good at strong type definition to avoid run time errors. Give it a try! \\n\\n**No 4 combinations:  C# Data structure: Tuple**\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\nIt is time for me to learn to review my own code. Track my progress and I was so surprised to learn that I need to practice backtracking in 2019, 53 year old. \\n\\n**Extra topic: backtracking, List<TreeNode>**\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sai_manoj_kumar",
                        "content": "Input for the testcase is not being parsed correctly. Where do I report this?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "From May to July 2019\\nIt is my practice for busy season from March to May for two online code assessments and one more phone screen. One of ideas is to finish another 100 algorithm on Leetcode, and pace myself sometimes to work on one algorithm with various approaches. It is for potential phone screen, I may get invited any time. So I like to learn how to prepare more carefully through practice.\\n\\nHere are various topic I cover in my practice, and I also like to share the discussion post for each idea. Some of ideas are just to study code on existing discussion post. \\n\\nI also use the algorithm to interview people on interviewing dot io. It is important for me to learn various solutions first in order to be a good interviewer, and also learn from interview experience through a lot of interviewees. \\n\\nIf you have advice for adding more topics on this algorithm as an interviewer, please leave in the comments. I will add them one by one. \\n\\n**Topics**\\n\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[Post order traversal (May 27, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\n**Recursive function design, why mix return will lead to lowest common ancestor?**\\n[recursive function - Confused and more work later (May 8, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288320/C-Work-on-the-algorithm-in-mock-interview)\\n[recursive function - mix returns, final one is lowest common ancestor (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302311/C-recursive-function-design-step-by-step-illustration)\\n[C# post order traversal and return p or q in recursive function](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/315272/C-post-order-traversal-and-return-p-or-q-in-recursive-function) case study mock interview on June 18, 2019\\n\\n**Return type**\\n**Return bool or TreeNode?**\\n[Recursive solution Easy to understand - return bool (May 15, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n[Recursive solution Easy to understand - return TreeNode (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302301/C-recursive-function-with-return-TreeNode-Easy-to-understand)\\n\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n\\n[C# recursive function to find lowest common ancestor given p and q are in the binary tree (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301664/C-recursive-function-to-find-lowest-common-ancestor-given-p-and-q-are-in-the-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301686/C-Find-lowest-common-ancestor-given-two-nodes-p-and-q-may-not-in-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (June 14, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311875/C-Lowest-common-ancestor-given-node-p-and-q-in-binary-tree)\\n\\n**Naive solution with Timeout and Complicated function**\\n[Timeout challenge (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288284/C-time-out-need-help-using-List-preorder-traversal)\\n[Timeout challenge - using a string to store path (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288289/C-time-out-need-help-using-string-preorder-traversal)\\n[Fix naive solution timeout with complicated function (May 13, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290656/C-Fix-timeout-bug-but-still-keep-the-code-on-purpose-complicated)\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nJune 25, 2019\\nThree practice for three ideas; I like to be a master of the lowest common ancestor! I started again from May 8, 2019, met a lot of talent in Sillicon Valley, Seattle, Toronto area on *** on this algorithm.\\n\\nDare to be a master! Self-claim first!\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\nJuly 4, 2019\\nTwo node\\'s distance in binary tree, the post is [here](https://leetcode.com/discuss/interview-question/125084/Amazon-Distance-between-2-nodes). \\nMy solution is written [here](https://leetcode.com/discuss/interview-question/125084/Amazon-or-Distance-between-2-nodes/300089). The idea is to find lowest common ancestor, and then calculate the distance between two nodes indirectly both to lowest common ancestor.\\n[C# Lowest common ancestor -> two node\\'s distance practice (upward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327282/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(uperward))\\n[C# Lowest common ancestor -> two node\\'s distance practice (downward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327278/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(downward))\\n\\n**Common mistakes in mock interview**\\n\\n1. Preorder traversal vs postorder traversal, early return when p or q is found, the rest of nodes in the tree is not traversed;\\n2. Redundant code in the recursive function;\\n"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "my code is pretty much the same as everyone else's, but I changed the comparison\\nfrom\\n\\n    if (root == p || root == q) then return root;\\n\\nto \\n\\n    if (root.val == p.val || root.val == q.val) then return root;\\n\\nthen I got errors, I'm really confused, if the former conditions are satisfied, the latter must be true too."
                    },
                    {
                        "username": "user3971c",
                        "content": "[@ayushanand18](/ayushanand18) I can\\'t speak for 2015, but as of now the constraints state that All Node.val are unique. "
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@ayushanand18](/ayushanand18) are you there suggesting him right after 8 years....wonder what he is doing now."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "there might also be some nodes which have the same values but not the one we are concerned about. i.e. duplicate value nodes."
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020\\n\\nI continue to ask the algorithm question in my interviewing dot io mock interviews as an interviewer in 2020, and then I was surprised to learn more about recursive function design, strong type, backtracking, and expedite the tree problem solving process. \\n\\nTo work on my C# crafting skills, I also practice the idea after each mock interview. \\n\\nApril 19, 2020\\n[C# backtracking practice after mock interview on April 19, 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655605/C-backtracking-practice-after-mock-interview-on-April-19-2020)\\n\\nMay 1, 2020\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nStatistics:\\n1. 40 mock interviews as an interviewer, ask lowest common ancestor in binary tree algorithm in 2019;\\n2. Work on recursive function design over 10 times;\\n3. Work on backtracking practice over 10 times;\\n4. All engineers over 40 engineers in two months I met in 2019 cannot beat performance I met in 2020, an ex-facebook engineer. \\n\\n"
                    }
                ]
            },
            {
                "id": 1566119,
                "content": [
                    {
                        "username": "jack76",
                        "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS(preOrder).. Easy solution\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three parameters: `root` (the current node), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n2. Check if the current node `root` is null or if it is either `p` or `q`. If any of these conditions is true, return the current node `root` as the lowest common ancestor.\\n\\n3. Recursively call the `rec` function for the left subtree of the current node and assign the result to a variable `l`.\\n\\n4. Recursively call the `rec` function for the right subtree of the current node and assign the result to a variable `r`.\\n\\n5. Check if both `l` and `r` are not null. If so, it means that `p` and `q` are found on different subtrees of the current node, and the current node `root` is their lowest common ancestor. Return the current node `root`.\\n\\n6. If `l` is null, it means that both `p` and `q` are on the right subtree (or not present in the tree). Return `r`.\\n\\n7. If none of the above conditions are met, it means that both `p` and `q` are on the left subtree (or not present in the tree). Return `l`.\\n\\n8. Define a function `lowestCommonAncestor` that takes three parameters: `root` (the root node of the tree), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n9. Return the result of calling the `rec` function with the parameters `root`, `p`, and `q`. This will find and return the lowest common ancestor of nodes `p` and `q` in the given binary tree.\\n\\n-------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n). All node have to visit in worst case.\\n\\n- Space complexity:\\nS.C=O(n) in worst case skewed tree. recursive stack take O(n).\\n--------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3702977/c-dfs-preorder-easy-solution/"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "Update: The bug is already fixed! Thanks LC\\n\\nIt may be due to how OJ parses the test case: every time I tried to run the testcase, it spat `5 is not a valid value of type TreeNode`. \\nI also tried to enclose 5 and 1 in `[]`but no lucky there.\\nCould someone fix this, or let me know if there is a temporary fix on my end, thanks!"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "When I checked some others solutions committed and passed, I found that, they all miss the checking step,which means we need to check if there are both p and q in this tree.\\n\\nfor example,there is a question name called Share C++/C# 24ms recursive solution , the solution it shows doesn't check wether TreeNode p and TreeNode q exist when it returns.\\n\\nSo what do you guys think??"
                    },
                    {
                        "username": "GUTTTS",
                        "content": "[@mochiball](/mochiball) bro he wrote that in 2015 maybe that time there wasnt anything mentioned in the constraints\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Please read the question constraints. It tells you that p and q are in the tree. No need to check if they exist "
                    },
                    {
                        "username": "harsha335",
                        "content": "in constraints they mentioned both p and q will be present in tree and they are unique and not equal."
                    },
                    {
                        "username": "gepo",
                        "content": "Something is going wrong.\\nLine 41: TypeError: object of type \\'int\\' has no len()"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020 \\n\\nIt is important for me to train myself to get familar with C# data structure and also think better what to choose in design process. There are more than five solutions I like to share using C# data struture: List, Stack, Queue, Dictionary (HashMap), HashSet, Tuple. \\n\\nHere are my highlights:\\n1. First and most important, it is to learn and get familiar using List<TreeNode>, and understand tree traversal, use one path as List variable to solve backtracking issue; \\n2. Next it is important to learn how to solve the algorithm using recursive function without any data structure;\\n3. Advanced topic is to try ideas using Tuple<TreeNode, int> and experience how efficient it is to design and remove ambiguity in design, follow Single Responsiblity Principle SRP. \\n4. Try other options like Stack, HashSet if you have time to practice. \\n\\n**Data structure is the tool to get organized**\\n\\nLet us get started. First one is combination of Queue, Dictionary, HashSet\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is data structure C# List<TreeNode> \\n\\n\\nC# **List** is enough to solve the problem - topics: backtracking, space optimization\\n\\n**No 2 combinations: C# Data structure: List**\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# HashSet<TreeNode>\\n\\n\\n**No 3 combinations: C# Data structure: HashSet**\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\nJune 25, 2019\\n\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Stack<TreeNode>\\n\\n\\n**Stack** is perfect to maintain the order in last in first out order. \\n\\n**No 4 combinations: C# Data structure: Stack**\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Tuple<TreeNode, int><br>\\n\\n\\n**Tuple** is so powerful and time-efficient, good at strong type definition to avoid run time errors. Give it a try! \\n\\n**No 4 combinations:  C# Data structure: Tuple**\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\nIt is time for me to learn to review my own code. Track my progress and I was so surprised to learn that I need to practice backtracking in 2019, 53 year old. \\n\\n**Extra topic: backtracking, List<TreeNode>**\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sai_manoj_kumar",
                        "content": "Input for the testcase is not being parsed correctly. Where do I report this?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "From May to July 2019\\nIt is my practice for busy season from March to May for two online code assessments and one more phone screen. One of ideas is to finish another 100 algorithm on Leetcode, and pace myself sometimes to work on one algorithm with various approaches. It is for potential phone screen, I may get invited any time. So I like to learn how to prepare more carefully through practice.\\n\\nHere are various topic I cover in my practice, and I also like to share the discussion post for each idea. Some of ideas are just to study code on existing discussion post. \\n\\nI also use the algorithm to interview people on interviewing dot io. It is important for me to learn various solutions first in order to be a good interviewer, and also learn from interview experience through a lot of interviewees. \\n\\nIf you have advice for adding more topics on this algorithm as an interviewer, please leave in the comments. I will add them one by one. \\n\\n**Topics**\\n\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[Post order traversal (May 27, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\n**Recursive function design, why mix return will lead to lowest common ancestor?**\\n[recursive function - Confused and more work later (May 8, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288320/C-Work-on-the-algorithm-in-mock-interview)\\n[recursive function - mix returns, final one is lowest common ancestor (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302311/C-recursive-function-design-step-by-step-illustration)\\n[C# post order traversal and return p or q in recursive function](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/315272/C-post-order-traversal-and-return-p-or-q-in-recursive-function) case study mock interview on June 18, 2019\\n\\n**Return type**\\n**Return bool or TreeNode?**\\n[Recursive solution Easy to understand - return bool (May 15, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n[Recursive solution Easy to understand - return TreeNode (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302301/C-recursive-function-with-return-TreeNode-Easy-to-understand)\\n\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n\\n[C# recursive function to find lowest common ancestor given p and q are in the binary tree (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301664/C-recursive-function-to-find-lowest-common-ancestor-given-p-and-q-are-in-the-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301686/C-Find-lowest-common-ancestor-given-two-nodes-p-and-q-may-not-in-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (June 14, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311875/C-Lowest-common-ancestor-given-node-p-and-q-in-binary-tree)\\n\\n**Naive solution with Timeout and Complicated function**\\n[Timeout challenge (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288284/C-time-out-need-help-using-List-preorder-traversal)\\n[Timeout challenge - using a string to store path (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288289/C-time-out-need-help-using-string-preorder-traversal)\\n[Fix naive solution timeout with complicated function (May 13, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290656/C-Fix-timeout-bug-but-still-keep-the-code-on-purpose-complicated)\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nJune 25, 2019\\nThree practice for three ideas; I like to be a master of the lowest common ancestor! I started again from May 8, 2019, met a lot of talent in Sillicon Valley, Seattle, Toronto area on *** on this algorithm.\\n\\nDare to be a master! Self-claim first!\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\nJuly 4, 2019\\nTwo node\\'s distance in binary tree, the post is [here](https://leetcode.com/discuss/interview-question/125084/Amazon-Distance-between-2-nodes). \\nMy solution is written [here](https://leetcode.com/discuss/interview-question/125084/Amazon-or-Distance-between-2-nodes/300089). The idea is to find lowest common ancestor, and then calculate the distance between two nodes indirectly both to lowest common ancestor.\\n[C# Lowest common ancestor -> two node\\'s distance practice (upward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327282/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(uperward))\\n[C# Lowest common ancestor -> two node\\'s distance practice (downward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327278/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(downward))\\n\\n**Common mistakes in mock interview**\\n\\n1. Preorder traversal vs postorder traversal, early return when p or q is found, the rest of nodes in the tree is not traversed;\\n2. Redundant code in the recursive function;\\n"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "my code is pretty much the same as everyone else's, but I changed the comparison\\nfrom\\n\\n    if (root == p || root == q) then return root;\\n\\nto \\n\\n    if (root.val == p.val || root.val == q.val) then return root;\\n\\nthen I got errors, I'm really confused, if the former conditions are satisfied, the latter must be true too."
                    },
                    {
                        "username": "user3971c",
                        "content": "[@ayushanand18](/ayushanand18) I can\\'t speak for 2015, but as of now the constraints state that All Node.val are unique. "
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@ayushanand18](/ayushanand18) are you there suggesting him right after 8 years....wonder what he is doing now."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "there might also be some nodes which have the same values but not the one we are concerned about. i.e. duplicate value nodes."
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020\\n\\nI continue to ask the algorithm question in my interviewing dot io mock interviews as an interviewer in 2020, and then I was surprised to learn more about recursive function design, strong type, backtracking, and expedite the tree problem solving process. \\n\\nTo work on my C# crafting skills, I also practice the idea after each mock interview. \\n\\nApril 19, 2020\\n[C# backtracking practice after mock interview on April 19, 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655605/C-backtracking-practice-after-mock-interview-on-April-19-2020)\\n\\nMay 1, 2020\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nStatistics:\\n1. 40 mock interviews as an interviewer, ask lowest common ancestor in binary tree algorithm in 2019;\\n2. Work on recursive function design over 10 times;\\n3. Work on backtracking practice over 10 times;\\n4. All engineers over 40 engineers in two months I met in 2019 cannot beat performance I met in 2020, an ex-facebook engineer. \\n\\n"
                    }
                ]
            },
            {
                "id": 1568338,
                "content": [
                    {
                        "username": "jack76",
                        "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS(preOrder).. Easy solution\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three parameters: `root` (the current node), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n2. Check if the current node `root` is null or if it is either `p` or `q`. If any of these conditions is true, return the current node `root` as the lowest common ancestor.\\n\\n3. Recursively call the `rec` function for the left subtree of the current node and assign the result to a variable `l`.\\n\\n4. Recursively call the `rec` function for the right subtree of the current node and assign the result to a variable `r`.\\n\\n5. Check if both `l` and `r` are not null. If so, it means that `p` and `q` are found on different subtrees of the current node, and the current node `root` is their lowest common ancestor. Return the current node `root`.\\n\\n6. If `l` is null, it means that both `p` and `q` are on the right subtree (or not present in the tree). Return `r`.\\n\\n7. If none of the above conditions are met, it means that both `p` and `q` are on the left subtree (or not present in the tree). Return `l`.\\n\\n8. Define a function `lowestCommonAncestor` that takes three parameters: `root` (the root node of the tree), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n9. Return the result of calling the `rec` function with the parameters `root`, `p`, and `q`. This will find and return the lowest common ancestor of nodes `p` and `q` in the given binary tree.\\n\\n-------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n). All node have to visit in worst case.\\n\\n- Space complexity:\\nS.C=O(n) in worst case skewed tree. recursive stack take O(n).\\n--------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3702977/c-dfs-preorder-easy-solution/"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "Update: The bug is already fixed! Thanks LC\\n\\nIt may be due to how OJ parses the test case: every time I tried to run the testcase, it spat `5 is not a valid value of type TreeNode`. \\nI also tried to enclose 5 and 1 in `[]`but no lucky there.\\nCould someone fix this, or let me know if there is a temporary fix on my end, thanks!"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "When I checked some others solutions committed and passed, I found that, they all miss the checking step,which means we need to check if there are both p and q in this tree.\\n\\nfor example,there is a question name called Share C++/C# 24ms recursive solution , the solution it shows doesn't check wether TreeNode p and TreeNode q exist when it returns.\\n\\nSo what do you guys think??"
                    },
                    {
                        "username": "GUTTTS",
                        "content": "[@mochiball](/mochiball) bro he wrote that in 2015 maybe that time there wasnt anything mentioned in the constraints\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Please read the question constraints. It tells you that p and q are in the tree. No need to check if they exist "
                    },
                    {
                        "username": "harsha335",
                        "content": "in constraints they mentioned both p and q will be present in tree and they are unique and not equal."
                    },
                    {
                        "username": "gepo",
                        "content": "Something is going wrong.\\nLine 41: TypeError: object of type \\'int\\' has no len()"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020 \\n\\nIt is important for me to train myself to get familar with C# data structure and also think better what to choose in design process. There are more than five solutions I like to share using C# data struture: List, Stack, Queue, Dictionary (HashMap), HashSet, Tuple. \\n\\nHere are my highlights:\\n1. First and most important, it is to learn and get familiar using List<TreeNode>, and understand tree traversal, use one path as List variable to solve backtracking issue; \\n2. Next it is important to learn how to solve the algorithm using recursive function without any data structure;\\n3. Advanced topic is to try ideas using Tuple<TreeNode, int> and experience how efficient it is to design and remove ambiguity in design, follow Single Responsiblity Principle SRP. \\n4. Try other options like Stack, HashSet if you have time to practice. \\n\\n**Data structure is the tool to get organized**\\n\\nLet us get started. First one is combination of Queue, Dictionary, HashSet\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is data structure C# List<TreeNode> \\n\\n\\nC# **List** is enough to solve the problem - topics: backtracking, space optimization\\n\\n**No 2 combinations: C# Data structure: List**\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# HashSet<TreeNode>\\n\\n\\n**No 3 combinations: C# Data structure: HashSet**\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\nJune 25, 2019\\n\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Stack<TreeNode>\\n\\n\\n**Stack** is perfect to maintain the order in last in first out order. \\n\\n**No 4 combinations: C# Data structure: Stack**\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Tuple<TreeNode, int><br>\\n\\n\\n**Tuple** is so powerful and time-efficient, good at strong type definition to avoid run time errors. Give it a try! \\n\\n**No 4 combinations:  C# Data structure: Tuple**\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\nIt is time for me to learn to review my own code. Track my progress and I was so surprised to learn that I need to practice backtracking in 2019, 53 year old. \\n\\n**Extra topic: backtracking, List<TreeNode>**\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sai_manoj_kumar",
                        "content": "Input for the testcase is not being parsed correctly. Where do I report this?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "From May to July 2019\\nIt is my practice for busy season from March to May for two online code assessments and one more phone screen. One of ideas is to finish another 100 algorithm on Leetcode, and pace myself sometimes to work on one algorithm with various approaches. It is for potential phone screen, I may get invited any time. So I like to learn how to prepare more carefully through practice.\\n\\nHere are various topic I cover in my practice, and I also like to share the discussion post for each idea. Some of ideas are just to study code on existing discussion post. \\n\\nI also use the algorithm to interview people on interviewing dot io. It is important for me to learn various solutions first in order to be a good interviewer, and also learn from interview experience through a lot of interviewees. \\n\\nIf you have advice for adding more topics on this algorithm as an interviewer, please leave in the comments. I will add them one by one. \\n\\n**Topics**\\n\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[Post order traversal (May 27, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\n**Recursive function design, why mix return will lead to lowest common ancestor?**\\n[recursive function - Confused and more work later (May 8, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288320/C-Work-on-the-algorithm-in-mock-interview)\\n[recursive function - mix returns, final one is lowest common ancestor (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302311/C-recursive-function-design-step-by-step-illustration)\\n[C# post order traversal and return p or q in recursive function](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/315272/C-post-order-traversal-and-return-p-or-q-in-recursive-function) case study mock interview on June 18, 2019\\n\\n**Return type**\\n**Return bool or TreeNode?**\\n[Recursive solution Easy to understand - return bool (May 15, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n[Recursive solution Easy to understand - return TreeNode (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302301/C-recursive-function-with-return-TreeNode-Easy-to-understand)\\n\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n\\n[C# recursive function to find lowest common ancestor given p and q are in the binary tree (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301664/C-recursive-function-to-find-lowest-common-ancestor-given-p-and-q-are-in-the-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301686/C-Find-lowest-common-ancestor-given-two-nodes-p-and-q-may-not-in-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (June 14, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311875/C-Lowest-common-ancestor-given-node-p-and-q-in-binary-tree)\\n\\n**Naive solution with Timeout and Complicated function**\\n[Timeout challenge (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288284/C-time-out-need-help-using-List-preorder-traversal)\\n[Timeout challenge - using a string to store path (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288289/C-time-out-need-help-using-string-preorder-traversal)\\n[Fix naive solution timeout with complicated function (May 13, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290656/C-Fix-timeout-bug-but-still-keep-the-code-on-purpose-complicated)\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nJune 25, 2019\\nThree practice for three ideas; I like to be a master of the lowest common ancestor! I started again from May 8, 2019, met a lot of talent in Sillicon Valley, Seattle, Toronto area on *** on this algorithm.\\n\\nDare to be a master! Self-claim first!\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\nJuly 4, 2019\\nTwo node\\'s distance in binary tree, the post is [here](https://leetcode.com/discuss/interview-question/125084/Amazon-Distance-between-2-nodes). \\nMy solution is written [here](https://leetcode.com/discuss/interview-question/125084/Amazon-or-Distance-between-2-nodes/300089). The idea is to find lowest common ancestor, and then calculate the distance between two nodes indirectly both to lowest common ancestor.\\n[C# Lowest common ancestor -> two node\\'s distance practice (upward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327282/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(uperward))\\n[C# Lowest common ancestor -> two node\\'s distance practice (downward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327278/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(downward))\\n\\n**Common mistakes in mock interview**\\n\\n1. Preorder traversal vs postorder traversal, early return when p or q is found, the rest of nodes in the tree is not traversed;\\n2. Redundant code in the recursive function;\\n"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "my code is pretty much the same as everyone else's, but I changed the comparison\\nfrom\\n\\n    if (root == p || root == q) then return root;\\n\\nto \\n\\n    if (root.val == p.val || root.val == q.val) then return root;\\n\\nthen I got errors, I'm really confused, if the former conditions are satisfied, the latter must be true too."
                    },
                    {
                        "username": "user3971c",
                        "content": "[@ayushanand18](/ayushanand18) I can\\'t speak for 2015, but as of now the constraints state that All Node.val are unique. "
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@ayushanand18](/ayushanand18) are you there suggesting him right after 8 years....wonder what he is doing now."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "there might also be some nodes which have the same values but not the one we are concerned about. i.e. duplicate value nodes."
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020\\n\\nI continue to ask the algorithm question in my interviewing dot io mock interviews as an interviewer in 2020, and then I was surprised to learn more about recursive function design, strong type, backtracking, and expedite the tree problem solving process. \\n\\nTo work on my C# crafting skills, I also practice the idea after each mock interview. \\n\\nApril 19, 2020\\n[C# backtracking practice after mock interview on April 19, 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655605/C-backtracking-practice-after-mock-interview-on-April-19-2020)\\n\\nMay 1, 2020\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nStatistics:\\n1. 40 mock interviews as an interviewer, ask lowest common ancestor in binary tree algorithm in 2019;\\n2. Work on recursive function design over 10 times;\\n3. Work on backtracking practice over 10 times;\\n4. All engineers over 40 engineers in two months I met in 2019 cannot beat performance I met in 2020, an ex-facebook engineer. \\n\\n"
                    }
                ]
            },
            {
                "id": 1569544,
                "content": [
                    {
                        "username": "jack76",
                        "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS(preOrder).. Easy solution\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three parameters: `root` (the current node), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n2. Check if the current node `root` is null or if it is either `p` or `q`. If any of these conditions is true, return the current node `root` as the lowest common ancestor.\\n\\n3. Recursively call the `rec` function for the left subtree of the current node and assign the result to a variable `l`.\\n\\n4. Recursively call the `rec` function for the right subtree of the current node and assign the result to a variable `r`.\\n\\n5. Check if both `l` and `r` are not null. If so, it means that `p` and `q` are found on different subtrees of the current node, and the current node `root` is their lowest common ancestor. Return the current node `root`.\\n\\n6. If `l` is null, it means that both `p` and `q` are on the right subtree (or not present in the tree). Return `r`.\\n\\n7. If none of the above conditions are met, it means that both `p` and `q` are on the left subtree (or not present in the tree). Return `l`.\\n\\n8. Define a function `lowestCommonAncestor` that takes three parameters: `root` (the root node of the tree), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n9. Return the result of calling the `rec` function with the parameters `root`, `p`, and `q`. This will find and return the lowest common ancestor of nodes `p` and `q` in the given binary tree.\\n\\n-------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n). All node have to visit in worst case.\\n\\n- Space complexity:\\nS.C=O(n) in worst case skewed tree. recursive stack take O(n).\\n--------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3702977/c-dfs-preorder-easy-solution/"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "Update: The bug is already fixed! Thanks LC\\n\\nIt may be due to how OJ parses the test case: every time I tried to run the testcase, it spat `5 is not a valid value of type TreeNode`. \\nI also tried to enclose 5 and 1 in `[]`but no lucky there.\\nCould someone fix this, or let me know if there is a temporary fix on my end, thanks!"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "When I checked some others solutions committed and passed, I found that, they all miss the checking step,which means we need to check if there are both p and q in this tree.\\n\\nfor example,there is a question name called Share C++/C# 24ms recursive solution , the solution it shows doesn't check wether TreeNode p and TreeNode q exist when it returns.\\n\\nSo what do you guys think??"
                    },
                    {
                        "username": "GUTTTS",
                        "content": "[@mochiball](/mochiball) bro he wrote that in 2015 maybe that time there wasnt anything mentioned in the constraints\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Please read the question constraints. It tells you that p and q are in the tree. No need to check if they exist "
                    },
                    {
                        "username": "harsha335",
                        "content": "in constraints they mentioned both p and q will be present in tree and they are unique and not equal."
                    },
                    {
                        "username": "gepo",
                        "content": "Something is going wrong.\\nLine 41: TypeError: object of type \\'int\\' has no len()"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020 \\n\\nIt is important for me to train myself to get familar with C# data structure and also think better what to choose in design process. There are more than five solutions I like to share using C# data struture: List, Stack, Queue, Dictionary (HashMap), HashSet, Tuple. \\n\\nHere are my highlights:\\n1. First and most important, it is to learn and get familiar using List<TreeNode>, and understand tree traversal, use one path as List variable to solve backtracking issue; \\n2. Next it is important to learn how to solve the algorithm using recursive function without any data structure;\\n3. Advanced topic is to try ideas using Tuple<TreeNode, int> and experience how efficient it is to design and remove ambiguity in design, follow Single Responsiblity Principle SRP. \\n4. Try other options like Stack, HashSet if you have time to practice. \\n\\n**Data structure is the tool to get organized**\\n\\nLet us get started. First one is combination of Queue, Dictionary, HashSet\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is data structure C# List<TreeNode> \\n\\n\\nC# **List** is enough to solve the problem - topics: backtracking, space optimization\\n\\n**No 2 combinations: C# Data structure: List**\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# HashSet<TreeNode>\\n\\n\\n**No 3 combinations: C# Data structure: HashSet**\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\nJune 25, 2019\\n\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Stack<TreeNode>\\n\\n\\n**Stack** is perfect to maintain the order in last in first out order. \\n\\n**No 4 combinations: C# Data structure: Stack**\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Tuple<TreeNode, int><br>\\n\\n\\n**Tuple** is so powerful and time-efficient, good at strong type definition to avoid run time errors. Give it a try! \\n\\n**No 4 combinations:  C# Data structure: Tuple**\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\nIt is time for me to learn to review my own code. Track my progress and I was so surprised to learn that I need to practice backtracking in 2019, 53 year old. \\n\\n**Extra topic: backtracking, List<TreeNode>**\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sai_manoj_kumar",
                        "content": "Input for the testcase is not being parsed correctly. Where do I report this?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "From May to July 2019\\nIt is my practice for busy season from March to May for two online code assessments and one more phone screen. One of ideas is to finish another 100 algorithm on Leetcode, and pace myself sometimes to work on one algorithm with various approaches. It is for potential phone screen, I may get invited any time. So I like to learn how to prepare more carefully through practice.\\n\\nHere are various topic I cover in my practice, and I also like to share the discussion post for each idea. Some of ideas are just to study code on existing discussion post. \\n\\nI also use the algorithm to interview people on interviewing dot io. It is important for me to learn various solutions first in order to be a good interviewer, and also learn from interview experience through a lot of interviewees. \\n\\nIf you have advice for adding more topics on this algorithm as an interviewer, please leave in the comments. I will add them one by one. \\n\\n**Topics**\\n\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[Post order traversal (May 27, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\n**Recursive function design, why mix return will lead to lowest common ancestor?**\\n[recursive function - Confused and more work later (May 8, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288320/C-Work-on-the-algorithm-in-mock-interview)\\n[recursive function - mix returns, final one is lowest common ancestor (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302311/C-recursive-function-design-step-by-step-illustration)\\n[C# post order traversal and return p or q in recursive function](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/315272/C-post-order-traversal-and-return-p-or-q-in-recursive-function) case study mock interview on June 18, 2019\\n\\n**Return type**\\n**Return bool or TreeNode?**\\n[Recursive solution Easy to understand - return bool (May 15, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n[Recursive solution Easy to understand - return TreeNode (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302301/C-recursive-function-with-return-TreeNode-Easy-to-understand)\\n\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n\\n[C# recursive function to find lowest common ancestor given p and q are in the binary tree (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301664/C-recursive-function-to-find-lowest-common-ancestor-given-p-and-q-are-in-the-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301686/C-Find-lowest-common-ancestor-given-two-nodes-p-and-q-may-not-in-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (June 14, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311875/C-Lowest-common-ancestor-given-node-p-and-q-in-binary-tree)\\n\\n**Naive solution with Timeout and Complicated function**\\n[Timeout challenge (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288284/C-time-out-need-help-using-List-preorder-traversal)\\n[Timeout challenge - using a string to store path (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288289/C-time-out-need-help-using-string-preorder-traversal)\\n[Fix naive solution timeout with complicated function (May 13, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290656/C-Fix-timeout-bug-but-still-keep-the-code-on-purpose-complicated)\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nJune 25, 2019\\nThree practice for three ideas; I like to be a master of the lowest common ancestor! I started again from May 8, 2019, met a lot of talent in Sillicon Valley, Seattle, Toronto area on *** on this algorithm.\\n\\nDare to be a master! Self-claim first!\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\nJuly 4, 2019\\nTwo node\\'s distance in binary tree, the post is [here](https://leetcode.com/discuss/interview-question/125084/Amazon-Distance-between-2-nodes). \\nMy solution is written [here](https://leetcode.com/discuss/interview-question/125084/Amazon-or-Distance-between-2-nodes/300089). The idea is to find lowest common ancestor, and then calculate the distance between two nodes indirectly both to lowest common ancestor.\\n[C# Lowest common ancestor -> two node\\'s distance practice (upward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327282/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(uperward))\\n[C# Lowest common ancestor -> two node\\'s distance practice (downward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327278/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(downward))\\n\\n**Common mistakes in mock interview**\\n\\n1. Preorder traversal vs postorder traversal, early return when p or q is found, the rest of nodes in the tree is not traversed;\\n2. Redundant code in the recursive function;\\n"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "my code is pretty much the same as everyone else's, but I changed the comparison\\nfrom\\n\\n    if (root == p || root == q) then return root;\\n\\nto \\n\\n    if (root.val == p.val || root.val == q.val) then return root;\\n\\nthen I got errors, I'm really confused, if the former conditions are satisfied, the latter must be true too."
                    },
                    {
                        "username": "user3971c",
                        "content": "[@ayushanand18](/ayushanand18) I can\\'t speak for 2015, but as of now the constraints state that All Node.val are unique. "
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@ayushanand18](/ayushanand18) are you there suggesting him right after 8 years....wonder what he is doing now."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "there might also be some nodes which have the same values but not the one we are concerned about. i.e. duplicate value nodes."
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020\\n\\nI continue to ask the algorithm question in my interviewing dot io mock interviews as an interviewer in 2020, and then I was surprised to learn more about recursive function design, strong type, backtracking, and expedite the tree problem solving process. \\n\\nTo work on my C# crafting skills, I also practice the idea after each mock interview. \\n\\nApril 19, 2020\\n[C# backtracking practice after mock interview on April 19, 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655605/C-backtracking-practice-after-mock-interview-on-April-19-2020)\\n\\nMay 1, 2020\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nStatistics:\\n1. 40 mock interviews as an interviewer, ask lowest common ancestor in binary tree algorithm in 2019;\\n2. Work on recursive function design over 10 times;\\n3. Work on backtracking practice over 10 times;\\n4. All engineers over 40 engineers in two months I met in 2019 cannot beat performance I met in 2020, an ex-facebook engineer. \\n\\n"
                    }
                ]
            },
            {
                "id": 1568138,
                "content": [
                    {
                        "username": "jack76",
                        "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS(preOrder).. Easy solution\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three parameters: `root` (the current node), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n2. Check if the current node `root` is null or if it is either `p` or `q`. If any of these conditions is true, return the current node `root` as the lowest common ancestor.\\n\\n3. Recursively call the `rec` function for the left subtree of the current node and assign the result to a variable `l`.\\n\\n4. Recursively call the `rec` function for the right subtree of the current node and assign the result to a variable `r`.\\n\\n5. Check if both `l` and `r` are not null. If so, it means that `p` and `q` are found on different subtrees of the current node, and the current node `root` is their lowest common ancestor. Return the current node `root`.\\n\\n6. If `l` is null, it means that both `p` and `q` are on the right subtree (or not present in the tree). Return `r`.\\n\\n7. If none of the above conditions are met, it means that both `p` and `q` are on the left subtree (or not present in the tree). Return `l`.\\n\\n8. Define a function `lowestCommonAncestor` that takes three parameters: `root` (the root node of the tree), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n9. Return the result of calling the `rec` function with the parameters `root`, `p`, and `q`. This will find and return the lowest common ancestor of nodes `p` and `q` in the given binary tree.\\n\\n-------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n). All node have to visit in worst case.\\n\\n- Space complexity:\\nS.C=O(n) in worst case skewed tree. recursive stack take O(n).\\n--------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3702977/c-dfs-preorder-easy-solution/"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "Update: The bug is already fixed! Thanks LC\\n\\nIt may be due to how OJ parses the test case: every time I tried to run the testcase, it spat `5 is not a valid value of type TreeNode`. \\nI also tried to enclose 5 and 1 in `[]`but no lucky there.\\nCould someone fix this, or let me know if there is a temporary fix on my end, thanks!"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "When I checked some others solutions committed and passed, I found that, they all miss the checking step,which means we need to check if there are both p and q in this tree.\\n\\nfor example,there is a question name called Share C++/C# 24ms recursive solution , the solution it shows doesn't check wether TreeNode p and TreeNode q exist when it returns.\\n\\nSo what do you guys think??"
                    },
                    {
                        "username": "GUTTTS",
                        "content": "[@mochiball](/mochiball) bro he wrote that in 2015 maybe that time there wasnt anything mentioned in the constraints\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Please read the question constraints. It tells you that p and q are in the tree. No need to check if they exist "
                    },
                    {
                        "username": "harsha335",
                        "content": "in constraints they mentioned both p and q will be present in tree and they are unique and not equal."
                    },
                    {
                        "username": "gepo",
                        "content": "Something is going wrong.\\nLine 41: TypeError: object of type \\'int\\' has no len()"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020 \\n\\nIt is important for me to train myself to get familar with C# data structure and also think better what to choose in design process. There are more than five solutions I like to share using C# data struture: List, Stack, Queue, Dictionary (HashMap), HashSet, Tuple. \\n\\nHere are my highlights:\\n1. First and most important, it is to learn and get familiar using List<TreeNode>, and understand tree traversal, use one path as List variable to solve backtracking issue; \\n2. Next it is important to learn how to solve the algorithm using recursive function without any data structure;\\n3. Advanced topic is to try ideas using Tuple<TreeNode, int> and experience how efficient it is to design and remove ambiguity in design, follow Single Responsiblity Principle SRP. \\n4. Try other options like Stack, HashSet if you have time to practice. \\n\\n**Data structure is the tool to get organized**\\n\\nLet us get started. First one is combination of Queue, Dictionary, HashSet\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is data structure C# List<TreeNode> \\n\\n\\nC# **List** is enough to solve the problem - topics: backtracking, space optimization\\n\\n**No 2 combinations: C# Data structure: List**\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# HashSet<TreeNode>\\n\\n\\n**No 3 combinations: C# Data structure: HashSet**\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\nJune 25, 2019\\n\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Stack<TreeNode>\\n\\n\\n**Stack** is perfect to maintain the order in last in first out order. \\n\\n**No 4 combinations: C# Data structure: Stack**\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Tuple<TreeNode, int><br>\\n\\n\\n**Tuple** is so powerful and time-efficient, good at strong type definition to avoid run time errors. Give it a try! \\n\\n**No 4 combinations:  C# Data structure: Tuple**\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\nIt is time for me to learn to review my own code. Track my progress and I was so surprised to learn that I need to practice backtracking in 2019, 53 year old. \\n\\n**Extra topic: backtracking, List<TreeNode>**\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sai_manoj_kumar",
                        "content": "Input for the testcase is not being parsed correctly. Where do I report this?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "From May to July 2019\\nIt is my practice for busy season from March to May for two online code assessments and one more phone screen. One of ideas is to finish another 100 algorithm on Leetcode, and pace myself sometimes to work on one algorithm with various approaches. It is for potential phone screen, I may get invited any time. So I like to learn how to prepare more carefully through practice.\\n\\nHere are various topic I cover in my practice, and I also like to share the discussion post for each idea. Some of ideas are just to study code on existing discussion post. \\n\\nI also use the algorithm to interview people on interviewing dot io. It is important for me to learn various solutions first in order to be a good interviewer, and also learn from interview experience through a lot of interviewees. \\n\\nIf you have advice for adding more topics on this algorithm as an interviewer, please leave in the comments. I will add them one by one. \\n\\n**Topics**\\n\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[Post order traversal (May 27, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\n**Recursive function design, why mix return will lead to lowest common ancestor?**\\n[recursive function - Confused and more work later (May 8, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288320/C-Work-on-the-algorithm-in-mock-interview)\\n[recursive function - mix returns, final one is lowest common ancestor (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302311/C-recursive-function-design-step-by-step-illustration)\\n[C# post order traversal and return p or q in recursive function](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/315272/C-post-order-traversal-and-return-p-or-q-in-recursive-function) case study mock interview on June 18, 2019\\n\\n**Return type**\\n**Return bool or TreeNode?**\\n[Recursive solution Easy to understand - return bool (May 15, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n[Recursive solution Easy to understand - return TreeNode (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302301/C-recursive-function-with-return-TreeNode-Easy-to-understand)\\n\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n\\n[C# recursive function to find lowest common ancestor given p and q are in the binary tree (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301664/C-recursive-function-to-find-lowest-common-ancestor-given-p-and-q-are-in-the-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301686/C-Find-lowest-common-ancestor-given-two-nodes-p-and-q-may-not-in-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (June 14, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311875/C-Lowest-common-ancestor-given-node-p-and-q-in-binary-tree)\\n\\n**Naive solution with Timeout and Complicated function**\\n[Timeout challenge (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288284/C-time-out-need-help-using-List-preorder-traversal)\\n[Timeout challenge - using a string to store path (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288289/C-time-out-need-help-using-string-preorder-traversal)\\n[Fix naive solution timeout with complicated function (May 13, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290656/C-Fix-timeout-bug-but-still-keep-the-code-on-purpose-complicated)\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nJune 25, 2019\\nThree practice for three ideas; I like to be a master of the lowest common ancestor! I started again from May 8, 2019, met a lot of talent in Sillicon Valley, Seattle, Toronto area on *** on this algorithm.\\n\\nDare to be a master! Self-claim first!\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\nJuly 4, 2019\\nTwo node\\'s distance in binary tree, the post is [here](https://leetcode.com/discuss/interview-question/125084/Amazon-Distance-between-2-nodes). \\nMy solution is written [here](https://leetcode.com/discuss/interview-question/125084/Amazon-or-Distance-between-2-nodes/300089). The idea is to find lowest common ancestor, and then calculate the distance between two nodes indirectly both to lowest common ancestor.\\n[C# Lowest common ancestor -> two node\\'s distance practice (upward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327282/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(uperward))\\n[C# Lowest common ancestor -> two node\\'s distance practice (downward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327278/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(downward))\\n\\n**Common mistakes in mock interview**\\n\\n1. Preorder traversal vs postorder traversal, early return when p or q is found, the rest of nodes in the tree is not traversed;\\n2. Redundant code in the recursive function;\\n"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "my code is pretty much the same as everyone else's, but I changed the comparison\\nfrom\\n\\n    if (root == p || root == q) then return root;\\n\\nto \\n\\n    if (root.val == p.val || root.val == q.val) then return root;\\n\\nthen I got errors, I'm really confused, if the former conditions are satisfied, the latter must be true too."
                    },
                    {
                        "username": "user3971c",
                        "content": "[@ayushanand18](/ayushanand18) I can\\'t speak for 2015, but as of now the constraints state that All Node.val are unique. "
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@ayushanand18](/ayushanand18) are you there suggesting him right after 8 years....wonder what he is doing now."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "there might also be some nodes which have the same values but not the one we are concerned about. i.e. duplicate value nodes."
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020\\n\\nI continue to ask the algorithm question in my interviewing dot io mock interviews as an interviewer in 2020, and then I was surprised to learn more about recursive function design, strong type, backtracking, and expedite the tree problem solving process. \\n\\nTo work on my C# crafting skills, I also practice the idea after each mock interview. \\n\\nApril 19, 2020\\n[C# backtracking practice after mock interview on April 19, 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655605/C-backtracking-practice-after-mock-interview-on-April-19-2020)\\n\\nMay 1, 2020\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nStatistics:\\n1. 40 mock interviews as an interviewer, ask lowest common ancestor in binary tree algorithm in 2019;\\n2. Work on recursive function design over 10 times;\\n3. Work on backtracking practice over 10 times;\\n4. All engineers over 40 engineers in two months I met in 2019 cannot beat performance I met in 2020, an ex-facebook engineer. \\n\\n"
                    }
                ]
            },
            {
                "id": 1567925,
                "content": [
                    {
                        "username": "jack76",
                        "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS(preOrder).. Easy solution\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three parameters: `root` (the current node), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n2. Check if the current node `root` is null or if it is either `p` or `q`. If any of these conditions is true, return the current node `root` as the lowest common ancestor.\\n\\n3. Recursively call the `rec` function for the left subtree of the current node and assign the result to a variable `l`.\\n\\n4. Recursively call the `rec` function for the right subtree of the current node and assign the result to a variable `r`.\\n\\n5. Check if both `l` and `r` are not null. If so, it means that `p` and `q` are found on different subtrees of the current node, and the current node `root` is their lowest common ancestor. Return the current node `root`.\\n\\n6. If `l` is null, it means that both `p` and `q` are on the right subtree (or not present in the tree). Return `r`.\\n\\n7. If none of the above conditions are met, it means that both `p` and `q` are on the left subtree (or not present in the tree). Return `l`.\\n\\n8. Define a function `lowestCommonAncestor` that takes three parameters: `root` (the root node of the tree), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n9. Return the result of calling the `rec` function with the parameters `root`, `p`, and `q`. This will find and return the lowest common ancestor of nodes `p` and `q` in the given binary tree.\\n\\n-------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n). All node have to visit in worst case.\\n\\n- Space complexity:\\nS.C=O(n) in worst case skewed tree. recursive stack take O(n).\\n--------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3702977/c-dfs-preorder-easy-solution/"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "Update: The bug is already fixed! Thanks LC\\n\\nIt may be due to how OJ parses the test case: every time I tried to run the testcase, it spat `5 is not a valid value of type TreeNode`. \\nI also tried to enclose 5 and 1 in `[]`but no lucky there.\\nCould someone fix this, or let me know if there is a temporary fix on my end, thanks!"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "When I checked some others solutions committed and passed, I found that, they all miss the checking step,which means we need to check if there are both p and q in this tree.\\n\\nfor example,there is a question name called Share C++/C# 24ms recursive solution , the solution it shows doesn't check wether TreeNode p and TreeNode q exist when it returns.\\n\\nSo what do you guys think??"
                    },
                    {
                        "username": "GUTTTS",
                        "content": "[@mochiball](/mochiball) bro he wrote that in 2015 maybe that time there wasnt anything mentioned in the constraints\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Please read the question constraints. It tells you that p and q are in the tree. No need to check if they exist "
                    },
                    {
                        "username": "harsha335",
                        "content": "in constraints they mentioned both p and q will be present in tree and they are unique and not equal."
                    },
                    {
                        "username": "gepo",
                        "content": "Something is going wrong.\\nLine 41: TypeError: object of type \\'int\\' has no len()"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020 \\n\\nIt is important for me to train myself to get familar with C# data structure and also think better what to choose in design process. There are more than five solutions I like to share using C# data struture: List, Stack, Queue, Dictionary (HashMap), HashSet, Tuple. \\n\\nHere are my highlights:\\n1. First and most important, it is to learn and get familiar using List<TreeNode>, and understand tree traversal, use one path as List variable to solve backtracking issue; \\n2. Next it is important to learn how to solve the algorithm using recursive function without any data structure;\\n3. Advanced topic is to try ideas using Tuple<TreeNode, int> and experience how efficient it is to design and remove ambiguity in design, follow Single Responsiblity Principle SRP. \\n4. Try other options like Stack, HashSet if you have time to practice. \\n\\n**Data structure is the tool to get organized**\\n\\nLet us get started. First one is combination of Queue, Dictionary, HashSet\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is data structure C# List<TreeNode> \\n\\n\\nC# **List** is enough to solve the problem - topics: backtracking, space optimization\\n\\n**No 2 combinations: C# Data structure: List**\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# HashSet<TreeNode>\\n\\n\\n**No 3 combinations: C# Data structure: HashSet**\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\nJune 25, 2019\\n\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Stack<TreeNode>\\n\\n\\n**Stack** is perfect to maintain the order in last in first out order. \\n\\n**No 4 combinations: C# Data structure: Stack**\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Tuple<TreeNode, int><br>\\n\\n\\n**Tuple** is so powerful and time-efficient, good at strong type definition to avoid run time errors. Give it a try! \\n\\n**No 4 combinations:  C# Data structure: Tuple**\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\nIt is time for me to learn to review my own code. Track my progress and I was so surprised to learn that I need to practice backtracking in 2019, 53 year old. \\n\\n**Extra topic: backtracking, List<TreeNode>**\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sai_manoj_kumar",
                        "content": "Input for the testcase is not being parsed correctly. Where do I report this?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "From May to July 2019\\nIt is my practice for busy season from March to May for two online code assessments and one more phone screen. One of ideas is to finish another 100 algorithm on Leetcode, and pace myself sometimes to work on one algorithm with various approaches. It is for potential phone screen, I may get invited any time. So I like to learn how to prepare more carefully through practice.\\n\\nHere are various topic I cover in my practice, and I also like to share the discussion post for each idea. Some of ideas are just to study code on existing discussion post. \\n\\nI also use the algorithm to interview people on interviewing dot io. It is important for me to learn various solutions first in order to be a good interviewer, and also learn from interview experience through a lot of interviewees. \\n\\nIf you have advice for adding more topics on this algorithm as an interviewer, please leave in the comments. I will add them one by one. \\n\\n**Topics**\\n\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[Post order traversal (May 27, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\n**Recursive function design, why mix return will lead to lowest common ancestor?**\\n[recursive function - Confused and more work later (May 8, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288320/C-Work-on-the-algorithm-in-mock-interview)\\n[recursive function - mix returns, final one is lowest common ancestor (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302311/C-recursive-function-design-step-by-step-illustration)\\n[C# post order traversal and return p or q in recursive function](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/315272/C-post-order-traversal-and-return-p-or-q-in-recursive-function) case study mock interview on June 18, 2019\\n\\n**Return type**\\n**Return bool or TreeNode?**\\n[Recursive solution Easy to understand - return bool (May 15, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n[Recursive solution Easy to understand - return TreeNode (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302301/C-recursive-function-with-return-TreeNode-Easy-to-understand)\\n\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n\\n[C# recursive function to find lowest common ancestor given p and q are in the binary tree (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301664/C-recursive-function-to-find-lowest-common-ancestor-given-p-and-q-are-in-the-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301686/C-Find-lowest-common-ancestor-given-two-nodes-p-and-q-may-not-in-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (June 14, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311875/C-Lowest-common-ancestor-given-node-p-and-q-in-binary-tree)\\n\\n**Naive solution with Timeout and Complicated function**\\n[Timeout challenge (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288284/C-time-out-need-help-using-List-preorder-traversal)\\n[Timeout challenge - using a string to store path (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288289/C-time-out-need-help-using-string-preorder-traversal)\\n[Fix naive solution timeout with complicated function (May 13, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290656/C-Fix-timeout-bug-but-still-keep-the-code-on-purpose-complicated)\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nJune 25, 2019\\nThree practice for three ideas; I like to be a master of the lowest common ancestor! I started again from May 8, 2019, met a lot of talent in Sillicon Valley, Seattle, Toronto area on *** on this algorithm.\\n\\nDare to be a master! Self-claim first!\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\nJuly 4, 2019\\nTwo node\\'s distance in binary tree, the post is [here](https://leetcode.com/discuss/interview-question/125084/Amazon-Distance-between-2-nodes). \\nMy solution is written [here](https://leetcode.com/discuss/interview-question/125084/Amazon-or-Distance-between-2-nodes/300089). The idea is to find lowest common ancestor, and then calculate the distance between two nodes indirectly both to lowest common ancestor.\\n[C# Lowest common ancestor -> two node\\'s distance practice (upward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327282/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(uperward))\\n[C# Lowest common ancestor -> two node\\'s distance practice (downward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327278/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(downward))\\n\\n**Common mistakes in mock interview**\\n\\n1. Preorder traversal vs postorder traversal, early return when p or q is found, the rest of nodes in the tree is not traversed;\\n2. Redundant code in the recursive function;\\n"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "my code is pretty much the same as everyone else's, but I changed the comparison\\nfrom\\n\\n    if (root == p || root == q) then return root;\\n\\nto \\n\\n    if (root.val == p.val || root.val == q.val) then return root;\\n\\nthen I got errors, I'm really confused, if the former conditions are satisfied, the latter must be true too."
                    },
                    {
                        "username": "user3971c",
                        "content": "[@ayushanand18](/ayushanand18) I can\\'t speak for 2015, but as of now the constraints state that All Node.val are unique. "
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@ayushanand18](/ayushanand18) are you there suggesting him right after 8 years....wonder what he is doing now."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "there might also be some nodes which have the same values but not the one we are concerned about. i.e. duplicate value nodes."
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020\\n\\nI continue to ask the algorithm question in my interviewing dot io mock interviews as an interviewer in 2020, and then I was surprised to learn more about recursive function design, strong type, backtracking, and expedite the tree problem solving process. \\n\\nTo work on my C# crafting skills, I also practice the idea after each mock interview. \\n\\nApril 19, 2020\\n[C# backtracking practice after mock interview on April 19, 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655605/C-backtracking-practice-after-mock-interview-on-April-19-2020)\\n\\nMay 1, 2020\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nStatistics:\\n1. 40 mock interviews as an interviewer, ask lowest common ancestor in binary tree algorithm in 2019;\\n2. Work on recursive function design over 10 times;\\n3. Work on backtracking practice over 10 times;\\n4. All engineers over 40 engineers in two months I met in 2019 cannot beat performance I met in 2020, an ex-facebook engineer. \\n\\n"
                    }
                ]
            },
            {
                "id": 1573825,
                "content": [
                    {
                        "username": "jack76",
                        "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS(preOrder).. Easy solution\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three parameters: `root` (the current node), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n2. Check if the current node `root` is null or if it is either `p` or `q`. If any of these conditions is true, return the current node `root` as the lowest common ancestor.\\n\\n3. Recursively call the `rec` function for the left subtree of the current node and assign the result to a variable `l`.\\n\\n4. Recursively call the `rec` function for the right subtree of the current node and assign the result to a variable `r`.\\n\\n5. Check if both `l` and `r` are not null. If so, it means that `p` and `q` are found on different subtrees of the current node, and the current node `root` is their lowest common ancestor. Return the current node `root`.\\n\\n6. If `l` is null, it means that both `p` and `q` are on the right subtree (or not present in the tree). Return `r`.\\n\\n7. If none of the above conditions are met, it means that both `p` and `q` are on the left subtree (or not present in the tree). Return `l`.\\n\\n8. Define a function `lowestCommonAncestor` that takes three parameters: `root` (the root node of the tree), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n9. Return the result of calling the `rec` function with the parameters `root`, `p`, and `q`. This will find and return the lowest common ancestor of nodes `p` and `q` in the given binary tree.\\n\\n-------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n). All node have to visit in worst case.\\n\\n- Space complexity:\\nS.C=O(n) in worst case skewed tree. recursive stack take O(n).\\n--------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3702977/c-dfs-preorder-easy-solution/"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "Update: The bug is already fixed! Thanks LC\\n\\nIt may be due to how OJ parses the test case: every time I tried to run the testcase, it spat `5 is not a valid value of type TreeNode`. \\nI also tried to enclose 5 and 1 in `[]`but no lucky there.\\nCould someone fix this, or let me know if there is a temporary fix on my end, thanks!"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "When I checked some others solutions committed and passed, I found that, they all miss the checking step,which means we need to check if there are both p and q in this tree.\\n\\nfor example,there is a question name called Share C++/C# 24ms recursive solution , the solution it shows doesn't check wether TreeNode p and TreeNode q exist when it returns.\\n\\nSo what do you guys think??"
                    },
                    {
                        "username": "GUTTTS",
                        "content": "[@mochiball](/mochiball) bro he wrote that in 2015 maybe that time there wasnt anything mentioned in the constraints\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Please read the question constraints. It tells you that p and q are in the tree. No need to check if they exist "
                    },
                    {
                        "username": "harsha335",
                        "content": "in constraints they mentioned both p and q will be present in tree and they are unique and not equal."
                    },
                    {
                        "username": "gepo",
                        "content": "Something is going wrong.\\nLine 41: TypeError: object of type \\'int\\' has no len()"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020 \\n\\nIt is important for me to train myself to get familar with C# data structure and also think better what to choose in design process. There are more than five solutions I like to share using C# data struture: List, Stack, Queue, Dictionary (HashMap), HashSet, Tuple. \\n\\nHere are my highlights:\\n1. First and most important, it is to learn and get familiar using List<TreeNode>, and understand tree traversal, use one path as List variable to solve backtracking issue; \\n2. Next it is important to learn how to solve the algorithm using recursive function without any data structure;\\n3. Advanced topic is to try ideas using Tuple<TreeNode, int> and experience how efficient it is to design and remove ambiguity in design, follow Single Responsiblity Principle SRP. \\n4. Try other options like Stack, HashSet if you have time to practice. \\n\\n**Data structure is the tool to get organized**\\n\\nLet us get started. First one is combination of Queue, Dictionary, HashSet\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is data structure C# List<TreeNode> \\n\\n\\nC# **List** is enough to solve the problem - topics: backtracking, space optimization\\n\\n**No 2 combinations: C# Data structure: List**\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# HashSet<TreeNode>\\n\\n\\n**No 3 combinations: C# Data structure: HashSet**\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\nJune 25, 2019\\n\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Stack<TreeNode>\\n\\n\\n**Stack** is perfect to maintain the order in last in first out order. \\n\\n**No 4 combinations: C# Data structure: Stack**\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Tuple<TreeNode, int><br>\\n\\n\\n**Tuple** is so powerful and time-efficient, good at strong type definition to avoid run time errors. Give it a try! \\n\\n**No 4 combinations:  C# Data structure: Tuple**\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\nIt is time for me to learn to review my own code. Track my progress and I was so surprised to learn that I need to practice backtracking in 2019, 53 year old. \\n\\n**Extra topic: backtracking, List<TreeNode>**\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sai_manoj_kumar",
                        "content": "Input for the testcase is not being parsed correctly. Where do I report this?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "From May to July 2019\\nIt is my practice for busy season from March to May for two online code assessments and one more phone screen. One of ideas is to finish another 100 algorithm on Leetcode, and pace myself sometimes to work on one algorithm with various approaches. It is for potential phone screen, I may get invited any time. So I like to learn how to prepare more carefully through practice.\\n\\nHere are various topic I cover in my practice, and I also like to share the discussion post for each idea. Some of ideas are just to study code on existing discussion post. \\n\\nI also use the algorithm to interview people on interviewing dot io. It is important for me to learn various solutions first in order to be a good interviewer, and also learn from interview experience through a lot of interviewees. \\n\\nIf you have advice for adding more topics on this algorithm as an interviewer, please leave in the comments. I will add them one by one. \\n\\n**Topics**\\n\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[Post order traversal (May 27, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\n**Recursive function design, why mix return will lead to lowest common ancestor?**\\n[recursive function - Confused and more work later (May 8, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288320/C-Work-on-the-algorithm-in-mock-interview)\\n[recursive function - mix returns, final one is lowest common ancestor (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302311/C-recursive-function-design-step-by-step-illustration)\\n[C# post order traversal and return p or q in recursive function](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/315272/C-post-order-traversal-and-return-p-or-q-in-recursive-function) case study mock interview on June 18, 2019\\n\\n**Return type**\\n**Return bool or TreeNode?**\\n[Recursive solution Easy to understand - return bool (May 15, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n[Recursive solution Easy to understand - return TreeNode (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302301/C-recursive-function-with-return-TreeNode-Easy-to-understand)\\n\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n\\n[C# recursive function to find lowest common ancestor given p and q are in the binary tree (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301664/C-recursive-function-to-find-lowest-common-ancestor-given-p-and-q-are-in-the-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301686/C-Find-lowest-common-ancestor-given-two-nodes-p-and-q-may-not-in-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (June 14, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311875/C-Lowest-common-ancestor-given-node-p-and-q-in-binary-tree)\\n\\n**Naive solution with Timeout and Complicated function**\\n[Timeout challenge (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288284/C-time-out-need-help-using-List-preorder-traversal)\\n[Timeout challenge - using a string to store path (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288289/C-time-out-need-help-using-string-preorder-traversal)\\n[Fix naive solution timeout with complicated function (May 13, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290656/C-Fix-timeout-bug-but-still-keep-the-code-on-purpose-complicated)\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nJune 25, 2019\\nThree practice for three ideas; I like to be a master of the lowest common ancestor! I started again from May 8, 2019, met a lot of talent in Sillicon Valley, Seattle, Toronto area on *** on this algorithm.\\n\\nDare to be a master! Self-claim first!\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\nJuly 4, 2019\\nTwo node\\'s distance in binary tree, the post is [here](https://leetcode.com/discuss/interview-question/125084/Amazon-Distance-between-2-nodes). \\nMy solution is written [here](https://leetcode.com/discuss/interview-question/125084/Amazon-or-Distance-between-2-nodes/300089). The idea is to find lowest common ancestor, and then calculate the distance between two nodes indirectly both to lowest common ancestor.\\n[C# Lowest common ancestor -> two node\\'s distance practice (upward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327282/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(uperward))\\n[C# Lowest common ancestor -> two node\\'s distance practice (downward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327278/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(downward))\\n\\n**Common mistakes in mock interview**\\n\\n1. Preorder traversal vs postorder traversal, early return when p or q is found, the rest of nodes in the tree is not traversed;\\n2. Redundant code in the recursive function;\\n"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "my code is pretty much the same as everyone else's, but I changed the comparison\\nfrom\\n\\n    if (root == p || root == q) then return root;\\n\\nto \\n\\n    if (root.val == p.val || root.val == q.val) then return root;\\n\\nthen I got errors, I'm really confused, if the former conditions are satisfied, the latter must be true too."
                    },
                    {
                        "username": "user3971c",
                        "content": "[@ayushanand18](/ayushanand18) I can\\'t speak for 2015, but as of now the constraints state that All Node.val are unique. "
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@ayushanand18](/ayushanand18) are you there suggesting him right after 8 years....wonder what he is doing now."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "there might also be some nodes which have the same values but not the one we are concerned about. i.e. duplicate value nodes."
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020\\n\\nI continue to ask the algorithm question in my interviewing dot io mock interviews as an interviewer in 2020, and then I was surprised to learn more about recursive function design, strong type, backtracking, and expedite the tree problem solving process. \\n\\nTo work on my C# crafting skills, I also practice the idea after each mock interview. \\n\\nApril 19, 2020\\n[C# backtracking practice after mock interview on April 19, 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655605/C-backtracking-practice-after-mock-interview-on-April-19-2020)\\n\\nMay 1, 2020\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nStatistics:\\n1. 40 mock interviews as an interviewer, ask lowest common ancestor in binary tree algorithm in 2019;\\n2. Work on recursive function design over 10 times;\\n3. Work on backtracking practice over 10 times;\\n4. All engineers over 40 engineers in two months I met in 2019 cannot beat performance I met in 2020, an ex-facebook engineer. \\n\\n"
                    }
                ]
            },
            {
                "id": 1569322,
                "content": [
                    {
                        "username": "ravitejrai123",
                        "content": "Can some body explain it to me ? \\nIs it because the tree size is small and there are only a few calls to the recursion stack ?\\n\\n"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "https://leetcode.com/discuss/interview-question/1648418/Amazon-Find-Common-Manager"
                    },
                    {
                        "username": "tchola",
                        "content": "For this input\\n\\n[37,-34,-48,null,-100,-101,48,null,null,null,null,-54,null,-71,-22,null,null,null,8]\\n-71\\n8\\n\\nIf this is a binary tree array representation, why is not parent of 8 a null value. I mean, if index of 8 is \\'18\\', the parent should be floor((18-1)/2) = 8 -> null\\n\\nCan someone explain this representation, please?"
                    },
                    {
                        "username": "nag418",
                        "content": "Question Note: what will  happen if the nodes\\' values are not unique\\n\\nIf the ndoes\\' value are not unique, how to slove?"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Go through all of my accepted submissions to find the difference between each submission. (I have backtracked using if else wherever possible :p)\\nGo through CTCI also\\nGo through LC solution 1 and 2 also\\n\\nNote:\\nThis question taught me the importance of drawing out examples:![image](https://assets.leetcode.com/users/images/aab57a9e-2250-46af-b595-2988fab530cd_1606070614.143661.png)\\n"
                    },
                    {
                        "username": "serenali",
                        "content": "what if one of the input node is not in the bst? what\\'s the solution? How can you solve it with DFS?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27 2020\\nIt is a good idea to put together a post to list all my past practice and also learning experience together up to May 27, 2020. \\n\\n\\n[C# Data structure talk: List, Stack, Queue, HashMap, HashSet and Tuple](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655785/C-Data-structure-talk%3A-List-Stack-Queue-HashMap-HashSet-and-Tuple)\\n[C# Recursive function design collections from 2019 to 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655638/C-Recursive-function-design-collections-from-2019-to-2020)\\n[C# various topics covered in 2020 practice](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655518/C-various-topics-covered-in-2020-practice)\\n[C# various topics covered through 2019 practice](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290650/C-various-topics-covered-through-2019-practice)\\n\\n"
                    },
                    {
                        "username": "pauldeepakraj",
                        "content": "Wanted to see what would be the solution for finding the lowest common ancestor of a N-ary(many children) tree?"
                    },
                    {
                        "username": "samuelsun1888",
                        "content": "Am I the only one who has this problem?"
                    },
                    {
                        "username": "bury",
                        "content": "This test case is having duplicate values of -100, which happens to be in the input as well.\\nThis TC seems to be in C++ TC list only. My equivalent Java code passed with no failures. Anyone else is having this issue?\\n\\n[37,-34,-48,null,-100,-100,48,null,null,null,null,-54,null,-71,-22,null,null,null,8]\\nnode with value -100\\nnode with value -71"
                    }
                ]
            },
            {
                "id": 1576127,
                "content": [
                    {
                        "username": "ravitejrai123",
                        "content": "Can some body explain it to me ? \\nIs it because the tree size is small and there are only a few calls to the recursion stack ?\\n\\n"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "https://leetcode.com/discuss/interview-question/1648418/Amazon-Find-Common-Manager"
                    },
                    {
                        "username": "tchola",
                        "content": "For this input\\n\\n[37,-34,-48,null,-100,-101,48,null,null,null,null,-54,null,-71,-22,null,null,null,8]\\n-71\\n8\\n\\nIf this is a binary tree array representation, why is not parent of 8 a null value. I mean, if index of 8 is \\'18\\', the parent should be floor((18-1)/2) = 8 -> null\\n\\nCan someone explain this representation, please?"
                    },
                    {
                        "username": "nag418",
                        "content": "Question Note: what will  happen if the nodes\\' values are not unique\\n\\nIf the ndoes\\' value are not unique, how to slove?"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Go through all of my accepted submissions to find the difference between each submission. (I have backtracked using if else wherever possible :p)\\nGo through CTCI also\\nGo through LC solution 1 and 2 also\\n\\nNote:\\nThis question taught me the importance of drawing out examples:![image](https://assets.leetcode.com/users/images/aab57a9e-2250-46af-b595-2988fab530cd_1606070614.143661.png)\\n"
                    },
                    {
                        "username": "serenali",
                        "content": "what if one of the input node is not in the bst? what\\'s the solution? How can you solve it with DFS?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27 2020\\nIt is a good idea to put together a post to list all my past practice and also learning experience together up to May 27, 2020. \\n\\n\\n[C# Data structure talk: List, Stack, Queue, HashMap, HashSet and Tuple](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655785/C-Data-structure-talk%3A-List-Stack-Queue-HashMap-HashSet-and-Tuple)\\n[C# Recursive function design collections from 2019 to 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655638/C-Recursive-function-design-collections-from-2019-to-2020)\\n[C# various topics covered in 2020 practice](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655518/C-various-topics-covered-in-2020-practice)\\n[C# various topics covered through 2019 practice](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290650/C-various-topics-covered-through-2019-practice)\\n\\n"
                    },
                    {
                        "username": "pauldeepakraj",
                        "content": "Wanted to see what would be the solution for finding the lowest common ancestor of a N-ary(many children) tree?"
                    },
                    {
                        "username": "samuelsun1888",
                        "content": "Am I the only one who has this problem?"
                    },
                    {
                        "username": "bury",
                        "content": "This test case is having duplicate values of -100, which happens to be in the input as well.\\nThis TC seems to be in C++ TC list only. My equivalent Java code passed with no failures. Anyone else is having this issue?\\n\\n[37,-34,-48,null,-100,-100,48,null,null,null,null,-54,null,-71,-22,null,null,null,8]\\nnode with value -100\\nnode with value -71"
                    }
                ]
            },
            {
                "id": 1575846,
                "content": [
                    {
                        "username": "ravitejrai123",
                        "content": "Can some body explain it to me ? \\nIs it because the tree size is small and there are only a few calls to the recursion stack ?\\n\\n"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "https://leetcode.com/discuss/interview-question/1648418/Amazon-Find-Common-Manager"
                    },
                    {
                        "username": "tchola",
                        "content": "For this input\\n\\n[37,-34,-48,null,-100,-101,48,null,null,null,null,-54,null,-71,-22,null,null,null,8]\\n-71\\n8\\n\\nIf this is a binary tree array representation, why is not parent of 8 a null value. I mean, if index of 8 is \\'18\\', the parent should be floor((18-1)/2) = 8 -> null\\n\\nCan someone explain this representation, please?"
                    },
                    {
                        "username": "nag418",
                        "content": "Question Note: what will  happen if the nodes\\' values are not unique\\n\\nIf the ndoes\\' value are not unique, how to slove?"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Go through all of my accepted submissions to find the difference between each submission. (I have backtracked using if else wherever possible :p)\\nGo through CTCI also\\nGo through LC solution 1 and 2 also\\n\\nNote:\\nThis question taught me the importance of drawing out examples:![image](https://assets.leetcode.com/users/images/aab57a9e-2250-46af-b595-2988fab530cd_1606070614.143661.png)\\n"
                    },
                    {
                        "username": "serenali",
                        "content": "what if one of the input node is not in the bst? what\\'s the solution? How can you solve it with DFS?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27 2020\\nIt is a good idea to put together a post to list all my past practice and also learning experience together up to May 27, 2020. \\n\\n\\n[C# Data structure talk: List, Stack, Queue, HashMap, HashSet and Tuple](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655785/C-Data-structure-talk%3A-List-Stack-Queue-HashMap-HashSet-and-Tuple)\\n[C# Recursive function design collections from 2019 to 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655638/C-Recursive-function-design-collections-from-2019-to-2020)\\n[C# various topics covered in 2020 practice](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655518/C-various-topics-covered-in-2020-practice)\\n[C# various topics covered through 2019 practice](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290650/C-various-topics-covered-through-2019-practice)\\n\\n"
                    },
                    {
                        "username": "pauldeepakraj",
                        "content": "Wanted to see what would be the solution for finding the lowest common ancestor of a N-ary(many children) tree?"
                    },
                    {
                        "username": "samuelsun1888",
                        "content": "Am I the only one who has this problem?"
                    },
                    {
                        "username": "bury",
                        "content": "This test case is having duplicate values of -100, which happens to be in the input as well.\\nThis TC seems to be in C++ TC list only. My equivalent Java code passed with no failures. Anyone else is having this issue?\\n\\n[37,-34,-48,null,-100,-100,48,null,null,null,null,-54,null,-71,-22,null,null,null,8]\\nnode with value -100\\nnode with value -71"
                    }
                ]
            },
            {
                "id": 1573438,
                "content": [
                    {
                        "username": "ravitejrai123",
                        "content": "Can some body explain it to me ? \\nIs it because the tree size is small and there are only a few calls to the recursion stack ?\\n\\n"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "https://leetcode.com/discuss/interview-question/1648418/Amazon-Find-Common-Manager"
                    },
                    {
                        "username": "tchola",
                        "content": "For this input\\n\\n[37,-34,-48,null,-100,-101,48,null,null,null,null,-54,null,-71,-22,null,null,null,8]\\n-71\\n8\\n\\nIf this is a binary tree array representation, why is not parent of 8 a null value. I mean, if index of 8 is \\'18\\', the parent should be floor((18-1)/2) = 8 -> null\\n\\nCan someone explain this representation, please?"
                    },
                    {
                        "username": "nag418",
                        "content": "Question Note: what will  happen if the nodes\\' values are not unique\\n\\nIf the ndoes\\' value are not unique, how to slove?"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Go through all of my accepted submissions to find the difference between each submission. (I have backtracked using if else wherever possible :p)\\nGo through CTCI also\\nGo through LC solution 1 and 2 also\\n\\nNote:\\nThis question taught me the importance of drawing out examples:![image](https://assets.leetcode.com/users/images/aab57a9e-2250-46af-b595-2988fab530cd_1606070614.143661.png)\\n"
                    },
                    {
                        "username": "serenali",
                        "content": "what if one of the input node is not in the bst? what\\'s the solution? How can you solve it with DFS?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27 2020\\nIt is a good idea to put together a post to list all my past practice and also learning experience together up to May 27, 2020. \\n\\n\\n[C# Data structure talk: List, Stack, Queue, HashMap, HashSet and Tuple](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655785/C-Data-structure-talk%3A-List-Stack-Queue-HashMap-HashSet-and-Tuple)\\n[C# Recursive function design collections from 2019 to 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655638/C-Recursive-function-design-collections-from-2019-to-2020)\\n[C# various topics covered in 2020 practice](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655518/C-various-topics-covered-in-2020-practice)\\n[C# various topics covered through 2019 practice](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290650/C-various-topics-covered-through-2019-practice)\\n\\n"
                    },
                    {
                        "username": "pauldeepakraj",
                        "content": "Wanted to see what would be the solution for finding the lowest common ancestor of a N-ary(many children) tree?"
                    },
                    {
                        "username": "samuelsun1888",
                        "content": "Am I the only one who has this problem?"
                    },
                    {
                        "username": "bury",
                        "content": "This test case is having duplicate values of -100, which happens to be in the input as well.\\nThis TC seems to be in C++ TC list only. My equivalent Java code passed with no failures. Anyone else is having this issue?\\n\\n[37,-34,-48,null,-100,-100,48,null,null,null,null,-54,null,-71,-22,null,null,null,8]\\nnode with value -100\\nnode with value -71"
                    }
                ]
            },
            {
                "id": 1574616,
                "content": [
                    {
                        "username": "ravitejrai123",
                        "content": "Can some body explain it to me ? \\nIs it because the tree size is small and there are only a few calls to the recursion stack ?\\n\\n"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "https://leetcode.com/discuss/interview-question/1648418/Amazon-Find-Common-Manager"
                    },
                    {
                        "username": "tchola",
                        "content": "For this input\\n\\n[37,-34,-48,null,-100,-101,48,null,null,null,null,-54,null,-71,-22,null,null,null,8]\\n-71\\n8\\n\\nIf this is a binary tree array representation, why is not parent of 8 a null value. I mean, if index of 8 is \\'18\\', the parent should be floor((18-1)/2) = 8 -> null\\n\\nCan someone explain this representation, please?"
                    },
                    {
                        "username": "nag418",
                        "content": "Question Note: what will  happen if the nodes\\' values are not unique\\n\\nIf the ndoes\\' value are not unique, how to slove?"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Go through all of my accepted submissions to find the difference between each submission. (I have backtracked using if else wherever possible :p)\\nGo through CTCI also\\nGo through LC solution 1 and 2 also\\n\\nNote:\\nThis question taught me the importance of drawing out examples:![image](https://assets.leetcode.com/users/images/aab57a9e-2250-46af-b595-2988fab530cd_1606070614.143661.png)\\n"
                    },
                    {
                        "username": "serenali",
                        "content": "what if one of the input node is not in the bst? what\\'s the solution? How can you solve it with DFS?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27 2020\\nIt is a good idea to put together a post to list all my past practice and also learning experience together up to May 27, 2020. \\n\\n\\n[C# Data structure talk: List, Stack, Queue, HashMap, HashSet and Tuple](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655785/C-Data-structure-talk%3A-List-Stack-Queue-HashMap-HashSet-and-Tuple)\\n[C# Recursive function design collections from 2019 to 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655638/C-Recursive-function-design-collections-from-2019-to-2020)\\n[C# various topics covered in 2020 practice](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655518/C-various-topics-covered-in-2020-practice)\\n[C# various topics covered through 2019 practice](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290650/C-various-topics-covered-through-2019-practice)\\n\\n"
                    },
                    {
                        "username": "pauldeepakraj",
                        "content": "Wanted to see what would be the solution for finding the lowest common ancestor of a N-ary(many children) tree?"
                    },
                    {
                        "username": "samuelsun1888",
                        "content": "Am I the only one who has this problem?"
                    },
                    {
                        "username": "bury",
                        "content": "This test case is having duplicate values of -100, which happens to be in the input as well.\\nThis TC seems to be in C++ TC list only. My equivalent Java code passed with no failures. Anyone else is having this issue?\\n\\n[37,-34,-48,null,-100,-100,48,null,null,null,null,-54,null,-71,-22,null,null,null,8]\\nnode with value -100\\nnode with value -71"
                    }
                ]
            },
            {
                "id": 1574561,
                "content": [
                    {
                        "username": "ravitejrai123",
                        "content": "Can some body explain it to me ? \\nIs it because the tree size is small and there are only a few calls to the recursion stack ?\\n\\n"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "https://leetcode.com/discuss/interview-question/1648418/Amazon-Find-Common-Manager"
                    },
                    {
                        "username": "tchola",
                        "content": "For this input\\n\\n[37,-34,-48,null,-100,-101,48,null,null,null,null,-54,null,-71,-22,null,null,null,8]\\n-71\\n8\\n\\nIf this is a binary tree array representation, why is not parent of 8 a null value. I mean, if index of 8 is \\'18\\', the parent should be floor((18-1)/2) = 8 -> null\\n\\nCan someone explain this representation, please?"
                    },
                    {
                        "username": "nag418",
                        "content": "Question Note: what will  happen if the nodes\\' values are not unique\\n\\nIf the ndoes\\' value are not unique, how to slove?"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Go through all of my accepted submissions to find the difference between each submission. (I have backtracked using if else wherever possible :p)\\nGo through CTCI also\\nGo through LC solution 1 and 2 also\\n\\nNote:\\nThis question taught me the importance of drawing out examples:![image](https://assets.leetcode.com/users/images/aab57a9e-2250-46af-b595-2988fab530cd_1606070614.143661.png)\\n"
                    },
                    {
                        "username": "serenali",
                        "content": "what if one of the input node is not in the bst? what\\'s the solution? How can you solve it with DFS?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27 2020\\nIt is a good idea to put together a post to list all my past practice and also learning experience together up to May 27, 2020. \\n\\n\\n[C# Data structure talk: List, Stack, Queue, HashMap, HashSet and Tuple](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655785/C-Data-structure-talk%3A-List-Stack-Queue-HashMap-HashSet-and-Tuple)\\n[C# Recursive function design collections from 2019 to 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655638/C-Recursive-function-design-collections-from-2019-to-2020)\\n[C# various topics covered in 2020 practice](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655518/C-various-topics-covered-in-2020-practice)\\n[C# various topics covered through 2019 practice](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290650/C-various-topics-covered-through-2019-practice)\\n\\n"
                    },
                    {
                        "username": "pauldeepakraj",
                        "content": "Wanted to see what would be the solution for finding the lowest common ancestor of a N-ary(many children) tree?"
                    },
                    {
                        "username": "samuelsun1888",
                        "content": "Am I the only one who has this problem?"
                    },
                    {
                        "username": "bury",
                        "content": "This test case is having duplicate values of -100, which happens to be in the input as well.\\nThis TC seems to be in C++ TC list only. My equivalent Java code passed with no failures. Anyone else is having this issue?\\n\\n[37,-34,-48,null,-100,-100,48,null,null,null,null,-54,null,-71,-22,null,null,null,8]\\nnode with value -100\\nnode with value -71"
                    }
                ]
            },
            {
                "id": 1573826,
                "content": [
                    {
                        "username": "ravitejrai123",
                        "content": "Can some body explain it to me ? \\nIs it because the tree size is small and there are only a few calls to the recursion stack ?\\n\\n"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "https://leetcode.com/discuss/interview-question/1648418/Amazon-Find-Common-Manager"
                    },
                    {
                        "username": "tchola",
                        "content": "For this input\\n\\n[37,-34,-48,null,-100,-101,48,null,null,null,null,-54,null,-71,-22,null,null,null,8]\\n-71\\n8\\n\\nIf this is a binary tree array representation, why is not parent of 8 a null value. I mean, if index of 8 is \\'18\\', the parent should be floor((18-1)/2) = 8 -> null\\n\\nCan someone explain this representation, please?"
                    },
                    {
                        "username": "nag418",
                        "content": "Question Note: what will  happen if the nodes\\' values are not unique\\n\\nIf the ndoes\\' value are not unique, how to slove?"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Go through all of my accepted submissions to find the difference between each submission. (I have backtracked using if else wherever possible :p)\\nGo through CTCI also\\nGo through LC solution 1 and 2 also\\n\\nNote:\\nThis question taught me the importance of drawing out examples:![image](https://assets.leetcode.com/users/images/aab57a9e-2250-46af-b595-2988fab530cd_1606070614.143661.png)\\n"
                    },
                    {
                        "username": "serenali",
                        "content": "what if one of the input node is not in the bst? what\\'s the solution? How can you solve it with DFS?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27 2020\\nIt is a good idea to put together a post to list all my past practice and also learning experience together up to May 27, 2020. \\n\\n\\n[C# Data structure talk: List, Stack, Queue, HashMap, HashSet and Tuple](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655785/C-Data-structure-talk%3A-List-Stack-Queue-HashMap-HashSet-and-Tuple)\\n[C# Recursive function design collections from 2019 to 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655638/C-Recursive-function-design-collections-from-2019-to-2020)\\n[C# various topics covered in 2020 practice](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655518/C-various-topics-covered-in-2020-practice)\\n[C# various topics covered through 2019 practice](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290650/C-various-topics-covered-through-2019-practice)\\n\\n"
                    },
                    {
                        "username": "pauldeepakraj",
                        "content": "Wanted to see what would be the solution for finding the lowest common ancestor of a N-ary(many children) tree?"
                    },
                    {
                        "username": "samuelsun1888",
                        "content": "Am I the only one who has this problem?"
                    },
                    {
                        "username": "bury",
                        "content": "This test case is having duplicate values of -100, which happens to be in the input as well.\\nThis TC seems to be in C++ TC list only. My equivalent Java code passed with no failures. Anyone else is having this issue?\\n\\n[37,-34,-48,null,-100,-100,48,null,null,null,null,-54,null,-71,-22,null,null,null,8]\\nnode with value -100\\nnode with value -71"
                    }
                ]
            },
            {
                "id": 1572384,
                "content": [
                    {
                        "username": "ravitejrai123",
                        "content": "Can some body explain it to me ? \\nIs it because the tree size is small and there are only a few calls to the recursion stack ?\\n\\n"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "https://leetcode.com/discuss/interview-question/1648418/Amazon-Find-Common-Manager"
                    },
                    {
                        "username": "tchola",
                        "content": "For this input\\n\\n[37,-34,-48,null,-100,-101,48,null,null,null,null,-54,null,-71,-22,null,null,null,8]\\n-71\\n8\\n\\nIf this is a binary tree array representation, why is not parent of 8 a null value. I mean, if index of 8 is \\'18\\', the parent should be floor((18-1)/2) = 8 -> null\\n\\nCan someone explain this representation, please?"
                    },
                    {
                        "username": "nag418",
                        "content": "Question Note: what will  happen if the nodes\\' values are not unique\\n\\nIf the ndoes\\' value are not unique, how to slove?"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Go through all of my accepted submissions to find the difference between each submission. (I have backtracked using if else wherever possible :p)\\nGo through CTCI also\\nGo through LC solution 1 and 2 also\\n\\nNote:\\nThis question taught me the importance of drawing out examples:![image](https://assets.leetcode.com/users/images/aab57a9e-2250-46af-b595-2988fab530cd_1606070614.143661.png)\\n"
                    },
                    {
                        "username": "serenali",
                        "content": "what if one of the input node is not in the bst? what\\'s the solution? How can you solve it with DFS?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27 2020\\nIt is a good idea to put together a post to list all my past practice and also learning experience together up to May 27, 2020. \\n\\n\\n[C# Data structure talk: List, Stack, Queue, HashMap, HashSet and Tuple](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655785/C-Data-structure-talk%3A-List-Stack-Queue-HashMap-HashSet-and-Tuple)\\n[C# Recursive function design collections from 2019 to 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655638/C-Recursive-function-design-collections-from-2019-to-2020)\\n[C# various topics covered in 2020 practice](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655518/C-various-topics-covered-in-2020-practice)\\n[C# various topics covered through 2019 practice](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290650/C-various-topics-covered-through-2019-practice)\\n\\n"
                    },
                    {
                        "username": "pauldeepakraj",
                        "content": "Wanted to see what would be the solution for finding the lowest common ancestor of a N-ary(many children) tree?"
                    },
                    {
                        "username": "samuelsun1888",
                        "content": "Am I the only one who has this problem?"
                    },
                    {
                        "username": "bury",
                        "content": "This test case is having duplicate values of -100, which happens to be in the input as well.\\nThis TC seems to be in C++ TC list only. My equivalent Java code passed with no failures. Anyone else is having this issue?\\n\\n[37,-34,-48,null,-100,-100,48,null,null,null,null,-54,null,-71,-22,null,null,null,8]\\nnode with value -100\\nnode with value -71"
                    }
                ]
            },
            {
                "id": 1571474,
                "content": [
                    {
                        "username": "ravitejrai123",
                        "content": "Can some body explain it to me ? \\nIs it because the tree size is small and there are only a few calls to the recursion stack ?\\n\\n"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "https://leetcode.com/discuss/interview-question/1648418/Amazon-Find-Common-Manager"
                    },
                    {
                        "username": "tchola",
                        "content": "For this input\\n\\n[37,-34,-48,null,-100,-101,48,null,null,null,null,-54,null,-71,-22,null,null,null,8]\\n-71\\n8\\n\\nIf this is a binary tree array representation, why is not parent of 8 a null value. I mean, if index of 8 is \\'18\\', the parent should be floor((18-1)/2) = 8 -> null\\n\\nCan someone explain this representation, please?"
                    },
                    {
                        "username": "nag418",
                        "content": "Question Note: what will  happen if the nodes\\' values are not unique\\n\\nIf the ndoes\\' value are not unique, how to slove?"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Go through all of my accepted submissions to find the difference between each submission. (I have backtracked using if else wherever possible :p)\\nGo through CTCI also\\nGo through LC solution 1 and 2 also\\n\\nNote:\\nThis question taught me the importance of drawing out examples:![image](https://assets.leetcode.com/users/images/aab57a9e-2250-46af-b595-2988fab530cd_1606070614.143661.png)\\n"
                    },
                    {
                        "username": "serenali",
                        "content": "what if one of the input node is not in the bst? what\\'s the solution? How can you solve it with DFS?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27 2020\\nIt is a good idea to put together a post to list all my past practice and also learning experience together up to May 27, 2020. \\n\\n\\n[C# Data structure talk: List, Stack, Queue, HashMap, HashSet and Tuple](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655785/C-Data-structure-talk%3A-List-Stack-Queue-HashMap-HashSet-and-Tuple)\\n[C# Recursive function design collections from 2019 to 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655638/C-Recursive-function-design-collections-from-2019-to-2020)\\n[C# various topics covered in 2020 practice](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655518/C-various-topics-covered-in-2020-practice)\\n[C# various topics covered through 2019 practice](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290650/C-various-topics-covered-through-2019-practice)\\n\\n"
                    },
                    {
                        "username": "pauldeepakraj",
                        "content": "Wanted to see what would be the solution for finding the lowest common ancestor of a N-ary(many children) tree?"
                    },
                    {
                        "username": "samuelsun1888",
                        "content": "Am I the only one who has this problem?"
                    },
                    {
                        "username": "bury",
                        "content": "This test case is having duplicate values of -100, which happens to be in the input as well.\\nThis TC seems to be in C++ TC list only. My equivalent Java code passed with no failures. Anyone else is having this issue?\\n\\n[37,-34,-48,null,-100,-100,48,null,null,null,null,-54,null,-71,-22,null,null,null,8]\\nnode with value -100\\nnode with value -71"
                    }
                ]
            },
            {
                "id": 1571476,
                "content": [
                    {
                        "username": "ravitejrai123",
                        "content": "Can some body explain it to me ? \\nIs it because the tree size is small and there are only a few calls to the recursion stack ?\\n\\n"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "https://leetcode.com/discuss/interview-question/1648418/Amazon-Find-Common-Manager"
                    },
                    {
                        "username": "tchola",
                        "content": "For this input\\n\\n[37,-34,-48,null,-100,-101,48,null,null,null,null,-54,null,-71,-22,null,null,null,8]\\n-71\\n8\\n\\nIf this is a binary tree array representation, why is not parent of 8 a null value. I mean, if index of 8 is \\'18\\', the parent should be floor((18-1)/2) = 8 -> null\\n\\nCan someone explain this representation, please?"
                    },
                    {
                        "username": "nag418",
                        "content": "Question Note: what will  happen if the nodes\\' values are not unique\\n\\nIf the ndoes\\' value are not unique, how to slove?"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Go through all of my accepted submissions to find the difference between each submission. (I have backtracked using if else wherever possible :p)\\nGo through CTCI also\\nGo through LC solution 1 and 2 also\\n\\nNote:\\nThis question taught me the importance of drawing out examples:![image](https://assets.leetcode.com/users/images/aab57a9e-2250-46af-b595-2988fab530cd_1606070614.143661.png)\\n"
                    },
                    {
                        "username": "serenali",
                        "content": "what if one of the input node is not in the bst? what\\'s the solution? How can you solve it with DFS?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27 2020\\nIt is a good idea to put together a post to list all my past practice and also learning experience together up to May 27, 2020. \\n\\n\\n[C# Data structure talk: List, Stack, Queue, HashMap, HashSet and Tuple](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655785/C-Data-structure-talk%3A-List-Stack-Queue-HashMap-HashSet-and-Tuple)\\n[C# Recursive function design collections from 2019 to 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655638/C-Recursive-function-design-collections-from-2019-to-2020)\\n[C# various topics covered in 2020 practice](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655518/C-various-topics-covered-in-2020-practice)\\n[C# various topics covered through 2019 practice](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290650/C-various-topics-covered-through-2019-practice)\\n\\n"
                    },
                    {
                        "username": "pauldeepakraj",
                        "content": "Wanted to see what would be the solution for finding the lowest common ancestor of a N-ary(many children) tree?"
                    },
                    {
                        "username": "samuelsun1888",
                        "content": "Am I the only one who has this problem?"
                    },
                    {
                        "username": "bury",
                        "content": "This test case is having duplicate values of -100, which happens to be in the input as well.\\nThis TC seems to be in C++ TC list only. My equivalent Java code passed with no failures. Anyone else is having this issue?\\n\\n[37,-34,-48,null,-100,-100,48,null,null,null,null,-54,null,-71,-22,null,null,null,8]\\nnode with value -100\\nnode with value -71"
                    }
                ]
            },
            {
                "id": 1571477,
                "content": [
                    {
                        "username": "xuan18",
                        "content": "It is the last test case (test case number as 31 I remember). \\nI'm using Java. If you use a different language and (I don't know) have a different test case, please ignore my question.\\n\\nIn this test case, p.val==91, and q.val==93. There are more than 2000 nodes given in the serialization of the tree, roughly half of them being null.\\n\\nMy program gives 91. However the OJ says it should be 10. I looked into it. There is a node with val==91 and depth==9 (the root is considered to have depth 0, and each node has depth 1 smaller than its children) that has 91 and 93 as descendants (itself being considered one of its descendants, according to the description). There are six nodes with value 10, their depths being 1,7,8,9,11,13, among which, the ones with depths 9, 11, and 13 do not have both 91 and 93 as descendants.\\n\\nI'm doing an in-order traverse of the tree. Let's first assume that the values of nodes are distinct. Now list all the non-null nodes in the order of in-order traverse (I don't actually form a list, but just to say it for convenience), for any two nodes that appear in the list, their least common ancestor is the (unique) one between them in the list (both of them included) that has minimum depth (it's not hard to keep track of the depth of each node in the traversal). If the values are not distinct and p.val and/or q.val appear multiple times, or p.val==q.val, just some simple modifications are needed. I'm not posting my program since I don't think anyone is taking the trouble to read it (or even this post).\\n\\nI saw many posts that first dive into the left subtree and then the right subtree. So now I'm aware of that although I have doubts... (in case the depth is not well maintained, a result \"deep\" in the left subtree could be replaced by a \"shallow\" result in the right subtree... anyway, I didn't think about it carefully. Forget about it).\\n\\nSo... why am I wrong ... or does anyone also get 91 for the last one?"
                    },
                    {
                        "username": "LazyEval",
                        "content": "Looks like image importing is broken, here is a link to the screenshot: http://imgur.com/NR8uRqx\\nNotice that there are no options to \"Run code\" or \"Custom tests\", but only to \"Submit\"\\n\\nUpdate: I triggered run code via keyboard shortcut (ctrl + ') and got this message:\\n\\n**Run Code Status: Failed\\nRun code disabled for this question**\\n\\nany idea if this is expected? Whats the point of disabling run code before submission?"
                    },
                    {
                        "username": "yichenwa",
                        "content": "It cannot pass with concise recursive solution."
                    },
                    {
                        "username": "spamf",
                        "content": "in the example 1 and 2 above, why do left and right branches order look so random - sometimes is left>val>right, sometimes right>val>left, left>right>val?"
                    },
                    {
                        "username": "KarthikRam",
                        "content": "Approach was to figure out to use p and q as references and then use recursion"
                    },
                    {
                        "username": "tanish69",
                        "content": "am I not in thr right senses or test case 31 is just \"nothing\"? its not showing any input? and its causing TLE in my code?"
                    },
                    {
                        "username": "dleyba042",
                        "content": "What is the point of making a binary tree that does not conform to a specific type of ordering??? ex. go left if smaller and right if larger."
                    },
                    {
                        "username": "Anik_Banerjee",
                        "content": "Can  someone explain how to tackle a follow up which asks what will happen if one of p or q  is not present ?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I do not understand what should we do.\\n\\nWe can find LCA with O(log N) time complexity if we knew parent node for each node in tree. But we don\\'t.\\n\\nSo, just to find parents we spend O(N). In this case we can traverse all nodes and mark are they ancestors or not..."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "are those node\\'s values different to each others?"
                    }
                ]
            },
            {
                "id": 1571475,
                "content": [
                    {
                        "username": "xuan18",
                        "content": "It is the last test case (test case number as 31 I remember). \\nI'm using Java. If you use a different language and (I don't know) have a different test case, please ignore my question.\\n\\nIn this test case, p.val==91, and q.val==93. There are more than 2000 nodes given in the serialization of the tree, roughly half of them being null.\\n\\nMy program gives 91. However the OJ says it should be 10. I looked into it. There is a node with val==91 and depth==9 (the root is considered to have depth 0, and each node has depth 1 smaller than its children) that has 91 and 93 as descendants (itself being considered one of its descendants, according to the description). There are six nodes with value 10, their depths being 1,7,8,9,11,13, among which, the ones with depths 9, 11, and 13 do not have both 91 and 93 as descendants.\\n\\nI'm doing an in-order traverse of the tree. Let's first assume that the values of nodes are distinct. Now list all the non-null nodes in the order of in-order traverse (I don't actually form a list, but just to say it for convenience), for any two nodes that appear in the list, their least common ancestor is the (unique) one between them in the list (both of them included) that has minimum depth (it's not hard to keep track of the depth of each node in the traversal). If the values are not distinct and p.val and/or q.val appear multiple times, or p.val==q.val, just some simple modifications are needed. I'm not posting my program since I don't think anyone is taking the trouble to read it (or even this post).\\n\\nI saw many posts that first dive into the left subtree and then the right subtree. So now I'm aware of that although I have doubts... (in case the depth is not well maintained, a result \"deep\" in the left subtree could be replaced by a \"shallow\" result in the right subtree... anyway, I didn't think about it carefully. Forget about it).\\n\\nSo... why am I wrong ... or does anyone also get 91 for the last one?"
                    },
                    {
                        "username": "LazyEval",
                        "content": "Looks like image importing is broken, here is a link to the screenshot: http://imgur.com/NR8uRqx\\nNotice that there are no options to \"Run code\" or \"Custom tests\", but only to \"Submit\"\\n\\nUpdate: I triggered run code via keyboard shortcut (ctrl + ') and got this message:\\n\\n**Run Code Status: Failed\\nRun code disabled for this question**\\n\\nany idea if this is expected? Whats the point of disabling run code before submission?"
                    },
                    {
                        "username": "yichenwa",
                        "content": "It cannot pass with concise recursive solution."
                    },
                    {
                        "username": "spamf",
                        "content": "in the example 1 and 2 above, why do left and right branches order look so random - sometimes is left>val>right, sometimes right>val>left, left>right>val?"
                    },
                    {
                        "username": "KarthikRam",
                        "content": "Approach was to figure out to use p and q as references and then use recursion"
                    },
                    {
                        "username": "tanish69",
                        "content": "am I not in thr right senses or test case 31 is just \"nothing\"? its not showing any input? and its causing TLE in my code?"
                    },
                    {
                        "username": "dleyba042",
                        "content": "What is the point of making a binary tree that does not conform to a specific type of ordering??? ex. go left if smaller and right if larger."
                    },
                    {
                        "username": "Anik_Banerjee",
                        "content": "Can  someone explain how to tackle a follow up which asks what will happen if one of p or q  is not present ?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I do not understand what should we do.\\n\\nWe can find LCA with O(log N) time complexity if we knew parent node for each node in tree. But we don\\'t.\\n\\nSo, just to find parents we spend O(N). In this case we can traverse all nodes and mark are they ancestors or not..."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "are those node\\'s values different to each others?"
                    }
                ]
            },
            {
                "id": 1568020,
                "content": [
                    {
                        "username": "xuan18",
                        "content": "It is the last test case (test case number as 31 I remember). \\nI'm using Java. If you use a different language and (I don't know) have a different test case, please ignore my question.\\n\\nIn this test case, p.val==91, and q.val==93. There are more than 2000 nodes given in the serialization of the tree, roughly half of them being null.\\n\\nMy program gives 91. However the OJ says it should be 10. I looked into it. There is a node with val==91 and depth==9 (the root is considered to have depth 0, and each node has depth 1 smaller than its children) that has 91 and 93 as descendants (itself being considered one of its descendants, according to the description). There are six nodes with value 10, their depths being 1,7,8,9,11,13, among which, the ones with depths 9, 11, and 13 do not have both 91 and 93 as descendants.\\n\\nI'm doing an in-order traverse of the tree. Let's first assume that the values of nodes are distinct. Now list all the non-null nodes in the order of in-order traverse (I don't actually form a list, but just to say it for convenience), for any two nodes that appear in the list, their least common ancestor is the (unique) one between them in the list (both of them included) that has minimum depth (it's not hard to keep track of the depth of each node in the traversal). If the values are not distinct and p.val and/or q.val appear multiple times, or p.val==q.val, just some simple modifications are needed. I'm not posting my program since I don't think anyone is taking the trouble to read it (or even this post).\\n\\nI saw many posts that first dive into the left subtree and then the right subtree. So now I'm aware of that although I have doubts... (in case the depth is not well maintained, a result \"deep\" in the left subtree could be replaced by a \"shallow\" result in the right subtree... anyway, I didn't think about it carefully. Forget about it).\\n\\nSo... why am I wrong ... or does anyone also get 91 for the last one?"
                    },
                    {
                        "username": "LazyEval",
                        "content": "Looks like image importing is broken, here is a link to the screenshot: http://imgur.com/NR8uRqx\\nNotice that there are no options to \"Run code\" or \"Custom tests\", but only to \"Submit\"\\n\\nUpdate: I triggered run code via keyboard shortcut (ctrl + ') and got this message:\\n\\n**Run Code Status: Failed\\nRun code disabled for this question**\\n\\nany idea if this is expected? Whats the point of disabling run code before submission?"
                    },
                    {
                        "username": "yichenwa",
                        "content": "It cannot pass with concise recursive solution."
                    },
                    {
                        "username": "spamf",
                        "content": "in the example 1 and 2 above, why do left and right branches order look so random - sometimes is left>val>right, sometimes right>val>left, left>right>val?"
                    },
                    {
                        "username": "KarthikRam",
                        "content": "Approach was to figure out to use p and q as references and then use recursion"
                    },
                    {
                        "username": "tanish69",
                        "content": "am I not in thr right senses or test case 31 is just \"nothing\"? its not showing any input? and its causing TLE in my code?"
                    },
                    {
                        "username": "dleyba042",
                        "content": "What is the point of making a binary tree that does not conform to a specific type of ordering??? ex. go left if smaller and right if larger."
                    },
                    {
                        "username": "Anik_Banerjee",
                        "content": "Can  someone explain how to tackle a follow up which asks what will happen if one of p or q  is not present ?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I do not understand what should we do.\\n\\nWe can find LCA with O(log N) time complexity if we knew parent node for each node in tree. But we don\\'t.\\n\\nSo, just to find parents we spend O(N). In this case we can traverse all nodes and mark are they ancestors or not..."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "are those node\\'s values different to each others?"
                    }
                ]
            },
            {
                "id": 2071920,
                "content": [
                    {
                        "username": "xuan18",
                        "content": "It is the last test case (test case number as 31 I remember). \\nI'm using Java. If you use a different language and (I don't know) have a different test case, please ignore my question.\\n\\nIn this test case, p.val==91, and q.val==93. There are more than 2000 nodes given in the serialization of the tree, roughly half of them being null.\\n\\nMy program gives 91. However the OJ says it should be 10. I looked into it. There is a node with val==91 and depth==9 (the root is considered to have depth 0, and each node has depth 1 smaller than its children) that has 91 and 93 as descendants (itself being considered one of its descendants, according to the description). There are six nodes with value 10, their depths being 1,7,8,9,11,13, among which, the ones with depths 9, 11, and 13 do not have both 91 and 93 as descendants.\\n\\nI'm doing an in-order traverse of the tree. Let's first assume that the values of nodes are distinct. Now list all the non-null nodes in the order of in-order traverse (I don't actually form a list, but just to say it for convenience), for any two nodes that appear in the list, their least common ancestor is the (unique) one between them in the list (both of them included) that has minimum depth (it's not hard to keep track of the depth of each node in the traversal). If the values are not distinct and p.val and/or q.val appear multiple times, or p.val==q.val, just some simple modifications are needed. I'm not posting my program since I don't think anyone is taking the trouble to read it (or even this post).\\n\\nI saw many posts that first dive into the left subtree and then the right subtree. So now I'm aware of that although I have doubts... (in case the depth is not well maintained, a result \"deep\" in the left subtree could be replaced by a \"shallow\" result in the right subtree... anyway, I didn't think about it carefully. Forget about it).\\n\\nSo... why am I wrong ... or does anyone also get 91 for the last one?"
                    },
                    {
                        "username": "LazyEval",
                        "content": "Looks like image importing is broken, here is a link to the screenshot: http://imgur.com/NR8uRqx\\nNotice that there are no options to \"Run code\" or \"Custom tests\", but only to \"Submit\"\\n\\nUpdate: I triggered run code via keyboard shortcut (ctrl + ') and got this message:\\n\\n**Run Code Status: Failed\\nRun code disabled for this question**\\n\\nany idea if this is expected? Whats the point of disabling run code before submission?"
                    },
                    {
                        "username": "yichenwa",
                        "content": "It cannot pass with concise recursive solution."
                    },
                    {
                        "username": "spamf",
                        "content": "in the example 1 and 2 above, why do left and right branches order look so random - sometimes is left>val>right, sometimes right>val>left, left>right>val?"
                    },
                    {
                        "username": "KarthikRam",
                        "content": "Approach was to figure out to use p and q as references and then use recursion"
                    },
                    {
                        "username": "tanish69",
                        "content": "am I not in thr right senses or test case 31 is just \"nothing\"? its not showing any input? and its causing TLE in my code?"
                    },
                    {
                        "username": "dleyba042",
                        "content": "What is the point of making a binary tree that does not conform to a specific type of ordering??? ex. go left if smaller and right if larger."
                    },
                    {
                        "username": "Anik_Banerjee",
                        "content": "Can  someone explain how to tackle a follow up which asks what will happen if one of p or q  is not present ?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I do not understand what should we do.\\n\\nWe can find LCA with O(log N) time complexity if we knew parent node for each node in tree. But we don\\'t.\\n\\nSo, just to find parents we spend O(N). In this case we can traverse all nodes and mark are they ancestors or not..."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "are those node\\'s values different to each others?"
                    }
                ]
            },
            {
                "id": 2044851,
                "content": [
                    {
                        "username": "xuan18",
                        "content": "It is the last test case (test case number as 31 I remember). \\nI'm using Java. If you use a different language and (I don't know) have a different test case, please ignore my question.\\n\\nIn this test case, p.val==91, and q.val==93. There are more than 2000 nodes given in the serialization of the tree, roughly half of them being null.\\n\\nMy program gives 91. However the OJ says it should be 10. I looked into it. There is a node with val==91 and depth==9 (the root is considered to have depth 0, and each node has depth 1 smaller than its children) that has 91 and 93 as descendants (itself being considered one of its descendants, according to the description). There are six nodes with value 10, their depths being 1,7,8,9,11,13, among which, the ones with depths 9, 11, and 13 do not have both 91 and 93 as descendants.\\n\\nI'm doing an in-order traverse of the tree. Let's first assume that the values of nodes are distinct. Now list all the non-null nodes in the order of in-order traverse (I don't actually form a list, but just to say it for convenience), for any two nodes that appear in the list, their least common ancestor is the (unique) one between them in the list (both of them included) that has minimum depth (it's not hard to keep track of the depth of each node in the traversal). If the values are not distinct and p.val and/or q.val appear multiple times, or p.val==q.val, just some simple modifications are needed. I'm not posting my program since I don't think anyone is taking the trouble to read it (or even this post).\\n\\nI saw many posts that first dive into the left subtree and then the right subtree. So now I'm aware of that although I have doubts... (in case the depth is not well maintained, a result \"deep\" in the left subtree could be replaced by a \"shallow\" result in the right subtree... anyway, I didn't think about it carefully. Forget about it).\\n\\nSo... why am I wrong ... or does anyone also get 91 for the last one?"
                    },
                    {
                        "username": "LazyEval",
                        "content": "Looks like image importing is broken, here is a link to the screenshot: http://imgur.com/NR8uRqx\\nNotice that there are no options to \"Run code\" or \"Custom tests\", but only to \"Submit\"\\n\\nUpdate: I triggered run code via keyboard shortcut (ctrl + ') and got this message:\\n\\n**Run Code Status: Failed\\nRun code disabled for this question**\\n\\nany idea if this is expected? Whats the point of disabling run code before submission?"
                    },
                    {
                        "username": "yichenwa",
                        "content": "It cannot pass with concise recursive solution."
                    },
                    {
                        "username": "spamf",
                        "content": "in the example 1 and 2 above, why do left and right branches order look so random - sometimes is left>val>right, sometimes right>val>left, left>right>val?"
                    },
                    {
                        "username": "KarthikRam",
                        "content": "Approach was to figure out to use p and q as references and then use recursion"
                    },
                    {
                        "username": "tanish69",
                        "content": "am I not in thr right senses or test case 31 is just \"nothing\"? its not showing any input? and its causing TLE in my code?"
                    },
                    {
                        "username": "dleyba042",
                        "content": "What is the point of making a binary tree that does not conform to a specific type of ordering??? ex. go left if smaller and right if larger."
                    },
                    {
                        "username": "Anik_Banerjee",
                        "content": "Can  someone explain how to tackle a follow up which asks what will happen if one of p or q  is not present ?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I do not understand what should we do.\\n\\nWe can find LCA with O(log N) time complexity if we knew parent node for each node in tree. But we don\\'t.\\n\\nSo, just to find parents we spend O(N). In this case we can traverse all nodes and mark are they ancestors or not..."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "are those node\\'s values different to each others?"
                    }
                ]
            },
            {
                "id": 1956067,
                "content": [
                    {
                        "username": "xuan18",
                        "content": "It is the last test case (test case number as 31 I remember). \\nI'm using Java. If you use a different language and (I don't know) have a different test case, please ignore my question.\\n\\nIn this test case, p.val==91, and q.val==93. There are more than 2000 nodes given in the serialization of the tree, roughly half of them being null.\\n\\nMy program gives 91. However the OJ says it should be 10. I looked into it. There is a node with val==91 and depth==9 (the root is considered to have depth 0, and each node has depth 1 smaller than its children) that has 91 and 93 as descendants (itself being considered one of its descendants, according to the description). There are six nodes with value 10, their depths being 1,7,8,9,11,13, among which, the ones with depths 9, 11, and 13 do not have both 91 and 93 as descendants.\\n\\nI'm doing an in-order traverse of the tree. Let's first assume that the values of nodes are distinct. Now list all the non-null nodes in the order of in-order traverse (I don't actually form a list, but just to say it for convenience), for any two nodes that appear in the list, their least common ancestor is the (unique) one between them in the list (both of them included) that has minimum depth (it's not hard to keep track of the depth of each node in the traversal). If the values are not distinct and p.val and/or q.val appear multiple times, or p.val==q.val, just some simple modifications are needed. I'm not posting my program since I don't think anyone is taking the trouble to read it (or even this post).\\n\\nI saw many posts that first dive into the left subtree and then the right subtree. So now I'm aware of that although I have doubts... (in case the depth is not well maintained, a result \"deep\" in the left subtree could be replaced by a \"shallow\" result in the right subtree... anyway, I didn't think about it carefully. Forget about it).\\n\\nSo... why am I wrong ... or does anyone also get 91 for the last one?"
                    },
                    {
                        "username": "LazyEval",
                        "content": "Looks like image importing is broken, here is a link to the screenshot: http://imgur.com/NR8uRqx\\nNotice that there are no options to \"Run code\" or \"Custom tests\", but only to \"Submit\"\\n\\nUpdate: I triggered run code via keyboard shortcut (ctrl + ') and got this message:\\n\\n**Run Code Status: Failed\\nRun code disabled for this question**\\n\\nany idea if this is expected? Whats the point of disabling run code before submission?"
                    },
                    {
                        "username": "yichenwa",
                        "content": "It cannot pass with concise recursive solution."
                    },
                    {
                        "username": "spamf",
                        "content": "in the example 1 and 2 above, why do left and right branches order look so random - sometimes is left>val>right, sometimes right>val>left, left>right>val?"
                    },
                    {
                        "username": "KarthikRam",
                        "content": "Approach was to figure out to use p and q as references and then use recursion"
                    },
                    {
                        "username": "tanish69",
                        "content": "am I not in thr right senses or test case 31 is just \"nothing\"? its not showing any input? and its causing TLE in my code?"
                    },
                    {
                        "username": "dleyba042",
                        "content": "What is the point of making a binary tree that does not conform to a specific type of ordering??? ex. go left if smaller and right if larger."
                    },
                    {
                        "username": "Anik_Banerjee",
                        "content": "Can  someone explain how to tackle a follow up which asks what will happen if one of p or q  is not present ?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I do not understand what should we do.\\n\\nWe can find LCA with O(log N) time complexity if we knew parent node for each node in tree. But we don\\'t.\\n\\nSo, just to find parents we spend O(N). In this case we can traverse all nodes and mark are they ancestors or not..."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "are those node\\'s values different to each others?"
                    }
                ]
            },
            {
                "id": 1933461,
                "content": [
                    {
                        "username": "xuan18",
                        "content": "It is the last test case (test case number as 31 I remember). \\nI'm using Java. If you use a different language and (I don't know) have a different test case, please ignore my question.\\n\\nIn this test case, p.val==91, and q.val==93. There are more than 2000 nodes given in the serialization of the tree, roughly half of them being null.\\n\\nMy program gives 91. However the OJ says it should be 10. I looked into it. There is a node with val==91 and depth==9 (the root is considered to have depth 0, and each node has depth 1 smaller than its children) that has 91 and 93 as descendants (itself being considered one of its descendants, according to the description). There are six nodes with value 10, their depths being 1,7,8,9,11,13, among which, the ones with depths 9, 11, and 13 do not have both 91 and 93 as descendants.\\n\\nI'm doing an in-order traverse of the tree. Let's first assume that the values of nodes are distinct. Now list all the non-null nodes in the order of in-order traverse (I don't actually form a list, but just to say it for convenience), for any two nodes that appear in the list, their least common ancestor is the (unique) one between them in the list (both of them included) that has minimum depth (it's not hard to keep track of the depth of each node in the traversal). If the values are not distinct and p.val and/or q.val appear multiple times, or p.val==q.val, just some simple modifications are needed. I'm not posting my program since I don't think anyone is taking the trouble to read it (or even this post).\\n\\nI saw many posts that first dive into the left subtree and then the right subtree. So now I'm aware of that although I have doubts... (in case the depth is not well maintained, a result \"deep\" in the left subtree could be replaced by a \"shallow\" result in the right subtree... anyway, I didn't think about it carefully. Forget about it).\\n\\nSo... why am I wrong ... or does anyone also get 91 for the last one?"
                    },
                    {
                        "username": "LazyEval",
                        "content": "Looks like image importing is broken, here is a link to the screenshot: http://imgur.com/NR8uRqx\\nNotice that there are no options to \"Run code\" or \"Custom tests\", but only to \"Submit\"\\n\\nUpdate: I triggered run code via keyboard shortcut (ctrl + ') and got this message:\\n\\n**Run Code Status: Failed\\nRun code disabled for this question**\\n\\nany idea if this is expected? Whats the point of disabling run code before submission?"
                    },
                    {
                        "username": "yichenwa",
                        "content": "It cannot pass with concise recursive solution."
                    },
                    {
                        "username": "spamf",
                        "content": "in the example 1 and 2 above, why do left and right branches order look so random - sometimes is left>val>right, sometimes right>val>left, left>right>val?"
                    },
                    {
                        "username": "KarthikRam",
                        "content": "Approach was to figure out to use p and q as references and then use recursion"
                    },
                    {
                        "username": "tanish69",
                        "content": "am I not in thr right senses or test case 31 is just \"nothing\"? its not showing any input? and its causing TLE in my code?"
                    },
                    {
                        "username": "dleyba042",
                        "content": "What is the point of making a binary tree that does not conform to a specific type of ordering??? ex. go left if smaller and right if larger."
                    },
                    {
                        "username": "Anik_Banerjee",
                        "content": "Can  someone explain how to tackle a follow up which asks what will happen if one of p or q  is not present ?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I do not understand what should we do.\\n\\nWe can find LCA with O(log N) time complexity if we knew parent node for each node in tree. But we don\\'t.\\n\\nSo, just to find parents we spend O(N). In this case we can traverse all nodes and mark are they ancestors or not..."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "are those node\\'s values different to each others?"
                    }
                ]
            },
            {
                "id": 1931926,
                "content": [
                    {
                        "username": "xuan18",
                        "content": "It is the last test case (test case number as 31 I remember). \\nI'm using Java. If you use a different language and (I don't know) have a different test case, please ignore my question.\\n\\nIn this test case, p.val==91, and q.val==93. There are more than 2000 nodes given in the serialization of the tree, roughly half of them being null.\\n\\nMy program gives 91. However the OJ says it should be 10. I looked into it. There is a node with val==91 and depth==9 (the root is considered to have depth 0, and each node has depth 1 smaller than its children) that has 91 and 93 as descendants (itself being considered one of its descendants, according to the description). There are six nodes with value 10, their depths being 1,7,8,9,11,13, among which, the ones with depths 9, 11, and 13 do not have both 91 and 93 as descendants.\\n\\nI'm doing an in-order traverse of the tree. Let's first assume that the values of nodes are distinct. Now list all the non-null nodes in the order of in-order traverse (I don't actually form a list, but just to say it for convenience), for any two nodes that appear in the list, their least common ancestor is the (unique) one between them in the list (both of them included) that has minimum depth (it's not hard to keep track of the depth of each node in the traversal). If the values are not distinct and p.val and/or q.val appear multiple times, or p.val==q.val, just some simple modifications are needed. I'm not posting my program since I don't think anyone is taking the trouble to read it (or even this post).\\n\\nI saw many posts that first dive into the left subtree and then the right subtree. So now I'm aware of that although I have doubts... (in case the depth is not well maintained, a result \"deep\" in the left subtree could be replaced by a \"shallow\" result in the right subtree... anyway, I didn't think about it carefully. Forget about it).\\n\\nSo... why am I wrong ... or does anyone also get 91 for the last one?"
                    },
                    {
                        "username": "LazyEval",
                        "content": "Looks like image importing is broken, here is a link to the screenshot: http://imgur.com/NR8uRqx\\nNotice that there are no options to \"Run code\" or \"Custom tests\", but only to \"Submit\"\\n\\nUpdate: I triggered run code via keyboard shortcut (ctrl + ') and got this message:\\n\\n**Run Code Status: Failed\\nRun code disabled for this question**\\n\\nany idea if this is expected? Whats the point of disabling run code before submission?"
                    },
                    {
                        "username": "yichenwa",
                        "content": "It cannot pass with concise recursive solution."
                    },
                    {
                        "username": "spamf",
                        "content": "in the example 1 and 2 above, why do left and right branches order look so random - sometimes is left>val>right, sometimes right>val>left, left>right>val?"
                    },
                    {
                        "username": "KarthikRam",
                        "content": "Approach was to figure out to use p and q as references and then use recursion"
                    },
                    {
                        "username": "tanish69",
                        "content": "am I not in thr right senses or test case 31 is just \"nothing\"? its not showing any input? and its causing TLE in my code?"
                    },
                    {
                        "username": "dleyba042",
                        "content": "What is the point of making a binary tree that does not conform to a specific type of ordering??? ex. go left if smaller and right if larger."
                    },
                    {
                        "username": "Anik_Banerjee",
                        "content": "Can  someone explain how to tackle a follow up which asks what will happen if one of p or q  is not present ?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I do not understand what should we do.\\n\\nWe can find LCA with O(log N) time complexity if we knew parent node for each node in tree. But we don\\'t.\\n\\nSo, just to find parents we spend O(N). In this case we can traverse all nodes and mark are they ancestors or not..."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "are those node\\'s values different to each others?"
                    }
                ]
            },
            {
                "id": 1925231,
                "content": [
                    {
                        "username": "xuan18",
                        "content": "It is the last test case (test case number as 31 I remember). \\nI'm using Java. If you use a different language and (I don't know) have a different test case, please ignore my question.\\n\\nIn this test case, p.val==91, and q.val==93. There are more than 2000 nodes given in the serialization of the tree, roughly half of them being null.\\n\\nMy program gives 91. However the OJ says it should be 10. I looked into it. There is a node with val==91 and depth==9 (the root is considered to have depth 0, and each node has depth 1 smaller than its children) that has 91 and 93 as descendants (itself being considered one of its descendants, according to the description). There are six nodes with value 10, their depths being 1,7,8,9,11,13, among which, the ones with depths 9, 11, and 13 do not have both 91 and 93 as descendants.\\n\\nI'm doing an in-order traverse of the tree. Let's first assume that the values of nodes are distinct. Now list all the non-null nodes in the order of in-order traverse (I don't actually form a list, but just to say it for convenience), for any two nodes that appear in the list, their least common ancestor is the (unique) one between them in the list (both of them included) that has minimum depth (it's not hard to keep track of the depth of each node in the traversal). If the values are not distinct and p.val and/or q.val appear multiple times, or p.val==q.val, just some simple modifications are needed. I'm not posting my program since I don't think anyone is taking the trouble to read it (or even this post).\\n\\nI saw many posts that first dive into the left subtree and then the right subtree. So now I'm aware of that although I have doubts... (in case the depth is not well maintained, a result \"deep\" in the left subtree could be replaced by a \"shallow\" result in the right subtree... anyway, I didn't think about it carefully. Forget about it).\\n\\nSo... why am I wrong ... or does anyone also get 91 for the last one?"
                    },
                    {
                        "username": "LazyEval",
                        "content": "Looks like image importing is broken, here is a link to the screenshot: http://imgur.com/NR8uRqx\\nNotice that there are no options to \"Run code\" or \"Custom tests\", but only to \"Submit\"\\n\\nUpdate: I triggered run code via keyboard shortcut (ctrl + ') and got this message:\\n\\n**Run Code Status: Failed\\nRun code disabled for this question**\\n\\nany idea if this is expected? Whats the point of disabling run code before submission?"
                    },
                    {
                        "username": "yichenwa",
                        "content": "It cannot pass with concise recursive solution."
                    },
                    {
                        "username": "spamf",
                        "content": "in the example 1 and 2 above, why do left and right branches order look so random - sometimes is left>val>right, sometimes right>val>left, left>right>val?"
                    },
                    {
                        "username": "KarthikRam",
                        "content": "Approach was to figure out to use p and q as references and then use recursion"
                    },
                    {
                        "username": "tanish69",
                        "content": "am I not in thr right senses or test case 31 is just \"nothing\"? its not showing any input? and its causing TLE in my code?"
                    },
                    {
                        "username": "dleyba042",
                        "content": "What is the point of making a binary tree that does not conform to a specific type of ordering??? ex. go left if smaller and right if larger."
                    },
                    {
                        "username": "Anik_Banerjee",
                        "content": "Can  someone explain how to tackle a follow up which asks what will happen if one of p or q  is not present ?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I do not understand what should we do.\\n\\nWe can find LCA with O(log N) time complexity if we knew parent node for each node in tree. But we don\\'t.\\n\\nSo, just to find parents we spend O(N). In this case we can traverse all nodes and mark are they ancestors or not..."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "are those node\\'s values different to each others?"
                    }
                ]
            },
            {
                "id": 1922888,
                "content": [
                    {
                        "username": "xuan18",
                        "content": "It is the last test case (test case number as 31 I remember). \\nI'm using Java. If you use a different language and (I don't know) have a different test case, please ignore my question.\\n\\nIn this test case, p.val==91, and q.val==93. There are more than 2000 nodes given in the serialization of the tree, roughly half of them being null.\\n\\nMy program gives 91. However the OJ says it should be 10. I looked into it. There is a node with val==91 and depth==9 (the root is considered to have depth 0, and each node has depth 1 smaller than its children) that has 91 and 93 as descendants (itself being considered one of its descendants, according to the description). There are six nodes with value 10, their depths being 1,7,8,9,11,13, among which, the ones with depths 9, 11, and 13 do not have both 91 and 93 as descendants.\\n\\nI'm doing an in-order traverse of the tree. Let's first assume that the values of nodes are distinct. Now list all the non-null nodes in the order of in-order traverse (I don't actually form a list, but just to say it for convenience), for any two nodes that appear in the list, their least common ancestor is the (unique) one between them in the list (both of them included) that has minimum depth (it's not hard to keep track of the depth of each node in the traversal). If the values are not distinct and p.val and/or q.val appear multiple times, or p.val==q.val, just some simple modifications are needed. I'm not posting my program since I don't think anyone is taking the trouble to read it (or even this post).\\n\\nI saw many posts that first dive into the left subtree and then the right subtree. So now I'm aware of that although I have doubts... (in case the depth is not well maintained, a result \"deep\" in the left subtree could be replaced by a \"shallow\" result in the right subtree... anyway, I didn't think about it carefully. Forget about it).\\n\\nSo... why am I wrong ... or does anyone also get 91 for the last one?"
                    },
                    {
                        "username": "LazyEval",
                        "content": "Looks like image importing is broken, here is a link to the screenshot: http://imgur.com/NR8uRqx\\nNotice that there are no options to \"Run code\" or \"Custom tests\", but only to \"Submit\"\\n\\nUpdate: I triggered run code via keyboard shortcut (ctrl + ') and got this message:\\n\\n**Run Code Status: Failed\\nRun code disabled for this question**\\n\\nany idea if this is expected? Whats the point of disabling run code before submission?"
                    },
                    {
                        "username": "yichenwa",
                        "content": "It cannot pass with concise recursive solution."
                    },
                    {
                        "username": "spamf",
                        "content": "in the example 1 and 2 above, why do left and right branches order look so random - sometimes is left>val>right, sometimes right>val>left, left>right>val?"
                    },
                    {
                        "username": "KarthikRam",
                        "content": "Approach was to figure out to use p and q as references and then use recursion"
                    },
                    {
                        "username": "tanish69",
                        "content": "am I not in thr right senses or test case 31 is just \"nothing\"? its not showing any input? and its causing TLE in my code?"
                    },
                    {
                        "username": "dleyba042",
                        "content": "What is the point of making a binary tree that does not conform to a specific type of ordering??? ex. go left if smaller and right if larger."
                    },
                    {
                        "username": "Anik_Banerjee",
                        "content": "Can  someone explain how to tackle a follow up which asks what will happen if one of p or q  is not present ?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I do not understand what should we do.\\n\\nWe can find LCA with O(log N) time complexity if we knew parent node for each node in tree. But we don\\'t.\\n\\nSo, just to find parents we spend O(N). In this case we can traverse all nodes and mark are they ancestors or not..."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "are those node\\'s values different to each others?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Palindrome Pairs",
        "question_content": "<p>You are given a <strong>0-indexed</strong> array of <strong>unique</strong> strings <code>words</code>.</p>\n\n<p>A <strong>palindrome pair</strong> is a pair of integers <code>(i, j)</code> such that:</p>\n\n<ul>\n\t<li><code>0 &lt;= i, j &lt; words.length</code>,</li>\n\t<li><code>i != j</code>, and</li>\n\t<li><code>words[i] + words[j]</code> (the concatenation of the two strings) is a <span data-keyword=\"palindrome-string\">palindrome</span>.</li>\n</ul>\n\n<p>Return <em>an array of all the <strong>palindrome pairs</strong> of </em><code>words</code>.</p>\n\n<p>You must write an algorithm with&nbsp;<code>O(sum of words[i].length)</code>&nbsp;runtime complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;abcd&quot;,&quot;dcba&quot;,&quot;lls&quot;,&quot;s&quot;,&quot;sssll&quot;]\n<strong>Output:</strong> [[0,1],[1,0],[3,2],[2,4]]\n<strong>Explanation:</strong> The palindromes are [&quot;abcddcba&quot;,&quot;dcbaabcd&quot;,&quot;slls&quot;,&quot;llssssll&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;bat&quot;,&quot;tab&quot;,&quot;cat&quot;]\n<strong>Output:</strong> [[0,1],[1,0]]\n<strong>Explanation:</strong> The palindromes are [&quot;battab&quot;,&quot;tabbat&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;a&quot;,&quot;&quot;]\n<strong>Output:</strong> [[0,1],[1,0]]\n<strong>Explanation:</strong> The palindromes are [&quot;a&quot;,&quot;a&quot;]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 5000</code></li>\n\t<li><code>0 &lt;= words[i].length &lt;= 300</code></li>\n\t<li><code>words[i]</code> consists of lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 79195,
                "title": "o-n-k-2-java-solution-with-trie-structure",
                "content": "Apparently there is an `O(n^2 * k)` naive solution for this problem, with `n` the total number of words in the `words` array and `k` the average length of each word: **for each word, we simply go through the `words` array and check whether the concatenated string is a palindrome or not.** \\n\\nOf course this will result in `TLE`, as expected. To improve the algorithm, we want to reduce the number of words that need to be checked for each word, instead of iterating through the whole array. This prompted me to think if I can extract any useful information out of the process checking whether the concatenated string is a palindrome, so that it can help eliminate as many words as possible for the rest of the `words` array.\\n\\nTo begin, here is the technique I employed to check for palindromes: maintain two pointers `i` and `j`, with `i` pointing to the start of the string and `j` to the end of the string. Characters pointed by `i` and `j` are compared. If at any time the characters pointed by them are not the same, we conclude the string is not a palindrome. Otherwise we move the two pointers towards each other until they meet in the middle and the string is a palindrome.\\n\\nBy examining the process above, I did find something that we may take advantage of to get rid of words that need to be checked otherwise. For example, let\\'s say we want to append words to `w0`, which starts with character `\\'a\\'`. Then we only need to consider words ending with character `\\'a\\'`, i.e., this will single out all words ending with character `\\'a\\'`. If the second character of `w0` is `\\'b\\'`, for instance, we can further reduce our candidate set to words ending with string `\"ba\"`, etc. Our naive solution throws away all these useful pieces of information and repeats the comparison, which leads to the undesired `O(n^2 * k)` time complexity.\\n\\nIn order to exploit the information gathered so far, we obviously need to restructure all the words in the `words` array. If you are familiar with **Trie** structure (I believe you are, since LeetCode has problems for it. In case you are not, see [Trie](https://en.wikipedia.org/wiki/Trie)), it will come to mind as we need to deal with words with common suffixes. The next step is to design the structure for each Trie node. There are at least two fields that should be covered for each TrieNode: a TrieNode array denoting the next layer of nodes and a boolean (or integer) to signify the end of a word. So our tentative TrieNode will look like this:\\n\\n```\\nclass TrieNode {\\n    TrieNode[] next;\\n    boolean isWord;\\n}\\n```\\nOne point here is that we assume all the words contain lowercase letters only. This is not specified in the problem statement so you probably need to confirm with the interviewer (here I assume it is the case).\\n\\nNow we will rearrange each word into this Trie structure: for each word, simply starting from its last character and identify the node at the next layer by indexing into root\\'s `next` array with index given by the difference between the ending character and character `\\'a\\'`. If the indexed node is null, create a new node.  Continue to the next layer and towards the beginning of the word in this manner until we are done with the word, at which point we will label the `isWord` field of the final node as true.\\n\\nAfter building up the Trie structure, we can proceed to search for pairs of palindromes for each word in the `words` array. I will use the following example to explain how it works and make possible modifications of the TrieNode we proposed above.\\n\\nLet\\'s say we have these words: `[\"ba\", \"a\", \"aaa\"]`, the Trie structure will be as follows:\\n\\n            root (f)\\n               | \\'a\\'\\n              n1 (t)\\n         ------------\\n     \\'b\\' |          | \\'a\\'\\n        n2 (t)    n3 (f)\\n                    | \\'a\\'\\n                  n4 (t)\\n The letter in parentheses indicates the value of `isWord` for each node: `f ==> false` and `t ==> true`. The letter beside each vertical line denotes the index into the `next` array of the corresponding node. For example, for the first vertical line, `\\'a\\'` means `root.next[0]` is not null. Similarly `\\'b\\'` means `n1.next[1]` is not null, and so on.\\n\\nHere is the searching process: \\n\\n 1. For word `\"ba\"`, starting from the first character `\\'b\\'`, index into the root.next array with index given by `\\'b\\' - \\'a\\' = 1`. The corresponding node is null, then we know there are no words ending at this character, so the searching process is terminated;\\n 2. For word `\"a\"`, again indexing into array root.next at index given by `\\'a\\' - \\'a\\' = 0` will yield node `n1`, which is not null. We then check the value of `n1.isWord`. If it is true, then it is possible to obtain a palindrome by appending this word to the one currently being examined (a.k.a word `\"a\"`). Also note that the two words should be distinct from each other, but the `n1.isWord` field provides no information about the word itself, which makes it impossible to distinguish the two words. So it is necessary to modify the structure of the TrieNode so that we can identify the word it represents. One easy way is to have an integer field to remember the index of the word in the `words` array. For non-word nodes, this integer will take negative values (`-1` for example) while for those representing a word, it will be non-negative values. Suppose we have made this modification, then the two words will be identified to be the same, so we discard this pair combination. Since the word `\"a\"` has only one letter, it seems we are done with it. Or do we? Not really. What if there are words with suffix `\"a\"` (`\"aaa\"` in this case)? We need to continue to check the rest part of these words (such as `\"aa\"` for the word `\"aaa\"`) and see if the rest forms a palindrome. If it is, then appending this word (`\"aaa\"` in this case) to the original word (`\"a\"`) will also form a palindrome (`\"aaaa\"`). Here I take another strategy: add an integer list to each TrieNode; the list will record the indices of all words satisfying the following two conditions: *1. each word has a suffix represented by the current TrieNode; 2. the rest of the word forms a palindrome.*\\n\\nBefore I get to the third word `\"aaa\"`, let me spell out the new TrieNode and the corresponding Trie structure for the above array.\\n\\n`TrieNode:`\\n\\n```\\nclass TrieNode {\\n    TrieNode[] next;\\n    int index;\\n    List<Integer> list;\\n            \\n    TrieNode() {\\n        next = new TrieNode[26];\\n        index = -1;\\n        list = new ArrayList<>();\\n    }\\n}\\n```\\n\\n`Trie`:\\n\\n              root (-1,[1,2])\\n                | \\'a\\'\\n              n1 (1,[0,1,2])\\n        ---------------------\\n    \\'b\\' |                 | \\'a\\'\\n      n2 (0,[0])    n3 (-1,[2])\\n                          | \\'a\\'\\n                     n4 (2,[2])\\n\\nThe first integer in the parentheses is the index of the word in the `words\"` array (defaulted to `-1`). The integers in the square bracket are the indices of words satisfying the two conditions mentioned above.\\n\\nLet\\'s continue with the third word `\"aaa\"` with this new structure. Indexing into array `root.next` at index given by `\\'a\\' - \\'a\\' = 0` will yield node `n1` and `n1.index = 1 >= 0`, which means we have a valid word now. The index of this word (which is `1`) is also different from the index of the word currently being visited, a.k.a `\"aaa\"` (which is `2`). So pair `(2,1)` is a possible concatenation to form a palindrome. But still we need to check the rest of `\"aaa\"` (excluding the substring represented by current node `n1` which is `\"a\"` from the beginning of `\"aaa\"`) to see if it is a palindrome. If so, `(2,1)` will be a valid combination. We continue in this fashion until we reach the end of `\"aaa\"`. Lastly we will check `n4.list` to see if there are any words satisfying the two conditions specified in `step 2` which are different from current word, and add the corresponding valid pairs.\\n\\nBoth building and searching the `Trie` structure take `O(n * k^2)`, which sets the total time complexity of the solution. Here is the complete Java program:\\n\\n```\\nprivate static class TrieNode {\\n    TrieNode[] next;\\n    int index;\\n    List<Integer> list;\\n    \\t\\n    TrieNode() {\\n    \\tnext = new TrieNode[26];\\n    \\tindex = -1;\\n    \\tlist = new ArrayList<>();\\n    }\\n}\\n    \\npublic List<List<Integer>> palindromePairs(String[] words) {\\n    List<List<Integer>> res = new ArrayList<>();\\n\\n    TrieNode root = new TrieNode();\\n\\t\\t\\n    for (int i = 0; i < words.length; i++) {\\n        addWord(root, words[i], i);\\n    }\\n\\t\\t\\n    for (int i = 0; i < words.length; i++) {\\n        search(words, i, root, res);\\n    }\\n    \\n    return res;\\n}\\n    \\nprivate void addWord(TrieNode root, String word, int index) {\\n    for (int i = word.length() - 1; i >= 0; i--) {\\n        int j = word.charAt(i) - \\'a\\';\\n\\t\\t\\t\\t\\n        if (root.next[j] == null) {\\n            root.next[j] = new TrieNode();\\n        }\\n\\t\\t\\t\\t\\n        if (isPalindrome(word, 0, i)) {\\n            root.list.add(index);\\n        }\\n\\t\\t\\t\\t\\n        root = root.next[j];\\n    }\\n    \\t\\n    root.list.add(index);\\n    root.index = index;\\n}\\n    \\nprivate void search(String[] words, int i, TrieNode root, List<List<Integer>> res) {\\n    for (int j = 0; j < words[i].length(); j++) {\\t\\n    \\tif (root.index >= 0 && root.index != i && isPalindrome(words[i], j, words[i].length() - 1)) {\\n    \\t    res.add(Arrays.asList(i, root.index));\\n    \\t}\\n    \\t\\t\\n    \\troot = root.next[words[i].charAt(j) - \\'a\\'];\\n      \\tif (root == null) return;\\n    }\\n    \\t\\n    for (int j : root.list) {\\n    \\tif (i == j) continue;\\n    \\tres.add(Arrays.asList(i, j));\\n    }\\n}\\n    \\nprivate boolean isPalindrome(String word, int i, int j) {\\n    while (i < j) {\\n    \\tif (word.charAt(i++) != word.charAt(j--)) return false;\\n    }\\n    \\t\\n    return true;\\n}\\n```\\n\\nWe have the TrieNode structure at the top. In the `palindromePairs` function, we build up the Trie by adding each word, then search for valid pairs for each word and record the results in the `res` list. The last `isPalindrome` function checks if the substring `[i, j]` (both inclusive) of the given word is a palindrome.\\n\\nHope this helps and happy coding!",
                "solutionTags": [],
                "code": "```\\nclass TrieNode {\\n    TrieNode[] next;\\n    boolean isWord;\\n}\\n```\n```\\nclass TrieNode {\\n    TrieNode[] next;\\n    int index;\\n    List<Integer> list;\\n            \\n    TrieNode() {\\n        next = new TrieNode[26];\\n        index = -1;\\n        list = new ArrayList<>();\\n    }\\n}\\n```\n```\\nprivate static class TrieNode {\\n    TrieNode[] next;\\n    int index;\\n    List<Integer> list;\\n    \\t\\n    TrieNode() {\\n    \\tnext = new TrieNode[26];\\n    \\tindex = -1;\\n    \\tlist = new ArrayList<>();\\n    }\\n}\\n    \\npublic List<List<Integer>> palindromePairs(String[] words) {\\n    List<List<Integer>> res = new ArrayList<>();\\n\\n    TrieNode root = new TrieNode();\\n\\t\\t\\n    for (int i = 0; i < words.length; i++) {\\n        addWord(root, words[i], i);\\n    }\\n\\t\\t\\n    for (int i = 0; i < words.length; i++) {\\n        search(words, i, root, res);\\n    }\\n    \\n    return res;\\n}\\n    \\nprivate void addWord(TrieNode root, String word, int index) {\\n    for (int i = word.length() - 1; i >= 0; i--) {\\n        int j = word.charAt(i) - \\'a\\';\\n\\t\\t\\t\\t\\n        if (root.next[j] == null) {\\n            root.next[j] = new TrieNode();\\n        }\\n\\t\\t\\t\\t\\n        if (isPalindrome(word, 0, i)) {\\n            root.list.add(index);\\n        }\\n\\t\\t\\t\\t\\n        root = root.next[j];\\n    }\\n    \\t\\n    root.list.add(index);\\n    root.index = index;\\n}\\n    \\nprivate void search(String[] words, int i, TrieNode root, List<List<Integer>> res) {\\n    for (int j = 0; j < words[i].length(); j++) {\\t\\n    \\tif (root.index >= 0 && root.index != i && isPalindrome(words[i], j, words[i].length() - 1)) {\\n    \\t    res.add(Arrays.asList(i, root.index));\\n    \\t}\\n    \\t\\t\\n    \\troot = root.next[words[i].charAt(j) - \\'a\\'];\\n      \\tif (root == null) return;\\n    }\\n    \\t\\n    for (int j : root.list) {\\n    \\tif (i == j) continue;\\n    \\tres.add(Arrays.asList(i, j));\\n    }\\n}\\n    \\nprivate boolean isPalindrome(String word, int i, int j) {\\n    while (i < j) {\\n    \\tif (word.charAt(i++) != word.charAt(j--)) return false;\\n    }\\n    \\t\\n    return true;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79210,
                "title": "the-easy-to-unserstand-java-solution",
                "content": "There are several cases to be considered that isPalindrome(s1 + s2):\\n\\nCase1: If s1 is a blank string, then for any string that is palindrome s2, s1+s2 and s2+s1 are palindrome.\\n\\nCase 2: If s2 is the reversing string of s1, then s1+s2 and s2+s1 are palindrome.\\n\\nCase 3: If s1[0:cut] is palindrome and there exists s2 is the reversing string of s1[cut+1:] , then s2+s1 is palindrome.\\n\\nCase 4: Similiar to case3. If s1[cut+1: ] is palindrome and there exists s2 is the reversing string of s1[0:cut] , then s1+s2 is palindrome.\\n\\nTo make the search faster, build a HashMap to store the String-idx pairs.\\n\\nMy code:\\n\\n    public class Solution {\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        if(words == null || words.length == 0){\\n            return res;\\n        }\\n        //build the map save the key-val pairs: String - idx\\n        HashMap<String, Integer> map = new HashMap<>();\\n        for(int i = 0; i < words.length; i++){\\n            map.put(words[i], i);\\n        }\\n        \\n        //special cases: \"\" can be combine with any palindrome string\\n        if(map.containsKey(\"\")){\\n            int blankIdx = map.get(\"\");\\n            for(int i = 0; i < words.length; i++){\\n                if(isPalindrome(words[i])){\\n                    if(i == blankIdx) continue;\\n                    res.add(Arrays.asList(blankIdx, i));\\n                    res.add(Arrays.asList(i, blankIdx));\\n                }\\n            }\\n        }\\n        \\n        //find all string and reverse string pairs\\n        for(int i = 0; i < words.length; i++){\\n            String cur_r = reverseStr(words[i]);\\n            if(map.containsKey(cur_r)){\\n                int found = map.get(cur_r);\\n                if(found == i) continue;\\n                res.add(Arrays.asList(i, found));\\n            }\\n        }\\n        \\n        //find the pair s1, s2 that \\n        //case1 : s1[0:cut] is palindrome and s1[cut+1:] = reverse(s2) => (s2, s1)\\n        //case2 : s1[cut+1:] is palindrome and s1[0:cut] = reverse(s2) => (s1, s2)\\n        for(int i = 0; i < words.length; i++){\\n            String cur = words[i];\\n            for(int cut = 1; cut < cur.length(); cut++){\\n                if(isPalindrome(cur.substring(0, cut))){\\n                    String cut_r = reverseStr(cur.substring(cut));\\n                    if(map.containsKey(cut_r)){\\n                        int found = map.get(cut_r);\\n                        if(found == i) continue;\\n                        res.add(Arrays.asList(found, i));\\n                    }\\n                }\\n                if(isPalindrome(cur.substring(cut))){\\n                    String cut_r = reverseStr(cur.substring(0, cut));\\n                    if(map.containsKey(cut_r)){\\n                        int found = map.get(cut_r);\\n                        if(found == i) continue;\\n                        res.add(Arrays.asList(i, found));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public String reverseStr(String str){\\n        StringBuilder sb= new StringBuilder(str);\\n        return sb.reverse().toString();\\n    }\\n    \\n    public boolean isPalindrome(String s){\\n        int i = 0;\\n        int j = s.length() - 1;\\n        while(i <= j){\\n            if(s.charAt(i) != s.charAt(j)){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        if(words == null || words.length == 0){\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 79209,
                "title": "accepted-python-solution-with-explanation",
                "content": "The basic idea is to check each word for prefixes (and suffixes) that are themselves palindromes.  If you find a prefix that is a valid palindrome, then the suffix reversed can be paired with the word in order to make a palindrome.  It's better explained with an example.\\n\\n    words = [\"bot\", \"t\", \"to\"]\\n\\nStarting with the string \"bot\".  We start checking all prefixes.  If `\"\", \"b\", \"bo\", \"bot\"` are themselves palindromes.  The empty string and \"b\" are palindromes.  We work with the corresponding suffixes (\"bot\", \"ot\") and check to see if their reverses (\"tob\", \"to\") are present in our initial word list.  If so (like the word to\"to\"), we have found a valid pairing where the reversed suffix can be **prepended** to the current word in order to form \"to\" + \"bot\" = \"tobot\".\\n\\nYou can do the same thing by checking all suffixes to see if they are palindromes.  If so, then finding all reversed prefixes will give you the words that can be **appended** to the current word to form a palindrome.\\n\\nThe process is then repeated for every word in the list.  Note that when considering suffixes, we explicitly leave out the empty string to avoid counting duplicates.  That is, if a palindrome can be created by appending an entire other word to the current word, then we will already consider such a palindrome when considering the empty string as prefix for the other word.  \\n\\n        def is_palindrome(check):\\n            return check == check[::-1]\\n    \\n        words = {word: i for i, word in enumerate(words)}\\n        valid_pals = []\\n        for word, k in words.iteritems():\\n            n = len(word)\\n            for j in range(n+1):\\n                pref = word[:j]\\n                suf = word[j:]\\n                if is_palindrome(pref):\\n                    back = suf[::-1]\\n                    if back != word and back in words:\\n                        valid_pals.append([words[back],  k])\\n                if j != n and is_palindrome(suf):\\n                    back = pref[::-1]\\n                    if back != word and back in words:\\n                        valid_pals.append([k, words[back]])\\n        return valid_pals",
                "solutionTags": [
                    "Python"
                ],
                "code": "The basic idea is to check each word for prefixes (and suffixes) that are themselves palindromes.  If you find a prefix that is a valid palindrome, then the suffix reversed can be paired with the word in order to make a palindrome.  It's better explained with an example.\\n\\n    words = [\"bot\", \"t\", \"to\"]\\n\\nStarting with the string \"bot\".  We start checking all prefixes.  If `\"\", \"b\", \"bo\", \"bot\"` are themselves palindromes.  The empty string and \"b\" are palindromes.  We work with the corresponding suffixes (\"bot\", \"ot\") and check to see if their reverses (\"tob\", \"to\") are present in our initial word list.  If so (like the word to\"to\"), we have found a valid pairing where the reversed suffix can be **prepended** to the current word in order to form \"to\" + \"bot\" = \"tobot\".\\n\\nYou can do the same thing by checking all suffixes to see if they are palindromes.  If so, then finding all reversed prefixes will give you the words that can be **appended** to the current word to form a palindrome.\\n\\nThe process is then repeated for every word in the list.  Note that when considering suffixes, we explicitly leave out the empty string to avoid counting duplicates.  That is, if a palindrome can be created by appending an entire other word to the current word, then we will already consider such a palindrome when considering the empty string as prefix for the other word.  \\n\\n        def is_palindrome(check):\\n            return check == check[::-1]\\n    \\n        words = {word: i for i, word in enumerate(words)}\\n        valid_pals = []\\n        for word, k in words.iteritems():\\n            n = len(word)\\n            for j in range(n+1):\\n                pref = word[:j]\\n                suf = word[j:]\\n                if is_palindrome(pref):\\n                    back = suf[::-1]\\n                    if back != word and back in words:\\n                        valid_pals.append([words[back],  k])\\n                if j != n and is_palindrome(suf):\\n                    back = pref[::-1]\\n                    if back != word and back in words:\\n                        valid_pals.append([k, words[back]])\\n        return valid_pals",
                "codeTag": "Python3"
            },
            {
                "id": 79199,
                "title": "150-ms-45-lines-java-solution",
                "content": "    public List<List<Integer>> palindromePairs(String[] words) {\\n        List<List<Integer>> ret = new ArrayList<>(); \\n        if (words == null || words.length < 2) return ret;\\n        Map<String, Integer> map = new HashMap<String, Integer>();\\n        for (int i=0; i<words.length; i++) map.put(words[i], i);\\n        for (int i=0; i<words.length; i++) {\\n            // System.out.println(words[i]);\\n            for (int j=0; j<=words[i].length(); j++) { // notice it should be \"j <= words[i].length()\"\\n                String str1 = words[i].substring(0, j);\\n                String str2 = words[i].substring(j);\\n                if (isPalindrome(str1)) {\\n                    String str2rvs = new StringBuilder(str2).reverse().toString();\\n                    if (map.containsKey(str2rvs) && map.get(str2rvs) != i) {\\n                        List<Integer> list = new ArrayList<Integer>();\\n                        list.add(map.get(str2rvs));\\n                        list.add(i);\\n                        ret.add(list);\\n                        // System.out.printf(\"isPal(str1): %s\\\\n\", list.toString());\\n                    }\\n                }\\n                if (isPalindrome(str2)) {\\n                    String str1rvs = new StringBuilder(str1).reverse().toString();\\n                    // check \"str.length() != 0\" to avoid duplicates\\n                    if (map.containsKey(str1rvs) && map.get(str1rvs) != i && str2.length()!=0) { \\n                        List<Integer> list = new ArrayList<Integer>();\\n                        list.add(i);\\n                        list.add(map.get(str1rvs));\\n                        ret.add(list);\\n                        // System.out.printf(\"isPal(str2): %s\\\\n\", list.toString());\\n                    }\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    private boolean isPalindrome(String str) {\\n        int left = 0;\\n        int right = str.length() - 1;\\n        while (left <= right) {\\n            if (str.charAt(left++) !=  str.charAt(right--)) return false;\\n        }\\n        return true;\\n    }\\n\\n\\n1. The `<=` in `for (int j=0; j<=words[i].length(); j++)` is aimed to handle empty string in the input. Consider the test case of [\"a\", \"\"];\\n\\n2.  Since we now use `<=` in `for (int j=0; j<=words[i].length(); j++)` instead of `<`. There may be duplicates in the output (consider test case [\"abcd\", \"dcba\"]). Therefore I put a `str2.length()!=0` to avoid duplicates.\\n\\n\\n\\nAnother way to avoid duplicates is to use `Set<List<Integer>> ret = new HashSet<>();` and return `new ArrayList<>(ret);`",
                "solutionTags": [],
                "code": "    public List<List<Integer>> palindromePairs(String[] words) {\\n        List<List<Integer>> ret = new ArrayList<>(); \\n        if (words == null || words.length < 2) return ret;\\n        Map<String, Integer> map = new HashMap<String, Integer>();\\n        for (int i=0; i<words.length; i++) map.put(words[i], i);\\n        for (int i=0; i<words.length; i++) {\\n            // System.out.println(words[i]);\\n            for (int j=0; j<=words[i].length(); j++) { // notice it should be \"j <= words[i].length()\"\\n                String str1 = words[i].substring(0, j);\\n                String str2 = words[i].substring(j);\\n                if (isPalindrome(str1)) {\\n                    String str2rvs = new StringBuilder(str2).reverse().toString();\\n                    if (map.containsKey(str2rvs) && map.get(str2rvs) != i) {\\n                        List<Integer> list = new ArrayList<Integer>();\\n                        list.add(map.get(str2rvs));\\n                        list.add(i);\\n                        ret.add(list);\\n                        // System.out.printf(\"isPal(str1): %s\\\\n\", list.toString());\\n                    }\\n                }\\n                if (isPalindrome(str2)) {\\n                    String str1rvs = new StringBuilder(str1).reverse().toString();\\n                    // check \"str.length() != 0\" to avoid duplicates\\n                    if (map.containsKey(str1rvs) && map.get(str1rvs) != i && str2.length()!=0) { \\n                        List<Integer> list = new ArrayList<Integer>();\\n                        list.add(i);\\n                        list.add(map.get(str1rvs));\\n                        ret.add(list);\\n                        // System.out.printf(\"isPal(str2): %s\\\\n\", list.toString());\\n                    }\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    private boolean isPalindrome(String str) {\\n        int left = 0;\\n        int right = str.length() - 1;\\n        while (left <= right) {\\n            if (str.charAt(left++) !=  str.charAt(right--)) return false;\\n        }\\n        return true;\\n    }\\n\\n\\n1. The `<=` in `for (int j=0; j<=words[i].length(); j++)` is aimed to handle empty string in the input. Consider the test case of [\"a\", \"\"];\\n\\n2.  Since we now use `<=` in `for (int j=0; j<=words[i].length(); j++)` instead of `<`. There may be duplicates in the output (consider test case [\"abcd\", \"dcba\"]). Therefore I put a `str2.length()!=0` to avoid duplicates.\\n\\n\\n\\nAnother way to avoid duplicates is to use `Set<List<Integer>> ret = new HashSet<>();` and return `new ArrayList<>(ret);`",
                "codeTag": "Unknown"
            },
            {
                "id": 79215,
                "title": "easy-to-understand-ac-c-solution-o-n-k-2-using-map",
                "content": "**Assumption**: No duplicated string in the given dictionary\\n\\n**Steps:**\\n\\n1. Traverse the array, build map. Key is the reversed string, value is index in array (0 based)\\n\\n2. Edge case - check if empty string exists. It's interesting that for given words {\"a\", \"\"}, it's expected to return two results [0,1] and [1,0]. Since my main logic can cover [0, 1] concatenate(\"a\", \"\"), so as to cover the other situation concatenate(\"\", \"a\"), I need to traverse the words array again, find the palindrome word candidate **except** \"\" itself, and add pair(\"\", palindrome word) to the final answer.\\n\\n3. Main logic part. Partition the word into left and right, and see 1) if there exists a candidate in map equals the left side of current word, and right side of current word is palindrome, so concatenate(current word, candidate) forms a pair: **left** | right | **candidate**. 2) same for checking the right side of current word: **candidate** | left | **right**.\\n\\n\\n\\n        class Solution {\\n        public:\\n            vector<vector<int>> palindromePairs(vector<string>& words) {\\n                unordered_map<string, int> dict;\\n                vector<vector<int>> ans;\\n                // build dictionary\\n                for(int i = 0; i < words.size(); i++) {\\n                    string key = words[i];\\n                    reverse(key.begin(), key.end());\\n                    dict[key] = i;\\n                }\\n                // edge case: if empty string \"\" exists, find all palindromes to become pairs (\"\", self)\\n                if(dict.find(\"\")!=dict.end()){\\n                    for(int i = 0; i < words.size(); i++){\\n                        if(i == dict[\"\"]) continue;\\n                        if(isPalindrome(words[i])) ans.push_back({dict[\"\"], i}); // 1) if self is palindrome, here ans covers concatenate(\"\", self) \\n                    }\\n                }\\n\\n                for(int i = 0; i < words.size(); i++) {\\n                    for(int j = 0; j < words[i].size(); j++) {\\n                        string left = words[i].substr(0, j);\\n                        string right = words[i].substr(j, words[i].size() - j);\\n\\n                        if(dict.find(left) != dict.end() && isPalindrome(right) && dict[left] != i) {\\n                            ans.push_back({i, dict[left]});     // 2) when j = 0, left = \"\", right = self, so here covers concatenate(self, \"\")\\n                        }\\n\\n                        if(dict.find(right) != dict.end() && isPalindrome(left) && dict[right] != i) {\\n                            ans.push_back({dict[right], i});\\n                        }\\n                    }\\n                }\\n\\n                return ans;        \\n            }\\n\\n            bool isPalindrome(string str){\\n                int i = 0;\\n                int j = str.size() - 1; \\n\\n                while(i < j) {\\n                    if(str[i++] != str[j--]) return false;\\n                }\\n\\n                return true;\\n            }\\n\\n        };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n        public:\\n            vector<vector<int>> palindromePairs(vector<string>& words) {\\n                unordered_map<string, int> dict;\\n                vector<vector<int>> ans;\\n                // build dictionary\\n                for(int i = 0; i < words.size(); i++) {\\n                    string key = words[i];\\n                    reverse(key.begin(), key.end());\\n                    dict[key] = i;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1269310,
                "title": "js-python-java-c-easy-map-matching-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nA naive approach here would attempt every possible pairing of **words**, but that would be inefficient. Instead, we can figure out what possible words would pair with each word and specifically check for those.\\n\\nTo do this, we\\'ll first have to store each word in a **map** structure (**wmap**), with the word as the key and the index as the value. This way, we can look up any possible matches with the current word as we iterate through **words**.\\n\\nThe next thing we\\'ll want to do is define a helper function (**isPal**) to check if a word is a palindrome. Rather than having to pass it a substring of a word, we can define it to take a range of indexes to check, so that we\\'re not constantly building new strings.\\n\\nAs we iterate through **words**, then, each word will possibly match another word in one of three ways:\\n - A blank string word will match on either side with any palindrome word. _(e.g. \"\" will match with \"abc\" and vice versa)_\\n - A full word will match on either side with its backwards version. _(e.g. \"abc\" will match with \"cba\", and vice versa)_\\n - A partial word will match its backwards version on the opposite side if the leftover portion of the word is a palindrome _(e.g. \"abcddd\" will match with \"cba\" because \"abc\" matches with \"cba\" and \"ddd\" is a palindrome)_\\n\\nThe first check is easy to perform. If we find a blank string, we can iterate through the entire **words** list an extra time searching for palindromes to match. We just need to remember not to match the blank string with itself.\\n\\nFor the second check, since we\\'ll eventually iterate to the matching full word, we should only add the one pair at this time, rather than both, as we\\'ll be able to add the second ordering of the same pair when we get to the second word.\\n\\nThe third check is the most difficult. For this, we\\'ll want to first reverse the current word to its backwards version (**bw**), since we\\'ll be matching existing frontwards words in **wmap**. Then we should iterate through the indexes of the word itself, testing both sides of the dividing index (**j**) for being a palindrome.\\n\\nIf a palindrome is found, then we can attempt to lookup the _other_ portion of the word in **wmap**. If a match is found, we can push that pair to our answer array (**ans**). At the end of the iteration of **words**, we can **return ans**.\\n\\n - _**Time Complexity: O(N * M^2)** where **N** is the length of **words** and **M** is the average length of the words in **words**_\\n - _**Space Complexity: O(N)** for **wmap**_\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **156ms / 49.2MB** (beats 100% / 85%).\\n```javascript\\nvar palindromePairs = function(words) {  \\n    let wmap = new Map(), ans = []\\n    for (let i = 0; i < words.length; i++)\\n        wmap.set(words[i], i)\\n    for (let i = 0; i < words.length; i++) {\\n        if (words[i] === \"\") {\\n            for (let j = 0; j < words.length; j++)\\n                if (isPal(words[j]) && j !== i)\\n                    ans.push([i, j], [j, i])\\n            continue\\n        }\\n        let bw = words[i].split(\"\").reverse().join(\"\")\\n        let res = wmap.get(bw)\\n        if (res !== undefined && res !== i)\\n            ans.push([i, res])\\n        for (let j = 1; j < bw.length; j++) {\\n            if (isPal(bw, 0, j - 1)) {\\n                let res = wmap.get(bw.slice(j))\\n                if (res !== undefined)\\n                    ans.push([i, res])\\n            }\\n            if (isPal(bw, j)) {\\n                let res = wmap.get(bw.slice(0,j))\\n                if (res !== undefined)\\n                    ans.push([res, i])\\n            }\\n        }\\n    }\\n    return ans\\n};\\n\\nconst isPal = (word, i=0, j=word.length-1) => {\\n    while (i < j)\\n        if (word[i++] !== word[j--]) return false\\n    return true\\n}\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **448ms / 15.6MB** (beats 89% / 73%).\\n```python\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        wmap, ans = {}, []\\n        for i in range(len(words)):\\n            wmap[words[i]] = i\\n        for i in range(len(words)):\\n            if words[i] == \"\":\\n                for j in range(len(words)):\\n                    w = words[j]\\n                    if self.isPal(w, 0, len(w)-1) and j != i:\\n                        ans.append([i, j])\\n                        ans.append([j, i])\\n                continue\\n            bw = words[i][::-1]\\n            if bw in wmap:\\n                res = wmap[bw]\\n                if res != i: ans.append([i, res])\\n            for j in range(1, len(bw)):\\n                if bw[j:] in wmap and self.isPal(bw, 0, j - 1):\\n                    ans.append([i, wmap[bw[j:]]])\\n                if bw[:j] in wmap and self.isPal(bw, j, len(bw)-1):\\n                    ans.append([wmap[bw[:j]], i])\\n        return ans\\n\\n    def isPal(self, word: str, i: int, j: int) -> bool:\\n        while i < j:\\n            if word[i] != word[j]: return False\\n            i += 1\\n            j -= 1\\n        return True\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **32ms / 40.7MB** (beats 82% / 94%).\\n```java\\nclass Solution {\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        Map<String, Integer> wmap = new HashMap<>();\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for (int i = 0; i < words.length; i++)\\n            wmap.put(words[i], i);\\n        for (int i = 0; i < words.length; i++) {\\n            if (words[i].equals(\"\")) {\\n                for (int j = 0; j < words.length; j++) {\\n                    String w = words[j];\\n                    if (isPal(w, 0, w.length()-1) && j != i) {\\n                        ans.add(List.of(i, j));\\n                        ans.add(List.of(j, i));\\n                    }\\n                }\\n                continue;\\n            }\\n            StringBuilder sb = new StringBuilder(words[i]);\\n            sb.reverse();\\n            String bw = sb.toString();\\n            if (wmap.containsKey(bw)) {\\n                int res = wmap.get(bw);\\n                if (res != i) ans.add(List.of(i, res));\\n            }\\n            for (int j = 1; j < bw.length(); j++) {\\n                if (isPal(bw, 0, j-1)) {\\n                    String s = bw.substring(j);\\n                    if (wmap.containsKey(s))\\n                        ans.add(List.of(i, wmap.get(s)));\\n                }\\n                if (isPal(bw, j, bw.length()-1)) {\\n                    String s = bw.substring(0,j);\\n                    if (wmap.containsKey(s))\\n                        ans.add(List.of(wmap.get(s), i));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private boolean isPal(String word, int i, int j) {\\n        while (i < j)\\n            if (word.charAt(i++) != word.charAt(j--)) return false;\\n        return true;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **84ms / 36.6MB** (beats 99% / 93%).\\n```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        unordered_map<string, int> wmap;\\n        vector<vector<int>> ans;\\n        for (int i = 0; i < words.size(); i++)\\n            wmap[words[i]] = i;\\n        for (int i = 0; i < words.size(); i++) {\\n            if (words[i] == \"\") {\\n                for (int j = 0; j < words.size(); j++) {\\n                    string& w = words[j];\\n                    if (isPal(w, 0, w.size()-1) && j != i) {\\n                        ans.push_back(vector<int> {i, j});\\n                        ans.push_back(vector<int> {j, i});\\n                    }\\n                }\\n                continue;\\n            }\\n            string bw = words[i];\\n            reverse(bw.begin(), bw.end());\\n            if (wmap.find(bw) != wmap.end()) {\\n                int res = wmap[bw];\\n                if (res != i) ans.push_back(vector<int> {i, res});\\n            }\\n            for (int j = 1; j < bw.size(); j++) {\\n                if (isPal(bw, 0, j-1)) {\\n                    string s = bw.substr(j, bw.size()-j);\\n                    if (wmap.find(s) != wmap.end())\\n                        ans.push_back(vector<int> {i, wmap[s]});\\n                }\\n                if (isPal(bw, j, bw.size()-1)) {\\n                    string s = bw.substr(0, j);\\n                    if (wmap.find(s) != wmap.end())\\n                        ans.push_back(vector<int> {wmap[s], i});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\nprivate:\\n    bool isPal(string& word, int i, int j) {\\n        while (i < j)\\n            if (word[i++] != word[j--]) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar palindromePairs = function(words) {  \\n    let wmap = new Map(), ans = []\\n    for (let i = 0; i < words.length; i++)\\n        wmap.set(words[i], i)\\n    for (let i = 0; i < words.length; i++) {\\n        if (words[i] === \"\") {\\n            for (let j = 0; j < words.length; j++)\\n                if (isPal(words[j]) && j !== i)\\n                    ans.push([i, j], [j, i])\\n            continue\\n        }\\n        let bw = words[i].split(\"\").reverse().join(\"\")\\n        let res = wmap.get(bw)\\n        if (res !== undefined && res !== i)\\n            ans.push([i, res])\\n        for (let j = 1; j < bw.length; j++) {\\n            if (isPal(bw, 0, j - 1)) {\\n                let res = wmap.get(bw.slice(j))\\n                if (res !== undefined)\\n                    ans.push([i, res])\\n            }\\n            if (isPal(bw, j)) {\\n                let res = wmap.get(bw.slice(0,j))\\n                if (res !== undefined)\\n                    ans.push([res, i])\\n            }\\n        }\\n    }\\n    return ans\\n};\\n\\nconst isPal = (word, i=0, j=word.length-1) => {\\n    while (i < j)\\n        if (word[i++] !== word[j--]) return false\\n    return true\\n}\\n```\n```python\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        wmap, ans = {}, []\\n        for i in range(len(words)):\\n            wmap[words[i]] = i\\n        for i in range(len(words)):\\n            if words[i] == \"\":\\n                for j in range(len(words)):\\n                    w = words[j]\\n                    if self.isPal(w, 0, len(w)-1) and j != i:\\n                        ans.append([i, j])\\n                        ans.append([j, i])\\n                continue\\n            bw = words[i][::-1]\\n            if bw in wmap:\\n                res = wmap[bw]\\n                if res != i: ans.append([i, res])\\n            for j in range(1, len(bw)):\\n                if bw[j:] in wmap and self.isPal(bw, 0, j - 1):\\n                    ans.append([i, wmap[bw[j:]]])\\n                if bw[:j] in wmap and self.isPal(bw, j, len(bw)-1):\\n                    ans.append([wmap[bw[:j]], i])\\n        return ans\\n\\n    def isPal(self, word: str, i: int, j: int) -> bool:\\n        while i < j:\\n            if word[i] != word[j]: return False\\n            i += 1\\n            j -= 1\\n        return True\\n```\n```java\\nclass Solution {\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        Map<String, Integer> wmap = new HashMap<>();\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for (int i = 0; i < words.length; i++)\\n            wmap.put(words[i], i);\\n        for (int i = 0; i < words.length; i++) {\\n            if (words[i].equals(\"\")) {\\n                for (int j = 0; j < words.length; j++) {\\n                    String w = words[j];\\n                    if (isPal(w, 0, w.length()-1) && j != i) {\\n                        ans.add(List.of(i, j));\\n                        ans.add(List.of(j, i));\\n                    }\\n                }\\n                continue;\\n            }\\n            StringBuilder sb = new StringBuilder(words[i]);\\n            sb.reverse();\\n            String bw = sb.toString();\\n            if (wmap.containsKey(bw)) {\\n                int res = wmap.get(bw);\\n                if (res != i) ans.add(List.of(i, res));\\n            }\\n            for (int j = 1; j < bw.length(); j++) {\\n                if (isPal(bw, 0, j-1)) {\\n                    String s = bw.substring(j);\\n                    if (wmap.containsKey(s))\\n                        ans.add(List.of(i, wmap.get(s)));\\n                }\\n                if (isPal(bw, j, bw.length()-1)) {\\n                    String s = bw.substring(0,j);\\n                    if (wmap.containsKey(s))\\n                        ans.add(List.of(wmap.get(s), i));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private boolean isPal(String word, int i, int j) {\\n        while (i < j)\\n            if (word.charAt(i++) != word.charAt(j--)) return false;\\n        return true;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        unordered_map<string, int> wmap;\\n        vector<vector<int>> ans;\\n        for (int i = 0; i < words.size(); i++)\\n            wmap[words[i]] = i;\\n        for (int i = 0; i < words.size(); i++) {\\n            if (words[i] == \"\") {\\n                for (int j = 0; j < words.size(); j++) {\\n                    string& w = words[j];\\n                    if (isPal(w, 0, w.size()-1) && j != i) {\\n                        ans.push_back(vector<int> {i, j});\\n                        ans.push_back(vector<int> {j, i});\\n                    }\\n                }\\n                continue;\\n            }\\n            string bw = words[i];\\n            reverse(bw.begin(), bw.end());\\n            if (wmap.find(bw) != wmap.end()) {\\n                int res = wmap[bw];\\n                if (res != i) ans.push_back(vector<int> {i, res});\\n            }\\n            for (int j = 1; j < bw.size(); j++) {\\n                if (isPal(bw, 0, j-1)) {\\n                    string s = bw.substr(j, bw.size()-j);\\n                    if (wmap.find(s) != wmap.end())\\n                        ans.push_back(vector<int> {i, wmap[s]});\\n                }\\n                if (isPal(bw, j, bw.size()-1)) {\\n                    string s = bw.substr(0, j);\\n                    if (wmap.find(s) != wmap.end())\\n                        ans.push_back(vector<int> {wmap[s], i});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\nprivate:\\n    bool isPal(string& word, int i, int j) {\\n        while (i < j)\\n            if (word[i++] != word[j--]) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 176205,
                "title": "beats-80-trie-java-with-explanations",
                "content": "**Thought**\\n```\\nWe want to concatenate string B to string A to make AB palindrome.\\n\\nHow could AB be palindrome? \\nIf B ends with x, then A must starts with x. If the second character of B is y, then the second last character of A is y...\\nThat is,\\n  Case 1. A must be prefix of reversed B, and the rest of reversed B should be palindrome. For example,\\n\\t(B:oooabc - cbaooo,    A:cba       AB:cba|oooabc)\\n  Case 2. Or, reversed B must be prefix of A, and the rest of A should be palindrome. For example,\\n\\t(B:abc - cba           A:cbaooo,   AB:cbaooo|abc)\\n    \\nEach word in words can be B. We put all reversed words in a trie. \\nEach word in words can be A. So we search A in trie, \\nIn this way,\\n  Case 1. if we found A in trie, and the branch under the end node is a palindrome, we found it!\\n  Case 2. if we reach a leaf of trie, and the rest of A is palindrome, we found it! \\n  \\n  For Case 1., we modify TrieNode data structure by adding belowPalindromeWordIds - list of word indices such that nodes below can construct a palindrome.\\n  For Case 2., we create a method isPalindrome(str, start, end) .\\n\\nPlease take care of corner cases of empty string. Both (\"\", self-palindrome) and (self-palindrome, \"\") are still palindrome.\\n```\\n**Code**\\n```\\n    private Node root;\\n    \\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        \\n        if (words == null || words.length == 0)\\n            return new ArrayList<>();\\n        \\n        root = new Node();\\n        int n = words.length;\\n        List<List<Integer>> finalResult = new ArrayList<>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (words[i].isEmpty()) {\\n                // Pair with all self-palindrome.\\n                List<Integer> selfPalindromeWordIndices = getSelfPalindrome(words);\\n                for (int pairId : selfPalindromeWordIndices) {\\n                    finalResult.add(new ArrayList<>(Arrays.asList(i, pairId)));\\n                    finalResult.add(new ArrayList<>(Arrays.asList(pairId, i)));\\n                }\\n            }\\n            else {\\n                insert(reverse(words[i]), i);\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            List<Integer> wordIndices = search(words[i], i);\\n            for (int pairId : wordIndices) {\\n                finalResult.add(new ArrayList<>(Arrays.asList(i, pairId)));\\n            }\\n        }\\n        \\n        return finalResult;\\n    }\\n    \\n    /****************** Trie-related *******************/\\n    \\n    private List<Integer> search(String word, int index) {\\n        \\n        List<Integer> wordIndices = new ArrayList<>();\\n        Node ptr = root;\\n        int n = word.length();\\n        for (int i = 0; i < n; i++) {\\n            int label = word.charAt(i) - \\'a\\';\\n            if (ptr.endWordId > -1 && isPalindrome(word, i, n - 1)) {\\n                wordIndices.add(ptr.endWordId);                \\n            }\\n            if (ptr.children[label] == null) {\\n                return wordIndices;\\n            } \\n            ptr = ptr.children[label];\\n        }\\n        if (ptr.endWordId > -1 && ptr.endWordId != index)\\n            wordIndices.add(ptr.endWordId);\\n        if (!ptr.belowPalindromeWordIds.isEmpty())\\n            wordIndices.addAll(ptr.belowPalindromeWordIds);\\n        \\n        return wordIndices;\\n    }\\n    \\n    private void insert(String word, int index) {\\n        \\n        Node ptr = root;\\n        int n = word.length();\\n        for (int i = 0; i < n; i++) {\\n            int label = word.charAt(i) - \\'a\\';               \\n            if (ptr.children[label] == null)\\n                ptr.children[label] = new Node();\\n            ptr = ptr.children[label];\\n            if (isPalindrome(word, i + 1, n - 1))\\n                ptr.belowPalindromeWordIds.add(index);\\n        }\\n        \\n        ptr.endWordId = index;\\n    }\\n    \\n    class Node {\\n        \\n        Node[] children;\\n        int endWordId; // Equals to -1 in default. If it is a word\\'s end, it is the index of the word.\\n        List<Integer> belowPalindromeWordIds; // List of word indices such that nodes below can construct a palindrome.\\n        \\n        public Node() {\\n            children = new Node[26];\\n            endWordId = -1;\\n            belowPalindromeWordIds = new ArrayList<>();\\n        }\\n        \\n    }\\n    \\n    /****************** Utility *******************/\\n    \\n    private String reverse(String str) {\\n        return new StringBuilder(str).reverse().toString();\\n    }\\n    \\n    private boolean isPalindrome(String str, int start, int end) {\\n        \\n        if (start > end) {\\n            return false;\\n        }\\n        \\n        while (start < end) {\\n            if (str.charAt(start) != str.charAt(end))\\n                return false;\\n            start++;\\n            end--;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private List<Integer> getSelfPalindrome(String[] words) {\\n        List<Integer> wordIndices = new ArrayList<>();\\n        for (int i = 0; i < words.length; i++) {\\n            if (isPalindrome(words[i], 0, words[i].length() - 1)) {\\n                wordIndices.add(i);\\n            }\\n        }\\n        return wordIndices;\\n    }\\n```\\n\\n\\n**I appreciate your VOTE UP (\\u25B0\\u2579\\u25E1\\u2579\\u25B0)**",
                "solutionTags": [],
                "code": "```\\nWe want to concatenate string B to string A to make AB palindrome.\\n\\nHow could AB be palindrome? \\nIf B ends with x, then A must starts with x. If the second character of B is y, then the second last character of A is y...\\nThat is,\\n  Case 1. A must be prefix of reversed B, and the rest of reversed B should be palindrome. For example,\\n\\t(B:oooabc - cbaooo,    A:cba       AB:cba|oooabc)\\n  Case 2. Or, reversed B must be prefix of A, and the rest of A should be palindrome. For example,\\n\\t(B:abc - cba           A:cbaooo,   AB:cbaooo|abc)\\n    \\nEach word in words can be B. We put all reversed words in a trie. \\nEach word in words can be A. So we search A in trie, \\nIn this way,\\n  Case 1. if we found A in trie, and the branch under the end node is a palindrome, we found it!\\n  Case 2. if we reach a leaf of trie, and the rest of A is palindrome, we found it! \\n  \\n  For Case 1., we modify TrieNode data structure by adding belowPalindromeWordIds - list of word indices such that nodes below can construct a palindrome.\\n  For Case 2., we create a method isPalindrome(str, start, end) .\\n\\nPlease take care of corner cases of empty string. Both (\"\", self-palindrome) and (self-palindrome, \"\") are still palindrome.\\n```\n```\\n    private Node root;\\n    \\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        \\n        if (words == null || words.length == 0)\\n            return new ArrayList<>();\\n        \\n        root = new Node();\\n        int n = words.length;\\n        List<List<Integer>> finalResult = new ArrayList<>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (words[i].isEmpty()) {\\n                // Pair with all self-palindrome.\\n                List<Integer> selfPalindromeWordIndices = getSelfPalindrome(words);\\n                for (int pairId : selfPalindromeWordIndices) {\\n                    finalResult.add(new ArrayList<>(Arrays.asList(i, pairId)));\\n                    finalResult.add(new ArrayList<>(Arrays.asList(pairId, i)));\\n                }\\n            }\\n            else {\\n                insert(reverse(words[i]), i);\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            List<Integer> wordIndices = search(words[i], i);\\n            for (int pairId : wordIndices) {\\n                finalResult.add(new ArrayList<>(Arrays.asList(i, pairId)));\\n            }\\n        }\\n        \\n        return finalResult;\\n    }\\n    \\n    /****************** Trie-related *******************/\\n    \\n    private List<Integer> search(String word, int index) {\\n        \\n        List<Integer> wordIndices = new ArrayList<>();\\n        Node ptr = root;\\n        int n = word.length();\\n        for (int i = 0; i < n; i++) {\\n            int label = word.charAt(i) - \\'a\\';\\n            if (ptr.endWordId > -1 && isPalindrome(word, i, n - 1)) {\\n                wordIndices.add(ptr.endWordId);                \\n            }\\n            if (ptr.children[label] == null) {\\n                return wordIndices;\\n            } \\n            ptr = ptr.children[label];\\n        }\\n        if (ptr.endWordId > -1 && ptr.endWordId != index)\\n            wordIndices.add(ptr.endWordId);\\n        if (!ptr.belowPalindromeWordIds.isEmpty())\\n            wordIndices.addAll(ptr.belowPalindromeWordIds);\\n        \\n        return wordIndices;\\n    }\\n    \\n    private void insert(String word, int index) {\\n        \\n        Node ptr = root;\\n        int n = word.length();\\n        for (int i = 0; i < n; i++) {\\n            int label = word.charAt(i) - \\'a\\';               \\n            if (ptr.children[label] == null)\\n                ptr.children[label] = new Node();\\n            ptr = ptr.children[label];\\n            if (isPalindrome(word, i + 1, n - 1))\\n                ptr.belowPalindromeWordIds.add(index);\\n        }\\n        \\n        ptr.endWordId = index;\\n    }\\n    \\n    class Node {\\n        \\n        Node[] children;\\n        int endWordId; // Equals to -1 in default. If it is a word\\'s end, it is the index of the word.\\n        List<Integer> belowPalindromeWordIds; // List of word indices such that nodes below can construct a palindrome.\\n        \\n        public Node() {\\n            children = new Node[26];\\n            endWordId = -1;\\n            belowPalindromeWordIds = new ArrayList<>();\\n        }\\n        \\n    }\\n    \\n    /****************** Utility *******************/\\n    \\n    private String reverse(String str) {\\n        return new StringBuilder(str).reverse().toString();\\n    }\\n    \\n    private boolean isPalindrome(String str, int start, int end) {\\n        \\n        if (start > end) {\\n            return false;\\n        }\\n        \\n        while (start < end) {\\n            if (str.charAt(start) != str.charAt(end))\\n                return false;\\n            start++;\\n            end--;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private List<Integer> getSelfPalindrome(String[] words) {\\n        List<Integer> wordIndices = new ArrayList<>();\\n        for (int i = 0; i < words.length; i++) {\\n            if (isPalindrome(words[i], 0, words[i].length() - 1)) {\\n                wordIndices.add(i);\\n            }\\n        }\\n        return wordIndices;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585494,
                "title": "c-trie-related-problems",
                "content": "```cpp\\nstruct TrieNode {\\n    TrieNode *next[26] = {};\\n    int index = -1;\\n    vector<int> palindromeIndexes;\\n};\\n\\nclass Solution {\\n    TrieNode root; // Suffix trie\\n    void add(string &s, int i) {\\n        auto node = &root;\\n        for (int j = s.size() - 1; j >= 0; --j) {\\n            if (isPalindrome(s, 0, j)) node->palindromeIndexes.push_back(i); // A[i]\\'s prefix forms a palindrome\\n            int c = s[j] - \\'a\\';\\n            if (!node->next[c]) node->next[c] = new TrieNode();\\n            node = node->next[c];\\n        }\\n        node->index = i;\\n        node->palindromeIndexes.push_back(i); // A[i]\\'s prefix is empty string here, which is a palindrome.\\n    }\\n    \\n    bool isPalindrome(string &s, int i, int j) {\\n        while (i < j && s[i] == s[j]) ++i, --j;\\n        return i >= j;\\n    }\\n    \\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& A) {\\n        int N = A.size();\\n        for (int i = 0; i < N; ++i) add(A[i], i);\\n        vector<vector<int>> ans;\\n        for (int i = 0; i < N; ++i) {\\n            auto s = A[i];\\n            auto node = &root;\\n            for (int j = 0; j < s.size() && node; ++j) {\\n                if (node->index != -1 && node->index != i && isPalindrome(s, j, s.size() - 1)) ans.push_back({ i, node->index }); \\n                // A[i]\\'s prefix matches this word and A[i]\\'s suffix forms a palindrome\\n                node = node->next[s[j] - \\'a\\'];\\n            }\\n            if (!node) continue;\\n            for (int j : node->palindromeIndexes) { \\n                // A[i] is exhausted in the matching above. \\n                // If a word whose prefix is palindrome after matching its suffix with A[i], \\n                // then this is also a valid pair\\n                if (i != j) ans.push_back({ i, j });\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Trie - Related Problems**\\n[1. Implement Trie (Prefix Tree) ](https://leetcode.com/problems/implement-trie-prefix-tree/)\\n[2. Palindrome Pairs ](https://leetcode.com/problems/palindrome-pairs/)\\n[3. Maximum XOR of Two Numbers in an Array ](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/)\\n[4. Concatenated Words ](https://leetcode.com/problems/concatenated-words/)\\n[5. Search Suggestions System ](https://leetcode.com/problems/search-suggestions-system/)\\n",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```cpp\\nstruct TrieNode {\\n    TrieNode *next[26] = {};\\n    int index = -1;\\n    vector<int> palindromeIndexes;\\n};\\n\\nclass Solution {\\n    TrieNode root; // Suffix trie\\n    void add(string &s, int i) {\\n        auto node = &root;\\n        for (int j = s.size() - 1; j >= 0; --j) {\\n            if (isPalindrome(s, 0, j)) node->palindromeIndexes.push_back(i); // A[i]\\'s prefix forms a palindrome\\n            int c = s[j] - \\'a\\';\\n            if (!node->next[c]) node->next[c] = new TrieNode();\\n            node = node->next[c];\\n        }\\n        node->index = i;\\n        node->palindromeIndexes.push_back(i); // A[i]\\'s prefix is empty string here, which is a palindrome.\\n    }\\n    \\n    bool isPalindrome(string &s, int i, int j) {\\n        while (i < j && s[i] == s[j]) ++i, --j;\\n        return i >= j;\\n    }\\n    \\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& A) {\\n        int N = A.size();\\n        for (int i = 0; i < N; ++i) add(A[i], i);\\n        vector<vector<int>> ans;\\n        for (int i = 0; i < N; ++i) {\\n            auto s = A[i];\\n            auto node = &root;\\n            for (int j = 0; j < s.size() && node; ++j) {\\n                if (node->index != -1 && node->index != i && isPalindrome(s, j, s.size() - 1)) ans.push_back({ i, node->index }); \\n                // A[i]\\'s prefix matches this word and A[i]\\'s suffix forms a palindrome\\n                node = node->next[s[j] - \\'a\\'];\\n            }\\n            if (!node) continue;\\n            for (int j : node->palindromeIndexes) { \\n                // A[i] is exhausted in the matching above. \\n                // If a word whose prefix is palindrome after matching its suffix with A[i], \\n                // then this is also a valid pair\\n                if (i != j) ans.push_back({ i, j });\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79219,
                "title": "python-solution",
                "content": "        wordict = {}\\n        res = [] \\n        for i in range(len(words)):\\n            wordict[words[i]] = i\\n        for i in range(len(words)):\\n            for j in range(len(words[i])+1):\\n                tmp1 = words[i][:j]\\n                tmp2 = words[i][j:]\\n                if tmp1[::-1] in wordict and wordict[tmp1[::-1]]!=i and tmp2 == tmp2[::-1]:\\n                    res.append([i,wordict[tmp1[::-1]]])\\n                if j!=0 and tmp2[::-1] in wordict and wordict[tmp2[::-1]]!=i and tmp1 == tmp1[::-1]:\\n                    res.append([wordict[tmp2[::-1]],i])\\n                    \\n        return res",
                "solutionTags": [],
                "code": "        wordict = {}\\n        res = [] \\n        for i in range(len(words)):\\n            wordict[words[i]] = i\\n        for i in range(len(words)):\\n            for j in range(len(words[i])+1):\\n                tmp1 = words[i][:j]\\n                tmp2 = words[i][j:]\\n                if tmp1[::-1] in wordict and wordict[tmp1[::-1]]!=i and tmp2 == tmp2[::-1]:\\n                    res.append([i,wordict[tmp1[::-1]]])\\n                if j!=0 and tmp2[::-1] in wordict and wordict[tmp2[::-1]]!=i and tmp1 == tmp1[::-1]:\\n                    res.append([wordict[tmp2[::-1]],i])\\n                    \\n        return res",
                "codeTag": "Unknown"
            },
            {
                "id": 2585763,
                "title": "java-100-149ms-hashmap-based-solution-w-video-explanation",
                "content": "*Please **Upvote** if you find this explanation helpful*\\n\\n**Video Explanation**\\n[Palindrome Pairs | YouTube](https://www.youtube.com/watch?v=C0p5J1KJ8Zk&feature=youtu.be)\\n\\n**Java Solution**\\n```\\n//149ms\\n\\nclass Solution {\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        HashMap<String,Integer> wordMap = new HashMap<>();\\n        Set<Integer> set = new TreeSet<>();\\n        int n = words.length;\\n        \\n        for(int i=0;i<n;i++){\\n            wordMap.put(words[i],i);\\n            set.add(words[i].length());\\n        }\\n        \\n        List<List<Integer>> ans = new ArrayList<>();\\n        \\n        for(int i=0;i<n;i++){\\n            int length = words[i].length();\\n            \\n            // if(length ==1){\\n            //     if(wordMap.containsKey(\"\")){\\n            //         ans.add(Arrays.asList(i, wordMap.get(\"\")));\\n            //         ans.add(Arrays.asList(wordMap.get(\"\"), i));\\n            //     }\\n            //     continue;\\n            // }\\n            String reverse= new StringBuilder(words[i]).reverse().toString();\\n            if(wordMap.containsKey(reverse) && wordMap.get(reverse) != i)\\n                ans.add(Arrays.asList(i,wordMap.get(reverse)));\\n            \\n            for(Integer k:set){\\n                if(k==length)\\n                    break;\\n                if(isPalindrome(reverse,0,length-1-k)){\\n                    String s1 = reverse.substring(length-k);\\n                    if(wordMap.containsKey(s1))\\n                        ans.add(Arrays.asList(i,wordMap.get(s1)));\\n                }\\n                \\n                if(isPalindrome(reverse,k,length-1)){\\n                    String s2 = reverse.substring(0,k);\\n                    if(wordMap.containsKey(s2))\\n                        ans.add(Arrays.asList(wordMap.get(s2),i));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private boolean isPalindrome(String s, int left, int right){\\n        while(left<right)\\n            if(s.charAt(left++)!=s.charAt(right--))\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//149ms\\n\\nclass Solution {\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        HashMap<String,Integer> wordMap = new HashMap<>();\\n        Set<Integer> set = new TreeSet<>();\\n        int n = words.length;\\n        \\n        for(int i=0;i<n;i++){\\n            wordMap.put(words[i],i);\\n            set.add(words[i].length());\\n        }\\n        \\n        List<List<Integer>> ans = new ArrayList<>();\\n        \\n        for(int i=0;i<n;i++){\\n            int length = words[i].length();\\n            \\n            // if(length ==1){\\n            //     if(wordMap.containsKey(\"\")){\\n            //         ans.add(Arrays.asList(i, wordMap.get(\"\")));\\n            //         ans.add(Arrays.asList(wordMap.get(\"\"), i));\\n            //     }\\n            //     continue;\\n            // }\\n            String reverse= new StringBuilder(words[i]).reverse().toString();\\n            if(wordMap.containsKey(reverse) && wordMap.get(reverse) != i)\\n                ans.add(Arrays.asList(i,wordMap.get(reverse)));\\n            \\n            for(Integer k:set){\\n                if(k==length)\\n                    break;\\n                if(isPalindrome(reverse,0,length-1-k)){\\n                    String s1 = reverse.substring(length-k);\\n                    if(wordMap.containsKey(s1))\\n                        ans.add(Arrays.asList(i,wordMap.get(s1)));\\n                }\\n                \\n                if(isPalindrome(reverse,k,length-1)){\\n                    String s2 = reverse.substring(0,k);\\n                    if(wordMap.containsKey(s2))\\n                        ans.add(Arrays.asList(wordMap.get(s2),i));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private boolean isPalindrome(String s, int left, int right){\\n        while(left<right)\\n            if(s.charAt(left++)!=s.charAt(right--))\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585442,
                "title": "intuitive-python3-hashmap-95-time-space-o-n-w-2",
                "content": "Please upvote if it helps!\\n```\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        backward, res = {}, []\\n        for i, word in enumerate(words):\\n            backward[word[::-1]] = i\\n\\n        for i, word in enumerate(words):\\n            \\n            if word in backward and backward[word] != i:\\n                res.append([i, backward[word]])\\n                \\n            if word != \"\" and \"\" in backward and word == word[::-1]:\\n                res.append([i, backward[\"\"]])\\n                res.append([backward[\"\"], i])\\n                \\n            for j in range(len(word)):\\n                if word[j:] in backward and word[:j] == word[j-1::-1]:\\n                    res.append([backward[word[j:]], i])\\n                if word[:j] in backward and word[j:] == word[:j-1:-1]:\\n                    res.append([i, backward[word[:j]]])\\n                    \\n        return res",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        backward, res = {}",
                "codeTag": "Java"
            },
            {
                "id": 2585633,
                "title": "c-brute-hashmap-trie-tle-fixed",
                "content": "**If you like it, please give a star, to my [Github](https://github.com/champmaniac/LeetCode) Repository and upvote this post.**\\n\\n**Intuition:** **Brute Force** : \\nWe basically check `every` pair of `words` and see if the `concatenation` of the two `words` is a `palindrome`.\\n\\n**Approach:**\\n* For each `word`, we check if the `reversed` word is in the words array.\\n* If it is, we add the `index` of the `reversed` word to the result.\\n* If the `reversed` word is not in the words array, we check if the reversed word is a prefix of the current word.\\n* If it is, we check if the **suffix** of the **current** word is a **palindrome**.\\n* If it is, we add the **index** of the **reversed** word to the **result**.\\n* Thus, we store the reversed word in a vector and return the **result**.\\n\\n**C++(TLE):**\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string word) {\\n        int i = 0;\\n        int j = word.size() - 1;\\n        while (i < j) {\\n            if (word[i] != word[j]) {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        vector<vector<int>> result;\\n        for (int i = 0; i < words.size(); i++) {\\n            for (int j = 0; j < words.size(); j++) {\\n                if (i == j) {\\n                    continue;\\n                }\\n                string word = words[i] + words[j];\\n                if (isPalindrome(word)) {\\n                    result.push_back({i, j});\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n****\\n**Time Complexity:** **O(n^2 * m)**\\n**Space Complexity:** **O(1)**\\n****\\n\\n#### The above code will give TLE because it\\'s just the brute force approach, so we need to optimize the Time Complexity.\\n**Approach:**\\n* We can use a `hashmap` to store the `words` and their `indices`.\\n* Now, we can iterate over the `words` and check if the `reversed` word exists in the `hashmap`.\\n* If it exists, then we can check if the remaining part of the word is a `palindrome`.\\n* If it is, then we can add the indices to the `result`.\\n* We can also check if the `word` is a `palindrome` and if the reversed word exists in the hashmap.\\n* If it does, then we can add the indices to the `result`.\\n\\n**C++ (YET ANOTHER TLE CODE):-**\\n```\\nbool isPalindrome(string word) {\\n        int i = 0;\\n        int j = word.size() - 1;\\n        while (i < j) {\\n            if (word[i] != word[j]) {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n}\\nvector<vector<int>> palindromePairs(vector<string>& words) {\\n        vector<vector<int>> result;\\n        unordered_map<string, int> wordMap;\\n        for (int i = 0; i < words.size(); i++) {\\n            wordMap[words[i]] = i;\\n        }\\n        for (int i = 0; i < words.size(); i++) {\\n            string word = words[i];\\n            string reversedWord = word;\\n            reverse(reversedWord.begin(), reversedWord.end());\\n            if (wordMap.find(reversedWord) != wordMap.end() && wordMap[reversedWord] != i) {\\n                result.push_back({i, wordMap[reversedWord]});\\n            }\\n            if (isPalindrome(word)) {\\n                string emptyString = \"\";\\n                if (wordMap.find(emptyString) != wordMap.end() && wordMap[emptyString] != i) {\\n                    result.push_back({i, wordMap[emptyString]});\\n                    result.push_back({wordMap[emptyString], i});\\n                }\\n            }\\n            for (int j = 1; j < word.size(); j++) {\\n                string left = word.substr(0, j);\\n                string right = word.substr(j);\\n                string reversedLeft = left;\\n                string reversedRight = right;\\n                reverse(reversedLeft.begin(), reversedLeft.end());\\n                reverse(reversedRight.begin(), reversedRight.end());\\n                if (isPalindrome(left) && wordMap.find(reversedRight) != wordMap.end()) {\\n                    result.push_back({wordMap[reversedRight], i});\\n                }\\n                if (isPalindrome(right) && wordMap.find(reversedLeft) != wordMap.end()) {\\n                    result.push_back({i, wordMap[reversedLeft]});\\n                }\\n            }\\n        }\\n        return result;\\n\\t}\\n```\\n****\\n**Time Complexity:** **O(n * k^2)** where `n` is the number of `words` and `k` is the `length` of the longest word\\n**Space Complexity:** **O(n * k)**\\n****\\n\\n#### The only way to optimize the code further is to use TRIE.\\n**Approach:**\\n* Idea is to use **Trie** to store all the words in **reverse** order \\n* For each **word**, we can check if the **current** node is a **palindrome**, if so, we can add all the **words** in the **current** node to the **answer**.\\n* We can also check if the current node is a **prefix** of the current word, if so, we can check if the remaining part of the word is a **palindrome**, if so, we can add the current word to the answer.\\n* We can also check if the current node is a **suffix** of the current word, if so, we can check if the remaining part of the word is a palindrome, if so, we can add the current word to the answer.\\n* We can also check if the current node is a **word**, if so, we can add the current word to the answer.\\n* So that we can find all the **palindromes** in `O(k)` time\\n\\n**C++(NO TLE, ACCEPTED CODE):**\\n```\\nstruct TrieNode\\n{\\n    TrieNode *child[26]={};\\n    int curIndex=-1;\\n    vector<int> wordIndex;\\n};\\nclass Solution\\n{\\n    bool isPalindrome(string &s, int i, int j)\\n    {\\n        while (i < j)\\n        {\\n            if (s[i++] != s[j--])\\n                return false;\\n        }\\n        return true;\\n    }\\n    TrieNode *root;\\n    void insert(string &s, int index)\\n    {\\n        TrieNode *cur = root;\\n        for (int i = s.size() - 1; i >= 0; i--)\\n        {\\n            int c = s[i] - \\'a\\';\\n            if (cur->child[c] == nullptr)\\n                cur->child[c] = new TrieNode();\\n            if (isPalindrome(s, 0, i))\\n                cur->wordIndex.push_back(index);\\n            cur = cur->child[c];\\n        }\\n        cur->wordIndex.push_back(index);\\n        cur->curIndex = index;\\n    }\\n\\npublic:\\n    vector<vector<int>> palindromePairs(vector<string> &words)\\n    {\\n        root = new TrieNode();\\n        for (int i = 0; i < words.size(); i++)\\n            insert(words[i], i);\\n        vector<vector<int>> ans;\\n        for (int i = 0; i < words.size(); i++)\\n        {\\n            TrieNode *cur = root;\\n            string &s = words[i];\\n            for (int j = 0; j < s.size(); j++)\\n            {\\n                if (cur->curIndex != -1 && cur->curIndex != i && isPalindrome(s, j, s.size() - 1))\\n                    ans.push_back({i, cur->curIndex});\\n                cur = cur->child[s[j] - \\'a\\'];\\n                if (cur == nullptr)\\n                    break;\\n            }\\n            if (cur == nullptr)\\n                continue;\\n            for (int j : cur->wordIndex)\\n            {\\n                if (i == j)\\n                    continue;\\n                ans.push_back({i, j});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n****\\n**Time Complexity:** **O(n * k^2)** where `n` is the number of words and `k` is the length of the longest word\\n**Space Complexity:** **O(n * k)**\\n****",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string word) {\\n        int i = 0;\\n        int j = word.size() - 1;\\n        while (i < j) {\\n            if (word[i] != word[j]) {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        vector<vector<int>> result;\\n        for (int i = 0; i < words.size(); i++) {\\n            for (int j = 0; j < words.size(); j++) {\\n                if (i == j) {\\n                    continue;\\n                }\\n                string word = words[i] + words[j];\\n                if (isPalindrome(word)) {\\n                    result.push_back({i, j});\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nbool isPalindrome(string word) {\\n        int i = 0;\\n        int j = word.size() - 1;\\n        while (i < j) {\\n            if (word[i] != word[j]) {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n}\\nvector<vector<int>> palindromePairs(vector<string>& words) {\\n        vector<vector<int>> result;\\n        unordered_map<string, int> wordMap;\\n        for (int i = 0; i < words.size(); i++) {\\n            wordMap[words[i]] = i;\\n        }\\n        for (int i = 0; i < words.size(); i++) {\\n            string word = words[i];\\n            string reversedWord = word;\\n            reverse(reversedWord.begin(), reversedWord.end());\\n            if (wordMap.find(reversedWord) != wordMap.end() && wordMap[reversedWord] != i) {\\n                result.push_back({i, wordMap[reversedWord]});\\n            }\\n            if (isPalindrome(word)) {\\n                string emptyString = \"\";\\n                if (wordMap.find(emptyString) != wordMap.end() && wordMap[emptyString] != i) {\\n                    result.push_back({i, wordMap[emptyString]});\\n                    result.push_back({wordMap[emptyString], i});\\n                }\\n            }\\n            for (int j = 1; j < word.size(); j++) {\\n                string left = word.substr(0, j);\\n                string right = word.substr(j);\\n                string reversedLeft = left;\\n                string reversedRight = right;\\n                reverse(reversedLeft.begin(), reversedLeft.end());\\n                reverse(reversedRight.begin(), reversedRight.end());\\n                if (isPalindrome(left) && wordMap.find(reversedRight) != wordMap.end()) {\\n                    result.push_back({wordMap[reversedRight], i});\\n                }\\n                if (isPalindrome(right) && wordMap.find(reversedLeft) != wordMap.end()) {\\n                    result.push_back({i, wordMap[reversedLeft]});\\n                }\\n            }\\n        }\\n        return result;\\n\\t}\\n```\n```\\nstruct TrieNode\\n{\\n    TrieNode *child[26]={};\\n    int curIndex=-1;\\n    vector<int> wordIndex;\\n};\\nclass Solution\\n{\\n    bool isPalindrome(string &s, int i, int j)\\n    {\\n        while (i < j)\\n        {\\n            if (s[i++] != s[j--])\\n                return false;\\n        }\\n        return true;\\n    }\\n    TrieNode *root;\\n    void insert(string &s, int index)\\n    {\\n        TrieNode *cur = root;\\n        for (int i = s.size() - 1; i >= 0; i--)\\n        {\\n            int c = s[i] - \\'a\\';\\n            if (cur->child[c] == nullptr)\\n                cur->child[c] = new TrieNode();\\n            if (isPalindrome(s, 0, i))\\n                cur->wordIndex.push_back(index);\\n            cur = cur->child[c];\\n        }\\n        cur->wordIndex.push_back(index);\\n        cur->curIndex = index;\\n    }\\n\\npublic:\\n    vector<vector<int>> palindromePairs(vector<string> &words)\\n    {\\n        root = new TrieNode();\\n        for (int i = 0; i < words.size(); i++)\\n            insert(words[i], i);\\n        vector<vector<int>> ans;\\n        for (int i = 0; i < words.size(); i++)\\n        {\\n            TrieNode *cur = root;\\n            string &s = words[i];\\n            for (int j = 0; j < s.size(); j++)\\n            {\\n                if (cur->curIndex != -1 && cur->curIndex != i && isPalindrome(s, j, s.size() - 1))\\n                    ans.push_back({i, cur->curIndex});\\n                cur = cur->child[s[j] - \\'a\\'];\\n                if (cur == nullptr)\\n                    break;\\n            }\\n            if (cur == nullptr)\\n                continue;\\n            for (int j : cur->wordIndex)\\n            {\\n                if (i == j)\\n                    continue;\\n                ans.push_back({i, j});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79217,
                "title": "accepted-short-java-solution-using-hashmap",
                "content": "\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        List<List<Integer>> pairs = new LinkedList<>();\\n        if (words == null) return pairs;\\n        HashMap<String, Integer> map = new HashMap<>();\\n        for (int i = 0; i < words.length; ++ i) map.put(words[i], i);\\n        for (int i = 0; i < words.length; ++ i) {\\n            int l = 0, r = 0;\\n            while (l <= r) {\\n                String s = words[i].substring(l, r);\\n                Integer j = map.get(new StringBuilder(s).reverse().toString());\\n                if (j != null && i != j && isPalindrome(words[i].substring(l == 0 ? r : 0, l == 0 ? words[i].length() : l)))\\n                    pairs.add(Arrays.asList(l == 0 ? new Integer[]{i, j} : new Integer[]{j, i}));\\n                if (r < words[i].length()) ++r;\\n                else ++l;\\n            }\\n        }\\n        return pairs;\\n    }\\n    \\n    private boolean isPalindrome(String s) {\\n        for (int i = 0; i < s.length()/2; ++ i)\\n            if (s.charAt(i) != s.charAt(s.length()-1-i))\\n                return false;\\n        return true;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        List<List<Integer>> pairs = new LinkedList<>();\\n        if (words == null) return pairs;\\n        HashMap<String, Integer> map = new HashMap<>();\\n        for (int i = 0; i < words.length; ++ i) map.put(words[i], i);\\n        for (int i = 0; i < words.length; ++ i) {\\n            int l = 0, r = 0;\\n            while (l <= r) {\\n                String s = words[i].substring(l, r);\\n                Integer j = map.get(new StringBuilder(s).reverse().toString());\\n                if (j != null && i != j && isPalindrome(words[i].substring(l == 0 ? r : 0, l == 0 ? words[i].length() : l)))\\n                    pairs.add(Arrays.asList(l == 0 ? new Integer[]{i, j} : new Integer[]{j, i}));\\n                if (r < words[i].length()) ++r;\\n                else ++l;\\n            }\\n        }\\n        return pairs;\\n    }\\n    \\n    private boolean isPalindrome(String s) {\\n        for (int i = 0; i < s.length()/2; ++ i)\\n            if (s.charAt(i) != s.charAt(s.length()-1-i))\\n                return false;\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 79202,
                "title": "clean-c-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        vector<vector<int>> result;\\n        unordered_map<string, int> dict;\\n        for(int i = 0; i < words.size(); i++) {\\n            dict[words[i]] = i;\\n        }\\n        for(int i = 0; i < words.size(); i++) {\\n            for(int j = 0; j <= words[i].length(); j++) {\\n                //check the suffix word\\n                if(is_palindrome(words[i], j, words[i].size() - 1)) {\\n                    /** the suffix word can be null to all the word **/\\n                    string suffix = words[i].substr(0, j);\\n                    reverse(suffix.begin(), suffix.end());\\n                    if(dict.find(suffix) != dict.end() && i != dict[suffix]) {\\n                        result.push_back({i, dict[suffix]});\\n                    }\\n                }\\n                //check the prefix word \\n                if(j > 0 && is_palindrome(words[i], 0, j - 1)) {\\n                    string prefix = words[i].substr(j);\\n                    reverse(prefix.begin(), prefix.end());\\n                    if(dict.find(prefix) != dict.end() && dict[prefix] != i) {\\n                        result.push_back({dict[prefix], i});\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    bool is_palindrome(string& s, int start, int end) {\\n        while(start < end) {\\n            if(s[start++] != s[end--]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        vector<vector<int>> result;\\n        unordered_map<string, int> dict;\\n        for(int i = 0; i < words.size(); i++) {\\n            dict[words[i]] = i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2585819,
                "title": "left-mid-right-palindrome-easy-to-understand-c-code",
                "content": "Before jumping to the solution let me make a statement which will make you remember the solution forever:\\n\\n**A palindrome is made up of 3 strings which are left, mid and right.**\\n\\nPalindrome = (Left + Mid + Right)\\n\\n**where:\\nMid = A Palindrome string\\nRight = reverse(Left)**\\n\\nMid and Left,Right can be empty too.\\nBut the conditions which are written above should hold to form a palindrome.\\n\\nExample: \\nstring = \"abcddcba\"\\nLeft = \"abc\"\\nMid = \"dd\"\\nRight = \"cba\" = reverse(Left)\\n\\nYou can apply this analogy to any palindrome.\\n\\nNow let\\'s understand the solution.\\n\\nAssume we are having two strings, str1 and str2\\nand\\nstr1 + str2 = Palindome\\n\\nNow two cases arise when we think in terms of left,mid and right.\\n\\nEither\\n\\nstr1 = Left + Mid\\nand \\nstr2 = Right\\n\\nOr\\n\\nstr1 = Left\\nand \\nstr2 = Mid + Right\\n\\nNow let\\'s say Im traversing the input array and I have a string, let\\'s say X.\\n\\nNow we can assume that our string X is (Left + Mid)\\nand then search for Right(which is reverse of Left) through a data stucture.\\nYou can use hashmap or Trie here, your choice.\\n\\nOr we can also assume our string is (Mid + Right)\\nand then search for Left(which is reverse of Right) \\n\\nAnd dividing the input string into (Left + Mid) or (Mid + Right) can be easily done by just traversing over the string using a for loop.\\n\\nC++ Code:\\n```\\nclass Solution {\\nprivate:\\n\\tbool isPalindrome(string& word, int l, int r) {\\n\\t\\twhile (l < r) {\\n\\t\\t\\tif (word[l] != word[r]) return false;\\n\\t\\t\\tl++; r--;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\npublic:\\n\\tvector<vector<int>> palindromePairs(vector<string>& words) {\\n\\t\\tunordered_map<string, int> mp;\\n\\t\\tvector<vector<int>> ans;\\n\\t\\tfor (int i = 0; i < words.size(); ++i) {\\n\\t\\t\\tif (words[i] == \"\")\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tstring str = words[i];\\n\\t\\t\\t//Inserting reverse so that we dont have to reverse every substring in later part\\n\\t\\t\\treverse(begin(str), end(str));\\n\\t\\t\\tmp[str] = i;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < words.size(); ++i) {\\n\\t\\t\\tif (words[i] == \"\")\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor (int j = 0; j < words.size(); ++j)\\n\\t\\t\\t\\t\\tif (i != j && isPalindrome(words[j], 0, words[j].size() - 1))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tans.push_back({i, j});\\n\\t\\t\\t\\t\\t\\tans.push_back({j, i});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tfor (int cut = 0; cut < words[i].size(); ++cut) {\\n\\t\\t\\t\\t//Current String gives Left + Mid\\n\\t\\t\\t\\t//We need to check whether Mid is Palindrome or not\\n\\t\\t\\t\\t//If yes, we need to search for Right\\n\\t\\t\\t\\t// Left = {0, cut-1}\\n\\t\\t\\t\\t// Mid = {cut, words[i].size() - 1}\\n\\t\\t\\t\\tif (isPalindrome(words[i], cut, words[i].size() - 1)) {\\n\\t\\t\\t\\t\\tstring right = words[i].substr(0, cut);\\n\\t\\t\\t\\t\\tif (mp.find(right) != end(mp) && mp[right] != i) {\\n\\t\\t\\t\\t\\t\\tans.push_back({i, mp[right]});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t//Current String gives Mid + Right\\n\\t\\t\\t\\t//We need to check whether Mid is Palindrome or not\\n\\t\\t\\t\\t//If yes, we need to search for Left\\n\\t\\t\\t\\t// Mid = {0, cut-1}\\n\\t\\t\\t\\t// Right = {cut, words[i].size() - 1}\\n\\t\\t\\t\\tif (isPalindrome(words[i], 0, cut - 1)) {\\n\\t\\t\\t\\t\\tstring left = words[i].substr(cut);\\n\\t\\t\\t\\t\\tif (mp.find(left) != end(mp) && mp[left] != i) {\\n\\t\\t\\t\\t\\t\\tans.push_back({mp[left], i});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\\n\\nI hope you understood.\\nPlease upvote if you like the explanation.\\n\\nYou can also have a look on this video made by me if you are looking for a code walkthrough:\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/bL7o_uM7e9g?start=398\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n\\nIf you are trying to run my code, just remove the comments, it will work :)\\n\\nTime Complexity = O(n * k^2)\\nSpave Complexity = O(n), Hashmap",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n\\tbool isPalindrome(string& word, int l, int r) {\\n\\t\\twhile (l < r) {\\n\\t\\t\\tif (word[l] != word[r]) return false;\\n\\t\\t\\tl++; r--;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\npublic:\\n\\tvector<vector<int>> palindromePairs(vector<string>& words) {\\n\\t\\tunordered_map<string, int> mp;\\n\\t\\tvector<vector<int>> ans;\\n\\t\\tfor (int i = 0; i < words.size(); ++i) {\\n\\t\\t\\tif (words[i] == \"\")\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tstring str = words[i];\\n\\t\\t\\t//Inserting reverse so that we dont have to reverse every substring in later part\\n\\t\\t\\treverse(begin(str), end(str));\\n\\t\\t\\tmp[str] = i;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < words.size(); ++i) {\\n\\t\\t\\tif (words[i] == \"\")\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor (int j = 0; j < words.size(); ++j)\\n\\t\\t\\t\\t\\tif (i != j && isPalindrome(words[j], 0, words[j].size() - 1))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tans.push_back({i, j});\\n\\t\\t\\t\\t\\t\\tans.push_back({j, i});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tfor (int cut = 0; cut < words[i].size(); ++cut) {\\n\\t\\t\\t\\t//Current String gives Left + Mid\\n\\t\\t\\t\\t//We need to check whether Mid is Palindrome or not\\n\\t\\t\\t\\t//If yes, we need to search for Right\\n\\t\\t\\t\\t// Left = {0, cut-1}\\n\\t\\t\\t\\t// Mid = {cut, words[i].size() - 1}\\n\\t\\t\\t\\tif (isPalindrome(words[i], cut, words[i].size() - 1)) {\\n\\t\\t\\t\\t\\tstring right = words[i].substr(0, cut);\\n\\t\\t\\t\\t\\tif (mp.find(right) != end(mp) && mp[right] != i) {\\n\\t\\t\\t\\t\\t\\tans.push_back({i, mp[right]});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t//Current String gives Mid + Right\\n\\t\\t\\t\\t//We need to check whether Mid is Palindrome or not\\n\\t\\t\\t\\t//If yes, we need to search for Left\\n\\t\\t\\t\\t// Mid = {0, cut-1}\\n\\t\\t\\t\\t// Right = {cut, words[i].size() - 1}\\n\\t\\t\\t\\tif (isPalindrome(words[i], 0, cut - 1)) {\\n\\t\\t\\t\\t\\tstring left = words[i].substr(cut);\\n\\t\\t\\t\\t\\tif (mp.find(left) != end(mp) && mp[left] != i) {\\n\\t\\t\\t\\t\\t\\tans.push_back({mp[left], i});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 273990,
                "title": "python-3-solution-with-comments-92-55",
                "content": "```\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        d = {w: i for i, w in enumerate(words)}\\n        ans = []\\n        for i, w in enumerate(words):\\n            # no divide, two cases\\n            if w[::-1] in d and d[w[::-1]] != i:\\n                ans.append([i, d[w[::-1]]])\\n            if w != \\'\\' and w[::-1] == w and \\'\\' in d:\\n                ans.append([i, d[\\'\\']])\\n                ans.append([d[\\'\\'], i])\\n            \\n            # divide into two parts, can\\'t be self, another two cases\\n            for k in range(1, len(w)):\\n                s1, s2 = w[:k], w[k:]\\n                if s1 == s1[::-1] and s2[::-1] in d:\\n                    ans.append([d[s2[::-1]], i])\\n                if s2 == s2[::-1] and s1[::-1] in d:\\n                    ans.append([i, d[s1[::-1]]])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        d = {w: i for i, w in enumerate(words)}\\n        ans = []\\n        for i, w in enumerate(words):\\n            # no divide, two cases\\n            if w[::-1] in d and d[w[::-1]] != i:\\n                ans.append([i, d[w[::-1]]])\\n            if w != \\'\\' and w[::-1] == w and \\'\\' in d:\\n                ans.append([i, d[\\'\\']])\\n                ans.append([d[\\'\\'], i])\\n            \\n            # divide into two parts, can\\'t be self, another two cases\\n            for k in range(1, len(w)):\\n                s1, s2 = w[:k], w[k:]\\n                if s1 == s1[::-1] and s2[::-1] in d:\\n                    ans.append([d[s2[::-1]], i])\\n                if s2 == s2[::-1] and s1[::-1] in d:\\n                    ans.append([i, d[s1[::-1]]])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1270450,
                "title": "python-faster-than-99-and-only-15-lines-of-code-a-simple-approach",
                "content": "This solution is O(n\\\\*k) time and space complexity (k is word length) and uses a very easy approach.\\nThe concatenated w1+w2 is palindrom if and only if:\\n* len(w1)==len(w2) and the reversed w1 equals w2\\n* len(w1)>len(w2) and the w1 must start with the reversed w2 and the remaining part of w1 should be a palindrome itself\\n* len(w1)<len(w2) and w2 must end with the reversed w1 and the remaining part of w2 should be a palindrome itself\\n\\nThe algorithm stores all reversed words with their index associated, and checks all words with all possible splits - checks for a pair as a shorter word for one of them, and palindromness for the other. The code is short and easy to understand.\\n\\n```\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        rmap={w[::-1]:i for i,w in enumerate(words)}\\n        res=[]\\n        for i,wrd in enumerate(words):\\n            rev=wrd[::-1]\\n            if wrd in rmap:                        # same length pair\\n                if rmap[wrd]!=i:                   # i and j should be distinct\\n                    res.append((i,rmap[wrd]))\\n            for j in range(1,len(wrd)+1):          # first or last j characters as palindrome, other part has pair\\n                if wrd[:-j] in rmap and wrd[-j:]==rev[:j]:\\n                    res.append((i,rmap[wrd[:-j]]))\\n                if wrd[j:] in rmap and wrd[:j]==rev[-j:]:\\n                    res.append((rmap[wrd[j:]],i))\\n        return res\\n```\\nPlease upvote if you like this solution style!\\nAny questions, remarks are welcome.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        rmap={w[::-1]:i for i,w in enumerate(words)}\\n        res=[]\\n        for i,wrd in enumerate(words):\\n            rev=wrd[::-1]\\n            if wrd in rmap:                        # same length pair\\n                if rmap[wrd]!=i:                   # i and j should be distinct\\n                    res.append((i,rmap[wrd]))\\n            for j in range(1,len(wrd)+1):          # first or last j characters as palindrome, other part has pair\\n                if wrd[:-j] in rmap and wrd[-j:]==rev[:j]:\\n                    res.append((i,rmap[wrd[:-j]]))\\n                if wrd[j:] in rmap and wrd[:j]==rev[-j:]:\\n                    res.append((rmap[wrd[j:]],i))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 148357,
                "title": "17-line-python-solution-trie-and-non-trie-explained-with-diagrams",
                "content": "Full description of trie solution with pics (conclusion on page explains why you might care about trie solution even though simple solution below exists): https://fizzbuzzed.com/top-interview-questions-5/\\n\\nSimpler no trie solution. Split into 2 cases as explained in the comments:\\n\\n```python\\ndef isPalindrome(word):\\n    return word == word[::-1]\\n\\ndef palindromePairs(words):\\n    output = []\\n    word_to_index = {word: i for i, word in enumerate(words)}\\n    for i, word1 in enumerate(words):\\n        for j in range(len(word1)+1):\\n            # Case 1 - Find all words, B, shorter than or the same size as\\n            # word1, that can be prepended so B + word1 is a palindrome.\\n            x_reversed = word1[j:][::-1]\\n            rest = word1[0:j]\\n            if isPalindrome(rest) and x_reversed in word_to_index and word_to_index[x_reversed] != i:\\n                output.append([word_to_index[x_reversed], i])\\n            # Case 2 - Find all words, B, shorter than word1 that can be appended\\n            # so word1 + B is a palindrome.\\n            if j == len(word1): continue\\n            x_reversed = word1[:j][::-1] \\n            rest = word1[j:]\\n            if isPalindrome(rest) and x_reversed in word_to_index and word_to_index[x_reversed] != i:\\n                output.append([i, word_to_index[x_reversed]])\\n    return output\\n```\\n",
                "solutionTags": [],
                "code": "```python\\ndef isPalindrome(word):\\n    return word == word[::-1]\\n\\ndef palindromePairs(words):\\n    output = []\\n    word_to_index = {word: i for i, word in enumerate(words)}\\n    for i, word1 in enumerate(words):\\n        for j in range(len(word1)+1):\\n            # Case 1 - Find all words, B, shorter than or the same size as\\n            # word1, that can be prepended so B + word1 is a palindrome.\\n            x_reversed = word1[j:][::-1]\\n            rest = word1[0:j]\\n            if isPalindrome(rest) and x_reversed in word_to_index and word_to_index[x_reversed] != i:\\n                output.append([word_to_index[x_reversed], i])\\n            # Case 2 - Find all words, B, shorter than word1 that can be appended\\n            # so word1 + B is a palindrome.\\n            if j == len(word1): continue\\n            x_reversed = word1[:j][::-1] \\n            rest = word1[j:]\\n            if isPalindrome(rest) and x_reversed in word_to_index and word_to_index[x_reversed] != i:\\n                output.append([i, word_to_index[x_reversed]])\\n    return output\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2585678,
                "title": "java-easy-solution-detailed-explanation-beginner-friendly-hashmap",
                "content": "\\n\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\n\\tNumber of cases :\\nCase1: If s1 is a blank string, then for any string that is palindrome s2, s1+s2 and s2+s1 are palindrome.\\nCase 2: If s2 is the reversing string of s1, then s1+s2 and s2+s1 are palindrome.\\nCase 3: If s1[0:cut] is palindrome and there exists s2 is the reversing string of s1[cut+1:] , then s2+s1 is palindrome.``\\nCase 4: Similiar to case3. If s1[cut+1: ] is palindrome and there exists s2 is the reversing string of s1[0:cut] , then s1+s2 is palindrome\\n```\\n```\\npublic class Solution {\\npublic List<List<Integer>> palindromePairs(String[] words) {\\n    List<List<Integer>> res = new ArrayList<List<Integer>>();\\n    if(words == null || words.length == 0){\\n        return res;\\n    }\\n    //build the map save the key-val pairs: String - idx\\n    HashMap<String, Integer> map = new HashMap<>();\\n    for(int i = 0; i < words.length; i++){\\n        map.put(words[i], i);\\n    }\\n    \\n    //special cases: \"\" can be combine with any palindrome string\\n    if(map.containsKey(\"\")){\\n        int blankIdx = map.get(\"\");\\n        for(int i = 0; i < words.length; i++){\\n            if(isPalindrome(words[i])){\\n                if(i == blankIdx) continue;\\n                res.add(Arrays.asList(blankIdx, i));\\n                res.add(Arrays.asList(i, blankIdx));\\n            }\\n        }\\n    }\\n    \\n    //find all string and reverse string pairs\\n    for(int i = 0; i < words.length; i++){\\n        String cur_r = reverseStr(words[i]);\\n        if(map.containsKey(cur_r)){\\n            int found = map.get(cur_r);\\n            if(found == i) continue;\\n            res.add(Arrays.asList(i, found));\\n        }\\n    }\\n    \\n    //find the pair s1, s2 that \\n    //case1 : s1[0:cut] is palindrome and s1[cut+1:] = reverse(s2) => (s2, s1)\\n    //case2 : s1[cut+1:] is palindrome and s1[0:cut] = reverse(s2) => (s1, s2)\\n    for(int i = 0; i < words.length; i++){\\n        String cur = words[i];\\n        for(int cut = 1; cut < cur.length(); cut++){\\n            if(isPalindrome(cur.substring(0, cut))){\\n                String cut_r = reverseStr(cur.substring(cut));\\n                if(map.containsKey(cut_r)){\\n                    int found = map.get(cut_r);\\n                    if(found == i) continue;\\n                    res.add(Arrays.asList(found, i));\\n                }\\n            }\\n            if(isPalindrome(cur.substring(cut))){\\n                String cut_r = reverseStr(cur.substring(0, cut));\\n                if(map.containsKey(cut_r)){\\n                    int found = map.get(cut_r);\\n                    if(found == i) continue;\\n                    res.add(Arrays.asList(i, found));\\n                }\\n            }\\n        }\\n    }\\n    \\n    return res;\\n}\\n\\npublic String reverseStr(String str){\\n    StringBuilder sb= new StringBuilder(str);\\n    return sb.reverse().toString();\\n}\\n\\npublic boolean isPalindrome(String s){\\n    int i = 0;\\n    int j = s.length() - 1;\\n    while(i <= j){\\n        if(s.charAt(i) != s.charAt(j)){\\n            return false;\\n        }\\n        i++;\\n        j--;\\n    }\\n    return true;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\tNumber of cases :\\nCase1: If s1 is a blank string, then for any string that is palindrome s2, s1+s2 and s2+s1 are palindrome.\\nCase 2: If s2 is the reversing string of s1, then s1+s2 and s2+s1 are palindrome.\\nCase 3: If s1[0:cut] is palindrome and there exists s2 is the reversing string of s1[cut+1:] , then s2+s1 is palindrome.``\\nCase 4: Similiar to case3. If s1[cut+1: ] is palindrome and there exists s2 is the reversing string of s1[0:cut] , then s1+s2 is palindrome\\n```\n```\\npublic class Solution {\\npublic List<List<Integer>> palindromePairs(String[] words) {\\n    List<List<Integer>> res = new ArrayList<List<Integer>>();\\n    if(words == null || words.length == 0){\\n        return res;\\n    }\\n    //build the map save the key-val pairs: String - idx\\n    HashMap<String, Integer> map = new HashMap<>();\\n    for(int i = 0; i < words.length; i++){\\n        map.put(words[i], i);\\n    }\\n    \\n    //special cases: \"\" can be combine with any palindrome string\\n    if(map.containsKey(\"\")){\\n        int blankIdx = map.get(\"\");\\n        for(int i = 0; i < words.length; i++){\\n            if(isPalindrome(words[i])){\\n                if(i == blankIdx) continue;\\n                res.add(Arrays.asList(blankIdx, i));\\n                res.add(Arrays.asList(i, blankIdx));\\n            }\\n        }\\n    }\\n    \\n    //find all string and reverse string pairs\\n    for(int i = 0; i < words.length; i++){\\n        String cur_r = reverseStr(words[i]);\\n        if(map.containsKey(cur_r)){\\n            int found = map.get(cur_r);\\n            if(found == i) continue;\\n            res.add(Arrays.asList(i, found));\\n        }\\n    }\\n    \\n    //find the pair s1, s2 that \\n    //case1 : s1[0:cut] is palindrome and s1[cut+1:] = reverse(s2) => (s2, s1)\\n    //case2 : s1[cut+1:] is palindrome and s1[0:cut] = reverse(s2) => (s1, s2)\\n    for(int i = 0; i < words.length; i++){\\n        String cur = words[i];\\n        for(int cut = 1; cut < cur.length(); cut++){\\n            if(isPalindrome(cur.substring(0, cut))){\\n                String cut_r = reverseStr(cur.substring(cut));\\n                if(map.containsKey(cut_r)){\\n                    int found = map.get(cut_r);\\n                    if(found == i) continue;\\n                    res.add(Arrays.asList(found, i));\\n                }\\n            }\\n            if(isPalindrome(cur.substring(cut))){\\n                String cut_r = reverseStr(cur.substring(0, cut));\\n                if(map.containsKey(cut_r)){\\n                    int found = map.get(cut_r);\\n                    if(found == i) continue;\\n                    res.add(Arrays.asList(i, found));\\n                }\\n            }\\n        }\\n    }\\n    \\n    return res;\\n}\\n\\npublic String reverseStr(String str){\\n    StringBuilder sb= new StringBuilder(str);\\n    return sb.reverse().toString();\\n}\\n\\npublic boolean isPalindrome(String s){\\n    int i = 0;\\n    int j = s.length() - 1;\\n    while(i <= j){\\n        if(s.charAt(i) != s.charAt(j)){\\n            return false;\\n        }\\n        i++;\\n        j--;\\n    }\\n    return true;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1269442,
                "title": "python-o-nk-2-n-2-prefix-suffix-solution-explained",
                "content": "Let `n` be number of words and `k` be average length of word. Then there is trivial algorithm with complexity `O(n^2k)`. There is better algorithm: for each word we can evaluate all prefixes and suffixes, and check if they are palindromes: for example if we have `abcxxyxx, cba`, if we want to combine them we need suffix `xxyxx` to be palindrome; if we want to combine `abc, xyyxcba`, we want prefix `xyyx` to be palindrome. So we do the following steps:\\n \\n 1. For each word, and each suffix/prefix of length `i`, we check if it is palindrome and if it is, we put prefix/suffix to our hash table `W_d`. Note, that for the case `abcxxyxx` we found suffix `xxyxx` which is palindrome, but we put prefix `abc` to our hash table. Note also that we need to handle the cases of empty suffixes/prefixes. For example if we have `abc` and `cba`, then we can connect these two strings in two ways, and we can say that we take empty prefix/suffix here. So, what will be kept in `W_d` is pairs `(t, ind)`, where `ind` is index of word and first element is `-1` for non-empty prefix, `1` for non-empty suffix and `0` for empty suffix **or** prefix.\\n 2. Now, we want to iterate through our `W` once again and for any word we look at `W_d[word[::-1]]`: possible candidates for this word. We need to make sure that candidate we found is not equal to word we consider at the moment. Next, if `one < 0`, it means, that we consider non-empty prefixes, that is why we consider `one <= 0` and append pair to our final answer. Same logic is for `one >= 0`. In this way for non-empty prefixes/suffixes we will deal with them only once and for empty we deal with them twice as it should be.\\n 3. In the end we remove duplicates: return set.\\n\\n#### Complexity\\nFor each word we make `O(k^2)` preprocessing, so in total we have `O(nk^2)` time for the first step. For the second step we traverse each element in values of `W_d` only once and we have no more than `O(n^2)` of them, so total time complexity is `O(nk^2 + n^2)`. Space complexity is `O(n^2)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def palindromePairs(self, W):\\n        W_d, ans = defaultdict(list), []\\n\\n        for idx, word in enumerate(W):\\n            W_d[word].append([0, idx])\\n            for i in range(1, len(word) + 1):\\n                suff, pref = word[:i], word[i:]\\n                if suff == suff[::-1]:\\n                    W_d[pref].append([- (pref != \"\"),idx])\\n                if pref == pref[::-1]:\\n                    W_d[suff].append([+ (suff != \"\"),idx])\\n                    \\n        for idx, word in enumerate(W):\\n            for one, two in W_d[word[::-1]]:\\n                if idx != two and one <= 0: \\n                    ans.append((idx, two))\\n                if idx != two and one >= 0: \\n                    ans.append((two, idx))\\n                    \\n        return set(ans)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Suffix Array"
                ],
                "code": "```python\\nclass Solution:\\n    def palindromePairs(self, W):\\n        W_d, ans = defaultdict(list), []\\n\\n        for idx, word in enumerate(W):\\n            W_d[word].append([0, idx])\\n            for i in range(1, len(word) + 1):\\n                suff, pref = word[:i], word[i:]\\n                if suff == suff[::-1]:\\n                    W_d[pref].append([- (pref != \"\"),idx])\\n                if pref == pref[::-1]:\\n                    W_d[suff].append([+ (suff != \"\"),idx])\\n                    \\n        for idx, word in enumerate(W):\\n            for one, two in W_d[word[::-1]]:\\n                if idx != two and one <= 0: \\n                    ans.append((idx, two))\\n                if idx != two and one >= 0: \\n                    ans.append((two, idx))\\n                    \\n        return set(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585453,
                "title": "python-hashmap-simple-and-intuitive",
                "content": "**tl;dr**\\n\\n- Iterate through words and map each to its index\\n- For each word, generate all possible (left-hand-side) and (right-hand-side) that could form a palindrome with current word\\n- Look up if we have a pair against the map in constant time\\n- Handle edge case where current word is already a palindrome and we have an empty string in the wordList\\n\\n**Solution**\\n```\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        # keep a hashmap of word to its index\\n        idx_map = {}\\n        for i, word in enumerate(words):\\n            idx_map[word] = i\\n            \\n        res = set()\\n        for i, word in enumerate(words):\\n            if not word:\\n                # we don\\'t process empty string by itself\\n                continue\\n            \\n            # generate all possible LHS that would form\\n            # a palindrome with current word\\n            for j in range(len(word)):\\n                current = word[:j]\\n                target = word[j:][::-1]\\n                if current == current[::-1] and target != word and target in idx_map:\\n                    res.add((idx_map[target], i))\\n                    \\n            # generate all possible RHS that would form\\n            # a palindrome with current word\\n            for j in range(len(word), -1, -1):\\n                current = word[j:]\\n                target = word[:j][::-1]\\n                if current == current[::-1] and target != word and target in idx_map:\\n                    res.add((i, idx_map[target]))\\n                    \\n            # check if current word is already a palindrome and\\n            # if we have an empty string in our map\\n            if word == word[::-1] and \"\" in idx_map:\\n                idx = idx_map[\"\"]\\n                res.add((i, idx))\\n                res.add((idx, i))\\n\\n        return list(res)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        # keep a hashmap of word to its index\\n        idx_map = {}\\n        for i, word in enumerate(words):\\n            idx_map[word] = i\\n            \\n        res = set()\\n        for i, word in enumerate(words):\\n            if not word:\\n                # we don\\'t process empty string by itself\\n                continue\\n            \\n            # generate all possible LHS that would form\\n            # a palindrome with current word\\n            for j in range(len(word)):\\n                current = word[:j]\\n                target = word[j:][::-1]\\n                if current == current[::-1] and target != word and target in idx_map:\\n                    res.add((idx_map[target], i))\\n                    \\n            # generate all possible RHS that would form\\n            # a palindrome with current word\\n            for j in range(len(word), -1, -1):\\n                current = word[j:]\\n                target = word[:j][::-1]\\n                if current == current[::-1] and target != word and target in idx_map:\\n                    res.add((i, idx_map[target]))\\n                    \\n            # check if current word is already a palindrome and\\n            # if we have an empty string in our map\\n            if word == word[::-1] and \"\" in idx_map:\\n                idx = idx_map[\"\"]\\n                res.add((i, idx))\\n                res.add((idx, i))\\n\\n        return list(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450251,
                "title": "c-trie-implementation",
                "content": "Explanation : First Insert all strings in reverse order, then search for each string , whether it forms a palindorme or not in Trie.\\nTrick -> If some characters matches while searching, then check if all other substrings after this point, are they palindrome or not.\\nObservation : If any string matches with some characters of other string from end, then only the left over part of string is the one we have to check are palindrome or not.\\nExample : \\nFirst case ----> ABACD, DC => Reverse ABACD --> DCABA, now DC matches with DC, so check is ABA is Palindrome or not.\\nsecond case ----> AB, BACC => reverse AB  --> BA, now in BACC, substring BA matches BA in first string, so check if CC is Palindrome or not.\\n\\nSo the logic is to insert all stringes in reverse into Trie and then check for each string by searching in Trie (without reversing search string).\\n\\nI hope this will help.\\nPLEASE UPVOTE IF YOU LIKE MY CODE.\\n\\n```\\nstruct TrieNode{\\n    TrieNode *children[26];\\n    int index;\\n    TrieNode() : index(-1) {\\n        for(int i = 0; i < 26; i++) {\\n            children[i] = NULL;\\n        }\\n    }\\n};\\n\\nvoid insert(TrieNode* root, string s, int i) {\\n    // first reverse and add strings into trie.\\n    reverse(s.begin(), s.end());\\n    TrieNode *ptr = root;\\n    for(char c : s) {\\n        int index = c - \\'a\\';\\n        if(!ptr->children[index]) {\\n            ptr->children[index] = new TrieNode();\\n        }\\n        ptr = ptr->children[index];\\n    }\\n    // index of string.\\n    ptr->index = i;\\n    return;\\n}\\n\\nvoid find(TrieNode* root, vector<int> &palindromes, string s = \"\") {\\n    // base condition, if formed string is a palindrome or not.\\n    if(root->index != -1) {\\n        int i = 0, j = s.length() - 1;\\n        //cout<<s<<endl;\\n        bool flag = true;\\n        while(i <= j) {\\n            if(s[i] != s[j]) {\\n                flag = false;\\n                break;\\n            }\\n            i++;\\n            j--;\\n        }\\n        if(flag)\\n            palindromes.push_back(root->index);\\n    }\\n    for(int i = 0; i < 26; i++) {\\n        if(root->children[i]) {\\n            char c = \\'a\\' + i;\\n            s.push_back(c);\\n            find(root->children[i], palindromes, s);\\n            s.pop_back();\\n        }\\n    }\\n    return;\\n}\\n\\nvector<int> search(TrieNode* root, string s) {\\n    vector<int> palindromes;\\n    TrieNode* ptr = root;\\n    for(int i = 0; i < s.length(); i++) {\\n        char c= s[i];\\n        int index = c - \\'a\\';\\n        // If any strings ends here, then check if out left out string is palindrome or not.\\n        if(ptr->index != -1) {\\n            int j = i, k = s.length() - 1;\\n            bool flag = true;\\n            while(j <= k) {\\n                if(s[j] != s[k]) {\\n                    flag = false;\\n                    break;\\n                }\\n                j++;\\n                k--;\\n            }\\n            if(flag)\\n                palindromes.push_back(ptr->index);\\n        }\\n        // If no characters ahead matching.\\n        if(!ptr->children[index]) {\\n            return palindromes;\\n        }\\n        ptr = ptr->children[index];\\n    }\\n    find(ptr, palindromes);\\n    return palindromes;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        struct TrieNode* root = new TrieNode();\\n        int i = 0;\\n        for(string s : words) {\\n            // insert into trie.\\n            insert(root, s, i++);\\n        }\\n        vector<vector<int>> result;\\n        i = 0;\\n        for(string s : words) {\\n            // search for all palindromes.\\n            vector<int> palindromes = search(root, s);\\n            //cout<<s<<endl;\\n            // add all palindromes into result.\\n            for(int x : palindromes) {\\n                if(i != x)\\n                    result.push_back({i, x});\\n            }\\n            i++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct TrieNode{\\n    TrieNode *children[26];\\n    int index;\\n    TrieNode() : index(-1) {\\n        for(int i = 0; i < 26; i++) {\\n            children[i] = NULL;\\n        }\\n    }\\n};\\n\\nvoid insert(TrieNode* root, string s, int i) {\\n    // first reverse and add strings into trie.\\n    reverse(s.begin(), s.end());\\n    TrieNode *ptr = root;\\n    for(char c : s) {\\n        int index = c - \\'a\\';\\n        if(!ptr->children[index]) {\\n            ptr->children[index] = new TrieNode();\\n        }\\n        ptr = ptr->children[index];\\n    }\\n    // index of string.\\n    ptr->index = i;\\n    return;\\n}\\n\\nvoid find(TrieNode* root, vector<int> &palindromes, string s = \"\") {\\n    // base condition, if formed string is a palindrome or not.\\n    if(root->index != -1) {\\n        int i = 0, j = s.length() - 1;\\n        //cout<<s<<endl;\\n        bool flag = true;\\n        while(i <= j) {\\n            if(s[i] != s[j]) {\\n                flag = false;\\n                break;\\n            }\\n            i++;\\n            j--;\\n        }\\n        if(flag)\\n            palindromes.push_back(root->index);\\n    }\\n    for(int i = 0; i < 26; i++) {\\n        if(root->children[i]) {\\n            char c = \\'a\\' + i;\\n            s.push_back(c);\\n            find(root->children[i], palindromes, s);\\n            s.pop_back();\\n        }\\n    }\\n    return;\\n}\\n\\nvector<int> search(TrieNode* root, string s) {\\n    vector<int> palindromes;\\n    TrieNode* ptr = root;\\n    for(int i = 0; i < s.length(); i++) {\\n        char c= s[i];\\n        int index = c - \\'a\\';\\n        // If any strings ends here, then check if out left out string is palindrome or not.\\n        if(ptr->index != -1) {\\n            int j = i, k = s.length() - 1;\\n            bool flag = true;\\n            while(j <= k) {\\n                if(s[j] != s[k]) {\\n                    flag = false;\\n                    break;\\n                }\\n                j++;\\n                k--;\\n            }\\n            if(flag)\\n                palindromes.push_back(ptr->index);\\n        }\\n        // If no characters ahead matching.\\n        if(!ptr->children[index]) {\\n            return palindromes;\\n        }\\n        ptr = ptr->children[index];\\n    }\\n    find(ptr, palindromes);\\n    return palindromes;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        struct TrieNode* root = new TrieNode();\\n        int i = 0;\\n        for(string s : words) {\\n            // insert into trie.\\n            insert(root, s, i++);\\n        }\\n        vector<vector<int>> result;\\n        i = 0;\\n        for(string s : words) {\\n            // search for all palindromes.\\n            vector<int> palindromes = search(root, s);\\n            //cout<<s<<endl;\\n            // add all palindromes into result.\\n            for(int x : palindromes) {\\n                if(i != x)\\n                    result.push_back({i, x});\\n            }\\n            i++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1987826,
                "title": "python-trie-solution-explained",
                "content": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = dict()\\n        self.end = False\\n        self.idx = -1\\n        self.palindromeIdxs = list()\\n\\nclass Solution:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        res = list()\\n        \\n        # populate the trie with\\n        # the reverse of every word.\\n        # once we\\'re done inserting\\n        # we\\'re going to have 3 conditions\\n        for i in range(len(words)):\\n            cur = self.root\\n            rWord = words[i][::-1]\\n            for j in range(len(rWord)):\\n                # if the current word (from j onwards)\\n                # is a palindrome, add it\\'s index to the trie node\\n                # (palindromIdx list) we\\'ll use it later on to find combinations\\n                if self.isPalindrome(rWord[j:]):\\n                    cur.palindromeIdxs.append(i)\\n                    \\n                if rWord[j] not in cur.children:\\n                    cur.children[rWord[j]] = TrieNode()\\n                cur = cur.children[rWord[j]]\\n                \\n            # once the word is done\\n            # add it\\'s index to the trie node\\n            cur.end = True\\n            cur.idx = i\\n            \\n        for i in range(len(words)):\\n            self.search(words[i], i, res)\\n            \\n        return res\\n        \\n    # to find all pairse, we can have\\n    # conditions:\\n    # 1. exact match (abc, cba)\\n    # 2. long word, short word in trie match (abbcc, a)\\n    # 3. short word, long word in trie match (lls, sssll)\\n    def search(self, word, idx, res):   \\n        cur = self.root\\n        for i in range(len(word)):\\n            # 2. long word, short trie\\n            # so the trie ended here and \\n            # we have matched till the ith\\n            # character, so we check if the\\n            # remaining of the word is also a\\n            # palindrome, if yes, then we have a pair\\n            # for e.g. word = abcdaa, trieWord = bcda\\n            # we can make a pair like abcdaabcda\\n            if cur.end and self.isPalindrome(word[i:]):\\n                res.append([idx, cur.idx])\\n                \\n            if word[i] not in cur.children:\\n                return\\n            cur = cur.children[word[i]]        \\n        \\n        # 1. exact match\\n        # in the given list, for that \\n        # we\\'ll take every word and then\\n        # check if the reverse of that\\n        # word lies in the trie\\n        # for e.g. for abc and cba\\n        # the trie would have both c->b->a and a->b->c\\n        # but when we take the first word (abc)\\n        # we\\'ll match this with a->b->c which is\\n        # actually cba and so we found a match\\n        if cur.end and cur.idx != idx:\\n            res.append([cur.idx, idx])\\n        \\n        # 3. long trie, short word\\n        # so the trie still has items (not cur.end)\\n        # and the word has ended, it\\'s the exact\\n        # opposite of point 2\\n        # for e.g. word=abcd trieWord=bcdaa\\n        # we can have a pair bcdaaabcd\\n        # and so we have a pair\\n        for pIdx in cur.palindromeIdxs:\\n            res.append([idx, pIdx])\\n                \\n        return\\n        \\n        \\n    def isPalindrome(self, s):\\n        return s == s[::-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = dict()\\n        self.end = False\\n        self.idx = -1\\n        self.palindromeIdxs = list()\\n\\nclass Solution:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        res = list()\\n        \\n        # populate the trie with\\n        # the reverse of every word.\\n        # once we\\'re done inserting\\n        # we\\'re going to have 3 conditions\\n        for i in range(len(words)):\\n            cur = self.root\\n            rWord = words[i][::-1]\\n            for j in range(len(rWord)):\\n                # if the current word (from j onwards)\\n                # is a palindrome, add it\\'s index to the trie node\\n                # (palindromIdx list) we\\'ll use it later on to find combinations\\n                if self.isPalindrome(rWord[j:]):\\n                    cur.palindromeIdxs.append(i)\\n                    \\n                if rWord[j] not in cur.children:\\n                    cur.children[rWord[j]] = TrieNode()\\n                cur = cur.children[rWord[j]]\\n                \\n            # once the word is done\\n            # add it\\'s index to the trie node\\n            cur.end = True\\n            cur.idx = i\\n            \\n        for i in range(len(words)):\\n            self.search(words[i], i, res)\\n            \\n        return res\\n        \\n    # to find all pairse, we can have\\n    # conditions:\\n    # 1. exact match (abc, cba)\\n    # 2. long word, short word in trie match (abbcc, a)\\n    # 3. short word, long word in trie match (lls, sssll)\\n    def search(self, word, idx, res):   \\n        cur = self.root\\n        for i in range(len(word)):\\n            # 2. long word, short trie\\n            # so the trie ended here and \\n            # we have matched till the ith\\n            # character, so we check if the\\n            # remaining of the word is also a\\n            # palindrome, if yes, then we have a pair\\n            # for e.g. word = abcdaa, trieWord = bcda\\n            # we can make a pair like abcdaabcda\\n            if cur.end and self.isPalindrome(word[i:]):\\n                res.append([idx, cur.idx])\\n                \\n            if word[i] not in cur.children:\\n                return\\n            cur = cur.children[word[i]]        \\n        \\n        # 1. exact match\\n        # in the given list, for that \\n        # we\\'ll take every word and then\\n        # check if the reverse of that\\n        # word lies in the trie\\n        # for e.g. for abc and cba\\n        # the trie would have both c->b->a and a->b->c\\n        # but when we take the first word (abc)\\n        # we\\'ll match this with a->b->c which is\\n        # actually cba and so we found a match\\n        if cur.end and cur.idx != idx:\\n            res.append([cur.idx, idx])\\n        \\n        # 3. long trie, short word\\n        # so the trie still has items (not cur.end)\\n        # and the word has ended, it\\'s the exact\\n        # opposite of point 2\\n        # for e.g. word=abcd trieWord=bcdaa\\n        # we can have a pair bcdaaabcd\\n        # and so we have a pair\\n        for pIdx in cur.palindromeIdxs:\\n            res.append([idx, pIdx])\\n                \\n        return\\n        \\n        \\n    def isPalindrome(self, s):\\n        return s == s[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 170996,
                "title": "java-solution-with-trie-structure-and-full-explanation",
                "content": "This challange has many traps and tricks and edge cases. It is very easy to drive yourself to a path where your solution almost works, just this edge case to add... and the edge cases never finish.\\nIf you are in this situation, take steps back and try to figure out why you have so many edge cases because it is likely that there is something fundamentally wrong in your solution.\\nI added extensive documentation to this solution, I hope it helps you to understand what is going on and more importantly, WHY :)\\n```\\nclass Solution {\\n    \\n    private class TrieNode {\\n        //index of the word in the words array (one int is enough as the words are \\n        //unique in the array)\\n        int wordsIndex = -1;\\n        //connecting Trie nodes by next letter (\\'a\\' = 0, \\'b\\' = 1, ..., \\'z\\' = 25)\\n        TrieNode[] nextLetter = new TrieNode[26];\\n        //list of indexes to words in the words array which has a suffix\\n        //finishing on this trie node and the rest of the word is palindrome\\n        //on its own\\n        List<Integer> palindromes = new ArrayList<>();\\n    }\\n\\n    /**\\n     * Check if part of the given word is palindrome.\\n     * @param word The word to check.\\n     * @param headIndex The head index from which to check for being palindrome.\\n     * @param tailIndex The tail index from which to check for being palindrome.\\n     * @return true iff the word fragment is palindrome.\\n     */\\n    private boolean isPalindrome(String word, int headIndex, int tailIndex) {\\n        while (headIndex < tailIndex) {\\n            if (word.charAt(headIndex++) != word.charAt(tailIndex--)) { return false; }\\n        }\\n        return true;\\n    }\\n    \\n    private void addWordToTrie(TrieNode trieNode, String[] words, int wordIndex) {\\n        final String word = words[wordIndex];\\n        \\n        //we build the trie BACKWARDS (during pairing we look for a matching front)\\n        //and the center part of the pair to be palindrome on its own\\n        for (int i = word.length() - 1; i >= 0; i--) {\\n            //check if we have palindrome to add to the palindromes list of the trie node\\n            \\n            //note: words which are palindrome on the words list will go under the \\n            //palindrome list of the root trie node -> this will be very useful if\\n            //the word list contains \"\" (empty string) since that will be matched with\\n            //all these immediately palindrome strings.\\n            \\n            if (isPalindrome(word, 0, i)) {\\n                trieNode.palindromes.add(wordIndex);\\n            }\\n\\n            //move one letter further\\n            \\n            final int letterIndex = word.charAt(i) - \\'a\\';\\n            if (trieNode.nextLetter[letterIndex] == null) {\\n                trieNode.nextLetter[letterIndex] = new TrieNode();\\n            }\\n            trieNode = trieNode.nextLetter[letterIndex];\\n        }\\n\\n        //we processed the whole word, we are at its last character\\n        //note: any single character word is palindrome so we add it\\n        //to the palindromes list\\n        //note: to be able to avoid pairing words with themselves\\n        //we mark this trie node with the index of the word (in the words array)\\n        trieNode.wordsIndex = wordIndex;\\n        trieNode.palindromes.add(wordIndex);\\n    }\\n        \\n    private void getPalindromePairs(List<List<Integer>> result, TrieNode trieNode, String[] words, int wordIndex) {\\n        final String word = words[wordIndex];\\n        \\n        for (int i = 0; i < word.length(); i++) {\\n\\n            //check if the current trie node contains a full word (wordsIndex != -1)\\n            //note: avoid pairing words with themselves, hence check if the trie node\\n            //represents the same word we are searching palindrome pairs for (trieNode.wordsIndex != wordIndex)\\n            //and see if the substring remaining from word is palindrome -> if so \\n            //then we can pair our word with the word from the trie node\\n            if (trieNode.wordsIndex != -1 && trieNode.wordsIndex != wordIndex && isPalindrome(word, i, word.length() -1)) {\\n                result.add(Arrays.asList(wordIndex, trieNode.wordsIndex));\\n            }\\n            \\n            //move to the next letter (if there is a path in the trie with the letter)\\n            final TrieNode nextLetterNode = trieNode.nextLetter[word.charAt(i) - \\'a\\'];\\n            if (nextLetterNode == null) { return; }\\n            trieNode = nextLetterNode;\\n        }\\n        \\n        //we processed the whole word, we are at its last character\\n        //here we add all palindromes to the result list from this trie node\\n        for (final Integer palindromeWordIndex : trieNode.palindromes) {\\n            //avoid false pairs (e.g. with \"aa\", we would end up at the same trie node for the same word)\\n            //because it is the same as itself if reversed\\n            if (wordIndex == palindromeWordIndex) { continue; }\\n            result.add(Arrays.asList(wordIndex, palindromeWordIndex));\\n        }    \\n    }\\n\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        \\n        final TrieNode trieRoot = new TrieNode();\\n        \\n        //build trie for words\\n        for (int i = 0; i < words.length; i++) {\\n            addWordToTrie(trieRoot, words, i);    \\n        }        \\n        \\n        //build pairs\\n        final List<List<Integer>> result = new ArrayList<>();\\n        for (int i = 0; i < words.length; i++) {\\n            getPalindromePairs(result, trieRoot, words, i);\\n        }\\n        return result;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private class TrieNode {\\n        //index of the word in the words array (one int is enough as the words are \\n        //unique in the array)\\n        int wordsIndex = -1;\\n        //connecting Trie nodes by next letter (\\'a\\' = 0, \\'b\\' = 1, ..., \\'z\\' = 25)\\n        TrieNode[] nextLetter = new TrieNode[26];\\n        //list of indexes to words in the words array which has a suffix\\n        //finishing on this trie node and the rest of the word is palindrome\\n        //on its own\\n        List<Integer> palindromes = new ArrayList<>();\\n    }\\n\\n    /**\\n     * Check if part of the given word is palindrome.\\n     * @param word The word to check.\\n     * @param headIndex The head index from which to check for being palindrome.\\n     * @param tailIndex The tail index from which to check for being palindrome.\\n     * @return true iff the word fragment is palindrome.\\n     */\\n    private boolean isPalindrome(String word, int headIndex, int tailIndex) {\\n        while (headIndex < tailIndex) {\\n            if (word.charAt(headIndex++) != word.charAt(tailIndex--)) { return false; }\\n        }\\n        return true;\\n    }\\n    \\n    private void addWordToTrie(TrieNode trieNode, String[] words, int wordIndex) {\\n        final String word = words[wordIndex];\\n        \\n        //we build the trie BACKWARDS (during pairing we look for a matching front)\\n        //and the center part of the pair to be palindrome on its own\\n        for (int i = word.length() - 1; i >= 0; i--) {\\n            //check if we have palindrome to add to the palindromes list of the trie node\\n            \\n            //note: words which are palindrome on the words list will go under the \\n            //palindrome list of the root trie node -> this will be very useful if\\n            //the word list contains \"\" (empty string) since that will be matched with\\n            //all these immediately palindrome strings.\\n            \\n            if (isPalindrome(word, 0, i)) {\\n                trieNode.palindromes.add(wordIndex);\\n            }\\n\\n            //move one letter further\\n            \\n            final int letterIndex = word.charAt(i) - \\'a\\';\\n            if (trieNode.nextLetter[letterIndex] == null) {\\n                trieNode.nextLetter[letterIndex] = new TrieNode();\\n            }\\n            trieNode = trieNode.nextLetter[letterIndex];\\n        }\\n\\n        //we processed the whole word, we are at its last character\\n        //note: any single character word is palindrome so we add it\\n        //to the palindromes list\\n        //note: to be able to avoid pairing words with themselves\\n        //we mark this trie node with the index of the word (in the words array)\\n        trieNode.wordsIndex = wordIndex;\\n        trieNode.palindromes.add(wordIndex);\\n    }\\n        \\n    private void getPalindromePairs(List<List<Integer>> result, TrieNode trieNode, String[] words, int wordIndex) {\\n        final String word = words[wordIndex];\\n        \\n        for (int i = 0; i < word.length(); i++) {\\n\\n            //check if the current trie node contains a full word (wordsIndex != -1)\\n            //note: avoid pairing words with themselves, hence check if the trie node\\n            //represents the same word we are searching palindrome pairs for (trieNode.wordsIndex != wordIndex)\\n            //and see if the substring remaining from word is palindrome -> if so \\n            //then we can pair our word with the word from the trie node\\n            if (trieNode.wordsIndex != -1 && trieNode.wordsIndex != wordIndex && isPalindrome(word, i, word.length() -1)) {\\n                result.add(Arrays.asList(wordIndex, trieNode.wordsIndex));\\n            }\\n            \\n            //move to the next letter (if there is a path in the trie with the letter)\\n            final TrieNode nextLetterNode = trieNode.nextLetter[word.charAt(i) - \\'a\\'];\\n            if (nextLetterNode == null) { return; }\\n            trieNode = nextLetterNode;\\n        }\\n        \\n        //we processed the whole word, we are at its last character\\n        //here we add all palindromes to the result list from this trie node\\n        for (final Integer palindromeWordIndex : trieNode.palindromes) {\\n            //avoid false pairs (e.g. with \"aa\", we would end up at the same trie node for the same word)\\n            //because it is the same as itself if reversed\\n            if (wordIndex == palindromeWordIndex) { continue; }\\n            result.add(Arrays.asList(wordIndex, palindromeWordIndex));\\n        }    \\n    }\\n\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        \\n        final TrieNode trieRoot = new TrieNode();\\n        \\n        //build trie for words\\n        for (int i = 0; i < words.length; i++) {\\n            addWordToTrie(trieRoot, words, i);    \\n        }        \\n        \\n        //build pairs\\n        final List<List<Integer>> result = new ArrayList<>();\\n        for (int i = 0; i < words.length; i++) {\\n            getPalindromePairs(result, trieRoot, words, i);\\n        }\\n        return result;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79240,
                "title": "python-solution-with-trie",
                "content": "My first post in discussion.  This idea is kind of hard to follow if you didn't try on the same way by yourself before.  Time complexity of current algorithm is not linear, but can be improved to guarantee linear even in worst case.  \\n\\nBuild a Trie with words.  When reach the end of the word, use \"isword\" to keep the index of the word.  During adding a word to the Trie, if the rest of the word is palin, add the index of the word to key \"ids\" of that node.\\n\\nThen for each word, look for the reverse of the word in the Trie.  During searching for each word, if word ends but the trie path still continues, check the \"ids\" key of that node (node[\"ids\"] keeps the index of the word which substring is palin after this node).\\n\\nCheck for empty string separately at last.\\n\\nCurrent algorithm has a high worst case time complexity, but can be improved to guarantee O(n) (total number of characters of all words).  I used a KMP method to calculate the suffix palin for each word in O(len(word)), and also for each reverse word.  Therefore the ispalin can be check in O(1) after a linear preprocess for each word.  However, that solution went TLE.  The reason is: for the current algorithm, we don't need to do ispalin check for a good part of cases. However, for that preprocess method, we can't escape a linear preprocessing.   \\n\\n\\nclass Solution(object):\\n    \\n    def ispalin(self, s):  # check if a string is palin (s is suffix of word in our case)\\n        return s == s[::-1]\\n    \\n    def palindromePairs(self, words):\\n        result = []\\n        root = {}  # use dict instead of a TrieNode class to save space\\n        for i, word in enumerate(words):\\n            curr = root\\n            for idx, ch in enumerate(word):\\n                if ch not in curr:\\n                    curr[ch] = {}\\n                curr = curr[ch]\\n                tmp = word[idx+1:]\\n                if tmp and self.ispalin(tmp):\\n                    # keep the idx of word if the suffix of the word after current position is palin\\n                    curr.setdefault(\"ids\", []).append(i)\\n            curr[\"isword\"] = i  # keep idx of word when reach the end\\n        for j, word in enumerate(words):  # start searching reverse of each word in the Trie\\n            w = word[::-1]\\n            curr = root\\n            fail = False\\n            for idx, ch in enumerate(w):\\n                if ch not in curr:\\n                    fail = True\\n                    break\\n                curr = curr[ch]\\n                # if current node is the end of some word, check whether the suffix of reverse word is palin\\n                i = curr.get(\"isword\")\\n                if i is not None and i != j and self.ispalin(w[idx+1:]):\\n                    result.append([i, j])\\n            if not fail and \"ids\" in curr:\\n                result.extend([i, j] for i in curr[\"ids\"] if i != j)\\n        if \"\" in words:  # check for \"\" case\\n            idx = words.index(\"\")\\n            result.extend(reduce(lambda x, y: x + y, ([[i, idx], [idx, i]] for i, w in enumerate(words) if w and self.ispalin(w))))\\n        return result",
                "solutionTags": [
                    "Python",
                    "Trie"
                ],
                "code": "class Solution(object):\\n    \\n    def ispalin(self, s):  # check if a string is palin (s is suffix of word in our case)\\n        return s == s[::-1]\\n    \\n    def palindromePairs(self, words):\\n        result = []\\n        root = {}",
                "codeTag": "Java"
            },
            {
                "id": 654766,
                "title": "c-solution-trie",
                "content": "It can be solved by trie data strcuture, as we have to find whether two strings after concatenating can become a palindrome or not... We insert all words in reverse in trie.. So if there is a word[i] and we break it into two parts , say left and right   w[l]  and w[r]  so if w[l] is present in trie that means there is a word present which after reversing equals to w[l] so that reverse(founded_word)== w[l] and w[r] is a palindrome then we can append founded_word at the end of current word  like this -::   w[l] + w[r] + founded_word  and it can be easily determined that it is a palindrome...  So idea is clear  , now use trie to reduce time for searching and inserting..  That\\'s it...  Hope u understand!!\\n```\\nclass Solution {\\npublic:\\n    struct trienode{  // make structure of trie..\\n      bool isendofword;\\n        trienode* children[26];\\n    };\\n    trienode* getnode(){   // for generating new trienode\\n        struct trienode* ne=new trienode;\\n        ne->isendofword=false;\\n        for(int i=0;i<26;i++){\\n            ne->children[i]=NULL;\\n        }\\n        return ne;\\n    }\\n    void insert(trienode* root,string &key){   //  insertion in trienode\\n        struct trienode* cp=root;\\n        for(int i=0;i<key.size();i++){\\n            int ind=key[i]-\\'a\\';\\n            if(cp->children[ind]==NULL){\\n                cp->children[ind]=getnode();\\n            }\\n            cp=cp->children[ind];\\n        }\\n        cp->isendofword=true;\\n    }\\n    bool search(trienode* root,string &key){  // searching in trienode\\n        struct trienode* cp=root;\\n        for(int i=0;i<key.size();i++){\\n            int ind=key[i]-\\'a\\';\\n            if(cp->children[ind]==NULL){   // if not found return false;\\n                return false;\\n            }\\n            cp=cp->children[ind];\\n        }\\n        return cp->isendofword==true; // check if it is end of word or not.\\n    }\\n    bool ispalindrome(string t){ // to check if it is palindrome or not\\n        int i=0,j=t.size()-1;\\n        while(i<j){\\n            if(t[i++]!=t[j--]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        struct trienode* rt=getnode();\\n        map<string,int> mp;\\n        for(int i=0;i<words.size();i++){\\n            reverse(words[i].begin(),words[i].end());\\n            mp[words[i]]=i; // mapping words to index\\n            insert(rt,words[i]); // inserting words\\n            reverse(words[i].begin(),words[i].end());\\n        }\\n        vector<vector<int> > ans;\\n        if(mp.count(\"\")){\\n            for(int i=0;i<words.size();i++){\\n                if(words[i]!=\"\" && ispalindrome(words[i])){\\n                    ans.push_back({mp[\"\"],i});  // making a seperate case for empty strings\\n                }\\n            }\\n        }\\n        for(int i=0;i<words.size();i++){\\n            for(int j=0;j<words[i].size();j++){\\n                string left=words[i].substr(0,j),right=words[i].substr(j);  // breaking string in 2 parts\\n                if(search(rt,left) && ispalindrome(right) && mp[left]!=i){  // as discussed\\n                    ans.push_back({i,mp[left]});\\n                }\\n                if(search(rt,right) && ispalindrome(left) && mp[right]!=i){// as discussed\\n                    ans.push_back({mp[right],i});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct trienode{  // make structure of trie..\\n      bool isendofword;\\n        trienode* children[26];\\n    };\\n    trienode* getnode(){   // for generating new trienode\\n        struct trienode* ne=new trienode;\\n        ne->isendofword=false;\\n        for(int i=0;i<26;i++){\\n            ne->children[i]=NULL;\\n        }\\n        return ne;\\n    }\\n    void insert(trienode* root,string &key){   //  insertion in trienode\\n        struct trienode* cp=root;\\n        for(int i=0;i<key.size();i++){\\n            int ind=key[i]-\\'a\\';\\n            if(cp->children[ind]==NULL){\\n                cp->children[ind]=getnode();\\n            }\\n            cp=cp->children[ind];\\n        }\\n        cp->isendofword=true;\\n    }\\n    bool search(trienode* root,string &key){  // searching in trienode\\n        struct trienode* cp=root;\\n        for(int i=0;i<key.size();i++){\\n            int ind=key[i]-\\'a\\';\\n            if(cp->children[ind]==NULL){   // if not found return false;\\n                return false;\\n            }\\n            cp=cp->children[ind];\\n        }\\n        return cp->isendofword==true; // check if it is end of word or not.\\n    }\\n    bool ispalindrome(string t){ // to check if it is palindrome or not\\n        int i=0,j=t.size()-1;\\n        while(i<j){\\n            if(t[i++]!=t[j--]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        struct trienode* rt=getnode();\\n        map<string,int> mp;\\n        for(int i=0;i<words.size();i++){\\n            reverse(words[i].begin(),words[i].end());\\n            mp[words[i]]=i; // mapping words to index\\n            insert(rt,words[i]); // inserting words\\n            reverse(words[i].begin(),words[i].end());\\n        }\\n        vector<vector<int> > ans;\\n        if(mp.count(\"\")){\\n            for(int i=0;i<words.size();i++){\\n                if(words[i]!=\"\" && ispalindrome(words[i])){\\n                    ans.push_back({mp[\"\"],i});  // making a seperate case for empty strings\\n                }\\n            }\\n        }\\n        for(int i=0;i<words.size();i++){\\n            for(int j=0;j<words[i].size();j++){\\n                string left=words[i].substr(0,j),right=words[i].substr(j);  // breaking string in 2 parts\\n                if(search(rt,left) && ispalindrome(right) && mp[left]!=i){  // as discussed\\n                    ans.push_back({i,mp[left]});\\n                }\\n                if(search(rt,right) && ispalindrome(left) && mp[right]!=i){// as discussed\\n                    ans.push_back({mp[right],i});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585595,
                "title": "java-explained-in-detail-easy-to-understand-hashmap",
                "content": "I do my best everyday to give a clear explanation, so to help everyone improve their skills.\\n\\nIf you find this **helpful**, please \\uD83D\\uDC4D **upvote** this post and watch my [Github Repository](https://github.com/cheehwatang/leetcode-java).\\n\\nThank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.\\n\\n---\\n\\n**Java**\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n\\n    // Based on the 3 examples given by LeetCode, we can derive 3 conditions where str1 + str2 = palindrome.\\n    // Case 1: If there is str1 \"\", and str2 that is palindrome, then str1 + str2 (\"\" + palindrome) is still a palindrome.\\n    //         From Example 3: words = [\"a\",\"\"]\\n    //                         str1 = \"\", str2 = \"a\" (a palindrome), so str1 + str2 = \"a\" (a palindrome).\\n    //\\n    // Case 2: If str1 is the reverse of str2, then str1 + str2 and str2 + str1 are both palindromes.\\n    //         From Example 2: words = [\"bat\"*,\"tab\"*,\"cat\"]\\n    //                         str1 = \"bat, str2 = \"tab\", str1 is the reverse of str2,\\n    //                         so str1 + str2 = \"battab\", and str2 + str1 = \"tabbat\".\\n    //\\n    // Case 3: If str1 is the reverse of a part of str2 (sub1 + sub2), and the second part is a palindrome, then the following:\\n    //         A. If str1 is the reverse of sub1, and sub2 is palindrome, then str2 + str1 = palindrome.\\n    //         B. If str1 is the reverse of sub2, and sub1 is palindrome, then str1 + str2 = palindrome.\\n    //         From Example 1: words = [\"abcd\",\"dcba\",\"lls\"*,\"s\"*,\"sssll\"*]\\n    //                         A. Not shown here.\\n    //                         B. str1 = \"s\", str2 = \"lls\" (sub1 = \"ll\", sub2 = \"s\"), or\\n    //                            str1 = \"lls\", str2 = \"sssll\" (sub1 = \"ss\", sub2 = \"sll\")\\n    //                         Both cases, str1 is the reverse of sub2, and sub1 is a palindrome.\\n    //\\n\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n\\n        // For this palindromePairs method to work, we need to write two other methods, namely:\\n        //      1. isPalindrome() to check if a given input is a palindrome.\\n        //      2. reverseStr() to return the reversed string.\\n\\n        // First instantiate the result list. Don\\'t worry about the List<Integer> within,\\n        // as we will instantiate the list of index pair when we found the concatenated palindrome pair.\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        // Check if the words input is null or empty.\\n        if (words == null || words.length == 0) {\\n            return result;\\n        }\\n\\n        // Use a hashmap (dictionary) to record the key-value pair (String-index pair).\\n        Map<String, Integer> dictionary = new HashMap<>();\\n\\n        // Use an array to keep track of the string length and its occurrences.\\n        // Why? To lower the time complexity needed when checking the dictionary for a particular string,\\n        //      by first checking if string of this length is in \\'words\\'.\\n        int[] hasLength = new int[5000 + 1];\\n\\n        // Traverse the \\'words\\', to record String and index in the dictionary, and the String length occurrence in hasLength.\\n        for (int i = 0; i < words.length; i++) {\\n            dictionary.put(words[i], i);\\n            hasLength[words[i].length()]++;\\n        }\\n\\n        // Case 1: If there is str1 \"\", and str2 that is palindrome.\\n        // If \"\" is in \\'words\\', then it can combine with any palindrome string, in both orderings, to form a palindrome.\\n        if (dictionary.containsKey(\"\")) {\\n            int emptyStrIndex = dictionary.get(\"\");\\n            // Check for all the palindromes.\\n            for (int i = 0; i < words.length; i++) {\\n                if (isPalindrome(words[i], 0, words[i].length() - 1)) {\\n                    // This to make sure we combine emptyStrIndex with itself.\\n                    if (i == emptyStrIndex) {\\n                        continue;\\n                    }\\n                    // Add to result, both str1 + str2 and str2 + str1 combinations.\\n                    result.add(Arrays.asList(emptyStrIndex, i));\\n                    result.add(Arrays.asList(i, emptyStrIndex));\\n                }\\n            }\\n        }\\n\\n        // Case 2: If str1 is the reverse of str2.\\n        // For each string in \\'words\\', we check if the reversed string (str2) is identical to the string (str1).\\n        for (int i = 0; i < words.length; i++) {\\n            // Call the reverseStr() method to reverse the string.\\n            String reversedStr = reverseStr(words[i]);\\n            // Find if the reverseStr is in the dictionary. If it is, we get the index.\\n            if (dictionary.containsKey(reversedStr)) {\\n                int reversedStrIndex = dictionary.get(reversedStr);\\n                // This is to make sure we check for palindromes, so we don\\'t combine palindrome with itself.\\n                if (i == reversedStrIndex) {\\n                    continue;\\n                }\\n                // Else, add to result.\\n                result.add(Arrays.asList(i, reversedStrIndex));\\n            }\\n        }\\n\\n        // Case 3: If str1 is the reverse of a part of str2 (sub1 + sub2), and the second part is a palindrome.\\n        // Checking for every string in \\'words\\'.\\n        for (int i = 0; i < words.length; i++) {\\n            String currentStr = words[i];\\n\\n            // Each string, check for all the possible substrings, using sliceIndex to traverse each string.\\n            for (int sliceIndex = 1; sliceIndex < currentStr.length(); sliceIndex++) {\\n\\n                // A. If str1 is the reverse of sub1, and sub2 is palindrome, then str2 + str1 = palindrome.\\n                // First check is sub1 length in hasLength, and check sub2 if is palindrome.\\n                if (hasLength[sliceIndex] > 0\\n                        && isPalindrome(currentStr, sliceIndex, currentStr.length() - 1)) {\\n\\n                    // Reverse sub1 to check if str1 is in the dictionary.\\n                    String reversedSubStr = reverseStr(currentStr.substring(0,sliceIndex));\\n                    if (dictionary.containsKey(reversedSubStr)) {\\n                        int reversedStrIndex = dictionary.get(reversedSubStr);\\n                        // This is to check for palindromes, when sliceIndex is in the middle of the palindrome.\\n                        if (reversedStrIndex == i) {\\n                            continue;\\n                        }\\n                        // str2 (sub1 + sub2 (palindrome)) + str1 (reverse of sub1)\\n                        result.add(Arrays.asList(i, reversedStrIndex));\\n                    }\\n                }\\n\\n                // B. If str1 is the reverse of sub2, and sub1 is palindrome, then str1 + str2 = palindrome.\\n                // First check is sub2 length in hasLength, and check sub1 if is palindrome.\\n                if (hasLength[currentStr.length() - sliceIndex] > 0\\n                        && isPalindrome(currentStr, 0, sliceIndex - 1)) {\\n\\n                    // Reverse sub2 to check if str1 is in the dictionary.\\n                    String reversedSubStr = reverseStr(currentStr.substring(sliceIndex, currentStr.length()));\\n                    if (dictionary.containsKey(reversedSubStr)) {\\n                        int reversedStrIndex = dictionary.get(reversedSubStr);\\n                        // This is to check for palindromes, when sliceIndex is in the middle of the palindrome.\\n                        if (reversedStrIndex == i) {\\n                            continue;\\n                        }\\n                        // str1 (reverse of sub2) + str2 (sub1 (palindrome) + sub2)\\n                        result.add(Arrays.asList(reversedStrIndex, i));\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    // Method 1:\\n    // To check if given string is a palindrome. Use 2 pointers (front and back) as input,\\n    // as we might check if the substring is a palindrome, not the whole string.\\n    private boolean isPalindrome(String str, int front, int back) {\\n        while (front < back) {\\n            if (str.charAt(front) != str.charAt(back)) {\\n                return false;\\n            }\\n            front++;\\n            back--;\\n        }\\n        return true;\\n    }\\n\\n    // Method 2:\\n    // To return the reversed string.\\n    private String reverseStr(String str) {\\n        StringBuilder stringBuilder = new StringBuilder(str);\\n        return stringBuilder.reverse().toString();\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n\\n    // Based on the 3 examples given by LeetCode, we can derive 3 conditions where str1 + str2 = palindrome.\\n    // Case 1: If there is str1 \"\", and str2 that is palindrome, then str1 + str2 (\"\" + palindrome) is still a palindrome.\\n    //         From Example 3: words = [\"a\",\"\"]\\n    //                         str1 = \"\", str2 = \"a\" (a palindrome), so str1 + str2 = \"a\" (a palindrome).\\n    //\\n    // Case 2: If str1 is the reverse of str2, then str1 + str2 and str2 + str1 are both palindromes.\\n    //         From Example 2: words = [\"bat\"*,\"tab\"*,\"cat\"]\\n    //                         str1 = \"bat, str2 = \"tab\", str1 is the reverse of str2,\\n    //                         so str1 + str2 = \"battab\", and str2 + str1 = \"tabbat\".\\n    //\\n    // Case 3: If str1 is the reverse of a part of str2 (sub1 + sub2), and the second part is a palindrome, then the following:\\n    //         A. If str1 is the reverse of sub1, and sub2 is palindrome, then str2 + str1 = palindrome.\\n    //         B. If str1 is the reverse of sub2, and sub1 is palindrome, then str1 + str2 = palindrome.\\n    //         From Example 1: words = [\"abcd\",\"dcba\",\"lls\"*,\"s\"*,\"sssll\"*]\\n    //                         A. Not shown here.\\n    //                         B. str1 = \"s\", str2 = \"lls\" (sub1 = \"ll\", sub2 = \"s\"), or\\n    //                            str1 = \"lls\", str2 = \"sssll\" (sub1 = \"ss\", sub2 = \"sll\")\\n    //                         Both cases, str1 is the reverse of sub2, and sub1 is a palindrome.\\n    //\\n\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n\\n        // For this palindromePairs method to work, we need to write two other methods, namely:\\n        //      1. isPalindrome() to check if a given input is a palindrome.\\n        //      2. reverseStr() to return the reversed string.\\n\\n        // First instantiate the result list. Don\\'t worry about the List<Integer> within,\\n        // as we will instantiate the list of index pair when we found the concatenated palindrome pair.\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        // Check if the words input is null or empty.\\n        if (words == null || words.length == 0) {\\n            return result;\\n        }\\n\\n        // Use a hashmap (dictionary) to record the key-value pair (String-index pair).\\n        Map<String, Integer> dictionary = new HashMap<>();\\n\\n        // Use an array to keep track of the string length and its occurrences.\\n        // Why? To lower the time complexity needed when checking the dictionary for a particular string,\\n        //      by first checking if string of this length is in \\'words\\'.\\n        int[] hasLength = new int[5000 + 1];\\n\\n        // Traverse the \\'words\\', to record String and index in the dictionary, and the String length occurrence in hasLength.\\n        for (int i = 0; i < words.length; i++) {\\n            dictionary.put(words[i], i);\\n            hasLength[words[i].length()]++;\\n        }\\n\\n        // Case 1: If there is str1 \"\", and str2 that is palindrome.\\n        // If \"\" is in \\'words\\', then it can combine with any palindrome string, in both orderings, to form a palindrome.\\n        if (dictionary.containsKey(\"\")) {\\n            int emptyStrIndex = dictionary.get(\"\");\\n            // Check for all the palindromes.\\n            for (int i = 0; i < words.length; i++) {\\n                if (isPalindrome(words[i], 0, words[i].length() - 1)) {\\n                    // This to make sure we combine emptyStrIndex with itself.\\n                    if (i == emptyStrIndex) {\\n                        continue;\\n                    }\\n                    // Add to result, both str1 + str2 and str2 + str1 combinations.\\n                    result.add(Arrays.asList(emptyStrIndex, i));\\n                    result.add(Arrays.asList(i, emptyStrIndex));\\n                }\\n            }\\n        }\\n\\n        // Case 2: If str1 is the reverse of str2.\\n        // For each string in \\'words\\', we check if the reversed string (str2) is identical to the string (str1).\\n        for (int i = 0; i < words.length; i++) {\\n            // Call the reverseStr() method to reverse the string.\\n            String reversedStr = reverseStr(words[i]);\\n            // Find if the reverseStr is in the dictionary. If it is, we get the index.\\n            if (dictionary.containsKey(reversedStr)) {\\n                int reversedStrIndex = dictionary.get(reversedStr);\\n                // This is to make sure we check for palindromes, so we don\\'t combine palindrome with itself.\\n                if (i == reversedStrIndex) {\\n                    continue;\\n                }\\n                // Else, add to result.\\n                result.add(Arrays.asList(i, reversedStrIndex));\\n            }\\n        }\\n\\n        // Case 3: If str1 is the reverse of a part of str2 (sub1 + sub2), and the second part is a palindrome.\\n        // Checking for every string in \\'words\\'.\\n        for (int i = 0; i < words.length; i++) {\\n            String currentStr = words[i];\\n\\n            // Each string, check for all the possible substrings, using sliceIndex to traverse each string.\\n            for (int sliceIndex = 1; sliceIndex < currentStr.length(); sliceIndex++) {\\n\\n                // A. If str1 is the reverse of sub1, and sub2 is palindrome, then str2 + str1 = palindrome.\\n                // First check is sub1 length in hasLength, and check sub2 if is palindrome.\\n                if (hasLength[sliceIndex] > 0\\n                        && isPalindrome(currentStr, sliceIndex, currentStr.length() - 1)) {\\n\\n                    // Reverse sub1 to check if str1 is in the dictionary.\\n                    String reversedSubStr = reverseStr(currentStr.substring(0,sliceIndex));\\n                    if (dictionary.containsKey(reversedSubStr)) {\\n                        int reversedStrIndex = dictionary.get(reversedSubStr);\\n                        // This is to check for palindromes, when sliceIndex is in the middle of the palindrome.\\n                        if (reversedStrIndex == i) {\\n                            continue;\\n                        }\\n                        // str2 (sub1 + sub2 (palindrome)) + str1 (reverse of sub1)\\n                        result.add(Arrays.asList(i, reversedStrIndex));\\n                    }\\n                }\\n\\n                // B. If str1 is the reverse of sub2, and sub1 is palindrome, then str1 + str2 = palindrome.\\n                // First check is sub2 length in hasLength, and check sub1 if is palindrome.\\n                if (hasLength[currentStr.length() - sliceIndex] > 0\\n                        && isPalindrome(currentStr, 0, sliceIndex - 1)) {\\n\\n                    // Reverse sub2 to check if str1 is in the dictionary.\\n                    String reversedSubStr = reverseStr(currentStr.substring(sliceIndex, currentStr.length()));\\n                    if (dictionary.containsKey(reversedSubStr)) {\\n                        int reversedStrIndex = dictionary.get(reversedSubStr);\\n                        // This is to check for palindromes, when sliceIndex is in the middle of the palindrome.\\n                        if (reversedStrIndex == i) {\\n                            continue;\\n                        }\\n                        // str1 (reverse of sub2) + str2 (sub1 (palindrome) + sub2)\\n                        result.add(Arrays.asList(reversedStrIndex, i));\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    // Method 1:\\n    // To check if given string is a palindrome. Use 2 pointers (front and back) as input,\\n    // as we might check if the substring is a palindrome, not the whole string.\\n    private boolean isPalindrome(String str, int front, int back) {\\n        while (front < back) {\\n            if (str.charAt(front) != str.charAt(back)) {\\n                return false;\\n            }\\n            front++;\\n            back--;\\n        }\\n        return true;\\n    }\\n\\n    // Method 2:\\n    // To return the reversed string.\\n    private String reverseStr(String str) {\\n        StringBuilder stringBuilder = new StringBuilder(str);\\n        return stringBuilder.reverse().toString();\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79254,
                "title": "java-naive-154-ms-o-nk-2-r-and-126-ms-o-nk-r-manacher-suffixes-prefixes",
                "content": "**Added: a (not so) naive solution**\\n\\nIf two concatenated words form a palindrome, then there are three cases to consider:\\n\\n    +---s1---+---s2--+     +---s1---+-s2-+    +-s1-+---s2---+\\n    |abcdefgh|hgfedcba|    |abcdxyyx|dcba|    |abcd|xyyxdcba|\\n\\nCase 1 is when one string is a mirror image of another. Case 2 is when the first string is longer than the other and consists of the mirror image of the other (prefix) and a palindrome (suffix). Case 3 is a mirror image of case 2. Case 1 can also be considered a special subcase of either case 2 or case 3 with an empty palindrome suffix/prefix.\\n\\nOf these three, case 1 is definitely the easiest because we just need to look up a word in a reverse string-to-index map (words are unique, so no multimaps needed). If we iterate over the list with `s1` as the current string, then case 2 is also much easier than case 3 because when we locate a prefix/palindrome split inside `s1` we just need to look up for the reversed prefix in the map.\\n\\nCase 3 is trickier, but we can get rid of case 3 altogether if we just make another run with the reversed words! This way case 3 turns into case 2. We only need to consider case 1 in one of these runs in order to avoid duplicate combinations. With that in mind, I present the following 154 ms solution:\\n\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        Map<String, Integer> index = new HashMap<>();\\n        Map<String, Integer> revIndex = new HashMap<>();\\n        String[] revWords = new String[words.length];\\n        for (int i = 0; i < words.length; ++i) {\\n            String s = words[i];\\n            String r = new StringBuilder(s).reverse().toString();\\n            index.put(s, i);\\n            revIndex.put(r, i);\\n            revWords[i] = r;\\n        }\\n        List<List<Integer>> result = new ArrayList<>();\\n        result.addAll(findPairs(words, revWords, revIndex, false));\\n        result.addAll(findPairs(revWords, words, index, true));\\n        return result;\\n    }\\n    \\n    private static List<List<Integer>> findPairs(String[] words, String[] revWords, Map<String, Integer> revIndex, boolean reverse) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        for (int i = 0; i < words.length; ++i) {\\n            String s = words[i];\\n            for (int k = reverse ? 1 : 0; k <= s.length(); ++k) { // check suffixes, <= because we allow empty words\\n                Integer j = revIndex.get(s.substring(k));\\n                if (j != null && j != i) { // reversed suffix is present in the words list\\n                    // check whether the prefix is a palindrome\\n                    if (s.regionMatches(0, revWords[i], s.length() - k, k)) {\\n                        result.add(reverse ? Arrays.asList(i, j) : Arrays.asList(j, i));\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\nNow this was actually the third solution I came up with. The first one was really ugly because it considered all three cases separately. The second one is below.\\n\\n**The ugly optimized solution**\\n\\nAs in other solutions posted here, I used Manacher's algorithm to quickly determine whether some part of a string is a palindrome or not. That gets rid of one O(nk^2) part, where `k` is the average word length and `n` is the number of words.\\n\\nAnother part is numerous calls to `substring`, so my idea is to avoid copying a substring unless there's a good chance that it's actually present in the list. I do this by creating a kind of ad-hoc hash tables for both reversed and non-reversed words.\\n\\nWe start by iterating over the list of the words and compute hashes for both reversed and non-reversed words. However, because I later calculate hashes of *suffixes* on the fly, which means that I calculate them right-to-left, so it is kind of mixed up which hash is reversed and which is not.\\n\\nThen we just compute every suffix's hash and look up the matching words. Updating the hash as we go, we avoid O(nk^2) complexity and get O(nk) which is the best we can get since we *have* to analyze all words. To consider all cases, we do it twice, for reversed and non-reversed words.\\n\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        int bCount = Integer.highestOneBit(words.length - 1) << 1; // round up to power of 2\\n        List<Integer>[] buckets = new List[bCount];\\n        List<Integer>[] revBuckets = new List[bCount];\\n        String[] revWords = new String[words.length];\\n        for (int i = 0; i < words.length; ++i) {\\n            String s = words[i];\\n            String r = new StringBuilder(s).reverse().toString();\\n            revWords[i] = r;\\n            int h = 0, hrev = 0;\\n            for (int j = 0; j < s.length(); ++j) {\\n                h = h * 17 + r.charAt(j); // will compute hash for suffixes in reversed order\\n                hrev = hrev * 17 + s.charAt(j); // so here s and r are swapped\\n            }\\n            h = (h & Integer.MAX_VALUE) % buckets.length;\\n            hrev = (hrev & Integer.MAX_VALUE) % revBuckets.length;\\n            if (buckets[h] == null) {\\n                buckets[h] = new ArrayList<>();\\n            }\\n            buckets[h].add(i);\\n            if (revBuckets[hrev] == null) {\\n                revBuckets[hrev] = new ArrayList();\\n            }\\n            revBuckets[hrev].add(i);\\n        }\\n        for (int i = 0; i < words.length; ++i) {\\n            String s = words[i];\\n            int[] m = manacher(s);\\n            for (int j : findPairs(s, m, 0, revBuckets, revWords)) {\\n                if (i != j) {\\n                    result.add(Arrays.asList(j, i));\\n                }\\n            }\\n            s = revWords[i];\\n            for (int j = 0, k = m.length - 1; j < k; ++j, --k) {\\n                int tmp = m[j];\\n                m[j] = m[k];\\n                m[k] = tmp;\\n            }\\n            for (int j : findPairs(s, m, 1, buckets, words)) {\\n                if (i != j) {\\n                    result.add(Arrays.asList(i, j));\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private static List<Integer> findPairs(String s, int[] manacher, int end,\\n            List<Integer>[] buckets, String[] words) {\\n        List<Integer> pairs = new ArrayList<>();\\n        for (int i = s.length(), h = 0;; ) {\\n            assert i + manacher[i] <= 2 * i;\\n            if (i + manacher[i] == 2 * i) {\\n                List<Integer> bucket = buckets[(h & Integer.MAX_VALUE) % buckets.length];\\n                if (bucket != null) {\\n                    for (int j : bucket) {\\n                        if (s.length() - i == words[j].length() && s.regionMatches(i, words[j], 0, words[j].length())) {\\n                            pairs.add(j);\\n                        }\\n                    }\\n                }\\n            }\\n            if (--i < end) {\\n                break;\\n            }\\n            h = h * 17 + s.charAt(i);\\n        }\\n        return pairs;\\n    }\\n    \\n    private static int[] manacher(String s) {\\n        final int n = s.length() * 2 + 1;\\n        int[] p = new int[n];\\n        for (int i = 0, c = 0; i < n; ++i) {\\n            int r = c + p[c], il, ir;\\n            if (i > r) {\\n                il = i - 1;\\n                ir = i + 1;\\n            } else {\\n                int i2 = c - (i - c);\\n                if (i + p[i2] >= r) {\\n                    ir = r + 1;\\n                    il = i - (ir - i);\\n                    p[i] = r - i;\\n                } else {\\n                    p[i] = p[i2];\\n                    il = ir = -1; // skip the check\\n                }\\n            }\\n            while (il >= 0 && ir < n && ((il & 1) == 0 || s.charAt(il / 2) == s.charAt(ir / 2))) {\\n                ++p[i];\\n                --il;\\n                ++ir;\\n            }\\n            if (i + p[i] > r) {\\n                c = i;\\n            }\\n        }\\n        return p;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "**Added: a (not so) naive solution**\\n\\nIf two concatenated words form a palindrome, then there are three cases to consider:\\n\\n    +---s1---+---s2--+     +---s1---+-s2-+    +-s1-+---s2---+\\n    |abcdefgh|hgfedcba|    |abcdxyyx|dcba|    |abcd|xyyxdcba|\\n\\nCase 1 is when one string is a mirror image of another. Case 2 is when the first string is longer than the other and consists of the mirror image of the other (prefix) and a palindrome (suffix). Case 3 is a mirror image of case 2. Case 1 can also be considered a special subcase of either case 2 or case 3 with an empty palindrome suffix/prefix.\\n\\nOf these three, case 1 is definitely the easiest because we just need to look up a word in a reverse string-to-index map (words are unique, so no multimaps needed). If we iterate over the list with `s1` as the current string, then case 2 is also much easier than case 3 because when we locate a prefix/palindrome split inside `s1` we just need to look up for the reversed prefix in the map.\\n\\nCase 3 is trickier, but we can get rid of case 3 altogether if we just make another run with the reversed words! This way case 3 turns into case 2. We only need to consider case 1 in one of these runs in order to avoid duplicate combinations. With that in mind, I present the following 154 ms solution:\\n\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        Map<String, Integer> index = new HashMap<>();\\n        Map<String, Integer> revIndex = new HashMap<>();\\n        String[] revWords = new String[words.length];\\n        for (int i = 0; i < words.length; ++i) {\\n            String s = words[i];\\n            String r = new StringBuilder(s).reverse().toString();\\n            index.put(s, i);\\n            revIndex.put(r, i);\\n            revWords[i] = r;\\n        }\\n        List<List<Integer>> result = new ArrayList<>();\\n        result.addAll(findPairs(words, revWords, revIndex, false));\\n        result.addAll(findPairs(revWords, words, index, true));\\n        return result;\\n    }\\n    \\n    private static List<List<Integer>> findPairs(String[] words, String[] revWords, Map<String, Integer> revIndex, boolean reverse) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        for (int i = 0; i < words.length; ++i) {\\n            String s = words[i];\\n            for (int k = reverse ? 1 : 0; k <= s.length(); ++k) { // check suffixes, <= because we allow empty words\\n                Integer j = revIndex.get(s.substring(k));\\n                if (j != null && j != i) { // reversed suffix is present in the words list\\n                    // check whether the prefix is a palindrome\\n                    if (s.regionMatches(0, revWords[i], s.length() - k, k)) {\\n                        result.add(reverse ? Arrays.asList(i, j) : Arrays.asList(j, i));\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\nNow this was actually the third solution I came up with. The first one was really ugly because it considered all three cases separately. The second one is below.\\n\\n**The ugly optimized solution**\\n\\nAs in other solutions posted here, I used Manacher's algorithm to quickly determine whether some part of a string is a palindrome or not. That gets rid of one O(nk^2) part, where `k` is the average word length and `n` is the number of words.\\n\\nAnother part is numerous calls to `substring`, so my idea is to avoid copying a substring unless there's a good chance that it's actually present in the list. I do this by creating a kind of ad-hoc hash tables for both reversed and non-reversed words.\\n\\nWe start by iterating over the list of the words and compute hashes for both reversed and non-reversed words. However, because I later calculate hashes of *suffixes* on the fly, which means that I calculate them right-to-left, so it is kind of mixed up which hash is reversed and which is not.\\n\\nThen we just compute every suffix's hash and look up the matching words. Updating the hash as we go, we avoid O(nk^2) complexity and get O(nk) which is the best we can get since we *have* to analyze all words. To consider all cases, we do it twice, for reversed and non-reversed words.\\n\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        int bCount = Integer.highestOneBit(words.length - 1) << 1; // round up to power of 2\\n        List<Integer>[] buckets = new List[bCount];\\n        List<Integer>[] revBuckets = new List[bCount];\\n        String[] revWords = new String[words.length];\\n        for (int i = 0; i < words.length; ++i) {\\n            String s = words[i];\\n            String r = new StringBuilder(s).reverse().toString();\\n            revWords[i] = r;\\n            int h = 0, hrev = 0;\\n            for (int j = 0; j < s.length(); ++j) {\\n                h = h * 17 + r.charAt(j); // will compute hash for suffixes in reversed order\\n                hrev = hrev * 17 + s.charAt(j); // so here s and r are swapped\\n            }\\n            h = (h & Integer.MAX_VALUE) % buckets.length;\\n            hrev = (hrev & Integer.MAX_VALUE) % revBuckets.length;\\n            if (buckets[h] == null) {\\n                buckets[h] = new ArrayList<>();\\n            }\\n            buckets[h].add(i);\\n            if (revBuckets[hrev] == null) {\\n                revBuckets[hrev] = new ArrayList();\\n            }\\n            revBuckets[hrev].add(i);\\n        }\\n        for (int i = 0; i < words.length; ++i) {\\n            String s = words[i];\\n            int[] m = manacher(s);\\n            for (int j : findPairs(s, m, 0, revBuckets, revWords)) {\\n                if (i != j) {\\n                    result.add(Arrays.asList(j, i));\\n                }\\n            }\\n            s = revWords[i];\\n            for (int j = 0, k = m.length - 1; j < k; ++j, --k) {\\n                int tmp = m[j];\\n                m[j] = m[k];\\n                m[k] = tmp;\\n            }\\n            for (int j : findPairs(s, m, 1, buckets, words)) {\\n                if (i != j) {\\n                    result.add(Arrays.asList(i, j));\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private static List<Integer> findPairs(String s, int[] manacher, int end,\\n            List<Integer>[] buckets, String[] words) {\\n        List<Integer> pairs = new ArrayList<>();\\n        for (int i = s.length(), h = 0;; ) {\\n            assert i + manacher[i] <= 2 * i;\\n            if (i + manacher[i] == 2 * i) {\\n                List<Integer> bucket = buckets[(h & Integer.MAX_VALUE) % buckets.length];\\n                if (bucket != null) {\\n                    for (int j : bucket) {\\n                        if (s.length() - i == words[j].length() && s.regionMatches(i, words[j], 0, words[j].length())) {\\n                            pairs.add(j);\\n                        }\\n                    }\\n                }\\n            }\\n            if (--i < end) {\\n                break;\\n            }\\n            h = h * 17 + s.charAt(i);\\n        }\\n        return pairs;\\n    }\\n    \\n    private static int[] manacher(String s) {\\n        final int n = s.length() * 2 + 1;\\n        int[] p = new int[n];\\n        for (int i = 0, c = 0; i < n; ++i) {\\n            int r = c + p[c], il, ir;\\n            if (i > r) {\\n                il = i - 1;\\n                ir = i + 1;\\n            } else {\\n                int i2 = c - (i - c);\\n                if (i + p[i2] >= r) {\\n                    ir = r + 1;\\n                    il = i - (ir - i);\\n                    p[i] = r - i;\\n                } else {\\n                    p[i] = p[i2];\\n                    il = ir = -1; // skip the check\\n                }\\n            }\\n            while (il >= 0 && ir < n && ((il & 1) == 0 || s.charAt(il / 2) == s.charAt(ir / 2))) {\\n                ++p[i];\\n                --il;\\n                ++ir;\\n            }\\n            if (i + p[i] > r) {\\n                c = i;\\n            }\\n        }\\n        return p;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 316960,
                "title": "different-python-solutions-brute-force-dictionary-trie",
                "content": "For different indices (i, j), the concatenation of A = words[i] and B = words[j] is palindrome if and only if\\n(i) B + A is aplindrome: A_suf[::-1] == B, A_pre is palindrome\\n(ii) A + B is palindrome: A_pre[::-1] == B, A_suf is palindrome\\nwhere A_pre = A[:k], A_suf = A[k:] for k equals one of 0, 1, ..., len(A). \\n\\nLet n = len(words), m be the maximal length of these words.\\n\\nSolution 1 with O(n^2 m) time and O(1) space:\\n```\\n    def palindromePairs(self, words):\\n        def is_palindrome_pair(A, B):\\n            lA, lB = len(A), len(B)\\n            i, j = 0, lA + lB - 1\\n            while i < j:\\n                s_i = A[i] if i < lA else B[i-lA]\\n                s_j = A[j] if j < lA else B[j-lA]\\n                if s_i != s_j:\\n                    return False\\n                i, j = i + 1, j - 1\\n            return True\\n        \\n        valid_pals = []\\n        n = len(words)\\n        for i in range(n - 1):\\n            for j in range(i + 1, n):\\n                if is_palindrome_pair(words[i], words[j]):\\n                    valid_pals.append([i, j])\\n                if is_palindrome_pair(words[j], words[i]):\\n                    valid_pals.append([j, i])\\n        return valid_pals\\n```\\n\\nSolution 2 with O(n * m^2) time and O(n * m) space:\\nFor each word A = words[i], use a dictionary to search B = words[j].\\n```\\n    def palindromePairs(self, words):\\n        def is_palindrome(check):\\n            return check == check[::-1]\\n        \\n        valid_pals = []\\n        words = {word: i for i, word in enumerate(words)}\\n        for word in words:\\n            m = len(word)\\n            for k in range(m+1):\\n                prefix = word[:k]\\n                suffix = word[k:]\\n                if is_palindrome(prefix):\\n                    back = suffix[::-1]\\n                    if back in words and words[back] != words[word]:\\n                        valid_pals.append([words[back],  words[word]])\\n                if k != m and is_palindrome(suffix): # k!= m is added to avoid considering A == B[::-1]  twice\\n                    back = prefix[::-1]\\n                    if back in words and words[back] != words[word]:\\n                        valid_pals.append([words[word], words[back]])\\n        return valid_pals\\n```\\n\\nSolution 3 with O(n * m^2) time and O(n * m) space:\\nFor each word A = words[i], use a trie to search B = words[j]. \\nThis method can be modified a little bit to work for follow up questions: \\nn is very large, duplicated words exist.\\n\\nPlease see and vote for my solutions for\\n[208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/discuss/320224/Simple-Python-solution)\\n[1233. Remove Sub-Folders from the Filesystem](https://leetcode.com/problems/remove-sub-folders-from-the-filesystem/discuss/409075/standard-python-prefix-tree-solution)\\n[1032. Stream of Characters](https://leetcode.com/problems/stream-of-characters/discuss/320837/Standard-Python-Trie-Solution)\\n[211. Add and Search Word - Data structure design](https://leetcode.com/problems/add-and-search-word-data-structure-design/discuss/319361/Simple-Python-solution)\\n[676. Implement Magic Dictionary](https://leetcode.com/problems/implement-magic-dictionary/discuss/320197/Simple-Python-solution)\\n[677. Map Sum Pairs](https://leetcode.com/problems/map-sum-pairs/discuss/320237/Simple-Python-solution)\\n[745. Prefix and Suffix Search](https://leetcode.com/problems/prefix-and-suffix-search/discuss/320712/Different-Python-solutions-with-thinking-process)\\n[425. Word Squares](https://leetcode.com/problems/word-squares/discuss/320916/Easily-implemented-Python-solution%3A-Backtrack-%2B-Trie)\\n[472. Concatenated Words](https://leetcode.com/problems/concatenated-words/discuss/322444/Python-solutions%3A-top-down-DP-Trie)\\n[212. Word Search II](https://leetcode.com/problems/word-search-ii/discuss/319071/Standard-Python-solution-with-Trie-%2B-Backtrack)\\n[336. Palindrome Pairs](https://leetcode.com/problems/palindrome-pairs/discuss/316960/Different-Python-solutions%3A-brute-force-dictionary-Trie)\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.isEnd = False\\n        self.index = -1\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n    def insert(self, word, index):\\n        node = self.root\\n        for char in word:\\n            if char not in node.children:\\n                node.children[char] = TrieNode()\\n            node = node.children[char]\\n        node.isEnd = True\\n        node.index = index\\n\\n    def search(self, word):\\n        node = self.root\\n        for char in word:\\n            if char not in node.children:\\n                return (False, -1)\\n            node = node.children[char]\\n        return (node.isEnd, node.index)\\n\\nclass Solution:\\n    def palindromePairs(self, words):\\n        def is_palindrome(check):\\n            return check == check[::-1]\\n        \\n        trie = Trie()\\n        for i, word in enumerate(words):\\n            trie.insert(word, i)\\n        valid_pals = []\\n        for i, word in enumerate(words):\\n            m = len(word)\\n            for k in range(m+1):\\n                prefix = word[:k]\\n                suffix = word[k:]\\n                if is_palindrome(prefix):\\n                    search, index = trie.search(suffix[::-1])\\n                    if search and index != i:\\n                        valid_pals.append([index,  i])\\n                if k != m and is_palindrome(suffix):\\n                    search, index = trie.search(prefix[::-1])\\n                    if search and index != i:\\n                        valid_pals.append([i, index])\\n        return valid_pals\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def palindromePairs(self, words):\\n        def is_palindrome_pair(A, B):\\n            lA, lB = len(A), len(B)\\n            i, j = 0, lA + lB - 1\\n            while i < j:\\n                s_i = A[i] if i < lA else B[i-lA]\\n                s_j = A[j] if j < lA else B[j-lA]\\n                if s_i != s_j:\\n                    return False\\n                i, j = i + 1, j - 1\\n            return True\\n        \\n        valid_pals = []\\n        n = len(words)\\n        for i in range(n - 1):\\n            for j in range(i + 1, n):\\n                if is_palindrome_pair(words[i], words[j]):\\n                    valid_pals.append([i, j])\\n                if is_palindrome_pair(words[j], words[i]):\\n                    valid_pals.append([j, i])\\n        return valid_pals\\n```\n```\\n    def palindromePairs(self, words):\\n        def is_palindrome(check):\\n            return check == check[::-1]\\n        \\n        valid_pals = []\\n        words = {word: i for i, word in enumerate(words)}\\n        for word in words:\\n            m = len(word)\\n            for k in range(m+1):\\n                prefix = word[:k]\\n                suffix = word[k:]\\n                if is_palindrome(prefix):\\n                    back = suffix[::-1]\\n                    if back in words and words[back] != words[word]:\\n                        valid_pals.append([words[back],  words[word]])\\n                if k != m and is_palindrome(suffix): # k!= m is added to avoid considering A == B[::-1]  twice\\n                    back = prefix[::-1]\\n                    if back in words and words[back] != words[word]:\\n                        valid_pals.append([words[word], words[back]])\\n        return valid_pals\\n```\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.isEnd = False\\n        self.index = -1\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n    def insert(self, word, index):\\n        node = self.root\\n        for char in word:\\n            if char not in node.children:\\n                node.children[char] = TrieNode()\\n            node = node.children[char]\\n        node.isEnd = True\\n        node.index = index\\n\\n    def search(self, word):\\n        node = self.root\\n        for char in word:\\n            if char not in node.children:\\n                return (False, -1)\\n            node = node.children[char]\\n        return (node.isEnd, node.index)\\n\\nclass Solution:\\n    def palindromePairs(self, words):\\n        def is_palindrome(check):\\n            return check == check[::-1]\\n        \\n        trie = Trie()\\n        for i, word in enumerate(words):\\n            trie.insert(word, i)\\n        valid_pals = []\\n        for i, word in enumerate(words):\\n            m = len(word)\\n            for k in range(m+1):\\n                prefix = word[:k]\\n                suffix = word[k:]\\n                if is_palindrome(prefix):\\n                    search, index = trie.search(suffix[::-1])\\n                    if search and index != i:\\n                        valid_pals.append([index,  i])\\n                if k != m and is_palindrome(suffix):\\n                    search, index = trie.search(prefix[::-1])\\n                    if search and index != i:\\n                        valid_pals.append([i, index])\\n        return valid_pals\\n```",
                "codeTag": "Java"
            },
            {
                "id": 129865,
                "title": "clean-c-solution",
                "content": "```\\n     bool isPalindrome(string& s) {   \\n          int l=0, r=s.size()-1;\\n          while(l<r){if(s[l++]!=s[r--]) return false;}\\n          return true; \\n    }\\n\\n\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        vector<vector<int>> ans;\\n        int n = words.size();\\n        if(n<2) return ans;\\n        unordered_map<string, int> m;\\n        for(int i=0;i<n;++i){ auto s= words[i]; reverse(s.begin(),s.end());  m[s]=i;}\\n        \\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<=words[i].size(); ++j){\\n                string st1 = words[i].substr(0,j);\\n                string st2 = words[i].substr(j);                \\n                \\n                 if(m.count(st1) && isPalindrome(st2) && m[st1] != i) {\\n                     ans.push_back({i, m[st1]});    \\n                 }\\n\\n                 if(!st1.empty()&&m.count(st2) && isPalindrome(st1) && m[st2] != i) {\\n                     ans.push_back({m[st2], i});\\n                 }\\n            }            \\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n     bool isPalindrome(string& s) {   \\n          int l=0, r=s.size()-1;\\n          while(l<r){if(s[l++]!=s[r--]) return false;}\\n          return true; \\n    }\\n\\n\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        vector<vector<int>> ans;\\n        int n = words.size();\\n        if(n<2) return ans;\\n        unordered_map<string, int> m;\\n        for(int i=0;i<n;++i){ auto s= words[i]; reverse(s.begin(),s.end());  m[s]=i;}\\n        \\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<=words[i].size(); ++j){\\n                string st1 = words[i].substr(0,j);\\n                string st2 = words[i].substr(j);                \\n                \\n                 if(m.count(st1) && isPalindrome(st2) && m[st1] != i) {\\n                     ans.push_back({i, m[st1]});    \\n                 }\\n\\n                 if(!st1.empty()&&m.count(st2) && isPalindrome(st1) && m[st2] != i) {\\n                     ans.push_back({m[st2], i});\\n                 }\\n            }            \\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2588179,
                "title": "short-c-without-tries-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Please do UPVOTE to motivate me to solve more daily challenges like this !!**\\n**Watch this video \\uD83E\\uDC83 for the better explanation of the code.\\n\\nhttps://www.youtube.com/watch?v=SJeIGnYoKNc\\n\\n\\n**Also you can SUBSCRIBE  \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.**\\nhttps://t.me/dsacoder  \\u2B05\\u2B05 **Telegram link** to discuss leetcode daily questions and other dsa problems\\n\\n**C++** Partial credit- https://leetcode.com/problems/palindrome-pairs/discuss/2585819/(Left-%2B-Mid-%2B-Right)-Palindrome-oror-Easy-to-Understand-oror-C%2B%2B-code\\n```\\n\\nclass Solution {\\n\\nprivate:\\n\\tbool checkPalindrome(string& word, int l, int r) {\\n\\t\\twhile (l < r)\\n\\t\\t{\\n\\t\\t\\tif (word[l] != word[r]) return false;\\n\\t\\t\\tl++; r--;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\npublic:\\n\\tvector<vector<int>> palindromePairs(vector<string>& words) {\\n\\t\\tunordered_map<string, int> um;\\n\\t\\tvector<vector<int>> ans;\\n\\t\\tint emptyindex = -1;\\n\\t\\tvector<int> indexOfPalindromes;\\n\\t\\tfor (int i = 0; i < words.size(); ++i)\\n\\t\\t{\\n\\t\\t\\tif (words[i] == \"\")\\n\\t\\t\\t{\\n\\t\\t\\t\\temptyindex = i;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tif (checkPalindrome(words[i], 0, words[i].size() - 1))\\n\\t\\t\\t\\tindexOfPalindromes.push_back(i);\\n\\t\\t\\tstring str = words[i];\\n\\t\\t\\t\\n\\t\\t\\treverse(begin(str), end(str));\\n\\t\\t\\tum[str] = i;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < words.size(); ++i)\\n\\t\\t{\\n\\t\\t\\tfor (int cut = 0; cut < words[i].size(); ++cut)\\n\\t\\t\\t{\\n\\t\\t\\t\\n\\t\\t\\t\\tif (checkPalindrome(words[i], cut, words[i].size() - 1))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstring right = words[i].substr(0, cut);\\n\\t\\t\\t\\t\\tif (um.find(right) != end(um) && um[right] != i)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tans.push_back(vector<int> {i, um[right]});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif (checkPalindrome(words[i], 0, cut - 1))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstring left = words[i].substr(cut);\\n\\t\\t\\t\\t\\tif (um.find(left) != end(um) && um[left] != i)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tans.push_back(vector<int> {um[left], i});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (emptyindex != -1)\\n\\t\\t\\tfor (int x : indexOfPalindromes)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans.push_back(vector<int> {emptyindex, x});\\n\\t\\t\\t\\tans.push_back(vector<int> {x, emptyindex});\\n\\t\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\n\\nprivate:\\n\\tbool checkPalindrome(string& word, int l, int r) {\\n\\t\\twhile (l < r)\\n\\t\\t{\\n\\t\\t\\tif (word[l] != word[r]) return false;\\n\\t\\t\\tl++; r--;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\npublic:\\n\\tvector<vector<int>> palindromePairs(vector<string>& words) {\\n\\t\\tunordered_map<string, int> um;\\n\\t\\tvector<vector<int>> ans;\\n\\t\\tint emptyindex = -1;\\n\\t\\tvector<int> indexOfPalindromes;\\n\\t\\tfor (int i = 0; i < words.size(); ++i)\\n\\t\\t{\\n\\t\\t\\tif (words[i] == \"\")\\n\\t\\t\\t{\\n\\t\\t\\t\\temptyindex = i;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tif (checkPalindrome(words[i], 0, words[i].size() - 1))\\n\\t\\t\\t\\tindexOfPalindromes.push_back(i);\\n\\t\\t\\tstring str = words[i];\\n\\t\\t\\t\\n\\t\\t\\treverse(begin(str), end(str));\\n\\t\\t\\tum[str] = i;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < words.size(); ++i)\\n\\t\\t{\\n\\t\\t\\tfor (int cut = 0; cut < words[i].size(); ++cut)\\n\\t\\t\\t{\\n\\t\\t\\t\\n\\t\\t\\t\\tif (checkPalindrome(words[i], cut, words[i].size() - 1))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstring right = words[i].substr(0, cut);\\n\\t\\t\\t\\t\\tif (um.find(right) != end(um) && um[right] != i)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tans.push_back(vector<int> {i, um[right]});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif (checkPalindrome(words[i], 0, cut - 1))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstring left = words[i].substr(cut);\\n\\t\\t\\t\\t\\tif (um.find(left) != end(um) && um[left] != i)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tans.push_back(vector<int> {um[left], i});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (emptyindex != -1)\\n\\t\\t\\tfor (int x : indexOfPalindromes)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans.push_back(vector<int> {emptyindex, x});\\n\\t\\t\\t\\tans.push_back(vector<int> {x, emptyindex});\\n\\t\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2586828,
                "title": "python-easy-91-fast-short-hashmap-beginner-friendly",
                "content": "Upvote if it helped. Thanks\\n\\n![image](https://assets.leetcode.com/users/images/51cdef59-13a3-46a4-9fbf-3cc326cc49d4_1663410552.3370268.png)\\n\\n```\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        ans =set()\\n        val_pos = {w:idx for idx,w in enumerate(words)}\\n        for i,word in enumerate(words):\\n            for j in range(len(word)+1):\\n                pref = word[:j] \\n                suf = word[j:]\\n                inv_pref = pref[::-1]\\n                inv_suf = suf[::-1]\\n                if(pref==inv_pref):\\n                    if(inv_suf in val_pos and val_pos[inv_suf]!=i):ans.add((val_pos[inv_suf],i))\\n            \\n                if(suf==inv_suf):\\n                    if(inv_pref in val_pos and val_pos[inv_pref]!=i):ans.add((i,val_pos[inv_pref]))\\n\\n        return [list(pair) for pair in ans]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        ans =set()\\n        val_pos = {w:idx for idx,w in enumerate(words)}\\n        for i,word in enumerate(words):\\n            for j in range(len(word)+1):\\n                pref = word[:j] \\n                suf = word[j:]\\n                inv_pref = pref[::-1]\\n                inv_suf = suf[::-1]\\n                if(pref==inv_pref):\\n                    if(inv_suf in val_pos and val_pos[inv_suf]!=i):ans.add((val_pos[inv_suf],i))\\n            \\n                if(suf==inv_suf):\\n                    if(inv_pref in val_pos and val_pos[inv_pref]!=i):ans.add((i,val_pos[inv_pref]))\\n\\n        return [list(pair) for pair in ans]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 356678,
                "title": "c-concise-solution",
                "content": "```cpp\\nvector<vector<int>> palindromePairs(vector<string>& words) {\\n\\tunordered_map<string, int> mp;\\n\\tfor(int i = 0; i < words.size(); i++) \\n\\t\\tmp[string(rbegin(words[i]), rend(words[i]))] = i;\\n\\n\\tvector<vector<int>> res;\\n\\tif(mp.count(\"\")) \\n\\t\\tfor(int i = 0; i < words.size(); i++) \\n\\t\\t\\tif(words[i] != \"\" && isPal(words[i]))\\n\\t\\t\\t\\tres.push_back({mp[\"\"], i});\\n\\n\\tfor(int i = 0; i < words.size(); i++)\\n\\t\\tfor(int j = 0; j < words[i].size(); j++) {\\n\\t\\t\\tstring l = words[i].substr(0, j), r = words[i].substr(j);\\n\\t\\t\\tif(mp.count(l) && isPal(r) && mp[l] != i) res.push_back({i, mp[l]});\\n\\t\\t\\tif(mp.count(r) && isPal(l) && mp[r] != i) res.push_back({mp[r], i});\\n\\t\\t}\\n\\treturn res;\\n}\\n\\nbool isPal(string &s) {\\n\\tfor(int i = 0, j = s.size() - 1; i < j; i++, j--) \\n\\t\\tif(s[i] != s[j]) \\n\\t\\t\\treturn false;\\n\\treturn true;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nvector<vector<int>> palindromePairs(vector<string>& words) {\\n\\tunordered_map<string, int> mp;\\n\\tfor(int i = 0; i < words.size(); i++) \\n\\t\\tmp[string(rbegin(words[i]), rend(words[i]))] = i;\\n\\n\\tvector<vector<int>> res;\\n\\tif(mp.count(\"\")) \\n\\t\\tfor(int i = 0; i < words.size(); i++) \\n\\t\\t\\tif(words[i] != \"\" && isPal(words[i]))\\n\\t\\t\\t\\tres.push_back({mp[\"\"], i});\\n\\n\\tfor(int i = 0; i < words.size(); i++)\\n\\t\\tfor(int j = 0; j < words[i].size(); j++) {\\n\\t\\t\\tstring l = words[i].substr(0, j), r = words[i].substr(j);\\n\\t\\t\\tif(mp.count(l) && isPal(r) && mp[l] != i) res.push_back({i, mp[l]});\\n\\t\\t\\tif(mp.count(r) && isPal(l) && mp[r] != i) res.push_back({mp[r], i});\\n\\t\\t}\\n\\treturn res;\\n}\\n\\nbool isPal(string &s) {\\n\\tfor(int i = 0, j = s.size() - 1; i < j; i++, j--) \\n\\t\\tif(s[i] != s[j]) \\n\\t\\t\\treturn false;\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2587685,
                "title": "c-hashmap-only-solution-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    // kind of like a dp map, which stores if the calculated string is a palindrome or not\\n    unordered_map<string, bool> check;\\n    // function to check is string is palindrome\\n    bool palin(string &s)\\n    {\\n        if(check.find(s) != check.end())\\n            return check[s];\\n        \\n        if(s.length() == 0){\\n            check[s] = true;\\n            return true;\\n        }\\n        int n = s.length();\\n        for(int i = 0; i <= n/2; i++)\\n        {\\n            if(s[i] != s[(n - i) - 1])\\n            {\\n                check[s] = false;\\n                return false;\\n            }\\n        }\\n        check[s] = true;\\n        return true;    \\n    }\\n    \\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        \\n        unordered_map<string, int> mp;\\n        vector<vector<int>> ans;\\n        //storing the reverse of every string in unordered map\\n        for(int i = 0 ; i < words.size(); i++)\\n        {\\n            string str = words[i];\\n            reverse(str.begin(), str.end());\\n            mp[str] = i;\\n        }\\n        // if any string is \"\" means palindrome strings and \"\" string will form a pair\\n        if(mp.find(\"\") != mp.end())\\n        {\\n            for(int i = 0; i < words.size(); i++)\\n            {\\n                if(i == mp[\"\"])\\n                    continue;\\n                if(palin(words[i]))\\n                {\\n                    ans.push_back({i, mp[\"\"]});\\n                }\\n            }\\n        }\\n        // checking in the main vector\\n        for(int i = 0 ; i < words.size(); i++)\\n        {\\n            // storing the ith word in right and left as \"\"\\n            string right = words[i];\\n            string left = \"\";\\n            // we will delete letters from right and insert each letter, character by character in left and check if it is present in the map or not. If present, it should not have the same index as i.\\n            \\n            // if all these conditions pass, then we can push the indexes in our answer vector\\n            for(int j = 0 ; j < words[i].length(); j++)\\n            {\\n                left.push_back(words[i][j]);\\n                right.erase(right.begin() + 0);\\n                if(mp.find(left) != mp.end() and palin(right) and mp[left] != i)\\n                    ans.push_back({i, mp[left]});\\n                \\n                if(mp.find(right) != mp.end() and palin(left) and mp[right] != i)\\n                    ans.push_back({mp[right], i});\\n            }\\n        }\\n        // return ans;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // kind of like a dp map, which stores if the calculated string is a palindrome or not\\n    unordered_map<string, bool> check;\\n    // function to check is string is palindrome\\n    bool palin(string &s)\\n    {\\n        if(check.find(s) != check.end())\\n            return check[s];\\n        \\n        if(s.length() == 0){\\n            check[s] = true;\\n            return true;\\n        }\\n        int n = s.length();\\n        for(int i = 0; i <= n/2; i++)\\n        {\\n            if(s[i] != s[(n - i) - 1])\\n            {\\n                check[s] = false;\\n                return false;\\n            }\\n        }\\n        check[s] = true;\\n        return true;    \\n    }\\n    \\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        \\n        unordered_map<string, int> mp;\\n        vector<vector<int>> ans;\\n        //storing the reverse of every string in unordered map\\n        for(int i = 0 ; i < words.size(); i++)\\n        {\\n            string str = words[i];\\n            reverse(str.begin(), str.end());\\n            mp[str] = i;\\n        }\\n        // if any string is \"\" means palindrome strings and \"\" string will form a pair\\n        if(mp.find(\"\") != mp.end())\\n        {\\n            for(int i = 0; i < words.size(); i++)\\n            {\\n                if(i == mp[\"\"])\\n                    continue;\\n                if(palin(words[i]))\\n                {\\n                    ans.push_back({i, mp[\"\"]});\\n                }\\n            }\\n        }\\n        // checking in the main vector\\n        for(int i = 0 ; i < words.size(); i++)\\n        {\\n            // storing the ith word in right and left as \"\"\\n            string right = words[i];\\n            string left = \"\";\\n            // we will delete letters from right and insert each letter, character by character in left and check if it is present in the map or not. If present, it should not have the same index as i.\\n            \\n            // if all these conditions pass, then we can push the indexes in our answer vector\\n            for(int j = 0 ; j < words[i].length(); j++)\\n            {\\n                left.push_back(words[i][j]);\\n                right.erase(right.begin() + 0);\\n                if(mp.find(left) != mp.end() and palin(right) and mp[left] != i)\\n                    ans.push_back({i, mp[left]});\\n                \\n                if(mp.find(right) != mp.end() and palin(left) and mp[right] != i)\\n                    ans.push_back({mp[right], i});\\n            }\\n        }\\n        // return ans;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1269407,
                "title": "palindrome-pairs-brute-force-to-optimal",
                "content": "***1) Brute Force:(TLE)***\\n\\n```\\nBrute force approach is quite straightforward,\\nconsider every pair of strings and check if the string formed is palindrome or not.\\n---------------------------------------------------------------------------------------------\\nTime Complexity : O(N^2 * M),\\nwhere N -- the number of words.\\nM -- maximum length of word that can be formed by concatenation of two words. \\n```\\n```---------------------------------------------------------------------------------------------```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    bool check(string a)\\n    {\\n        int i=0,j=a.length()-1;\\n        while(i<=j)\\n        {\\n            if(a[i]!=a[j])\\n                return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    vector<vector<int>> palindromePairs(vector<string>& words) \\n    {\\n        vector<vector<int>> res;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            for(int j=0;j<words.size();j++)\\n            {\\n                if(i!=j)\\n                {\\n                    if(check(words[i]+words[j]))\\n                        res.push_back({i,j});\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n```---------------------------------------------------------------------------------------------```\\n\\n***2)Optimization(Accepted):***\\n```\\n1) First of all, as in the output we need to return indices corresponding to the possible candidates, \\nso it is very clear that we need to have mapping between word and its index.\\n\\n2 Now, Each string can be divided at particular index into two substrings,first is prefix string and second is suffix string,\\nwe first check whether prefix string is a palindrome and if so then there is a possibility that by using this prefix string,we can form a new palindrome.\\n\\nSo, to check whether the palindrome can be formed using prefix string,we need to check whether the reverse of suffix string is present in the map or not.\\nAnd same goes for the case when we try suffix string as the possible candidate for palindrome.\\n\\n3) If for prefix string , the reverse suffix string\\'s index is different as of the current string, then we are sure that we found a pair of palindromic strings.\\n\\n4) If for suffix string , the reverse prefix string\\'s index is different as of the current string, then we are sure that we found another pair of palindromic strings.\\n```\\n```\\n# Time Complexity: O(N * M^2),\\n# N -- number of words,\\n# M -- Average length of words(Worst Case).\\n```\\n\\n```---------------------------------------------------------------------------------------------```\\n\\n**C++(USING MAPS)**\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string &str)\\n    {\\n        int i=0;\\n        int j=str.length()-1;\\n        while(i<=j)\\n        {\\n            if(str[i]!=str[j])\\n                return false;\\n            i++,j--;\\n        }\\n        return true;\\n    }\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        vector<vector<int>> res;\\n        if(words.size()<2)\\n            return res;\\n        unordered_map<string,int> mp;\\n        for(int i=0;i<words.size();i++)\\n            mp[words[i]] = i;\\n        \\n        for(int i=0;i<words.size();i++)\\n        {\\n            for(int j=0;j<=words[i].length();j++)\\n            {\\n                string prefixString = words[i].substr(0,j);\\n                string suffixString = words[i].substr(j);\\n\\n                if(isPalindrome(prefixString))\\n                {\\n                    string reverseString = suffixString;\\n                    reverse(reverseString.begin(),reverseString.end());\\n                    if(mp.count(reverseString) and mp[reverseString]!=i)\\n                    {\\n                        res.push_back({mp[reverseString],i});\\n                    }\\n                }\\n                \\n                if(isPalindrome(suffixString))\\n                {\\n                    string reverseString = prefixString;\\n                    reverse(reverseString.begin(),reverseString.end());\\n                    if(mp.count(reverseString) and mp[reverseString]!=i and !suffixString.empty())\\n                    {\\n                        res.push_back({i,mp[reverseString]});\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nBrute force approach is quite straightforward,\\nconsider every pair of strings and check if the string formed is palindrome or not.\\n---------------------------------------------------------------------------------------------\\nTime Complexity : O(N^2 * M),\\nwhere N -- the number of words.\\nM -- maximum length of word that can be formed by concatenation of two words. \\n```\n```---------------------------------------------------------------------------------------------```\n```\\nclass Solution {\\npublic:\\n    bool check(string a)\\n    {\\n        int i=0,j=a.length()-1;\\n        while(i<=j)\\n        {\\n            if(a[i]!=a[j])\\n                return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    vector<vector<int>> palindromePairs(vector<string>& words) \\n    {\\n        vector<vector<int>> res;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            for(int j=0;j<words.size();j++)\\n            {\\n                if(i!=j)\\n                {\\n                    if(check(words[i]+words[j]))\\n                        res.push_back({i,j});\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```---------------------------------------------------------------------------------------------```\n```\\n1) First of all, as in the output we need to return indices corresponding to the possible candidates, \\nso it is very clear that we need to have mapping between word and its index.\\n\\n2 Now, Each string can be divided at particular index into two substrings,first is prefix string and second is suffix string,\\nwe first check whether prefix string is a palindrome and if so then there is a possibility that by using this prefix string,we can form a new palindrome.\\n\\nSo, to check whether the palindrome can be formed using prefix string,we need to check whether the reverse of suffix string is present in the map or not.\\nAnd same goes for the case when we try suffix string as the possible candidate for palindrome.\\n\\n3) If for prefix string , the reverse suffix string\\'s index is different as of the current string, then we are sure that we found a pair of palindromic strings.\\n\\n4) If for suffix string , the reverse prefix string\\'s index is different as of the current string, then we are sure that we found another pair of palindromic strings.\\n```\n```\\n# Time Complexity: O(N * M^2),\\n# N -- number of words,\\n# M -- Average length of words(Worst Case).\\n```\n```---------------------------------------------------------------------------------------------```\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string &str)\\n    {\\n        int i=0;\\n        int j=str.length()-1;\\n        while(i<=j)\\n        {\\n            if(str[i]!=str[j])\\n                return false;\\n            i++,j--;\\n        }\\n        return true;\\n    }\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        vector<vector<int>> res;\\n        if(words.size()<2)\\n            return res;\\n        unordered_map<string,int> mp;\\n        for(int i=0;i<words.size();i++)\\n            mp[words[i]] = i;\\n        \\n        for(int i=0;i<words.size();i++)\\n        {\\n            for(int j=0;j<=words[i].length();j++)\\n            {\\n                string prefixString = words[i].substr(0,j);\\n                string suffixString = words[i].substr(j);\\n\\n                if(isPalindrome(prefixString))\\n                {\\n                    string reverseString = suffixString;\\n                    reverse(reverseString.begin(),reverseString.end());\\n                    if(mp.count(reverseString) and mp[reverseString]!=i)\\n                    {\\n                        res.push_back({mp[reverseString],i});\\n                    }\\n                }\\n                \\n                if(isPalindrome(suffixString))\\n                {\\n                    string reverseString = prefixString;\\n                    reverse(reverseString.begin(),reverseString.end());\\n                    if(mp.count(reverseString) and mp[reverseString]!=i and !suffixString.empty())\\n                    {\\n                        res.push_back({i,mp[reverseString]});\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79314,
                "title": "my-c-solution-275ms-worst-case-o-n-2",
                "content": "use a hashtable (unordered_map map) to save the mapping between string and its index and use a ordered set (wLen) to save all possible string lengths. Then go through each string, \\na) generate its reverse string temp\\nb) see if temp is in the map, if so, add (it, map[temp]) to res\\nc) check if it can concatenate a shorter string to generate a palindrome, then for each possible shorter length sL\\n  c1) check if we can add a sL-long string after the current string\\n  c2) check if we can add a sL-long string before the current one \\n\\n    class Solution {\\n    private:\\n        bool isP(string &s, int left, int right)\\n        { // check if s[left::right] is a palindrome\\n            while(left<right)\\n                if(s[left++] !=s[right--]) return false;\\n            return true;\\n        }\\n    \\n    public:\\n        vector<vector<int>> palindromePairs(vector<string>& words) {\\n            unordered_map<string, int> map;\\n            set<int> wLen;\\n            int it, len=words.size(), it2, sL, lL;\\n            vector<vector<int>> res;\\n    \\n            for(it=0; it<len; ++it) { //build map and the length set\\n                map[words[it]] = it;\\n                wLen.insert(words[it].size());\\n            }\\n    \\n            for(it=0; it<len; ++it)\\n            { // for each string\\n                string temp = words[it];\\n                lL = temp.size();\\n                std::reverse(temp.begin(), temp.end()); // reverse it, step a)\\n                if(map.count(temp) && map[temp]!=it)\\n                      res.push_back(vector<int>({it, map[temp]})); //step b)\\n                auto itC = wLen.find(words[it].size());\\n                for(auto itL=wLen.begin(); itL!=itC; ++itL)\\n                { // for each possible shorter length\\n                    sL = *itL;\\n                    if(isP(temp, 0, lL-sL-1) && map.count(temp.substr(lL-sL)))\\n                          res.push_back(vector<int>({it, map[temp.substr(lL-sL)]})); //step c1)\\n                    if(isP(temp, sL, lL-1) && map.count(temp.substr(0,sL)))\\n                         res.push_back(vector<int>({map[temp.substr(0,sL)], it})); //step c2)                       \\n                }\\n            }    \\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    private:\\n        bool isP(string &s, int left, int right)\\n        { // check if s[left::right] is a palindrome\\n            while(left<right)\\n                if(s[left++] !=s[right--]) return false;\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2586445,
                "title": "js-javascript-2-solutions-brute-force-map",
                "content": "**Solution 1: Brute Force Solution ~ Time Limit Exceeded**\\n\\n```\\n// Time complexity: O(n^2 * k)\\n// Space complexity: O(n * k).\\n\\nvar palindromePairs = function(words) {\\n\\tconst ans = [];\\n\\t\\n\\tfor(let i = 0; i < words.length; i++) {\\n\\t\\tfor(let j = 0; j < words.length; j++) {\\n\\t\\t\\tif(i != j) {\\n\\t\\t\\t\\tconst a = words[i] + words[j];\\n\\t\\t\\t\\tconst b = a.split(\"\").reverse().join(\"\");\\n\\n\\t\\t\\t\\tif(a === b)\\n\\t\\t\\t\\t\\tans.push([i, j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans;\\n};\\n```\\n\\n**Solution 2: Using Map + Set ~ 600 ms**\\n\\n```\\nvar palindromePairs = function(words) {\\n\\tconst wordMap = new Map();\\n\\tconst set = new Set();\\n\\tconst n = words.length;\\n\\t\\n\\tfor (let i = 0; i < n; i++) {\\n\\t\\twordMap.set(words[i], i);\\n\\t\\tset.add(words[i].length);\\n\\t}\\n\\t\\n    const lengths = Array.from(set).sort((a, b) => a - b);\\n\\tconst ans = [];\\n\\t\\n\\tfor(let i = 0; i < n; i++) {\\n\\t\\tlet length = words[i].length;\\n\\t\\t\\n\\t\\tif (length === 1) {\\n\\t\\t\\tif (wordMap.has(\"\")) {\\n\\t\\t\\t\\tans.push([i, wordMap.get(\"\")]);\\n\\t\\t\\t\\tans.push([wordMap.get(\"\"), i]);\\n\\t\\t\\t} \\n\\t\\t} \\n\\t\\t\\n\\t\\telse {\\n\\t\\t\\tconst reverse = words[i].split(\"\").reverse().join(\"\");\\n\\t\\t\\t\\n\\t\\t\\tif (wordMap.has(reverse) && wordMap.get(reverse) != i)\\n\\t\\t\\t\\tans.push([i, wordMap.get(reverse)]);\\n\\t\\t\\t\\n\\t\\t\\tfor (const k of lengths) {\\n\\t\\t\\t\\tif (k === length)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif (isPalindrome(reverse, 0, length - 1 - k)) {\\n\\t\\t\\t\\t\\tconst s1 = reverse.substring(length - k);\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif (wordMap.has(s1))\\n\\t\\t\\t\\t\\t\\tans.push([i, wordMap.get(s1)]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif (isPalindrome(reverse, k, length - 1)) {\\n\\t\\t\\t\\t\\tconst s2 = reverse.substring(0, k);\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif (wordMap.has(s2))\\n\\t\\t\\t\\t\\t\\tans.push([wordMap.get(s2), i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn ans;\\n};\\n\\nvar isPalindrome = function(s, left, right) {\\n\\twhile (left < right)\\n\\t\\tif (s[left++] !== s[right--])\\n\\t\\t\\treturn false;\\n\\t\\t\\n\\treturn true;\\n};\\n```\\n\\n**Please upvote if you find this post useful. Happy Coding!**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Time complexity: O(n^2 * k)\\n// Space complexity: O(n * k).\\n\\nvar palindromePairs = function(words) {\\n\\tconst ans = [];\\n\\t\\n\\tfor(let i = 0; i < words.length; i++) {\\n\\t\\tfor(let j = 0; j < words.length; j++) {\\n\\t\\t\\tif(i != j) {\\n\\t\\t\\t\\tconst a = words[i] + words[j];\\n\\t\\t\\t\\tconst b = a.split(\"\").reverse().join(\"\");\\n\\n\\t\\t\\t\\tif(a === b)\\n\\t\\t\\t\\t\\tans.push([i, j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans;\\n};\\n```\n```\\nvar palindromePairs = function(words) {\\n\\tconst wordMap = new Map();\\n\\tconst set = new Set();\\n\\tconst n = words.length;\\n\\t\\n\\tfor (let i = 0; i < n; i++) {\\n\\t\\twordMap.set(words[i], i);\\n\\t\\tset.add(words[i].length);\\n\\t}\\n\\t\\n    const lengths = Array.from(set).sort((a, b) => a - b);\\n\\tconst ans = [];\\n\\t\\n\\tfor(let i = 0; i < n; i++) {\\n\\t\\tlet length = words[i].length;\\n\\t\\t\\n\\t\\tif (length === 1) {\\n\\t\\t\\tif (wordMap.has(\"\")) {\\n\\t\\t\\t\\tans.push([i, wordMap.get(\"\")]);\\n\\t\\t\\t\\tans.push([wordMap.get(\"\"), i]);\\n\\t\\t\\t} \\n\\t\\t} \\n\\t\\t\\n\\t\\telse {\\n\\t\\t\\tconst reverse = words[i].split(\"\").reverse().join(\"\");\\n\\t\\t\\t\\n\\t\\t\\tif (wordMap.has(reverse) && wordMap.get(reverse) != i)\\n\\t\\t\\t\\tans.push([i, wordMap.get(reverse)]);\\n\\t\\t\\t\\n\\t\\t\\tfor (const k of lengths) {\\n\\t\\t\\t\\tif (k === length)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif (isPalindrome(reverse, 0, length - 1 - k)) {\\n\\t\\t\\t\\t\\tconst s1 = reverse.substring(length - k);\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif (wordMap.has(s1))\\n\\t\\t\\t\\t\\t\\tans.push([i, wordMap.get(s1)]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif (isPalindrome(reverse, k, length - 1)) {\\n\\t\\t\\t\\t\\tconst s2 = reverse.substring(0, k);\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif (wordMap.has(s2))\\n\\t\\t\\t\\t\\t\\tans.push([wordMap.get(s2), i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn ans;\\n};\\n\\nvar isPalindrome = function(s, left, right) {\\n\\twhile (left < right)\\n\\t\\tif (s[left++] !== s[right--])\\n\\t\\t\\treturn false;\\n\\t\\t\\n\\treturn true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2585974,
                "title": "4-cases-c-ac-solution",
                "content": "```\\n/* 4 cases to find palindrome pairs(str1, str2):\\ncase 1: If str1 is empty, then for any string str2 is a palindrome can match => (str1 + str2), (str2+str1)\\ncase 2: If str1/str2 is the reverse part of others, then => (str1 + str2), (str2 + str1)\\n\\ncase 3: Little Tricky!!\\nstr1 => [0,.....,x,.....n], where 0,.,x,n -> denotes index of string str1\\n\\nSuppose, str1[0...x] is palindrome, then reverse(str2) must match with str1[x+1...n], output => (str2 + str1) \\n\\nFor eg: \\nstr1 = \"abacd\", str2 = \"cd\", then palindrome => rev(str2) + str1 => dcabacd\\n[Note: Here, aba in str1 -> palindrome]\\n\\ncase 4: Similar to case 3,\\n\\nIf, str[x....n] is palindrome, then reverse(str2) must match with str1[0,...x], output => (str1 + str2)\\n\\nFor eg:\\nstr1 = \"abcbab\", str2 = \"abc\", then palindrome => str1 + rev(str2) => abcbababc\\n[Note: Here, bab in str1 -> palindrome]\\n*/\\n\\n\\nclass Solution {\\nprivate:\\n    bool isPalin(string str, int start, int end)\\n    {\\n        while(start < end)\\n        {\\n            if(str[start++] != str[end--])\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n\\n    \\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        \\n        vector<vector<int>> res;\\n        \\n        int n = words.size();\\n        \\n        unordered_map<string, int> mp;\\n        set<int> st;\\n        \\n        // first insert all words with index into hashmap\\n        for(int i = 0; i < n; i++)\\n        {\\n            mp[words[i]] = i;\\n            st.insert(words[i].size());\\n        }\\n        \\n        \\n        for(int i = 0; i < n; i++)\\n        {            \\n            int len = words[i].size();\\n            \\n            // case 1\\n            if(len == 1)\\n            {\\n                if(mp.count(\"\") && mp[\"\"] != i)\\n                {\\n                    res.push_back({i, mp[\"\"]});\\n                    res.push_back({mp[\"\"], i});\\n                }\\n                \\n                continue;\\n            }\\n            \\n                \\n            string rev = words[i];\\n            reverse(rev.begin(), rev.end());\\n            \\n            // case 2\\n            if(mp.count(rev) && mp[rev] != i)\\n            {\\n                res.push_back({i, mp[rev]});\\n            }\\n            \\n            \\n            for(auto size : st)\\n            {\\n                if(len == size) \\n                    break;\\n                \\n                // case 3\\n                if(isPalin(rev, 0, len - 1 - size))\\n                {\\n                    string str1 = rev.substr(len-size);\\n                    if(mp.count(str1))\\n                    {\\n                        res.push_back({i, mp[str1]});\\n                    }\\n                }\\n                \\n                \\n                // case 4\\n                if(isPalin(rev, size, len - 1))\\n                {\\n                    string str2 = rev.substr(0, size);\\n                    \\n                    if(mp.count(str2))\\n                    {\\n                        res.push_back({mp[str2], i});\\n                    }\\n                }\\n            }\\n                \\n        }\\n        \\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/* 4 cases to find palindrome pairs(str1, str2):\\ncase 1: If str1 is empty, then for any string str2 is a palindrome can match => (str1 + str2), (str2+str1)\\ncase 2: If str1/str2 is the reverse part of others, then => (str1 + str2), (str2 + str1)\\n\\ncase 3: Little Tricky!!\\nstr1 => [0,.....,x,.....n], where 0,.,x,n -> denotes index of string str1\\n\\nSuppose, str1[0...x] is palindrome, then reverse(str2) must match with str1[x+1...n], output => (str2 + str1) \\n\\nFor eg: \\nstr1 = \"abacd\", str2 = \"cd\", then palindrome => rev(str2) + str1 => dcabacd\\n[Note: Here, aba in str1 -> palindrome]\\n\\ncase 4: Similar to case 3,\\n\\nIf, str[x....n] is palindrome, then reverse(str2) must match with str1[0,...x], output => (str1 + str2)\\n\\nFor eg:\\nstr1 = \"abcbab\", str2 = \"abc\", then palindrome => str1 + rev(str2) => abcbababc\\n[Note: Here, bab in str1 -> palindrome]\\n*/\\n\\n\\nclass Solution {\\nprivate:\\n    bool isPalin(string str, int start, int end)\\n    {\\n        while(start < end)\\n        {\\n            if(str[start++] != str[end--])\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n\\n    \\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        \\n        vector<vector<int>> res;\\n        \\n        int n = words.size();\\n        \\n        unordered_map<string, int> mp;\\n        set<int> st;\\n        \\n        // first insert all words with index into hashmap\\n        for(int i = 0; i < n; i++)\\n        {\\n            mp[words[i]] = i;\\n            st.insert(words[i].size());\\n        }\\n        \\n        \\n        for(int i = 0; i < n; i++)\\n        {            \\n            int len = words[i].size();\\n            \\n            // case 1\\n            if(len == 1)\\n            {\\n                if(mp.count(\"\") && mp[\"\"] != i)\\n                {\\n                    res.push_back({i, mp[\"\"]});\\n                    res.push_back({mp[\"\"], i});\\n                }\\n                \\n                continue;\\n            }\\n            \\n                \\n            string rev = words[i];\\n            reverse(rev.begin(), rev.end());\\n            \\n            // case 2\\n            if(mp.count(rev) && mp[rev] != i)\\n            {\\n                res.push_back({i, mp[rev]});\\n            }\\n            \\n            \\n            for(auto size : st)\\n            {\\n                if(len == size) \\n                    break;\\n                \\n                // case 3\\n                if(isPalin(rev, 0, len - 1 - size))\\n                {\\n                    string str1 = rev.substr(len-size);\\n                    if(mp.count(str1))\\n                    {\\n                        res.push_back({i, mp[str1]});\\n                    }\\n                }\\n                \\n                \\n                // case 4\\n                if(isPalin(rev, size, len - 1))\\n                {\\n                    string str2 = rev.substr(0, size);\\n                    \\n                    if(mp.count(str2))\\n                    {\\n                        res.push_back({mp[str2], i});\\n                    }\\n                }\\n            }\\n                \\n        }\\n        \\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585651,
                "title": "unorderd-map-c-solution",
                "content": "Here is my approach for the problem\\nthe intuation and approach explained:\\nto make the string palindrome we may add substring from the start to position i reversed at the end or add substring from end to position j at the start\\nso i have 2 map saving the string reversed and normal\\nif we have a closer look, when we add x elements at the end the we sure that the first x element match with the last x element since the substring that we will add will be the first x elements reversed , so we check from postion x + 1 to size - 1 to see if the string will be palindrome\\nthe same idea works when we add substring to the start we only need to check from index 0 to index x - 1 and see if its palindrome.\\nwhen it is a palindrome i add the pair into a set to avoid any repetaing pairs \\nanother point is we have to use unordered map not a normal map to do the operation in constat time \\nthe complexity will be O(N * M^2) where M is the max size of the string.\\n```\\nclass Solution {\\n    bool checkPal(string &str , int st , int ed){\\n        int i = st , j = ed;\\n        while(i < j){\\n            if(str[i] != str[j]){\\n                return 0;\\n            }\\n            i++,j--;\\n        }\\n        return 1;\\n    }\\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        int n = words.size();\\n        unordered_map<string , int> mp;\\n        unordered_map<string , int> mp2;\\n        for(int i = 0 ; i < n ; i++){\\n            reverse(words[i].begin() , words[i].end());\\n            mp[words[i]] = i;\\n            reverse(words[i].begin() , words[i].end());\\n            mp2[words[i]] = i; \\n        }\\n        \\n        vector<vector<int>> ans;\\n        set<vector<int>> st;\\n        vector<int>temp(2);\\n        if(mp.find(\"\") != mp.end()){\\n            int id = mp[\"\"];\\n            for(int i = 0 ; i < n ;i++){\\n                if(i == id){\\n                    continue;\\n                }\\n                if(checkPal(words[i] , 0 , words[i].size() - 1) ){\\n                    temp[0] = id;\\n                    temp[1] = i;\\n                    st.insert(temp);\\n                    temp[0] = i;\\n                    temp[1] = id;\\n                    st.insert(temp);\\n                }\\n            }\\n        }\\n        for(int i = 0 ; i < n ; i++){\\n            if(words[i] == \"\"){\\n                continue;\\n            }\\n            string need = \"\";\\n            for(int j = 0 ; j < words[i].size() ; j++){\\n                need += words[i][j];\\n                if(mp.find(need) != mp.end() && mp[need] != i && checkPal(words[i], j + 1 , words[i].size() - 1)){\\n                    temp[0] = i;\\n                    temp[1] = mp[need];\\n                     st.insert(temp);\\n                }\\n            }\\n            need = \"\";\\n            for(int j = words[i].size() - 1 ; j >= 0 ; j--){\\n                need += words[i][j];\\n                if(mp2.find(need) != mp2.end() && mp2[need] != i && checkPal(words[i] , 0 , j - 1)){\\n                    temp[0] = mp2[need];\\n                    temp[1] = i;\\n                    st.insert(temp);\\n                }\\n            \\n            }\\n        }\\n        for(auto x : st){\\n            ans.push_back(x);\\n        }\\n        //sort(ans.begin() , ans.end());\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool checkPal(string &str , int st , int ed){\\n        int i = st , j = ed;\\n        while(i < j){\\n            if(str[i] != str[j]){\\n                return 0;\\n            }\\n            i++,j--;\\n        }\\n        return 1;\\n    }\\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        int n = words.size();\\n        unordered_map<string , int> mp;\\n        unordered_map<string , int> mp2;\\n        for(int i = 0 ; i < n ; i++){\\n            reverse(words[i].begin() , words[i].end());\\n            mp[words[i]] = i;\\n            reverse(words[i].begin() , words[i].end());\\n            mp2[words[i]] = i; \\n        }\\n        \\n        vector<vector<int>> ans;\\n        set<vector<int>> st;\\n        vector<int>temp(2);\\n        if(mp.find(\"\") != mp.end()){\\n            int id = mp[\"\"];\\n            for(int i = 0 ; i < n ;i++){\\n                if(i == id){\\n                    continue;\\n                }\\n                if(checkPal(words[i] , 0 , words[i].size() - 1) ){\\n                    temp[0] = id;\\n                    temp[1] = i;\\n                    st.insert(temp);\\n                    temp[0] = i;\\n                    temp[1] = id;\\n                    st.insert(temp);\\n                }\\n            }\\n        }\\n        for(int i = 0 ; i < n ; i++){\\n            if(words[i] == \"\"){\\n                continue;\\n            }\\n            string need = \"\";\\n            for(int j = 0 ; j < words[i].size() ; j++){\\n                need += words[i][j];\\n                if(mp.find(need) != mp.end() && mp[need] != i && checkPal(words[i], j + 1 , words[i].size() - 1)){\\n                    temp[0] = i;\\n                    temp[1] = mp[need];\\n                     st.insert(temp);\\n                }\\n            }\\n            need = \"\";\\n            for(int j = words[i].size() - 1 ; j >= 0 ; j--){\\n                need += words[i][j];\\n                if(mp2.find(need) != mp2.end() && mp2[need] != i && checkPal(words[i] , 0 , j - 1)){\\n                    temp[0] = mp2[need];\\n                    temp[1] = i;\\n                    st.insert(temp);\\n                }\\n            \\n            }\\n        }\\n        for(auto x : st){\\n            ans.push_back(x);\\n        }\\n        //sort(ans.begin() , ans.end());\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1779474,
                "title": "c-trie-traversal",
                "content": "- construct a trie with reversed words. `ab` -> `ba` \\n- traverse each word in trie\\n\\t- if we find a word ending before end of current word, then check if rest of the word is palindrome\\n\\t\\t- if searching for `ab` and matched `a` in trie so far, check if `b` is palindrome\\n\\t- if we matched the whole word, we should look for every suffix under the ending node and check if they are palindrome\\n\\n```\\nclass Solution {\\n    struct Trie\\n    {\\n      std::vector<std::vector<int>> trie;\\n      std::vector<int> index;\\n      \\n      Trie()\\n      {\\n        trie.push_back(std::vector<int>(26));\\n        index.push_back(-1);\\n      }\\n      \\n      void insert(const std::string& str, int idx)\\n      {\\n        int node = 0;\\n        for(char c: str)\\n        {\\n          if(trie[node][c-\\'a\\']==0)\\n          {\\n            trie[node][c-\\'a\\'] = trie.size();\\n            trie.push_back(std::vector<int>(26));\\n            index.push_back(-1);\\n          }\\n          node = trie[node][c-\\'a\\'];\\n        }\\n        index[node] = idx;\\n      }\\n      \\n      bool is_palindrome(const std::string& str, int lo, int hi)\\n      {\\n        while(lo<hi)\\n        {\\n          if(str[lo]!=str[hi])\\n            return false;\\n          ++lo;\\n          --hi;\\n        }\\n        return true;\\n      }\\n      \\n      void dfs(int node, std::vector<int>& result, std::string& current)\\n      {\\n        if(index[node]!=-1 && is_palindrome(current, 0, int(current.size())-1))\\n        {\\n          result.push_back(index[node]);\\n        }\\n        \\n        for(int i=0; i < trie[node].size(); ++i)\\n        {\\n          if(trie[node][i]!=0)\\n          {\\n            current.push_back(\\'a\\'+i);\\n            dfs(trie[node][i], result, current);\\n            current.pop_back();\\n          }\\n        }\\n      }\\n      \\n      std::vector<int> find_all(const std::string& str)\\n      {\\n        std::vector<int> result;\\n        \\n        int node = 0;\\n        for(int i=0; i < str.size(); ++i)\\n        {\\n          // assume str is \"ab\" and we found \"a\" so far\\n          // then check if the rest of str(\"b\") is palindrome\\n          if(index[node]!=-1 && is_palindrome(str, i, int(str.size())-1))\\n          {\\n            result.push_back(index[node]);\\n          }\\n          \\n          char c = str[i];\\n          if(trie[node][c-\\'a\\']==0)\\n            return result;\\n          \\n          node = trie[node][c-\\'a\\'];\\n        }\\n        \\n        // we fully matched str in trie. now search this node recursively to find palindromes underneath\\n        // ab ...... ba => any palindrome in between will result palindrome in overall\\n        std::string current;\\n        dfs(node, result, current);\\n        return result;\\n      }\\n    };\\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n\\n      Trie reverse;\\n      for(int i=0; i < words.size(); ++i)\\n      {\\n        auto word = words[i];\\n        std::reverse(word.begin(), word.end());\\n        reverse.insert(word, i);\\n      }\\n      \\n      std::vector<std::vector<int>> result;\\n      for(int i=0; i < words.size(); ++i)\\n      { \\n        auto indexes = reverse.find_all(words[i]);\\n        for(int index: indexes)\\n        {\\n          if(index!=i)\\n          {\\n            result.push_back({i, index});\\n          }\\n        }\\n      }\\n      return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    struct Trie\\n    {\\n      std::vector<std::vector<int>> trie;\\n      std::vector<int> index;\\n      \\n      Trie()\\n      {\\n        trie.push_back(std::vector<int>(26));\\n        index.push_back(-1);\\n      }\\n      \\n      void insert(const std::string& str, int idx)\\n      {\\n        int node = 0;\\n        for(char c: str)\\n        {\\n          if(trie[node][c-\\'a\\']==0)\\n          {\\n            trie[node][c-\\'a\\'] = trie.size();\\n            trie.push_back(std::vector<int>(26));\\n            index.push_back(-1);\\n          }\\n          node = trie[node][c-\\'a\\'];\\n        }\\n        index[node] = idx;\\n      }\\n      \\n      bool is_palindrome(const std::string& str, int lo, int hi)\\n      {\\n        while(lo<hi)\\n        {\\n          if(str[lo]!=str[hi])\\n            return false;\\n          ++lo;\\n          --hi;\\n        }\\n        return true;\\n      }\\n      \\n      void dfs(int node, std::vector<int>& result, std::string& current)\\n      {\\n        if(index[node]!=-1 && is_palindrome(current, 0, int(current.size())-1))\\n        {\\n          result.push_back(index[node]);\\n        }\\n        \\n        for(int i=0; i < trie[node].size(); ++i)\\n        {\\n          if(trie[node][i]!=0)\\n          {\\n            current.push_back(\\'a\\'+i);\\n            dfs(trie[node][i], result, current);\\n            current.pop_back();\\n          }\\n        }\\n      }\\n      \\n      std::vector<int> find_all(const std::string& str)\\n      {\\n        std::vector<int> result;\\n        \\n        int node = 0;\\n        for(int i=0; i < str.size(); ++i)\\n        {\\n          // assume str is \"ab\" and we found \"a\" so far\\n          // then check if the rest of str(\"b\") is palindrome\\n          if(index[node]!=-1 && is_palindrome(str, i, int(str.size())-1))\\n          {\\n            result.push_back(index[node]);\\n          }\\n          \\n          char c = str[i];\\n          if(trie[node][c-\\'a\\']==0)\\n            return result;\\n          \\n          node = trie[node][c-\\'a\\'];\\n        }\\n        \\n        // we fully matched str in trie. now search this node recursively to find palindromes underneath\\n        // ab ...... ba => any palindrome in between will result palindrome in overall\\n        std::string current;\\n        dfs(node, result, current);\\n        return result;\\n      }\\n    };\\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n\\n      Trie reverse;\\n      for(int i=0; i < words.size(); ++i)\\n      {\\n        auto word = words[i];\\n        std::reverse(word.begin(), word.end());\\n        reverse.insert(word, i);\\n      }\\n      \\n      std::vector<std::vector<int>> result;\\n      for(int i=0; i < words.size(); ++i)\\n      { \\n        auto indexes = reverse.find_all(words[i]);\\n        for(int index: indexes)\\n        {\\n          if(index!=i)\\n          {\\n            result.push_back({i, index});\\n          }\\n        }\\n      }\\n      return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1271294,
                "title": "python3-best-explanation",
                "content": "```\\n\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        \\n        def isPallindrome(word):\\n            return word==word[::-1]\\n        \\n        ans=[]\\n        dict={}\\n#make map for word with their respective index\\n        for idx,word in enumerate(words):\\n            dict[word]=idx\\n        \\n# if there is empty string in map then it will generate two pallindrome string\\n        if \"\" in dict:\\n            idx=dict[\"\"]\\n            for word in dict:\\n                if isPallindrome(word):\\n                    if dict[word]!=idx:\\n                        ans.append([dict[word],idx])\\n                        ans.append([idx,dict[word]])\\n        \\n# check if reverse is there in map\\n# strings like abc and cba\\n        for word in dict:\\n            if word[::-1] in dict:\\n                if dict[word]!=dict[word[::-1]]:\\n                    ans.append([dict[word],dict[word[::-1]]])\\n\\n# last case little bit tricky\\n# consider string which contain substring as pallindrome\\n# aade we can see aa is pallindrome we will split this string in two halves\\n# aa-de and then search for reverse of de that is ed in map \\n# if ed is there we can merge like edaade to get pallindrome\\n# similarly we can find if after splitting right part is pallindrome \\n# we will search for reverse of right part in map\\n# abcd splliting into ab-cd we will search for ba in map\\n# if its there we can form abcdba pallindrome string\\n        for word in dict:\\n            for i in range(1,len(word)):\\n                prefix=word[:i]\\n                suffix=word[i:]\\n                \\n                if isPallindrome(prefix):\\n                    if suffix[::-1] in dict:\\n                        ans.append([dict[suffix[::-1]],dict[word]])\\n                if isPallindrome(suffix):\\n                    if prefix[::-1] in dict:\\n                        ans.append([dict[word],dict[prefix[::-1]]])\\n        return ans",
                "solutionTags": [],
                "code": "class Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        \\n        def isPallindrome(word):\\n            return word==word[::-1]\\n        \\n        ans=[]\\n        dict={}",
                "codeTag": "Java"
            },
            {
                "id": 1270025,
                "title": "java-intuitive-code-with-some-explanation-o-n-m-2",
                "content": "The time complexity for this solution is O(N M^2). \\ne.x` N = words.length` and `M = words[i].length`. In the last for loop there is following structure\\n```\\nFor word in words (this is O(n))\\n\\tFor character in word (this is O(m) -> total O(nm))\\n\\t\\treverse (this is O(m) -> total O(nm^2))\\n\\t\\tisPalindrome (this is O(m) -> total O(nm^2))\\n```\\n\\n```\\n//Implementation\\nclass Solution {\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        //In future, we need to know the index of the word. For this purpose, we create a map\\n        Map<String, Integer> map = new HashMap<>();\\n        for (int i = 0; i < words.length; i++) map.put(words[i], i);\\n\\n\\t\\t//Case 1 - Empty string case\\n        /*\\n\\t\\t\\tIf there is an empty string in the array(e.g \"\") in the array that means that every words[i] that is palindrome could be paired with an empty \\n\\t\\t\\tstring. e.g if there are words[1] = \"aba\" and word[5] = \"\" we can make pairs of it like this [1, 5] and [5, 1], \\n\\t\\t\\tbecause \"aba\" + \"\" = \"aba\" and \"\" + \"aba\" = \"aba\" as well. \\n\\t\\t*/\\n        if (map.containsKey(\"\")) {\\n            Integer emptyStrIndex = map.get(\"\");\\n            for (int i = 0; i < words.length; i++) {\\n                if (emptyStrIndex != i && isPalindrome(words[i])) {\\n                    ans.add(Arrays.asList(i, emptyStrIndex));\\n                    ans.add(Arrays.asList(emptyStrIndex, i));\\n                }\\n            }\\n        }\\n\\n        //Case 2 - Reflection Case\\n\\t\\t/*\\n\\t\\t\\tHere we need to check for reflection case. e.g if words[i] == \"abc\" and there are \"cba\" available somewhere in the array it means that \\n\\t\\t\\twe can form a palindrome. Same happens when words[i] == \"cba\" it will check for \"abc\"\\n\\t\\t*/\\n        for (int i = 0; i < words.length; i++) {\\n            String reversed = new StringBuilder(words[i]).reverse().toString();\\n            if (map.containsKey(reversed)) {\\n                int reversedIndex = map.get(reversed);\\n                if (reversedIndex != i) {\\n                    ans.add(Arrays.asList(i, reversedIndex));\\n                }\\n            }\\n        }\\n\\n        //Case 3 - Partition Case\\n\\t\\t/*\\n\\t\\tThis case is trickier. Basically what we are doing here is that we are checking every possible substring of words[i] \\n\\t\\tif contains palindrome string. If it does the reversed remaining part(out of substring) should be found somewhere \\n\\t\\tin the array to form a palindrome using word[i]. \\n\\t\\te.g words[i] = \"abade\" we can partition it with these chunks \\n\\t\\tleft = \"a\" right = \"bade\"\\n\\t\\tleft = \"ab\" right = \"ade\"\\n\\t\\tleft = \"aba\" right = \"de\"\\n\\t\\tleft = \"abad\" right = \"e\"\\n\\t\\tSo here the third case left = \"aba\" which is a palindrome. The remaining part is \"de\"(Reversed is \"ed\"). \\n\\t\\tTherefore if somewhere in the array there is string \"ed\" it means that we can form palindrome by adding \"ed\" + \"aba[de]\" = \"edabade\"\\n\\t\\tWe need to check it for both left and right parts\\n\\t\\t*/\\n        for (int i = 0; i < words.length; i++) {\\n            String word = words[i];\\n            for (int j = 1; j < word.length(); j++) {\\n                String left = word.substring(0, j);\\n                String right = word.substring(j);\\n\\n                if(isPalindrome(left)){\\n                    Integer foundIndex = map.get(new StringBuilder(right).reverse().toString());\\n                    if(foundIndex != null){\\n                        ans.add(Arrays.asList(foundIndex, i));\\n                    }\\n                }\\n\\n                if(isPalindrome(right)){\\n                    Integer foundIndex = map.get(new StringBuilder(left).reverse().toString());\\n                    if(foundIndex != null){\\n                        ans.add(Arrays.asList(i, foundIndex));\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    private boolean isPalindrome(String str) {\\n        int i = 0, j = str.length() - 1;\\n        while (i <= j) if (str.charAt(i++) != str.charAt(j--)) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nFor word in words (this is O(n))\\n\\tFor character in word (this is O(m) -> total O(nm))\\n\\t\\treverse (this is O(m) -> total O(nm^2))\\n\\t\\tisPalindrome (this is O(m) -> total O(nm^2))\\n```\n```\\n//Implementation\\nclass Solution {\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        //In future, we need to know the index of the word. For this purpose, we create a map\\n        Map<String, Integer> map = new HashMap<>();\\n        for (int i = 0; i < words.length; i++) map.put(words[i], i);\\n\\n\\t\\t//Case 1 - Empty string case\\n        /*\\n\\t\\t\\tIf there is an empty string in the array(e.g \"\") in the array that means that every words[i] that is palindrome could be paired with an empty \\n\\t\\t\\tstring. e.g if there are words[1] = \"aba\" and word[5] = \"\" we can make pairs of it like this [1, 5] and [5, 1], \\n\\t\\t\\tbecause \"aba\" + \"\" = \"aba\" and \"\" + \"aba\" = \"aba\" as well. \\n\\t\\t*/\\n        if (map.containsKey(\"\")) {\\n            Integer emptyStrIndex = map.get(\"\");\\n            for (int i = 0; i < words.length; i++) {\\n                if (emptyStrIndex != i && isPalindrome(words[i])) {\\n                    ans.add(Arrays.asList(i, emptyStrIndex));\\n                    ans.add(Arrays.asList(emptyStrIndex, i));\\n                }\\n            }\\n        }\\n\\n        //Case 2 - Reflection Case\\n\\t\\t/*\\n\\t\\t\\tHere we need to check for reflection case. e.g if words[i] == \"abc\" and there are \"cba\" available somewhere in the array it means that \\n\\t\\t\\twe can form a palindrome. Same happens when words[i] == \"cba\" it will check for \"abc\"\\n\\t\\t*/\\n        for (int i = 0; i < words.length; i++) {\\n            String reversed = new StringBuilder(words[i]).reverse().toString();\\n            if (map.containsKey(reversed)) {\\n                int reversedIndex = map.get(reversed);\\n                if (reversedIndex != i) {\\n                    ans.add(Arrays.asList(i, reversedIndex));\\n                }\\n            }\\n        }\\n\\n        //Case 3 - Partition Case\\n\\t\\t/*\\n\\t\\tThis case is trickier. Basically what we are doing here is that we are checking every possible substring of words[i] \\n\\t\\tif contains palindrome string. If it does the reversed remaining part(out of substring) should be found somewhere \\n\\t\\tin the array to form a palindrome using word[i]. \\n\\t\\te.g words[i] = \"abade\" we can partition it with these chunks \\n\\t\\tleft = \"a\" right = \"bade\"\\n\\t\\tleft = \"ab\" right = \"ade\"\\n\\t\\tleft = \"aba\" right = \"de\"\\n\\t\\tleft = \"abad\" right = \"e\"\\n\\t\\tSo here the third case left = \"aba\" which is a palindrome. The remaining part is \"de\"(Reversed is \"ed\"). \\n\\t\\tTherefore if somewhere in the array there is string \"ed\" it means that we can form palindrome by adding \"ed\" + \"aba[de]\" = \"edabade\"\\n\\t\\tWe need to check it for both left and right parts\\n\\t\\t*/\\n        for (int i = 0; i < words.length; i++) {\\n            String word = words[i];\\n            for (int j = 1; j < word.length(); j++) {\\n                String left = word.substring(0, j);\\n                String right = word.substring(j);\\n\\n                if(isPalindrome(left)){\\n                    Integer foundIndex = map.get(new StringBuilder(right).reverse().toString());\\n                    if(foundIndex != null){\\n                        ans.add(Arrays.asList(foundIndex, i));\\n                    }\\n                }\\n\\n                if(isPalindrome(right)){\\n                    Integer foundIndex = map.get(new StringBuilder(left).reverse().toString());\\n                    if(foundIndex != null){\\n                        ans.add(Arrays.asList(i, foundIndex));\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    private boolean isPalindrome(String str) {\\n        int i = 0, j = str.length() - 1;\\n        while (i <= j) if (str.charAt(i++) != str.charAt(j--)) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 559259,
                "title": "java-ac-brute-force-solution-with-optimisation-to-avoid-creating-a-new-string",
                "content": "The idea is to not create a new string for doing the Palindrome check and instead just index into the strings correctly.\\nWithout this, the checker throws a TLE.\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        int n = words.length;\\n        List<List<Integer>> output = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                if (isPalindrome(words[i], words[j])) {\\n                    output.add(Arrays.asList(i, j));\\n                }\\n                if (isPalindrome(words[j], words[i])) {\\n                    output.add(Arrays.asList(j, i));\\n                }\\n            }\\n        }\\n        return output;\\n    }\\n    \\n    private boolean isPalindrome(String word1, String word2) {\\n        int start = 0;\\n        int l1 = word1.length();\\n        int l2 = word2.length();\\n        int end = l1 + l2 - 1;\\n\\t\\t\\n        while (start < end) {\\n            char ch1 = start < l1 ? word1.charAt(start) : word2.charAt(start - l1);\\n            char ch2 = end >= l1 ? word2.charAt(end - l1) : word1.charAt(end);\\n            if (ch1 != ch2) {\\n                return false;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        int n = words.length;\\n        List<List<Integer>> output = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                if (isPalindrome(words[i], words[j])) {\\n                    output.add(Arrays.asList(i, j));\\n                }\\n                if (isPalindrome(words[j], words[i])) {\\n                    output.add(Arrays.asList(j, i));\\n                }\\n            }\\n        }\\n        return output;\\n    }\\n    \\n    private boolean isPalindrome(String word1, String word2) {\\n        int start = 0;\\n        int l1 = word1.length();\\n        int l2 = word2.length();\\n        int end = l1 + l2 - 1;\\n\\t\\t\\n        while (start < end) {\\n            char ch1 = start < l1 ? word1.charAt(start) : word2.charAt(start - l1);\\n            char ch2 = end >= l1 ? word2.charAt(end - l1) : word1.charAt(end);\\n            if (ch1 != ch2) {\\n                return false;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244897,
                "title": "336-time-95-65-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe algorithm uses a dictionary to store the reverse of the words and their indices, and then iterates through each word and checks for palindrome pairs using substrings. It first checks for empty string as a special case, and then iterates through all possible substrings of each word to check for palindrome pairs. The resulting pairs are appended to a list and returned at the end.\\n\\n# Complexity\\n- Time complexity:\\n95.65%\\n\\n- Space complexity:\\n45.1%\\n\\n# Code\\n```\\nclass Solution:\\n  def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n    ans = []   # initialize a list to store the palindrome pairs\\n    dict = {word[::-1]: i for i, word in enumerate(words)}  # create a dictionary to store the reverse of words and their indices\\n\\n    for i, word in enumerate(words):  # iterate through the words and their indices\\n      if \"\" in dict and dict[\"\"] != i and word == word[::-1]:  # check if empty string is in the dictionary and the current word is palindrome\\n        ans.append([i, dict[\"\"]])  # append the indices to the ans list\\n\\n      for j in range(1, len(word) + 1):  # iterate through the word characters\\n        l = word[:j]  # get the left substring\\n        r = word[j:]  # get the right substring\\n        if l in dict and dict[l] != i and r == r[::-1]:  # check if left substring is in the dictionary and the right substring is palindrome\\n          ans.append([i, dict[l]])  # append the indices to the ans list\\n        if r in dict and dict[r] != i and l == l[::-1]:  # check if right substring is in the dictionary and the left substring is palindrome\\n          ans.append([dict[r], i])  # append the indices to the ans list\\n\\n    return ans  # return the ans list\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Trie"
                ],
                "code": "```\\nclass Solution:\\n  def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n    ans = []   # initialize a list to store the palindrome pairs\\n    dict = {word[::-1]: i for i, word in enumerate(words)}  # create a dictionary to store the reverse of words and their indices\\n\\n    for i, word in enumerate(words):  # iterate through the words and their indices\\n      if \"\" in dict and dict[\"\"] != i and word == word[::-1]:  # check if empty string is in the dictionary and the current word is palindrome\\n        ans.append([i, dict[\"\"]])  # append the indices to the ans list\\n\\n      for j in range(1, len(word) + 1):  # iterate through the word characters\\n        l = word[:j]  # get the left substring\\n        r = word[j:]  # get the right substring\\n        if l in dict and dict[l] != i and r == r[::-1]:  # check if left substring is in the dictionary and the right substring is palindrome\\n          ans.append([i, dict[l]])  # append the indices to the ans list\\n        if r in dict and dict[r] != i and l == l[::-1]:  # check if right substring is in the dictionary and the left substring is palindrome\\n          ans.append([dict[r], i])  # append the indices to the ans list\\n\\n    return ans  # return the ans list\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2586386,
                "title": "go-golang-map-solution",
                "content": "```\\nfunc palindromePairs(words []string) [][]int {\\n    dict := map[string]int{}\\n    \\n    for i, word := range words {\\n        dict[reverse(word)] = i\\n    }\\n    \\n    result := map[[2]int]bool{}\\n    \\n    for i, word := range words {\\n        for j := 0; j <= len(word); j++ {\\n            now := word[:j]\\n            \\n            if k, ok := dict[now]; ok && i != k && isPalindrome(word[j:]) {\\n                result[[2]int{i, k}] = true\\n            }\\n            \\n            now = word[len(word)-j:]\\n            \\n            if k, ok := dict[now]; ok && i != k && isPalindrome(word[:len(word)-j]) {\\n                result[[2]int{k, i}] = true\\n            }\\n        }\\n    }\\n    \\n    ans := make([][]int, 0, len(result))\\n    \\n    for pair := range result {\\n        now := pair\\n        ans = append(ans, now[:])\\n    }\\n    \\n    return ans\\n}\\n\\nfunc isPalindrome(word string) bool {\\n    for l, r := 0, len(word)-1; l < r; l, r = l+1, r-1 {\\n        if word[l] != word[r] {\\n            return false\\n        }\\n    }\\n    \\n    return true\\n}\\n\\nfunc reverse(word string) string {\\n    str := []byte(word)\\n    \\n    for l, r := 0, len(word)-1; l < r; l, r = l+1, r-1 {\\n        str[l], str[r] = str[r], str[l]\\n    }\\n    \\n    return string(str)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc palindromePairs(words []string) [][]int {\\n    dict := map[string]int{}\\n    \\n    for i, word := range words {\\n        dict[reverse(word)] = i\\n    }\\n    \\n    result := map[[2]int]bool{}\\n    \\n    for i, word := range words {\\n        for j := 0; j <= len(word); j++ {\\n            now := word[:j]\\n            \\n            if k, ok := dict[now]; ok && i != k && isPalindrome(word[j:]) {\\n                result[[2]int{i, k}] = true\\n            }\\n            \\n            now = word[len(word)-j:]\\n            \\n            if k, ok := dict[now]; ok && i != k && isPalindrome(word[:len(word)-j]) {\\n                result[[2]int{k, i}] = true\\n            }\\n        }\\n    }\\n    \\n    ans := make([][]int, 0, len(result))\\n    \\n    for pair := range result {\\n        now := pair\\n        ans = append(ans, now[:])\\n    }\\n    \\n    return ans\\n}\\n\\nfunc isPalindrome(word string) bool {\\n    for l, r := 0, len(word)-1; l < r; l, r = l+1, r-1 {\\n        if word[l] != word[r] {\\n            return false\\n        }\\n    }\\n    \\n    return true\\n}\\n\\nfunc reverse(word string) string {\\n    str := []byte(word)\\n    \\n    for l, r := 0, len(word)-1; l < r; l, r = l+1, r-1 {\\n        str[l], str[r] = str[r], str[l]\\n    }\\n    \\n    return string(str)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2251917,
                "title": "java-trie-solution-with-whiteboard-notes",
                "content": "**Before jumping to solution:**\\nHere is my Java solution with whiteboard notes for future reference, I apologize for bad handwriting, `I made it for myself, but later thought, they might help someone to quickly revise this problem, so sharing it here too.` \\n\\nPlease note that, **below in image**:\\n1. `palind`  stands for palindrome.\\n2. [] brackets are for `palins` list.\\n3. () brackets are for `pos`.\\n\\nRefer to Trie class in code for palins and pos.\\n\\n**Tip**: The problem is very hard, a dry run will help understand it faster.\\n\\n![image](https://assets.leetcode.com/users/images/90b65098-bec2-46bf-a2a9-9aa82b370c62_1657218501.9295862.jpeg)\\n\\n**Important:** Thanks to **Allenlipeng** for sharing this, I can\\'t share his blog on this problem, becuase doing that will hide this post from everyone.\\nBut Google search this: `Palindrome Pairs allenlipeng47` and you\\'ll find the blog.\\n\\n**Code:** This is same as Allen\\'s code.\\n```\\nclass Solution {\\n    public static class Trie {\\n    int pos;\\n    Trie[] nodes;   // consider xyxabc. if current trie is \\'a\\'. Then a.nodes has information. It means string after a is palindrome\\n    List<Integer> palins;\\n    public Trie() {\\n        pos = -1;\\n        nodes = new Trie[26];\\n        palins = new ArrayList<>();\\n    }\\n}\\n\\npublic static void add(Trie root, String word, int pos) {\\n    for (int i = word.length() - 1; i >= 0; i--) {\\n        char ch = word.charAt(i);\\n        if (isPalindrome(word, 0, i)) { // check if substring(0, i) is palindrome.\\n            root.palins.add(pos);\\n        }\\n        if (root.nodes[ch - \\'a\\'] == null) {\\n            root.nodes[ch - \\'a\\'] = new Trie();\\n        }\\n        root = root.nodes[ch - \\'a\\'];\\n    }\\n    root.pos = pos; // if it is xyxcba. Until now, the node should be at x.\\n    root.palins.add(pos);\\n}\\n\\npublic static void search(Trie root, String[] words, int i, List<List<Integer>> ans) {\\n    int len = words[i].length();\\n    for (int j = 0; j < len && root != null; j++) {\\n        if (root.pos >= 0 && i != root.pos && isPalindrome(words[i], j, len - 1)) {\\n            ans.add(Arrays.asList(new Integer[] {i, root.pos}));\\n        }\\n        char ch = words[i].charAt(j);\\n        root = root.nodes[ch - \\'a\\'];\\n    }\\n    if (root != null && root.palins.size() > 0) { // assume \\'xyxabc\\' is in trie, now try \\'cba\\'\\n        for (int j : root.palins) {\\n            if (j != i) {\\n                ans.add(Arrays.asList(new Integer[] {i, j}));\\n            }\\n        }\\n    }\\n}\\n\\npublic static List<List<Integer>> palindromePairs(String[] words) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    Trie trie = new Trie();\\n    for (int i = 0; i < words.length; i++) {\\n        add(trie, words[i], i);\\n    }\\n    for (int i = 0; i < words.length; i++) {\\n        search(trie, words, i, ans);\\n    }\\n    return ans;\\n}\\n\\npublic static boolean isPalindrome(String str, int i, int j) {\\n    while (i < j) {\\n        if (str.charAt(i++) != str.charAt(j--)) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    public static class Trie {\\n    int pos;\\n    Trie[] nodes;   // consider xyxabc. if current trie is \\'a\\'. Then a.nodes has information. It means string after a is palindrome\\n    List<Integer> palins;\\n    public Trie() {\\n        pos = -1;\\n        nodes = new Trie[26];\\n        palins = new ArrayList<>();\\n    }\\n}\\n\\npublic static void add(Trie root, String word, int pos) {\\n    for (int i = word.length() - 1; i >= 0; i--) {\\n        char ch = word.charAt(i);\\n        if (isPalindrome(word, 0, i)) { // check if substring(0, i) is palindrome.\\n            root.palins.add(pos);\\n        }\\n        if (root.nodes[ch - \\'a\\'] == null) {\\n            root.nodes[ch - \\'a\\'] = new Trie();\\n        }\\n        root = root.nodes[ch - \\'a\\'];\\n    }\\n    root.pos = pos; // if it is xyxcba. Until now, the node should be at x.\\n    root.palins.add(pos);\\n}\\n\\npublic static void search(Trie root, String[] words, int i, List<List<Integer>> ans) {\\n    int len = words[i].length();\\n    for (int j = 0; j < len && root != null; j++) {\\n        if (root.pos >= 0 && i != root.pos && isPalindrome(words[i], j, len - 1)) {\\n            ans.add(Arrays.asList(new Integer[] {i, root.pos}));\\n        }\\n        char ch = words[i].charAt(j);\\n        root = root.nodes[ch - \\'a\\'];\\n    }\\n    if (root != null && root.palins.size() > 0) { // assume \\'xyxabc\\' is in trie, now try \\'cba\\'\\n        for (int j : root.palins) {\\n            if (j != i) {\\n                ans.add(Arrays.asList(new Integer[] {i, j}));\\n            }\\n        }\\n    }\\n}\\n\\npublic static List<List<Integer>> palindromePairs(String[] words) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    Trie trie = new Trie();\\n    for (int i = 0; i < words.length; i++) {\\n        add(trie, words[i], i);\\n    }\\n    for (int i = 0; i < words.length; i++) {\\n        search(trie, words, i, ans);\\n    }\\n    return ans;\\n}\\n\\npublic static boolean isPalindrome(String str, int i, int j) {\\n    while (i < j) {\\n        if (str.charAt(i++) != str.charAt(j--)) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1270363,
                "title": "rust-32ms-100-rt-hashmap",
                "content": "I hope you guys love Rust\\'s iterators as much as I do... :)\\n\\n```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn palindrome_pairs(words: Vec<String>) -> Vec<Vec<i32>> {\\n        let word_map: HashMap<_, _> = words\\n            .iter()\\n            .enumerate()\\n            .map(|(i, w)| (w.as_str(), i))\\n            .collect();\\n\\n        words.iter().enumerate().fold(vec![], |mut acc, (i, w)| {\\n            let n = w.len();\\n            let rev: String = w.chars().rev().collect();\\n            let from_right = (0..n)\\n                .filter(|&k| w[..n - k].chars().eq(w[..n - k].chars().rev()))\\n                .filter_map(|k| word_map.get(&rev[..k]).map(|&j| (j, i)));\\n\\n            (0..=n)\\n                .filter(|&k| w[k..].chars().eq(w[k..].chars().rev()))\\n                .filter_map(|k| word_map.get(&rev[n - k..]).map(|&j| (i, j)))\\n                .chain(from_right)\\n                .filter(|&(i, j)| i != j)\\n                .for_each(|(i, j)| acc.push(vec![i as _, j as _]));\\n\\n            acc\\n        })\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn palindrome_pairs(words: Vec<String>) -> Vec<Vec<i32>> {\\n        let word_map: HashMap<_, _> = words\\n            .iter()\\n            .enumerate()\\n            .map(|(i, w)| (w.as_str(), i))\\n            .collect();\\n\\n        words.iter().enumerate().fold(vec![], |mut acc, (i, w)| {\\n            let n = w.len();\\n            let rev: String = w.chars().rev().collect();\\n            let from_right = (0..n)\\n                .filter(|&k| w[..n - k].chars().eq(w[..n - k].chars().rev()))\\n                .filter_map(|k| word_map.get(&rev[..k]).map(|&j| (j, i)));\\n\\n            (0..=n)\\n                .filter(|&k| w[k..].chars().eq(w[k..].chars().rev()))\\n                .filter_map(|k| word_map.get(&rev[n - k..]).map(|&j| (i, j)))\\n                .chain(from_right)\\n                .filter(|&(i, j)| i != j)\\n                .for_each(|(i, j)| acc.push(vec![i as _, j as _]));\\n\\n            acc\\n        })\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 871532,
                "title": "java-hashmap-solution-explained",
                "content": "```\\n/*\\n    Thought process:\\n        The easiest pairs are simply reversed versions of each other\\n            Example: \\'abcd\\' + \\'dcba\\'\\n        Storing the reverse of input word will help us look up these\\n        easy pairs quickly. We also need to get the indexes fast to\\n        store pairs (i, j) in result. Let\\'s handle quick word lookups\\n        and index lookups with a single HashMap\\n        \\n        The key = reversedWord & value = index i\\n        \\n        Now we can check for easy pairs like so:\\n            String curr = word[i]\\n            if (wordMap.containsKey(curr))\\n                j is wordMap.get(curr)\\n                the pair is now (i, j)\\n        \\n        The next case is when two different words can be combined\\n            Example: \\'race\\' + \\'car\\'\\n        We can see that splitting \\'race\\' to \\'rac\\' and \\'e\\' works.\\n        \\'car\\' was reversed & stored in the wordMap as (\\'rac\\', idx)\\n        So the map does contain \\'rac\\' as a key. If \\'e\\' is a palindrome\\n        then we can combine \\'race\\' with \\'car\\'.\\n        \\n        We can check for these pairs like so:\\n            String curr = word[i]\\n            int wordLen = cufr.length();\\n            //Try all suffixes\\n            for j = 0 -> wordLen\\n                //Suffix \\'e\\' is palindrome\\n                if isPalindrome(curr, j, wordLen - 1)\\n                    //Check if remaining prefix \\'rac\\' exists in wordMap\\n                    String prefix = curr.substring(0, j)\\n                    if wordMap.containsKey(prefix)\\n                        addToResults(result, i, wordMap.get(prefix))\\n\\n\\n        The next case is when two different words can be combined\\n        but in a different order.\\n            Example: \\'nu\\' + \\'run\\'\\n        We can see that splitting \\'run\\' to \\'r\\' and \\'un\\' works.\\n        \\'nu\\' was reversed & stored in the wordMap as (\\'un\\', idx)\\n        So the map does contain \\'un\\' as a key. If \\'r\\' is a palindrome\\n        then we can combine \\'nu\\' with \\'run\\'. The main difference\\n        this time is we are removing from the start of a word like \\'run\\'\\n        and not from the end when we look at \\'race\\'\\n        \\n        We can check for these pairs simliarly as before like so:\\n            String curr = word[i]\\n            int wordLen = cufr.length();\\n            for (j = wordLen-1  ->  0\\n                //Prefix \\'r\\' is palindrome\\n                if isPalindrome(curr, 0, j) \\n                    //Check if remaining suffix \\'un\\' exists in wordMap\\n                    String suffix = curr.substring(j + 1)\\n                    if wordMap.containsKey(suffix)\\n                        addToResults(result, wordMap.get(suffix), i)\\n                \\n    \\n    These 3 Cases can be handled in a single loop like so:\\n        //Find palindrome pairs\\n        for i = 0 -> len\\n            String curr = words[i]\\n            Check Case 1: Have Reverse of curr\\n                updateResult\\n                \\n            Check Case 2: Removing prefix from curr\\n                updateResult\\n            \\n            Check Case 3: Removing suffix from curr\\n                updateResult\\n        //end for loop\\n        \\n        return result\\n*/\\n\\nclass Solution {\\n    public List<List<Integer>> palindromePairs(String[] words) {        \\n        //2D List for results\\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        //Map containing each key: reversed word, val: index\\n        Map<String, Integer> wordMap = new HashMap<>();\\n        int len = words.length;\\n        for (int i = 0; i < len; i++) {\\n            String reversed = new StringBuilder(words[i]).reverse().toString();\\n            wordMap.put(reversed, i);\\n        }\\n        \\n        //Find palindrome pairs\\n        for (int i = 0; i < len; i++) {\\n            String curr = words[i];\\n            int wordLen = curr.length();\\n            //Is there a reversed version?\\n            if (wordMap.containsKey(curr))\\n                addToResults(result, i, wordMap.get(curr));\\n\\n            //Check if curr has a reversed suffix in commin with another\\n            //Example: race & car\\n            for (int j = 0; j < wordLen; j++) {\\n                //Check if suffix is palindrome j -> len\\n                if (isPalindrome(curr, j, wordLen - 1)) {\\n                    //Check if remaining prefix 0 -> j-1 exists in wordMap\\n                    String prefix = curr.substring(0, j);\\n                    if (wordMap.containsKey(prefix))\\n                        addToResults(result, i, wordMap.get(prefix));\\n                }\\n            }\\n            \\n            //Check if curr has a reversed prefix in common with another\\n            //Example: run & nu\\n            for (int j = wordLen - 1; j >= 0; j--) {\\n                //Check if prefix is palindrome 0 -> j\\n                if (isPalindrome(curr, 0, j)) {\\n                    //Check if remaining suffix j+1 -> len exists in wordMap\\n                    String suffix = curr.substring(j + 1);\\n                    if (wordMap.containsKey(suffix))\\n                        addToResults(result, wordMap.get(suffix), i);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    //Check that substring of curr is a palindrome from start to end\\n    public boolean isPalindrome(String curr, int start, int end) {\\n        while (start < end) {\\n            if (curr.charAt(start) != curr.charAt(end))\\n                return false;\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n    \\n    //Add pair [i, j] to result if indexes are not the same\\n    public void addToResults(List<List<Integer>> result, int i, int j) {\\n        //Indices shoud be different\\n        if (i == j)\\n            return;\\n        \\n        result.add(Arrays.asList(i, j));\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<List<Integer>> palindromePairs(String[] words) {        \\n        //2D List for results\\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        //Map containing each key: reversed word, val: index\\n        Map<String, Integer> wordMap = new HashMap<>();\\n        int len = words.length;\\n        for (int i = 0; i < len; i++) {\\n            String reversed = new StringBuilder(words[i]).reverse().toString();\\n            wordMap.put(reversed, i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 376518,
                "title": "python-solution-with-illustrative-examples-for-the-code",
                "content": "idea: isolate the non-palindrome part (prefix/suffix) to match for getting a palindrome, if there is no palindrome part then search for the reverse of the entire word\\n```\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        if not words: return [[]]\\n        lookup = {w: i for i,w in enumerate(words)}   # swap key (index) and value (word)\\n        res = []\\n        for i, w in enumerate(words):\\n            for j in range(len(w)+1):\\n                pre, suf = w[:j], w[j:]   # pre(fix) and suf(fix)\\n                if pre==pre[::-1] and suf[::-1]!=w and suf[::-1] in lookup:\\n                    res.append([lookup[suf[::-1]], i])   # palindrome prefix e.g. \\'lls\\' and \\'s\\', \\'sssll\\' and \\'lls\\' in Example 1\\n                if suf==suf[::-1] and pre[::-1]!=w and pre[::-1] in lookup and j!=len(w):   # j==len(w) case is already checked above\\n                    res.append([i, lookup[pre[::-1]]])   # palindrome suffix e.g. \\'sll\\' and \\'s\\'\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        if not words: return [[]]\\n        lookup = {w: i for i,w in enumerate(words)}   # swap key (index) and value (word)\\n        res = []\\n        for i, w in enumerate(words):\\n            for j in range(len(w)+1):\\n                pre, suf = w[:j], w[j:]   # pre(fix) and suf(fix)\\n                if pre==pre[::-1] and suf[::-1]!=w and suf[::-1] in lookup:\\n                    res.append([lookup[suf[::-1]], i])   # palindrome prefix e.g. \\'lls\\' and \\'s\\', \\'sssll\\' and \\'lls\\' in Example 1\\n                if suf==suf[::-1] and pre[::-1]!=w and pre[::-1] in lookup and j!=len(w):   # j==len(w) case is already checked above\\n                    res.append([i, lookup[pre[::-1]]])   # palindrome suffix e.g. \\'sll\\' and \\'s\\'\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585539,
                "title": "javascript-code",
                "content": "```\\nvar palindromePairs = function(words) {\\n    let word_map = new Map(), ans = []\\n    for (let i = 0; i < words.length; i++)\\n        word_map.set(words[i], i)\\n    for (let i = 0; i < words.length; i++) {\\n        if (words[i] === \"\") {\\n            for (let j = 0; j < words.length; j++)\\n                if (is_Palindrome(words[j]) && j !== i)\\n                    ans.push([i, j], [j, i])\\n            continue\\n        }\\n        let reverse_str = words[i].split(\"\").reverse().join(\"\")\\n        let res = word_map.get(reverse_str)\\n        if (res !== undefined && res !== i)\\n            ans.push([i, res])\\n        for (let j = 1; j < reverse_str.length; j++) {\\n            if (is_Palindrome(reverse_str, 0, j - 1)) {\\n                let res = word_map.get(reverse_str.slice(j))\\n                if (res !== undefined)\\n                    ans.push([i, res])\\n            }\\n            if (is_Palindrome(reverse_str, j)) {\\n                let res = word_map.get(reverse_str.slice(0,j))\\n                if (res !== undefined)\\n                    ans.push([res, i])\\n            }\\n        }\\n    }\\n    return ans\\n};\\n\\n//check if a word is palindrome\\nconst is_Palindrome = (word, i=0, j=word.length-1) => {\\n    while (i < j)\\n        if (word[i++] !== word[j--]) return false\\n    return true\\n}",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar palindromePairs = function(words) {\\n    let word_map = new Map(), ans = []\\n    for (let i = 0; i < words.length; i++)\\n        word_map.set(words[i], i)\\n    for (let i = 0; i < words.length; i++) {\\n        if (words[i] === \"\") {\\n            for (let j = 0; j < words.length; j++)\\n                if (is_Palindrome(words[j]) && j !== i)\\n                    ans.push([i, j], [j, i])\\n            continue\\n        }\\n        let reverse_str = words[i].split(\"\").reverse().join(\"\")\\n        let res = word_map.get(reverse_str)\\n        if (res !== undefined && res !== i)\\n            ans.push([i, res])\\n        for (let j = 1; j < reverse_str.length; j++) {\\n            if (is_Palindrome(reverse_str, 0, j - 1)) {\\n                let res = word_map.get(reverse_str.slice(j))\\n                if (res !== undefined)\\n                    ans.push([i, res])\\n            }\\n            if (is_Palindrome(reverse_str, j)) {\\n                let res = word_map.get(reverse_str.slice(0,j))\\n                if (res !== undefined)\\n                    ans.push([res, i])\\n            }\\n        }\\n    }\\n    return ans\\n};\\n\\n//check if a word is palindrome\\nconst is_Palindrome = (word, i=0, j=word.length-1) => {\\n    while (i < j)\\n        if (word[i++] !== word[j--]) return false\\n    return true\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1777721,
                "title": "c-hashmap-solution-works-for-new-test-cases-space-99-fast-40",
                "content": "The approach shared by other hashmap solutions is correct. However, they fail to pass new test cases. The problem is in the way they are iterating over the string to generate `left` and `right` substring. Applying `substr` over the same word is slow and includes repetitive work. What we can do is push back first character of `right` to `left` and remove first character from `right`. This way we avoid generating substring using `substr`. Rest of the approach remains the same.\\n\\n```\\nclass Solution {\\npublic:\\n    bool check_palindrome(string &s) {\\n        int left = 0;\\n        int right = s.size() - 1;\\n        \\n        while (left < right) {\\n            if (s[left] != s[right]) {\\n                return false;\\n            }\\n            left++; right--;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        unordered_map<string, int> rev;\\n        string temp;\\n        \\n        int n = words.size();\\n        \\n        for (int i = 0; i < n; i++) {\\n            temp = words[i];\\n            reverse(temp.begin(), temp.end());\\n            \\n            rev[temp] = i;\\n        }\\n        \\n        vector<vector<int>> ans;\\n        \\n        if (rev.find(\"\") != rev.end()) {\\n            for (int i = 0; i < n; i++) {\\n                if (rev[\"\"] == i) {\\n                    continue;\\n                }\\n                \\n                if (check_palindrome(words[i])) {\\n                    ans.push_back({i, rev[\"\"]});\\n                }\\n            }\\n        }\\n        \\n        string left, right, word;\\n        \\n        for (int i = 0; i < n; i++) {\\n            word = words[i];\\n            \\n            left = \"\";\\n            right = word;\\n            \\n            int sz = word.size();\\n            \\n            for (int j = 0; j < sz; j++) {\\n                left.push_back(word[j]);\\n                right.erase(0, 1);\\n                \\n                if (rev.find(left) != rev.end() && rev[left] != i && check_palindrome(right)) {\\n                    ans.push_back({i, rev[left]});\\n                }\\n                \\n                if (rev.find(right) != rev.end() && rev[right] != i && check_palindrome(left)) {\\n                    ans.push_back({rev[right], i});\\n                }\\n            }\\n        }   \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check_palindrome(string &s) {\\n        int left = 0;\\n        int right = s.size() - 1;\\n        \\n        while (left < right) {\\n            if (s[left] != s[right]) {\\n                return false;\\n            }\\n            left++; right--;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        unordered_map<string, int> rev;\\n        string temp;\\n        \\n        int n = words.size();\\n        \\n        for (int i = 0; i < n; i++) {\\n            temp = words[i];\\n            reverse(temp.begin(), temp.end());\\n            \\n            rev[temp] = i;\\n        }\\n        \\n        vector<vector<int>> ans;\\n        \\n        if (rev.find(\"\") != rev.end()) {\\n            for (int i = 0; i < n; i++) {\\n                if (rev[\"\"] == i) {\\n                    continue;\\n                }\\n                \\n                if (check_palindrome(words[i])) {\\n                    ans.push_back({i, rev[\"\"]});\\n                }\\n            }\\n        }\\n        \\n        string left, right, word;\\n        \\n        for (int i = 0; i < n; i++) {\\n            word = words[i];\\n            \\n            left = \"\";\\n            right = word;\\n            \\n            int sz = word.size();\\n            \\n            for (int j = 0; j < sz; j++) {\\n                left.push_back(word[j]);\\n                right.erase(0, 1);\\n                \\n                if (rev.find(left) != rev.end() && rev[left] != i && check_palindrome(right)) {\\n                    ans.push_back({i, rev[left]});\\n                }\\n                \\n                if (rev.find(right) != rev.end() && rev[right] != i && check_palindrome(left)) {\\n                    ans.push_back({rev[right], i});\\n                }\\n            }\\n        }   \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766423,
                "title": "c-tries-implementation",
                "content": "First you have to Insert all strings in reverse order, then search for each string , whether it forms a palindorme or not in Trie.\\nif string matches with other string from end,then you have to check the left out string that it\\'s palindrone or not.\\n**Example :**\\nwe have two string **ZYZCA** and **AC** then -> reverse of ZYZCA => **ACZYZ**, now **AC** match with string 1 **AC**,so we have to check **ZYZ** is palindrome or not.\\n\\nSo the logic is to insert all stringes in reverse into Trie and then check for each string by searching in Trie (**without reversing search string**).\\n```\\nclass Solution\\n{\\npublic:\\n    // Trie Class\\n    class TrieNode\\n    {\\n    public:\\n        char data;\\n        TrieNode **children;\\n        int index;\\n        //Constructor to insert Char value and make TrieNode\\n        TrieNode(int data)\\n        {\\n            this->data = data;\\n            children = new TrieNode *[26];\\n            for (int i = 0; i < 26; i++)\\n            {\\n                children[i] = NULL;\\n            }\\n            index = -1;\\n        }\\n    };\\n    TrieNode *root;\\n    // Solution constructor to create root for Trie Class;\\n    Solution()\\n    {\\n        root = new TrieNode(\\' \\');\\n    }\\n    void insertWord(TrieNode *root, string word, int i)\\n    {\\n        // base call\\n        if (word.size() == 0)\\n        {\\n            //if we have to check the string is present or not then we have to check that root->index != -1\\n            //at ending of string we initializes index of string\\n            root->index = i;\\n            return;\\n        }\\n        // small calculations\\n        int index = word[0] - \\'a\\';\\n        TrieNode *child;\\n        if (root->children[index] != NULL)\\n        {\\n            child = root->children[index];\\n        }\\n        else\\n        {\\n            child = new TrieNode(word[0]);\\n            root->children[index] = child;\\n        }\\n        //recursion to insert word in Trie\\n        insertWord(child, word.substr(1), i);\\n    }\\n\\n    void insertWord(string word, int i)\\n    {\\n        insertWord(root, word, i);\\n    }\\n\\n    // find Function\\n    void find(TrieNode *root, vector<int> &palindromes, string s = \"\")\\n    {\\n        // base condition\\n        if (root->index != -1)\\n        {\\n            int i = 0, j = s.length() - 1;\\n            bool flag = true;\\n            while (i <= j)\\n            {\\n                if (s[i] != s[j])\\n                {\\n                    flag = false;\\n                    break;\\n                }\\n                i++;\\n                j--;\\n            }\\n            if (flag)\\n                palindromes.push_back(root->index);\\n        }\\n        for (int i = 0; i < 26; i++)\\n        {\\n            if (root->children[i])\\n            {\\n                char c = \\'a\\' + i;\\n                s.push_back(c);\\n                find(root->children[i], palindromes, s);\\n                s.pop_back();\\n            }\\n        }\\n        return;\\n    }\\n    // Search Function\\n    vector<int> search(TrieNode *root, string s)\\n    {\\n        vector<int> palindromes;\\n        TrieNode *ptr = root;\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            char c = s[i];\\n            int index = c - \\'a\\';\\n            //if string end here then we have to check that the remaining string is palindrone or not.;\\n            if (ptr->index != -1)\\n            {\\n                int j = i, k = s.length() - 1;\\n                bool flag = true;\\n                while (j <= k)\\n                {\\n                    if (s[j] != s[k])\\n                    {\\n                        flag = false;\\n                        break;\\n                    }\\n                    j++;\\n                    k--;\\n                }\\n                if (flag)\\n                    palindromes.push_back(ptr->index);\\n            }\\n            if (!ptr->children[index])\\n            {\\n                return palindromes;\\n            }\\n            ptr = ptr->children[index];\\n        }\\n        find(ptr, palindromes);\\n        return palindromes;\\n    }\\n\\npublic:\\n    vector<vector<int>> palindromePairs(vector<string> &words)\\n    {\\n        int i = 0;\\n        for (string s : words)\\n        {\\n            reverse(s.begin(), s.end());\\n            insertWord(s, i++);\\n        }\\n        vector<vector<int>> answer;\\n        i = 0;\\n        for (string s : words)\\n        {\\n            vector<int> palindromes = search(root, s);\\n\\n            for (int a : palindromes)\\n            {\\n                if (i != a)\\n                {\\n                    answer.push_back({i, a});\\n                }\\n            }\\n            i++;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    // Trie Class\\n    class TrieNode\\n    {\\n    public:\\n        char data;\\n        TrieNode **children;\\n        int index;\\n        //Constructor to insert Char value and make TrieNode\\n        TrieNode(int data)\\n        {\\n            this->data = data;\\n            children = new TrieNode *[26];\\n            for (int i = 0; i < 26; i++)\\n            {\\n                children[i] = NULL;\\n            }\\n            index = -1;\\n        }\\n    };\\n    TrieNode *root;\\n    // Solution constructor to create root for Trie Class;\\n    Solution()\\n    {\\n        root = new TrieNode(\\' \\');\\n    }\\n    void insertWord(TrieNode *root, string word, int i)\\n    {\\n        // base call\\n        if (word.size() == 0)\\n        {\\n            //if we have to check the string is present or not then we have to check that root->index != -1\\n            //at ending of string we initializes index of string\\n            root->index = i;\\n            return;\\n        }\\n        // small calculations\\n        int index = word[0] - \\'a\\';\\n        TrieNode *child;\\n        if (root->children[index] != NULL)\\n        {\\n            child = root->children[index];\\n        }\\n        else\\n        {\\n            child = new TrieNode(word[0]);\\n            root->children[index] = child;\\n        }\\n        //recursion to insert word in Trie\\n        insertWord(child, word.substr(1), i);\\n    }\\n\\n    void insertWord(string word, int i)\\n    {\\n        insertWord(root, word, i);\\n    }\\n\\n    // find Function\\n    void find(TrieNode *root, vector<int> &palindromes, string s = \"\")\\n    {\\n        // base condition\\n        if (root->index != -1)\\n        {\\n            int i = 0, j = s.length() - 1;\\n            bool flag = true;\\n            while (i <= j)\\n            {\\n                if (s[i] != s[j])\\n                {\\n                    flag = false;\\n                    break;\\n                }\\n                i++;\\n                j--;\\n            }\\n            if (flag)\\n                palindromes.push_back(root->index);\\n        }\\n        for (int i = 0; i < 26; i++)\\n        {\\n            if (root->children[i])\\n            {\\n                char c = \\'a\\' + i;\\n                s.push_back(c);\\n                find(root->children[i], palindromes, s);\\n                s.pop_back();\\n            }\\n        }\\n        return;\\n    }\\n    // Search Function\\n    vector<int> search(TrieNode *root, string s)\\n    {\\n        vector<int> palindromes;\\n        TrieNode *ptr = root;\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            char c = s[i];\\n            int index = c - \\'a\\';\\n            //if string end here then we have to check that the remaining string is palindrone or not.;\\n            if (ptr->index != -1)\\n            {\\n                int j = i, k = s.length() - 1;\\n                bool flag = true;\\n                while (j <= k)\\n                {\\n                    if (s[j] != s[k])\\n                    {\\n                        flag = false;\\n                        break;\\n                    }\\n                    j++;\\n                    k--;\\n                }\\n                if (flag)\\n                    palindromes.push_back(ptr->index);\\n            }\\n            if (!ptr->children[index])\\n            {\\n                return palindromes;\\n            }\\n            ptr = ptr->children[index];\\n        }\\n        find(ptr, palindromes);\\n        return palindromes;\\n    }\\n\\npublic:\\n    vector<vector<int>> palindromePairs(vector<string> &words)\\n    {\\n        int i = 0;\\n        for (string s : words)\\n        {\\n            reverse(s.begin(), s.end());\\n            insertWord(s, i++);\\n        }\\n        vector<vector<int>> answer;\\n        i = 0;\\n        for (string s : words)\\n        {\\n            vector<int> palindromes = search(root, s);\\n\\n            for (int a : palindromes)\\n            {\\n                if (i != a)\\n                {\\n                    answer.push_back({i, a});\\n                }\\n            }\\n            i++;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 699230,
                "title": "python-detailed-explanation-with-example",
                "content": "```\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        ## RC ##\\n        ## APPROACH : GREEDY ##\\n        ## LOGIC ##\\n        #   1st Inside For Loop: [abaaa, ba, aa] => prefix : \\'ab\\', check if reverse of \\'ab\\' is the given list, check if remainingprefix :\\'aaa\\' is palindrome, make sure it is not the same word, (reverse word).\\n\\n        #   2nd  Inside For Loop: [ abaaa, ba, aa ] => suffix : \\'aa\\', check if reverse of \\'aa\\' is the given list, check if remainingsuffix :\\'aba\\' is palindrome, make sure it is not the same word, (reverse word).\\n        \\n\\t\\t## TIME COMPLEXITY : O(K^2 x N) ## k -> prefix\\n\\t\\t## SPACE COMPLEXITY : O((K + N)^2) ##\\n\\n        # Ex : \\n        # words : [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]\\n        # reversedWords: {\\'dcba\\': 0, \\'abcd\\': 1, \\'sll\\': 2, \\'s\\': 3, \\'llsss\\': 4}\\n        # ans : [[0,1],[1,0],[3,2],[2,4]]\\n\\n        def isPalindrome(s):\\n            start = 0\\n            end = len(s) - 1\\n\\n            while( start < end ):\\n                if( s[ start ] != s[ end ] ):\\n                    return False\\n                start += 1\\n                end -= 1\\n            return True\\n\\n        results = set()\\n        reversedWords = { word[::-1]: index for index, word in enumerate(words) }\\n\\n        for i, word in enumerate(words):\\n            for j in range(0,len(word)+1):\\n                prefix = word[:j]\\n                pfremain = word[j:]\\n                if prefix in reversedWords and isPalindrome(pfremain) and reversedWords[prefix] != i:\\n                    results.add((i,reversedWords[prefix]))\\n            for j in range(len(word), -1, -1):\\n                suffix = word[j:]\\n                sfremain = word[:j]\\n                if suffix in reversedWords and isPalindrome(sfremain) and reversedWords[suffix] != i:\\n                    results.add((reversedWords[suffix],i))\\n        return results\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        ## RC ##\\n        ## APPROACH : GREEDY ##\\n        ## LOGIC ##\\n        #   1st Inside For Loop: [abaaa, ba, aa] => prefix : \\'ab\\', check if reverse of \\'ab\\' is the given list, check if remainingprefix :\\'aaa\\' is palindrome, make sure it is not the same word, (reverse word).\\n\\n        #   2nd  Inside For Loop: [ abaaa, ba, aa ] => suffix : \\'aa\\', check if reverse of \\'aa\\' is the given list, check if remainingsuffix :\\'aba\\' is palindrome, make sure it is not the same word, (reverse word).\\n        \\n\\t\\t## TIME COMPLEXITY : O(K^2 x N) ## k -> prefix\\n\\t\\t## SPACE COMPLEXITY : O((K + N)^2) ##\\n\\n        # Ex : \\n        # words : [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]\\n        # reversedWords: {\\'dcba\\': 0, \\'abcd\\': 1, \\'sll\\': 2, \\'s\\': 3, \\'llsss\\': 4}\\n        # ans : [[0,1],[1,0],[3,2],[2,4]]\\n\\n        def isPalindrome(s):\\n            start = 0\\n            end = len(s) - 1\\n\\n            while( start < end ):\\n                if( s[ start ] != s[ end ] ):\\n                    return False\\n                start += 1\\n                end -= 1\\n            return True\\n\\n        results = set()\\n        reversedWords = { word[::-1]: index for index, word in enumerate(words) }\\n\\n        for i, word in enumerate(words):\\n            for j in range(0,len(word)+1):\\n                prefix = word[:j]\\n                pfremain = word[j:]\\n                if prefix in reversedWords and isPalindrome(pfremain) and reversedWords[prefix] != i:\\n                    results.add((i,reversedWords[prefix]))\\n            for j in range(len(word), -1, -1):\\n                suffix = word[j:]\\n                sfremain = word[:j]\\n                if suffix in reversedWords and isPalindrome(sfremain) and reversedWords[suffix] != i:\\n                    results.add((reversedWords[suffix],i))\\n        return results\\n```",
                "codeTag": "Java"
            },
            {
                "id": 391739,
                "title": "python-set-for-beginners",
                "content": "```\\ndef palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        \\n        dicts={}\\n        for i, word in enumerate(words):\\n            dicts[word[::-1]]=i\\n        \\n        def isPalindrome(s):\\n            return s==s[::-1]\\n        \\n        res = set()\\n        for i, word in enumerate(words):\\n\\n            for j in range(len(word)+1): # to cover the case of empty string \\n                left = word[:j]\\n                right = word[j:]\\n                # case 1: \\n                if isPalindrome(left) and (right in dicts) and (i!=dicts[right]):\\n                    res.add((dicts[right], i))\\n                # case 2:\\n                if isPalindrome(right) and (left in dicts) and (i!=dicts[left]):\\n                    res.add((i, dicts[left]))\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        \\n        dicts={}\\n        for i, word in enumerate(words):\\n            dicts[word[::-1]]=i\\n        \\n        def isPalindrome(s):\\n            return s==s[::-1]\\n        \\n        res = set()\\n        for i, word in enumerate(words):\\n\\n            for j in range(len(word)+1): # to cover the case of empty string \\n                left = word[:j]\\n                right = word[j:]\\n                # case 1: \\n                if isPalindrome(left) and (right in dicts) and (i!=dicts[right]):\\n                    res.add((dicts[right], i))\\n                # case 2:\\n                if isPalindrome(right) and (left in dicts) and (i!=dicts[left]):\\n                    res.add((i, dicts[left]))\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2586148,
                "title": "c-solution-using-hashmap-and-dp-well-commented",
                "content": "**Please upvote if you like my solution.**\\n```\\nclass Solution {\\npublic:\\n    map<string,bool> sm; // to store calculated string and if it is palindrome or not\\n    bool pal(string &s){\\n        if(sm.find(s) != sm.end()) return sm[s];\\n        int n = s.length();\\n        if(n == 0) return sm[s] = true;\\n        for(int i = 0;i <= n/2;i++){\\n            if( s[i] != s[(n - i) - 1] ) return sm[s] = false;\\n        }\\n        return sm[s] = true;\\n    }\\n    \\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        vector<vector<int>> ans; // to store answer\\n        unordered_map<string,int> m; // unordered map is used because its search time is O(1) for avg case \\n        for(int i=0;i<words.size();i++){\\n            string s = words[i];\\n            reverse(s.begin(),s.end());\\n            m[s] = i; // storing reverse strings in map\\n        }\\n\\t\\t// if we have empty string in given words then for this we only check if words have palindrome words in it and insert that pair in ans\\n        if(m.find(\"\") != m.end()) {\\n            for(int i = 0; i < words.size(); i++) {\\n                if(i == m[\"\"]) continue;\\n                if(pal(words[i])){ ans.push_back({i, m[\"\"]});}\\n            }\\n        }\\n\\t\\t// Now traversing words in words \\n        for(int i=0;i<words.size();i++){\\n\\t\\t\\t// storing i\\'th word in r and initializing l as empty string\\n            string r = words[i];\\n            string l = \"\";\\n\\t\\t\\t// Now traversing i\\'th word ans poping start character from r and pushing it to l and checking \\n\\t\\t\\t// if we can find that in map and also if l or r is palindrome and final check is that if found then \\n\\t\\t\\t// must not have same index so after these checks we can add those index to answer\\n            for(int j = 0; j < words[i].length() ; j++){\\n                l.push_back(words[i][j]);\\n                r.erase(0,1);\\n                if(m.find(l) != m.end() && pal(r) && m[l] != i) ans.push_back({i, m[l]});\\n                if(m.find(r) != m.end() && pal(l) && m[r] != i) ans.push_back({m[r], i});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<string,bool> sm; // to store calculated string and if it is palindrome or not\\n    bool pal(string &s){\\n        if(sm.find(s) != sm.end()) return sm[s];\\n        int n = s.length();\\n        if(n == 0) return sm[s] = true;\\n        for(int i = 0;i <= n/2;i++){\\n            if( s[i] != s[(n - i) - 1] ) return sm[s] = false;\\n        }\\n        return sm[s] = true;\\n    }\\n    \\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        vector<vector<int>> ans; // to store answer\\n        unordered_map<string,int> m; // unordered map is used because its search time is O(1) for avg case \\n        for(int i=0;i<words.size();i++){\\n            string s = words[i];\\n            reverse(s.begin(),s.end());\\n            m[s] = i; // storing reverse strings in map\\n        }\\n\\t\\t// if we have empty string in given words then for this we only check if words have palindrome words in it and insert that pair in ans\\n        if(m.find(\"\") != m.end()) {\\n            for(int i = 0; i < words.size(); i++) {\\n                if(i == m[\"\"]) continue;\\n                if(pal(words[i])){ ans.push_back({i, m[\"\"]});}\\n            }\\n        }\\n\\t\\t// Now traversing words in words \\n        for(int i=0;i<words.size();i++){\\n\\t\\t\\t// storing i\\'th word in r and initializing l as empty string\\n            string r = words[i];\\n            string l = \"\";\\n\\t\\t\\t// Now traversing i\\'th word ans poping start character from r and pushing it to l and checking \\n\\t\\t\\t// if we can find that in map and also if l or r is palindrome and final check is that if found then \\n\\t\\t\\t// must not have same index so after these checks we can add those index to answer\\n            for(int j = 0; j < words[i].length() ; j++){\\n                l.push_back(words[i][j]);\\n                r.erase(0,1);\\n                if(m.find(l) != m.end() && pal(r) && m[l] != i) ans.push_back({i, m[l]});\\n                if(m.find(r) != m.end() && pal(l) && m[r] != i) ans.push_back({m[r], i});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585807,
                "title": "accepted-no-tle-this-time",
                "content": "```\\nclass Solution {\\npublic:\\n /* n - # of words\\n    k - avg len of words\\n    O(nkk), beats O(nnk)\\n    \\n    group words by length, and sorted groups by length\\n    then check every word against word groups shorter\\n    for words same len, only add once, because the other counter part will add too\\n    \\n    same complexity using trie, prefix tree\\n\\n     s[l, r] inclusive */\\n    inline bool isPalindrome(const string &s, int l, int r) {\\n        while(l < r && s[l] == s[r]) {\\n            l++;\\n            r--;\\n        }\\n        return l >= r;\\n    }\\n    \\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        // groups of words sorted by size\\n        map<int, unordered_map<string, int>> mm;\\n        for(int i=0; i<words.size(); i++) {   // O(n*log(k))\\n            mm[words[i].size()][string(words[i].rbegin(), words[i].rend())] = i;\\n        }\\n        \\n        vector<vector<int>> res;\\n        for(int i=0; i < words.size(); i++) { // O(n*k*k)\\n            auto w = words[i];\\n            \\n            for(auto & [k, m] : mm) {\\n                if (k > w.size()) break;\\n                \\n                // same len word, add only once, for other word will add again as well\\n                if (k == w.size()) {\\n                    if (m.count(w) && m[w] != i) {\\n                        res.push_back({i, m[w]});\\n                    }\\n                    break;\\n                }\\n                \\n                // check back\\n                if (isPalindrome(w, k, w.size() - 1)) {\\n                    auto tgt = w.substr(0, k);\\n                    if (m.count(tgt)) {\\n                        res.push_back({i, m[tgt]});\\n                    }\\n                }\\n\\n                // check front\\n                if (isPalindrome(w, 0, w.size() - k - 1)) {\\n                    auto tgt = w.substr(w.size() - k);\\n                    if (m.count(tgt)) {\\n                        res.push_back({m[tgt], i});\\n                    }\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n/* \\ntests\\n - same len words forming palindromes\\n - [\\'abc\\', \\'cba\\']\\n - diff len words forming palindromes\\n */\\n \\n //Runtime: 693 ms, faster than 92.98% of C++ online submissions for Palindrome Pairs.\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n /* n - # of words\\n    k - avg len of words\\n    O(nkk), beats O(nnk)\\n    \\n    group words by length, and sorted groups by length\\n    then check every word against word groups shorter\\n    for words same len, only add once, because the other counter part will add too\\n    \\n    same complexity using trie, prefix tree\\n\\n     s[l, r] inclusive */\\n    inline bool isPalindrome(const string &s, int l, int r) {\\n        while(l < r && s[l] == s[r]) {\\n            l++;\\n            r--;\\n        }\\n        return l >= r;\\n    }\\n    \\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        // groups of words sorted by size\\n        map<int, unordered_map<string, int>> mm;\\n        for(int i=0; i<words.size(); i++) {   // O(n*log(k))\\n            mm[words[i].size()][string(words[i].rbegin(), words[i].rend())] = i;\\n        }\\n        \\n        vector<vector<int>> res;\\n        for(int i=0; i < words.size(); i++) { // O(n*k*k)\\n            auto w = words[i];\\n            \\n            for(auto & [k, m] : mm) {\\n                if (k > w.size()) break;\\n                \\n                // same len word, add only once, for other word will add again as well\\n                if (k == w.size()) {\\n                    if (m.count(w) && m[w] != i) {\\n                        res.push_back({i, m[w]});\\n                    }\\n                    break;\\n                }\\n                \\n                // check back\\n                if (isPalindrome(w, k, w.size() - 1)) {\\n                    auto tgt = w.substr(0, k);\\n                    if (m.count(tgt)) {\\n                        res.push_back({i, m[tgt]});\\n                    }\\n                }\\n\\n                // check front\\n                if (isPalindrome(w, 0, w.size() - k - 1)) {\\n                    auto tgt = w.substr(w.size() - k);\\n                    if (m.count(tgt)) {\\n                        res.push_back({m[tgt], i});\\n                    }\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n/* \\ntests\\n - same len words forming palindromes\\n - [\\'abc\\', \\'cba\\']\\n - diff len words forming palindromes\\n */\\n \\n //Runtime: 693 ms, faster than 92.98% of C++ online submissions for Palindrome Pairs.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2552848,
                "title": "java-simple-solution-beat-95",
                "content": "The key idea to solve the problem is:\\nStore all the string into dictionary. (The dictionary could be hashmap or trie or whatever.) We try to calculate what kind of stirng could be the palindrome with s, then we search this string in our dictionary.\\n\\nMore concretely:\\nFor a string `str`\\ncase-1: if  `str` is palindrome itself, then find if there is \"\".  Because `str + \"\" `and `\"\" + str` are still palindrome.\\nCase-2: if the reverse of str is in our \\'dictionary\\'. Then` str + str.reverse` is palindrome\\nCase-3:` s = [s1 + s2]`, s2 is palindrome. then `s1 + s2 + s1.reverse()` is palindrom. we need to find s1.reverse();\\nCase-4:  `s = [s1 + s2]`, s1 is palindrome. then s2.reverse() + s1 + s2 is palindrom. we need to find s2.reverse();\\n\\nImportant Trick:\\nThis is the thing help you hugely improve the runtime.\\nTrick1: before check wether a string is in the dictionary or not, Check if the length is in the dictionary.\\nTrick2: To check isPalindrome, don\\'t invoke substring() method too many times! Just use different index pointer for different substring!\\n\\n\\tclass Solution {\\n\\t\\tpublic List<List<Integer>> palindromePairs(String[] words) {\\n\\t\\t\\tList<List<Integer>> res = new ArrayList<List<Integer>>();\\n\\t\\t\\tif(words == null || words.length == 0){\\n\\t\\t\\t\\treturn res;\\n\\t\\t\\t}\\n\\t\\t\\tint[] hasLength = new int[5002];\\n\\t\\t\\t//build the map save the key-val pairs: String - idx\\n\\t\\t\\tHashMap<String, Integer> map = new HashMap<>();\\n\\t\\t\\tfor(int i = 0; i < words.length; i++){\\n\\t\\t\\t\\tmap.put(words[i], i);\\n\\t\\t\\t\\thasLength[words[i].length()]++;\\n\\t\\t\\t}\\n\\n\\n\\n\\t\\t\\t//case-1\\n\\t\\t\\t//special cases: \"\" can be combine with any palindrome string\\n\\t\\t\\tif(map.containsKey(\"\")){\\n\\t\\t\\t\\tint blankIdx = map.get(\"\");\\n\\t\\t\\t\\tfor(int i = 0; i < words.length; i++){\\n\\t\\t\\t\\t\\tif(isPalindrome(words[i], 0, words[i].length() - 1)){\\n\\t\\t\\t\\t\\t\\tif(i == blankIdx) continue;\\n\\t\\t\\t\\t\\t\\tres.add(Arrays.asList(blankIdx, i));\\n\\t\\t\\t\\t\\t\\tres.add(Arrays.asList(i, blankIdx));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t//case-2\\n\\t\\t\\t//find all string and reverse string pairs\\n\\t\\t\\tfor(int i = 0; i < words.length; i++){\\n\\t\\t\\t\\tString cur_r = reverseStr(words[i]);\\n\\t\\t\\t\\tif(map.containsKey(cur_r)){\\n\\t\\t\\t\\t\\tint found = map.get(cur_r);\\n\\t\\t\\t\\t\\tif(found == i) continue;\\n\\t\\t\\t\\t\\tres.add(Arrays.asList(i, found));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\t//case3- s = [s1 + s2], s2 is palindrome\\uFF0Cfind s1.reverse()  => [s, findIndex]\\n\\t\\t\\t//case4- s = [s1 + s2], s1 is palindrome\\uFF0Cfind s2.reverse()  => [findIndex, s]\\n\\t\\t\\tfor(int i = 0; i < words.length; i++){\\n\\t\\t\\t\\tString cur = words[i];\\n\\n\\t\\t\\t\\tfor(int cut = 1; cut < cur.length(); cut++){\\n\\t\\t\\t\\t\\tif(hasLength[cur.length() - cut] > 0 && isPalindrome(cur, 0, cut - 1)){\\n\\t\\t\\t\\t\\t\\tString cut_r = reverseStr(cur.substring(cut));\\n\\t\\t\\t\\t\\t\\tif(map.containsKey(cut_r)){\\n\\t\\t\\t\\t\\t\\t\\tint found = map.get(cut_r);\\n\\t\\t\\t\\t\\t\\t\\tif(found == i) continue;\\n\\t\\t\\t\\t\\t\\t\\tres.add(Arrays.asList(found, i));\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(hasLength[cut] > 0 && isPalindrome(cur, cut, cur.length() - 1)){\\n\\t\\t\\t\\t\\t\\tString cut_r = reverseStr(cur.substring(0, cut));\\n\\t\\t\\t\\t\\t\\tif(map.containsKey(cut_r)){\\n\\t\\t\\t\\t\\t\\t\\tint found = map.get(cut_r);\\n\\t\\t\\t\\t\\t\\t\\tif(found == i) continue;\\n\\t\\t\\t\\t\\t\\t\\tres.add(Arrays.asList(i, found));\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\n\\t\\tpublic String reverseStr(String str){\\n\\t\\t\\tStringBuilder sb= new StringBuilder(str);\\n\\t\\t\\treturn sb.reverse().toString();\\n\\t\\t}\\n\\n\\t\\tpublic boolean isPalindrome(String s, int i, int j){\\n\\n        while(i < j){\\n            if(s.charAt(i) != s.charAt(j)){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic List<List<Integer>> palindromePairs(String[] words) {\\n\\t\\t\\tList<List<Integer>> res = new ArrayList<List<Integer>>();\\n\\t\\t\\tif(words == null || words.length == 0){\\n\\t\\t\\t\\treturn res;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2255423,
                "title": "c-no-trie-very-straightforward-graphical-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/53429ff6-b6da-4312-ac9f-9af4b15dd082_1657295100.2741961.jpeg)\\n\\n```\\nclass Solution {\\n//function to determine whether the substring [l...r] of a string is a palindrome (to handle the middle part of the picture) \\n    bool pal_substr(string &s, int l, int r) {\\n        while(l<=r) {\\n            if (s[l] != s[r]) return false; \\n            l++; r--;\\n        }\\n        return true; \\n    }\\npublic:\\n    vector<vector<int>> palindromePairs(vector<string> w) {\\n        unordered_map <string, int> straight;  //dictionary where key is a string from words, and value is it\\'s index\\n        unordered_map <string, int> rev;  //same but with reversed words \\n        for (int i = 0; i < w.size(); i++) {\\n            straight[w[i]] = i;\\n            string u = w[i]; reverse(u.begin(), u.end());\\n            rev[u] = i;\\n        }\\n        set <vector<int>> ans;    //keep found pairs in a set to ensure they are unique\\n        for (int i = 0; i < w.size(); i++) {\\n            string t = \"\"; \\n\\t\\t\\t// lets go from the beginning of string w[i], adding each character to string t. if dictionary rev contains t, and if t is not the same as w[i], and if the remaining part of w[i] is a palindrome (see picture), we\\'ve found a suitable pair of indices \\n            if (rev.find(t) != rev.end()) if (rev[t] != i) if (pal_substr(w[i], 0, w[i].size()-1)) ans.insert({i, rev[t]}); \\n            for (int j = 0; j < w[i].size(); j++) {\\n                t += w[i][j];\\n                if (rev.find(t) != rev.end()) if (rev[t] != i) if (pal_substr(w[i], j+1, w[i].size()-1)) ans.insert({i, rev[t]}); \\n            }\\n            t = \"\";\\n\\t\\t\\t// same but another way around \\n            if (straight.find(t) != straight.end()) if (straight[t] != i) if (pal_substr(w[i], 0, w[i].size()-1)) ans.insert({straight[t], i});\\n            for (int j = w[i].size()-1; j >= 0; j--) {\\n                t += w[i][j];\\n                if (straight.find(t) != straight.end()) if (straight[t] != i) if (pal_substr(w[i], 0, j-1)) ans.insert({straight[t], i}); \\n            }\\n        }\\n\\t\\t//convert set to vector \\n        return vector<vector<int>>(ans.begin(), ans.end()); \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n//function to determine whether the substring [l...r] of a string is a palindrome (to handle the middle part of the picture) \\n    bool pal_substr(string &s, int l, int r) {\\n        while(l<=r) {\\n            if (s[l] != s[r]) return false; \\n            l++; r--;\\n        }\\n        return true; \\n    }\\npublic:\\n    vector<vector<int>> palindromePairs(vector<string> w) {\\n        unordered_map <string, int> straight;  //dictionary where key is a string from words, and value is it\\'s index\\n        unordered_map <string, int> rev;  //same but with reversed words \\n        for (int i = 0; i < w.size(); i++) {\\n            straight[w[i]] = i;\\n            string u = w[i]; reverse(u.begin(), u.end());\\n            rev[u] = i;\\n        }\\n        set <vector<int>> ans;    //keep found pairs in a set to ensure they are unique\\n        for (int i = 0; i < w.size(); i++) {\\n            string t = \"\"; \\n\\t\\t\\t// lets go from the beginning of string w[i], adding each character to string t. if dictionary rev contains t, and if t is not the same as w[i], and if the remaining part of w[i] is a palindrome (see picture), we\\'ve found a suitable pair of indices \\n            if (rev.find(t) != rev.end()) if (rev[t] != i) if (pal_substr(w[i], 0, w[i].size()-1)) ans.insert({i, rev[t]}); \\n            for (int j = 0; j < w[i].size(); j++) {\\n                t += w[i][j];\\n                if (rev.find(t) != rev.end()) if (rev[t] != i) if (pal_substr(w[i], j+1, w[i].size()-1)) ans.insert({i, rev[t]}); \\n            }\\n            t = \"\";\\n\\t\\t\\t// same but another way around \\n            if (straight.find(t) != straight.end()) if (straight[t] != i) if (pal_substr(w[i], 0, w[i].size()-1)) ans.insert({straight[t], i});\\n            for (int j = w[i].size()-1; j >= 0; j--) {\\n                t += w[i][j];\\n                if (straight.find(t) != straight.end()) if (straight[t] != i) if (pal_substr(w[i], 0, j-1)) ans.insert({straight[t], i}); \\n            }\\n        }\\n\\t\\t//convert set to vector \\n        return vector<vector<int>>(ans.begin(), ans.end()); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1651095,
                "title": "o-nk-solution-using-kmp-algorithm-for-finding-palindrome-analyses-of-all-algorithm",
                "content": "<b>1. Brute force | O(k*n<sup>2</sup>) Time  and O(1) space</b>\\nwe take all possible combination of words and add it to our result list if it\\'s a palindrome\\n<b> GOLANG</b>\\n```\\nfunc palindromePairs(words []string) [][]int {\\nresult := [][]int{}\\n// n^2 to generate all combination\\nfor  i, word1 := range words {\\n\\tfor j, word2 := range words {\\n\\t\\tif i != j {\\n\\t\\t\\t// isPalindrome is O(k)\\n\\t\\t\\tif isPalindrome(word1+word2) {\\n\\t\\t\\t\\tresult = append(result, []int{i,j})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\nreturn result\\n}\\n\\nfunc isPalindrome(s string) bool {\\n\\tl := len(s)\\n\\tfor i:= 0;i<l/2;i++ {\\n\\t\\tif s[i] != s[l-1-i] {\\n\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```\\n<hr></hr>\\n<b>2. Better Solution | Using Map | O(n*k<sup>2</sup>) and O(n) space</b>\\n\\nLets Consider a word combination <b><i>word<sub>x</sub>|word<sub>y</sub></i></b>. For this to be a palindrome, one of the following three case has to happen\\n1. if <i><b>len(word<sub>x</sub>) == len(word<sub>y</sub>)</b></i>, then <b>word<sub>x</sub></b> has to be reverse of word<sub>y</sub></b>\\n\\n2. if <i><b>len(word<sub>x</sub>) < len(word<sub>y</sub>)</b></i>, \\tthen <b>word<sub>y</sub></b> has to be of the form <b><i>palin<sub>y</sub>|word<sub>y\\'</sub></i></b> where \\n\\t\\t<b><i>palin<sub>y</sub></i></b> is a palindromic substring of  <b>word<sub>y</sub></b> that exists at its left boundary\\n\\t\\t<b><i>word<sub>y\\'</sub></i></b> is the remaining substring of <b>word<sub>y</sub></b> and it has to be a reverse of <b>word<sub>x</sub></b>\\n\\t\\t\\n3. Similarly, if <b><i>len(word<sub>x</sub>) > len(word<sub>y</sub>)</i></b>, \\tthen <b>word<sub>x</sub></b> has to be of the form <b><i>word<sub>x\\'</sub>|palin<sub>x</sub></i></b> where \\n\\t\\t<b><i>palin<sub>x</sub></i></b> is a palindromic substring of  <b>word<sub>x</sub></b> that exists at its right boundary\\n\\t\\t<b><i>word<sub>x\\'</sub></i></b> is the remaining substring of <b>word<sub>x</sub></b> and it has to be a reverse of <b>word<sub>y</sub></b>\\n\\nSo if we can find all such palindromic substrings of a word, we only need to find if the reverse of the remaining substring exists in the list of words provided \\n - To efficiently find if a particular string is present in a list, we can use a hashmap. this will be a <b>O(1)</b> step\\n - To find all palindromic substrings of a word that lies at the boundary, we will take all possible index i at check if any of the left or right substring are Palindromes. \\n Checking of palindrome is an<b> O(k)</b> step where k is the length of the string and iterating for all index is also an <b>O(k)</b> step \\n Thus the overall time complexity will be <b>O(n)*O(k<sup>2</sup>)</b> and space complexity will be <b>O(n)</b> for hashmap.\\n \\n<b> GOLANG</b>\\n```\\nfunc palindromePairs(words []string) [][]int { \\nresult := [][]int{}\\nm := map[string]int{}\\nfor  i, word := range words {\\n\\tm[word] = i\\n}\\n\\nfor  i, word := range words {\\nl := len(word)\\n\\tfor k:=0;k<l;k++ {\\n\\t// checking if the left substring is palindromic\\n\\t\\tif isPalindrome(word[:k]) {\\n\\t\\t\\tif j, ok := m[reverse(word[k:])];ok{\\n\\t\\t\\tif i!= j {\\n\\t\\t\\t\\tresult = append(result, []int{j,i})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t// checking if the right substring is palindromic\\n\\t\\tif isPalindrome(word[k:]) {\\n\\t\\t\\tif j, ok := m[reverse(word[:k])];ok{\\n\\t\\t\\tif i!= j {\\n\\t\\t\\t\\tresult = append(result, []int{i,j})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\nreturn result\\n}\\n\\nfunc reverse(s string) string {\\n  buf := []byte(s)\\n  for i:= 0;i<len(buf)/2;i++ {\\n    buf[i], buf[len(buf)-i-1] =  buf[len(buf)-i-1],buf[i]\\n  }\\n  return string(buf)\\n}\\n\\nfunc isPalindrome(s string) bool {\\n\\tl := len(s)\\n\\tfor i:= 0;i<l/2;i++ {\\n\\t\\tif s[i] != s[l-1-i] {\\n\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```\\n<hr></hr>\\n<b>3. Even Better Solution | O(nk) time and O(n+k) space</b>\\n\\n<b>EDIT: I forgot to consider the time taken by hash function which is constant wrt to the number of element added but will surely  be atleast linear time wrt to the size of the string and also the substring generation step is O(k) and therefore the time complexity is still O(nk<sup>2</sup>)</b>\\n\\nIn the 2<sup>nd</sup> Solution, the major cost is from the computation of all possible palindrome of  a given word which is O(k<sup>2</sup>). We will bring this cost down to O(k) using KMP algorithm for string matching.\\nPlease check KMP algorithm for better understanding of the following steps\\n\\n- As a preprocessing step we will create a <b>lps</b>(longest prefix substring) array of <b>word<sub>x</sub></b> and also generate reverse of <b>word<sub>x</sub></b> i.e, <b>wordRev<sub>x</sub></b>\\n- we will try to match  <b>word<sub>x</sub></b> with <b>wordRev<sub>x</sub></b> using the <b>lps</b> array index by index\\n At each index i, we have the length of the longest prefix of <b>word<sub>x</sub></b> which is also a suffix of <b>wordRev<sub>x</sub>[:i]</b>. Thus at last index the value we have gives us the longest palindrome that exist at the left boundary\\n \\n Using the value at the last index and the <b>lps</b> array we can find all the remaining palindrome that exist at the left boundary(if need clarification let me know)\\n Similarly we need to find all palindrome that exist at the right boundary\\n All of the above step are <b>O(k)</b> and the overall time complexity is <b>O(nk)</b>\\n Space complexity is <b>O(n) + O(k)(for lps array)</b> \\n \\n <b> GOLANG</b>\\n ```\\n func palindromePairs(words []string) [][]int {\\n\\n  res := [][]int{}\\n  m := map[string]int{} \\n  for i, word:= range words {\\n    m[word] = i\\n  }\\n  \\n  \\n for i, word:= range words {\\n    l := len(word)\\n    wordRev := reverse(word)\\n    \\n    // calculation of palindrome at left boundary\\n    lps := KMPPreprocessing(word) \\n    start := 0\\n    for j:=0;j<l;j++ {\\n      for start > 0 && wordRev[j] != word[start] {\\n        start = lps[start-1]+1\\n      }\\n      if wordRev[j]==word[start] {\\n        start++\\n      }\\n    }\\n    start--\\n    for start >= 0 {\\n      if j, ok := m[wordRev[:(l-start-1)]]; ok {\\n        if j != i {\\n            res = append(res, []int{j,i})\\n        }\\n      }\\n      start = lps[start]\\n    }\\n   \\n   // case where len(word1)==len(word2)\\n    if j, ok := m[wordRev]; ok {\\n        if j != i {\\n        res = append(res, []int{j,i})\\n        }\\n      }\\n   \\n   // calculation of palindrome at right boundary\\n    lps = KMPPreprocessing(wordRev) \\n    start = 0\\n    for j:=0;j<l;j++ {\\n      for start > 0 && word[j] != wordRev[start] {\\n        start = lps[start-1]+1\\n      }\\n      if word[j]==wordRev[start] {\\n        start++\\n      }\\n    }\\n    start--\\n    for start >= 0 {\\n      if j, ok := m[wordRev[start+1:]]; ok {\\n        if j != i {\\n        res = append(res, []int{i,j})\\n        }\\n      }\\n      start = lps[start]\\n    }\\n  }\\n  return res\\n}\\n\\nfunc KMPPreprocessing(s string) []int {\\n  n := len(s)\\n  if n == 0 {\\n    return nil\\n  }\\n  f := make([]int, n)\\n  f[0] = -1\\n  start := 0\\n  for i:=1;i<n;i++{\\n    if s[i] == s[f[i-1]+1] {\\n      f[i] = f[i-1]+1\\n    }else {\\n      start = f[i-1]\\n      for start >= 0 && s[i] != s[start+1] {\\n        start = f[start]\\n      }\\n      if s[i] == s[start+1] {\\n        f[i] = start+1\\n      }else {\\n        f[i]= start\\n      }\\n      \\n    }\\n  }\\n  return f\\n}\\n\\nfunc reverse(s string) string {\\n  buf := []byte(s)\\n  for i:= 0;i<len(buf)/2;i++ {\\n    buf[i], buf[len(buf)-i-1] =  buf[len(buf)-i-1],buf[i]\\n  }\\n  return string(buf)\\n}\\n ```\\n <hr></hr>\\n <b>4. Another try at O(nk) solution</b> :D\\n \\n Please check this [code](https://leetcode.com/problems/palindrome-pairs/discuss/79195/O(n-*-k2)-java-solution-with-Trie-structure) by @[fun4LeetCode](https://leetcode.com/fun4LeetCode/)\\n \\n The algorithm presented is <b>O(n*k<sup>2</sup>)</b>. Now if we apply the logic presented in our 3<sup>rd</sup> solution we can get rid of the extra O(k) we got due to hashmap and substring generation\\n Here is my modified Java code -\\n \\n <b>JAVA</b>\\n ```\\nclass Solution {\\n   private static class TrieNode {\\n    TrieNode[] next;\\n    int index;\\n    List<Integer> list;\\n    \\t\\n    TrieNode() {\\n    \\tnext = new TrieNode[26];\\n    \\tindex = -1;\\n    \\tlist = new ArrayList<>();\\n    }\\n}\\n    \\npublic List<List<Integer>> palindromePairs(String[] words) {\\n    List<List<Integer>> res = new ArrayList<>();\\n\\n    TrieNode root = new TrieNode();\\n\\t\\t\\n    for (int i = 0; i < words.length; i++) {\\n        addWord(root, words[i], i);\\n    }\\n\\t\\t\\n    for (int i = 0; i < words.length; i++) {\\n        search(words, i, root, res);\\n    }\\n    \\n    return res;\\n}\\n    \\nprivate void addWord(TrieNode root, String word, int index) {\\n  boolean[] idx = getRightPalindrome(word);\\n    for (int i = word.length() - 1; i >= 0; i--) {\\n        int j = word.charAt(i) - \\'a\\';\\n\\t\\t\\t\\t\\n        if (root.next[j] == null) {\\n            root.next[j] = new TrieNode();\\n        }\\n\\t\\t\\t\\t\\n        if (idx[i]) {\\n            root.list.add(index);\\n        }\\n\\t\\t\\t\\t\\n        root = root.next[j];\\n    }\\n    \\t\\n    root.list.add(index);\\n    root.index = index;\\n}\\n    \\nprivate void search(String[] words, int i, TrieNode root, List<List<Integer>> res) {\\n    boolean[] idx = getLeftPalindrome(words[i]);\\n  int l = words[i].length();\\n    for (int j = 0; j < words[i].length(); j++) {\\t\\n    \\tif (root.index >= 0 && root.index != i && idx[l-1-j]) {\\n    \\t    res.add(Arrays.asList(i, root.index));\\n    \\t}\\n    \\t\\t\\n    \\troot = root.next[words[i].charAt(j) - \\'a\\'];\\n      \\tif (root == null) return;\\n    }\\n    \\t\\n    for (int j : root.list) {\\n    \\tif (i == j) continue;\\n    \\tres.add(Arrays.asList(i, j));\\n    }\\n}\\n    \\nprivate boolean isPalindrome(String word, int i, int j) {\\n    while (i < j) {\\n    \\tif (word.charAt(i++) != word.charAt(j--)) return false;\\n    }\\n    \\t\\n    return true;\\n}\\nprivate boolean[] getRightPalindrome(String word) {\\n    boolean[] idx = new boolean[word.length()];\\n    String wordRev = new StringBuilder(word).reverse().toString();\\n    int[] lps = KMPPreprocessing(word);\\n    \\n      int l = word.length();\\n    int  start = 0;\\n    for (int j=0;j<l;j++) {\\n      while (start > 0 && wordRev.charAt(j) != word.charAt(start)) {\\n        start = lps[start-1]+1;\\n      }\\n      if (wordRev.charAt(j)==word.charAt(start) ){\\n        start++;\\n      }\\n    }\\n    start--;\\n    while (start >= 0) {\\n      idx[start] = true;\\n      start = lps[start];\\n    }\\n    return idx;\\n}\\n  \\nprivate boolean[] getLeftPalindrome(String word) {\\n    boolean[] idx = getRightPalindrome(new StringBuilder(word).reverse().toString());\\n    return idx;\\n}\\n  \\nprivate int[] KMPPreprocessing(String s) {\\n  int n = s.length();\\n  int[] f = new int[n];\\n  if (n == 0) {\\n    return f;\\n  }\\n  f[0] = -1;\\n  int start = 0;\\n  for (int i=1;i<n;i++){\\n    if (s.charAt(i) == s.charAt(f[i-1]+1) ){\\n      f[i] = f[i-1]+1;\\n    }else {\\n      start = f[i-1];\\n      while (start >= 0 && s.charAt(i) != s.charAt(start+1) ){\\n        start = f[start];\\n      }\\n      if (s.charAt(i) == s.charAt(start+1)) {\\n        f[i] = start+1;\\n      }else {\\n        f[i]= start;\\n      }\\n    }\\n  }\\n  return f;\\n}\\n}\\n```\\n \\n <b> GOLANG </b>\\n ```\\n type Trie struct {\\nindex int\\nlist []int\\nnext [26]*Trie\\n}\\n\\nfunc createTrie() *Trie {\\n  return &Trie{index:-1}\\n}\\n\\nfunc (t *Trie) addWord(s string, index int) {\\n  idx := getRightPalindrome(s);\\n  l := len(s)\\n  for j:= l-1;j>=0;j--{\\n    c := int(s[j]-\\'a\\')\\n    if t.next[c] == nil {\\n      t.next[c] = &Trie{index:-1}\\n    }\\n    if idx[j] {\\n      t.list = append(t.list, index)\\n    }\\n    t= t.next[c]\\n  }\\n  t.list = append(t.list, index)\\n  t.index= index\\n}\\n\\nfunc (t *Trie) searchAndAppendWordPair(s string, index int, res [][]int) [][]int {\\n  idx := getLeftPalindrome(s);\\n  \\n  l := len(s)\\n  for j:= 0;j<l;j++{\\n    if t.index != -1 && t.index != index && idx[j]/*isPalindrome(s, j, l-1)*/ {\\n      res = append(res, []int{index, t.index})\\n    }\\n    c := int(s[j]-\\'a\\')\\n    if t.next[c] == nil {\\n      return res\\n    }\\n    t= t.next[c]\\n  }\\n  for _, j:= range t.list {\\n    if index != j {\\n      res = append(res, []int{index, j})\\n    }\\n  }\\n  return res\\n}\\n\\nfunc palindromePairs(words []string) [][]int {\\n\\n  res := [][]int{}\\n  m := map[string]int{} \\n  for i, word:= range words {\\n    m[word] = i\\n  }\\n  \\n  \\n  trie := createTrie()\\n  \\n for i, word:= range words {\\n   trie.addWord(word, i)\\n }\\n  for i, word:= range words {\\n   res = trie.searchAndAppendWordPair(word, i, res)\\n }\\n  \\n   return res\\n}\\n\\nfunc isPalindrome(s string, i,j int) bool{\\n  for i<j{\\n    if s[i]!= s[j] {\\n      return false\\n    }\\n    i++\\n    j--\\n  }\\n  return true\\n}\\n\\nfunc KMPPreprocessing(s string) []int {\\n  n := len(s)\\n  if n == 0 {\\n    return nil\\n  }\\n  f := make([]int, n)\\n  f[0] = -1\\n  start := 0\\n  for i:=1;i<n;i++{\\n    if s[i] == s[f[i-1]+1] {\\n      f[i] = f[i-1]+1\\n    }else {\\n      start = f[i-1]\\n      for start >= 0 && s[i] != s[start+1] {\\n        start = f[start]\\n      }\\n      if s[i] == s[start+1] {\\n        f[i] = start+1\\n      }else {\\n        f[i]= start\\n      }\\n      \\n    }\\n  }\\n  return f\\n}\\n\\nfunc getRightPalindrome(word string) []bool{\\n  idx := make([]bool, len(word))\\n  wordRev := reverse(word)\\n  lps := KMPPreprocessing(word)\\n    \\n  l := len(word)\\n  start := 0\\n  for j:=0;j<l;j++ {\\n      for start > 0 && wordRev[j] != word[start] {\\n        start = lps[start-1]+1\\n      }\\n      if (wordRev[j]==word[start] ){\\n        start++\\n      }\\n    }\\n    start--\\n    for start >= 0 {\\n      idx[start] = true\\n      start = lps[start]\\n    }\\n    return idx\\n  }\\n\\nfunc getLeftPalindrome(word string) []bool{\\n  idx := make([]bool, len(word))\\n  wordRev := reverse(word)\\n  lps := KMPPreprocessing(wordRev)\\n    \\n  l := len(word)\\n  start := 0\\n  for j:=0;j<l;j++ {\\n      for start > 0 && word[j] != wordRev[start] {\\n        start = lps[start-1]+1\\n      }\\n      if (word[j]==wordRev[start] ){\\n        start++\\n      }\\n    }\\n    start--\\n    for start >= 0 {\\n      idx[l-1-start] = true\\n      start = lps[start]\\n    }\\n    return idx\\n  }\\n\\nfunc reverse(s string) string {\\n  buf := []byte(s)\\n  for i:= 0;i<len(buf)/2;i++ {\\n    buf[i], buf[len(buf)-i-1] =  buf[len(buf)-i-1],buf[i]\\n  }\\n  return string(buf)\\n}\\n\\n```\\n Though 4th solution is <b>O(k*n)</b>. It is 3rd solution which is the fastest.\\n \\n Please let me know If I missed something or if there is a fault in my analysis\\n",
                "solutionTags": [],
                "code": "```\\nfunc palindromePairs(words []string) [][]int {\\nresult := [][]int{}\\n// n^2 to generate all combination\\nfor  i, word1 := range words {\\n\\tfor j, word2 := range words {\\n\\t\\tif i != j {\\n\\t\\t\\t// isPalindrome is O(k)\\n\\t\\t\\tif isPalindrome(word1+word2) {\\n\\t\\t\\t\\tresult = append(result, []int{i,j})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\nreturn result\\n}\\n\\nfunc isPalindrome(s string) bool {\\n\\tl := len(s)\\n\\tfor i:= 0;i<l/2;i++ {\\n\\t\\tif s[i] != s[l-1-i] {\\n\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```\n```\\nfunc palindromePairs(words []string) [][]int { \\nresult := [][]int{}\\nm := map[string]int{}\\nfor  i, word := range words {\\n\\tm[word] = i\\n}\\n\\nfor  i, word := range words {\\nl := len(word)\\n\\tfor k:=0;k<l;k++ {\\n\\t// checking if the left substring is palindromic\\n\\t\\tif isPalindrome(word[:k]) {\\n\\t\\t\\tif j, ok := m[reverse(word[k:])];ok{\\n\\t\\t\\tif i!= j {\\n\\t\\t\\t\\tresult = append(result, []int{j,i})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t// checking if the right substring is palindromic\\n\\t\\tif isPalindrome(word[k:]) {\\n\\t\\t\\tif j, ok := m[reverse(word[:k])];ok{\\n\\t\\t\\tif i!= j {\\n\\t\\t\\t\\tresult = append(result, []int{i,j})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\nreturn result\\n}\\n\\nfunc reverse(s string) string {\\n  buf := []byte(s)\\n  for i:= 0;i<len(buf)/2;i++ {\\n    buf[i], buf[len(buf)-i-1] =  buf[len(buf)-i-1],buf[i]\\n  }\\n  return string(buf)\\n}\\n\\nfunc isPalindrome(s string) bool {\\n\\tl := len(s)\\n\\tfor i:= 0;i<l/2;i++ {\\n\\t\\tif s[i] != s[l-1-i] {\\n\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```\n```\\n func palindromePairs(words []string) [][]int {\\n\\n  res := [][]int{}\\n  m := map[string]int{} \\n  for i, word:= range words {\\n    m[word] = i\\n  }\\n  \\n  \\n for i, word:= range words {\\n    l := len(word)\\n    wordRev := reverse(word)\\n    \\n    // calculation of palindrome at left boundary\\n    lps := KMPPreprocessing(word) \\n    start := 0\\n    for j:=0;j<l;j++ {\\n      for start > 0 && wordRev[j] != word[start] {\\n        start = lps[start-1]+1\\n      }\\n      if wordRev[j]==word[start] {\\n        start++\\n      }\\n    }\\n    start--\\n    for start >= 0 {\\n      if j, ok := m[wordRev[:(l-start-1)]]; ok {\\n        if j != i {\\n            res = append(res, []int{j,i})\\n        }\\n      }\\n      start = lps[start]\\n    }\\n   \\n   // case where len(word1)==len(word2)\\n    if j, ok := m[wordRev]; ok {\\n        if j != i {\\n        res = append(res, []int{j,i})\\n        }\\n      }\\n   \\n   // calculation of palindrome at right boundary\\n    lps = KMPPreprocessing(wordRev) \\n    start = 0\\n    for j:=0;j<l;j++ {\\n      for start > 0 && word[j] != wordRev[start] {\\n        start = lps[start-1]+1\\n      }\\n      if word[j]==wordRev[start] {\\n        start++\\n      }\\n    }\\n    start--\\n    for start >= 0 {\\n      if j, ok := m[wordRev[start+1:]]; ok {\\n        if j != i {\\n        res = append(res, []int{i,j})\\n        }\\n      }\\n      start = lps[start]\\n    }\\n  }\\n  return res\\n}\\n\\nfunc KMPPreprocessing(s string) []int {\\n  n := len(s)\\n  if n == 0 {\\n    return nil\\n  }\\n  f := make([]int, n)\\n  f[0] = -1\\n  start := 0\\n  for i:=1;i<n;i++{\\n    if s[i] == s[f[i-1]+1] {\\n      f[i] = f[i-1]+1\\n    }else {\\n      start = f[i-1]\\n      for start >= 0 && s[i] != s[start+1] {\\n        start = f[start]\\n      }\\n      if s[i] == s[start+1] {\\n        f[i] = start+1\\n      }else {\\n        f[i]= start\\n      }\\n      \\n    }\\n  }\\n  return f\\n}\\n\\nfunc reverse(s string) string {\\n  buf := []byte(s)\\n  for i:= 0;i<len(buf)/2;i++ {\\n    buf[i], buf[len(buf)-i-1] =  buf[len(buf)-i-1],buf[i]\\n  }\\n  return string(buf)\\n}\\n ```\n```\\nclass Solution {\\n   private static class TrieNode {\\n    TrieNode[] next;\\n    int index;\\n    List<Integer> list;\\n    \\t\\n    TrieNode() {\\n    \\tnext = new TrieNode[26];\\n    \\tindex = -1;\\n    \\tlist = new ArrayList<>();\\n    }\\n}\\n    \\npublic List<List<Integer>> palindromePairs(String[] words) {\\n    List<List<Integer>> res = new ArrayList<>();\\n\\n    TrieNode root = new TrieNode();\\n\\t\\t\\n    for (int i = 0; i < words.length; i++) {\\n        addWord(root, words[i], i);\\n    }\\n\\t\\t\\n    for (int i = 0; i < words.length; i++) {\\n        search(words, i, root, res);\\n    }\\n    \\n    return res;\\n}\\n    \\nprivate void addWord(TrieNode root, String word, int index) {\\n  boolean[] idx = getRightPalindrome(word);\\n    for (int i = word.length() - 1; i >= 0; i--) {\\n        int j = word.charAt(i) - \\'a\\';\\n\\t\\t\\t\\t\\n        if (root.next[j] == null) {\\n            root.next[j] = new TrieNode();\\n        }\\n\\t\\t\\t\\t\\n        if (idx[i]) {\\n            root.list.add(index);\\n        }\\n\\t\\t\\t\\t\\n        root = root.next[j];\\n    }\\n    \\t\\n    root.list.add(index);\\n    root.index = index;\\n}\\n    \\nprivate void search(String[] words, int i, TrieNode root, List<List<Integer>> res) {\\n    boolean[] idx = getLeftPalindrome(words[i]);\\n  int l = words[i].length();\\n    for (int j = 0; j < words[i].length(); j++) {\\t\\n    \\tif (root.index >= 0 && root.index != i && idx[l-1-j]) {\\n    \\t    res.add(Arrays.asList(i, root.index));\\n    \\t}\\n    \\t\\t\\n    \\troot = root.next[words[i].charAt(j) - \\'a\\'];\\n      \\tif (root == null) return;\\n    }\\n    \\t\\n    for (int j : root.list) {\\n    \\tif (i == j) continue;\\n    \\tres.add(Arrays.asList(i, j));\\n    }\\n}\\n    \\nprivate boolean isPalindrome(String word, int i, int j) {\\n    while (i < j) {\\n    \\tif (word.charAt(i++) != word.charAt(j--)) return false;\\n    }\\n    \\t\\n    return true;\\n}\\nprivate boolean[] getRightPalindrome(String word) {\\n    boolean[] idx = new boolean[word.length()];\\n    String wordRev = new StringBuilder(word).reverse().toString();\\n    int[] lps = KMPPreprocessing(word);\\n    \\n      int l = word.length();\\n    int  start = 0;\\n    for (int j=0;j<l;j++) {\\n      while (start > 0 && wordRev.charAt(j) != word.charAt(start)) {\\n        start = lps[start-1]+1;\\n      }\\n      if (wordRev.charAt(j)==word.charAt(start) ){\\n        start++;\\n      }\\n    }\\n    start--;\\n    while (start >= 0) {\\n      idx[start] = true;\\n      start = lps[start];\\n    }\\n    return idx;\\n}\\n  \\nprivate boolean[] getLeftPalindrome(String word) {\\n    boolean[] idx = getRightPalindrome(new StringBuilder(word).reverse().toString());\\n    return idx;\\n}\\n  \\nprivate int[] KMPPreprocessing(String s) {\\n  int n = s.length();\\n  int[] f = new int[n];\\n  if (n == 0) {\\n    return f;\\n  }\\n  f[0] = -1;\\n  int start = 0;\\n  for (int i=1;i<n;i++){\\n    if (s.charAt(i) == s.charAt(f[i-1]+1) ){\\n      f[i] = f[i-1]+1;\\n    }else {\\n      start = f[i-1];\\n      while (start >= 0 && s.charAt(i) != s.charAt(start+1) ){\\n        start = f[start];\\n      }\\n      if (s.charAt(i) == s.charAt(start+1)) {\\n        f[i] = start+1;\\n      }else {\\n        f[i]= start;\\n      }\\n    }\\n  }\\n  return f;\\n}\\n}\\n```\n```\\n type Trie struct {\\nindex int\\nlist []int\\nnext [26]*Trie\\n}\\n\\nfunc createTrie() *Trie {\\n  return &Trie{index:-1}\\n}\\n\\nfunc (t *Trie) addWord(s string, index int) {\\n  idx := getRightPalindrome(s);\\n  l := len(s)\\n  for j:= l-1;j>=0;j--{\\n    c := int(s[j]-\\'a\\')\\n    if t.next[c] == nil {\\n      t.next[c] = &Trie{index:-1}\\n    }\\n    if idx[j] {\\n      t.list = append(t.list, index)\\n    }\\n    t= t.next[c]\\n  }\\n  t.list = append(t.list, index)\\n  t.index= index\\n}\\n\\nfunc (t *Trie) searchAndAppendWordPair(s string, index int, res [][]int) [][]int {\\n  idx := getLeftPalindrome(s);\\n  \\n  l := len(s)\\n  for j:= 0;j<l;j++{\\n    if t.index != -1 && t.index != index && idx[j]/*isPalindrome(s, j, l-1)*/ {\\n      res = append(res, []int{index, t.index})\\n    }\\n    c := int(s[j]-\\'a\\')\\n    if t.next[c] == nil {\\n      return res\\n    }\\n    t= t.next[c]\\n  }\\n  for _, j:= range t.list {\\n    if index != j {\\n      res = append(res, []int{index, j})\\n    }\\n  }\\n  return res\\n}\\n\\nfunc palindromePairs(words []string) [][]int {\\n\\n  res := [][]int{}\\n  m := map[string]int{} \\n  for i, word:= range words {\\n    m[word] = i\\n  }\\n  \\n  \\n  trie := createTrie()\\n  \\n for i, word:= range words {\\n   trie.addWord(word, i)\\n }\\n  for i, word:= range words {\\n   res = trie.searchAndAppendWordPair(word, i, res)\\n }\\n  \\n   return res\\n}\\n\\nfunc isPalindrome(s string, i,j int) bool{\\n  for i<j{\\n    if s[i]!= s[j] {\\n      return false\\n    }\\n    i++\\n    j--\\n  }\\n  return true\\n}\\n\\nfunc KMPPreprocessing(s string) []int {\\n  n := len(s)\\n  if n == 0 {\\n    return nil\\n  }\\n  f := make([]int, n)\\n  f[0] = -1\\n  start := 0\\n  for i:=1;i<n;i++{\\n    if s[i] == s[f[i-1]+1] {\\n      f[i] = f[i-1]+1\\n    }else {\\n      start = f[i-1]\\n      for start >= 0 && s[i] != s[start+1] {\\n        start = f[start]\\n      }\\n      if s[i] == s[start+1] {\\n        f[i] = start+1\\n      }else {\\n        f[i]= start\\n      }\\n      \\n    }\\n  }\\n  return f\\n}\\n\\nfunc getRightPalindrome(word string) []bool{\\n  idx := make([]bool, len(word))\\n  wordRev := reverse(word)\\n  lps := KMPPreprocessing(word)\\n    \\n  l := len(word)\\n  start := 0\\n  for j:=0;j<l;j++ {\\n      for start > 0 && wordRev[j] != word[start] {\\n        start = lps[start-1]+1\\n      }\\n      if (wordRev[j]==word[start] ){\\n        start++\\n      }\\n    }\\n    start--\\n    for start >= 0 {\\n      idx[start] = true\\n      start = lps[start]\\n    }\\n    return idx\\n  }\\n\\nfunc getLeftPalindrome(word string) []bool{\\n  idx := make([]bool, len(word))\\n  wordRev := reverse(word)\\n  lps := KMPPreprocessing(wordRev)\\n    \\n  l := len(word)\\n  start := 0\\n  for j:=0;j<l;j++ {\\n      for start > 0 && word[j] != wordRev[start] {\\n        start = lps[start-1]+1\\n      }\\n      if (word[j]==wordRev[start] ){\\n        start++\\n      }\\n    }\\n    start--\\n    for start >= 0 {\\n      idx[l-1-start] = true\\n      start = lps[start]\\n    }\\n    return idx\\n  }\\n\\nfunc reverse(s string) string {\\n  buf := []byte(s)\\n  for i:= 0;i<len(buf)/2;i++ {\\n    buf[i], buf[len(buf)-i-1] =  buf[len(buf)-i-1],buf[i]\\n  }\\n  return string(buf)\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1241920,
                "title": "easy-c-soln-hash-map-without-trie",
                "content": "//Note :- In place of hash map, trie can easly be deployed (in that case rather than using mp.find(), we will go for trie search). Or you can form a reverse trie i.e. trie of reversed word so at the time of search you don\\'t need to reverse left and right every time\\n```\\nclass Solution {\\npublic:\\n    bool palindrome(string s){\\n        int i=0,j=s.length()-1;\\n        while(i<=j){\\n            if(s[i++]!=s[j--])return false;\\n        }\\n        return true;\\n    }\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        unordered_map<string,int> mp;\\n        for(int i=0;i<words.size();i++){\\n            mp[words[i]]=i;\\n        }\\n        set<vector<int>>res;\\n        for(int i=0;i<words.size();i++){\\n            string word=words[i];\\n            if(word==\"\"){\\n                for(int j=0;j<words.size();j++){\\n                    if(i==j)continue;\\n                    if(palindrome(words[j])){\\n                        res.insert({i,j});\\n                        res.insert({j,i});\\n                    }\\n                }\\n                continue;\\n                \\n            }\\n            string temp=string(word.rbegin(),word.rend());\\n            if(mp.find(temp)!=mp.end()){if(i!=mp[temp])res.insert({i,mp[temp]});}\\n            for(int j=0;j<word.length()-1;j++){\\n                string left=word.substr(0,j+1);\\n                string right=word.substr(j+1);\\n                string rright=string(right.rbegin(),right.rend());\\n                string rleft=string(left.rbegin(),left.rend());\\n                if(palindrome(left) && (mp.find(rright)!=mp.end())){\\n                    if(i!=mp[rright])res.insert({mp[rright],i});\\n                }\\n                if(palindrome(right) && (mp.find(rleft)!=mp.end())){\\n                    if(i!=mp[rleft])res.insert({i,mp[rleft]});\\n                }\\n            }\\n        }\\n        return {res.begin(),res.end()};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool palindrome(string s){\\n        int i=0,j=s.length()-1;\\n        while(i<=j){\\n            if(s[i++]!=s[j--])return false;\\n        }\\n        return true;\\n    }\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        unordered_map<string,int> mp;\\n        for(int i=0;i<words.size();i++){\\n            mp[words[i]]=i;\\n        }\\n        set<vector<int>>res;\\n        for(int i=0;i<words.size();i++){\\n            string word=words[i];\\n            if(word==\"\"){\\n                for(int j=0;j<words.size();j++){\\n                    if(i==j)continue;\\n                    if(palindrome(words[j])){\\n                        res.insert({i,j});\\n                        res.insert({j,i});\\n                    }\\n                }\\n                continue;\\n                \\n            }\\n            string temp=string(word.rbegin(),word.rend());\\n            if(mp.find(temp)!=mp.end()){if(i!=mp[temp])res.insert({i,mp[temp]});}\\n            for(int j=0;j<word.length()-1;j++){\\n                string left=word.substr(0,j+1);\\n                string right=word.substr(j+1);\\n                string rright=string(right.rbegin(),right.rend());\\n                string rleft=string(left.rbegin(),left.rend());\\n                if(palindrome(left) && (mp.find(rright)!=mp.end())){\\n                    if(i!=mp[rright])res.insert({mp[rright],i});\\n                }\\n                if(palindrome(right) && (mp.find(rleft)!=mp.end())){\\n                    if(i!=mp[rleft])res.insert({i,mp[rleft]});\\n                }\\n            }\\n        }\\n        return {res.begin(),res.end()};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1235153,
                "title": "python3-trie",
                "content": "\\n```\\nclass Trie: \\n    def __init__(self): \\n        self.root = {}\\n    \\n    def insert(self, word, k): \\n        node = self.root \\n        for i, c in enumerate(word): \\n            if word[i:] == word[i:][::-1]: node.setdefault(\"val\", []).append(k)\\n            node = node.setdefault(c, {})\\n        node.setdefault(\"val\", []).append(k)\\n        node.setdefault(\"end\", []).append(k)\\n            \\n    def search(self, word): \\n        ans = []\\n        node = self.root\\n        for i, c in enumerate(word): \\n            if word[i:] == word[i:][::-1]: ans.extend(node.get(\"end\", []))\\n            if c not in node: break \\n            node = node[c]\\n        else: ans += node.get(\"val\", [])\\n        return ans \\n    \\n\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        trie = Trie()\\n        for i, word in enumerate(words): \\n            trie.insert(word, i)\\n        \\n        ans = set()\\n        for i, word in enumerate(words): \\n            val = trie.search(word[::-1])\\n            for ii in val: \\n                if ii != i: ans.add((ii, i))\\n        return ans \\n```\\n\\n**hash table**\\n```\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        mp = {x: i for i, x in enumerate(words)} # val-to-pos mapping \\n        \\n        ans = []\\n        for i, word in enumerate(words): \\n            for ii in range(len(word)+1): \\n                prefix = word[:ii]\\n                if prefix == prefix[::-1]: # palindromic prefix \\n                    key = word[ii:][::-1]\\n                    if key in mp and mp[key] != i: ans.append([mp[key], i])\\n                suffix = word[~ii:]\\n                if ii < len(word) and suffix == suffix[::-1]: # palindromic suffix \\n                    key = word[:~ii][::-1]\\n                    if key in mp and mp[key] != i: ans.append([i, mp[key]])\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Trie: \\n    def __init__(self): \\n        self.root = {}\\n    \\n    def insert(self, word, k): \\n        node = self.root \\n        for i, c in enumerate(word): \\n            if word[i:] == word[i:][::-1]: node.setdefault(\"val\", []).append(k)\\n            node = node.setdefault(c, {})\\n        node.setdefault(\"val\", []).append(k)\\n        node.setdefault(\"end\", []).append(k)\\n            \\n    def search(self, word): \\n        ans = []\\n        node = self.root\\n        for i, c in enumerate(word): \\n            if word[i:] == word[i:][::-1]: ans.extend(node.get(\"end\", []))\\n            if c not in node: break \\n            node = node[c]\\n        else: ans += node.get(\"val\", [])\\n        return ans \\n    \\n\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        trie = Trie()\\n        for i, word in enumerate(words): \\n            trie.insert(word, i)\\n        \\n        ans = set()\\n        for i, word in enumerate(words): \\n            val = trie.search(word[::-1])\\n            for ii in val: \\n                if ii != i: ans.add((ii, i))\\n        return ans \\n```\n```\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        mp = {x: i for i, x in enumerate(words)} # val-to-pos mapping \\n        \\n        ans = []\\n        for i, word in enumerate(words): \\n            for ii in range(len(word)+1): \\n                prefix = word[:ii]\\n                if prefix == prefix[::-1]: # palindromic prefix \\n                    key = word[ii:][::-1]\\n                    if key in mp and mp[key] != i: ans.append([mp[key], i])\\n                suffix = word[~ii:]\\n                if ii < len(word) and suffix == suffix[::-1]: # palindromic suffix \\n                    key = word[:~ii][::-1]\\n                    if key in mp and mp[key] != i: ans.append([i, mp[key]])\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 279554,
                "title": "o-n-k-2-java-solution-beats-67",
                "content": "```java\\nclass Solution {\\n    \\n    // \\u5BF9\\u4E8E\\u6BCF\\u4E2A String, \\u90FD\\u5C1D\\u8BD5\\u628A\\u5B83\\u5207\\u6210\\u4E24\\u90E8\\u5206\\uFF0C\\u89C2\\u5BDF\\u6BCF\\u4E00\\u90E8\\u5206\\u662F\\u5426\\u4E3A\\u56DE\\u6587\\u4E32\\n    // \\u6BD4\\u5982\\u5BF9\\u4E8E \"abacd\", \\u5DE6\\u4FA7 \"aba\" \\u662F\\u56DE\\u6587\\uFF0C\\u8FD8\\u5269\\u4E0B \"cd\", \\u6240\\u4EE5\\u60F3\\u8981\\u548C\\u53E6\\u4E00\\u4E2A\\u5B57\\u7B26\\u4E32\\u7EC4\\u6210\\u4E00\\u4E2A\\u957F\\u7684\\u56DE\\u6587\\u4E32\\uFF0C\\u53EA\\u9700\\u8981 Map \\u4E2D\\u6709 \"dc\" \\u5373\\u53EF\\n    // \\u52A0\\u5230\\u539F\\u5B57\\u7B26\\u4E32\\u7684\\u5DE6\\u8FB9: \"dc\", \"abacd\" => \"dcabacd\"\\n    // \\u5BF9\\u4E8E\\u53F3\\u534A\\u90E8\\u5206 substring \\u7684\\u5206\\u6790\\u540C\\u7406\\n    // \\u8FD9\\u6837\\u7684\\u8BDD\\u603B\\u5171\\u7684\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\u5C31\\u4F1A\\u964D\\u4F4E\\u5230 O(n * k^2), \\u5176\\u4E2D k \\u662F\\u6700\\u957F\\u5355\\u8BCD\\u7684\\u957F\\u5EA6\\uFF0C\\u5B9E\\u9645\\u4E2D k \\u5E94\\u8BE5\\u8FDC\\u5C0F\\u4E8E n, \\u82F1\\u8BED\\u4E2D\\u53EF\\u8FD1\\u4F3C\\u4E3A\\u5E38\\u91CF\\u3002\\n    \\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (words == null || words.length < 2) return result;\\n        \\n        Map<String, Integer> map = new HashMap<>();\\n        for (int i = 0; i < words.length; i++) {\\n            map.put(words[i], i);\\n        }\\n        \\n        for (int i = 0; i < words.length; i++) {\\n            for (int j = 0; j <= words[i].length(); j++) {\\n                String str1 = words[i].substring(0, j);\\n                String str2 = words[i].substring(j);                               // \\u5206\\u6210\\u5DE6\\u53F3\\u4E24\\u4E2A substring\\n                if (isPalindrome(str1)) {                                          // \\u5DE6\\u4FA7\\u4E3A\\u56DE\\u6587\\uFF0C\\u9700\\u8981\\u627E\\u5230\\u53F3\\u4FA7\\u7684\\u9006\\u5E8F\\u5728 map \\u4E2D\\n                    String reStr2 = new StringBuilder(str2).reverse().toString();\\n                    if (map.containsKey(reStr2) && map.get(reStr2) != i) {         // \\u4E0D\\u80FD\\u662F\\u672C\\u8EAB\\uFF0C\\u6BD4\\u5982 reStr2 \\u662F \"a\", \\u5176\\u672C\\u8EAB\\u4E0D\\u53EF\\u7528\\n                        result.add(Arrays.asList(map.get(reStr2), i));             // \\u6839\\u636E\\u4F8B\\u5B50\\u7684\\u5206\\u6790\\uFF0Cstr2 \\u7684\\u53CD\\u5E8F\\u5B57\\u7B26\\u4E32\\u8981\\u52A0\\u5230\\u5F53\\u524D\\u5B57\\u7B26\\u4E32\\u7684\\u5DE6\\u8FB9\\n                    }\\n                }\\n                if (str2.length() != 0 && isPalindrome(str2)) {                    // \\u8981\\u52A0\\u4E0A\\u4E0D\\u4E3A\\u7A7A\\u7684\\u6761\\u4EF6\\uFF0C\\u4E3A\\u4E86\\u907F\\u514D\\u91CD\\u590D\\uFF0C\\u5426\\u5219 words[i] \\u6574\\u4F53\\u5C31\\u4F1A\\u5728 str1 \\u548C str2 \\u4E3A\\u7A7A\\u7684\\u65F6\\u5019\\u88AB\\u8003\\u8651\\u4E24\\u6B21\\n                    String reStr1 = new StringBuilder(str1).reverse().toString();\\n                    if (map.containsKey(reStr1) && map.get(reStr1) != i) { \\n                        result.add(Arrays.asList(i, map.get(reStr1))); \\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    // Check whether a string is Palindrome\\n    private boolean isPalindrome(String str) {\\n        int left = 0, right = str.length() - 1;\\n        while (left < right) {\\n            if (str.charAt(left) != str.charAt(right)) return false;\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    \\n    // \\u5BF9\\u4E8E\\u6BCF\\u4E2A String, \\u90FD\\u5C1D\\u8BD5\\u628A\\u5B83\\u5207\\u6210\\u4E24\\u90E8\\u5206\\uFF0C\\u89C2\\u5BDF\\u6BCF\\u4E00\\u90E8\\u5206\\u662F\\u5426\\u4E3A\\u56DE\\u6587\\u4E32\\n    // \\u6BD4\\u5982\\u5BF9\\u4E8E \"abacd\", \\u5DE6\\u4FA7 \"aba\" \\u662F\\u56DE\\u6587\\uFF0C\\u8FD8\\u5269\\u4E0B \"cd\", \\u6240\\u4EE5\\u60F3\\u8981\\u548C\\u53E6\\u4E00\\u4E2A\\u5B57\\u7B26\\u4E32\\u7EC4\\u6210\\u4E00\\u4E2A\\u957F\\u7684\\u56DE\\u6587\\u4E32\\uFF0C\\u53EA\\u9700\\u8981 Map \\u4E2D\\u6709 \"dc\" \\u5373\\u53EF\\n    // \\u52A0\\u5230\\u539F\\u5B57\\u7B26\\u4E32\\u7684\\u5DE6\\u8FB9: \"dc\", \"abacd\" => \"dcabacd\"\\n    // \\u5BF9\\u4E8E\\u53F3\\u534A\\u90E8\\u5206 substring \\u7684\\u5206\\u6790\\u540C\\u7406\\n    // \\u8FD9\\u6837\\u7684\\u8BDD\\u603B\\u5171\\u7684\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\u5C31\\u4F1A\\u964D\\u4F4E\\u5230 O(n * k^2), \\u5176\\u4E2D k \\u662F\\u6700\\u957F\\u5355\\u8BCD\\u7684\\u957F\\u5EA6\\uFF0C\\u5B9E\\u9645\\u4E2D k \\u5E94\\u8BE5\\u8FDC\\u5C0F\\u4E8E n, \\u82F1\\u8BED\\u4E2D\\u53EF\\u8FD1\\u4F3C\\u4E3A\\u5E38\\u91CF\\u3002\\n    \\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (words == null || words.length < 2) return result;\\n        \\n        Map<String, Integer> map = new HashMap<>();\\n        for (int i = 0; i < words.length; i++) {\\n            map.put(words[i], i);\\n        }\\n        \\n        for (int i = 0; i < words.length; i++) {\\n            for (int j = 0; j <= words[i].length(); j++) {\\n                String str1 = words[i].substring(0, j);\\n                String str2 = words[i].substring(j);                               // \\u5206\\u6210\\u5DE6\\u53F3\\u4E24\\u4E2A substring\\n                if (isPalindrome(str1)) {                                          // \\u5DE6\\u4FA7\\u4E3A\\u56DE\\u6587\\uFF0C\\u9700\\u8981\\u627E\\u5230\\u53F3\\u4FA7\\u7684\\u9006\\u5E8F\\u5728 map \\u4E2D\\n                    String reStr2 = new StringBuilder(str2).reverse().toString();\\n                    if (map.containsKey(reStr2) && map.get(reStr2) != i) {         // \\u4E0D\\u80FD\\u662F\\u672C\\u8EAB\\uFF0C\\u6BD4\\u5982 reStr2 \\u662F \"a\", \\u5176\\u672C\\u8EAB\\u4E0D\\u53EF\\u7528\\n                        result.add(Arrays.asList(map.get(reStr2), i));             // \\u6839\\u636E\\u4F8B\\u5B50\\u7684\\u5206\\u6790\\uFF0Cstr2 \\u7684\\u53CD\\u5E8F\\u5B57\\u7B26\\u4E32\\u8981\\u52A0\\u5230\\u5F53\\u524D\\u5B57\\u7B26\\u4E32\\u7684\\u5DE6\\u8FB9\\n                    }\\n                }\\n                if (str2.length() != 0 && isPalindrome(str2)) {                    // \\u8981\\u52A0\\u4E0A\\u4E0D\\u4E3A\\u7A7A\\u7684\\u6761\\u4EF6\\uFF0C\\u4E3A\\u4E86\\u907F\\u514D\\u91CD\\u590D\\uFF0C\\u5426\\u5219 words[i] \\u6574\\u4F53\\u5C31\\u4F1A\\u5728 str1 \\u548C str2 \\u4E3A\\u7A7A\\u7684\\u65F6\\u5019\\u88AB\\u8003\\u8651\\u4E24\\u6B21\\n                    String reStr1 = new StringBuilder(str1).reverse().toString();\\n                    if (map.containsKey(reStr1) && map.get(reStr1) != i) { \\n                        result.add(Arrays.asList(i, map.get(reStr1))); \\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    // Check whether a string is Palindrome\\n    private boolean isPalindrome(String str) {\\n        int left = 0, right = str.length() - 1;\\n        while (left < right) {\\n            if (str.charAt(left) != str.charAt(right)) return false;\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 202266,
                "title": "simple-java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    // o(n * k^3)\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        if (words == null || words.length == 0) return res;\\n        HashMap<String, Integer> map = new HashMap<>();\\n        //o(n)\\n        for (int i = 0; i < words.length; i++) {\\n            map.put(words[i], i);\\n        }\\n        //o(n)\\n        for (int i = 0; i < words.length; i++) {\\n            //IMPORTANT!! \\n            if (words[i].length() == 0) {\\n                for (String key : map.keySet()) {\\n                    if (isPalidrome(key))   addResult(res, i, map.get(key));\\n                }\\n                continue;\\n            }\\n            // o(k)\\n            for (int j = 0; j < words[i].length(); j++) {\\n                String s1 = words[i].substring(0, j);\\n                String s2 = words[i].substring(j);\\n                // o(k)\\n                if (isPalidrome(s1)) {\\n                    // o(k)\\n                    String reversed = new StringBuilder(s2).reverse().toString();\\n                    if (map.containsKey(reversed)) {\\n                        addResult(res, map.get(reversed), i);\\n                    }\\n                }\\n                if (isPalidrome(s2)) {\\n                    String reversed = new StringBuilder(s1).reverse().toString();\\n                    if (map.containsKey(reversed)) {\\n                        addResult(res, i, map.get(reversed));\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    } \\n    //o(1)\\n    public void addResult(List<List<Integer>> res, int i, int j) {\\n        ArrayList<Integer> temp = new ArrayList<>();\\n        if (i == j) return;\\n        temp.add(i);\\n        temp.add(j);\\n        res.add(temp);\\n    }\\n    // o(k)\\n    public boolean isPalidrome(String s) {\\n        for (int i = 0, j = s.length() - 1; i <= j; i++, j--) {\\n            if (s.charAt(i) != s.charAt(j)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // o(n * k^3)\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        if (words == null || words.length == 0) return res;\\n        HashMap<String, Integer> map = new HashMap<>();\\n        //o(n)\\n        for (int i = 0; i < words.length; i++) {\\n            map.put(words[i], i);\\n        }\\n        //o(n)\\n        for (int i = 0; i < words.length; i++) {\\n            //IMPORTANT!! \\n            if (words[i].length() == 0) {\\n                for (String key : map.keySet()) {\\n                    if (isPalidrome(key))   addResult(res, i, map.get(key));\\n                }\\n                continue;\\n            }\\n            // o(k)\\n            for (int j = 0; j < words[i].length(); j++) {\\n                String s1 = words[i].substring(0, j);\\n                String s2 = words[i].substring(j);\\n                // o(k)\\n                if (isPalidrome(s1)) {\\n                    // o(k)\\n                    String reversed = new StringBuilder(s2).reverse().toString();\\n                    if (map.containsKey(reversed)) {\\n                        addResult(res, map.get(reversed), i);\\n                    }\\n                }\\n                if (isPalidrome(s2)) {\\n                    String reversed = new StringBuilder(s1).reverse().toString();\\n                    if (map.containsKey(reversed)) {\\n                        addResult(res, i, map.get(reversed));\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    } \\n    //o(1)\\n    public void addResult(List<List<Integer>> res, int i, int j) {\\n        ArrayList<Integer> temp = new ArrayList<>();\\n        if (i == j) return;\\n        temp.add(i);\\n        temp.add(j);\\n        res.add(temp);\\n    }\\n    // o(k)\\n    public boolean isPalidrome(String s) {\\n        for (int i = 0, j = s.length() - 1; i <= j; i++, j--) {\\n            if (s.charAt(i) != s.charAt(j)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79246,
                "title": "java-trie-solution",
                "content": "Thanks ChiCeline's solution, I learnt from the Python code and create this java version. The raw time complexity calculate as O(n * len * len).\\n\\nI'll appreciate it if you could provide any suggestion.\\n```\\npublic class Solution {\\n    class TrieNode {\\n        TrieNode[] children;\\n        ArrayList<Integer> ids;\\n        int index; // index of current word\\n        public TrieNode() {\\n            this.children = new TrieNode[26];\\n            this.ids = new ArrayList<Integer>();\\n            this.index = -1;\\n        }\\n    }\\n    \\n    private TrieNode root;\\n    \\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        List<List<Integer>> list = new ArrayList<List<Integer>>();\\n        if (words.length < 2) return list;\\n        List<Integer> empty = new ArrayList<Integer>(); // to record index of empty word\\n        root = new TrieNode();\\n        \\n        for (int i = 0; i < words.length; i++) { // O(n*len*len)\\n            if (words[i].length() == 0) {\\n                empty.add(i);\\n                continue;\\n            }\\n            insert(words[i], i);\\n        }\\n        \\n        for (int i = 0; i < words.length; i++) { // (n*len)\\n            search(words[i], list, i, empty);\\n        }\\n        return list;\\n    }\\n    \\n    private void search(String word, List<List<Integer>> list, int idx, List<Integer> empty) {\\n        char[] wd = word.toCharArray();\\n        TrieNode cur = root;\\n        \\n        for (int i = wd.length - 1; i >= 0; i--) { // O(len)\\n            int pt = wd[i] - 'a';\\n            if (cur.index != -1 && isPalin(wd, 0, i)) { // prefix is palin, \"cur.index != -1\" means the end of a word\\n                List<Integer> li = new ArrayList<Integer>();\\n                li.add(cur.index);\\n                li.add(idx);\\n                list.add(li);\\n            }\\n            if (cur.children[pt] == null) return; // nothing to compare for the next step\\n            cur = cur.children[pt];\\n        }\\n        \\n        if (cur.ids.size() != 0) { // suffix is palin \\n            for (Integer in : cur.ids) {\\n                if (in != idx) {\\n                    List<Integer> li = new ArrayList<Integer>();\\n                    li.add(in);\\n                    li.add(idx);\\n                    list.add(li);\\n                } else {\\n                    for (Integer em : empty) {\\n                        List<Integer> li = new ArrayList<Integer>();\\n                        li.add(em);\\n                        li.add(idx);\\n                        list.add(li);\\n                        li = new ArrayList<Integer>();\\n                        li.add(idx);\\n                        li.add(em);\\n                        list.add(li);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    private void insert(String word, int idx) { // O(len*len)\\n        char[] wd = word.toCharArray();\\n        TrieNode cur = root;\\n        \\n        for (int i = 0; i < wd.length; i++) {\\n            int pt = wd[i] - 'a';\\n            if (cur.children[pt] == null) {\\n                cur.children[pt] = new TrieNode();\\n            }\\n            cur = cur.children[pt];\\n            if (i == wd.length - 1) {\\n                cur.index = idx;\\n            }\\n            if (isPalin(wd, i + 1, wd.length - 1)) {\\n                cur.ids.add(idx);\\n            }\\n        }\\n    }\\n    \\n    private boolean isPalin(char[] str, int i, int j) {\\n        while (j - i > 0) {\\n            if (str[i++] != str[j--]) return false;\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    class TrieNode {\\n        TrieNode[] children;\\n        ArrayList<Integer> ids;\\n        int index; // index of current word\\n        public TrieNode() {\\n            this.children = new TrieNode[26];\\n            this.ids = new ArrayList<Integer>();\\n            this.index = -1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 79283,
                "title": "accepted-javascript-solution-using-hashmap",
                "content": "For the first time, I used **String.split('').reverse().join('')** to do reverse on 'reversedPrefix' and 'reversedSuffix' every turn in the loop of words[i], but this got TLE. So I try doing reverse by myself and finally get accepted.\\n  \\n    /**\\n     * @param {string[]} words\\n     * @return {number[][]}\\n     */\\n    var palindromePairs = function (words) {\\n      var i, j, wordLength, prefix, suffix, reversedPrefix, reversedSuffix;\\n      var dict = {};\\n      var result = [];\\n      var length = words.length;\\n    \\n      if (!words || length === 0) {\\n        return [];\\n      }\\n    \\n      for (i = 0; i < length; i += 1) {\\n        dict[words[i]] = i;\\n      }\\n    \\n      for (i = 0; i < length; i += 1) {\\n        wordLength = words[i].length;\\n \\n        prefix = '';\\n        suffix = words[i];\\n        reversedPrefix = '';\\n        reversedSuffix = suffix.split('').reverse().join('');\\n\\n        for (j = 0; j < wordLength + 1; j += 1) {\\n          if (j !== 0) {\\n            prefix += words[i][j - 1];\\n            suffix = suffix.slice(1);\\n            reversedPrefix = words[i][j - 1] + reversedPrefix;\\n            reversedSuffix = reversedSuffix.slice(0, reversedSuffix.length - 1);\\n          }\\n\\n          if (j !== 0 && prefix === reversedPrefix && reversedSuffix in dict && dict[reversedSuffix] !== i) {\\n            result.push([dict[reversedSuffix], i]);\\n          }\\n\\n          if (suffix === reversedSuffix && reversedPrefix in dict && dict[reversedPrefix] !== i) {\\n            result.push([i, dict[reversedPrefix]]);\\n          }\\n        }\\n      }\\n      return result;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "For the first time, I used **String.split('').reverse().join('')** to do reverse on 'reversedPrefix' and 'reversedSuffix' every turn in the loop of words[i], but this got TLE. So I try doing reverse by myself and finally get accepted.\\n  \\n    /**\\n     * @param {string[]} words\\n     * @return {number[][]}\\n     */\\n    var palindromePairs = function (words) {\\n      var i, j, wordLength, prefix, suffix, reversedPrefix, reversedSuffix;\\n      var dict = {};\\n      var result = [];\\n      var length = words.length;\\n    \\n      if (!words || length === 0) {\\n        return [];\\n      }\\n    \\n      for (i = 0; i < length; i += 1) {\\n        dict[words[i]] = i;\\n      }\\n    \\n      for (i = 0; i < length; i += 1) {\\n        wordLength = words[i].length;\\n \\n        prefix = '';\\n        suffix = words[i];\\n        reversedPrefix = '';\\n        reversedSuffix = suffix.split('').reverse().join('');\\n\\n        for (j = 0; j < wordLength + 1; j += 1) {\\n          if (j !== 0) {\\n            prefix += words[i][j - 1];\\n            suffix = suffix.slice(1);\\n            reversedPrefix = words[i][j - 1] + reversedPrefix;\\n            reversedSuffix = reversedSuffix.slice(0, reversedSuffix.length - 1);\\n          }\\n\\n          if (j !== 0 && prefix === reversedPrefix && reversedSuffix in dict && dict[reversedSuffix] !== i) {\\n            result.push([dict[reversedSuffix], i]);\\n          }\\n\\n          if (suffix === reversedSuffix && reversedPrefix in dict && dict[reversedPrefix] !== i) {\\n            result.push([i, dict[reversedPrefix]]);\\n          }\\n        }\\n      }\\n      return result;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 79277,
                "title": "11-line-python-solution-easy-to-understand-mix-all-words-all-reversed-words-then-use-common-prefix",
                "content": "Sort all words and all reversed words. One word (call it `A`) is the prefix of the following words (call it `B`). If `A` is `B`'s prefix and one is reversed one is not, and their indexes are different, then we find a palindrome pair.\\n\\n    def palindromePairs(self, words):\\n        # 0 means the word is not reversed, 1 means the word is reversed\\n        words, length, result = sorted([(w, 0, i, len(w)) for i, w in enumerate(words)] +\\n                                       [(w[::-1], 1, i, len(w)) for i, w in enumerate(words)]), len(words) * 2, []\\n        for i, (word1, rev1, ind1, len1) in enumerate(words):\\n            for j in xrange(i + 1, length):\\n                word2, rev2, ind2, _ = words[j]\\n                if word2.startswith(word1):\\n                    if ind1 != ind2 and rev1 ^ rev2:\\n                        rest = word2[len1:]\\n                        if rest == rest[::-1]: result += ([ind1, ind2],) if rev2 else ([ind2, ind1],)\\n                else:\\n                    break\\n        return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "Sort all words and all reversed words. One word (call it `A`) is the prefix of the following words (call it `B`). If `A` is `B`'s prefix and one is reversed one is not, and their indexes are different, then we find a palindrome pair.\\n\\n    def palindromePairs(self, words):\\n        # 0 means the word is not reversed, 1 means the word is reversed\\n        words, length, result = sorted([(w, 0, i, len(w)) for i, w in enumerate(words)] +\\n                                       [(w[::-1], 1, i, len(w)) for i, w in enumerate(words)]), len(words) * 2, []\\n        for i, (word1, rev1, ind1, len1) in enumerate(words):\\n            for j in xrange(i + 1, length):\\n                word2, rev2, ind2, _ = words[j]\\n                if word2.startswith(word1):\\n                    if ind1 != ind2 and rev1 ^ rev2:\\n                        rest = word2[len1:]\\n                        if rest == rest[::-1]: result += ([ind1, ind2],) if rev2 else ([ind2, ind1],)\\n                else:\\n                    break\\n        return result",
                "codeTag": "Python3"
            },
            {
                "id": 2811711,
                "title": "trie-easy-explaination-how-to-avoid-tle-c-solution",
                "content": "- A lot of people are frustated with TLE errors (especially for last 2 test cases 135th and 136th)\\n- Consistent TLEs made me doubt if my Trie approach was even worth doing\\n- But it is indeed okay if some care is taken\\n- Added word in Trie is referred to as a stored word, the words that are then searched for in the trie are referred to as search key.\\n\\n#### Basic approach \\n- Reverse all words and insert in a trie.\\n- Then search with normal (unreversed) words. If a match is made, then that means the reverse of one word and normal order of other word are equal i.e the concatenation can form a palindrome. Add this pair in final answer. (For order, the search key (i.e unreversed word) will come first and the existing key stored in trie will come later because a search key i - \"abcd\" matching j - \"abcd\" stored in trie means  that j was \"dcba\" and was reversed and then stored so i + j i.e abcd + dcba are forming palindrome ).\\n\\n### Special cases\\n- It is not difficult to observe that a palindrome can be formed by not just pairs like \"abcd\" & \"dcba\", but by other cases too. \"abcd**txt**\" & \"dcba\" are also forming palindrome. This means that \"dcba\" will be reversed and stored as \"abcd\" .The search key \"abcd**txt**\" will match with this stored word only upto some length. So we need to check at all terminal nodes (i.e the nodes where a word is ending:  \"d\" for \"abcd\" in this case )that the remainng part of the search key \"**txt**\" might itself be a palindrome so we need to consider this pair also.\\n- By similar logic, we look at other case. \"abcd\" & \"**txt**dcba\" also form a palindrome. \"txtdcba\" will be reversed and stored as \"abcd**txt**\". In this case the search key \"abcd\" will totatlly match with word in trie, but the node might not be a terminal node. So at every node we need to know that even if we are stopping the comparison, the word in the trie might have palindromes ahead. For instance the search key i - \"abcd\" might exhaust at \"abcd\" in trie and we might think that since d is not terminal, no pair has been found. But \"abcd\" in trie might lead to j - \"abcd**txt**\" & k -\"abcd**fbhbf**\". Both of which are valid pairs with our search key. So we need to store about j & k at node \"d\" itself, so that once we stop comparsion, we can just use values i,j & i,k from node \"d\" only.\\n- What the previous two points mean is that while adding in trie, we need to check at each inserted node if remaining string is a palindrom and store the index in curent node itself if remaining string is a palindrome. Similarly, while searching also, if we see a terminal node for a word, then we can check if our remaining search key is a palindrome or not and add that pair.\\n\\n#### Storage Structure\\n- Each node should store whether it is terminal or not (like all tries).\\n- If terminal, then index(id) of word ending at this node needs to be stored\\n- Also an array(list) of all indexes(id\\'s) of words that follow and have remaining string as palindrome needs to be stored at current node.\\n\\n### Avoiding TLE\\n\\n- Basic one - Don\\'t use recursion for inserting/searching in Trie, use iteration to avoid function calls.\\n- Dont actually reverse the strings to insert, since that itself will be time consuming. Just start from length -1 and go to 0 as we insert.\\n- Dont pass by value, as it leads to copying of values, pass references instead.\\n\\nSimple code but with TLE - **Dont waste time reading**\\n\\n```\\nbool isPalFun(string word)\\n{\\n    int n = word.length();\\n    for(int i = 0; i<n/2; i++)\\n    {\\n        if(word[i] != word[n-1-i])\\n            return false;\\n    }\\n    return true;\\n};\\n\\nclass Node{\\n    public:\\n    bool isTerminal;\\n    int terminalIndex;\\n    vector<int> * Pals;\\n    Node ** children;\\n    \\n    Node()\\n    {\\n        isTerminal = false;\\n        Pals = new vector<int>();\\n        \\n        children = new Node*[26];\\n        for(int i = 0; i<26; i++)\\n            children[i] = NULL;\\n    }\\n};\\nclass Solution {\\n    Node* root;\\npublic:\\n    Solution()\\n    {\\n        root = new Node();\\n    }\\n    void insert(Node *root, string word, int index)\\n    {\\n        if(word.length() == 0)\\n        {\\n            root->terminalIndex = index;\\n            root->isTerminal = true;\\n            return;\\n        }\\n        \\n        if(isPalFun(word))  // while inserting, check for each node\\n        {\\n            root->Pals->push_back(index);\\n        }\\n        \\n        if(root->children[word[0]-\\'a\\'] == NULL)\\n            root->children[word[0] - \\'a\\'] = new Node();\\n        \\n        insert(root->children[word[0] - \\'a\\'], word.substr(1),index);\\n    }\\n    vector<vector<int>> search(Node * root, string word, int index)\\n    {\\n        if(root == NULL)\\n        {\\n           vector<vector<int>> ans;\\n            return ans;\\n        }\\n        if(word.length() == 0)\\n        {\\n           vector<vector<int>> ans;\\n            if(root->isTerminal)\\n            {\\n                if(root->terminalIndex != index)\\n                {\\n                    vector<int> v{index, root->terminalIndex};\\n                    ans.push_back(v);\\n                }\\n            }\\n            \\n            for(int p : *(root->Pals))\\n            {\\n                if(p != index)\\n                {\\n                    vector<int> v{index, p};\\n                    ans.push_back(v);\\n                }\\n            }\\n            \\n            return ans;\\n        }\\n        \\n        vector<vector<int>> smallAns = search(root->children[word[0] - \\'a\\'], word.substr(1), index);\\n        \\n        if(root->isTerminal)\\n        {\\n            if(isPalFun(word))\\n            {\\n               vector<int> v{index, root->terminalIndex};\\n                smallAns.push_back(v); \\n            }\\n        }\\n        \\n        return smallAns;\\n    }\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        vector<vector<int>> ans;\\n        for(int i = 0; i<words.size(); i++)\\n        {\\n            string rev = words[i];\\n            reverse(rev.begin(), rev.end());\\n            insert(root, rev, i);\\n        }\\n        for(int i = 0; i<words.size(); i++)\\n        {\\n            auto a = search(root, words[i], i);\\n            for(int j = 0; j<a.size(); j++)\\n                ans.push_back(a[j]);\\n        }\\n        return ans;\\n    }\\n};\\n``` \\n### Accepted code without TLE\\n\\n```\\nbool isPal(string &s,int i, int j)\\n{\\n    while(j > i)\\n    {\\n        if(s[i++] != s[j--])\\n            return false;\\n    }\\n    return true;\\n}\\n\\nclass Node{\\npublic:\\n    Node ** children;\\n    int index;\\n    vector<int> pals;  // for storing indexes of those words that have remaining substring as palindrome after this node.\\n    Node()\\n    {\\n        children = new Node*[26];\\n        for(int i = 0; i<26; i++)\\n            children[i] = NULL;\\n        \\n        index = -1;\\n    }\\n};\\n\\nclass Solution {\\n    Node* root;\\npublic:\\n    Solution()\\n    {\\n        root = new Node();\\n    }\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        int n = words.size();\\n        \\n        // ADD reverse of all words into trie\\n        for(int i = 0; i<n; i++)\\n        {\\n            Node* cur = root;\\n            for(int j = words[i].length() -1; j >= 0; j--)  // j starts from end and goes to 0 bcz reverse string added.\\n            {\\n                if(!(cur->children[words[i][j] - \\'a\\']))  // declare if child node doesn\\'t exist\\n                    cur->children[words[i][j] - \\'a\\'] = new Node();\\n                \\n                if(isPal(words[i],0,j))     // store index in current node if remaining string is a palindrome\\n                    cur->pals.push_back(i);\\n                \\n                cur = cur->children[words[i][j] - \\'a\\'];\\n            }\\n            \\n            cur->index = i;         // mark the node is terminal by changing index from -1 to actual index\\n            cur->pals.push_back(i);\\n        }\\n        \\n        vector<vector<int>> ans;\\n        \\n        // now search for all words\\n        for(int i = 0; i<n; i++)\\n        {\\n            Node *cur = root;\\n            for(int j = 0; j< words[i].length; j++)\\n            {\\n                if(cur->index != -1)   // we are at terminal node\\n                    if(cur->index != i)   // bcz we dont want i,i pair to get added\\n                        if(isPal(words[i], j, words[i].length()-1))  // means stored word has ended, and the remainng search key is a palindrome\\n                            ans.push_back({i, cur->index});\\n                \\n\\t\\t\\t\\tcur = cur->children[words[i][j] - \\'a\\'];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(cur == NULL)\\n\\t\\t\\t\\t\\tbreak;\\n            }\\n            \\n            if(cur != NULL)\\n\\t\\t\\t {\\n\\t\\t\\t\\tfor(int e : cur->pals)  // the search key has ended, now simply add word indexes that have some palidrome string remaining ahead of this node.\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(i != e)\\n\\t\\t\\t\\t\\t\\tans.push_back({i, e});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n        return ans;\\n    }\\n};\\n```\\n\\nFeel free to ask any doubts, thanks to @kiranpalsingh1806 for help.\\n\\n",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nbool isPalFun(string word)\\n{\\n    int n = word.length();\\n    for(int i = 0; i<n/2; i++)\\n    {\\n        if(word[i] != word[n-1-i])\\n            return false;\\n    }\\n    return true;\\n};\\n\\nclass Node{\\n    public:\\n    bool isTerminal;\\n    int terminalIndex;\\n    vector<int> * Pals;\\n    Node ** children;\\n    \\n    Node()\\n    {\\n        isTerminal = false;\\n        Pals = new vector<int>();\\n        \\n        children = new Node*[26];\\n        for(int i = 0; i<26; i++)\\n            children[i] = NULL;\\n    }\\n};\\nclass Solution {\\n    Node* root;\\npublic:\\n    Solution()\\n    {\\n        root = new Node();\\n    }\\n    void insert(Node *root, string word, int index)\\n    {\\n        if(word.length() == 0)\\n        {\\n            root->terminalIndex = index;\\n            root->isTerminal = true;\\n            return;\\n        }\\n        \\n        if(isPalFun(word))  // while inserting, check for each node\\n        {\\n            root->Pals->push_back(index);\\n        }\\n        \\n        if(root->children[word[0]-\\'a\\'] == NULL)\\n            root->children[word[0] - \\'a\\'] = new Node();\\n        \\n        insert(root->children[word[0] - \\'a\\'], word.substr(1),index);\\n    }\\n    vector<vector<int>> search(Node * root, string word, int index)\\n    {\\n        if(root == NULL)\\n        {\\n           vector<vector<int>> ans;\\n            return ans;\\n        }\\n        if(word.length() == 0)\\n        {\\n           vector<vector<int>> ans;\\n            if(root->isTerminal)\\n            {\\n                if(root->terminalIndex != index)\\n                {\\n                    vector<int> v{index, root->terminalIndex};\\n                    ans.push_back(v);\\n                }\\n            }\\n            \\n            for(int p : *(root->Pals))\\n            {\\n                if(p != index)\\n                {\\n                    vector<int> v{index, p};\\n                    ans.push_back(v);\\n                }\\n            }\\n            \\n            return ans;\\n        }\\n        \\n        vector<vector<int>> smallAns = search(root->children[word[0] - \\'a\\'], word.substr(1), index);\\n        \\n        if(root->isTerminal)\\n        {\\n            if(isPalFun(word))\\n            {\\n               vector<int> v{index, root->terminalIndex};\\n                smallAns.push_back(v); \\n            }\\n        }\\n        \\n        return smallAns;\\n    }\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        vector<vector<int>> ans;\\n        for(int i = 0; i<words.size(); i++)\\n        {\\n            string rev = words[i];\\n            reverse(rev.begin(), rev.end());\\n            insert(root, rev, i);\\n        }\\n        for(int i = 0; i<words.size(); i++)\\n        {\\n            auto a = search(root, words[i], i);\\n            for(int j = 0; j<a.size(); j++)\\n                ans.push_back(a[j]);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nbool isPal(string &s,int i, int j)\\n{\\n    while(j > i)\\n    {\\n        if(s[i++] != s[j--])\\n            return false;\\n    }\\n    return true;\\n}\\n\\nclass Node{\\npublic:\\n    Node ** children;\\n    int index;\\n    vector<int> pals;  // for storing indexes of those words that have remaining substring as palindrome after this node.\\n    Node()\\n    {\\n        children = new Node*[26];\\n        for(int i = 0; i<26; i++)\\n            children[i] = NULL;\\n        \\n        index = -1;\\n    }\\n};\\n\\nclass Solution {\\n    Node* root;\\npublic:\\n    Solution()\\n    {\\n        root = new Node();\\n    }\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        int n = words.size();\\n        \\n        // ADD reverse of all words into trie\\n        for(int i = 0; i<n; i++)\\n        {\\n            Node* cur = root;\\n            for(int j = words[i].length() -1; j >= 0; j--)  // j starts from end and goes to 0 bcz reverse string added.\\n            {\\n                if(!(cur->children[words[i][j] - \\'a\\']))  // declare if child node doesn\\'t exist\\n                    cur->children[words[i][j] - \\'a\\'] = new Node();\\n                \\n                if(isPal(words[i],0,j))     // store index in current node if remaining string is a palindrome\\n                    cur->pals.push_back(i);\\n                \\n                cur = cur->children[words[i][j] - \\'a\\'];\\n            }\\n            \\n            cur->index = i;         // mark the node is terminal by changing index from -1 to actual index\\n            cur->pals.push_back(i);\\n        }\\n        \\n        vector<vector<int>> ans;\\n        \\n        // now search for all words\\n        for(int i = 0; i<n; i++)\\n        {\\n            Node *cur = root;\\n            for(int j = 0; j< words[i].length; j++)\\n            {\\n                if(cur->index != -1)   // we are at terminal node\\n                    if(cur->index != i)   // bcz we dont want i,i pair to get added\\n                        if(isPal(words[i], j, words[i].length()-1))  // means stored word has ended, and the remainng search key is a palindrome\\n                            ans.push_back({i, cur->index});\\n                \\n\\t\\t\\t\\tcur = cur->children[words[i][j] - \\'a\\'];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(cur == NULL)\\n\\t\\t\\t\\t\\tbreak;\\n            }\\n            \\n            if(cur != NULL)\\n\\t\\t\\t {\\n\\t\\t\\t\\tfor(int e : cur->pals)  // the search key has ended, now simply add word indexes that have some palidrome string remaining ahead of this node.\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(i != e)\\n\\t\\t\\t\\t\\t\\tans.push_back({i, e});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589144,
                "title": "java-hashing-explained",
                "content": "**Idea:**\\n* There are 3 ways to form Palindrome Pairs (PP)\\n\\t* **Case 1:** \\n\\t\\t* Concatenate an empty string to a palindrome. \\n\\t\\t* This will generate 2 strings because empty can be concatenated at either end. \\n\\t\\t* `words` must have a palindrome and an empty string for this case to occur\\n\\t\\t* E.g.: \"\" + \"aba\" = \"aba\", \"aba\" + \"\" = \"aba\"\\n\\t* **Case 2:** \\n\\t\\t* Append a string to its reverse. \\n\\t\\t* `words` must contain the reverse of the word for this case to occur\\n\\t\\t* E.g.: \"abcd\" + \"dcba\" = \"abcddcba\"\\n\\t* **Case 3:** \\n\\t\\t* If a word can be split in 2 parts such that:\\n\\t\\t\\t* the first half\\'s reverse (R) exists in `words` and the second half is a palindrome. Then this word can be concatenated with R to form a palindrome.\\n\\t\\t\\t* E.g.: words = [\"ab\", \"a\"]. \"ab\" can be split into \"a\", \"b\". Reverse of \"a\" exists in `words` and \"b\" is a palindrome. So \"ab\" +\"a\" = \"aba\" is a palindrome\\n\\t\\t* Similarly, \\n\\t\\t\\t* the second half\\'s reverse exists in `words` and the first half is a palindrome. Then R can be concatenated with this word to form a palindrome.\\n\\t\\t\\t* E.g.: words = [\"lls\", \"s\"]. \"lls\" can be split into \"ll\", \"s\". Reverse of \"s\" exists in `words` and \"ll\" is a palindrome. So \"s\" +\"lls\" = \"slls\" is a palindrome.\\n>**T/S:** O(nw\\xB2)/O(nw\\xB2), where n = size(words), w = average size(words[i])\\n```\\n/**\\n * @param words array of unique words\\n * @return all the pairs of the distinct indices (i, j) in words, so that the concatenation of words[i] + words[j]\\n * is a palindrome\\n */\\npublic List<List<Integer>> palindromePairs(String[] words) {\\n\\tvar pairs = new ArrayList<List<Integer>>();\\n\\tvar reverseIndex = getReverseIndex(words);\\n\\taddEmptyAndPalindromes(words, pairs, reverseIndex);\\n\\taddReverses(words, pairs, reverseIndex);\\n\\taddSplits(words, pairs, reverseIndex);\\n\\treturn pairs;\\n}\\n\\n/**\\n * T/S: O(nw)/O(nw), where n = size(words), w = avg_size(words[i])\\n *\\n * @param words array of words\\n * @return a map of reverse words to their indices\\n */\\nprivate Map<String, Integer> getReverseIndex(String[] words) {\\n\\tvar reverseIndex = new HashMap<String, Integer>();\\n\\tfor (var i = 0; i < words.length; i++)\\n\\t\\treverseIndex.put(new StringBuilder(words[i]).reverse().toString(), i);\\n\\treturn reverseIndex;\\n}\\n\\n/**\\n * Case 1\\n * T/S: O(nw)/O(n), where n = size(words), w = avg_size(words[i])\\n */\\nprivate void addEmptyAndPalindromes(String[] words, List<List<Integer>> pairs, Map<String, Integer> reverseIndex) {\\n\\tvar i = reverseIndex.getOrDefault(\"\", -1);\\n\\tif (i == -1)\\n\\t\\treturn;\\n\\tfor (var j = 0; j < words.length; j++)\\n\\t\\tif (j != i && isPalindrome(words[j])) {\\n\\t\\t\\tpairs.add(List.of(i, j));\\n\\t\\t\\tpairs.add(List.of(j, i));\\n\\t\\t}\\n}\\n\\n/**\\n * Case 2\\n * T/S: O(n)/O(n), where n = size(words), w = avg_size(words[i])\\n */\\nprivate void addReverses(String[] words, List<List<Integer>> pairs, Map<String, Integer> reverseIndex) {\\n\\tfor (int i = 0; i < words.length; i++) {\\n\\t\\tvar j = reverseIndex.getOrDefault(words[i], -1);\\n\\t\\tif (i != j && j != -1)\\n\\t\\t\\tpairs.add(List.of(i, j));\\n\\t}\\n}\\n\\n/**\\n * Case 3\\n * T/S: O(nw\\xB2)/O(nw\\xB2), where n = size(words), w = avg_size(words[i])\\n */\\nprivate void addSplits(String[] words, List<List<Integer>> pairs, Map<String, Integer> reverseIndex) {\\n\\tfor (var i = 0; i < words.length; i++) {\\n\\t\\tvar word = words[i];\\n\\n\\t\\tfor (var j = 1; j < word.length(); j++) {\\n\\t\\t\\tvar left = word.substring(0, j);\\n\\t\\t\\tvar right = word.substring(j);\\n\\n\\t\\t\\tif (reverseIndex.containsKey(right) && isPalindrome(left))\\n\\t\\t\\t\\tpairs.add(List.of(reverseIndex.get(right), i));\\n\\t\\t\\tif (reverseIndex.containsKey(left) && isPalindrome(right))\\n\\t\\t\\t\\tpairs.add(List.of(i, reverseIndex.get(left)));\\n\\t\\t}\\n\\t}\\n}\\n\\n/**\\n * T/S: O(w)/O(1), where w = size(s)\\n *\\n * @param s string\\n * @return true if the string is a palindrome, else false\\n */\\nprivate boolean isPalindrome(String s) {\\n\\tfor (int i = 0, j = s.length() - 1; i < j; i++, j--)\\n\\t\\tif (s.charAt(i) != s.charAt(j))\\n\\t\\t\\treturn false;\\n\\treturn true;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * @param words array of unique words\\n * @return all the pairs of the distinct indices (i, j) in words, so that the concatenation of words[i] + words[j]\\n * is a palindrome\\n */\\npublic List<List<Integer>> palindromePairs(String[] words) {\\n\\tvar pairs = new ArrayList<List<Integer>>();\\n\\tvar reverseIndex = getReverseIndex(words);\\n\\taddEmptyAndPalindromes(words, pairs, reverseIndex);\\n\\taddReverses(words, pairs, reverseIndex);\\n\\taddSplits(words, pairs, reverseIndex);\\n\\treturn pairs;\\n}\\n\\n/**\\n * T/S: O(nw)/O(nw), where n = size(words), w = avg_size(words[i])\\n *\\n * @param words array of words\\n * @return a map of reverse words to their indices\\n */\\nprivate Map<String, Integer> getReverseIndex(String[] words) {\\n\\tvar reverseIndex = new HashMap<String, Integer>();\\n\\tfor (var i = 0; i < words.length; i++)\\n\\t\\treverseIndex.put(new StringBuilder(words[i]).reverse().toString(), i);\\n\\treturn reverseIndex;\\n}\\n\\n/**\\n * Case 1\\n * T/S: O(nw)/O(n), where n = size(words), w = avg_size(words[i])\\n */\\nprivate void addEmptyAndPalindromes(String[] words, List<List<Integer>> pairs, Map<String, Integer> reverseIndex) {\\n\\tvar i = reverseIndex.getOrDefault(\"\", -1);\\n\\tif (i == -1)\\n\\t\\treturn;\\n\\tfor (var j = 0; j < words.length; j++)\\n\\t\\tif (j != i && isPalindrome(words[j])) {\\n\\t\\t\\tpairs.add(List.of(i, j));\\n\\t\\t\\tpairs.add(List.of(j, i));\\n\\t\\t}\\n}\\n\\n/**\\n * Case 2\\n * T/S: O(n)/O(n), where n = size(words), w = avg_size(words[i])\\n */\\nprivate void addReverses(String[] words, List<List<Integer>> pairs, Map<String, Integer> reverseIndex) {\\n\\tfor (int i = 0; i < words.length; i++) {\\n\\t\\tvar j = reverseIndex.getOrDefault(words[i], -1);\\n\\t\\tif (i != j && j != -1)\\n\\t\\t\\tpairs.add(List.of(i, j));\\n\\t}\\n}\\n\\n/**\\n * Case 3\\n * T/S: O(nw\\xB2)/O(nw\\xB2), where n = size(words), w = avg_size(words[i])\\n */\\nprivate void addSplits(String[] words, List<List<Integer>> pairs, Map<String, Integer> reverseIndex) {\\n\\tfor (var i = 0; i < words.length; i++) {\\n\\t\\tvar word = words[i];\\n\\n\\t\\tfor (var j = 1; j < word.length(); j++) {\\n\\t\\t\\tvar left = word.substring(0, j);\\n\\t\\t\\tvar right = word.substring(j);\\n\\n\\t\\t\\tif (reverseIndex.containsKey(right) && isPalindrome(left))\\n\\t\\t\\t\\tpairs.add(List.of(reverseIndex.get(right), i));\\n\\t\\t\\tif (reverseIndex.containsKey(left) && isPalindrome(right))\\n\\t\\t\\t\\tpairs.add(List.of(i, reverseIndex.get(left)));\\n\\t\\t}\\n\\t}\\n}\\n\\n/**\\n * T/S: O(w)/O(1), where w = size(s)\\n *\\n * @param s string\\n * @return true if the string is a palindrome, else false\\n */\\nprivate boolean isPalindrome(String s) {\\n\\tfor (int i = 0, j = s.length() - 1; i < j; i++, j--)\\n\\t\\tif (s.charAt(i) != s.charAt(j))\\n\\t\\t\\treturn false;\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2587830,
                "title": "improved-brute-force-solution-without-trie-using-bit-manipulation",
                "content": "My solution is basically the brute-force solution with a handful of effective optimizations. They not only avoids TLE, but **one of the submissions reached the 75th percentile**. Here they are:\\n\\n##### 1. Using char[]\\nSpecifically for Java, I use char[] instead of String to avoid calling charAt; that optimization sacrifices memory in favor of time, but in other languages, it may not matter.\\n\\n##### 2. Avoid concatenating strings\\nVerifying if two strings are palindromes the usual way would require concatenating the strings, which is costly. So I use an algorithm in method `isPalindromeConcat` that changes references instead of using concatenation.\\n\\n##### 3. Cut-off pairs of words that can\\'t form a palindrome when merged\\nMerging two strings s1 and s2 results in a string s3 where the count of each letter in s3 is the sum of the count of each letter in s1 and the count of each letter in s2. Some merges of \"abc\" and \"de\", for example, would result in \"abcde\", \"abdce\", \"edcba\", among others. \"abcde\" is a particular case of merge, the well-known concatenation.\\n\\nAnother optimization is to verify if the merge of two strings (for which concatenation is a particular case) would never result in a palindrome. In a palindrome string, the number of occurrences of each letter must be even except for at most one of the letters. So, given two words s1 and s2, let\\'s count the number of occurrences of the string that results from the merging of s1 and s2. If there\\'s more than one letter for which the number of occurrences is odd, then no merging of those two strings (including concatenation), could result in a palindrome string.\\n\\nTo implement that verification, instead of using a map (or an array) to store the number of occurrences, as the alphabet contains 26 letters, I\\'ve chosen encode the relevant information using a 32-bit integer and each bit of this integer encodes if the number of occurrences of a letter is even (if it\\'s 0) or odd (if it\\'s 1). So 0 means all number of occurrences is even. 1 means the number of occurrences of all letters is even, except for \\'a\\'. 11 (1011 on base 2) means that the number of occurrences is even for all letters is even except for letters \\'d\\', \\'b\\' and \\'a\\'. You get the ideia, hopefully.\\n\\nThe XOR operation turns out to be useful to keep the parity information of the count. If the count starts, as 0 which means even. If a occurrence is added, `0^1` results in 1, which means odd. If the count is odd then `1^1` results in 0, which means even.\\n\\nWhen two pairs must be checked, the parity of the sum of the counts can be verified by XORing each bit of the encoded counts.\\n\\n| count for s1 | count for s2 | count for s1 + count for s2 |\\n| ------------ | ------------ | ----------------------------|\\n| even             | even              | even |\\n| even      | odd       | odd |\\n| odd      | even       | odd |\\n| odd      | odd       | even |\\n\\nCompare with XOR truth-table\\n\\n|a|b|a^b|\\n|-|-|-|\\n|0|0|0|\\n|0|1|1|\\n|1|0|1|\\n|1|1|0|\\n\\nSo if the XOR of two encodings is 0, then we know that all counts of occurrences is even and, so, the concatenation _can_ be a palindrome and we must verify it. The same can be said when the XOR of the two encodings has only one bit set to 1.\\n\\nIn order to verify if a given number has only one bit set, i.e., it\\'s a power of two, I reused [this Stackoverflow answer](https://stackoverflow.com/questions/51094594/how-to-check-if-exactly-one-bit-is-set-in-an-int).\\n\\nIf neither the result of the XOR is 0 or a power of 2, then we know that there\\'s more than one letter whose count is odd and so we can safely skip that pair.\\n\\n##### 4. Complexity\\nFor that version of the algorithm, I use O(w + n) of extra space, where w is the sum of the length of all strings in the `words` array. But if you don\\'t use the first optimization, then the extra space is O(n) extra space, where n is the length of words.\\n\\nRegarding time, the complexity would be O(w^2) where w is the sum of the length of all strings in the `words` array. The worst case time complexity is the same as the brute force solution, but the verification based on the count of occurrences improves the _average_ case time complexity.\\n\\n##### 5. Code\\n\\n**Java**\\n\\n```java\\npublic class Solution {\\n\\tpublic List<List<Integer>> palindromePairs(String[] words) {\\n\\t\\tList<List<Integer>> answer = new ArrayList<>();\\n\\n\\t\\tint n = words.length;\\n\\n\\t\\tif (n == 1) {\\n\\t\\t\\treturn answer;\\n\\t\\t}\\n\\n\\t\\tchar[][] words_ = new char[n][];\\n\\n\\t\\tint[] tables = new int[n];\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tint table = 0;\\n\\n\\t\\t\\tchar[] word = words[i].toCharArray();\\n\\n\\t\\t\\twords_[i] = word;\\n\\n\\t\\t\\tfor (int j = 0; j < word.length; j++) {\\n\\t\\t\\t\\ttable ^= 1 << (word[j] - \\'a\\');\\n\\t\\t\\t}\\n\\n\\t\\t\\ttables[i] = table;\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tif (i == j) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tint bits = tables[i] ^ tables[j];\\n\\n\\t\\t\\t\\tif (bits != 0 && ((bits & (bits - 1)) != 0)) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (isPalindromeConcat(words_[i], words_[j])) {\\n\\t\\t\\t\\t\\tanswer.add(List.of(i, j));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn answer;\\n\\t}\\n\\n\\tprivate boolean isPalindromeConcat(char[] s1, char[] s2) {\\n\\t\\tchar[] w1 = s1;\\n\\n\\t\\tchar[] w2 = s2;\\n\\n\\t\\tint x = 0;\\n\\n\\t\\tint y = w2.length - 1;\\n\\n\\t\\twhile (w1 != w2 || x <= y) {\\n\\t\\t\\tif (y < 0 && x == w1.length) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (y < 0) {\\n\\t\\t\\t\\tw2 = w1;\\n\\n\\t\\t\\t\\ty = w2.length - 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (x == w1.length) {\\n\\t\\t\\t\\tw1 = w2;\\n\\n\\t\\t\\t\\tx = 0;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (w1 == s2 && w2 == s1) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (w1[x] != w2[y]) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\t\\t\\t++x;\\n\\n\\t\\t\\t--y;\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\\n}\\n```\\n\\n**Javascript**\\n```javascript\\nvar palindromePairs = function(words) {\\n    const n = words.length\\n\\n    if (n === 1) {\\n        return []\\n    }\\n\\n    const ca = \\'a\\'.codePointAt()\\n\\n    const tables = words.map(word => [...word].reduce((acc, cur) => acc ^ (1 << (cur.codePointAt() - ca)), 0))\\n\\n    const answer = []\\n\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < n; j++) {\\n            if (i === j) {\\n                continue\\n            }\\n            \\n            const bits = tables[i] ^ tables[j]\\n\\n            if (bits !== 0 && ((bits & (bits - 1)) !== 0)) {\\n                continue\\n            }\\n\\n            if (isPalindromeConcat(words[i], words[j])) {\\n                answer.push([i, j])\\n            }\\n        }\\n    }\\n\\n    \\n    return answer\\n};\\n\\nfunction isPalindromeConcat(s1, s2) {\\n\\tlet w1 = s1\\n\\n\\tlet w2 = s2\\n\\n\\tlet x = 0\\n\\n\\tlet y = w2.length - 1\\n\\n\\twhile (w1 !== w2 || x <= y) {\\n\\t\\tif (y < 0 && x === w1.length) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\n\\t\\tif (y < 0) {\\n\\t\\t\\tw2 = w1\\n\\n\\t\\t\\ty = w2.length - 1\\n\\t\\t}\\n\\n\\t\\tif (x === w1.length) {\\n\\t\\t\\tw1 = w2\\n\\n\\t\\t\\tx = 0\\n\\t\\t}\\n\\n\\t\\tif (w1 === s2 && w2 === s1) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\n\\t\\tif (w1[x] !== w2[y]) {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\n\\t\\tx++\\n\\n\\t\\ty--\\n\\t}\\n\\n\\treturn true\\n}\\n```\\n\\n**Go**\\n\\n```go\\nfunc palindromePairs(words []string) [][]int {\\n\\tn := len(words)\\n\\n\\tanswer := [][]int{}\\n\\n\\tif n == 1 {\\n\\t\\treturn answer\\n\\t}\\n\\n\\ttables := make([]int, n)\\n\\n\\tfor i, word := range words {\\n\\t\\tnumber := 0\\n\\n\\t\\tfor _, c := range word {\\n\\t\\t\\tnumber ^= 1 << (c - \\'a\\')\\n\\t\\t}\\n\\n\\t\\ttables[i] = number\\n\\t}\\n\\n\\tfor i, word := range words {\\n\\t\\tfor j := i + 1; j < n; j++ {\\n\\t\\t\\tti := tables[i]\\n\\n\\t\\t\\ttj := tables[j]\\n\\n\\t\\t\\tcount := ti ^ tj\\n\\n\\t\\t\\tif count != 0 && (count&(count-1) != 0) {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\n\\t\\t\\tif isPalindromeConcat(word, words[j]) {\\n\\t\\t\\t\\tanswer = append(answer, []int{i, j})\\n\\t\\t\\t}\\n\\n\\t\\t\\tif isPalindromeConcat(words[j], word) {\\n\\t\\t\\t\\tanswer = append(answer, []int{j, i})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn answer\\n}\\n\\nfunc isPalindromeConcat(s1, s2 string) bool {\\n\\tw1 := s1\\n\\n\\tw2 := s2\\n\\n\\tx := 0\\n\\n\\ty := len(w2) - 1\\n\\n\\tfor w1 != w2 || x <= y {\\n\\t\\tif y < 0 && x == len(w1) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\n\\t\\tif y < 0 {\\n\\t\\t\\tw2 = w1\\n\\n\\t\\t\\ty = len(w2) - 1\\n\\t\\t}\\n\\n\\t\\tif x == len(w1) {\\n\\t\\t\\tw1 = w2\\n\\n\\t\\t\\tx = 0\\n\\t\\t}\\n\\n\\t\\tif w1 == s2 && w2 == s1 {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\n\\t\\tif w1[x] != w2[y] {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\n\\t\\tx++\\n\\n\\t\\ty--\\n\\t}\\n\\n\\treturn true\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "Go",
                    "Bit Manipulation"
                ],
                "code": "```java\\npublic class Solution {\\n\\tpublic List<List<Integer>> palindromePairs(String[] words) {\\n\\t\\tList<List<Integer>> answer = new ArrayList<>();\\n\\n\\t\\tint n = words.length;\\n\\n\\t\\tif (n == 1) {\\n\\t\\t\\treturn answer;\\n\\t\\t}\\n\\n\\t\\tchar[][] words_ = new char[n][];\\n\\n\\t\\tint[] tables = new int[n];\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tint table = 0;\\n\\n\\t\\t\\tchar[] word = words[i].toCharArray();\\n\\n\\t\\t\\twords_[i] = word;\\n\\n\\t\\t\\tfor (int j = 0; j < word.length; j++) {\\n\\t\\t\\t\\ttable ^= 1 << (word[j] - \\'a\\');\\n\\t\\t\\t}\\n\\n\\t\\t\\ttables[i] = table;\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tif (i == j) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tint bits = tables[i] ^ tables[j];\\n\\n\\t\\t\\t\\tif (bits != 0 && ((bits & (bits - 1)) != 0)) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (isPalindromeConcat(words_[i], words_[j])) {\\n\\t\\t\\t\\t\\tanswer.add(List.of(i, j));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn answer;\\n\\t}\\n\\n\\tprivate boolean isPalindromeConcat(char[] s1, char[] s2) {\\n\\t\\tchar[] w1 = s1;\\n\\n\\t\\tchar[] w2 = s2;\\n\\n\\t\\tint x = 0;\\n\\n\\t\\tint y = w2.length - 1;\\n\\n\\t\\twhile (w1 != w2 || x <= y) {\\n\\t\\t\\tif (y < 0 && x == w1.length) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (y < 0) {\\n\\t\\t\\t\\tw2 = w1;\\n\\n\\t\\t\\t\\ty = w2.length - 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (x == w1.length) {\\n\\t\\t\\t\\tw1 = w2;\\n\\n\\t\\t\\t\\tx = 0;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (w1 == s2 && w2 == s1) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (w1[x] != w2[y]) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\t\\t\\t++x;\\n\\n\\t\\t\\t--y;\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\\n}\\n```\n```javascript\\nvar palindromePairs = function(words) {\\n    const n = words.length\\n\\n    if (n === 1) {\\n        return []\\n    }\\n\\n    const ca = \\'a\\'.codePointAt()\\n\\n    const tables = words.map(word => [...word].reduce((acc, cur) => acc ^ (1 << (cur.codePointAt() - ca)), 0))\\n\\n    const answer = []\\n\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < n; j++) {\\n            if (i === j) {\\n                continue\\n            }\\n            \\n            const bits = tables[i] ^ tables[j]\\n\\n            if (bits !== 0 && ((bits & (bits - 1)) !== 0)) {\\n                continue\\n            }\\n\\n            if (isPalindromeConcat(words[i], words[j])) {\\n                answer.push([i, j])\\n            }\\n        }\\n    }\\n\\n    \\n    return answer\\n};\\n\\nfunction isPalindromeConcat(s1, s2) {\\n\\tlet w1 = s1\\n\\n\\tlet w2 = s2\\n\\n\\tlet x = 0\\n\\n\\tlet y = w2.length - 1\\n\\n\\twhile (w1 !== w2 || x <= y) {\\n\\t\\tif (y < 0 && x === w1.length) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\n\\t\\tif (y < 0) {\\n\\t\\t\\tw2 = w1\\n\\n\\t\\t\\ty = w2.length - 1\\n\\t\\t}\\n\\n\\t\\tif (x === w1.length) {\\n\\t\\t\\tw1 = w2\\n\\n\\t\\t\\tx = 0\\n\\t\\t}\\n\\n\\t\\tif (w1 === s2 && w2 === s1) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\n\\t\\tif (w1[x] !== w2[y]) {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\n\\t\\tx++\\n\\n\\t\\ty--\\n\\t}\\n\\n\\treturn true\\n}\\n```\n```go\\nfunc palindromePairs(words []string) [][]int {\\n\\tn := len(words)\\n\\n\\tanswer := [][]int{}\\n\\n\\tif n == 1 {\\n\\t\\treturn answer\\n\\t}\\n\\n\\ttables := make([]int, n)\\n\\n\\tfor i, word := range words {\\n\\t\\tnumber := 0\\n\\n\\t\\tfor _, c := range word {\\n\\t\\t\\tnumber ^= 1 << (c - \\'a\\')\\n\\t\\t}\\n\\n\\t\\ttables[i] = number\\n\\t}\\n\\n\\tfor i, word := range words {\\n\\t\\tfor j := i + 1; j < n; j++ {\\n\\t\\t\\tti := tables[i]\\n\\n\\t\\t\\ttj := tables[j]\\n\\n\\t\\t\\tcount := ti ^ tj\\n\\n\\t\\t\\tif count != 0 && (count&(count-1) != 0) {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\n\\t\\t\\tif isPalindromeConcat(word, words[j]) {\\n\\t\\t\\t\\tanswer = append(answer, []int{i, j})\\n\\t\\t\\t}\\n\\n\\t\\t\\tif isPalindromeConcat(words[j], word) {\\n\\t\\t\\t\\tanswer = append(answer, []int{j, i})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn answer\\n}\\n\\nfunc isPalindromeConcat(s1, s2 string) bool {\\n\\tw1 := s1\\n\\n\\tw2 := s2\\n\\n\\tx := 0\\n\\n\\ty := len(w2) - 1\\n\\n\\tfor w1 != w2 || x <= y {\\n\\t\\tif y < 0 && x == len(w1) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\n\\t\\tif y < 0 {\\n\\t\\t\\tw2 = w1\\n\\n\\t\\t\\ty = len(w2) - 1\\n\\t\\t}\\n\\n\\t\\tif x == len(w1) {\\n\\t\\t\\tw1 = w2\\n\\n\\t\\t\\tx = 0\\n\\t\\t}\\n\\n\\t\\tif w1 == s2 && w2 == s1 {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\n\\t\\tif w1[x] != w2[y] {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\n\\t\\tx++\\n\\n\\t\\ty--\\n\\t}\\n\\n\\treturn true\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2586755,
                "title": "c-solution-using-dictionary",
                "content": "```C#\\npublic class Solution {\\n    public IList<IList<int>> PalindromePairs(string[] words)\\n    {\\n        int count = words.Length;\\n        List<IList<int>> res = new();\\n        \\n        Dictionary<string, int> d = new ();\\n        for (int i = 0; i < words.Length; i++) d[words[i]] = i;\\n\\n        for (int i = 0; i < count; i++)\\n        {\\n            int len = words[i].Length;\\n            string reversed = Reverse(words[i]);\\n            if (d.TryGetValue(reversed, out int ans1) && ans1 != i) res.Add(new List<int>{ i, ans1 });\\n\\n            for (int j = 0; j < len; j++)\\n            {\\n                if (IsPalindrome(reversed, 0, len - 1 - j) && d.TryGetValue(reversed.Substring(len - j), out int ans2)) res.Add(new List<int>{ i, ans2 });\\n                if (IsPalindrome(reversed, j, len - 1) && d.TryGetValue(reversed.Substring(0, j), out int ans3)) res.Add(new List<int>{ ans3, i });\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    private bool IsPalindrome(string s, int lo, int hi)\\n    {\\n        while (lo < hi)\\n        {\\n            if (s[lo++] != s[hi--]) return false;\\n        }\\n\\n        return true;\\n    }\\n    \\n    private string Reverse(string text) {\\n        char[] charArray = text.ToCharArray();\\n        Array.Reverse(charArray);\\n        return new string(charArray);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```C#\\npublic class Solution {\\n    public IList<IList<int>> PalindromePairs(string[] words)\\n    {\\n        int count = words.Length;\\n        List<IList<int>> res = new();\\n        \\n        Dictionary<string, int> d = new ();\\n        for (int i = 0; i < words.Length; i++) d[words[i]] = i;\\n\\n        for (int i = 0; i < count; i++)\\n        {\\n            int len = words[i].Length;\\n            string reversed = Reverse(words[i]);\\n            if (d.TryGetValue(reversed, out int ans1) && ans1 != i) res.Add(new List<int>{ i, ans1 });\\n\\n            for (int j = 0; j < len; j++)\\n            {\\n                if (IsPalindrome(reversed, 0, len - 1 - j) && d.TryGetValue(reversed.Substring(len - j), out int ans2)) res.Add(new List<int>{ i, ans2 });\\n                if (IsPalindrome(reversed, j, len - 1) && d.TryGetValue(reversed.Substring(0, j), out int ans3)) res.Add(new List<int>{ ans3, i });\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    private bool IsPalindrome(string s, int lo, int hi)\\n    {\\n        while (lo < hi)\\n        {\\n            if (s[lo++] != s[hi--]) return false;\\n        }\\n\\n        return true;\\n    }\\n    \\n    private string Reverse(string text) {\\n        char[] charArray = text.ToCharArray();\\n        Array.Reverse(charArray);\\n        return new string(charArray);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2586672,
                "title": "dictionary-solution-with-ranges-no-trie",
                "content": "```csharp\\npublic IList<IList<int>> PalindromePairs(string[] words)\\n{\\n\\tList<IList<int>> res = new();\\n\\tvar dict = Enumerable.Range(0, words.Length).ToDictionary(x => words[x], x => x);\\n\\n\\tforeach (var (word, i) in dict)\\n\\t{\\n\\t\\tint j = 0;\\n\\t\\tstring r = string.Concat(word.Reverse());\\n\\n\\t\\tif (dict.TryGetValue(r, out j) && j != i) res.Add(new List<int>{ i, j });\\n\\n\\t\\tfor (int k = 0; k < word.Length; k++)\\n\\t\\t{\\n\\t\\t\\tif (IsPalindrome(r[..^k]) && dict.TryGetValue(r[^k..], out j)) res.Add(new List<int>{ i, j });\\n\\t\\t\\tif (IsPalindrome(r[k..]) && dict.TryGetValue(r[..k], out j)) res.Add(new List<int>{ j, i });\\n\\t\\t}\\n\\t}\\n\\n\\treturn res;\\n}\\n\\nprivate bool IsPalindrome(string s)\\n{\\n\\tint i = 0;\\n\\n\\twhile (i < s.Length / 2)\\n\\t{\\n\\t\\tif (s[i++] != s[^i]) return false;\\n\\t}\\n\\n\\treturn true;\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic IList<IList<int>> PalindromePairs(string[] words)\\n{\\n\\tList<IList<int>> res = new();\\n\\tvar dict = Enumerable.Range(0, words.Length).ToDictionary(x => words[x], x => x);\\n\\n\\tforeach (var (word, i) in dict)\\n\\t{\\n\\t\\tint j = 0;\\n\\t\\tstring r = string.Concat(word.Reverse());\\n\\n\\t\\tif (dict.TryGetValue(r, out j) && j != i) res.Add(new List<int>{ i, j });\\n\\n\\t\\tfor (int k = 0; k < word.Length; k++)\\n\\t\\t{\\n\\t\\t\\tif (IsPalindrome(r[..^k]) && dict.TryGetValue(r[^k..], out j)) res.Add(new List<int>{ i, j });\\n\\t\\t\\tif (IsPalindrome(r[k..]) && dict.TryGetValue(r[..k], out j)) res.Add(new List<int>{ j, i });\\n\\t\\t}\\n\\t}\\n\\n\\treturn res;\\n}\\n\\nprivate bool IsPalindrome(string s)\\n{\\n\\tint i = 0;\\n\\n\\twhile (i < s.Length / 2)\\n\\t{\\n\\t\\tif (s[i++] != s[^i]) return false;\\n\\t}\\n\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2586426,
                "title": "java-100-hashmap",
                "content": "[https://youtu.be/voOXHUTmcUM](http://)\\n```\\nclass Solution {\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        HashMap<String,Integer> wMap = new HashMap<>();\\n        Set<Integer> set = new TreeSet<>();//Sorted Set\\n        int n = words.length;\\n        \\n        for(int i=0;i<n;i++){\\n            wMap.put(words[i],i);\\n            set.add(words[i].length());\\n        }\\n        \\n        List<List<Integer>> ans = new ArrayList<>();\\n        \\n        for(int i=0;i<n;i++){\\n            int length = words[i].length();\\n            \\n            if(length ==1){\\n                if(wMap.containsKey(\"\")){\\n                    ans.add(Arrays.asList(i, wMap.get(\"\")));\\n                    ans.add(Arrays.asList(wMap.get(\"\"), i));\\n                }\\n                continue;\\n            }\\n            String reverse= new StringBuilder(words[i]).reverse().toString();\\n            if(wMap.containsKey(reverse) && wMap.get(reverse) != i)\\n                ans.add(Arrays.asList(i,wMap.get(reverse)));\\n            \\n            for(Integer k:set){\\n                if(k==length)\\n                    break;\\n                if(isPalindrome(reverse,0,length-1-k)){\\n                    String s1 = reverse.substring(length-k);\\n                    if(wMap.containsKey(s1))\\n                        ans.add(Arrays.asList(i,wMap.get(s1)));\\n                }\\n                \\n                if(isPalindrome(reverse,k,length-1)){\\n                    String s2 = reverse.substring(0,k);\\n                    if(wMap.containsKey(s2))\\n                        ans.add(Arrays.asList(wMap.get(s2),i));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private boolean isPalindrome(String s, int left, int right){\\n        while(left<right)\\n            if(s.charAt(left++)!=s.charAt(right--))\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        HashMap<String,Integer> wMap = new HashMap<>();\\n        Set<Integer> set = new TreeSet<>();//Sorted Set\\n        int n = words.length;\\n        \\n        for(int i=0;i<n;i++){\\n            wMap.put(words[i],i);\\n            set.add(words[i].length());\\n        }\\n        \\n        List<List<Integer>> ans = new ArrayList<>();\\n        \\n        for(int i=0;i<n;i++){\\n            int length = words[i].length();\\n            \\n            if(length ==1){\\n                if(wMap.containsKey(\"\")){\\n                    ans.add(Arrays.asList(i, wMap.get(\"\")));\\n                    ans.add(Arrays.asList(wMap.get(\"\"), i));\\n                }\\n                continue;\\n            }\\n            String reverse= new StringBuilder(words[i]).reverse().toString();\\n            if(wMap.containsKey(reverse) && wMap.get(reverse) != i)\\n                ans.add(Arrays.asList(i,wMap.get(reverse)));\\n            \\n            for(Integer k:set){\\n                if(k==length)\\n                    break;\\n                if(isPalindrome(reverse,0,length-1-k)){\\n                    String s1 = reverse.substring(length-k);\\n                    if(wMap.containsKey(s1))\\n                        ans.add(Arrays.asList(i,wMap.get(s1)));\\n                }\\n                \\n                if(isPalindrome(reverse,k,length-1)){\\n                    String s2 = reverse.substring(0,k);\\n                    if(wMap.containsKey(s2))\\n                        ans.add(Arrays.asList(wMap.get(s2),i));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private boolean isPalindrome(String s, int left, int right){\\n        while(left<right)\\n            if(s.charAt(left++)!=s.charAt(right--))\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585359,
                "title": "daily-leetcoding-challenge-september-day-17",
                "content": "This problem is the Daily LeetCoding Challenge for September, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/palindrome-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute force\n\n  \n**Approach 2:** Hashing\n\n  \n**Approach 3:** Using a Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/palindrome-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2552445,
                "title": "c-unordered-map-without-trie",
                "content": "```\\n/* eg-> ab   aca       ba \\n         ^   (palin)   rev-> (ab)\\n         |_ _ _  _  _  _|\\n            \\nAlgo: 1.Reverse all the word and insert in hashmap with all its indexes\\n         For each index\\n         1.find all its perfixes\\n         2.find all its corresponding suffixes\\n         3.if prefix is palindrome\\n         4.check if suffix exist in map\\n         5. result-> (]mp[suffix],idx)*/\\nclass Solution {\\npublic:\\n    bool isPalindrome(string &str)\\n    {\\n        int i=0,j=str.size()-1;\\n        while(i<j)\\n        {\\n            if(str[i]!=str[j])\\n                return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        unordered_map<string,int> mp;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            string x=words[i];\\n            reverse(x.begin(),x.end());\\n            mp[x]=i;\\n        }\\n        vector<vector<int>> res;\\n        for(int j=0;j<words.size();j++)\\n        {\\n            string str=words[j];\\n            for(int i=0;i<=str.size();i++)\\n            {\\n                string prefix=str.substr(0,i);\\n                string suffix=str.substr(i);\\n                if(!prefix.empty() and isPalindrome(prefix) and mp.count(suffix)and j!=mp[suffix])\\n                {\\n                    res.push_back({mp[suffix],j});\\n                }\\n                if(isPalindrome(suffix) and mp.count(prefix) and j!=mp[prefix] )\\n                {\\n                    res.push_back({j,mp[prefix]});\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/* eg-> ab   aca       ba \\n         ^   (palin)   rev-> (ab)\\n         |_ _ _  _  _  _|\\n            \\nAlgo: 1.Reverse all the word and insert in hashmap with all its indexes\\n         For each index\\n         1.find all its perfixes\\n         2.find all its corresponding suffixes\\n         3.if prefix is palindrome\\n         4.check if suffix exist in map\\n         5. result-> (]mp[suffix],idx)*/\\nclass Solution {\\npublic:\\n    bool isPalindrome(string &str)\\n    {\\n        int i=0,j=str.size()-1;\\n        while(i<j)\\n        {\\n            if(str[i]!=str[j])\\n                return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        unordered_map<string,int> mp;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            string x=words[i];\\n            reverse(x.begin(),x.end());\\n            mp[x]=i;\\n        }\\n        vector<vector<int>> res;\\n        for(int j=0;j<words.size();j++)\\n        {\\n            string str=words[j];\\n            for(int i=0;i<=str.size();i++)\\n            {\\n                string prefix=str.substr(0,i);\\n                string suffix=str.substr(i);\\n                if(!prefix.empty() and isPalindrome(prefix) and mp.count(suffix)and j!=mp[suffix])\\n                {\\n                    res.push_back({mp[suffix],j});\\n                }\\n                if(isPalindrome(suffix) and mp.count(prefix) and j!=mp[prefix] )\\n                {\\n                    res.push_back({j,mp[prefix]});\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918670,
                "title": "simple-js-solution-w-comments-map-trie",
                "content": "```\\n/**\\n * *Time: O(N x M^2)\\n * *Space: O(N)\\n */\\n// Runtime: 2689 ms, faster than 26.00% of JavaScript online submissions for Palindrome Pairs.\\n// Memory Usage: 88.7 MB, less than 46.00% of JavaScript online submissions for Palindrome Pairs.\\nconst palindromePairs = words => {\\n\\tconst map = new Map(); // reversed word: index\\n\\tconst output = [];\\n\\n\\tconst isPalindrome = word => {\\n\\t\\tlet L = 0;\\n\\t\\tlet R = word.length - 1;\\n\\n\\t\\twhile (L < R) {\\n\\t\\t\\tif (word[L] != word[R]) return false;\\n\\n\\t\\t\\tL++;\\n\\t\\t\\tR--;\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t};\\n\\n\\t// reverse all words and add to map => reversed word: index\\n\\tconst insertReversed = words => {\\n\\t\\tfor (let i = 0; i < words.length; i++) {\\n\\t\\t\\tconst word = words[i];\\n\\t\\t\\tlet reversed = \\'\\';\\n\\n\\t\\t\\tfor (let j = word.length - 1; j >= 0; j--) {\\n\\t\\t\\t\\treversed += word[j];\\n\\t\\t\\t}\\n\\n\\t\\t\\tmap.set(reversed, i);\\n\\t\\t}\\n\\t};\\n\\n\\t// empty string forms palindrome w/ every palindrome in the list\\n\\tconst handleEmptyString = () => {\\n\\t\\tif (map.has(\\'\\')) {\\n\\t\\t\\tfor (let i = 0; i < words.length; i++) {\\n\\t\\t\\t\\tconst idx = map.get(\\'\\');\\n\\n\\t\\t\\t\\tif (idx === i) continue;\\n\\t\\t\\t\\tif (isPalindrome(words[i])) output.push([idx, i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\t// match prefix AND suffix of current word\\n\\t// to reversed word and check if it makes a valid palindrome\\n\\tconst findPalindromes = words => {\\n\\t\\tfor (let i = 0; i < words.length; i++) {\\n\\t\\t\\tconst word = words[i];\\n\\n\\t\\t\\tfor (let j = 0; j < word.length; j++) {\\n\\t\\t\\t\\tconst prefix = word.slice(0, j);\\n\\t\\t\\t\\tconst suffix = word.slice(j);\\n\\n\\t\\t\\t\\tconst prefixIdx = map.get(prefix);\\n\\t\\t\\t\\tconst suffixIdx = map.get(suffix);\\n\\n\\t\\t\\t\\t// if prefix is palindrome: suffix + words[i]\\n\\t\\t\\t\\tif (map.has(suffix) && suffixIdx !== i) {\\n\\t\\t\\t\\t\\tconst validPrefix = isPalindrome(prefix);\\n\\n\\t\\t\\t\\t\\tif (validPrefix) output.push([suffixIdx, i]);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// if suffix is palindrome: words[i] + prefix\\n\\t\\t\\t\\tif (map.has(prefix) && prefixIdx !== i) {\\n\\t\\t\\t\\t\\tconst validSuffix = isPalindrome(suffix);\\n\\n\\t\\t\\t\\t\\tif (validSuffix) output.push([i, prefixIdx]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\tinsertReversed(words);\\n\\thandleEmptyString(map);\\n\\tfindPalindromes(words);\\n\\n\\treturn output;\\n};\\n\\n\\n\\n\\n\\n/**\\n * *Time: O(N x M^2)\\n * *Space: O((N + K)^2)\\n */\\n// Runtime: 796 ms, faster than 100.00% of JavaScript online submissions for Palindrome Pairs.\\n// Memory Usage: 128 MB, less than 36.71% of JavaScript online submissions for Palindrome Pairs.\\nconst palindromePairs = (words) => {\\n  const root = {};\\n  const output = [];\\n\\n  const isPalindrome = (word) => {\\n    let L = 0;\\n    let R = word.length - 1;\\n\\n    while (L < R) {\\n      if (word[L++] !== word[R--]) return false;\\n    }\\n\\n    return true;\\n  };\\n\\n  const insertReversed = (words) => {\\n    for (let i = 0; i < words.length; i++) {\\n      const word = words[i];\\n      let node = root;\\n\\n      for (let j = word.length - 1; j >= 0; j--) {\\n        const char = word[j];\\n\\n        if (!node[char]) node[char] = {};\\n\\n        node = node[char];\\n      }\\n\\n      node.isEnd = true;\\n      node.index = i;\\n    }\\n  };\\n\\n  // empty string forms palindrome w/ every palindrome in the list\\n  const handleEmptyString = (root) => {\\n    if (!root.isEnd) return; // if isEnd, empty string\\n\\n    for (let i = 0; i < words.length; i++) {\\n      const valid = isPalindrome(words[i]);\\n\\n      if (root.index === i) continue;\\n      if (valid) output.push([i, root.index]);\\n    }\\n  };\\n\\n  // traverse trie along given word and return last prefix node\\n\\n  // case 2: if word shorter - get last prefix node given the word and DFS to check if trie has palindromes\\n  // case 3: if word longer - check if suffix is valid palindrome, if not stop\\n  const getLastPrefixNode = (word, idx) => {\\n    let node = root;\\n\\n    for (let i = 0; i < word.length; i++) {\\n      const char = word[i];\\n\\n      // case 3: word is longer\\n      // check if rest of the word form valid palindrome\\n      if (!node[char]) return;\\n      if (node[char].isEnd && node[char].index !== idx && i < word.length - 1) {\\n        const suffix = word.slice(i + 1);\\n        const valid = isPalindrome(suffix);\\n\\n        if (valid) output.push([idx, node[char].index]);\\n      }\\n\\n      node = node[char];\\n    }\\n\\n    return node;\\n  };\\n\\n  // traverse trie starting from lastPrefixNode find valid palindromes\\n  const traverse = (node, idx, suffix) => {\\n    // case 1. same word length\\n    if (node.isEnd && node.index !== idx) {\\n      const valid = isPalindrome(suffix);\\n\\n      if (valid) output.push([idx, node.index]);\\n    }\\n\\n    // case 2. word is shorter\\n    // traverse trie until valid match found\\n    for (const key in node) {\\n      traverse(node[key], idx, suffix + key);\\n    }\\n  };\\n\\n  insertReversed(words);\\n  handleEmptyString(root);\\n\\n  for (let i = 0; i < words.length; i++) {\\n    const lastPrefixNode = getLastPrefixNode(words[i], i);\\n\\n    if (lastPrefixNode) traverse(lastPrefixNode, i, \\'\\');\\n  }\\n\\n  return output;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * *Time: O(N x M^2)\\n * *Space: O(N)\\n */\\n// Runtime: 2689 ms, faster than 26.00% of JavaScript online submissions for Palindrome Pairs.\\n// Memory Usage: 88.7 MB, less than 46.00% of JavaScript online submissions for Palindrome Pairs.\\nconst palindromePairs = words => {\\n\\tconst map = new Map(); // reversed word: index\\n\\tconst output = [];\\n\\n\\tconst isPalindrome = word => {\\n\\t\\tlet L = 0;\\n\\t\\tlet R = word.length - 1;\\n\\n\\t\\twhile (L < R) {\\n\\t\\t\\tif (word[L] != word[R]) return false;\\n\\n\\t\\t\\tL++;\\n\\t\\t\\tR--;\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t};\\n\\n\\t// reverse all words and add to map => reversed word: index\\n\\tconst insertReversed = words => {\\n\\t\\tfor (let i = 0; i < words.length; i++) {\\n\\t\\t\\tconst word = words[i];\\n\\t\\t\\tlet reversed = \\'\\';\\n\\n\\t\\t\\tfor (let j = word.length - 1; j >= 0; j--) {\\n\\t\\t\\t\\treversed += word[j];\\n\\t\\t\\t}\\n\\n\\t\\t\\tmap.set(reversed, i);\\n\\t\\t}\\n\\t};\\n\\n\\t// empty string forms palindrome w/ every palindrome in the list\\n\\tconst handleEmptyString = () => {\\n\\t\\tif (map.has(\\'\\')) {\\n\\t\\t\\tfor (let i = 0; i < words.length; i++) {\\n\\t\\t\\t\\tconst idx = map.get(\\'\\');\\n\\n\\t\\t\\t\\tif (idx === i) continue;\\n\\t\\t\\t\\tif (isPalindrome(words[i])) output.push([idx, i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\t// match prefix AND suffix of current word\\n\\t// to reversed word and check if it makes a valid palindrome\\n\\tconst findPalindromes = words => {\\n\\t\\tfor (let i = 0; i < words.length; i++) {\\n\\t\\t\\tconst word = words[i];\\n\\n\\t\\t\\tfor (let j = 0; j < word.length; j++) {\\n\\t\\t\\t\\tconst prefix = word.slice(0, j);\\n\\t\\t\\t\\tconst suffix = word.slice(j);\\n\\n\\t\\t\\t\\tconst prefixIdx = map.get(prefix);\\n\\t\\t\\t\\tconst suffixIdx = map.get(suffix);\\n\\n\\t\\t\\t\\t// if prefix is palindrome: suffix + words[i]\\n\\t\\t\\t\\tif (map.has(suffix) && suffixIdx !== i) {\\n\\t\\t\\t\\t\\tconst validPrefix = isPalindrome(prefix);\\n\\n\\t\\t\\t\\t\\tif (validPrefix) output.push([suffixIdx, i]);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// if suffix is palindrome: words[i] + prefix\\n\\t\\t\\t\\tif (map.has(prefix) && prefixIdx !== i) {\\n\\t\\t\\t\\t\\tconst validSuffix = isPalindrome(suffix);\\n\\n\\t\\t\\t\\t\\tif (validSuffix) output.push([i, prefixIdx]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\tinsertReversed(words);\\n\\thandleEmptyString(map);\\n\\tfindPalindromes(words);\\n\\n\\treturn output;\\n};\\n\\n\\n\\n\\n\\n/**\\n * *Time: O(N x M^2)\\n * *Space: O((N + K)^2)\\n */\\n// Runtime: 796 ms, faster than 100.00% of JavaScript online submissions for Palindrome Pairs.\\n// Memory Usage: 128 MB, less than 36.71% of JavaScript online submissions for Palindrome Pairs.\\nconst palindromePairs = (words) => {\\n  const root = {};\\n  const output = [];\\n\\n  const isPalindrome = (word) => {\\n    let L = 0;\\n    let R = word.length - 1;\\n\\n    while (L < R) {\\n      if (word[L++] !== word[R--]) return false;\\n    }\\n\\n    return true;\\n  };\\n\\n  const insertReversed = (words) => {\\n    for (let i = 0; i < words.length; i++) {\\n      const word = words[i];\\n      let node = root;\\n\\n      for (let j = word.length - 1; j >= 0; j--) {\\n        const char = word[j];\\n\\n        if (!node[char]) node[char] = {};\\n\\n        node = node[char];\\n      }\\n\\n      node.isEnd = true;\\n      node.index = i;\\n    }\\n  };\\n\\n  // empty string forms palindrome w/ every palindrome in the list\\n  const handleEmptyString = (root) => {\\n    if (!root.isEnd) return; // if isEnd, empty string\\n\\n    for (let i = 0; i < words.length; i++) {\\n      const valid = isPalindrome(words[i]);\\n\\n      if (root.index === i) continue;\\n      if (valid) output.push([i, root.index]);\\n    }\\n  };\\n\\n  // traverse trie along given word and return last prefix node\\n\\n  // case 2: if word shorter - get last prefix node given the word and DFS to check if trie has palindromes\\n  // case 3: if word longer - check if suffix is valid palindrome, if not stop\\n  const getLastPrefixNode = (word, idx) => {\\n    let node = root;\\n\\n    for (let i = 0; i < word.length; i++) {\\n      const char = word[i];\\n\\n      // case 3: word is longer\\n      // check if rest of the word form valid palindrome\\n      if (!node[char]) return;\\n      if (node[char].isEnd && node[char].index !== idx && i < word.length - 1) {\\n        const suffix = word.slice(i + 1);\\n        const valid = isPalindrome(suffix);\\n\\n        if (valid) output.push([idx, node[char].index]);\\n      }\\n\\n      node = node[char];\\n    }\\n\\n    return node;\\n  };\\n\\n  // traverse trie starting from lastPrefixNode find valid palindromes\\n  const traverse = (node, idx, suffix) => {\\n    // case 1. same word length\\n    if (node.isEnd && node.index !== idx) {\\n      const valid = isPalindrome(suffix);\\n\\n      if (valid) output.push([idx, node.index]);\\n    }\\n\\n    // case 2. word is shorter\\n    // traverse trie until valid match found\\n    for (const key in node) {\\n      traverse(node[key], idx, suffix + key);\\n    }\\n  };\\n\\n  insertReversed(words);\\n  handleEmptyString(root);\\n\\n  for (let i = 0; i < words.length; i++) {\\n    const lastPrefixNode = getLastPrefixNode(words[i], i);\\n\\n    if (lastPrefixNode) traverse(lastPrefixNode, i, \\'\\');\\n  }\\n\\n  return output;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1270377,
                "title": "palindrome-pairs-java-easy-approach-explained",
                "content": "**Approach 1:**\\n- If we apply the brute-force approach here, i.e. considering every pair of string by combining them and checking if it\\'s a palindrome, it will give **TLE** !!\\nTime-Complexity for Brute-force: **O(N^2 * M)**,\\nwhere,\\nN = size of words array.\\nM = Average size of words[i] string.\\n\\n**Approach 2:**\\nThis is somewhat optimized approach where we try to reduce the square time-xomplexity on `N (size of input list)`, and try to put it on `M (the avg. length of strings)`.\\n- Idea here is that, we store each string against its index in a HashMap.\\n\\n- Now, there are 3 possible cases:\\n\\t- There is an empty string in input, in which case, all palindrome strings in input becomes the solution with this empty string as prefix and suffix both. For eg., `s1 = \"\", s2 = \"aba\"`. Here, `(s1+s2)` and `(s2+s1)`, both are palindromes.\\n\\n\\t- Second case is where a palindrom and its reverse, both are available in the input. Just like above case, both the combinations are valid solutions. For eg., `s1 = \"abcd\", s2 = \"dcba\"`. Here, both combos are valid solutions.\\n\\n\\t- This is the tricky use-case. Here, the 2 strings might not be exact complement of each other, but their combination could be a palindrome, like `s1 = \"abcdc\", s2 = \"ba\"`. So, `(s1+s2) = \"abcdcba\"` which is a palindrome. Similarly, the other combination could as well be a palindrome. Hence, the idea here is to **reverse and break each string under consideration into 2 substrings, `prefix` and `suffix`**, and check that:\\n\\t\\t- `prefix` is a palindrome and `suffix` is available in the HashMap, which would mean that the string under consideration will act as prefix to palindromic string of combination of both. For eg., string = \"bcaaa\", other string = \"cb\". So, reverse and a valid split becomes `\"aaa\" and \"cb\"`. Here, `\"cb\"` is now available in HashMap.\\n\\t\\t- This is the exact opposite of above case where string under consideration acts as suffix to palindromic string of combination.\\nPlease check the code to understand it even better.\\n\\n\\nCode:\\n**Runtime:** 58 ms **(Faster than 60%)**\\n**Memory Usage:** 40.4 MB **(Beats 99.2%)**\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        List<List<Integer>> soln = new ArrayList<>();\\n        List<Integer> wordsPair = new ArrayList<>();\\n        Map<String, Integer> wordsMap = new HashMap<>();\\n\\n        for (int i=0; i<words.length; i++)\\n            wordsMap.put(words[i], i);\\n\\n        for (int i=0; i<words.length; i++) {\\n            if (wordsMap.containsKey(\"\") && !words[i].equals(\"\") && isPalindrome(words[i])) {\\n                soln.add(Arrays.asList(wordsMap.get(\"\"), wordsMap.get(words[i])));\\n                soln.add(Arrays.asList(wordsMap.get(words[i]), wordsMap.get(\"\")));\\n            }\\n\\n            StringBuilder sb = new StringBuilder(words[i]);\\n            String revStr = sb.reverse().toString();\\n\\n            if (wordsMap.containsKey(revStr) && !words[i].equals(revStr))\\n                soln.add(Arrays.asList(wordsMap.get(words[i]), wordsMap.get(revStr)));\\n\\n            for (int j=1; j<words[i].length(); j++) {\\n                String prefix = revStr.substring(0, j);\\n                String suffix = revStr.substring(j);\\n\\n                if (isPalindrome(prefix) && wordsMap.containsKey(suffix))\\n                    soln.add(Arrays.asList(i, wordsMap.get(suffix)));\\n                if (isPalindrome(suffix) && wordsMap.containsKey(prefix))\\n                    soln.add(Arrays.asList(wordsMap.get(prefix), i));\\n            }\\n        }\\n        return soln;\\n    }\\n\\n    private boolean isPalindrome(String str) {\\n        int i = 0, j = str.length()-1;\\n        while (i <= j) {\\n            if (str.charAt(i) != str.charAt(j))\\n                return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n------------------------------------------------------------------------------------------------------------------------------\\nIf you find this post helpful, please do upvote!\\nHappy Coding! :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        List<List<Integer>> soln = new ArrayList<>();\\n        List<Integer> wordsPair = new ArrayList<>();\\n        Map<String, Integer> wordsMap = new HashMap<>();\\n\\n        for (int i=0; i<words.length; i++)\\n            wordsMap.put(words[i], i);\\n\\n        for (int i=0; i<words.length; i++) {\\n            if (wordsMap.containsKey(\"\") && !words[i].equals(\"\") && isPalindrome(words[i])) {\\n                soln.add(Arrays.asList(wordsMap.get(\"\"), wordsMap.get(words[i])));\\n                soln.add(Arrays.asList(wordsMap.get(words[i]), wordsMap.get(\"\")));\\n            }\\n\\n            StringBuilder sb = new StringBuilder(words[i]);\\n            String revStr = sb.reverse().toString();\\n\\n            if (wordsMap.containsKey(revStr) && !words[i].equals(revStr))\\n                soln.add(Arrays.asList(wordsMap.get(words[i]), wordsMap.get(revStr)));\\n\\n            for (int j=1; j<words[i].length(); j++) {\\n                String prefix = revStr.substring(0, j);\\n                String suffix = revStr.substring(j);\\n\\n                if (isPalindrome(prefix) && wordsMap.containsKey(suffix))\\n                    soln.add(Arrays.asList(i, wordsMap.get(suffix)));\\n                if (isPalindrome(suffix) && wordsMap.containsKey(prefix))\\n                    soln.add(Arrays.asList(wordsMap.get(prefix), i));\\n            }\\n        }\\n        return soln;\\n    }\\n\\n    private boolean isPalindrome(String str) {\\n        int i = 0, j = str.length()-1;\\n        while (i <= j) {\\n            if (str.charAt(i) != str.charAt(j))\\n                return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1270359,
                "title": "python-pretty-fast-316ms",
                "content": "```\\nclass Solution(object):\\n    def palindromePairs(self, words):\\n        result = set()\\n        d = {words[x]: x for x in range(len(words))}\\n        for i, w in enumerate(words):\\n            rev = w[::-1]\\n            l = len(w)\\n            for j in range(l + 1):\\n                if w[j:] == rev[:l-j]:\\n                    if rev[l-j:] in d:\\n                        result.add((i, d[rev[l-j:]]))\\n                if w[:l-j] == rev[j:]:\\n                    if rev[:j] in d:\\n                        result.add((d[rev[:j]], i))\\n\\n        return [x for x in result if x[0] != x[1]]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def palindromePairs(self, words):\\n        result = set()\\n        d = {words[x]: x for x in range(len(words))}\\n        for i, w in enumerate(words):\\n            rev = w[::-1]\\n            l = len(w)\\n            for j in range(l + 1):\\n                if w[j:] == rev[:l-j]:\\n                    if rev[l-j:] in d:\\n                        result.add((i, d[rev[l-j:]]))\\n                if w[:l-j] == rev[j:]:\\n                    if rev[:j] in d:\\n                        result.add((d[rev[:j]], i))\\n\\n        return [x for x in result if x[0] != x[1]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876433,
                "title": "o-n-2-solution-using-hash",
                "content": "First, compute all prefix hashes:\\n- `hash_words[i][j] = hash of words[i][0..j]` and,\\n-  `hash_rwords[i][j] = hash of rwords[i][0..j]` where `rwords[i]` is the reverse string of `words[i]`.\\n\\nWith these prefix hashes, we can fast check if any substring is a palindrome in `O(1)`.\\n\\nThe remaining work is simply iterating through all `O(N^2)` string pair and check if they can be concatenated into a palindrome.\\n\\n```\\n#define all(a) a.begin(), a.end()\\n#define ll long long\\n#define BASE 17\\n#define MOD 10000019\\n\\nclass Solution {\\npublic:\\n  int power[301];\\n  int hash_words[5001][301], hash_rwords[5001][301];\\n  vector<vector<int>> res;\\n\\n  void computeHash(const string& w, int hash[]) {\\n    int n = w.length();\\n    if (n == 0) return;\\n    \\n    hash[0] = (w[0] - \\'a\\') % MOD;\\n    for (int i = 1; i < n; ++i)\\n      hash[i] = (hash[i-1] * BASE + w[i] - \\'a\\') % MOD;\\n  }\\n  \\n  int hashSubstr(int h[], int l, int r) {\\n    if (l == 0) return h[r];\\n    int res = ((ll) h[r] - (ll) h[l-1] * power[r-l+1]) % MOD;\\n    if (res < 0) res += MOD;\\n    return res;\\n  }\\n  \\n  // Is the last k characters of words[i] a palindrome?\\n  bool isPalindromeSuffix(int i, int n, int k) {\\n    int h1 = hashSubstr(hash_words[i], n-k, n-1);\\n    int h2 = hashSubstr(hash_rwords[i], 0, k-1);\\n    return h1 == h2;\\n  }\\n  \\n  // Is the first k characters of words[i] a palindrome?\\n  bool isPalindromePrefix(int i, int n, int k) {\\n    int h1 = hashSubstr(hash_words[i], 0, k-1);\\n    int h2 = hashSubstr(hash_rwords[i], n-k, n-1);\\n    return h1 == h2;\\n  }\\n  \\n  vector<vector<int>> palindromePairs(vector<string>& words) {\\n    power[0] = 1;\\n    for (int i = 1; i < 301; ++i)\\n      power[i] = (power[i-1] * BASE) % MOD;\\n    \\n    int n = words.size();\\n    \\n    vector<string> rwords = words;\\n    for (int i = 0; i < n; ++i)\\n      reverse(all(rwords[i]));\\n    \\n    for (int i = 0; i < n; ++i) {\\n      computeHash(words[i], hash_words[i]);\\n      computeHash(rwords[i], hash_rwords[i]);\\n    }\\n    \\n    for (int i = 0; i < n; ++i) {      \\n      int m = words[i].length(), l = 0;\\n      \\n      for (int j = 0; j < n; ++j) if (i != j) {\\n        int n = rwords[j].length();\\n        \\n        bool ok = false;\\n        if (m == 0 && n == 0) ok = true;\\n        else if (m == 0) ok = isPalindromePrefix(j, n, n);\\n        else if (n == 0) ok = isPalindromePrefix(i, m, m);\\n        else if (m == n) ok = hash_words[i][n-1] == hash_rwords[j][m-1];\\n        else if (m > n) {\\n          ok = (hashSubstr(hash_words[i], 0, n-1) == hash_rwords[j][n-1]) &&\\n            isPalindromeSuffix(i, m, m-n);\\n        }\\n        else {\\n          ok = (hash_words[i][m-1] == hashSubstr(hash_rwords[j], 0, m-1)) &&\\n            isPalindromePrefix(j, n, n-m);\\n        }\\n        if (ok) res.push_back({i, j});\\n      }\\n    }\\n    \\n    return res;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define all(a) a.begin(), a.end()\\n#define ll long long\\n#define BASE 17\\n#define MOD 10000019\\n\\nclass Solution {\\npublic:\\n  int power[301];\\n  int hash_words[5001][301], hash_rwords[5001][301];\\n  vector<vector<int>> res;\\n\\n  void computeHash(const string& w, int hash[]) {\\n    int n = w.length();\\n    if (n == 0) return;\\n    \\n    hash[0] = (w[0] - \\'a\\') % MOD;\\n    for (int i = 1; i < n; ++i)\\n      hash[i] = (hash[i-1] * BASE + w[i] - \\'a\\') % MOD;\\n  }\\n  \\n  int hashSubstr(int h[], int l, int r) {\\n    if (l == 0) return h[r];\\n    int res = ((ll) h[r] - (ll) h[l-1] * power[r-l+1]) % MOD;\\n    if (res < 0) res += MOD;\\n    return res;\\n  }\\n  \\n  // Is the last k characters of words[i] a palindrome?\\n  bool isPalindromeSuffix(int i, int n, int k) {\\n    int h1 = hashSubstr(hash_words[i], n-k, n-1);\\n    int h2 = hashSubstr(hash_rwords[i], 0, k-1);\\n    return h1 == h2;\\n  }\\n  \\n  // Is the first k characters of words[i] a palindrome?\\n  bool isPalindromePrefix(int i, int n, int k) {\\n    int h1 = hashSubstr(hash_words[i], 0, k-1);\\n    int h2 = hashSubstr(hash_rwords[i], n-k, n-1);\\n    return h1 == h2;\\n  }\\n  \\n  vector<vector<int>> palindromePairs(vector<string>& words) {\\n    power[0] = 1;\\n    for (int i = 1; i < 301; ++i)\\n      power[i] = (power[i-1] * BASE) % MOD;\\n    \\n    int n = words.size();\\n    \\n    vector<string> rwords = words;\\n    for (int i = 0; i < n; ++i)\\n      reverse(all(rwords[i]));\\n    \\n    for (int i = 0; i < n; ++i) {\\n      computeHash(words[i], hash_words[i]);\\n      computeHash(rwords[i], hash_rwords[i]);\\n    }\\n    \\n    for (int i = 0; i < n; ++i) {      \\n      int m = words[i].length(), l = 0;\\n      \\n      for (int j = 0; j < n; ++j) if (i != j) {\\n        int n = rwords[j].length();\\n        \\n        bool ok = false;\\n        if (m == 0 && n == 0) ok = true;\\n        else if (m == 0) ok = isPalindromePrefix(j, n, n);\\n        else if (n == 0) ok = isPalindromePrefix(i, m, m);\\n        else if (m == n) ok = hash_words[i][n-1] == hash_rwords[j][m-1];\\n        else if (m > n) {\\n          ok = (hashSubstr(hash_words[i], 0, n-1) == hash_rwords[j][n-1]) &&\\n            isPalindromeSuffix(i, m, m-n);\\n        }\\n        else {\\n          ok = (hash_words[i][m-1] == hashSubstr(hash_rwords[j], 0, m-1)) &&\\n            isPalindromePrefix(j, n, n-m);\\n        }\\n        if (ok) res.push_back({i, j});\\n      }\\n    }\\n    \\n    return res;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 486389,
                "title": "python-intuitive-solution-beats-93-100-with-explanation",
                "content": "```\\n\\'\\'\\'\\nFor each word W, we examine all possible partners that can concatenate into palindrome.\\nW and its partners have the same length\\n    1. If W[::-1] exists and W != W[::-1], (W, W[::-1]) is a valid pair. To avoid duplicate, always place current W first.\\n    2. If W == W[::-1] then it must pair with empty sting \\'\\' to make it a pair.\\nW and its parterns have different length\\n    3.Divide word into two parts by all possible locations, check if the palindrome of either part exist.\\n    \\'abcd\\' -> \\'a\\'&\\'bcd\\', \\'ab\\'&\\'cd\\', \\'abc\\'&\\'d\\'\\n    Denode the first part as pre and the second part as pos.\\n    If pos itself is palindrome, then we try to find pre[::-1] as partner, such that pre+pos+pre[::-1] is a valid palindrome.\\n    If pre itself is palindrome, then we try to find pos[::-1] as partner, such that pos[::-1]+pre+pos is a valid palindrome.\\n\\'\\'\\'\\n\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        empty_idx = None\\n        word_dict = {}\\n        for idx, w in enumerate(words):\\n            if w != \\'\\':\\n                word_dict[w] = idx\\n            else:\\n                empty_idx = idx\\n\\n        res = []\\n        for w, idx in word_dict.items():\\n            w_reverse = w[::-1]\\n            if w == w_reverse and empty_idx != None:\\n                res += [(idx, empty_idx), (empty_idx, idx)]\\n            if w != w_reverse and word_dict.get(w_reverse, -1) != -1:\\n                res += [(idx, word_dict[w_reverse])]\\n            for i in range(1, len(w)):\\n                pre, pos = w[:i], w[i:]\\n                pre_reverse, pos_reverse = pre[::-1], pos[::-1]\\n                if pre == pre_reverse and word_dict.get(pos_reverse, -1) != -1:\\n                    res += [(word_dict[pos_reverse], idx)]\\n                if pos == pos_reverse and word_dict.get(pre_reverse, -1) != -1:\\n                    res += [(idx, word_dict[pre_reverse])]\\n\\n        return res\\n```",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```\\n\\'\\'\\'\\nFor each word W, we examine all possible partners that can concatenate into palindrome.\\nW and its partners have the same length\\n    1. If W[::-1] exists and W != W[::-1], (W, W[::-1]) is a valid pair. To avoid duplicate, always place current W first.\\n    2. If W == W[::-1] then it must pair with empty sting \\'\\' to make it a pair.\\nW and its parterns have different length\\n    3.Divide word into two parts by all possible locations, check if the palindrome of either part exist.\\n    \\'abcd\\' -> \\'a\\'&\\'bcd\\', \\'ab\\'&\\'cd\\', \\'abc\\'&\\'d\\'\\n    Denode the first part as pre and the second part as pos.\\n    If pos itself is palindrome, then we try to find pre[::-1] as partner, such that pre+pos+pre[::-1] is a valid palindrome.\\n    If pre itself is palindrome, then we try to find pos[::-1] as partner, such that pos[::-1]+pre+pos is a valid palindrome.\\n\\'\\'\\'\\n\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        empty_idx = None\\n        word_dict = {}\\n        for idx, w in enumerate(words):\\n            if w != \\'\\':\\n                word_dict[w] = idx\\n            else:\\n                empty_idx = idx\\n\\n        res = []\\n        for w, idx in word_dict.items():\\n            w_reverse = w[::-1]\\n            if w == w_reverse and empty_idx != None:\\n                res += [(idx, empty_idx), (empty_idx, idx)]\\n            if w != w_reverse and word_dict.get(w_reverse, -1) != -1:\\n                res += [(idx, word_dict[w_reverse])]\\n            for i in range(1, len(w)):\\n                pre, pos = w[:i], w[i:]\\n                pre_reverse, pos_reverse = pre[::-1], pos[::-1]\\n                if pre == pre_reverse and word_dict.get(pos_reverse, -1) != -1:\\n                    res += [(word_dict[pos_reverse], idx)]\\n                if pos == pos_reverse and word_dict.get(pre_reverse, -1) != -1:\\n                    res += [(idx, word_dict[pre_reverse])]\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393650,
                "title": "java-trie-solution",
                "content": "```\\nclass Solution {\\n    class TrieNode{\\n        int id;\\n        TrieNode[] children;\\n        List<Integer> pos;\\n        boolean hasWord;\\n        public TrieNode(){\\n            this.id = -1;\\n            this.children = new TrieNode[26];\\n            this.hasWord = false;\\n            this.pos = new ArrayList<>();\\n        }\\n    }\\n    List<List<Integer>> res = new ArrayList<>();\\n    TrieNode root = new TrieNode();\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        //Trie\\n        //N * Len, N * Len^2\\n        if(words == null || words.length == 0)\\n            return res;\\n        for(int i = 0; i < words.length; i ++){\\n            insert(words[i], i);\\n        }\\n        for(int i = 0; i < words.length; i ++){\\n            search(words[i], i);\\n        }\\n        return res;\\n    }\\n    public void insert(String word, int index){\\n        TrieNode node = root;\\n        for(int i = word.length() - 1; i >= 0; i --){\\n            if(isPalin(word, 0, i)){\\n                node.pos.add(index);\\n            }\\n            int k = word.charAt(i) - \\'a\\';\\n            if(node.children[k] == null){\\n                node.children[k] = new TrieNode();\\n            }\\n            node = node.children[k];\\n        }\\n        node.hasWord = true;\\n        node.pos.add(index);\\n        node.id = index;\\n        \\n    }\\n    \\n    \\n    public void search(String word, int index){\\n        TrieNode node = root;\\n        for(int i = 0; i < word.length(); i ++){\\n            if(node.id >= 0 && node.id != index && isPalin(word, i, word.length() - 1)){\\n                List<Integer> tmp = new ArrayList<>();\\n                tmp.add(index);\\n                tmp.add(node.id);\\n                res.add(tmp);\\n            }\\n            int k = word.charAt(i) - \\'a\\';\\n            if(node.children[k] == null){\\n                return;\\n            }\\n            node = node.children[k];\\n        }\\n        for(int item : node.pos){\\n            if(item == index){\\n                continue;\\n            }\\n            List<Integer> tmp = new ArrayList<>();\\n            tmp.add(index);\\n            tmp.add(item);\\n            res.add(tmp);\\n        }\\n        \\n    }\\n    private boolean isPalin(String word, int start, int end){\\n        while(start < end){\\n            if(word.charAt(start) != word.charAt(end))\\n                return false;\\n            start ++;\\n            end --;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class TrieNode{\\n        int id;\\n        TrieNode[] children;\\n        List<Integer> pos;\\n        boolean hasWord;\\n        public TrieNode(){\\n            this.id = -1;\\n            this.children = new TrieNode[26];\\n            this.hasWord = false;\\n            this.pos = new ArrayList<>();\\n        }\\n    }\\n    List<List<Integer>> res = new ArrayList<>();\\n    TrieNode root = new TrieNode();\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        //Trie\\n        //N * Len, N * Len^2\\n        if(words == null || words.length == 0)\\n            return res;\\n        for(int i = 0; i < words.length; i ++){\\n            insert(words[i], i);\\n        }\\n        for(int i = 0; i < words.length; i ++){\\n            search(words[i], i);\\n        }\\n        return res;\\n    }\\n    public void insert(String word, int index){\\n        TrieNode node = root;\\n        for(int i = word.length() - 1; i >= 0; i --){\\n            if(isPalin(word, 0, i)){\\n                node.pos.add(index);\\n            }\\n            int k = word.charAt(i) - \\'a\\';\\n            if(node.children[k] == null){\\n                node.children[k] = new TrieNode();\\n            }\\n            node = node.children[k];\\n        }\\n        node.hasWord = true;\\n        node.pos.add(index);\\n        node.id = index;\\n        \\n    }\\n    \\n    \\n    public void search(String word, int index){\\n        TrieNode node = root;\\n        for(int i = 0; i < word.length(); i ++){\\n            if(node.id >= 0 && node.id != index && isPalin(word, i, word.length() - 1)){\\n                List<Integer> tmp = new ArrayList<>();\\n                tmp.add(index);\\n                tmp.add(node.id);\\n                res.add(tmp);\\n            }\\n            int k = word.charAt(i) - \\'a\\';\\n            if(node.children[k] == null){\\n                return;\\n            }\\n            node = node.children[k];\\n        }\\n        for(int item : node.pos){\\n            if(item == index){\\n                continue;\\n            }\\n            List<Integer> tmp = new ArrayList<>();\\n            tmp.add(index);\\n            tmp.add(item);\\n            res.add(tmp);\\n        }\\n        \\n    }\\n    private boolean isPalin(String word, int start, int end){\\n        while(start < end){\\n            if(word.charAt(start) != word.charAt(end))\\n                return false;\\n            start ++;\\n            end --;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 385643,
                "title": "straight-forward-solution-in-30-lines-java",
                "content": "1. Compare each pair of word in words for palindrome - A and B, B and A\\n2. Logic for palindrome is inspired from merge of mergesort\\n\\n```\\npublic List<List<Integer>> palindromePairs(String[] words) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for(int i = 0; i < words.length; i++){\\n            for(int j = i+1; j < words.length; j++){\\n                if(isPalindrome(words, i, j)) ans.add(Arrays.asList(i, j));\\n                if(isPalindrome(words, j, i)) ans.add(Arrays.asList(j, i));\\n            }\\n        }\\n        return ans;\\n    }    \\n    private boolean isPalindrome(String[] words, int i, int j) {\\n        int m = 0;\\n        int n = words[j].length()-1;\\n        while (m < words[i].length() && n >=0){\\n            if (words[i].charAt(m) != words[j].charAt(n)) return false;\\n            m++; n--;\\n        }\\n        int m2 = words[i].length() -1;\\n        while(m < m2){\\n            if(words[i].charAt(m) != words[i].charAt(m2)) return false;\\n            m++; m2--;\\n        }\\n        int n2 = 0;\\n        while(n > n2){\\n            if(words[j].charAt(n) != words[j].charAt(n2)) return false;\\n            n--; n2++;\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "1. Compare each pair of word in words for palindrome - A and B, B and A\\n2. Logic for palindrome is inspired from merge of mergesort\\n\\n```\\npublic List<List<Integer>> palindromePairs(String[] words) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for(int i = 0; i < words.length; i++){\\n            for(int j = i+1; j < words.length; j++){\\n                if(isPalindrome(words, i, j)) ans.add(Arrays.asList(i, j));\\n                if(isPalindrome(words, j, i)) ans.add(Arrays.asList(j, i));\\n            }\\n        }\\n        return ans;\\n    }    \\n    private boolean isPalindrome(String[] words, int i, int j) {\\n        int m = 0;\\n        int n = words[j].length()-1;\\n        while (m < words[i].length() && n >=0){\\n            if (words[i].charAt(m) != words[j].charAt(n)) return false;\\n            m++; n--;\\n        }\\n        int m2 = words[i].length() -1;\\n        while(m < m2){\\n            if(words[i].charAt(m) != words[i].charAt(m2)) return false;\\n            m++; m2--;\\n        }\\n        int n2 = 0;\\n        while(n > n2){\\n            if(words[j].charAt(n) != words[j].charAt(n2)) return false;\\n            n--; n2++;\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 338659,
                "title": "rabin-karp-c-time-o-n-k-2-space-o-n-and-time-o-n-k-space-o-n-k",
                "content": "The solution I have given here is Time -  O(n * k^2) | Space - O(n) where n is the number of words and k is the length of the words. \\n\\nThe basic idea is compute and store forward and backward hashes for each word in 2 different maps `map1` and `map2`. Now for each word iterate throught the characters first from front and then from back. Calculare the rolling hash and check if it exists in the maps. If the hash exists in the map, then check if the remaining word is a palindrome, if it is, then we have a palindrome pair. \\n\\nEg. let the 2 words be \"abcdc\" and \"ba\". Now the partial hash of \"ab\" will match the backward hash of \"ba\". Then we check if \"cdc\" is a palindrome and hence we have a match.\\n\\nThe optimization to reduce it to Space - O(n) AND Time - O(n * k) | Space - O(n * k) is as follows. \\nOur function `isPalindrome()` takes O(k) time. However we could have pre- computed the suffix and prefix hashes for each word and stored them using - O(NK) space and time. Then we can compute `isPalindrome()`  in O(1) time. \\n\\n```\\nlong long int p = 10e8 + 7; \\n\\nlong long int d = 31;\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        unordered_map<long long int, int> map1;\\n        unordered_map<long long int, int> map2;\\n      \\n        int n = words.size();\\n\\t\\t\\n\\t\\t// O(N*K)\\n        for(int i = 0; i < n; i++)\\n            map1[revHash(words[i])] = i; \\n        for(int i = 0; i < n; i++)\\n            map2[hash(words[i])] = i; \\n        \\n        vector<vector<int>> ans;\\n        \\n        for(int i = 0; i < n; i++) { // O(N) - for every word\\n            string &word = words[i];\\n            int n1 = word.size(); \\n            long long int h = 0; \\n            \\n\\t\\t\\t// If word is empty string, check every other word for palindromes\\n            if(word == \"\") {  // O(N * K) - this happens maximum one time, can be optimized to O(N)\\n                for(int j = 0; j < n; j++) {\\n                    if(j!=i && isPalindrome(words[j], 0, words[j].size()-1)) { \\n                         ans.push_back({i, j});\\n                         ans.push_back({j, i});\\n                    }\\n                }\\n                continue;\\n            }\\n            \\n\\t\\t\\t// - O(K) - hashing through length of word\\n            for(int j = 0; j <n1 ; j++) {  \\n                 h = (h*d + word[j]-\\'a\\' + 1)%p;\\n\\t\\t\\t\\t \\n\\t\\t\\t\\t// O(K) - checking if remaining word is palindrome -> can be optimized to O(1) by precomputing hashes\\n                if(map1.count(h) && map1[h]!=i && isPalindrome(word, j+1, n1-1)){\\n                    if(j == n1-1 && map1[h] < i)continue;\\n                    ans.push_back({i, map1[h]});\\n                }\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// Repeat the same from the other end\\n            h = 0; \\n            for(int j = n1-1; j >=0 ; j--) {\\n                h = (h*d + word[j]-\\'a\\' + 1)%p;\\n                if(map2.count(h) && map2[h]!=i  && isPalindrome(word, 0, j-1)){                               if(j == 0 && map2[h] < i)continue;\\n                    ans.push_back({map2[h], i});\\n                }\\n            }\\n        }\\n        \\n        return ans; \\n        \\n    }\\n    \\n\\t// O(K) -> can be optimized to O(1)\\n    bool isPalindrome(string &s, int l, int r) {\\n        \\n        while(l<r){\\n            if(s[l]!=s[r])return false;\\n            l++;r--;\\n        }\\n        \\n        return true;\\n    }\\n    \\n\\t// O(K) \\n    long long int hash(string &s) {\\n        \\n        if(s == \"\")return -1;\\n        \\n        long long int h = 0; \\n        \\n        for(char c: s)\\n            h = (h*d + c-\\'a\\' + 1)%p;\\n        \\n        return h; \\n    }\\n    \\n\\t// O(K) \\n    long long int revHash(string s) {\\n        reverse(s.begin(), s.end());\\n        return hash(s); \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlong long int p = 10e8 + 7; \\n\\nlong long int d = 31;\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        unordered_map<long long int, int> map1;\\n        unordered_map<long long int, int> map2;\\n      \\n        int n = words.size();\\n\\t\\t\\n\\t\\t// O(N*K)\\n        for(int i = 0; i < n; i++)\\n            map1[revHash(words[i])] = i; \\n        for(int i = 0; i < n; i++)\\n            map2[hash(words[i])] = i; \\n        \\n        vector<vector<int>> ans;\\n        \\n        for(int i = 0; i < n; i++) { // O(N) - for every word\\n            string &word = words[i];\\n            int n1 = word.size(); \\n            long long int h = 0; \\n            \\n\\t\\t\\t// If word is empty string, check every other word for palindromes\\n            if(word == \"\") {  // O(N * K) - this happens maximum one time, can be optimized to O(N)\\n                for(int j = 0; j < n; j++) {\\n                    if(j!=i && isPalindrome(words[j], 0, words[j].size()-1)) { \\n                         ans.push_back({i, j});\\n                         ans.push_back({j, i});\\n                    }\\n                }\\n                continue;\\n            }\\n            \\n\\t\\t\\t// - O(K) - hashing through length of word\\n            for(int j = 0; j <n1 ; j++) {  \\n                 h = (h*d + word[j]-\\'a\\' + 1)%p;\\n\\t\\t\\t\\t \\n\\t\\t\\t\\t// O(K) - checking if remaining word is palindrome -> can be optimized to O(1) by precomputing hashes\\n                if(map1.count(h) && map1[h]!=i && isPalindrome(word, j+1, n1-1)){\\n                    if(j == n1-1 && map1[h] < i)continue;\\n                    ans.push_back({i, map1[h]});\\n                }\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// Repeat the same from the other end\\n            h = 0; \\n            for(int j = n1-1; j >=0 ; j--) {\\n                h = (h*d + word[j]-\\'a\\' + 1)%p;\\n                if(map2.count(h) && map2[h]!=i  && isPalindrome(word, 0, j-1)){                               if(j == 0 && map2[h] < i)continue;\\n                    ans.push_back({map2[h], i});\\n                }\\n            }\\n        }\\n        \\n        return ans; \\n        \\n    }\\n    \\n\\t// O(K) -> can be optimized to O(1)\\n    bool isPalindrome(string &s, int l, int r) {\\n        \\n        while(l<r){\\n            if(s[l]!=s[r])return false;\\n            l++;r--;\\n        }\\n        \\n        return true;\\n    }\\n    \\n\\t// O(K) \\n    long long int hash(string &s) {\\n        \\n        if(s == \"\")return -1;\\n        \\n        long long int h = 0; \\n        \\n        for(char c: s)\\n            h = (h*d + c-\\'a\\' + 1)%p;\\n        \\n        return h; \\n    }\\n    \\n\\t// O(K) \\n    long long int revHash(string s) {\\n        reverse(s.begin(), s.end());\\n        return hash(s); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 211268,
                "title": "java-solution-using-hashmap",
                "content": "```\\n// add to result when found \\n// case 1: \"\" can be combine with any palindrome string\\n// case 2: reversed string existed\\n// case 3: find the pair s1, s2 that \\n//         s1[cut: ] isPalindrome => reverse(s2[0:cut]) exists => (s1, s2)\\n//         s1[0:cut] isPalindrome => reverse(s2[cut: ]) exists => (s2, s1)\\n\\nclass Solution {\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        HashMap<String, Integer> map = new HashMap<>();\\n        for(int i = 0; i < words.length; i++) {\\n            map.put(words[i], i);\\n        }\\n        \\n        if(map.containsKey(\"\")) {\\n            int blank = map.get(\"\");\\n            for(int i = 0; i < words.length; i++) {\\n                if(isPalindrome(words[i]) && i != blank) {\\n                    result.add(Arrays.asList(blank, i));\\n                    result.add(Arrays.asList(i, blank));\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0; i < words.length; i++) {\\n            String reversed = reverse(words[i]);\\n            if(map.containsKey(reversed) && map.get(reversed) != i) {\\n                result.add(Arrays.asList(i, map.get(reversed)));\\n            }\\n        }\\n        \\n        for(int i = 0; i < words.length; i++) {\\n            String curr = words[i];\\n            for(int cut = 1; cut < curr.length(); cut++) {\\n                if(isPalindrome(curr.substring(cut))) {\\n                    String reversed = reverse(curr.substring(0,cut));\\n                    if(map.containsKey(reversed) && map.get(reversed) != i) {\\n                        result.add(Arrays.asList(i, map.get(reversed)));\\n                    }\\n                }\\n                if(isPalindrome(curr.substring(0,cut))) {\\n                    String reversed = reverse(curr.substring(cut));\\n                    if(map.containsKey(reversed) && map.get(reversed) != i) {\\n                        result.add(Arrays.asList(map.get(reversed), i));\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private boolean isPalindrome(String str) {\\n        int left = 0;\\n        int right = str.length() - 1;\\n        while(left <= right) {\\n            if(str.charAt(left) != str.charAt(right)) return false;\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n    \\n    private String reverse(String str) {\\n        StringBuilder sb = new StringBuilder(str).reverse();\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// add to result when found \\n// case 1: \"\" can be combine with any palindrome string\\n// case 2: reversed string existed\\n// case 3: find the pair s1, s2 that \\n//         s1[cut: ] isPalindrome => reverse(s2[0:cut]) exists => (s1, s2)\\n//         s1[0:cut] isPalindrome => reverse(s2[cut: ]) exists => (s2, s1)\\n\\nclass Solution {\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        HashMap<String, Integer> map = new HashMap<>();\\n        for(int i = 0; i < words.length; i++) {\\n            map.put(words[i], i);\\n        }\\n        \\n        if(map.containsKey(\"\")) {\\n            int blank = map.get(\"\");\\n            for(int i = 0; i < words.length; i++) {\\n                if(isPalindrome(words[i]) && i != blank) {\\n                    result.add(Arrays.asList(blank, i));\\n                    result.add(Arrays.asList(i, blank));\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0; i < words.length; i++) {\\n            String reversed = reverse(words[i]);\\n            if(map.containsKey(reversed) && map.get(reversed) != i) {\\n                result.add(Arrays.asList(i, map.get(reversed)));\\n            }\\n        }\\n        \\n        for(int i = 0; i < words.length; i++) {\\n            String curr = words[i];\\n            for(int cut = 1; cut < curr.length(); cut++) {\\n                if(isPalindrome(curr.substring(cut))) {\\n                    String reversed = reverse(curr.substring(0,cut));\\n                    if(map.containsKey(reversed) && map.get(reversed) != i) {\\n                        result.add(Arrays.asList(i, map.get(reversed)));\\n                    }\\n                }\\n                if(isPalindrome(curr.substring(0,cut))) {\\n                    String reversed = reverse(curr.substring(cut));\\n                    if(map.containsKey(reversed) && map.get(reversed) != i) {\\n                        result.add(Arrays.asList(map.get(reversed), i));\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private boolean isPalindrome(String str) {\\n        int left = 0;\\n        int right = str.length() - 1;\\n        while(left <= right) {\\n            if(str.charAt(left) != str.charAt(right)) return false;\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n    \\n    private String reverse(String str) {\\n        StringBuilder sb = new StringBuilder(str).reverse();\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152013,
                "title": "java-solution-using-backtracking",
                "content": "class Solution {\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        \\n        List<List<Integer>> finalIndex =new ArrayList<List<Integer>> ();\\n        \\n        auxPalindromePairs(words,new ArrayList<Integer>(),finalIndex,0);\\n        return finalIndex;\\n    }\\n    void auxPalindromePairs(String words[], List<Integer> index, List<List<Integer>> finalIndex, int start)\\n    {\\n        if(index.size()==2)\\n        {\\n            if(isPalidrime(words[index.get(0)]+words[index.get(1)]))\\n            {\\n                finalIndex.add(new ArrayList(index));\\n            }\\n            if(isPalidrime(words[index.get(1)]+words[index.get(0)]))\\n            {\\n                List<Integer> temp=new ArrayList<Integer>();\\n                temp.add(index.get(1));\\n                temp.add(index.get(0));\\n                finalIndex.add(temp);\\n            }\\n        }\\n        else\\n        {\\n            for(int i=start;i<words.length;i++)\\n            {\\n                if(index.contains(i)) continue;\\n                index.add(i);\\n                auxPalindromePairs(words,index,finalIndex, i+1);\\n                index.remove(index.size()-1);\\n            }\\n        }\\n    }\\n    boolean isPalidrime(String s)\\n    {\\n        int low=0, high=s.length()-1;\\n        while(low<high)\\n        {\\n            if(s.charAt(low++)!=s.charAt(high--))\\n                return false;\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        \\n        List<List<Integer>> finalIndex =new ArrayList<List<Integer>> ();\\n        \\n        auxPalindromePairs(words,new ArrayList<Integer>(),finalIndex,0);\\n        return finalIndex;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 79198,
                "title": "short-c-solution-using-multiple-maps-with-explanation",
                "content": "m1[pf] = the list of index i such that words[i] has prefix reverse(pf) and its compliment is palindromic. This mean words[i] + pf is palindromic.\\nm2[sf] = the list of index i such that words[i] has suffix reverse(sf) and its compliment is palindromic. This mean sf + words[i] is palindromic.\\nm[w] = the index of word w.\\nThus for each i in m1[w], (i,m[w]) is a palindrome pair. For each i in m2[w], (m[w], i) is a palindrome pair.\\n```\\nclass Solution {\\npublic:\\n    string rev(string t) {\\n        reverse(t.begin(),t.end());\\n        return t;\\n    }\\n    vector<vector<int>> palindromePairs(vector<string>& w) {\\n        unordered_map<string, unordered_set<int>> m1,m2;\\n        unordered_map<int, unordered_set<int>>m;\\n        unordered_map<string,int> m3;\\n        vector<vector<int>> ans;\\n        for (int i = 0; i < w.size(); ++i) {\\n            for (int j = 0; j <= w[i].size(); ++j) {\\n                string t = w[i].substr(0,j);\\n                if (t == rev(t)) m1[rev(w[i].substr(j))].insert(i);\\n                string s = w[i].substr(j);\\n                if (s == rev(s)) m2[rev(w[i].substr(0,j))].insert(i);\\n            }\\n            m3[w[i]] = i;\\n        }\\n        for (int i = 0; i < w.size(); ++i) {\\n            if (m1.count(w[i])) for (int j:m1[w[i]]) m[i].insert(j);\\n            if (m2.count(w[i])) for (int j:m2[w[i]]) m[j].insert(i);\\n        }\\n        for (int i = 0; i < w.size(); ++i) if (m.count(i)) {\\n            for (int j:m[i]) if (i != j) ans.push_back({i,j});\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string rev(string t) {\\n        reverse(t.begin(),t.end());\\n        return t;\\n    }\\n    vector<vector<int>> palindromePairs(vector<string>& w) {\\n        unordered_map<string, unordered_set<int>> m1,m2;\\n        unordered_map<int, unordered_set<int>>m;\\n        unordered_map<string,int> m3;\\n        vector<vector<int>> ans;\\n        for (int i = 0; i < w.size(); ++i) {\\n            for (int j = 0; j <= w[i].size(); ++j) {\\n                string t = w[i].substr(0,j);\\n                if (t == rev(t)) m1[rev(w[i].substr(j))].insert(i);\\n                string s = w[i].substr(j);\\n                if (s == rev(s)) m2[rev(w[i].substr(0,j))].insert(i);\\n            }\\n            m3[w[i]] = i;\\n        }\\n        for (int i = 0; i < w.size(); ++i) {\\n            if (m1.count(w[i])) for (int j:m1[w[i]]) m[i].insert(j);\\n            if (m2.count(w[i])) for (int j:m2[w[i]]) m[j].insert(i);\\n        }\\n        for (int i = 0; i < w.size(); ++i) if (m.count(i)) {\\n            for (int j:m[i]) if (i != j) ans.push_back({i,j});\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79259,
                "title": "concise-python-solution",
                "content": "    class Solution(object):\\n        def palindromePairs(self, words):\\n            \"\"\"\\n            :type words: List[str]\\n            :rtype: List[List[int]]\\n            \"\"\"\\n            res = []\\n            dic = {}\\n            for i in range(len(words)):\\n                dic[words[i]] = i\\n            for word in words:\\n                word_rev = word[::-1]\\n                if word_rev in dic and dic[word_rev] != dic[word]:\\n                    res.append([dic[word_rev], dic[word]])\\n                for i in range(len(word)):\\n                    temp1 = word[:i][::-1]\\n                    temp2 = word_rev[:i]\\n                    if temp1 in dic and isPal(word[i:]):\\n                        res.append([dic[word], dic[temp1]])\\n                    if temp2 in dic and isPal(word_rev[i:]):\\n                        res.append([ dic[temp2], dic[word]])\\n            return res\\n    def isPal(word):\\n        left = 0\\n        right = len(word)-1\\n        while left < right:\\n            if word[left] != word[right]:\\n                return False\\n            left += 1\\n            right -= 1\\n        return True",
                "solutionTags": [],
                "code": "class Solution(object):\\n        def palindromePairs(self, words):\\n            \"\"\"\\n            :type words: List[str]\\n            :rtype: List[List[int]]\\n            \"\"\"\\n            res = []\\n            dic = {}",
                "codeTag": "Java"
            },
            {
                "id": 79287,
                "title": "accepted-simple-c-solution",
                "content": "Translated version from [zrythpzhl][1]'s Python solution. \\n\\n    class Solution {\\n    public:\\n        vector<vector<int>> palindromePairs(vector<string>& words) {\\n            vector<vector<int>> res;\\n            if (!words.size()) return res;\\n            unordered_map<string, size_t> word_idx;\\n            for (size_t i = 0; i < words.size(); ++i) {\\n                word_idx[words[i]] = i;\\n            }\\n            vector<int> slu(2);\\n            for (size_t i = 0; i < words.size(); ++i) {\\n                size_t len = words[i].length();\\n                for (size_t l = 0; l <= len; ++l) {\\n                    string left = words[i].substr(0, l);\\n                    string right = words[i].substr(l);\\n                    string rleft = left;\\n                    string rright = right;\\n                    reverse(rleft.begin(), rleft.end());\\n                    reverse(rright.begin(), rright.end());\\n                    if (word_idx.find(rleft) != word_idx.end()) {\\n                        if (word_idx[rleft] != i && isPalindrome(right)) {\\n                            slu[0] = i;\\n                            slu[1] = word_idx[rleft];\\n                            res.push_back(slu);                        \\n                        }\\n    \\n                    }\\n                    if (l != 0 && word_idx.find(rright) != word_idx.end()) {\\n                        if (word_idx[rright] != i && isPalindrome(left)) {\\n                            slu[0] = word_idx[rright];\\n                            slu[1] = i;\\n                            res.push_back(slu);                        \\n                        }\\n    \\n                    }\\n    \\n                }\\n            }\\n            return res;\\n        }\\n        \\n        bool isPalindrome(string s) {\\n            if (s.size() <= 1) return true;\\n            size_t i = 0; \\n            size_t j = s.size() - 1;\\n            while (i < j) {\\n                if (s[i++] != s[j--]) return false;\\n            }\\n            \\n            return true;\\n        }\\n    };\\n\\n\\n  [1]: https://leetcode.com/discuss/91284/python-solution",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> palindromePairs(vector<string>& words) {\\n            vector<vector<int>> res;\\n            if (!words.size()) return res;\\n            unordered_map<string, size_t> word_idx;\\n            for (size_t i = 0; i < words.size(); ++i) {\\n                word_idx[words[i]] = i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 79307,
                "title": "easy-to-understand-java-code-using-hashmap",
                "content": "    public List<List<Integer>> palindromePairs(String[] words) {\\n    \\t\\tList<List<Integer>> result = new ArrayList<>();\\n    \\t\\tHashMap<String, Integer> hm = new HashMap<>();\\n    \\n    \\t\\t// put all the words in HashMap for easy look-up\\n    \\t\\tfor (int i = 0; i < words.length; i++) {\\n    \\t\\t\\thm.put(words[i], i);\\n    \\t\\t}\\n    \\n    \\t\\tfor (int i = 0; i < words.length; i++) {\\n    \\t\\t\\tString reverse = new StringBuilder(words[i]).reverse().toString();\\n    \\n    \\t\\t\\t// check if there is reverse word present\\n    \\t\\t\\tif (hm.containsKey(reverse) && hm.get(reverse) != i) {\\n    \\t\\t\\t\\tList<Integer> list = new ArrayList<>();\\n    \\t\\t\\t\\tlist.add(i);\\n    \\t\\t\\t\\tlist.add(hm.get(reverse));\\n    \\t\\t\\t\\tresult.add(list);\\n    \\t\\t\\t}\\n    \\n    \\t\\t\\t// check if there is empty string\\n    \\t\\t\\t// in that case if word is palindrome, empty string can be added\\n    \\t\\t\\t// before and after the word.\\n    \\t\\t\\tif (hm.containsKey(\"\")\\n    \\t\\t\\t\\t\\t&& hm.get(\"\") != i\\n    \\t\\t\\t\\t\\t&& new StringBuilder(words[i]).reverse().toString()\\n    \\t\\t\\t\\t\\t\\t\\t.equals(words[i])) {\\n    \\t\\t\\t\\tList<Integer> list = new ArrayList<>();\\n    \\t\\t\\t\\tlist.add(i);\\n    \\t\\t\\t\\tlist.add(hm.get(\"\"));\\n    \\t\\t\\t\\tresult.add(list);\\n    \\t\\t\\t\\tlist = new ArrayList<>();\\n    \\t\\t\\t\\tlist.add(hm.get(\"\"));\\n    \\t\\t\\t\\tlist.add(i);\\n    \\t\\t\\t\\tresult.add(list);\\n    \\t\\t\\t}\\n    \\n    \\t\\t\\t// check if some other word can be added as prefix\\n    \\t\\t\\tint curReverse = 0;\\n    \\t\\t\\twhile (curReverse < reverse.length() - 1) {\\n    \\t\\t\\t\\tif (hm.containsKey(reverse.substring(0, curReverse + 1))) {\\n    \\t\\t\\t\\t\\tString rem = words[i].substring(0, words[i].length()\\n    \\t\\t\\t\\t\\t\\t\\t- curReverse - 1);\\n    \\t\\t\\t\\t\\tif (new StringBuilder(rem).reverse().toString().equals(rem)) {\\n    \\t\\t\\t\\t\\t\\tList<Integer> list = new ArrayList<>();\\n    \\t\\t\\t\\t\\t\\tlist.add(hm.get(reverse.substring(0, curReverse + 1)));\\n    \\t\\t\\t\\t\\t\\tlist.add(i);\\n    \\t\\t\\t\\t\\t\\tresult.add(list);\\n    \\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tcurReverse++;\\n    \\t\\t\\t}\\n    \\n    \\t\\t\\t// check if some other word can be added as suffix\\n    \\t\\t\\tint curForward = 0;\\n    \\t\\t\\twhile (curForward < words[i].length() - 1) {\\n    \\t\\t\\t\\tString rev = new StringBuilder(words[i].substring(0,\\n    \\t\\t\\t\\t\\t\\tcurForward + 1)).reverse().toString();\\n    \\t\\t\\t\\tif (hm.containsKey(rev)) {\\n    \\t\\t\\t\\t\\tString rem = words[i].substring(curForward + 1);\\n    \\t\\t\\t\\t\\tif (new StringBuilder(rem).reverse().toString().equals(rem)) {\\n    \\t\\t\\t\\t\\t\\tList<Integer> list = new ArrayList<>();\\n    \\t\\t\\t\\t\\t\\tlist.add(i);\\n    \\t\\t\\t\\t\\t\\tlist.add(hm.get(rev));\\n    \\t\\t\\t\\t\\t\\tresult.add(list);\\n    \\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tcurForward++;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn result;\\n    \\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<List<Integer>> palindromePairs(String[] words) {\\n    \\t\\tList<List<Integer>> result = new ArrayList<>();\\n    \\t\\tHashMap<String, Integer> hm = new HashMap<>();\\n    \\n    \\t\\t// put all the words in HashMap for easy look-up\\n    \\t\\tfor (int i = 0; i < words.length; i++) {\\n    \\t\\t\\thm.put(words[i], i);\\n    \\t\\t}\\n    \\n    \\t\\tfor (int i = 0; i < words.length; i++) {\\n    \\t\\t\\tString reverse = new StringBuilder(words[i]).reverse().toString();\\n    \\n    \\t\\t\\t// check if there is reverse word present\\n    \\t\\t\\tif (hm.containsKey(reverse) && hm.get(reverse) != i) {\\n    \\t\\t\\t\\tList<Integer> list = new ArrayList<>();\\n    \\t\\t\\t\\tlist.add(i);\\n    \\t\\t\\t\\tlist.add(hm.get(reverse));\\n    \\t\\t\\t\\tresult.add(list);\\n    \\t\\t\\t}\\n    \\n    \\t\\t\\t// check if there is empty string\\n    \\t\\t\\t// in that case if word is palindrome, empty string can be added\\n    \\t\\t\\t// before and after the word.\\n    \\t\\t\\tif (hm.containsKey(\"\")\\n    \\t\\t\\t\\t\\t&& hm.get(\"\") != i\\n    \\t\\t\\t\\t\\t&& new StringBuilder(words[i]).reverse().toString()\\n    \\t\\t\\t\\t\\t\\t\\t.equals(words[i])) {\\n    \\t\\t\\t\\tList<Integer> list = new ArrayList<>();\\n    \\t\\t\\t\\tlist.add(i);\\n    \\t\\t\\t\\tlist.add(hm.get(\"\"));\\n    \\t\\t\\t\\tresult.add(list);\\n    \\t\\t\\t\\tlist = new ArrayList<>();\\n    \\t\\t\\t\\tlist.add(hm.get(\"\"));\\n    \\t\\t\\t\\tlist.add(i);\\n    \\t\\t\\t\\tresult.add(list);\\n    \\t\\t\\t}\\n    \\n    \\t\\t\\t// check if some other word can be added as prefix\\n    \\t\\t\\tint curReverse = 0;\\n    \\t\\t\\twhile (curReverse < reverse.length() - 1) {\\n    \\t\\t\\t\\tif (hm.containsKey(reverse.substring(0, curReverse + 1))) {\\n    \\t\\t\\t\\t\\tString rem = words[i].substring(0, words[i].length()\\n    \\t\\t\\t\\t\\t\\t\\t- curReverse - 1);\\n    \\t\\t\\t\\t\\tif (new StringBuilder(rem).reverse().toString().equals(rem)) {\\n    \\t\\t\\t\\t\\t\\tList<Integer> list = new ArrayList<>();\\n    \\t\\t\\t\\t\\t\\tlist.add(hm.get(reverse.substring(0, curReverse + 1)));\\n    \\t\\t\\t\\t\\t\\tlist.add(i);\\n    \\t\\t\\t\\t\\t\\tresult.add(list);\\n    \\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tcurReverse++;\\n    \\t\\t\\t}\\n    \\n    \\t\\t\\t// check if some other word can be added as suffix\\n    \\t\\t\\tint curForward = 0;\\n    \\t\\t\\twhile (curForward < words[i].length() - 1) {\\n    \\t\\t\\t\\tString rev = new StringBuilder(words[i].substring(0,\\n    \\t\\t\\t\\t\\t\\tcurForward + 1)).reverse().toString();\\n    \\t\\t\\t\\tif (hm.containsKey(rev)) {\\n    \\t\\t\\t\\t\\tString rem = words[i].substring(curForward + 1);\\n    \\t\\t\\t\\t\\tif (new StringBuilder(rem).reverse().toString().equals(rem)) {\\n    \\t\\t\\t\\t\\t\\tList<Integer> list = new ArrayList<>();\\n    \\t\\t\\t\\t\\t\\tlist.add(i);\\n    \\t\\t\\t\\t\\t\\tlist.add(hm.get(rev));\\n    \\t\\t\\t\\t\\t\\tresult.add(list);\\n    \\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tcurForward++;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn result;\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2596483,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        HashMap<String,Integer> wordMap = new HashMap<>();\\n        Set<Integer> set = new TreeSet<>();\\n        int n = words.length;\\n        \\n        for(int i=0;i<n;i++){\\n            wordMap.put(words[i],i);\\n            set.add(words[i].length());\\n        }\\n        \\n        List<List<Integer>> ans = new ArrayList<>();\\n        \\n        for(int i=0;i<n;i++){\\n            int length = words[i].length();\\n            \\n            if(length ==1){\\n                if(wordMap.containsKey(\"\")){\\n                    ans.add(Arrays.asList(i, wordMap.get(\"\")));\\n                    ans.add(Arrays.asList(wordMap.get(\"\"), i));\\n                }\\n                continue;\\n            }\\n            String reverse= new StringBuilder(words[i]).reverse().toString();\\n            if(wordMap.containsKey(reverse) && wordMap.get(reverse) != i)\\n                ans.add(Arrays.asList(i,wordMap.get(reverse)));\\n            \\n\\n            for(Integer k:set){\\n                // means next strings will be larger than current one\\n                //hence no prefix suffix would be possible\\n                if(k == length) break;\\n                \\n                //adding prefix\\n                //string:  llsss\\n                //reverse: sssll\\n                //we are checking if ll is an palindrome\\n                if(isPalindrome(reverse,k,length-1)){\\n                    String s1 =  reverse.substring(0,k);\\n                    //there should be an string: sss in map\\n                    if(wordMap.containsKey(s1)){\\n                        ans.add(Arrays.asList(wordMap.get(s1),i));\\n                    }\\n                }\\n\\n                //adding suffix\\n                //string: sssll\\n                //reverse: llsss\\n                //ll should be an palindrome\\n                //remove sss, string of length k from end\\n                if(isPalindrome(reverse,0,length-1-k)){\\n                    //get sss: i.e. last k elements of reversed string\\n                    String s1 = reverse.substring(length-k);\\n                    if(wordMap.containsKey(s1)){\\n                        ans.add(Arrays.asList(i,wordMap.get(s1)));\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private boolean isPalindrome(String s, int left, int right){\\n        while(left<right)\\n            if(s.charAt(left++)!=s.charAt(right--))\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        HashMap<String,Integer> wordMap = new HashMap<>();\\n        Set<Integer> set = new TreeSet<>();\\n        int n = words.length;\\n        \\n        for(int i=0;i<n;i++){\\n            wordMap.put(words[i],i);\\n            set.add(words[i].length());\\n        }\\n        \\n        List<List<Integer>> ans = new ArrayList<>();\\n        \\n        for(int i=0;i<n;i++){\\n            int length = words[i].length();\\n            \\n            if(length ==1){\\n                if(wordMap.containsKey(\"\")){\\n                    ans.add(Arrays.asList(i, wordMap.get(\"\")));\\n                    ans.add(Arrays.asList(wordMap.get(\"\"), i));\\n                }\\n                continue;\\n            }\\n            String reverse= new StringBuilder(words[i]).reverse().toString();\\n            if(wordMap.containsKey(reverse) && wordMap.get(reverse) != i)\\n                ans.add(Arrays.asList(i,wordMap.get(reverse)));\\n            \\n\\n            for(Integer k:set){\\n                // means next strings will be larger than current one\\n                //hence no prefix suffix would be possible\\n                if(k == length) break;\\n                \\n                //adding prefix\\n                //string:  llsss\\n                //reverse: sssll\\n                //we are checking if ll is an palindrome\\n                if(isPalindrome(reverse,k,length-1)){\\n                    String s1 =  reverse.substring(0,k);\\n                    //there should be an string: sss in map\\n                    if(wordMap.containsKey(s1)){\\n                        ans.add(Arrays.asList(wordMap.get(s1),i));\\n                    }\\n                }\\n\\n                //adding suffix\\n                //string: sssll\\n                //reverse: llsss\\n                //ll should be an palindrome\\n                //remove sss, string of length k from end\\n                if(isPalindrome(reverse,0,length-1-k)){\\n                    //get sss: i.e. last k elements of reversed string\\n                    String s1 = reverse.substring(length-k);\\n                    if(wordMap.containsKey(s1)){\\n                        ans.add(Arrays.asList(i,wordMap.get(s1)));\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private boolean isPalindrome(String s, int left, int right){\\n        while(left<right)\\n            if(s.charAt(left++)!=s.charAt(right--))\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588700,
                "title": "python-100-speed-99-8-space-detailed-comments-sort-and-hashmap",
                "content": "![image](https://assets.leetcode.com/users/images/97a58d25-fc7c-4821-9561-6543173d3735_1663437409.8188717.png)\\n\\n\\n\\n```python\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        # list of (index, word, is_reversed), `word` can be either a orginal word or a reversed word\\n        # the list is sorted so that words with similar prefix are consecutive\\n        words = sorted(chain(((i, w, False) for i, w in enumerate(words)), \\n                             ((i, w[::-1], True) for i, w in enumerate(words))),\\n                             key=lambda x: x[1])\\n        \\n        # Loop through each word         \\n        for i, (idx1, w1, is_reversed1) in enumerate(words):\\n            # Look at each word (w2) after the current word (w1) to find a prefix of the current word\\n            # When w1 is a prefix of w2 then w1 + w2[::-1] is a palindrome\\n            # Because the words are sorted, if w1 is a prefix of w2 then w1 will come before w2, so we only need to start from i + 1\\n            for j in range(i + 1, len(words)):\\n                idx2, w2, is_reversed2 = words[j]\\n                if w2.startswith(w1):\\n                    # we want one of w1 and w2 is a reversed word\\n                    # because if w1 is a prefix of w2 but both w1 and w2 are in the orginal words then w1 + w2[::-1] cannot be a palindrome\\n                    if is_reversed1 == is_reversed2:\\n                        continue\\n                    rest = w2[len(w1):]\\n                    # check idx1 != idx2 for cases where a word is a palindrome itself\\n                    # then check whether the postfix of w2 is a palindrome\\n                    if idx1 != idx2 and rest == rest[::-1]:\\n                        # if w1 is an original word and w2 is a reversed word, then w1 + w2[::-1] is a palindrome => return (idx1, idx2)\\n                        # otherwise w1 + w2[::-1] = w2 + w1[::] is a palindrome => return (idx2, idx1)\\n                        yield (idx1, idx2) if is_reversed2 else (idx2, idx1)\\n                else:\\n                    # because the words are sorted, so if we found a word that is not a prefix of the curent word \\n                    # then every word after that can\\'t be a prefix of the current word\\n                    break\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        # list of (index, word, is_reversed), `word` can be either a orginal word or a reversed word\\n        # the list is sorted so that words with similar prefix are consecutive\\n        words = sorted(chain(((i, w, False) for i, w in enumerate(words)), \\n                             ((i, w[::-1], True) for i, w in enumerate(words))),\\n                             key=lambda x: x[1])\\n        \\n        # Loop through each word         \\n        for i, (idx1, w1, is_reversed1) in enumerate(words):\\n            # Look at each word (w2) after the current word (w1) to find a prefix of the current word\\n            # When w1 is a prefix of w2 then w1 + w2[::-1] is a palindrome\\n            # Because the words are sorted, if w1 is a prefix of w2 then w1 will come before w2, so we only need to start from i + 1\\n            for j in range(i + 1, len(words)):\\n                idx2, w2, is_reversed2 = words[j]\\n                if w2.startswith(w1):\\n                    # we want one of w1 and w2 is a reversed word\\n                    # because if w1 is a prefix of w2 but both w1 and w2 are in the orginal words then w1 + w2[::-1] cannot be a palindrome\\n                    if is_reversed1 == is_reversed2:\\n                        continue\\n                    rest = w2[len(w1):]\\n                    # check idx1 != idx2 for cases where a word is a palindrome itself\\n                    # then check whether the postfix of w2 is a palindrome\\n                    if idx1 != idx2 and rest == rest[::-1]:\\n                        # if w1 is an original word and w2 is a reversed word, then w1 + w2[::-1] is a palindrome => return (idx1, idx2)\\n                        # otherwise w1 + w2[::-1] = w2 + w1[::] is a palindrome => return (idx2, idx1)\\n                        yield (idx1, idx2) if is_reversed2 else (idx2, idx1)\\n                else:\\n                    # because the words are sorted, so if we found a word that is not a prefix of the curent word \\n                    # then every word after that can\\'t be a prefix of the current word\\n                    break\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588000,
                "title": "trie-solution-well-commented-cpp",
                "content": "\\n\\nExplanation : First Insert all strings in reverse order, then search for each string , whether it forms a palindorme or not in Trie.\\n\\nNote-> If some characters matches while searching, then check if all other substrings after this point, are they palindrome or not.\\n\\nthere are two cases for a palindrome of two strings\\n\\ncase 1:\\n    let the strings be [bd, dbccc]\\n    here the words will be inserted in reverse order\\n\\tso while searching \\n    i=1;\\n    dbccc\\n    we find first two characters of dbccc in trie(as bd s inserted in reverse), so other three characters should be palindrome, the other characters should be checked seperately,\\n    \\ncase 2:\\n    let the strings be \"abacd\", \"dc\"  \\n    here the words will be inserted in reverse order\\n    so while searching\\n    for i=1\\n    dc\\n    we will find dc in the tree(as abacd is inserted in reverse), the remaining 3 elements aba in the trie, should be checked for palindrome\\n```\\n//trie node\\nstruct TrieNode\\n{\\n    TrieNode* links[26];\\n    int index;\\n};\\n\\n\\nclass Trie\\n{\\nprivate:\\n    //root of the trie\\n    TrieNode* root;\\npublic:\\n    //contsructor creates the root while a object is created\\n    Trie()\\n    {\\n        root = getNewNode();\\n    }\\n    \\n    //returns a newnode with all initialized to nulls,\\n    TrieNode* getNewNode()\\n    {\\n        TrieNode* newNode = new TrieNode;\\n        for(int i=0; i<26; i++)\\n        {\\n            newNode->links[i] = NULL;\\n        }\\n        newNode->index = -1;\\n        \\n        return newNode;\\n        \\n    }\\n    \\n    //inserting in reverse order, the first letter which will be last element in the trie, will have its index as, its original index in the given array \\n    void insert(string s, int ind)\\n    {\\n        \\n        int len = s.size();\\n        \\n        TrieNode* tempRoot = root;\\n        \\n        for(int i=len-1; i>=0; i--)\\n        {\\n            \\n            if(tempRoot -> links[s[i] - \\'a\\'] == NULL)\\n            {\\n                tempRoot -> links[ s[i] - \\'a\\' ] = getNewNode();\\n            }\\n            \\n            tempRoot = tempRoot -> links[s[i] - \\'a\\'];\\n            \\n        }\\n        \\n        tempRoot -> index = ind;\\n        \\n    }\\n    \\n    //simple palindrome function \\n    bool isPalindrome(string s, int low, int high)\\n    {\\n        while(low <= high)\\n        {\\n            if(s[low] != s[high])\\n            {\\n                return false;\\n            }\\n            low++;\\n            high--;\\n        }\\n        return true;\\n    }\\n    \\n    // case 2 check\\n    void search2ForCase2(TrieNode* root, vector<int> &palindrome, string s)\\n    {\\n        \\n        if(root->index != -1)\\n        {  \\n            int low = 0;\\n            int high = s.size() -1;\\n            if(isPalindrome(s, low, high))\\n            {\\n                palindrome.push_back(root->index);\\n            }\\n            \\n        }\\n        \\n        for(int i=0; i<26; i++)\\n        {\\n            if(root->links[i] != NULL)\\n            {\\n                s.push_back(\\'a\\' + i);\\n                search2ForCase2(root->links[i], palindrome, s);\\n                s.pop_back();\\n            }\\n        }\\n        \\n        \\n    }\\n    \\n    //casse 1 check\\n    vector<int> search1ForCase1(string s, vector<int> &palindrome)\\n    {\\n    \\n        \\n        TrieNode* tempRoot = root;\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(tempRoot -> index != -1)\\n            {\\n                int low = i;\\n                int high = s.size() -1;\\n                if(isPalindrome(s, low, high))\\n                {\\n                    palindrome.push_back(tempRoot->index);\\n                }\\n            }\\n            \\n            if(tempRoot -> links[s[i] - \\'a\\'] == NULL)\\n            {\\n                return palindrome;\\n            }\\n            else\\n            {\\n                tempRoot = tempRoot->links[s[i] - \\'a\\'];\\n        \\n            }\\n        }\\n        \\n        search2ForCase2(tempRoot, palindrome, \"\");\\n        \\n        return palindrome;\\n    }\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        //object\\n        Trie trie;\\n        \\n        //inserting all words\\n        int n = words.size();\\n        for(int i=0; i<n; i++)\\n        {\\n            trie.insert(words[i], i);\\n        }\\n        \\n        vector<vector<int>> ans;\\n        \\n        //finding palindromes for each word one by one\\n        for(int i=0; i<n; i++)\\n        {\\n            \\n            vector<int> palindrome;\\n            trie.search1ForCase1(words[i], palindrome);\\n            \\n            //appeding it to the ans, ignoring the self palindrome\\n            // [\"aba\"] if this is the only string, then [0,0] will be the output\\n            //which is not valid, so => (it!=i)\\n            for(auto it : palindrome)\\n            {\\n                if(it != i)\\n                {\\n                    ans.push_back({i, it});\\n                }\\n            }\\n            \\n        }\\n        \\n        //return the ans\\n        return ans;\\n        \\n    }\\n};\\n```\\nFeel free to comment \\nMention if any improvements can be done\\nKeep Coding <3",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "```\\n//trie node\\nstruct TrieNode\\n{\\n    TrieNode* links[26];\\n    int index;\\n};\\n\\n\\nclass Trie\\n{\\nprivate:\\n    //root of the trie\\n    TrieNode* root;\\npublic:\\n    //contsructor creates the root while a object is created\\n    Trie()\\n    {\\n        root = getNewNode();\\n    }\\n    \\n    //returns a newnode with all initialized to nulls,\\n    TrieNode* getNewNode()\\n    {\\n        TrieNode* newNode = new TrieNode;\\n        for(int i=0; i<26; i++)\\n        {\\n            newNode->links[i] = NULL;\\n        }\\n        newNode->index = -1;\\n        \\n        return newNode;\\n        \\n    }\\n    \\n    //inserting in reverse order, the first letter which will be last element in the trie, will have its index as, its original index in the given array \\n    void insert(string s, int ind)\\n    {\\n        \\n        int len = s.size();\\n        \\n        TrieNode* tempRoot = root;\\n        \\n        for(int i=len-1; i>=0; i--)\\n        {\\n            \\n            if(tempRoot -> links[s[i] - \\'a\\'] == NULL)\\n            {\\n                tempRoot -> links[ s[i] - \\'a\\' ] = getNewNode();\\n            }\\n            \\n            tempRoot = tempRoot -> links[s[i] - \\'a\\'];\\n            \\n        }\\n        \\n        tempRoot -> index = ind;\\n        \\n    }\\n    \\n    //simple palindrome function \\n    bool isPalindrome(string s, int low, int high)\\n    {\\n        while(low <= high)\\n        {\\n            if(s[low] != s[high])\\n            {\\n                return false;\\n            }\\n            low++;\\n            high--;\\n        }\\n        return true;\\n    }\\n    \\n    // case 2 check\\n    void search2ForCase2(TrieNode* root, vector<int> &palindrome, string s)\\n    {\\n        \\n        if(root->index != -1)\\n        {  \\n            int low = 0;\\n            int high = s.size() -1;\\n            if(isPalindrome(s, low, high))\\n            {\\n                palindrome.push_back(root->index);\\n            }\\n            \\n        }\\n        \\n        for(int i=0; i<26; i++)\\n        {\\n            if(root->links[i] != NULL)\\n            {\\n                s.push_back(\\'a\\' + i);\\n                search2ForCase2(root->links[i], palindrome, s);\\n                s.pop_back();\\n            }\\n        }\\n        \\n        \\n    }\\n    \\n    //casse 1 check\\n    vector<int> search1ForCase1(string s, vector<int> &palindrome)\\n    {\\n    \\n        \\n        TrieNode* tempRoot = root;\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(tempRoot -> index != -1)\\n            {\\n                int low = i;\\n                int high = s.size() -1;\\n                if(isPalindrome(s, low, high))\\n                {\\n                    palindrome.push_back(tempRoot->index);\\n                }\\n            }\\n            \\n            if(tempRoot -> links[s[i] - \\'a\\'] == NULL)\\n            {\\n                return palindrome;\\n            }\\n            else\\n            {\\n                tempRoot = tempRoot->links[s[i] - \\'a\\'];\\n        \\n            }\\n        }\\n        \\n        search2ForCase2(tempRoot, palindrome, \"\");\\n        \\n        return palindrome;\\n    }\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        //object\\n        Trie trie;\\n        \\n        //inserting all words\\n        int n = words.size();\\n        for(int i=0; i<n; i++)\\n        {\\n            trie.insert(words[i], i);\\n        }\\n        \\n        vector<vector<int>> ans;\\n        \\n        //finding palindromes for each word one by one\\n        for(int i=0; i<n; i++)\\n        {\\n            \\n            vector<int> palindrome;\\n            trie.search1ForCase1(words[i], palindrome);\\n            \\n            //appeding it to the ans, ignoring the self palindrome\\n            // [\"aba\"] if this is the only string, then [0,0] will be the output\\n            //which is not valid, so => (it!=i)\\n            for(auto it : palindrome)\\n            {\\n                if(it != i)\\n                {\\n                    ans.push_back({i, it});\\n                }\\n            }\\n            \\n        }\\n        \\n        //return the ans\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587209,
                "title": "latest-code-solved-time-limit-exceeds-problem",
                "content": "**IF THIS CODE HELPS YOU THEN PLEASE UPVOTE :)\\t**\\n\\t\\n\\tclass Solution {\\n\\t  public List<List<Integer>> palindromePairs(String[] words) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    Map<String, Integer> map = new HashMap<>(); // {reversed word: its index}\\n\\n    for (int i = 0; i < words.length; ++i)\\n      map.put(new StringBuilder(words[i]).reverse().toString(), i);\\n\\n    for (int i = 0; i < words.length; ++i) {\\n      final String word = words[i];\\n      // special case to prevent duplicate calculation\\n      if (map.containsKey(\"\") && map.get(\"\") != i && isPalindrome(word))\\n        ans.add(Arrays.asList(i, map.get(\"\")));\\n      for (int j = 1; j <= word.length(); ++j) {\\n        final String l = word.substring(0, j);\\n        final String r = word.substring(j);\\n        if (map.containsKey(l) && map.get(l) != i && isPalindrome(r))\\n          ans.add(Arrays.asList(i, map.get(l)));\\n        if (map.containsKey(r) && map.get(r) != i && isPalindrome(l))\\n          ans.add(Arrays.asList(map.get(r), i));\\n      }\\n    }\\n\\n    return ans;\\n\\t  }\\n\\n\\t  private boolean isPalindrome(final String word) {\\n\\t\\tint l = 0;\\n\\t\\tint r = word.length() - 1;\\n\\t\\twhile (l < r)\\n\\t\\t  if (word.charAt(l++) != word.charAt(r--))\\n\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t  }\\n\\t}\\n#copied",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t  public List<List<Integer>> palindromePairs(String[] words) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    Map<String, Integer> map = new HashMap<>(); // {reversed word: its index}",
                "codeTag": "Java"
            },
            {
                "id": 2586992,
                "title": "palindrome-pairs-problem-easy-understanding",
                "content": "```\\nclass Solution {\\n    bool check_palindrome(string &s)\\n    {\\n        int i=0;\\n        int j = s.length()-1;\\n        while(i<=j)\\n        {\\n            if(s[i++] != s[j--])\\n            {\\n                return false;\\n            }\\n        }\\n      return true;\\n    }\\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n          vector<vector<int>> ans;\\n          unordered_map<string,int> mp;\\n          for(int i=0;i<words.size();i++)\\n          {\\n              string temp  = words[i];\\n              reverse(temp.begin(),temp.end());\\n              mp[temp] = i;\\n          }\\n        \\n          if(mp.find(\"\") != mp.end())\\n          {\\n              for(int i=0;i<words.size();i++)\\n              {\\n                  if(!words[i].empty() && check_palindrome(words[i]))\\n                  {\\n                     ans.push_back({i,mp[\"\"]});\\n                  }\\n              }\\n          }\\n        \\n          for(int i=0;i<words.size();i++)\\n          {\\n              string left=\"\",right=\"\";\\n              for(int j=0;j<words[i].size();j++)\\n              {\\n                  left.push_back(words[i][j]);\\n                  right = words[i].substr(j+1);\\n                 if(mp.count(left) && i != mp[left] && check_palindrome(right))\\n                 {\\n                     ans.push_back({i,mp[left]});\\n                 }\\n                  \\n                  if(mp.count(right) && i!=mp[right] && check_palindrome(left))\\n                  {\\n                      ans.push_back({mp[right],i});\\n                  }\\n                \\n              } \\n          }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    bool check_palindrome(string &s)\\n    {\\n        int i=0;\\n        int j = s.length()-1;\\n        while(i<=j)\\n        {\\n            if(s[i++] != s[j--])\\n            {\\n                return false;\\n            }\\n        }\\n      return true;\\n    }\\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n          vector<vector<int>> ans;\\n          unordered_map<string,int> mp;\\n          for(int i=0;i<words.size();i++)\\n          {\\n              string temp  = words[i];\\n              reverse(temp.begin(),temp.end());\\n              mp[temp] = i;\\n          }\\n        \\n          if(mp.find(\"\") != mp.end())\\n          {\\n              for(int i=0;i<words.size();i++)\\n              {\\n                  if(!words[i].empty() && check_palindrome(words[i]))\\n                  {\\n                     ans.push_back({i,mp[\"\"]});\\n                  }\\n              }\\n          }\\n        \\n          for(int i=0;i<words.size();i++)\\n          {\\n              string left=\"\",right=\"\";\\n              for(int j=0;j<words[i].size();j++)\\n              {\\n                  left.push_back(words[i][j]);\\n                  right = words[i].substr(j+1);\\n                 if(mp.count(left) && i != mp[left] && check_palindrome(right))\\n                 {\\n                     ans.push_back({i,mp[left]});\\n                 }\\n                  \\n                  if(mp.count(right) && i!=mp[right] && check_palindrome(left))\\n                  {\\n                      ans.push_back({mp[right],i});\\n                  }\\n                \\n              } \\n          }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585875,
                "title": "java-hashmap-manacher-s-alogorithm-o-n-w-80-time-space",
                "content": "This approach uses Manacher\\'s Algorithm to acheive linear time for calculation of all palidromes within a string.\\nPlease use this [article](https://www.scaler.com/topics/data-structures/manachers-algorithm/) for an in-depth explanation of the algorithm.\\n\\nNow that we can detect all palidromes in a word, we can use a HashMap to find any possible pairs. Here are cases of pairs:\\n1. If the palidrome extends to the start of the word, the word will form a pair with the reverse of the leftover. Ex: \"abade\" comprise of the palidrome, \"aba\", and its leftover, \"de\", so it can form a pair with word \"ed\" resulting in \"edabade\". \\n2. If the palidrome extends to the end of the word, the same concept applies but the leftover is at the front of the palidrome.\\n3. Notice that both cases above takes care of the edge case involving a blank string \"\" but they can create duplicates in some cases.\\n\\nWithout further ado, here is the code:\\n\\n```\\npublic class Solution {\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        List<List<Integer>> ans = new ArrayList<>(); \\n        if (words == null || words.length < 2) return ans;\\n\\t\\t\\n\\t\\t// Build a map of all the current words. Will be used to find pairs in constant time.\\n        Map<String, Integer> map = new HashMap<String, Integer>();\\n        for (int i=0; i<words.length; i++) map.put(words[i], i);\\n        \\n        for (int i=0; i<words.length; i++) {\\n\\t\\t\\t\\n\\t\\t\\t// Creating a reverse string to use for checking\\n            String reverse = new StringBuilder(words[i]).reverse().toString();\\n            \\n\\t\\t\\t// Start of Manacher\\'s Algorithm\\n            char[] extended = new char[words[i].length()*2+1];\\n            for(int j = 0; j < words[i].length(); ++j)\\n                extended[j*2+1]=words[i].charAt(j);\\n            \\n            int center = 0, radius = 0;\\n            int oldCenter = 0, oldRadius = 0;\\n            int mirroredCenter = 0, maxMirroredRadius = 0;\\n            int[] radii = new int[extended.length];\\n            \\n            while(center<extended.length){\\n                while(center-radius-1>=0 && \\n                      center+radius+1<extended.length && \\n                      extended[center-radius-1]==extended[center+radius+1])\\n                    radius++;\\n                \\n                radii[center] = radius;\\n                oldCenter = center;\\n                oldRadius = radius;\\n                \\n                // Check for any pair from the detected palidrome\\n                checkPair(radius,center,radii.length-1,i,reverse,map,ans);\\n                center++;\\n                radius = 0;\\n\\n                while(center<=oldCenter+oldRadius){\\n                    mirroredCenter = oldCenter - (center - oldCenter);\\n                    maxMirroredRadius = oldCenter + oldRadius - center;\\n\\n                    if(radii[mirroredCenter]<maxMirroredRadius){\\n                        radii[center]=radii[mirroredCenter];\\n\\t\\t\\t\\t\\t\\t// Check for any pair from the detected palidrome\\n                        checkPair(radii[center],center,radii.length-1,i,reverse,map,ans);\\n                        center++;\\n                    } else if (radii[mirroredCenter]>maxMirroredRadius){\\n                        radii[center]=maxMirroredRadius;\\n\\t\\t\\t\\t\\t\\t// Check for any pair from the detected palidrome\\n                        checkPair(radii[center],center,radii.length-1,i,reverse,map,ans);\\n                        center++;\\n                    } else {\\n                        radius = maxMirroredRadius;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private void checkPair(int radius, int center, int end, int i, String reverse, Map<String,Integer> map, List<List<Integer>> ans){\\n\\t\\t// If the palidrome reaches to the start of the word\\n        if(center-radius==0){\\n            String check = reverse.substring(0,reverse.length()-radius);\\n            if(map.containsKey(check))\\n                addPair(map.get(check),i,ans);\\n        }\\n         // If the palidrome reaches to the end of the word. Also takes care of possible duplicate case.\\n        if(center+radius==end && center!=end){\\n            String check = reverse.substring(radius);\\n            if(map.containsKey(check))\\n                addPair(i,map.get(check),ans);\\n        }\\n    }\\n    \\n    private void addPair(int i, int j, List<List<Integer>> ans){\\n\\t\\t// Do not add if the words are the same\\n        if(i==j) return;\\n        \\n        List<Integer> pair = new ArrayList<>(2);\\n        pair.add(i);\\n        pair.add(j);\\n        ans.add(pair);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        List<List<Integer>> ans = new ArrayList<>(); \\n        if (words == null || words.length < 2) return ans;\\n\\t\\t\\n\\t\\t// Build a map of all the current words. Will be used to find pairs in constant time.\\n        Map<String, Integer> map = new HashMap<String, Integer>();\\n        for (int i=0; i<words.length; i++) map.put(words[i], i);\\n        \\n        for (int i=0; i<words.length; i++) {\\n\\t\\t\\t\\n\\t\\t\\t// Creating a reverse string to use for checking\\n            String reverse = new StringBuilder(words[i]).reverse().toString();\\n            \\n\\t\\t\\t// Start of Manacher\\'s Algorithm\\n            char[] extended = new char[words[i].length()*2+1];\\n            for(int j = 0; j < words[i].length(); ++j)\\n                extended[j*2+1]=words[i].charAt(j);\\n            \\n            int center = 0, radius = 0;\\n            int oldCenter = 0, oldRadius = 0;\\n            int mirroredCenter = 0, maxMirroredRadius = 0;\\n            int[] radii = new int[extended.length];\\n            \\n            while(center<extended.length){\\n                while(center-radius-1>=0 && \\n                      center+radius+1<extended.length && \\n                      extended[center-radius-1]==extended[center+radius+1])\\n                    radius++;\\n                \\n                radii[center] = radius;\\n                oldCenter = center;\\n                oldRadius = radius;\\n                \\n                // Check for any pair from the detected palidrome\\n                checkPair(radius,center,radii.length-1,i,reverse,map,ans);\\n                center++;\\n                radius = 0;\\n\\n                while(center<=oldCenter+oldRadius){\\n                    mirroredCenter = oldCenter - (center - oldCenter);\\n                    maxMirroredRadius = oldCenter + oldRadius - center;\\n\\n                    if(radii[mirroredCenter]<maxMirroredRadius){\\n                        radii[center]=radii[mirroredCenter];\\n\\t\\t\\t\\t\\t\\t// Check for any pair from the detected palidrome\\n                        checkPair(radii[center],center,radii.length-1,i,reverse,map,ans);\\n                        center++;\\n                    } else if (radii[mirroredCenter]>maxMirroredRadius){\\n                        radii[center]=maxMirroredRadius;\\n\\t\\t\\t\\t\\t\\t// Check for any pair from the detected palidrome\\n                        checkPair(radii[center],center,radii.length-1,i,reverse,map,ans);\\n                        center++;\\n                    } else {\\n                        radius = maxMirroredRadius;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private void checkPair(int radius, int center, int end, int i, String reverse, Map<String,Integer> map, List<List<Integer>> ans){\\n\\t\\t// If the palidrome reaches to the start of the word\\n        if(center-radius==0){\\n            String check = reverse.substring(0,reverse.length()-radius);\\n            if(map.containsKey(check))\\n                addPair(map.get(check),i,ans);\\n        }\\n         // If the palidrome reaches to the end of the word. Also takes care of possible duplicate case.\\n        if(center+radius==end && center!=end){\\n            String check = reverse.substring(radius);\\n            if(map.containsKey(check))\\n                addPair(i,map.get(check),ans);\\n        }\\n    }\\n    \\n    private void addPair(int i, int j, List<List<Integer>> ans){\\n\\t\\t// Do not add if the words are the same\\n        if(i==j) return;\\n        \\n        List<Integer> pair = new ArrayList<>(2);\\n        pair.add(i);\\n        pair.add(j);\\n        ans.add(pair);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585570,
                "title": "java-accepted-without-using-trie",
                "content": "```\\nclass Solution {\\n\\tpublic List<List<Integer>> palindromePairs(String[] words) {\\n\\t\\tList<List<Integer>> res = new ArrayList<List<Integer>>();\\n\\t\\tif (words == null || words.length == 0) {\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t\\tint[] temp = new int[5002];\\n\\t\\tHashMap<String, Integer> map = new HashMap<>();\\n\\t\\tfor (int i = 0; i < words.length; i++) {\\n\\t\\t\\tmap.put(words[i], i);\\n\\t\\t\\ttemp[words[i].length()]++;\\n\\t\\t}\\n\\n\\t\\tif (map.containsKey(\"\")) {\\n\\t\\t\\tint index = map.get(\"\");\\n\\t\\t\\tfor (int i = 0; i < words.length; i++) {\\n\\t\\t\\t\\tif (isPalindrome(words[i], 0, words[i].length() - 1)) {\\n\\t\\t\\t\\t\\tif (i == index)\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\tres.add(Arrays.asList(index, i));\\n\\t\\t\\t\\t\\tres.add(Arrays.asList(i, index));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < words.length; i++) {\\n\\t\\t\\tString cur_r = reverseStr(words[i]);\\n\\t\\t\\tif (map.containsKey(cur_r)) {\\n\\t\\t\\t\\tint found = map.get(cur_r);\\n\\t\\t\\t\\tif (found == i)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tres.add(Arrays.asList(i, found));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < words.length; i++) {\\n\\t\\t\\tString cur = words[i];\\n\\t\\t\\tfor (int cut = 1; cut < cur.length(); cut++) {\\n\\t\\t\\t\\tif (temp[cur.length() - cut] > 0 && isPalindrome(cur, 0, cut - 1)) {\\n\\t\\t\\t\\t\\tString cut_r = reverseStr(cur.substring(cut));\\n\\t\\t\\t\\t\\tif (map.containsKey(cut_r)) {\\n\\t\\t\\t\\t\\t\\tint found = map.get(cut_r);\\n\\t\\t\\t\\t\\t\\tif (found == i)\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\tres.add(Arrays.asList(found, i));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (temp[cut] > 0 && isPalindrome(cur, cut, cur.length() - 1)) {\\n\\t\\t\\t\\t\\tString cut_r = reverseStr(cur.substring(0, cut));\\n\\t\\t\\t\\t\\tif (map.containsKey(cut_r)) {\\n\\t\\t\\t\\t\\t\\tint found = map.get(cut_r);\\n\\t\\t\\t\\t\\t\\tif (found == i)\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\tres.add(Arrays.asList(i, found));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\n\\tpublic String reverseStr(String str) {\\n\\t\\tStringBuilder sb = new StringBuilder(str);\\n\\t\\treturn sb.reverse().toString();\\n\\t}\\n\\n\\tpublic boolean isPalindrome(String s, int i, int j) {\\n\\t\\twhile (i < j) {\\n\\t\\t\\tif (s.charAt(i) != s.charAt(j)) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t\\tj--;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic List<List<Integer>> palindromePairs(String[] words) {\\n\\t\\tList<List<Integer>> res = new ArrayList<List<Integer>>();\\n\\t\\tif (words == null || words.length == 0) {\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t\\tint[] temp = new int[5002];\\n\\t\\tHashMap<String, Integer> map = new HashMap<>();\\n\\t\\tfor (int i = 0; i < words.length; i++) {\\n\\t\\t\\tmap.put(words[i], i);\\n\\t\\t\\ttemp[words[i].length()]++;\\n\\t\\t}\\n\\n\\t\\tif (map.containsKey(\"\")) {\\n\\t\\t\\tint index = map.get(\"\");\\n\\t\\t\\tfor (int i = 0; i < words.length; i++) {\\n\\t\\t\\t\\tif (isPalindrome(words[i], 0, words[i].length() - 1)) {\\n\\t\\t\\t\\t\\tif (i == index)\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\tres.add(Arrays.asList(index, i));\\n\\t\\t\\t\\t\\tres.add(Arrays.asList(i, index));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < words.length; i++) {\\n\\t\\t\\tString cur_r = reverseStr(words[i]);\\n\\t\\t\\tif (map.containsKey(cur_r)) {\\n\\t\\t\\t\\tint found = map.get(cur_r);\\n\\t\\t\\t\\tif (found == i)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tres.add(Arrays.asList(i, found));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < words.length; i++) {\\n\\t\\t\\tString cur = words[i];\\n\\t\\t\\tfor (int cut = 1; cut < cur.length(); cut++) {\\n\\t\\t\\t\\tif (temp[cur.length() - cut] > 0 && isPalindrome(cur, 0, cut - 1)) {\\n\\t\\t\\t\\t\\tString cut_r = reverseStr(cur.substring(cut));\\n\\t\\t\\t\\t\\tif (map.containsKey(cut_r)) {\\n\\t\\t\\t\\t\\t\\tint found = map.get(cut_r);\\n\\t\\t\\t\\t\\t\\tif (found == i)\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\tres.add(Arrays.asList(found, i));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (temp[cut] > 0 && isPalindrome(cur, cut, cur.length() - 1)) {\\n\\t\\t\\t\\t\\tString cut_r = reverseStr(cur.substring(0, cut));\\n\\t\\t\\t\\t\\tif (map.containsKey(cut_r)) {\\n\\t\\t\\t\\t\\t\\tint found = map.get(cut_r);\\n\\t\\t\\t\\t\\t\\tif (found == i)\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\tres.add(Arrays.asList(i, found));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\n\\tpublic String reverseStr(String str) {\\n\\t\\tStringBuilder sb = new StringBuilder(str);\\n\\t\\treturn sb.reverse().toString();\\n\\t}\\n\\n\\tpublic boolean isPalindrome(String s, int i, int j) {\\n\\t\\twhile (i < j) {\\n\\t\\t\\tif (s.charAt(i) != s.charAt(j)) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t\\tj--;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2212921,
                "title": "c-solution-using-unordered-map-some-tips-to-avoid-tle-o-n-k-2",
                "content": "What helped me to understand the solution is by thinking the following cases:\\n\\n```cpp\\n[\"tabxyx\", \"bat\"]\\n[\"batxyx\", \"tab\"]\\n[\"bat\", \"xyxtab\"]\\n[\"tab\", \"xyxbat\"]\\n```\\n\\nWe can see that the only concatenated string either `tabxyxbat` or `batxyxtab` mirrors at the character `y`, so it\\'s easy to see that if we can find a substring (e.g., `substr(\"tabxyx\", 0, 3) == \"tab\"`) in another reversed string (e.g., `reverse(\"bat\") == \"tab\"`), the only left part is checking if the remaining substring `xyx` is palindrome or not.\\n\\nInpired by other two solutions ([solution1](https://leetcode.com/problems/palindrome-pairs/discuss/79215/Easy-to-understand-AC-C%2B%2B-solution-O(n*k2)-using-map), [solution2](https://leetcode.com/problems/palindrome-pairs/discuss/2174302/C%2B%2B-or-Concise-solution-with-hashing-O(n*k2)-(no-TLE))), I did two modifications to finally get rid of TLE:\\n1. Use `emplace_back` instead of `push_back` since `push_back` would do an unnecessary copy\\n2. Use `string_view` instead of `string` to avoid copying when creating the substrings\\n\\nIt\\'s a bit lenghy than most of the other solutions, but I think wrapping logic inside functions may be more easy to understand what\\'s happening.\\n\\nThe time complexity `n` is the number of words, `k` is the maximum length of any word. Since we iterate every possible smaller substring length from `0` to `k` and the inner loop checks whether the remaining substring is palindrome, it contributes to the `k^2` part.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        const int wordSize = words.size();\\n        vector<string> reversedWords(wordSize);\\n        for (int i = 0; i < wordSize; i++) {\\n            string s = words[i];\\n            std::reverse(s.begin(), s.end());\\n            reversedWords[i] = s;\\n            reversedWordToIndex[reversedWords[i]] = i;\\n        }\\n        \\n        // \"\" matches with every word if the word is palindrome\\n        const auto itEmpty = reversedWordToIndex.find(\"\");\\n        if (itEmpty != reversedWordToIndex.end()) {\\n            const int emptyIndex = itEmpty->second;\\n            for (int i = 0; i < wordSize; i++) {\\n                if (i == emptyIndex) continue;\\n                const string &word = words[i];\\n                const int wordLen = word.length();\\n                if (!isPalindrome(word, 0, wordLen - 1)) continue;\\n                results.emplace_back(vector<int>{emptyIndex, i});\\n                results.emplace_back(vector<int>{i, emptyIndex});\\n            }\\n        }\\n        \\n        for (int i = 0; i < wordSize; i++) {\\n            const string &word = words[i];\\n            const int wordLen = word.length();\\n            \\n            // Check if substr(word, sublen) from left == reversedWord\\n            for (int sublen = 1; sublen < wordLen; sublen++) {\\n                const int matchIndex = findLeftSubstrMatchIndex(word, sublen);\\n                if (matchIndex < 0 || matchIndex == i) continue;\\n                results.emplace_back(vector<int>{i, matchIndex});\\n            }\\n            \\n            // Check if substr(word, sublen) from right == reversedWord\\n            for (int sublen = 1; sublen < wordLen; sublen++) {\\n                const int matchIndex = findRightSubstrMatchIndex(word, sublen);\\n                if (matchIndex < 0 || matchIndex == i) continue;\\n                results.emplace_back(vector<int>{matchIndex, i});\\n            }\\n            \\n            // Check if word == reversedWord\\n            const int matchIndex = findLeftSubstrMatchIndex(word, wordLen);\\n            if (matchIndex < 0 || matchIndex >= i) continue; // matchIndex >= i is to avoid duplicate pairs, matchIndex <= i would also be okay\\n            results.emplace_back(vector<int>{i, matchIndex});\\n            results.emplace_back(vector<int>{matchIndex, i});\\n        }\\n        return results;\\n    }\\n    \\n    // words=[\"batx\", \"tab\"]\\n    // reversed=[\"xtab\", \"bat\"]\\n    // substr(word=\"batx\", sublen=3) = \"bat\"\\n    int findLeftSubstrMatchIndex(const string &word, const int sublen) {\\n        const string_view part(word.c_str(), sublen);\\n        const auto it = reversedWordToIndex.find(part);\\n        if (it == reversedWordToIndex.end()) return -1;\\n        if (isPalindrome(word, sublen, word.length() - 1)) return it->second;\\n        return -1;\\n    }\\n    \\n    // words=[\"tabx\", \"bat\"]\\n    // reversed=[\"xtab\", \"tab\"]\\n    // substr(word=\"xtab\", sublen=3) = \"tab\"\\n    int findRightSubstrMatchIndex(const string &word, const int sublen) {\\n        const string_view part(word.c_str() + word.length() - sublen);\\n        const auto it = reversedWordToIndex.find(part);\\n        if (it == reversedWordToIndex.end()) return -1;\\n        if (isPalindrome(word, 0, word.length() - sublen - 1)) return it->second;\\n        return -1;\\n    }\\n    \\n    bool isPalindrome(const string &word, int left, int right) {\\n        while (left < right && word[left] == word[right]) {\\n            left++;\\n            right--;\\n        }\\n        return left >= right;\\n    }\\n    \\n    unordered_map<string_view, int> reversedWordToIndex;\\n    vector<vector<int>> results;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n[\"tabxyx\", \"bat\"]\\n[\"batxyx\", \"tab\"]\\n[\"bat\", \"xyxtab\"]\\n[\"tab\", \"xyxbat\"]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        const int wordSize = words.size();\\n        vector<string> reversedWords(wordSize);\\n        for (int i = 0; i < wordSize; i++) {\\n            string s = words[i];\\n            std::reverse(s.begin(), s.end());\\n            reversedWords[i] = s;\\n            reversedWordToIndex[reversedWords[i]] = i;\\n        }\\n        \\n        // \"\" matches with every word if the word is palindrome\\n        const auto itEmpty = reversedWordToIndex.find(\"\");\\n        if (itEmpty != reversedWordToIndex.end()) {\\n            const int emptyIndex = itEmpty->second;\\n            for (int i = 0; i < wordSize; i++) {\\n                if (i == emptyIndex) continue;\\n                const string &word = words[i];\\n                const int wordLen = word.length();\\n                if (!isPalindrome(word, 0, wordLen - 1)) continue;\\n                results.emplace_back(vector<int>{emptyIndex, i});\\n                results.emplace_back(vector<int>{i, emptyIndex});\\n            }\\n        }\\n        \\n        for (int i = 0; i < wordSize; i++) {\\n            const string &word = words[i];\\n            const int wordLen = word.length();\\n            \\n            // Check if substr(word, sublen) from left == reversedWord\\n            for (int sublen = 1; sublen < wordLen; sublen++) {\\n                const int matchIndex = findLeftSubstrMatchIndex(word, sublen);\\n                if (matchIndex < 0 || matchIndex == i) continue;\\n                results.emplace_back(vector<int>{i, matchIndex});\\n            }\\n            \\n            // Check if substr(word, sublen) from right == reversedWord\\n            for (int sublen = 1; sublen < wordLen; sublen++) {\\n                const int matchIndex = findRightSubstrMatchIndex(word, sublen);\\n                if (matchIndex < 0 || matchIndex == i) continue;\\n                results.emplace_back(vector<int>{matchIndex, i});\\n            }\\n            \\n            // Check if word == reversedWord\\n            const int matchIndex = findLeftSubstrMatchIndex(word, wordLen);\\n            if (matchIndex < 0 || matchIndex >= i) continue; // matchIndex >= i is to avoid duplicate pairs, matchIndex <= i would also be okay\\n            results.emplace_back(vector<int>{i, matchIndex});\\n            results.emplace_back(vector<int>{matchIndex, i});\\n        }\\n        return results;\\n    }\\n    \\n    // words=[\"batx\", \"tab\"]\\n    // reversed=[\"xtab\", \"bat\"]\\n    // substr(word=\"batx\", sublen=3) = \"bat\"\\n    int findLeftSubstrMatchIndex(const string &word, const int sublen) {\\n        const string_view part(word.c_str(), sublen);\\n        const auto it = reversedWordToIndex.find(part);\\n        if (it == reversedWordToIndex.end()) return -1;\\n        if (isPalindrome(word, sublen, word.length() - 1)) return it->second;\\n        return -1;\\n    }\\n    \\n    // words=[\"tabx\", \"bat\"]\\n    // reversed=[\"xtab\", \"tab\"]\\n    // substr(word=\"xtab\", sublen=3) = \"tab\"\\n    int findRightSubstrMatchIndex(const string &word, const int sublen) {\\n        const string_view part(word.c_str() + word.length() - sublen);\\n        const auto it = reversedWordToIndex.find(part);\\n        if (it == reversedWordToIndex.end()) return -1;\\n        if (isPalindrome(word, 0, word.length() - sublen - 1)) return it->second;\\n        return -1;\\n    }\\n    \\n    bool isPalindrome(const string &word, int left, int right) {\\n        while (left < right && word[left] == word[right]) {\\n            left++;\\n            right--;\\n        }\\n        return left >= right;\\n    }\\n    \\n    unordered_map<string_view, int> reversedWordToIndex;\\n    vector<vector<int>> results;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2177564,
                "title": "go-o-n-2",
                "content": "```\\nfunc palindromePairs(words []string) [][]int {\\n    var res [][]int\\n    \\n    var isPalindromic func(string) bool\\n    isPalindromic = func(str string) bool {\\n        if len(str) < 2 {return true}\\n        l, r := 0, len(str) - 1\\n        for l < r {\\n            if str[l] != str[r] {return false}\\n            l, r = l + 1, r - 1\\n        }\\n        return true\\n    }\\n    \\n    for i := 0; i < len(words); i++ {\\n        for j := 0; j < len(words); j++ {\\n            if i != j && isPalindromic(words[i] + words[j]) {\\n                res = append(res, []int{i, j})\\n            }\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc palindromePairs(words []string) [][]int {\\n    var res [][]int\\n    \\n    var isPalindromic func(string) bool\\n    isPalindromic = func(str string) bool {\\n        if len(str) < 2 {return true}\\n        l, r := 0, len(str) - 1\\n        for l < r {\\n            if str[l] != str[r] {return false}\\n            l, r = l + 1, r - 1\\n        }\\n        return true\\n    }\\n    \\n    for i := 0; i < len(words); i++ {\\n        for j := 0; j < len(words); j++ {\\n            if i != j && isPalindromic(words[i] + words[j]) {\\n                res = append(res, []int{i, j})\\n            }\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1271196,
                "title": "c-solution-using-hash-map",
                "content": "```\\n    /*\\n     * Approach is similar to trie but using it a map\\n     *\\n     * We have 3 cases where\\n     * . If the string is \"\" and if there is a palindromic substring, then there will\\n     *   2 palindrome pairs\\n     *   Eg: s1 = \"\"  s2 = aba =>  \"\"aba or aba\"\" => 2 palindromic pairs\\n     *\\n     * . Case where there are 2 strings with equal length\\n     *   Eg: s1 = abcd s2 = dcba => abcddcba & dcbaabcd are palindrome pairs\\n     *\\n     * . Case with strings having non equal lengths\\n     *   Eg: s1 = lls   s2 = s\\n     *   In this case, we can s1 into 2 substrings at indices 1....s1.length()\\n     *   say left, right, check whether left is palindrome and reverse of right is equal\\n     *   to s2, then there will a pair\\n     *   Simillarly, if right is palindrome and reverse of left is equal to s2, then there\\n     *   is also a pair.\\n     *       \\n    */\\n    \\n    bool isPalindrome(string& s) {\\n        int left = 0;\\n        int right = s.length() - 1;\\n        \\n        while (left < right) {\\n            if (s[left] != s[right]) {\\n                return false;\\n            }\\n            \\n            left++;\\n            right--;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        // 2d vector to store teh indices of palindrome pairs\\n        vector<vector<int>> res;\\n        \\n        // map to store the words and their indices, using map because the contents\\n        // can be accessed in O(1) time\\n        unordered_map<string, int> mp;\\n        \\n        // Loop all the words and update the map\\n        for (int i = 0; i < words.size(); i++) {\\n            // Store the index and word int the map\\n            mp[words[i]] = i;\\n        }\\n        \\n        // Empty string case\\n        if (mp.count(\"\") == 1) {\\n            // We have an empty string in the input words\\n\\n            // get the idx of the empty word\\n            int idx = mp[\"\"];\\n            \\n            // Loop over all words in the input vector, check whether the stirng is\\n            // palindrome or not\\n            for (int i = 0; i < words.size(); i++) {\\n                // Check if the input word is not \"\" and check if it is a palindrome or not\\n                if (i != idx && isPalindrome(words[i])) {\\n                    // word at index i is a palindrome, add the indices to result\\n                    res.push_back({i, idx});\\n                    res.push_back({idx, i});\\n                }\\n            }\\n        }\\n        \\n        // Equal length strings\\n        // Traverse all the words and find whether reverse of the string is available in map\\n        // or not\\n        for (int i = 0; i < words.size(); i++) {\\n            // Get the reverse of the current word\\n            string s(words[i].rbegin(), words[i].rend());\\n            \\n            // Check if is available in map or not\\n            if (mp.count(s) == 1 && mp[s] != i) {\\n                // reverse word is available in map, we got a pair add it to result\\n                res.push_back({i, mp[s]});\\n            }\\n        }\\n        \\n        // Temp Variables\\n        string s = \"\";\\n        string left, right;\\n        string rev;\\n        \\n        // Non- Equal Strings\\n        for (int i = 0; i < words.size(); i++) {\\n            // Retrieve the current word\\n            s = words[i];\\n            \\n            // Generate the substrings at different intervals\\n            for (int j = 1; j < s.length(); j++) {\\n                // Generate the two substrings that are divide at index j\\n                left = s.substr(0, j); \\n                right = s.substr(j);\\n                \\n                // Need to check whether left is palindrome and reverse of right is\\n                // available in the input vector\\n                if (isPalindrome(left)) {\\n                    // left word is palindrome, check reverse of right substring is\\n                    // in input vector\\n                    string rev(right.rbegin(), right.rend());\\n                    // Check if this is available in input map or not\\n                    if (mp.count(rev) == 1) {\\n                        // Reverse word is available at input vector, got a pair\\n                        res.push_back({mp[rev], i});\\n                    }\\n                }\\n                \\n                // Check if right substring is palindrome or not\\n                if (isPalindrome(right)) {\\n                    // Right substring is palindrome, check reverse of left substring\\n                    // is available in input vector or not\\n                    string rev(left.rbegin(), left.rend());\\n                    \\n                    // Check if this is available in input map or not\\n                    if (mp.count(rev) == 1) {\\n                        // Reverse word is availble, we got a pir\\n                        res.push_back({i, mp[rev]});\\n                    }\\n                }\\n            }            \\n        }\\n\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    /*\\n     * Approach is similar to trie but using it a map\\n     *\\n     * We have 3 cases where\\n     * . If the string is \"\" and if there is a palindromic substring, then there will\\n     *   2 palindrome pairs\\n     *   Eg: s1 = \"\"  s2 = aba =>  \"\"aba or aba\"\" => 2 palindromic pairs\\n     *\\n     * . Case where there are 2 strings with equal length\\n     *   Eg: s1 = abcd s2 = dcba => abcddcba & dcbaabcd are palindrome pairs\\n     *\\n     * . Case with strings having non equal lengths\\n     *   Eg: s1 = lls   s2 = s\\n     *   In this case, we can s1 into 2 substrings at indices 1....s1.length()\\n     *   say left, right, check whether left is palindrome and reverse of right is equal\\n     *   to s2, then there will a pair\\n     *   Simillarly, if right is palindrome and reverse of left is equal to s2, then there\\n     *   is also a pair.\\n     *       \\n    */\\n    \\n    bool isPalindrome(string& s) {\\n        int left = 0;\\n        int right = s.length() - 1;\\n        \\n        while (left < right) {\\n            if (s[left] != s[right]) {\\n                return false;\\n            }\\n            \\n            left++;\\n            right--;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        // 2d vector to store teh indices of palindrome pairs\\n        vector<vector<int>> res;\\n        \\n        // map to store the words and their indices, using map because the contents\\n        // can be accessed in O(1) time\\n        unordered_map<string, int> mp;\\n        \\n        // Loop all the words and update the map\\n        for (int i = 0; i < words.size(); i++) {\\n            // Store the index and word int the map\\n            mp[words[i]] = i;\\n        }\\n        \\n        // Empty string case\\n        if (mp.count(\"\") == 1) {\\n            // We have an empty string in the input words\\n\\n            // get the idx of the empty word\\n            int idx = mp[\"\"];\\n            \\n            // Loop over all words in the input vector, check whether the stirng is\\n            // palindrome or not\\n            for (int i = 0; i < words.size(); i++) {\\n                // Check if the input word is not \"\" and check if it is a palindrome or not\\n                if (i != idx && isPalindrome(words[i])) {\\n                    // word at index i is a palindrome, add the indices to result\\n                    res.push_back({i, idx});\\n                    res.push_back({idx, i});\\n                }\\n            }\\n        }\\n        \\n        // Equal length strings\\n        // Traverse all the words and find whether reverse of the string is available in map\\n        // or not\\n        for (int i = 0; i < words.size(); i++) {\\n            // Get the reverse of the current word\\n            string s(words[i].rbegin(), words[i].rend());\\n            \\n            // Check if is available in map or not\\n            if (mp.count(s) == 1 && mp[s] != i) {\\n                // reverse word is available in map, we got a pair add it to result\\n                res.push_back({i, mp[s]});\\n            }\\n        }\\n        \\n        // Temp Variables\\n        string s = \"\";\\n        string left, right;\\n        string rev;\\n        \\n        // Non- Equal Strings\\n        for (int i = 0; i < words.size(); i++) {\\n            // Retrieve the current word\\n            s = words[i];\\n            \\n            // Generate the substrings at different intervals\\n            for (int j = 1; j < s.length(); j++) {\\n                // Generate the two substrings that are divide at index j\\n                left = s.substr(0, j); \\n                right = s.substr(j);\\n                \\n                // Need to check whether left is palindrome and reverse of right is\\n                // available in the input vector\\n                if (isPalindrome(left)) {\\n                    // left word is palindrome, check reverse of right substring is\\n                    // in input vector\\n                    string rev(right.rbegin(), right.rend());\\n                    // Check if this is available in input map or not\\n                    if (mp.count(rev) == 1) {\\n                        // Reverse word is available at input vector, got a pair\\n                        res.push_back({mp[rev], i});\\n                    }\\n                }\\n                \\n                // Check if right substring is palindrome or not\\n                if (isPalindrome(right)) {\\n                    // Right substring is palindrome, check reverse of left substring\\n                    // is available in input vector or not\\n                    string rev(left.rbegin(), left.rend());\\n                    \\n                    // Check if this is available in input map or not\\n                    if (mp.count(rev) == 1) {\\n                        // Reverse word is availble, we got a pir\\n                        res.push_back({i, mp[rev]});\\n                    }\\n                }\\n            }            \\n        }\\n\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 762908,
                "title": "standard-java-solution",
                "content": "### Theory\\nWe can easily come up with a brute force solution where we have a nested for loop, combine the strings, and check to see if its a palindrome. This will be N^2 * K Time algorithm, where N is the number of words, and K is the length of the longest word.\\n\\nWe can actually get it down to K^2 * N, which is a far better improvment.\\nThere are ideally 3 cases in which we can find a palindrome:\\n1) When processing a word, we can find a reverse version of the word elsewhere.\\n2) When we process a word from right to left, and we find a substring that is a palindrome, we can check to see if the other portions of the string fufill our palindrome criteria\\n3) When we process a word from left to right, and we find a substring that is a palindrome, we can check to see if the other portions of the string fufill our palindrome criteria\\n\\nCredits - This video is actually really helpful and integral to understanding the 3 cases above:\\nhttps://www.youtube.com/watch?v=9G0Tme4w04s\\n\\n### Solution Brute Force\\n```\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = 0; i < words.length; i++) {\\n            for (int j = 0; j < words.length; j++) {\\n                if (i == j) continue;\\n                String candidate = words[i].concat(words[j]);\\n                if (isPalindrome(candidate, 0, candidate.length() - 1)) {\\n                    res.add(Arrays.asList(i, j));\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }  \\n    \\n    private boolean isPalindrome(String candidate, int left, int right) {\\n        while (left < right) {\\n            if (candidate.charAt(left) != candidate.charAt(right)) return false;\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n```\\n\\n### Solution Optimal\\n```\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        Map<String, Integer> map = new HashMap<>();\\n        for (int i = 0; i < words.length; i++) {\\n            String rev = new StringBuilder(words[i]).reverse().toString();\\n            map.put(rev, i);\\n        }\\n        \\n        for (int i = 0; i < words.length; i++) {\\n            String curr = words[i];\\n            if (map.containsKey(curr) && map.get(curr) != i) \\n                res.add(Arrays.asList(i, map.get(curr)));\\n            \\n            //left piviot - searching for a prefix\\n            for (int j = curr.length() - 1; j >= 0; j--) {\\n                if (isPalindrome(curr, 0, j)) {\\n                    String sub = curr.substring(j + 1);\\n                    if (map.containsKey(sub))\\n                        res.add(Arrays.asList(map.get(sub), i));\\n                }   \\n            }\\n            \\n            // right pivot - searching for a suffix\\n            for (int j = 0; j < curr.length(); j++) {\\n                if (isPalindrome(curr, j, curr.length() - 1)) {\\n                    String sub = curr.substring(0, j);\\n                    if (map.containsKey(sub))\\n                        res.add(Arrays.asList(i, map.get(sub)));\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }  \\n    \\n    private boolean isPalindrome(String candidate, int left, int right) {\\n        while (left < right) {\\n            if (candidate.charAt(left) != candidate.charAt(right)) return false;\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = 0; i < words.length; i++) {\\n            for (int j = 0; j < words.length; j++) {\\n                if (i == j) continue;\\n                String candidate = words[i].concat(words[j]);\\n                if (isPalindrome(candidate, 0, candidate.length() - 1)) {\\n                    res.add(Arrays.asList(i, j));\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }  \\n    \\n    private boolean isPalindrome(String candidate, int left, int right) {\\n        while (left < right) {\\n            if (candidate.charAt(left) != candidate.charAt(right)) return false;\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n```\n```\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        Map<String, Integer> map = new HashMap<>();\\n        for (int i = 0; i < words.length; i++) {\\n            String rev = new StringBuilder(words[i]).reverse().toString();\\n            map.put(rev, i);\\n        }\\n        \\n        for (int i = 0; i < words.length; i++) {\\n            String curr = words[i];\\n            if (map.containsKey(curr) && map.get(curr) != i) \\n                res.add(Arrays.asList(i, map.get(curr)));\\n            \\n            //left piviot - searching for a prefix\\n            for (int j = curr.length() - 1; j >= 0; j--) {\\n                if (isPalindrome(curr, 0, j)) {\\n                    String sub = curr.substring(j + 1);\\n                    if (map.containsKey(sub))\\n                        res.add(Arrays.asList(map.get(sub), i));\\n                }   \\n            }\\n            \\n            // right pivot - searching for a suffix\\n            for (int j = 0; j < curr.length(); j++) {\\n                if (isPalindrome(curr, j, curr.length() - 1)) {\\n                    String sub = curr.substring(0, j);\\n                    if (map.containsKey(sub))\\n                        res.add(Arrays.asList(i, map.get(sub)));\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }  \\n    \\n    private boolean isPalindrome(String candidate, int left, int right) {\\n        while (left < right) {\\n            if (candidate.charAt(left) != candidate.charAt(right)) return false;\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 726716,
                "title": "c-trie",
                "content": "```\\n vector<vector<int>> res;\\n    \\n    struct TrieNode{\\n        int indexWord;\\n        bool isWord;\\n        TrieNode* children[26];\\n    };\\n    \\n    \\n    TrieNode* getNewNode(){\\n        TrieNode* node = new TrieNode();\\n        node->isWord = false;\\n        node->indexWord = -1;\\n        for(int i=0;i<26;i++)\\n            node->children[i] = NULL;\\n        return node;\\n    }\\n    \\n    void insert(TrieNode* root, string & word, int indexWord){\\n        TrieNode* temp = root;\\n        for(int i=0;i<word.length();i++){\\n            int index = word[i] - \\'a\\';\\n            if(temp->children[index] == NULL)\\n                temp->children[index] = getNewNode();\\n            temp = temp->children[index];\\n        }\\n        temp->isWord = true;\\n        temp->indexWord = indexWord;\\n    }\\n    \\n    bool isSubstringPalindrone(string str){\\n        string s1 = str;\\n        reverse(str.begin(), str.end());\\n        return s1 == str;\\n    }\\n    \\n    \\n    void dfs(TrieNode* root, vector<int> & v1, string & str){\\n        if(root == NULL)\\n            return;\\n        if(root->isWord == true && str!=\"\" && isSubstringPalindrone(str))\\n            v1.push_back(root->indexWord);\\n        for(int i=0;i<26;i++){\\n            if(root->children[i]!= NULL){\\n                str+=\\'a\\' + i;\\n                dfs(root->children[i], v1, str);\\n                str.pop_back();\\n            }\\n        }\\n    }\\n    \\n    void helper(TrieNode* root, string word, int  wordIndex){\\n        int index = 0;\\n        while(index < word.length()){\\n            root = root->children[word[index] - \\'a\\'];\\n            index++;\\n            if(root == NULL)\\n                break;\\n            if(root->isWord == true){\\n                if(root->indexWord != wordIndex && isSubstringPalindrone(word.substr(index))){\\n                    vector<int> v1;\\n                    v1.push_back(wordIndex); \\n                    v1.push_back(root->indexWord);\\n                    res.push_back(v1);\\n                }\\n            }\\n        }\\n        if(index == word.length() && root!= NULL){\\n            string  str = \"\";\\n            vector<int> v1;\\n            dfs(root, v1, str);\\n            for(int i: v1){\\n                if(i!= wordIndex){\\n                    vector<int> v2;\\n                    v2.push_back(wordIndex); \\n                    v2.push_back(i);\\n                    res.push_back(v2);\\n                }\\n            }\\n        }\\n        \\n        \\n    }\\n    \\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        TrieNode* root = getNewNode();\\n        int emptyIndex = -1;\\n        for(int i=0;i<words.size();i++){\\n            if(words[i] == \"\")\\n                emptyIndex = i;\\n            string word = words[i];\\n            reverse(word.begin(), word.end());\\n            insert(root, word, i);\\n        }\\n        \\n        for(int i=0;i<words.size();i++){\\n            string word = words[i];\\n            if(emptyIndex!= -1 && i!= emptyIndex  && isSubstringPalindrone(word)){\\n                vector<int> v1;\\n                v1.push_back(i);\\n                v1.push_back(emptyIndex);\\n                res.push_back(v1);\\n            }\\n            helper(root, word, i);\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n vector<vector<int>> res;\\n    \\n    struct TrieNode{\\n        int indexWord;\\n        bool isWord;\\n        TrieNode* children[26];\\n    };\\n    \\n    \\n    TrieNode* getNewNode(){\\n        TrieNode* node = new TrieNode();\\n        node->isWord = false;\\n        node->indexWord = -1;\\n        for(int i=0;i<26;i++)\\n            node->children[i] = NULL;\\n        return node;\\n    }\\n    \\n    void insert(TrieNode* root, string & word, int indexWord){\\n        TrieNode* temp = root;\\n        for(int i=0;i<word.length();i++){\\n            int index = word[i] - \\'a\\';\\n            if(temp->children[index] == NULL)\\n                temp->children[index] = getNewNode();\\n            temp = temp->children[index];\\n        }\\n        temp->isWord = true;\\n        temp->indexWord = indexWord;\\n    }\\n    \\n    bool isSubstringPalindrone(string str){\\n        string s1 = str;\\n        reverse(str.begin(), str.end());\\n        return s1 == str;\\n    }\\n    \\n    \\n    void dfs(TrieNode* root, vector<int> & v1, string & str){\\n        if(root == NULL)\\n            return;\\n        if(root->isWord == true && str!=\"\" && isSubstringPalindrone(str))\\n            v1.push_back(root->indexWord);\\n        for(int i=0;i<26;i++){\\n            if(root->children[i]!= NULL){\\n                str+=\\'a\\' + i;\\n                dfs(root->children[i], v1, str);\\n                str.pop_back();\\n            }\\n        }\\n    }\\n    \\n    void helper(TrieNode* root, string word, int  wordIndex){\\n        int index = 0;\\n        while(index < word.length()){\\n            root = root->children[word[index] - \\'a\\'];\\n            index++;\\n            if(root == NULL)\\n                break;\\n            if(root->isWord == true){\\n                if(root->indexWord != wordIndex && isSubstringPalindrone(word.substr(index))){\\n                    vector<int> v1;\\n                    v1.push_back(wordIndex); \\n                    v1.push_back(root->indexWord);\\n                    res.push_back(v1);\\n                }\\n            }\\n        }\\n        if(index == word.length() && root!= NULL){\\n            string  str = \"\";\\n            vector<int> v1;\\n            dfs(root, v1, str);\\n            for(int i: v1){\\n                if(i!= wordIndex){\\n                    vector<int> v2;\\n                    v2.push_back(wordIndex); \\n                    v2.push_back(i);\\n                    res.push_back(v2);\\n                }\\n            }\\n        }\\n        \\n        \\n    }\\n    \\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        TrieNode* root = getNewNode();\\n        int emptyIndex = -1;\\n        for(int i=0;i<words.size();i++){\\n            if(words[i] == \"\")\\n                emptyIndex = i;\\n            string word = words[i];\\n            reverse(word.begin(), word.end());\\n            insert(root, word, i);\\n        }\\n        \\n        for(int i=0;i<words.size();i++){\\n            string word = words[i];\\n            if(emptyIndex!= -1 && i!= emptyIndex  && isSubstringPalindrone(word)){\\n                vector<int> v1;\\n                v1.push_back(i);\\n                v1.push_back(emptyIndex);\\n                res.push_back(v1);\\n            }\\n            helper(root, word, i);\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 642557,
                "title": "python-hash-table-beats-98-in-time-with-comments",
                "content": "```\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n\\t\\t# check if a string is palindrome\\n        def isPalin(string):\\n            for i in range(len(string) // 2):\\n                if(string[i] != string[-(i+1)]):\\n                    return False\\n            return True\\n\\n        ht = {}\\n\\t\\t# put the reversed words into the hashtable\\n        for idx, word in enumerate(words):\\n            ht[word[::-1]] = idx\\n        res = []\\n\\t\\t\\t\\t\\n\\t\\t# traverse through the words again\\n        for idx, word in enumerate(words):\\n            l = len(word)\\n            for i in range(l):\\n\\t\\t\\t\\t# divide into left and right part\\n                left = word[:i]\\n                right = word[i:]\\n                if left in ht and isPalin(right) and ht[left] != idx:    \\n                    res.append([idx, ht[left]])\\n\\t\\t\\t\\t\\t# in case of [\"a\", \"\"]\\n                    if left == \"\":\\n                        res.append([ht[left], idx])\\n                if right in ht and isPalin(left) and ht[right] != idx:\\n                    res.append([ht[right], idx])  \\n\\t\\t\\t\\t\\t# in case of [\"\", \"a\"]  \\n                    if right == \"\":\\n                        res.append([idx, ht[right]])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n\\t\\t# check if a string is palindrome\\n        def isPalin(string):\\n            for i in range(len(string) // 2):\\n                if(string[i] != string[-(i+1)]):\\n                    return False\\n            return True\\n\\n        ht = {}\\n\\t\\t# put the reversed words into the hashtable\\n        for idx, word in enumerate(words):\\n            ht[word[::-1]] = idx\\n        res = []\\n\\t\\t\\t\\t\\n\\t\\t# traverse through the words again\\n        for idx, word in enumerate(words):\\n            l = len(word)\\n            for i in range(l):\\n\\t\\t\\t\\t# divide into left and right part\\n                left = word[:i]\\n                right = word[i:]\\n                if left in ht and isPalin(right) and ht[left] != idx:    \\n                    res.append([idx, ht[left]])\\n\\t\\t\\t\\t\\t# in case of [\"a\", \"\"]\\n                    if left == \"\":\\n                        res.append([ht[left], idx])\\n                if right in ht and isPalin(left) and ht[right] != idx:\\n                    res.append([ht[right], idx])  \\n\\t\\t\\t\\t\\t# in case of [\"\", \"a\"]  \\n                    if right == \"\":\\n                        res.append([idx, ht[right]])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 336856,
                "title": "o-n-k-2-python-solution-easy-to-understand",
                "content": "```python\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        def judge(s):\\n            i, j = 0, len(s) - 1\\n            while i < j:\\n                if s[i] == s[j]: \\n                    i += 1\\n                    j -= 1\\n                else: return False\\n            return True\\n        d = {s : i for i, s in enumerate(words)}\\n        res = set()\\n        for i, s in enumerate(words):\\n            for j in range(len(s) + 1):\\n                s1, s2 = s[:j], s[j:]\\n                if s1[::-1] in d and judge(s2) and d[s1[::-1]] != i:\\n                    res.add((i, d[s1[::-1]]))\\n                if s2[::-1] in d and judge(s1) and d[s2[::-1]] != i:\\n                    res.add((d[s2[::-1]], i))\\n        return list(res)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        def judge(s):\\n            i, j = 0, len(s) - 1\\n            while i < j:\\n                if s[i] == s[j]: \\n                    i += 1\\n                    j -= 1\\n                else: return False\\n            return True\\n        d = {s : i for i, s in enumerate(words)}\\n        res = set()\\n        for i, s in enumerate(words):\\n            for j in range(len(s) + 1):\\n                s1, s2 = s[:j], s[j:]\\n                if s1[::-1] in d and judge(s2) and d[s1[::-1]] != i:\\n                    res.add((i, d[s1[::-1]]))\\n                if s2[::-1] in d and judge(s1) and d[s2[::-1]] != i:\\n                    res.add((d[s2[::-1]], i))\\n        return list(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 156929,
                "title": "z-algorithm-c-base-on-214-o-nk-roughly-really-straightforward-and-easy",
                "content": "There are KMPs, so this is based on Z-algoritm, which is easier to code. If you don\\'t know kmp or Z, learn and write a template for them. Then the thing is easy as this is exatcly problem 214, you extend your string to make a palindorm and search in map. Some tricks will be used like you only extend to twice length -1 and you both extend before and back( do 214 for 2 times). And you extend twice length before for distint result. Those tricks are trivial, once you know Z and 214, this problem is easy. The running time is good as kmp O(nk) roughly, k as length of cur processing string.\\n```\\nint match_length(string & s, int pos1, int pos2){\\n    \\n    int length = 0;\\n    \\n    //\\u5F53\\u524D\\u5B57\\u7B26match\\uFF0C\\u5EF6\\u957F\\u957F\\u5EA6\\n    while (length + pos2 < s.size() && s[length+pos1] == s[length+pos2] ) {\\n        length++;\\n    }\\n    \\n    return length;\\n}\\n\\nvector<int> z_algorithm(string & s){\\n    \\n    vector<int> z_array(s.size(),0);\\n    //\\u5DE6\\u53F3\\u7A97\\u53E3\\u521D\\u59CB\\u5316 \\u8BBE\\u4E3A-1 \\u5DE6\\u53F3inclusive \\u8868\\u793A\\u5F53\\u524D\\u6700\\u8FDC\\u80FDmatch\\u5230\\u7684\\u5730\\u65B9\\uFF08r\\uFF09 \\u548C\\u5F00\\u59CBmatch\\u65F6\\u7684\\u4F4D\\u7F6E lr\\u59CB\\u7EC8\\u662F \\u4ECEl\\u5F00\\u59CB\\u6700\\u957F\\u7684prefix\\n    int l = -1;\\n    int r = -1;\\n    \\n    for (int i = 1; i< s.size(); i++) {\\n        //\\u60C5\\u51B51\\uFF0C\\u5F53\\u524D\\u4F4D\\u7F6E\\u6BD4\\u4E4B\\u524D\\u6700\\u8FDCmatch\\u4F4D\\u7F6E\\u8FDC\\uFF0C\\u4ECE\\u5F53\\u524D\\u4F4D\\u7F6E\\u548Cstring\\u5F00\\u5934\\u5F00\\u59CBmatch\\uFF0Cupdata l\\uFF0Cr\\n        if (i > r) {\\n            int length = match_length(s,0,i);\\n            l = i;\\n            r = i + length - 1;\\n            z_array[i] = length;\\n        } else {\\n            //\\u60C5\\u51B52\\uFF0C\\u5F53\\u524D\\u4F4D\\u7F6E\\u5904\\u4E8E\\u4E4B\\u524D\\u6700\\u8FDCmatch\\u91CC\\u9762\\uFF0C\\u90A3\\u4E48\\u6211\\u4EEC\\u53EF\\u4EE5\\u76F4\\u63A5\\u901A\\u8FC7\\u67E5\\u8868\\u5F97\\u77E5\\u53EF\\u80FD\\u7684match\\uFF0C\\u548C\\u8868\\u4E2D\\u786E\\u5B9A\\u7684match\\n            int lastMatch = z_array[i-l];\\n            \\n            //2-1  \\u53EF\\u80FD\\u7684match\\u6BD4\\u5DF2\\u6709\\u5927\\u6216\\u8005\\u7B49\\u4E8E\\uFF0C\\u610F\\u5473\\u7740\\u73B0\\u5728\\u7684r\\u6709\\u62D3\\u5C55\\u6027\\uFF0C \\u5E94\\u4E3Al\\u5230r\\u662Fprefix \\u4ECEk\\u5230r\\u4E00\\u5B9Amatch\\uFF0C1\\uFF0C\\u6709\\u673A\\u4F1A\\u62D3\\u5C55\\n            if (i+lastMatch-1 >= r) {\\n                int newMatch = match_length(s, r-i+1, r+1);//\\u6CE8\\u610F \\u5728\\u8FD9\\u91CC\\u662F\\u4ECEr\\u540E\\u4E00\\u4F4D\\u5F00\\u59CB\\uFF0C\\u800C\\u4E0D\\u662F\\u4ECE \\u5F53\\u524D\\u4F4D+z\\u3010i-l\\u3011\\u5F00\\u59CB\\uFF0C\\u5E94\\u4E3Az\\u3010i-l\\u3011\\u7684\\u503C\\u4E0D\\u4E00\\u5B9A\\u53EF\\u4EE5\\u653E\\u5230z\\u3010i\\u3011\\u4E0A\\uFF0C\\u6211\\u4EEC\\u5E94\\u8BE5\\u624D\\u53F3\\u4F4D\\u52A0\\u4E00\\u6765\\u68C0\\u67E5\\n                l = i;\\n                r = r + newMatch;\\n                z_array[i] = r-l+1;\\n            } else {\\n                //2-2 \\u6CA1\\u6709\\u62D3\\u5C55\\u6027\\uFF0Clr prefix \\u901A\\u8FC7\\u67E5\\u8868\\u544A\\u8BC9\\u6211\\u4EEClr\\u4E2D\\u540E\\u9762\\u5DF2\\u7ECF\\u6709\\u963B\\u65AD\\uFF0C\\u6700\\u591A\\u548C\\u4E4B\\u524D\\u4E00\\u6837\\uFF0C\\u4E0D\\u80FD\\u62D3\\u5C55\\n                z_array[i] = lastMatch;\\n            }\\n        }\\n    }\\n    \\n    return z_array;\\n}\\n\\nvector<vector<int>> palindromePairs(vector<string>& words) {\\n    unordered_map<string, int> data;\\n    vector<int> z;\\n    vector<vector<int>> result;\\n    \\n    for (int i = 0; i < words.size(); i++)\\n        data[words[i]] = i;\\n    \\n    for (int k = 0; k < words.size(); k++) {\\n        string s = words[k];\\n        string ss = s;\\n        reverse(ss.begin(), ss.end());\\n        \\n        if(data.count(ss) && ss != s)\\n            result.push_back({k,data[ss]});\\n        \\n        ss = s + ss;\\n        \\n        z = z_algorithm(ss);\\n        for(int i = (int)ss.size()-1, j = 1; i >= (int)s.size(); i--, j++) {\\n            if(z[i]==j) {\\n                string temp = ss.substr(s.size(),s.size()-z[i]);\\n                if(data.count(temp))\\n                    result.push_back({data[temp],k});\\n            }\\n        }\\n        \\n        s = words[k];\\n        reverse(s.begin(), s.end());\\n        ss = s;\\n        reverse(ss.begin(), ss.end());\\n        ss = s + ss;\\n        \\n        z = z_algorithm(ss);\\n        for(int i = (int)ss.size()-1, j = 1; i >= (int)s.size(); i--, j++) {\\n            if(z[i]==j) {\\n                string temp = ss.substr(s.size(),s.size()-z[i]);\\n                reverse(temp.begin(), temp.end());\\n                if(data.count(temp))\\n                    result.push_back({k,data[temp]});\\n            }\\n        }\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint match_length(string & s, int pos1, int pos2){\\n    \\n    int length = 0;\\n    \\n    //\\u5F53\\u524D\\u5B57\\u7B26match\\uFF0C\\u5EF6\\u957F\\u957F\\u5EA6\\n    while (length + pos2 < s.size() && s[length+pos1] == s[length+pos2] ) {\\n        length++;\\n    }\\n    \\n    return length;\\n}\\n\\nvector<int> z_algorithm(string & s){\\n    \\n    vector<int> z_array(s.size(),0);\\n    //\\u5DE6\\u53F3\\u7A97\\u53E3\\u521D\\u59CB\\u5316 \\u8BBE\\u4E3A-1 \\u5DE6\\u53F3inclusive \\u8868\\u793A\\u5F53\\u524D\\u6700\\u8FDC\\u80FDmatch\\u5230\\u7684\\u5730\\u65B9\\uFF08r\\uFF09 \\u548C\\u5F00\\u59CBmatch\\u65F6\\u7684\\u4F4D\\u7F6E lr\\u59CB\\u7EC8\\u662F \\u4ECEl\\u5F00\\u59CB\\u6700\\u957F\\u7684prefix\\n    int l = -1;\\n    int r = -1;\\n    \\n    for (int i = 1; i< s.size(); i++) {\\n        //\\u60C5\\u51B51\\uFF0C\\u5F53\\u524D\\u4F4D\\u7F6E\\u6BD4\\u4E4B\\u524D\\u6700\\u8FDCmatch\\u4F4D\\u7F6E\\u8FDC\\uFF0C\\u4ECE\\u5F53\\u524D\\u4F4D\\u7F6E\\u548Cstring\\u5F00\\u5934\\u5F00\\u59CBmatch\\uFF0Cupdata l\\uFF0Cr\\n        if (i > r) {\\n            int length = match_length(s,0,i);\\n            l = i;\\n            r = i + length - 1;\\n            z_array[i] = length;\\n        } else {\\n            //\\u60C5\\u51B52\\uFF0C\\u5F53\\u524D\\u4F4D\\u7F6E\\u5904\\u4E8E\\u4E4B\\u524D\\u6700\\u8FDCmatch\\u91CC\\u9762\\uFF0C\\u90A3\\u4E48\\u6211\\u4EEC\\u53EF\\u4EE5\\u76F4\\u63A5\\u901A\\u8FC7\\u67E5\\u8868\\u5F97\\u77E5\\u53EF\\u80FD\\u7684match\\uFF0C\\u548C\\u8868\\u4E2D\\u786E\\u5B9A\\u7684match\\n            int lastMatch = z_array[i-l];\\n            \\n            //2-1  \\u53EF\\u80FD\\u7684match\\u6BD4\\u5DF2\\u6709\\u5927\\u6216\\u8005\\u7B49\\u4E8E\\uFF0C\\u610F\\u5473\\u7740\\u73B0\\u5728\\u7684r\\u6709\\u62D3\\u5C55\\u6027\\uFF0C \\u5E94\\u4E3Al\\u5230r\\u662Fprefix \\u4ECEk\\u5230r\\u4E00\\u5B9Amatch\\uFF0C1\\uFF0C\\u6709\\u673A\\u4F1A\\u62D3\\u5C55\\n            if (i+lastMatch-1 >= r) {\\n                int newMatch = match_length(s, r-i+1, r+1);//\\u6CE8\\u610F \\u5728\\u8FD9\\u91CC\\u662F\\u4ECEr\\u540E\\u4E00\\u4F4D\\u5F00\\u59CB\\uFF0C\\u800C\\u4E0D\\u662F\\u4ECE \\u5F53\\u524D\\u4F4D+z\\u3010i-l\\u3011\\u5F00\\u59CB\\uFF0C\\u5E94\\u4E3Az\\u3010i-l\\u3011\\u7684\\u503C\\u4E0D\\u4E00\\u5B9A\\u53EF\\u4EE5\\u653E\\u5230z\\u3010i\\u3011\\u4E0A\\uFF0C\\u6211\\u4EEC\\u5E94\\u8BE5\\u624D\\u53F3\\u4F4D\\u52A0\\u4E00\\u6765\\u68C0\\u67E5\\n                l = i;\\n                r = r + newMatch;\\n                z_array[i] = r-l+1;\\n            } else {\\n                //2-2 \\u6CA1\\u6709\\u62D3\\u5C55\\u6027\\uFF0Clr prefix \\u901A\\u8FC7\\u67E5\\u8868\\u544A\\u8BC9\\u6211\\u4EEClr\\u4E2D\\u540E\\u9762\\u5DF2\\u7ECF\\u6709\\u963B\\u65AD\\uFF0C\\u6700\\u591A\\u548C\\u4E4B\\u524D\\u4E00\\u6837\\uFF0C\\u4E0D\\u80FD\\u62D3\\u5C55\\n                z_array[i] = lastMatch;\\n            }\\n        }\\n    }\\n    \\n    return z_array;\\n}\\n\\nvector<vector<int>> palindromePairs(vector<string>& words) {\\n    unordered_map<string, int> data;\\n    vector<int> z;\\n    vector<vector<int>> result;\\n    \\n    for (int i = 0; i < words.size(); i++)\\n        data[words[i]] = i;\\n    \\n    for (int k = 0; k < words.size(); k++) {\\n        string s = words[k];\\n        string ss = s;\\n        reverse(ss.begin(), ss.end());\\n        \\n        if(data.count(ss) && ss != s)\\n            result.push_back({k,data[ss]});\\n        \\n        ss = s + ss;\\n        \\n        z = z_algorithm(ss);\\n        for(int i = (int)ss.size()-1, j = 1; i >= (int)s.size(); i--, j++) {\\n            if(z[i]==j) {\\n                string temp = ss.substr(s.size(),s.size()-z[i]);\\n                if(data.count(temp))\\n                    result.push_back({data[temp],k});\\n            }\\n        }\\n        \\n        s = words[k];\\n        reverse(s.begin(), s.end());\\n        ss = s;\\n        reverse(ss.begin(), ss.end());\\n        ss = s + ss;\\n        \\n        z = z_algorithm(ss);\\n        for(int i = (int)ss.size()-1, j = 1; i >= (int)s.size(); i--, j++) {\\n            if(z[i]==j) {\\n                string temp = ss.substr(s.size(),s.size()-z[i]);\\n                reverse(temp.begin(), temp.end());\\n                if(data.count(temp))\\n                    result.push_back({k,data[temp]});\\n            }\\n        }\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 150602,
                "title": "javascript-solution-290ms-using-trie",
                "content": "# Performance\\nTime: O(n) where n = words.length * words[x].length\\nSpace: O(n)\\nRuntime: ~290ms\\n\\n# High level strategy\\n1. Create a \"reverse\" trie where characters mapped from the end of each word\\n2. Loop through each word\\n3. Loop through each character in each word\\n4. Navigate through trie along with each character\\n5. Check for potential palindromes:\\n  a. Words found during navigation through trie are potential palindromes\\n  b. Remaining words in trie after reaching end of characters are potential\\n      palindromes\\n\\n# Code\\n\\n```javascript\\nconst palindromePairs = function(words) {\\n  const trie = createTrieStartingFromLastCharacterInEachWord(words);\\n  const results = []; // pairs of indexes for each palindrome\\n  words.forEach((word, wordIndex) => {\\n    let node = trie;\\n    addPotentialPalindrome(node, word, wordIndex, results); // checks for empty word \\'\\'\\n    for (let i=0; i<word.length; i++) {\\n      if (!node.next[word[i]]) return;\\n      node = node.next[word[i]];\\n      addPotentialPalindrome(node, word, wordIndex, results);\\n    }\\n    let remainingWords = findRemainingWords(node).filter(n => n !== node);\\n    remainingWords.forEach(node => {\\n      addPotentialPalindrome(node, word, wordIndex, results);\\n    });\\n  });\\n  return results;\\n};\\n\\nclass Trie {\\n  constructor() {\\n    this.next = {};\\n    this.word = null;\\n    this.wordIndex = null;\\n  }\\n}\\n\\nconst createTrieStartingFromLastCharacterInEachWord = words => {\\n  const trie = new Trie();\\n  words.forEach((word, index) => {\\n    let node = trie;\\n    for (let i=word.length-1; i>=0; i--) {\\n      // Create next pointer if not exists & move node to next pointer\\n      node = node.next[word[i]] = node.next[word[i]] || new Trie();\\n    }\\n    node.word = word;\\n    node.wordIndex = index;\\n  });\\n  return trie;\\n};\\n\\nconst addPotentialPalindrome = (node, word, wordIndex, results) => {\\n  if (nodeMakesAPalindromeWithWord(node, word, wordIndex))\\n    results.push([wordIndex, node.wordIndex]);\\n};\\n\\nconst nodeMakesAPalindromeWithWord = (node, word, wordIndex) => {\\n  if (node && (node.word || node.word === \\'\\') && wordIndex !== node.wordIndex) {\\n    if (word.length >= node.word.length) {\\n      return wordIsPalindrome(word.slice(node.word.length, word.length));\\n    } else {\\n      return wordIsPalindrome(node.word.slice(0, node.word.length-word.length))\\n    }\\n  }\\n  return false;\\n}\\n\\nconst wordIsPalindrome = word => {\\n  const half = Math.floor(word.length/2);\\n  for (let i=0; i<half; i++) {\\n    if (word[i] !== word[word.length-i-1]) return false;\\n  }\\n  return true;\\n};\\n\\nconst findRemainingWords = (node, results=[]) => {\\n  if (!node) return results;\\n  if (node.word) results.push(node);\\n  for (let k in node.next) {\\n    findRemainingWords(node.next[k], results);\\n  }\\n  return results;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nconst palindromePairs = function(words) {\\n  const trie = createTrieStartingFromLastCharacterInEachWord(words);\\n  const results = []; // pairs of indexes for each palindrome\\n  words.forEach((word, wordIndex) => {\\n    let node = trie;\\n    addPotentialPalindrome(node, word, wordIndex, results); // checks for empty word \\'\\'\\n    for (let i=0; i<word.length; i++) {\\n      if (!node.next[word[i]]) return;\\n      node = node.next[word[i]];\\n      addPotentialPalindrome(node, word, wordIndex, results);\\n    }\\n    let remainingWords = findRemainingWords(node).filter(n => n !== node);\\n    remainingWords.forEach(node => {\\n      addPotentialPalindrome(node, word, wordIndex, results);\\n    });\\n  });\\n  return results;\\n};\\n\\nclass Trie {\\n  constructor() {\\n    this.next = {};\\n    this.word = null;\\n    this.wordIndex = null;\\n  }\\n}\\n\\nconst createTrieStartingFromLastCharacterInEachWord = words => {\\n  const trie = new Trie();\\n  words.forEach((word, index) => {\\n    let node = trie;\\n    for (let i=word.length-1; i>=0; i--) {\\n      // Create next pointer if not exists & move node to next pointer\\n      node = node.next[word[i]] = node.next[word[i]] || new Trie();\\n    }\\n    node.word = word;\\n    node.wordIndex = index;\\n  });\\n  return trie;\\n};\\n\\nconst addPotentialPalindrome = (node, word, wordIndex, results) => {\\n  if (nodeMakesAPalindromeWithWord(node, word, wordIndex))\\n    results.push([wordIndex, node.wordIndex]);\\n};\\n\\nconst nodeMakesAPalindromeWithWord = (node, word, wordIndex) => {\\n  if (node && (node.word || node.word === \\'\\') && wordIndex !== node.wordIndex) {\\n    if (word.length >= node.word.length) {\\n      return wordIsPalindrome(word.slice(node.word.length, word.length));\\n    } else {\\n      return wordIsPalindrome(node.word.slice(0, node.word.length-word.length))\\n    }\\n  }\\n  return false;\\n}\\n\\nconst wordIsPalindrome = word => {\\n  const half = Math.floor(word.length/2);\\n  for (let i=0; i<half; i++) {\\n    if (word[i] !== word[word.length-i-1]) return false;\\n  }\\n  return true;\\n};\\n\\nconst findRemainingWords = (node, results=[]) => {\\n  if (!node) return results;\\n  if (node.word) results.push(node);\\n  for (let k in node.next) {\\n    findRemainingWords(node.next[k], results);\\n  }\\n  return results;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79205,
                "title": "short-c-trie",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        vector<vector<int>>res;\\n        buildTrie(words);\\n        for(int i = 0; i < words.size(); i++){\\n            string s = words[i];\\n            for(auto x: Trie[s]) if(isPalindrome(x.first) && i != x.second) res.push_back({i, x.second});\\n            for(int j = 0; j <= s.size(); j++)\\n                if(m.count(s.substr(0, j)) && isPalindrome(s.substr(j)) && i != m[s.substr(0, j)]) \\n                    res.push_back({i, m[s.substr(0, j)]});\\n        }    \\n        return res;\\n    }\\n    \\nprivate:\\n    unordered_map<string, vector<pair<string, int> > >Trie;\\n    unordered_map<string, int>m;\\n    void buildTrie(vector<string>& words){\\n        for(int i = 0; i < words.size(); i++){\\n            string s = words[i];\\n            reverse(s.begin(), s.end());\\n            m[s] = i;\\n            for(int j = 0; j < s.size(); j++) Trie[s.substr(0, j)].push_back({s.substr(j), i});\\n        }\\n    }\\n    \\n    bool isPalindrome(string s){\\n        int i = 0, j = s.size() - 1;\\n        while(i < j) if(s[i++] != s[j--]) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        vector<vector<int>>res;\\n        buildTrie(words);\\n        for(int i = 0; i < words.size(); i++){\\n            string s = words[i];\\n            for(auto x: Trie[s]) if(isPalindrome(x.first) && i != x.second) res.push_back({i, x.second});\\n            for(int j = 0; j <= s.size(); j++)\\n                if(m.count(s.substr(0, j)) && isPalindrome(s.substr(j)) && i != m[s.substr(0, j)]) \\n                    res.push_back({i, m[s.substr(0, j)]});\\n        }    \\n        return res;\\n    }\\n    \\nprivate:\\n    unordered_map<string, vector<pair<string, int> > >Trie;\\n    unordered_map<string, int>m;\\n    void buildTrie(vector<string>& words){\\n        for(int i = 0; i < words.size(); i++){\\n            string s = words[i];\\n            reverse(s.begin(), s.end());\\n            m[s] = i;\\n            for(int j = 0; j < s.size(); j++) Trie[s.substr(0, j)].push_back({s.substr(j), i});\\n        }\\n    }\\n    \\n    bool isPalindrome(string s){\\n        int i = 0, j = s.size() - 1;\\n        while(i < j) if(s[i++] != s[j--]) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79225,
                "title": "accepted-native-brute-force-solution",
                "content": "the idea is just to loop to check <i,j> string ,whether w[i]+w[j] can be palindrome,\\nthe difference is we skip the string concatenation ,  directly check the palindrome based on i and j string, seems very quick in ac test\\n```\\nbool palindrome(string &s,string &t){\\n        int m = s.size(),n = t.size();\\n        int l = 0,r = n-1;\\n        while(l < m && r >= 0){\\n            if(s[l] != t[r])return false;\\n            l++,r--;\\n        }\\n        if(l < m){\\n            r = m-1;\\n            while(l < r){\\n                if(s[l] != s[r])return false;\\n                l++,r--;\\n            }\\n        }else {\\n            if(r >= 0){\\n                l = 0;\\n                while(l < r){\\n                    if(t[l] != t[r])return false;\\n                    l++,r--;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    //hash table\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n                        vector<vector<int>>res;\\n                        for(int i = 0;i < words.size();i++){\\n                            for(int j=0;j < words.size();j++){\\n                                if(i==j)continue;\\n                                //two pointer\\n                                if(palindrome(words[i],words[j])){\\n                                    res.push_back({i,j});\\n                                }\\n                            }\\n                        }\\n                        return res;\\n    }\\n````",
                "solutionTags": [],
                "code": "```\\nbool palindrome(string &s,string &t){\\n        int m = s.size(),n = t.size();\\n        int l = 0,r = n-1;\\n        while(l < m && r >= 0){\\n            if(s[l] != t[r])return false;\\n            l++,r--;\\n        }\\n        if(l < m){\\n            r = m-1;\\n            while(l < r){\\n                if(s[l] != s[r])return false;\\n                l++,r--;\\n            }\\n        }else {\\n            if(r >= 0){\\n                l = 0;\\n                while(l < r){\\n                    if(t[l] != t[r])return false;\\n                    l++,r--;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    //hash table\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n                        vector<vector<int>>res;\\n                        for(int i = 0;i < words.size();i++){\\n                            for(int j=0;j < words.size();j++){\\n                                if(i==j)continue;\\n                                //two pointer\\n                                if(palindrome(words[i],words[j])){\\n                                    res.push_back({i,j});\\n                                }\\n                            }\\n                        }\\n                        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3866882,
                "title": "best-and-easy-to-understand-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        from collections import defaultdict\\n        dict_ = defaultdict(int)\\n        for h in range(len(words)):\\n            dict_[words[h]] = h\\n        result = []\\n        for i in range(len(words)):\\n            word = words[i]\\n            if \"\" in dict_ and dict_[\"\"] != i and word == word[::-1]:\\n                result.append([i,dict_[\"\"]])\\n            for j in range(len(word)):\\n                prefix = word[:j+1]\\n                suffix = word[j+1:]\\n                if prefix[::-1] in dict_ and dict_[prefix[::-1]] != i and suffix == suffix[::-1]:\\n                    result.append([i,dict_[prefix[::-1]]])\\n                if suffix[::-1] in dict_ and dict_[suffix[::-1]] != i and prefix == prefix[::-1]:\\n                    result.append([dict_[suffix[::-1]],i])\\n        return(result)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        from collections import defaultdict\\n        dict_ = defaultdict(int)\\n        for h in range(len(words)):\\n            dict_[words[h]] = h\\n        result = []\\n        for i in range(len(words)):\\n            word = words[i]\\n            if \"\" in dict_ and dict_[\"\"] != i and word == word[::-1]:\\n                result.append([i,dict_[\"\"]])\\n            for j in range(len(word)):\\n                prefix = word[:j+1]\\n                suffix = word[j+1:]\\n                if prefix[::-1] in dict_ and dict_[prefix[::-1]] != i and suffix == suffix[::-1]:\\n                    result.append([i,dict_[prefix[::-1]]])\\n                if suffix[::-1] in dict_ and dict_[suffix[::-1]] != i and prefix == prefix[::-1]:\\n                    result.append([dict_[suffix[::-1]],i])\\n        return(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569487,
                "title": "easy-python-solution-using-mapping",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        dct=defaultdict(lambda :-1)\\n        n=len(words)\\n        flg=-1\\n        for i in range(n):\\n            dct[words[i]]=i\\n            if words[i]==\"\":\\n                flg=i\\n        lst=[]\\n        for i in range(n):\\n            for j in range(len(words[i])):\\n                if dct[words[i][j:][::-1]]!=-1 and i!=dct[words[i][j:][::-1]] and words[i][:j]==words[i][:j][::-1]:\\n                    if [dct[words[i][j:][::-1]],i] not in lst:\\n                        lst.append([dct[words[i][j:][::-1]],i])\\n                if dct[words[i][:j][::-1]]!=-1 and i!=dct[words[i][:j][::-1]] and words[i][j:]==words[i][j:][::-1]:\\n                    \\n                    lst.append([i,dct[words[i][:j][::-1]]])\\n        if \"\" in words:\\n            for i in range(n):\\n                if \"\"!=words[i] and words[i][::-1]==words[i]:\\n                    if [i,flg] not in lst:\\n                        lst.append([i,flg])\\n                    if [flg,i] not in lst:\\n                        lst.append([flg,i])\\n        return lst\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        dct=defaultdict(lambda :-1)\\n        n=len(words)\\n        flg=-1\\n        for i in range(n):\\n            dct[words[i]]=i\\n            if words[i]==\"\":\\n                flg=i\\n        lst=[]\\n        for i in range(n):\\n            for j in range(len(words[i])):\\n                if dct[words[i][j:][::-1]]!=-1 and i!=dct[words[i][j:][::-1]] and words[i][:j]==words[i][:j][::-1]:\\n                    if [dct[words[i][j:][::-1]],i] not in lst:\\n                        lst.append([dct[words[i][j:][::-1]],i])\\n                if dct[words[i][:j][::-1]]!=-1 and i!=dct[words[i][:j][::-1]] and words[i][j:]==words[i][j:][::-1]:\\n                    \\n                    lst.append([i,dct[words[i][:j][::-1]]])\\n        if \"\" in words:\\n            for i in range(n):\\n                if \"\"!=words[i] and words[i][::-1]==words[i]:\\n                    if [i,flg] not in lst:\\n                        lst.append([i,flg])\\n                    if [flg,i] not in lst:\\n                        lst.append([flg,i])\\n        return lst\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857520,
                "title": "easy-python-solution",
                "content": "class Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        backward, res = {}, []\\n        for i, word in enumerate(words):\\n            backward[word[::-1]] = i\\n\\n        for i, word in enumerate(words):\\n            \\n            if word in backward and backward[word] != i:\\n                res.append([i, backward[word]])\\n                \\n            if word != \"\" and \"\" in backward and word == word[::-1]:\\n                res.append([i, backward[\"\"]])\\n                res.append([backward[\"\"], i])\\n                \\n            for j in range(len(word)):\\n                if word[j:] in backward and word[:j] == word[j-1::-1]:\\n                    res.append([backward[word[j:]], i])\\n                if word[:j] in backward and word[j:] == word[:j-1:-1]:\\n                    res.append([i, backward[word[:j]]])\\n                    \\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        backward, res = {}",
                "codeTag": "Java"
            },
            {
                "id": 2846852,
                "title": "python3-on-site-coding-round-implementation",
                "content": "I got this question in an on-site coding round (Will not disclose name because of NDA). I hadn\\'t seen this problem so this is the best I could do in 45 mins.  I have seen better solutions using Trie but Trie wasn\\'t the first thing that came to my mind during interview.\\n\\nBeats 90% -\\n![Screen Shot 2022-11-25 at 12.25.00 AM.png](https://assets.leetcode.com/users/images/e3648af1-f94f-4ede-ae21-1a03f76dd59e_1669357535.9209704.png)\\n\\n*Here is my solution using Hashmap -* \\n# Code\\n```\\nclass Solution:\\n    def palindromePairs(self, words):\\n        @cache\\n        def pal(string):\\n            l, r = 0, len(string)-1\\n            while l < r:\\n                if string[l] != string[r]:\\n                    return False\\n                l+=1\\n                r-=1\\n            return True\\n                \\n        output = set()\\n        words_idx = {w:idx for idx,w in enumerate(words)}\\n\\n        # Index of empty string\\n        idx_empty = -1\\n        if \"\" in words_idx:\\n            idx_empty = words_idx[\"\"]\\n\\n        for idx, word in enumerate(words):\\n            # To handle cases with empty string\\n            if pal(word) and word != \"\" and idx_empty != -1:\\n                    output.add((idx_empty, idx))\\n                    output.add((idx, idx_empty))\\n\\n            substring = \"\"\\n            for i in range(len(word)):\\n                substring += word[i]\\n                # Where suffix is pal\\n                if substring[::-1] in words_idx and pal(word[i+1:]) and idx != words_idx[substring[::-1]]:\\n                    output.add((idx, words_idx[substring[::-1]]))\\n\\n                # Where prefix is pal \\n                if word[i+1:][::-1] in words_idx and pal(substring) and idx != words_idx[word[i+1:][::-1]]:\\n                    output.add((words_idx[word[i+1:][::-1]], idx))\\n            \\n        return output\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def palindromePairs(self, words):\\n        @cache\\n        def pal(string):\\n            l, r = 0, len(string)-1\\n            while l < r:\\n                if string[l] != string[r]:\\n                    return False\\n                l+=1\\n                r-=1\\n            return True\\n                \\n        output = set()\\n        words_idx = {w:idx for idx,w in enumerate(words)}\\n\\n        # Index of empty string\\n        idx_empty = -1\\n        if \"\" in words_idx:\\n            idx_empty = words_idx[\"\"]\\n\\n        for idx, word in enumerate(words):\\n            # To handle cases with empty string\\n            if pal(word) and word != \"\" and idx_empty != -1:\\n                    output.add((idx_empty, idx))\\n                    output.add((idx, idx_empty))\\n\\n            substring = \"\"\\n            for i in range(len(word)):\\n                substring += word[i]\\n                # Where suffix is pal\\n                if substring[::-1] in words_idx and pal(word[i+1:]) and idx != words_idx[substring[::-1]]:\\n                    output.add((idx, words_idx[substring[::-1]]))\\n\\n                # Where prefix is pal \\n                if word[i+1:][::-1] in words_idx and pal(substring) and idx != words_idx[word[i+1:][::-1]]:\\n                    output.add((words_idx[word[i+1:][::-1]], idx))\\n            \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589280,
                "title": "trie-c",
                "content": "```\\nstruct TrieNode {\\n    int index;\\n    vector<int> palindromeSuffix;\\n    TrieNode* children[26] = {nullptr};\\n    TrieNode(){\\n        index = -1;\\n    }\\n};\\n\\nclass Solution {\\n    bool isPalindrome(string& word, int start, int end){\\n        while(start<end){\\n            if (word[start++] != word[end--]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void addWordInTrie(TrieNode* root, string& word, int idx){\\n        int n = word.size();\\n        for(int i=n-1; i>=0; i--){\\n            int next = word[i]-\\'a\\';\\n            if (root->children[next] == nullptr){\\n                root->children[next] = new TrieNode();\\n            }\\n            \\n            if (isPalindrome(word, 0, i)){\\n                root->palindromeSuffix.push_back(idx);\\n            }\\n            \\n            root = root->children[next];\\n        }\\n        \\n        root->index = idx;\\n        root->palindromeSuffix.push_back(idx);\\n    }\\n    \\n    void searchWord(TrieNode* root, string& word, int idx, vector<vector<int>>& op){\\n        int wordN = word.size();\\n        for(int i=0; i<wordN; i++){\\n            if (root->index >= 0 && root->index != idx && isPalindrome(word, i, wordN-1)){\\n                op.push_back({idx, root->index});\\n            }\\n            \\n            root = root->children[word[i]-\\'a\\'];\\n            // no string exist in reverse, then return\\n            if (root == NULL){\\n                return;\\n            }\\n        }\\n        for(auto i: root->palindromeSuffix){\\n            if (i == idx){\\n                continue;\\n            }\\n            op.push_back({idx, i});\\n        }\\n    }\\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        TrieNode* root = new TrieNode();\\n        vector<vector<int>> op;\\n        int n = words.size();\\n        for(int i=0; i<n; i++){\\n            addWordInTrie(root, words[i], i);\\n        }\\n        for(int i=0; i<n; i++){\\n            searchWord(root, words[i], i, op);\\n        }\\n        return op;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nstruct TrieNode {\\n    int index;\\n    vector<int> palindromeSuffix;\\n    TrieNode* children[26] = {nullptr};\\n    TrieNode(){\\n        index = -1;\\n    }\\n};\\n\\nclass Solution {\\n    bool isPalindrome(string& word, int start, int end){\\n        while(start<end){\\n            if (word[start++] != word[end--]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void addWordInTrie(TrieNode* root, string& word, int idx){\\n        int n = word.size();\\n        for(int i=n-1; i>=0; i--){\\n            int next = word[i]-\\'a\\';\\n            if (root->children[next] == nullptr){\\n                root->children[next] = new TrieNode();\\n            }\\n            \\n            if (isPalindrome(word, 0, i)){\\n                root->palindromeSuffix.push_back(idx);\\n            }\\n            \\n            root = root->children[next];\\n        }\\n        \\n        root->index = idx;\\n        root->palindromeSuffix.push_back(idx);\\n    }\\n    \\n    void searchWord(TrieNode* root, string& word, int idx, vector<vector<int>>& op){\\n        int wordN = word.size();\\n        for(int i=0; i<wordN; i++){\\n            if (root->index >= 0 && root->index != idx && isPalindrome(word, i, wordN-1)){\\n                op.push_back({idx, root->index});\\n            }\\n            \\n            root = root->children[word[i]-\\'a\\'];\\n            // no string exist in reverse, then return\\n            if (root == NULL){\\n                return;\\n            }\\n        }\\n        for(auto i: root->palindromeSuffix){\\n            if (i == idx){\\n                continue;\\n            }\\n            op.push_back({idx, i});\\n        }\\n    }\\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        TrieNode* root = new TrieNode();\\n        vector<vector<int>> op;\\n        int n = words.size();\\n        for(int i=0; i<n; i++){\\n            addWordInTrie(root, words[i], i);\\n        }\\n        for(int i=0; i<n; i++){\\n            searchWord(root, words[i], i, op);\\n        }\\n        return op;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589059,
                "title": "python-solution-using-dictionary",
                "content": "At first the solution seems to be pretty easy: we just check if reversed `words[i]` is in `words`. If yes and the index `j` of reversed word is not equal to `i`, correspondent indices `[i,j]` are added to the answer list. This covers the case like `\"abcd\"` and `\"dcba\"` , when both are in `words`\\n\\nIf index `j` of reversed word is equal to `i` and `words[i]` is not an empty string, it means `words[i]` is a palindrome itself. So if `\"\"` is in `words`, the palindrome can be formed from palindromic `words[i]` by adding empty string to the beginning or to the end of this `words[i]`.\\n\\nBut let\\'s look at the **Example 1** in the [problem description](https://leetcode.com/problems/palindrome-pairs/). There we have `\"lls\"` and `\"s\"`, that can form a palindrome `\"slls\"`. The above solution will not detect it. To cover such cases we need to split `words[i]` to `prefix` and `suffix`. If `prefix` is a palindrome, we need to check if reversed `suffix` is in `words[i]`. Then the palindrome can be formed from reversed suffix + palindromic `prefix` + `suffix`. The same should be checked for `suffix`. If `suffix` is palindromic and reversed `prefix` is in `words`, than palindrome can be formed from `prefix` + palindromic `suffix` + reversed `prefix`\\n\\nTo search reversed `words[i]` in a constant time we need to create hashtable mapping the reversed `words[i]` and index `i` for each word in `words`\\n\\n\\n**Time complexity**: `O(n `&times; `m`<sup>`2`</sup>`)`, where `n = len(words)`, `m =` words\\' length in `words`<br>\\n- create dictionary of reversed words: `O(n`&times;`m)`, \\n- process each word - `n` iterations, each involves `(m-1)` iterations to create `prefix` and `suffix`, and (potentially), check if they are palindromic. In total: `O(n `&times; `m`<sup>`2`</sup>`)`\\n\\n**Space complexity:** `O(n)` for dictionary of reversed words\\n\\n```python\\ndef palindromePairs(self, words: List[str]) -> List[List[int]]:\\n\\n    def isPalindrome(word: str) -> bool:\\n        for i in range(len(word) >> 1):\\n            if word[i] != word[~i]:\\n                return False\\n        return True\\n    # end isPalindrome\\n\\n    words_dict: Dict[str,int] = {word[::-1]:i for i, word in enumerate(words)} # map reversed words to their indices\\n    ans: List[List[int]] = []\\n\\n    for i in range(len(words)):\\n        \\n        # analyze the whole words[i]\\n        if words[i] in words_dict:\\n            if i != words_dict[words[i]]:\\n                # words[i] is not a palindrome, but reversed word exists in `words`,\\n                # thus joining words[i] with reversed word them will give a palindrome\\n                ans.append([i,words_dict[words[i]]])\\n            elif len(words[i]) and \"\" in words_dict:\\n                # words[i] is non-empty string palindrome and \"\" is in `words`,\\n                # so adding \"\" to the beginning or to the end of words[i] gives a palindrome\\n                ans.append([words_dict[\"\"],i])\\n                ans.append([i,words_dict[\"\"]])\\n        \\n        # analyze prefixes and suffixes\\n        for j in range(1,len(words[i])):\\n            pref = words[i][:j]\\n            suff = words[i][j:]\\n            if suff in words_dict and isPalindrome(pref): # check if suff in words_dict first, palindrome check is expensive\\n                    ans.append([words_dict[suff],i])\\n            if pref in words_dict and isPalindrome(suff):\\n                    ans.append([i, words_dict[pref]])\\n    return ans\\n# end palindromePairs()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef palindromePairs(self, words: List[str]) -> List[List[int]]:\\n\\n    def isPalindrome(word: str) -> bool:\\n        for i in range(len(word) >> 1):\\n            if word[i] != word[~i]:\\n                return False\\n        return True\\n    # end isPalindrome\\n\\n    words_dict: Dict[str,int] = {word[::-1]:i for i, word in enumerate(words)} # map reversed words to their indices\\n    ans: List[List[int]] = []\\n\\n    for i in range(len(words)):\\n        \\n        # analyze the whole words[i]\\n        if words[i] in words_dict:\\n            if i != words_dict[words[i]]:\\n                # words[i] is not a palindrome, but reversed word exists in `words`,\\n                # thus joining words[i] with reversed word them will give a palindrome\\n                ans.append([i,words_dict[words[i]]])\\n            elif len(words[i]) and \"\" in words_dict:\\n                # words[i] is non-empty string palindrome and \"\" is in `words`,\\n                # so adding \"\" to the beginning or to the end of words[i] gives a palindrome\\n                ans.append([words_dict[\"\"],i])\\n                ans.append([i,words_dict[\"\"]])\\n        \\n        # analyze prefixes and suffixes\\n        for j in range(1,len(words[i])):\\n            pref = words[i][:j]\\n            suff = words[i][j:]\\n            if suff in words_dict and isPalindrome(pref): # check if suff in words_dict first, palindrome check is expensive\\n                    ans.append([words_dict[suff],i])\\n            if pref in words_dict and isPalindrome(suff):\\n                    ans.append([i, words_dict[pref]])\\n    return ans\\n# end palindromePairs()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2588611,
                "title": "c-trie-data-structure",
                "content": "```\\nclass Solution {\\npublic:\\n    class Trie\\n    {\\n        public:\\n        int index=-1;\\n        Trie *next[26];\\n        vector<int> list;\\n        \\n    };\\n    vector<vector<int>> ans;\\n    \\n    bool ispalindrome(string &s,int i,int j)\\n    {\\n        \\n        while(i<j)\\n        {\\n            if(s[i++]!=s[j--])\\n                return false;  \\n        }   \\n        \\n        return true;\\n    }\\n    void addword(string &s,Trie *root,int indx)\\n    {\\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(!root->next[s[i]-\\'a\\'])\\n                root->next[s[i]-\\'a\\']=new Trie();\\n            \\n            if(ispalindrome(s,0,i))\\n                (root->list).push_back(indx);\\n            \\n            root=root->next[s[i]-\\'a\\'];\\n        }\\n        \\n        root->index=indx;\\n    }\\n    void search(string &s,Trie *root,int indx)\\n    {\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(root->index>=0&&root->index!=indx&&ispalindrome(s,i,s.size()-1))\\n            {\\n                ans.push_back({indx,root->index});\\n            }\\n            \\n            if(!root->next[s[i]-\\'a\\'])\\n                return ;\\n            \\n            root=root->next[s[i]-\\'a\\'];\\n        }\\n        \\n        if(root->index!=-1&&root->index!=indx)\\n            ans.push_back({indx,root->index});\\n        \\n        for(int j:root->list)\\n        {\\n            if(indx!=j)\\n                ans.push_back({indx,j});\\n        }\\n    }\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        Trie *root=new Trie();\\n        \\n        for(int i=0;i<words.size();i++)\\n            addword(words[i],root,i);\\n        \\n        for(int i=0;i<words.size();i++)\\n            search(words[i],root,i);\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Tree",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    class Trie\\n    {\\n        public:\\n        int index=-1;\\n        Trie *next[26];\\n        vector<int> list;\\n        \\n    };\\n    vector<vector<int>> ans;\\n    \\n    bool ispalindrome(string &s,int i,int j)\\n    {\\n        \\n        while(i<j)\\n        {\\n            if(s[i++]!=s[j--])\\n                return false;  \\n        }   \\n        \\n        return true;\\n    }\\n    void addword(string &s,Trie *root,int indx)\\n    {\\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(!root->next[s[i]-\\'a\\'])\\n                root->next[s[i]-\\'a\\']=new Trie();\\n            \\n            if(ispalindrome(s,0,i))\\n                (root->list).push_back(indx);\\n            \\n            root=root->next[s[i]-\\'a\\'];\\n        }\\n        \\n        root->index=indx;\\n    }\\n    void search(string &s,Trie *root,int indx)\\n    {\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(root->index>=0&&root->index!=indx&&ispalindrome(s,i,s.size()-1))\\n            {\\n                ans.push_back({indx,root->index});\\n            }\\n            \\n            if(!root->next[s[i]-\\'a\\'])\\n                return ;\\n            \\n            root=root->next[s[i]-\\'a\\'];\\n        }\\n        \\n        if(root->index!=-1&&root->index!=indx)\\n            ans.push_back({indx,root->index});\\n        \\n        for(int j:root->list)\\n        {\\n            if(indx!=j)\\n                ans.push_back({indx,j});\\n        }\\n    }\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        Trie *root=new Trie();\\n        \\n        for(int i=0;i<words.size();i++)\\n            addword(words[i],root,i);\\n        \\n        for(int i=0;i<words.size();i++)\\n            search(words[i],root,i);\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2586841,
                "title": "java-trie-solution",
                "content": "```\\nclass Trie {\\n    Integer endIndex;\\n    Map<Character, Trie> child = new HashMap<>();\\n    List<Integer> palindromesFromHere = new ArrayList<>();\\n\\n    boolean isWordNode() {\\n        return endIndex != null;\\n    }\\n}\\n\\nclass Solution {\\n\\n    private Trie buildTrie(String[] words) {\\n        final Trie root = new Trie();\\n        for (int i = 0, n = words.length; i < n; i++) {\\n            final String currWord = words[i];\\n            Trie currentTrie = root;\\n            for (int j = 0, jn = currWord.length(); j < jn; j++) {\\n                final int reverseIndex = jn - j - 1;\\n                if (isPalindrome(currWord, 0, reverseIndex)) currentTrie.palindromesFromHere.add(i);\\n                final Character currReverseChar = currWord.charAt(reverseIndex);\\n                currentTrie = currentTrie.child.computeIfAbsent(currReverseChar, c -> new Trie());\\n            }\\n            currentTrie.endIndex = i;\\n        }\\n        return root;\\n    }\\n\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        final Trie root = buildTrie(words);\\n        final List<List<Integer>> pairs = new ArrayList<>();\\n\\n        outer: for (int i = 0, n = words.length; i < n; i++) {\\n            final String currWord = words[i];\\n            Trie currentTrie = root;\\n            for (int j = 0, jn = currWord.length(); j < jn; j++) {\\n                // case 3 : When W1 is bigger than W2 and W1 ends with palindrome\\n                if (currentTrie.isWordNode() && isPalindrome(currWord, j, jn - 1)) {\\n                    pairs.add(Arrays.asList(i, currentTrie.endIndex));\\n                }\\n\\n                // move to next trie\\n                currentTrie = currentTrie.child.get(currWord.charAt(j));\\n                if (currentTrie == null) continue outer;\\n            }\\n\\n            // case 1 : W1 and W2 are of same size and reverse of each other\\n            if (currentTrie.isWordNode() && currentTrie.endIndex != i) {\\n                pairs.add(Arrays.asList(i, currentTrie.endIndex));\\n            }\\n\\n            // case 2 : W1 is smaller than W2 and W2 begins with palindrome\\n\\n            for (final Integer palindromeIndex : currentTrie.palindromesFromHere) {\\n                pairs.add(Arrays.asList(i, palindromeIndex));\\n            }\\n        }\\n\\n        return pairs;\\n    }\\n\\n    private boolean isPalindrome(String word, int fromIndex, int toIndex) {\\n        for (int i = fromIndex, j = toIndex; i < j; i++, j--) {\\n            if (word.charAt(i) != word.charAt(j)) return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass Trie {\\n    Integer endIndex;\\n    Map<Character, Trie> child = new HashMap<>();\\n    List<Integer> palindromesFromHere = new ArrayList<>();\\n\\n    boolean isWordNode() {\\n        return endIndex != null;\\n    }\\n}\\n\\nclass Solution {\\n\\n    private Trie buildTrie(String[] words) {\\n        final Trie root = new Trie();\\n        for (int i = 0, n = words.length; i < n; i++) {\\n            final String currWord = words[i];\\n            Trie currentTrie = root;\\n            for (int j = 0, jn = currWord.length(); j < jn; j++) {\\n                final int reverseIndex = jn - j - 1;\\n                if (isPalindrome(currWord, 0, reverseIndex)) currentTrie.palindromesFromHere.add(i);\\n                final Character currReverseChar = currWord.charAt(reverseIndex);\\n                currentTrie = currentTrie.child.computeIfAbsent(currReverseChar, c -> new Trie());\\n            }\\n            currentTrie.endIndex = i;\\n        }\\n        return root;\\n    }\\n\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        final Trie root = buildTrie(words);\\n        final List<List<Integer>> pairs = new ArrayList<>();\\n\\n        outer: for (int i = 0, n = words.length; i < n; i++) {\\n            final String currWord = words[i];\\n            Trie currentTrie = root;\\n            for (int j = 0, jn = currWord.length(); j < jn; j++) {\\n                // case 3 : When W1 is bigger than W2 and W1 ends with palindrome\\n                if (currentTrie.isWordNode() && isPalindrome(currWord, j, jn - 1)) {\\n                    pairs.add(Arrays.asList(i, currentTrie.endIndex));\\n                }\\n\\n                // move to next trie\\n                currentTrie = currentTrie.child.get(currWord.charAt(j));\\n                if (currentTrie == null) continue outer;\\n            }\\n\\n            // case 1 : W1 and W2 are of same size and reverse of each other\\n            if (currentTrie.isWordNode() && currentTrie.endIndex != i) {\\n                pairs.add(Arrays.asList(i, currentTrie.endIndex));\\n            }\\n\\n            // case 2 : W1 is smaller than W2 and W2 begins with palindrome\\n\\n            for (final Integer palindromeIndex : currentTrie.palindromesFromHere) {\\n                pairs.add(Arrays.asList(i, palindromeIndex));\\n            }\\n        }\\n\\n        return pairs;\\n    }\\n\\n    private boolean isPalindrome(String word, int fromIndex, int toIndex) {\\n        for (int i = fromIndex, j = toIndex; i < j; i++, j--) {\\n            if (word.charAt(i) != word.charAt(j)) return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2586764,
                "title": "c-using-map",
                "content": "class Solution {\\npublic:\\n    \\n    bool pal(string &s,int i,int j){\\n        while(i<j){\\n            if(s[i++]!=s[j--]) return 0;\\n        }\\n        return 1;\\n    }\\n    vector<vector<int>> palindromePairs(vector<string>& a) {\\n        vector<vector<int>> ans;\\n        unordered_map<string,int> mp,m;\\n        int n=a.size();\\n        for(int i=0;i<a.size();i++){\\n            reverse(a[i].begin(),a[i].end());\\n            m[a[i]]=i;\\n            reverse(a[i].begin(),a[i].end());\\n            mp[a[i]]=i;\\n        }\\n        if(mp.find(\"\")!=mp.end()){\\n            int bi=mp[\"\"];\\n            for(int i=0;i<n;i++){\\n                if(i!=bi && pal(a[i],0,a[i].size()-1)){\\n                    ans.push_back({i,bi});\\n                    ans.push_back({bi,i});\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            string t=a[i];\\n            reverse(t.begin(),t.end());\\n            if(mp.find(t)!=mp.end() && mp[t]!=i){\\n                ans.push_back({i,mp[t]});\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(a[i]==\"\") continue;\\n            string t=\"\";\\n            for(int j=0;j<a[i].size()-1;j++){\\n                t+=a[i][j];\\n                if(m.find(t) != m.end() && m[t] != i && pal(a[i], j + 1 , a[i].size() - 1)){\\n                    ans.push_back({i,m[t]});\\n                }\\n            }\\n            t=\"\";\\n            for(int j=a[i].size()-1;j>0;j--){\\n                t+=a[i][j];\\n                if(mp.find(t)!=mp.end() && mp[t] != i && pal(a[i],0,j-1)){\\n                    ans.push_back({mp[t],i});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    bool pal(string &s,int i,int j){\\n        while(i<j){\\n            if(s[i++]!=s[j--]) return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2585948,
                "title": "c-hasmap-brute-trie-tle-fixed",
                "content": "**336. Palindrome Pairs**\\n\\n\\n3145\\n\\n307\\n\\n\\n**Share**\\nGiven a list of unique words, return all the pairs of the distinct indices (i, j) in the given list, so that the concatenation of the two words words[i] + words[j] is a palindrome.\\n\\n \\n\\n**Example 1:**\\n\\n**Input: words** = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]\\n**Output**: [[0,1],[1,0],[3,2],[2,4]]\\n**Explanation**: The palindromes are [\"dcbaabcd\",\"abcddcba\",\"slls\",\"llssssll\"]\\n**Example** 2:\\n\\n**Input: words** = [\"bat\",\"tab\",\"cat\"]\\n**Output**: [[0,1],[1,0]]\\n**Explanation**: The palindromes are [\"battab\",\"tabbat\"]\\n**Example** 3:\\n\\n**Input: words** = [\"a\",\"\"]\\n**Output**: [[0,1],[1,0]]\\n \\n\\n**Constraints:**\\n\\n1 <= words.length <= 5000\\n0 <= words[i].length <= 300\\nwords[i] consists of lower-case English letters.\\n\\n**EXPLAIN SOLUTION -**\\n\\n\\n**Intuition: Brute Force :**\\nWe basically check every pair of words and see if the concatenation of the two words is a palindrome.\\n\\n**Approach:**\\n\\nFor each word, we check if the reversed word is in the words array.\\nIf it is, we add the index of the reversed word to the result.\\nIf the reversed word is not in the words array, we check if the reversed word is a prefix of the current word.\\nIf it is, we check if the suffix of the current word is a palindrome.\\nIf it is, we add the index of the reversed word to the result.\\nThus, we store the reversed word in a vector and return the result.\\n**C++(TLE):**\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string word) {\\n        int i = 0;\\n        int j = word.size() - 1;\\n        while (i < j) {\\n            if (word[i] != word[j]) {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        vector<vector<int>> result;\\n        for (int i = 0; i < words.size(); i++) {\\n            for (int j = 0; j < words.size(); j++) {\\n                if (i == j) {\\n                    continue;\\n                }\\n                string word = words[i] + words[j];\\n                if (isPalindrome(word)) {\\n                    result.push_back({i, j});\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n**Time Complexity: O(n^2 * m)\\nSpace Complexity: O(1)**\\n\\nThe above code will give TLE because it\\'s just the brute force approach, so we need to optimize the Time Complexity.\\n**Approach:**\\n\\nWe can use a hashmap to store the words and their indices.\\nNow, we can iterate over the words and check if the reversed word exists in the hashmap.\\nIf it exists, then we can check if the remaining part of the word is a palindrome.\\nIf it is, then we can add the indices to the result.\\nWe can also check if the word is a palindrome and if the reversed word exists in the hashmap.\\nIf it does, then we can add the indices to the result.\\nC++ (YET ANOTHER TLE CODE):-\\n\\n```\\nbool isPalindrome(string word) {\\n        int i = 0;\\n        int j = word.size() - 1;\\n        while (i < j) {\\n            if (word[i] != word[j]) {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n}\\nvector<vector<int>> palindromePairs(vector<string>& words) {\\n        vector<vector<int>> result;\\n        unordered_map<string, int> wordMap;\\n        for (int i = 0; i < words.size(); i++) {\\n            wordMap[words[i]] = i;\\n        }\\n        for (int i = 0; i < words.size(); i++) {\\n            string word = words[i];\\n            string reversedWord = word;\\n            reverse(reversedWord.begin(), reversedWord.end());\\n            if (wordMap.find(reversedWord) != wordMap.end() && wordMap[reversedWord] != i) {\\n                result.push_back({i, wordMap[reversedWord]});\\n            }\\n            if (isPalindrome(word)) {\\n                string emptyString = \"\";\\n                if (wordMap.find(emptyString) != wordMap.end() && wordMap[emptyString] != i) {\\n                    result.push_back({i, wordMap[emptyString]});\\n                    result.push_back({wordMap[emptyString], i});\\n                }\\n            }\\n            for (int j = 1; j < word.size(); j++) {\\n                string left = word.substr(0, j);\\n                string right = word.substr(j);\\n                string reversedLeft = left;\\n                string reversedRight = right;\\n                reverse(reversedLeft.begin(), reversedLeft.end());\\n                reverse(reversedRight.begin(), reversedRight.end());\\n                if (isPalindrome(left) && wordMap.find(reversedRight) != wordMap.end()) {\\n                    result.push_back({wordMap[reversedRight], i});\\n                }\\n                if (isPalindrome(right) && wordMap.find(reversedLeft) != wordMap.end()) {\\n                    result.push_back({i, wordMap[reversedLeft]});\\n                }\\n            }\\n        }\\n        return result;\\n\\t}\\n```\\nTime Complexity: O(n * k^2) where n is the number of words and k is the length of the longest word\\nSpace Complexity: O(n * k)\\n\\nThe only way to optimize the code further is to use TRIE.\\n**Approach:**\\n\\nIdea is to use Trie to store all the words in reverse order\\nSo that we can find all the palindromes in O(k) time\\nC++(NO TLE, ACCEPTED CODE):\\n\\n```\\nstruct TrieNode {\\n    TrieNode *next[26] = {};\\n    int index = -1;\\n    vector<int> palindromeIndexes;\\n};\\nclass Solution {\\n    bool isPalindrome(string &s, int i, int j) {\\n        while (i < j && s[i] == s[j]) ++i, --j;\\n        return i >= j;\\n    }\\n    TrieNode *root;\\n    void insert(string &s, int index) {\\n        TrieNode *node = root;\\n        for (int i = s.size() - 1; i >= 0; i--) {\\n            int c = s[i] - \\'a\\';\\n            if (!node->next[c]) {\\n                node->next[c] = new TrieNode();\\n            }\\n            if (isPalindrome(s, 0, i)) {\\n                node->palindromeIndexes.push_back(index);\\n            }\\n            node = node->next[c];\\n        }\\n        node->index = index;\\n        node->palindromeIndexes.push_back(index);\\n    }\\n    public:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        root = new TrieNode();\\n        for (int i = 0; i < words.size(); i++) {\\n            insert(words[i], i);\\n        }\\n        vector<vector<int>> result;\\n        for (int i = 0; i < words.size(); i++) {\\n            TrieNode *node = root;\\n            string &s = words[i];\\n            for (int j = 0; j < s.size(); j++) {\\n                if (node->index >= 0 && node->index != i && isPalindrome(s, j, s.size() - 1)) {\\n                    result.push_back({i, node->index});\\n                }\\n                node = node->next[s[j] - \\'a\\'];\\n                if (!node) break;\\n            }\\n            if (node) {\\n                for (int j : node->palindromeIndexes) {\\n                    if (i == j) continue;\\n                    result.push_back({i, j});\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```**\\nTime Complexity: O(n * k^2) where n is the number of words and k is the length of the longest word\\nSpace Complexity: O(n * k)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string word) {\\n        int i = 0;\\n        int j = word.size() - 1;\\n        while (i < j) {\\n            if (word[i] != word[j]) {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        vector<vector<int>> result;\\n        for (int i = 0; i < words.size(); i++) {\\n            for (int j = 0; j < words.size(); j++) {\\n                if (i == j) {\\n                    continue;\\n                }\\n                string word = words[i] + words[j];\\n                if (isPalindrome(word)) {\\n                    result.push_back({i, j});\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nbool isPalindrome(string word) {\\n        int i = 0;\\n        int j = word.size() - 1;\\n        while (i < j) {\\n            if (word[i] != word[j]) {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n}\\nvector<vector<int>> palindromePairs(vector<string>& words) {\\n        vector<vector<int>> result;\\n        unordered_map<string, int> wordMap;\\n        for (int i = 0; i < words.size(); i++) {\\n            wordMap[words[i]] = i;\\n        }\\n        for (int i = 0; i < words.size(); i++) {\\n            string word = words[i];\\n            string reversedWord = word;\\n            reverse(reversedWord.begin(), reversedWord.end());\\n            if (wordMap.find(reversedWord) != wordMap.end() && wordMap[reversedWord] != i) {\\n                result.push_back({i, wordMap[reversedWord]});\\n            }\\n            if (isPalindrome(word)) {\\n                string emptyString = \"\";\\n                if (wordMap.find(emptyString) != wordMap.end() && wordMap[emptyString] != i) {\\n                    result.push_back({i, wordMap[emptyString]});\\n                    result.push_back({wordMap[emptyString], i});\\n                }\\n            }\\n            for (int j = 1; j < word.size(); j++) {\\n                string left = word.substr(0, j);\\n                string right = word.substr(j);\\n                string reversedLeft = left;\\n                string reversedRight = right;\\n                reverse(reversedLeft.begin(), reversedLeft.end());\\n                reverse(reversedRight.begin(), reversedRight.end());\\n                if (isPalindrome(left) && wordMap.find(reversedRight) != wordMap.end()) {\\n                    result.push_back({wordMap[reversedRight], i});\\n                }\\n                if (isPalindrome(right) && wordMap.find(reversedLeft) != wordMap.end()) {\\n                    result.push_back({i, wordMap[reversedLeft]});\\n                }\\n            }\\n        }\\n        return result;\\n\\t}\\n```\n```\\nstruct TrieNode {\\n    TrieNode *next[26] = {};\\n    int index = -1;\\n    vector<int> palindromeIndexes;\\n};\\nclass Solution {\\n    bool isPalindrome(string &s, int i, int j) {\\n        while (i < j && s[i] == s[j]) ++i, --j;\\n        return i >= j;\\n    }\\n    TrieNode *root;\\n    void insert(string &s, int index) {\\n        TrieNode *node = root;\\n        for (int i = s.size() - 1; i >= 0; i--) {\\n            int c = s[i] - \\'a\\';\\n            if (!node->next[c]) {\\n                node->next[c] = new TrieNode();\\n            }\\n            if (isPalindrome(s, 0, i)) {\\n                node->palindromeIndexes.push_back(index);\\n            }\\n            node = node->next[c];\\n        }\\n        node->index = index;\\n        node->palindromeIndexes.push_back(index);\\n    }\\n    public:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        root = new TrieNode();\\n        for (int i = 0; i < words.size(); i++) {\\n            insert(words[i], i);\\n        }\\n        vector<vector<int>> result;\\n        for (int i = 0; i < words.size(); i++) {\\n            TrieNode *node = root;\\n            string &s = words[i];\\n            for (int j = 0; j < s.size(); j++) {\\n                if (node->index >= 0 && node->index != i && isPalindrome(s, j, s.size() - 1)) {\\n                    result.push_back({i, node->index});\\n                }\\n                node = node->next[s[j] - \\'a\\'];\\n                if (!node) break;\\n            }\\n            if (node) {\\n                for (int j : node->palindromeIndexes) {\\n                    if (i == j) continue;\\n                    result.push_back({i, j});\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585899,
                "title": "easy-java-accepted-solution",
                "content": "```\\nclass Solution {\\n    private Node root;\\n    \\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        \\n        if (words == null || words.length == 0)\\n            return new ArrayList<>();\\n        \\n        root = new Node();\\n        int n = words.length;\\n        List<List<Integer>> finalResult = new ArrayList<>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (words[i].isEmpty()) {\\n                // Pair with all self-palindrome.\\n                List<Integer> selfPalindromeWordIndices = getSelfPalindrome(words);\\n                for (int pairId : selfPalindromeWordIndices) {\\n                    finalResult.add(new ArrayList<>(Arrays.asList(i, pairId)));\\n                    finalResult.add(new ArrayList<>(Arrays.asList(pairId, i)));\\n                }\\n            }\\n            else {\\n                insert(reverse(words[i]), i);\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            List<Integer> wordIndices = search(words[i], i);\\n            for (int pairId : wordIndices) {\\n                finalResult.add(new ArrayList<>(Arrays.asList(i, pairId)));\\n            }\\n        }\\n        \\n        return finalResult;\\n    }\\n    \\n    /****************** Trie-related *******************/\\n    \\n    private List<Integer> search(String word, int index) {\\n        \\n        List<Integer> wordIndices = new ArrayList<>();\\n        Node ptr = root;\\n        int n = word.length();\\n        for (int i = 0; i < n; i++) {\\n            int label = word.charAt(i) - \\'a\\';\\n            if (ptr.endWordId > -1 && isPalindrome(word, i, n - 1)) {\\n                wordIndices.add(ptr.endWordId);                \\n            }\\n            if (ptr.children[label] == null) {\\n                return wordIndices;\\n            } \\n            ptr = ptr.children[label];\\n        }\\n        if (ptr.endWordId > -1 && ptr.endWordId != index)\\n            wordIndices.add(ptr.endWordId);\\n        if (!ptr.belowPalindromeWordIds.isEmpty())\\n            wordIndices.addAll(ptr.belowPalindromeWordIds);\\n        \\n        return wordIndices;\\n    }\\n    \\n    private void insert(String word, int index) {\\n        \\n        Node ptr = root;\\n        int n = word.length();\\n        for (int i = 0; i < n; i++) {\\n            int label = word.charAt(i) - \\'a\\';               \\n            if (ptr.children[label] == null)\\n                ptr.children[label] = new Node();\\n            ptr = ptr.children[label];\\n            if (isPalindrome(word, i + 1, n - 1))\\n                ptr.belowPalindromeWordIds.add(index);\\n        }\\n        \\n        ptr.endWordId = index;\\n    }\\n    \\n    class Node {\\n        \\n        Node[] children;\\n        int endWordId; // Equals to -1 in default. If it is a word\\'s end, it is the index of the word.\\n        List<Integer> belowPalindromeWordIds; // List of word indices such that nodes below can construct a palindrome.\\n        \\n        public Node() {\\n            children = new Node[26];\\n            endWordId = -1;\\n            belowPalindromeWordIds = new ArrayList<>();\\n        }\\n        \\n    }\\n    \\n    /****************** Utility *******************/\\n    \\n    private String reverse(String str) {\\n        return new StringBuilder(str).reverse().toString();\\n    }\\n    \\n    private boolean isPalindrome(String str, int start, int end) {\\n        \\n        if (start > end) {\\n            return false;\\n        }\\n        \\n        while (start < end) {\\n            if (str.charAt(start) != str.charAt(end))\\n                return false;\\n            start++;\\n            end--;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private List<Integer> getSelfPalindrome(String[] words) {\\n        List<Integer> wordIndices = new ArrayList<>();\\n        for (int i = 0; i < words.length; i++) {\\n            if (isPalindrome(words[i], 0, words[i].length() - 1)) {\\n                wordIndices.add(i);\\n            }\\n        }\\n        return wordIndices;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private Node root;\\n    \\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        \\n        if (words == null || words.length == 0)\\n            return new ArrayList<>();\\n        \\n        root = new Node();\\n        int n = words.length;\\n        List<List<Integer>> finalResult = new ArrayList<>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (words[i].isEmpty()) {\\n                // Pair with all self-palindrome.\\n                List<Integer> selfPalindromeWordIndices = getSelfPalindrome(words);\\n                for (int pairId : selfPalindromeWordIndices) {\\n                    finalResult.add(new ArrayList<>(Arrays.asList(i, pairId)));\\n                    finalResult.add(new ArrayList<>(Arrays.asList(pairId, i)));\\n                }\\n            }\\n            else {\\n                insert(reverse(words[i]), i);\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            List<Integer> wordIndices = search(words[i], i);\\n            for (int pairId : wordIndices) {\\n                finalResult.add(new ArrayList<>(Arrays.asList(i, pairId)));\\n            }\\n        }\\n        \\n        return finalResult;\\n    }\\n    \\n    /****************** Trie-related *******************/\\n    \\n    private List<Integer> search(String word, int index) {\\n        \\n        List<Integer> wordIndices = new ArrayList<>();\\n        Node ptr = root;\\n        int n = word.length();\\n        for (int i = 0; i < n; i++) {\\n            int label = word.charAt(i) - \\'a\\';\\n            if (ptr.endWordId > -1 && isPalindrome(word, i, n - 1)) {\\n                wordIndices.add(ptr.endWordId);                \\n            }\\n            if (ptr.children[label] == null) {\\n                return wordIndices;\\n            } \\n            ptr = ptr.children[label];\\n        }\\n        if (ptr.endWordId > -1 && ptr.endWordId != index)\\n            wordIndices.add(ptr.endWordId);\\n        if (!ptr.belowPalindromeWordIds.isEmpty())\\n            wordIndices.addAll(ptr.belowPalindromeWordIds);\\n        \\n        return wordIndices;\\n    }\\n    \\n    private void insert(String word, int index) {\\n        \\n        Node ptr = root;\\n        int n = word.length();\\n        for (int i = 0; i < n; i++) {\\n            int label = word.charAt(i) - \\'a\\';               \\n            if (ptr.children[label] == null)\\n                ptr.children[label] = new Node();\\n            ptr = ptr.children[label];\\n            if (isPalindrome(word, i + 1, n - 1))\\n                ptr.belowPalindromeWordIds.add(index);\\n        }\\n        \\n        ptr.endWordId = index;\\n    }\\n    \\n    class Node {\\n        \\n        Node[] children;\\n        int endWordId; // Equals to -1 in default. If it is a word\\'s end, it is the index of the word.\\n        List<Integer> belowPalindromeWordIds; // List of word indices such that nodes below can construct a palindrome.\\n        \\n        public Node() {\\n            children = new Node[26];\\n            endWordId = -1;\\n            belowPalindromeWordIds = new ArrayList<>();\\n        }\\n        \\n    }\\n    \\n    /****************** Utility *******************/\\n    \\n    private String reverse(String str) {\\n        return new StringBuilder(str).reverse().toString();\\n    }\\n    \\n    private boolean isPalindrome(String str, int start, int end) {\\n        \\n        if (start > end) {\\n            return false;\\n        }\\n        \\n        while (start < end) {\\n            if (str.charAt(start) != str.charAt(end))\\n                return false;\\n            start++;\\n            end--;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private List<Integer> getSelfPalindrome(String[] words) {\\n        List<Integer> wordIndices = new ArrayList<>();\\n        for (int i = 0; i < words.length; i++) {\\n            if (isPalindrome(words[i], 0, words[i].length() - 1)) {\\n                wordIndices.add(i);\\n            }\\n        }\\n        return wordIndices;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585855,
                "title": "c-trie-related-problems-100-worked",
                "content": "**336. Palindrome Pairs**\\n\\n\\n3092\\n\\n305\\n\\n**Share**\\nGiven a list of unique words, return all the pairs of the distinct indices (i, j) in the given list, so that the concatenation of the two words words[i] + words[j] is a palindrome.\\n\\n \\n**Example 1:**\\n\\n**Input: words** = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]\\n**Output**: [[0,1],[1,0],[3,2],[2,4]]\\n**Explanation**: The palindromes are [\"dcbaabcd\",\"abcddcba\",\"slls\",\"llssssll\"]\\n**Example 2**:\\n\\n**Input:** words = [\"bat\",\"tab\",\"cat\"]\\n**Output**: [[0,1],[1,0]]\\n**Explanation**: The palindromes are [\"battab\",\"tabbat\"]\\n**Example** 3:\\n\\n**Input: words** = [\"a\",\"\"]\\n**Output**: [[0,1],[1,0]]\\n \\n\\n**Constraints:**\\n\\n1 <= words.length <= 5000\\n0 <= words[i].length <= 300\\nwords[i] consists of lower-case English letters.\\n\\n\\nCode - \\n```\\nstruct TrieNode {\\n    TrieNode *next[26] = {};\\n    int index = -1;\\n    vector<int> palindromeIndexes;\\n};\\n\\nclass Solution {\\n    TrieNode root; // Suffix trie\\n    void add(string &s, int i) {\\n        auto node = &root;\\n        for (int j = s.size() - 1; j >= 0; --j) {\\n            if (isPalindrome(s, 0, j)) node->palindromeIndexes.push_back(i); // A[i]\\'s prefix forms a palindrome\\n            int c = s[j] - \\'a\\';\\n            if (!node->next[c]) node->next[c] = new TrieNode();\\n            node = node->next[c];\\n        }\\n        node->index = i;\\n        node->palindromeIndexes.push_back(i); // A[i]\\'s prefix is empty string here, which is a palindrome.\\n    }\\n    \\n    bool isPalindrome(string &s, int i, int j) {\\n        while (i < j && s[i] == s[j]) ++i, --j;\\n        return i >= j;\\n    }\\n    \\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& A) {\\n        int N = A.size();\\n        for (int i = 0; i < N; ++i) add(A[i], i);\\n        vector<vector<int>> ans;\\n        for (int i = 0; i < N; ++i) {\\n            auto s = A[i];\\n            auto node = &root;\\n            for (int j = 0; j < s.size() && node; ++j) {\\n                if (node->index != -1 && node->index != i && isPalindrome(s, j, s.size() - 1)) ans.push_back({ i, node->index }); \\n                // A[i]\\'s prefix matches this word and A[i]\\'s suffix forms a palindrome\\n                node = node->next[s[j] - \\'a\\'];\\n            }\\n            if (!node) continue;\\n            for (int j : node->palindromeIndexes) { \\n                // A[i] is exhausted in the matching above. \\n                // If a word whose prefix is palindrome after matching its suffix with A[i], \\n                // then this is also a valid pair\\n                if (i != j) ans.push_back({ i, j });\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nTrie - Related Problems\\n1. Implement Trie (Prefix Tree)\\n2. Palindrome Pairs\\n3. Maximum XOR of Two Numbers in an Array\\n4. Concatenated Words\\n5. Search Suggestions System\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "```\\nstruct TrieNode {\\n    TrieNode *next[26] = {};\\n    int index = -1;\\n    vector<int> palindromeIndexes;\\n};\\n\\nclass Solution {\\n    TrieNode root; // Suffix trie\\n    void add(string &s, int i) {\\n        auto node = &root;\\n        for (int j = s.size() - 1; j >= 0; --j) {\\n            if (isPalindrome(s, 0, j)) node->palindromeIndexes.push_back(i); // A[i]\\'s prefix forms a palindrome\\n            int c = s[j] - \\'a\\';\\n            if (!node->next[c]) node->next[c] = new TrieNode();\\n            node = node->next[c];\\n        }\\n        node->index = i;\\n        node->palindromeIndexes.push_back(i); // A[i]\\'s prefix is empty string here, which is a palindrome.\\n    }\\n    \\n    bool isPalindrome(string &s, int i, int j) {\\n        while (i < j && s[i] == s[j]) ++i, --j;\\n        return i >= j;\\n    }\\n    \\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& A) {\\n        int N = A.size();\\n        for (int i = 0; i < N; ++i) add(A[i], i);\\n        vector<vector<int>> ans;\\n        for (int i = 0; i < N; ++i) {\\n            auto s = A[i];\\n            auto node = &root;\\n            for (int j = 0; j < s.size() && node; ++j) {\\n                if (node->index != -1 && node->index != i && isPalindrome(s, j, s.size() - 1)) ans.push_back({ i, node->index }); \\n                // A[i]\\'s prefix matches this word and A[i]\\'s suffix forms a palindrome\\n                node = node->next[s[j] - \\'a\\'];\\n            }\\n            if (!node) continue;\\n            for (int j : node->palindromeIndexes) { \\n                // A[i] is exhausted in the matching above. \\n                // If a word whose prefix is palindrome after matching its suffix with A[i], \\n                // then this is also a valid pair\\n                if (i != j) ans.push_back({ i, j });\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585742,
                "title": "java-trie-easy-explanation-commented",
                "content": "```\\npublic class Solution {\\n    class TrieNode {\\n        public TrieNode[] next;\\n        public int index;\\n        public List<Integer> list;\\n        \\n        public TrieNode() {\\n            index = -1;\\n            next = new TrieNode[26];\\n            list = new ArrayList<>();\\n        }\\n    }\\n    \\n    /**\\n        Let the average length of the String be O(m), then addWord takes O(m^2) amount of time\\n    **/\\n    public void addWord(TrieNode root, String word, int wordIdx) {\\n        for (int i = word.length() - 1; i >= 0; i--) {\\n            char c = word.charAt(i);\\n            if (root.next[c - \\'a\\'] == null) {\\n                root.next[c - \\'a\\'] = new TrieNode();\\n            }\\n            \\n            /**\\n                check and mark if part of string is a palindrome.\\n            **/\\n            if(isPalindrome(word, 0, i)) root.list.add(wordIdx);\\n            root = root.next[c - \\'a\\'];\\n        }\\n        \\n        root.index = wordIdx;\\n    }\\n    \\n    /**\\n        Search takes, O(m^2) amortized time.\\n    **/\\n    public List<List<Integer>> search(TrieNode root, String word, int wordIdx) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        /** \\n            Search part 1 : if the counterparts in Trie are complete words, then check if the unmatched string is a palindore, if it is then             w1 + w2 is a palindorome.\\n        **/\\n        for (int i = 0; i < word.length(); i++) {\\n            if (root.index != -1 && wordIdx != root.index && isPalindrome(word, i, word.length() - 1)) {\\n                res.add(Arrays.asList(wordIdx, root.index));\\n            }\\n            \\n            char c = word.charAt(i);\\n            root = root.next[c - \\'a\\'];\\n            if (root == null) return res;\\n        }\\n        \\n        /**\\n            Search part 2 : if w1 (current search word) is completely matched, see if there is any other word that is complete, if yes w2 is\\n            the reverse of w1 and therefore w1 + w2 is a plaindrome.\\n        **/\\n        if (root.index != wordIdx && root.index != -1) {\\n            res.add(Arrays.asList(wordIdx, root.index));\\n        }\\n        \\n        /** \\n            If w1 is completely matched and if there are any words that are larger than w1 and matched completely and have the rest of the               string as a palindrome then w1 + w2 will be a plaindrome.\\n        **/\\n        for (Integer k : root.list) {\\n            res.add(Arrays.asList(wordIdx, k));\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private boolean isPalindrome(String word, int s, int e) {\\n        while(s < e && word.charAt(s) == word.charAt(e)) {\\n            s++;\\n            e--;\\n        }\\n        \\n        return s >= e;\\n    }\\n    \\n    /**\\n        Time complexity : O(n * m^2).\\n        Space Complexity : O(n * m).\\n    **/\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        TrieNode root = new TrieNode();\\n        \\n        /**\\n            addWord is invoked O(n) number of times, therefore it takes O(n * m^2) Time.\\n        **/\\n        for(int i = 0; i < words.length; i++) {\\n            addWord(root, words[i], i);\\n        }\\n        \\n        /**\\n            Search is invoked O(n) times, it takes O(n * m^2) worse case time.\\n        **/\\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = 0; i < words.length; i++) {\\n            res.addAll(search(root, words[i], i));\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\npublic class Solution {\\n    class TrieNode {\\n        public TrieNode[] next;\\n        public int index;\\n        public List<Integer> list;\\n        \\n        public TrieNode() {\\n            index = -1;\\n            next = new TrieNode[26];\\n            list = new ArrayList<>();\\n        }\\n    }\\n    \\n    /**\\n        Let the average length of the String be O(m), then addWord takes O(m^2) amount of time\\n    **/\\n    public void addWord(TrieNode root, String word, int wordIdx) {\\n        for (int i = word.length() - 1; i >= 0; i--) {\\n            char c = word.charAt(i);\\n            if (root.next[c - \\'a\\'] == null) {\\n                root.next[c - \\'a\\'] = new TrieNode();\\n            }\\n            \\n            /**\\n                check and mark if part of string is a palindrome.\\n            **/\\n            if(isPalindrome(word, 0, i)) root.list.add(wordIdx);\\n            root = root.next[c - \\'a\\'];\\n        }\\n        \\n        root.index = wordIdx;\\n    }\\n    \\n    /**\\n        Search takes, O(m^2) amortized time.\\n    **/\\n    public List<List<Integer>> search(TrieNode root, String word, int wordIdx) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        /** \\n            Search part 1 : if the counterparts in Trie are complete words, then check if the unmatched string is a palindore, if it is then             w1 + w2 is a palindorome.\\n        **/\\n        for (int i = 0; i < word.length(); i++) {\\n            if (root.index != -1 && wordIdx != root.index && isPalindrome(word, i, word.length() - 1)) {\\n                res.add(Arrays.asList(wordIdx, root.index));\\n            }\\n            \\n            char c = word.charAt(i);\\n            root = root.next[c - \\'a\\'];\\n            if (root == null) return res;\\n        }\\n        \\n        /**\\n            Search part 2 : if w1 (current search word) is completely matched, see if there is any other word that is complete, if yes w2 is\\n            the reverse of w1 and therefore w1 + w2 is a plaindrome.\\n        **/\\n        if (root.index != wordIdx && root.index != -1) {\\n            res.add(Arrays.asList(wordIdx, root.index));\\n        }\\n        \\n        /** \\n            If w1 is completely matched and if there are any words that are larger than w1 and matched completely and have the rest of the               string as a palindrome then w1 + w2 will be a plaindrome.\\n        **/\\n        for (Integer k : root.list) {\\n            res.add(Arrays.asList(wordIdx, k));\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private boolean isPalindrome(String word, int s, int e) {\\n        while(s < e && word.charAt(s) == word.charAt(e)) {\\n            s++;\\n            e--;\\n        }\\n        \\n        return s >= e;\\n    }\\n    \\n    /**\\n        Time complexity : O(n * m^2).\\n        Space Complexity : O(n * m).\\n    **/\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        TrieNode root = new TrieNode();\\n        \\n        /**\\n            addWord is invoked O(n) number of times, therefore it takes O(n * m^2) Time.\\n        **/\\n        for(int i = 0; i < words.length; i++) {\\n            addWord(root, words[i], i);\\n        }\\n        \\n        /**\\n            Search is invoked O(n) times, it takes O(n * m^2) worse case time.\\n        **/\\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = 0; i < words.length; i++) {\\n            res.addAll(search(root, words[i], i));\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585699,
                "title": "python-with-comments",
                "content": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = dict()\\n        self.end = False\\n        self.idx = -1\\n        self.palindromeIdxs = list()\\n\\nclass Solution:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        res = list()\\n        \\n        # populate the trie with\\n        # the reverse of every word.\\n        # once we\\'re done inserting\\n        # we\\'re going to have 3 conditions\\n        for i in range(len(words)):\\n            cur = self.root\\n            rWord = words[i][::-1]\\n            for j in range(len(rWord)):\\n                # if the current word (from j onwards)\\n                # is a palindrome, add it\\'s index to the trie node\\n                # (palindromIdx list) we\\'ll use it later on to find combinations\\n                if self.isPalindrome(rWord[j:]):\\n                    cur.palindromeIdxs.append(i)\\n                    \\n                if rWord[j] not in cur.children:\\n                    cur.children[rWord[j]] = TrieNode()\\n                cur = cur.children[rWord[j]]\\n                \\n            # once the word is done\\n            # add it\\'s index to the trie node\\n            cur.end = True\\n            cur.idx = i\\n            \\n        for i in range(len(words)):\\n            self.search(words[i], i, res)\\n            \\n        return res\\n        \\n    # to find all pairse, we can have\\n    # conditions:\\n    # 1. exact match (abc, cba)\\n    # 2. long word, short word in trie match (abbcc, a)\\n    # 3. short word, long word in trie match (lls, sssll)\\n    def search(self, word, idx, res):   \\n        cur = self.root\\n        for i in range(len(word)):\\n            # 2. long word, short trie\\n            # so the trie ended here and \\n            # we have matched till the ith\\n            # character, so we check if the\\n            # remaining of the word is also a\\n            # palindrome, if yes, then we have a pair\\n            # for e.g. word = abcdaa, trieWord = bcda\\n            # we can make a pair like abcdaabcda\\n            if cur.end and self.isPalindrome(word[i:]):\\n                res.append([idx, cur.idx])\\n                \\n            if word[i] not in cur.children:\\n                return\\n            cur = cur.children[word[i]]        \\n        \\n        # 1. exact match\\n        # in the given list, for that \\n        # we\\'ll take every word and then\\n        # check if the reverse of that\\n        # word lies in the trie\\n        # for e.g. for abc and cba\\n        # the trie would have both c->b->a and a->b->c\\n        # but when we take the first word (abc)\\n        # we\\'ll match this with a->b->c which is\\n        # actually cba and so we found a match\\n        if cur.end and cur.idx != idx:\\n            res.append([cur.idx, idx])\\n        \\n        # 3. long trie, short word\\n        # so the trie still has items (not cur.end)\\n        # and the word has ended, it\\'s the exact\\n        # opposite of point 2\\n        # for e.g. word=abcd trieWord=bcdaa\\n        # we can have a pair bcdaaabcd\\n        # and so we have a pair\\n        for pIdx in cur.palindromeIdxs:\\n            res.append([idx, pIdx])\\n                \\n        return\\n        \\n        \\n    def isPalindrome(self, s):\\n        return s == s[::-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = dict()\\n        self.end = False\\n        self.idx = -1\\n        self.palindromeIdxs = list()\\n\\nclass Solution:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        res = list()\\n        \\n        # populate the trie with\\n        # the reverse of every word.\\n        # once we\\'re done inserting\\n        # we\\'re going to have 3 conditions\\n        for i in range(len(words)):\\n            cur = self.root\\n            rWord = words[i][::-1]\\n            for j in range(len(rWord)):\\n                # if the current word (from j onwards)\\n                # is a palindrome, add it\\'s index to the trie node\\n                # (palindromIdx list) we\\'ll use it later on to find combinations\\n                if self.isPalindrome(rWord[j:]):\\n                    cur.palindromeIdxs.append(i)\\n                    \\n                if rWord[j] not in cur.children:\\n                    cur.children[rWord[j]] = TrieNode()\\n                cur = cur.children[rWord[j]]\\n                \\n            # once the word is done\\n            # add it\\'s index to the trie node\\n            cur.end = True\\n            cur.idx = i\\n            \\n        for i in range(len(words)):\\n            self.search(words[i], i, res)\\n            \\n        return res\\n        \\n    # to find all pairse, we can have\\n    # conditions:\\n    # 1. exact match (abc, cba)\\n    # 2. long word, short word in trie match (abbcc, a)\\n    # 3. short word, long word in trie match (lls, sssll)\\n    def search(self, word, idx, res):   \\n        cur = self.root\\n        for i in range(len(word)):\\n            # 2. long word, short trie\\n            # so the trie ended here and \\n            # we have matched till the ith\\n            # character, so we check if the\\n            # remaining of the word is also a\\n            # palindrome, if yes, then we have a pair\\n            # for e.g. word = abcdaa, trieWord = bcda\\n            # we can make a pair like abcdaabcda\\n            if cur.end and self.isPalindrome(word[i:]):\\n                res.append([idx, cur.idx])\\n                \\n            if word[i] not in cur.children:\\n                return\\n            cur = cur.children[word[i]]        \\n        \\n        # 1. exact match\\n        # in the given list, for that \\n        # we\\'ll take every word and then\\n        # check if the reverse of that\\n        # word lies in the trie\\n        # for e.g. for abc and cba\\n        # the trie would have both c->b->a and a->b->c\\n        # but when we take the first word (abc)\\n        # we\\'ll match this with a->b->c which is\\n        # actually cba and so we found a match\\n        if cur.end and cur.idx != idx:\\n            res.append([cur.idx, idx])\\n        \\n        # 3. long trie, short word\\n        # so the trie still has items (not cur.end)\\n        # and the word has ended, it\\'s the exact\\n        # opposite of point 2\\n        # for e.g. word=abcd trieWord=bcdaa\\n        # we can have a pair bcdaaabcd\\n        # and so we have a pair\\n        for pIdx in cur.palindromeIdxs:\\n            res.append([idx, pIdx])\\n                \\n        return\\n        \\n        \\n    def isPalindrome(self, s):\\n        return s == s[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585670,
                "title": "swift-ten-liner-no-tries-no-tle",
                "content": "[Click here for TRIE approach](https://leetcode.com/problems/palindrome-pairs/discuss/2589342/Swift-or-Trie)\\n\\n**Very compact solution, 10 SLOC (accepted answer)**\\n```\\nclass Solution {\\n    func palindromePairs(_ words: [String]) -> [[Int]] {        \\n        func isPalindrome(_ word:[Character], _ front:Int, _ back:Int) -> Bool {\\n            for (a,b) in zip(front...back, (front...back).reversed()) where word[a] != word[b] || a >= b { return a >= b }\\n            return true // will never get here\\n        }\\n\\n        let lookup = words.enumerated().reduce(into: [[Character]:Int]()) { $0[Array($1.1)] = $1.0 }\\n        return lookup.reduce(into: (result: [[Int]](), sizes: Set(lookup.keys.map { $0.count }))) { data, tuple in let (word, index) = tuple\\n            data.result += [lookup[word.reversed()]].compactMap{$0}.filter{$0 != index}.map{[index,$0]}\\n            data.result += word.indices.filter { data.sizes.contains(word.count-$0-1) && isPalindrome(word, 0, $0) }.compactMap { lookup[word[($0+1)..<word.count].reversed()] }.filter{$0 != index}.map{[$0, index]}\\n            data.result += word.indices.filter { data.sizes.contains($0) && isPalindrome(word, $0, word.count-1)}.compactMap { lookup[word[0..<$0].reversed()] }.filter { $0 != index}.map{[index,$0]}\\n        }.result\\n    }\\n}\\n```\\n\\n---\\nThis is a difficult problem for Swift, since the heavy-load test cases create TLE without optimization. The optimization is to create a set of input word sizes and only check palindromes if there is a word of that size available, this cut down the work and changed outcome from TLE to Accepted Answer.\\n\\n**More optimized approach (accepted answer, NO TLE)**\\n```\\nclass Solution {\\n    func palindromePairs(_ words: [String]) -> [[Int]] {\\n        let lookup = words.enumerated().reduce(into: [[Character]:Int]()) { $0[Array($1.1)] = $1.0 }\\n        let lookupHashed = lookup.reduce(into: [Int:Int]()) { $0[Array($1.key.reversed()).hashValue] = $1.value }\\n        let lookupKeySizes = Set(lookup.keys.map { $0.count })\\n        var result = [[Int]]()\\n        \\n        func isValidPalindrome(_ word:[Character], _ front:Int, _ back:Int) -> Bool {\\n            for (a,b) in zip(front...back, (front...back).reversed()) where word[a] != word[b] || a >= b { return a >= b }\\n            return true // will never get here\\n        }\\n        \\n        func validPrefixes(_ word:[Character]) -> [Int] {\\n            var result = [Int]()\\n            for i in word.indices where lookupKeySizes.contains(i) && isValidPalindrome(word, i, word.count-1) {\\n                if let otherIndex = lookupHashed[word[0..<i].hashValue] {\\n                    result.append(otherIndex)\\n                }\\n            }\\n            return result\\n        }\\n\\n        func validSuffixes(_ word:[Character]) -> [Int] {   \\n            var result = [Int]()\\n            for i in word.indices where lookupKeySizes.contains(word.count-i-1) && isValidPalindrome(word, 0, i) {\\n                if let otherIndex = lookupHashed[word[(i+1)..<word.count].hashValue] {\\n                    result.append(otherIndex)\\n                }\\n            }\\n            return result\\n        }\\n        \\n        for (word, index) in lookup {\\n            if let otherIndex = lookupHashed[word.hashValue], index != otherIndex {\\n                result.append([index, otherIndex])\\n            }\\n            \\n            for suffix in validSuffixes(word) where suffix != index {\\n                result.append([suffix, index])\\n            }\\n            \\n            for prefix in validPrefixes(word) where prefix != index {\\n                result.append([index, prefix])\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func palindromePairs(_ words: [String]) -> [[Int]] {        \\n        func isPalindrome(_ word:[Character], _ front:Int, _ back:Int) -> Bool {\\n            for (a,b) in zip(front...back, (front...back).reversed()) where word[a] != word[b] || a >= b { return a >= b }\\n            return true // will never get here\\n        }\\n\\n        let lookup = words.enumerated().reduce(into: [[Character]:Int]()) { $0[Array($1.1)] = $1.0 }\\n        return lookup.reduce(into: (result: [[Int]](), sizes: Set(lookup.keys.map { $0.count }))) { data, tuple in let (word, index) = tuple\\n            data.result += [lookup[word.reversed()]].compactMap{$0}.filter{$0 != index}.map{[index,$0]}\\n            data.result += word.indices.filter { data.sizes.contains(word.count-$0-1) && isPalindrome(word, 0, $0) }.compactMap { lookup[word[($0+1)..<word.count].reversed()] }.filter{$0 != index}.map{[$0, index]}\\n            data.result += word.indices.filter { data.sizes.contains($0) && isPalindrome(word, $0, word.count-1)}.compactMap { lookup[word[0..<$0].reversed()] }.filter { $0 != index}.map{[index,$0]}\\n        }.result\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func palindromePairs(_ words: [String]) -> [[Int]] {\\n        let lookup = words.enumerated().reduce(into: [[Character]:Int]()) { $0[Array($1.1)] = $1.0 }\\n        let lookupHashed = lookup.reduce(into: [Int:Int]()) { $0[Array($1.key.reversed()).hashValue] = $1.value }\\n        let lookupKeySizes = Set(lookup.keys.map { $0.count })\\n        var result = [[Int]]()\\n        \\n        func isValidPalindrome(_ word:[Character], _ front:Int, _ back:Int) -> Bool {\\n            for (a,b) in zip(front...back, (front...back).reversed()) where word[a] != word[b] || a >= b { return a >= b }\\n            return true // will never get here\\n        }\\n        \\n        func validPrefixes(_ word:[Character]) -> [Int] {\\n            var result = [Int]()\\n            for i in word.indices where lookupKeySizes.contains(i) && isValidPalindrome(word, i, word.count-1) {\\n                if let otherIndex = lookupHashed[word[0..<i].hashValue] {\\n                    result.append(otherIndex)\\n                }\\n            }\\n            return result\\n        }\\n\\n        func validSuffixes(_ word:[Character]) -> [Int] {   \\n            var result = [Int]()\\n            for i in word.indices where lookupKeySizes.contains(word.count-i-1) && isValidPalindrome(word, 0, i) {\\n                if let otherIndex = lookupHashed[word[(i+1)..<word.count].hashValue] {\\n                    result.append(otherIndex)\\n                }\\n            }\\n            return result\\n        }\\n        \\n        for (word, index) in lookup {\\n            if let otherIndex = lookupHashed[word.hashValue], index != otherIndex {\\n                result.append([index, otherIndex])\\n            }\\n            \\n            for suffix in validSuffixes(word) where suffix != index {\\n                result.append([suffix, index])\\n            }\\n            \\n            for prefix in validPrefixes(word) where prefix != index {\\n                result.append([index, prefix])\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585645,
                "title": "js-two-approaches-with-explanation-easy-to-understand",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/09/336-palindrome-pairs.html\\nIt is very useful, and I just wanted to share it with you.\\nNote: You can bookmark it as a resource, and for another approaches\\n<br>\\n\\n```\\n/**\\n * @param {string[]} words\\n * @return {number[][]}\\n */\\nvar palindromePairs = function(words) {\\n    let word_map = new Map(), ans = []\\n    for (let i = 0; i < words.length; i++)\\n        word_map.set(words[i], i)\\n    for (let i = 0; i < words.length; i++) {\\n        if (words[i] === \"\") {\\n            for (let j = 0; j < words.length; j++)\\n                if (is_Palindrome(words[j]) && j !== i)\\n                    ans.push([i, j], [j, i])\\n            continue\\n        }\\n        let reverse_str = words[i].split(\"\").reverse().join(\"\")\\n        let res = word_map.get(reverse_str)\\n        if (res !== undefined && res !== i)\\n            ans.push([i, res])\\n        for (let j = 1; j < reverse_str.length; j++) {\\n            if (is_Palindrome(reverse_str, 0, j - 1)) {\\n                let res = word_map.get(reverse_str.slice(j))\\n                if (res !== undefined)\\n                    ans.push([i, res])\\n            }\\n            if (is_Palindrome(reverse_str, j)) {\\n                let res = word_map.get(reverse_str.slice(0,j))\\n                if (res !== undefined)\\n                    ans.push([res, i])\\n            }\\n        }\\n    }\\n    return ans\\n};\\n\\n//check if a word is palindrome\\nconst is_Palindrome = (word, i=0, j=word.length-1) => {\\n    while (i < j)\\n        if (word[i++] !== word[j--]) return false\\n    return true\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {number[][]}\\n */\\nvar palindromePairs = function(words) {\\n    let word_map = new Map(), ans = []\\n    for (let i = 0; i < words.length; i++)\\n        word_map.set(words[i], i)\\n    for (let i = 0; i < words.length; i++) {\\n        if (words[i] === \"\") {\\n            for (let j = 0; j < words.length; j++)\\n                if (is_Palindrome(words[j]) && j !== i)\\n                    ans.push([i, j], [j, i])\\n            continue\\n        }\\n        let reverse_str = words[i].split(\"\").reverse().join(\"\")\\n        let res = word_map.get(reverse_str)\\n        if (res !== undefined && res !== i)\\n            ans.push([i, res])\\n        for (let j = 1; j < reverse_str.length; j++) {\\n            if (is_Palindrome(reverse_str, 0, j - 1)) {\\n                let res = word_map.get(reverse_str.slice(j))\\n                if (res !== undefined)\\n                    ans.push([i, res])\\n            }\\n            if (is_Palindrome(reverse_str, j)) {\\n                let res = word_map.get(reverse_str.slice(0,j))\\n                if (res !== undefined)\\n                    ans.push([res, i])\\n            }\\n        }\\n    }\\n    return ans\\n};\\n\\n//check if a word is palindrome\\nconst is_Palindrome = (word, i=0, j=word.length-1) => {\\n    while (i < j)\\n        if (word[i++] !== word[j--]) return false\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2585571,
                "title": "c-tle-and-barely-passing-solution-with-some-explaination-xd",
                "content": "\\n```\\nstd::vector<std::vector<int>> palindromePairs(std::vector<std::string>& words) {\\n\\tconst int n = words.size();\\n\\tstd::vector<std::vector<int>> result;\\n\\tstd::unordered_map<std::string, int> map_;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tmap_[words[i]] = i;\\n\\t}\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tint left = 0, right = 0;\\n\\t\\twhile (left <= right) {\\n\\t\\t\\tstd::string temp = words[i].substr(left, right - left);\\n\\t\\t\\tstd::reverse(temp.begin(), temp.end());\\n\\t\\t\\tstd::string valid_substr = words[i].substr(left == 0 ? right : 0, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   left == 0 ? words[i].size() - right : left);\\n\\t\\t\\tif (map_.count(temp) && i != map_[temp] && isValid(valid_substr)) {\\n\\t\\t\\t\\tif (left == 0) {\\n\\t\\t\\t\\t\\tresult.push_back({i, map_[temp]});\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\telse result.push_back({map_[temp], i});\\n\\t\\t\\t}\\n\\t\\t\\tif (right < words[i].size()) {\\n\\t\\t\\t\\tright++;\\n\\t\\t\\t} \\n\\t\\t\\telse left++;\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\nbool isValid(std::string temp) {\\n\\tconst int n = temp.size();\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tif (temp[i] != temp[n - 1 - i]) return false;\\n\\t}\\n\\treturn true;\\n}\\n```\\n```\\nTime Limit Exceeded, 134 / 136 test cases passed. \\n```\\n\\n```\\nstd::vector<std::vector<int>> palindromePairs(std::vector<std::string>& words) {\\n\\tconst int n = words.size();\\n\\tstd::vector<std::vector<int>> result;\\n\\tstd::unordered_map<std::string, int> map_;\\n\\tstd::set<int> set_;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tmap_[words[i]] = i;\\n\\t\\tset_.insert(words[i].size());\\n\\t}\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tstd::string temp = words[i];\\n\\t\\tint len = temp.size();\\n\\t\\tstd::reverse(temp.begin(), temp.end());\\n\\t\\tif (map_.count(temp) && map_[temp] != i) {\\n\\t\\t\\tresult.push_back({i, map_[temp]});\\n\\t\\t}\\n\\t\\tauto a = set_.find(len);\\n\\t\\tfor (auto it = set_.begin(); it != a; it++) {\\n\\t\\t\\tint d = *it;\\n\\t\\t\\tif (isValid(temp, 0, len - d - 1) && map_.count(temp.substr(len - d))) {\\n\\t\\t\\t\\tresult.push_back({i, map_[temp.substr(len - d)]});\\n\\t\\t\\t}\\n\\t\\t\\tif (isValid(temp, d, len - 1) && map_.count(temp.substr(0, d))) {\\n\\t\\t\\t\\tresult.push_back({map_[temp.substr(0, d)], i});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\nbool isValid(std::string temp, int left, int right) {\\n\\twhile (left < right) {\\n\\t\\tif (temp[left++] != temp[right--]) return false;\\n\\t}\\n\\treturn true;\\n}\\n```\\n```\\nRuntime: 1464 ms, faster than 61.31% of C++ online submissions for Palindrome Pairs.\\nMemory Usage: 361.5 MB, less than 56.87% of C++ online submissions for Palindrome Pairs.\\n```\\n\\n### **336. Palindrome Pairs**\\n- This question gives us a list of unique words, and let us find out all the palindrome pairs.\\n- As everyone does? I first tried to brute force it, just pick every two words, concatenate them together and check if that combination satisfy the definition of palindrome, but of course it exceeded the time limit as expected, since this is a HARD question.\\n- The thought process of the code would be like:\\n- I. Initialization\\n  - (1) First, we use a hash table ```std::unordered_map<std::string, int> map_``` to establish the mapping of each word and its position.\\n  - (2) Then we need a set ```std::set<int> set_``` to save the length of the words that have appeared.\\n- II. Algorithm\\n  - (1) The idea is to traverse the word set and for each traversed words, we flip them ```std::reverse(temp.begin(), temp.end())```, and then check whether the flipped string exists in the hash table ```if (map_.count(temp) && map_[temp] != i)```. \\n    - Note that if the position of the flipped word is the same as the original one, then we cannot take that one into account, \\n    - since there might be in some situations that the flipped word would still be the same, like abba, codedoc, ...\\n  - (2) Up to now, we only deal with the simpliest case like bat and tab. There\\'re cases like \"abcd\" and \"cba\", \"dcb\" and \"abcd\" that also need to be considered. \\n    - And that\\'s why we need an additional ```std::set``` to help us figure this out.\\n  - (3) Given that ```std::set``` is a sorted container, we can find the iterator in the set that indicates the current word length ```auto a = set_.find(len)```\\n  - (4) Then we go through the set from the beginning till the point that it shares the same length as the current word, that is, traversing all the lengths that are smaller than the current word. \\n    - For instance, \"abcdd\" is \"ddcba\" after flipping, suppose we find that in the set there are words with length of 3, \\n    - then we check if \"dd\" is a palindrome string, \\n    - if so, then we further check if \"cba\" exists in the hash table, \\n    - if so, which means \"abcdd\" and \"cba\" are palindrome pairs. \\n    - And we stored the pair into result. \\n    - The string we hope to find in the word set should be tried on the left ```if (isValid(temp, d, len - 1) && map_.count(temp.substr(0, d)))``` and right ```if (isValid(temp, 0, len - d - 1) && map_.count(temp.substr(len - d)))``` sides of the traversed string, see if it is a palindrome pair \\n  - (5) After traversing the whole word set, we can get all the palindrome pairs, I think\\n- You might feel a little bit confused, because I did a terrible job at explaining all this\\n- After typing out some of my thoughts, I suddenly realize that I\\'m actually not 100% sure what I\\'m doing, since I cannot explain it like crystal clear\\n- Hope you think it\\'s helpful\\n- Sorry for the poor English and the poor explaination\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstd::vector<std::vector<int>> palindromePairs(std::vector<std::string>& words) {\\n\\tconst int n = words.size();\\n\\tstd::vector<std::vector<int>> result;\\n\\tstd::unordered_map<std::string, int> map_;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tmap_[words[i]] = i;\\n\\t}\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tint left = 0, right = 0;\\n\\t\\twhile (left <= right) {\\n\\t\\t\\tstd::string temp = words[i].substr(left, right - left);\\n\\t\\t\\tstd::reverse(temp.begin(), temp.end());\\n\\t\\t\\tstd::string valid_substr = words[i].substr(left == 0 ? right : 0, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   left == 0 ? words[i].size() - right : left);\\n\\t\\t\\tif (map_.count(temp) && i != map_[temp] && isValid(valid_substr)) {\\n\\t\\t\\t\\tif (left == 0) {\\n\\t\\t\\t\\t\\tresult.push_back({i, map_[temp]});\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\telse result.push_back({map_[temp], i});\\n\\t\\t\\t}\\n\\t\\t\\tif (right < words[i].size()) {\\n\\t\\t\\t\\tright++;\\n\\t\\t\\t} \\n\\t\\t\\telse left++;\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\nbool isValid(std::string temp) {\\n\\tconst int n = temp.size();\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tif (temp[i] != temp[n - 1 - i]) return false;\\n\\t}\\n\\treturn true;\\n}\\n```\n```\\nTime Limit Exceeded, 134 / 136 test cases passed. \\n```\n```\\nstd::vector<std::vector<int>> palindromePairs(std::vector<std::string>& words) {\\n\\tconst int n = words.size();\\n\\tstd::vector<std::vector<int>> result;\\n\\tstd::unordered_map<std::string, int> map_;\\n\\tstd::set<int> set_;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tmap_[words[i]] = i;\\n\\t\\tset_.insert(words[i].size());\\n\\t}\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tstd::string temp = words[i];\\n\\t\\tint len = temp.size();\\n\\t\\tstd::reverse(temp.begin(), temp.end());\\n\\t\\tif (map_.count(temp) && map_[temp] != i) {\\n\\t\\t\\tresult.push_back({i, map_[temp]});\\n\\t\\t}\\n\\t\\tauto a = set_.find(len);\\n\\t\\tfor (auto it = set_.begin(); it != a; it++) {\\n\\t\\t\\tint d = *it;\\n\\t\\t\\tif (isValid(temp, 0, len - d - 1) && map_.count(temp.substr(len - d))) {\\n\\t\\t\\t\\tresult.push_back({i, map_[temp.substr(len - d)]});\\n\\t\\t\\t}\\n\\t\\t\\tif (isValid(temp, d, len - 1) && map_.count(temp.substr(0, d))) {\\n\\t\\t\\t\\tresult.push_back({map_[temp.substr(0, d)], i});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\nbool isValid(std::string temp, int left, int right) {\\n\\twhile (left < right) {\\n\\t\\tif (temp[left++] != temp[right--]) return false;\\n\\t}\\n\\treturn true;\\n}\\n```\n```\\nRuntime: 1464 ms, faster than 61.31% of C++ online submissions for Palindrome Pairs.\\nMemory Usage: 361.5 MB, less than 56.87% of C++ online submissions for Palindrome Pairs.\\n```\n```std::unordered_map<std::string, int> map_```\n```std::set<int> set_```\n```std::reverse(temp.begin(), temp.end())```\n```if (map_.count(temp) && map_[temp] != i)```\n```std::set```\n```std::set```\n```auto a = set_.find(len)```\n```if (isValid(temp, d, len - 1) && map_.count(temp.substr(0, d)))```\n```if (isValid(temp, 0, len - d - 1) && map_.count(temp.substr(len - d)))```",
                "codeTag": "Unknown"
            },
            {
                "id": 2585481,
                "title": "recent-accepted-solutions",
                "content": "```\\n class Solution {\\n public:\\n     vector<vector<int>> palindromePairs(vector<string>& words) {\\n         unordered_map<string, int> dict;\\n         vector<vector<int>> ans;\\n         // build dictionary\\n         for(int i = 0; i < words.size(); i++) {\\n             string key = words[i];\\n             reverse(key.begin(), key.end());\\n             dict[key] = i;\\n         }\\n         // edge case: if empty string \"\" exists, find all palindromes to become pairs (\"\", self)\\n         if(dict.find(\"\")!=dict.end()){\\n             for(int i = 0; i < words.size(); i++){\\n                 if(i == dict[\"\"]) continue;\\n                 if(isPalindrome(words[i])) ans.push_back({dict[\"\"], i}); // 1) if self is palindrome, here ans covers concatenate(\"\", self) \\n             }\\n         }\\n\\n         for(int i = 0; i < words.size(); i++) {\\n             for(int j = 0; j < words[i].size(); j++) {\\n                 string left = words[i].substr(0, j);\\n                 string right = words[i].substr(j, words[i].size() - j);\\n\\n                 if(dict.find(left) != dict.end() && isPalindrome(right) && dict[left] != i) {\\n                     ans.push_back({i, dict[left]});     // 2) when j = 0, left = \"\", right = self, so here covers concatenate(self, \"\")\\n                 }\\n\\n                 if(dict.find(right) != dict.end() && isPalindrome(left) && dict[right] != i) {\\n                     ans.push_back({dict[right], i});\\n                 }\\n             }\\n         }\\n\\n         return ans;        \\n     }\\n\\n     bool isPalindrome(string str){\\n         int i = 0;\\n         int j = str.size() - 1; \\n\\n         while(i < j) {\\n             if(str[i++] != str[j--]) return false;\\n         }\\n\\n         return true;\\n     }\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\n class Solution {\\n public:\\n     vector<vector<int>> palindromePairs(vector<string>& words) {\\n         unordered_map<string, int> dict;\\n         vector<vector<int>> ans;\\n         // build dictionary\\n         for(int i = 0; i < words.size(); i++) {\\n             string key = words[i];\\n             reverse(key.begin(), key.end());\\n             dict[key] = i;\\n         }\\n         // edge case: if empty string \"\" exists, find all palindromes to become pairs (\"\", self)\\n         if(dict.find(\"\")!=dict.end()){\\n             for(int i = 0; i < words.size(); i++){\\n                 if(i == dict[\"\"]) continue;\\n                 if(isPalindrome(words[i])) ans.push_back({dict[\"\"], i}); // 1) if self is palindrome, here ans covers concatenate(\"\", self) \\n             }\\n         }\\n\\n         for(int i = 0; i < words.size(); i++) {\\n             for(int j = 0; j < words[i].size(); j++) {\\n                 string left = words[i].substr(0, j);\\n                 string right = words[i].substr(j, words[i].size() - j);\\n\\n                 if(dict.find(left) != dict.end() && isPalindrome(right) && dict[left] != i) {\\n                     ans.push_back({i, dict[left]});     // 2) when j = 0, left = \"\", right = self, so here covers concatenate(self, \"\")\\n                 }\\n\\n                 if(dict.find(right) != dict.end() && isPalindrome(left) && dict[right] != i) {\\n                     ans.push_back({dict[right], i});\\n                 }\\n             }\\n         }\\n\\n         return ans;        \\n     }\\n\\n     bool isPalindrome(string str){\\n         int i = 0;\\n         int j = str.size() - 1; \\n\\n         while(i < j) {\\n             if(str[i++] != str[j--]) return false;\\n         }\\n\\n         return true;\\n     }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585413,
                "title": "java-accepted-solution",
                "content": "```\\n\\npublic class Solution {\\npublic List<List<Integer>> palindromePairs(String[] words) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tHashMap<String, Integer> hm = new HashMap<>();\\n\\n\\t\\t// put all the words in HashMap for easy look-up\\n\\t\\tfor (int i = 0; i < words.length; i++) {\\n\\t\\t\\thm.put(words[i], i);\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < words.length; i++) {\\n\\t\\t\\tString reverse = new StringBuilder(words[i]).reverse().toString();\\n\\n\\t\\t\\t// check if there is reverse word present\\n\\t\\t\\tif (hm.containsKey(reverse) && hm.get(reverse) != i) {\\n\\t\\t\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\t\\t\\tlist.add(i);\\n\\t\\t\\t\\tlist.add(hm.get(reverse));\\n\\t\\t\\t\\tresult.add(list);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// check if there is empty string\\n\\t\\t\\t// in that case if word is palindrome, empty string can be added\\n\\t\\t\\t// before and after the word.\\n\\t\\t\\tif (hm.containsKey(\"\")\\n\\t\\t\\t\\t\\t&& hm.get(\"\") != i\\n\\t\\t\\t\\t\\t&& new StringBuilder(words[i]).reverse().toString()\\n\\t\\t\\t\\t\\t\\t\\t.equals(words[i])) {\\n\\t\\t\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\t\\t\\tlist.add(i);\\n\\t\\t\\t\\tlist.add(hm.get(\"\"));\\n\\t\\t\\t\\tresult.add(list);\\n\\t\\t\\t\\tlist = new ArrayList<>();\\n\\t\\t\\t\\tlist.add(hm.get(\"\"));\\n\\t\\t\\t\\tlist.add(i);\\n\\t\\t\\t\\tresult.add(list);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// check if some other word can be added as prefix\\n\\t\\t\\tint curReverse = 0;\\n\\t\\t\\twhile (curReverse < reverse.length() - 1) {\\n\\t\\t\\t\\tif (hm.containsKey(reverse.substring(0, curReverse + 1))) {\\n\\t\\t\\t\\t\\tString rem = words[i].substring(0, words[i].length()\\n\\t\\t\\t\\t\\t\\t\\t- curReverse - 1);\\n\\t\\t\\t\\t\\tif (new StringBuilder(rem).reverse().toString().equals(rem)) {\\n\\t\\t\\t\\t\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\t\\t\\t\\t\\tlist.add(hm.get(reverse.substring(0, curReverse + 1)));\\n\\t\\t\\t\\t\\t\\tlist.add(i);\\n\\t\\t\\t\\t\\t\\tresult.add(list);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcurReverse++;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// check if some other word can be added as suffix\\n\\t\\t\\tint curForward = 0;\\n\\t\\t\\twhile (curForward < words[i].length() - 1) {\\n\\t\\t\\t\\tString rev = new StringBuilder(words[i].substring(0,\\n\\t\\t\\t\\t\\t\\tcurForward + 1)).reverse().toString();\\n\\t\\t\\t\\tif (hm.containsKey(rev)) {\\n\\t\\t\\t\\t\\tString rem = words[i].substring(curForward + 1);\\n\\t\\t\\t\\t\\tif (new StringBuilder(rem).reverse().toString().equals(rem)) {\\n\\t\\t\\t\\t\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\t\\t\\t\\t\\tlist.add(i);\\n\\t\\t\\t\\t\\t\\tlist.add(hm.get(rev));\\n\\t\\t\\t\\t\\t\\tresult.add(list);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcurForward++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\npublic class Solution {\\npublic List<List<Integer>> palindromePairs(String[] words) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tHashMap<String, Integer> hm = new HashMap<>();\\n\\n\\t\\t// put all the words in HashMap for easy look-up\\n\\t\\tfor (int i = 0; i < words.length; i++) {\\n\\t\\t\\thm.put(words[i], i);\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < words.length; i++) {\\n\\t\\t\\tString reverse = new StringBuilder(words[i]).reverse().toString();\\n\\n\\t\\t\\t// check if there is reverse word present\\n\\t\\t\\tif (hm.containsKey(reverse) && hm.get(reverse) != i) {\\n\\t\\t\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\t\\t\\tlist.add(i);\\n\\t\\t\\t\\tlist.add(hm.get(reverse));\\n\\t\\t\\t\\tresult.add(list);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// check if there is empty string\\n\\t\\t\\t// in that case if word is palindrome, empty string can be added\\n\\t\\t\\t// before and after the word.\\n\\t\\t\\tif (hm.containsKey(\"\")\\n\\t\\t\\t\\t\\t&& hm.get(\"\") != i\\n\\t\\t\\t\\t\\t&& new StringBuilder(words[i]).reverse().toString()\\n\\t\\t\\t\\t\\t\\t\\t.equals(words[i])) {\\n\\t\\t\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\t\\t\\tlist.add(i);\\n\\t\\t\\t\\tlist.add(hm.get(\"\"));\\n\\t\\t\\t\\tresult.add(list);\\n\\t\\t\\t\\tlist = new ArrayList<>();\\n\\t\\t\\t\\tlist.add(hm.get(\"\"));\\n\\t\\t\\t\\tlist.add(i);\\n\\t\\t\\t\\tresult.add(list);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// check if some other word can be added as prefix\\n\\t\\t\\tint curReverse = 0;\\n\\t\\t\\twhile (curReverse < reverse.length() - 1) {\\n\\t\\t\\t\\tif (hm.containsKey(reverse.substring(0, curReverse + 1))) {\\n\\t\\t\\t\\t\\tString rem = words[i].substring(0, words[i].length()\\n\\t\\t\\t\\t\\t\\t\\t- curReverse - 1);\\n\\t\\t\\t\\t\\tif (new StringBuilder(rem).reverse().toString().equals(rem)) {\\n\\t\\t\\t\\t\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\t\\t\\t\\t\\tlist.add(hm.get(reverse.substring(0, curReverse + 1)));\\n\\t\\t\\t\\t\\t\\tlist.add(i);\\n\\t\\t\\t\\t\\t\\tresult.add(list);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcurReverse++;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// check if some other word can be added as suffix\\n\\t\\t\\tint curForward = 0;\\n\\t\\t\\twhile (curForward < words[i].length() - 1) {\\n\\t\\t\\t\\tString rev = new StringBuilder(words[i].substring(0,\\n\\t\\t\\t\\t\\t\\tcurForward + 1)).reverse().toString();\\n\\t\\t\\t\\tif (hm.containsKey(rev)) {\\n\\t\\t\\t\\t\\tString rem = words[i].substring(curForward + 1);\\n\\t\\t\\t\\t\\tif (new StringBuilder(rem).reverse().toString().equals(rem)) {\\n\\t\\t\\t\\t\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\t\\t\\t\\t\\tlist.add(i);\\n\\t\\t\\t\\t\\t\\tlist.add(hm.get(rev));\\n\\t\\t\\t\\t\\t\\tresult.add(list);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcurForward++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2582718,
                "title": "python-time-o-n-w-w-intuition-to-solution-comments",
                "content": "```\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        # Intuition\\n        \\n        # From example 1: [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]\\n        # abcd -> look for reversed string: dcba. If exist, then:\\n        # we have 2 results: \"abcd-dcba\" or \"dcba-abdc\"\\n        \\n        # From example 3: [\"a\",\"\"]\\n        # a is parlindrome => look for empty string. If exist, then:\\n        # we have 2 results: empty + \"a\" or \"a\" + empty\\n        \\n        # Because words are unique, there is no such a case like this:\\n        # word is parlindrome and its reversed version exist.\\n        # \"aa\" at index 0, reverse \"aa\" at index 1.\\n        \\n        # back to example 1: for word lls\\n        # we know that \"lls\" and \"s\" create a solution\\n        # because:\\n        # \"s\" + \"lls\" -> is a parlindrome\\n        #          | the last s match with string \"s\"\\n        #          | and ll is parlindrome.\\n        # From this, we can defind a search like this:\\n        # if we see \"lls\", we split \"lls\" into 2 parts: left and right\\n        # for example: left = ll = is parlindrome, right = \"s\"\\n        # we will look for reversed of right to make the solution like this:\\n        # reversed + left + right = \"s\" + \"ll\" + \"s\"\\n        \\n        # if left is not parlindrome, but right, like:\\n        # word = \"lsll\", split -> left = \"ls\", right = \"ll\"\\n        # then we will look for reversed of left, and solution is:\\n        # left + right + reversed = \"ls\" + \"ll\" + \"sl\"\\n        \\n        # So basically, we have to cover 3 cases.\\n        # To make searching the reversed string fast, \\n        # we will store word in a hash map: word -> index\\n        # Lets to to implementation.\\n        \\n        # Create hash map to store word -> index\\n        word2index = {w:i for i, w in enumerate(words)}\\n        \\n        res = []\\n        for i, w  in enumerate(words):  # O(N) time\\n            if w == \"\":\\n                continue\\n                \\n            # Process case 1: abcd & dcba\\n            re_w = w[::-1]\\n            if re_w in word2index and word2index[re_w] != i:\\n                res.append((i, word2index[re_w]))\\n                \\n            # process case 2: \"aa\" and \"\"\\n            if w == w[::-1] and \"\" in word2index:\\n                res.append((i, word2index[\"\"]))\\n                res.append((word2index[\"\"], i))\\n\\n            # process case 3: \"lls\" and \"s\" or \"lsll\" and \"sl\"\\n            for s in range(len(w) - 1):  # O(W) time\\n                left, right = w[:s+1], w[s+1:]\\n\\n                re_w = right[::-1]  # O(W) time\\n                if left == left[::-1] and re_w in word2index:\\n                    res.append((word2index[re_w], i))\\n\\n                re_w = left[::-1]\\n                if right == right[::-1] and re_w in word2index:\\n                    res.append((i, word2index[re_w]))\\n                    \\n        # Space: O(N)\\n        # Time: O(N*W*W), W is the average word size\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        # Intuition\\n        \\n        # From example 1: [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]\\n        # abcd -> look for reversed string: dcba. If exist, then:\\n        # we have 2 results: \"abcd-dcba\" or \"dcba-abdc\"\\n        \\n        # From example 3: [\"a\",\"\"]\\n        # a is parlindrome => look for empty string. If exist, then:\\n        # we have 2 results: empty + \"a\" or \"a\" + empty\\n        \\n        # Because words are unique, there is no such a case like this:\\n        # word is parlindrome and its reversed version exist.\\n        # \"aa\" at index 0, reverse \"aa\" at index 1.\\n        \\n        # back to example 1: for word lls\\n        # we know that \"lls\" and \"s\" create a solution\\n        # because:\\n        # \"s\" + \"lls\" -> is a parlindrome\\n        #          | the last s match with string \"s\"\\n        #          | and ll is parlindrome.\\n        # From this, we can defind a search like this:\\n        # if we see \"lls\", we split \"lls\" into 2 parts: left and right\\n        # for example: left = ll = is parlindrome, right = \"s\"\\n        # we will look for reversed of right to make the solution like this:\\n        # reversed + left + right = \"s\" + \"ll\" + \"s\"\\n        \\n        # if left is not parlindrome, but right, like:\\n        # word = \"lsll\", split -> left = \"ls\", right = \"ll\"\\n        # then we will look for reversed of left, and solution is:\\n        # left + right + reversed = \"ls\" + \"ll\" + \"sl\"\\n        \\n        # So basically, we have to cover 3 cases.\\n        # To make searching the reversed string fast, \\n        # we will store word in a hash map: word -> index\\n        # Lets to to implementation.\\n        \\n        # Create hash map to store word -> index\\n        word2index = {w:i for i, w in enumerate(words)}\\n        \\n        res = []\\n        for i, w  in enumerate(words):  # O(N) time\\n            if w == \"\":\\n                continue\\n                \\n            # Process case 1: abcd & dcba\\n            re_w = w[::-1]\\n            if re_w in word2index and word2index[re_w] != i:\\n                res.append((i, word2index[re_w]))\\n                \\n            # process case 2: \"aa\" and \"\"\\n            if w == w[::-1] and \"\" in word2index:\\n                res.append((i, word2index[\"\"]))\\n                res.append((word2index[\"\"], i))\\n\\n            # process case 3: \"lls\" and \"s\" or \"lsll\" and \"sl\"\\n            for s in range(len(w) - 1):  # O(W) time\\n                left, right = w[:s+1], w[s+1:]\\n\\n                re_w = right[::-1]  # O(W) time\\n                if left == left[::-1] and re_w in word2index:\\n                    res.append((word2index[re_w], i))\\n\\n                re_w = left[::-1]\\n                if right == right[::-1] and re_w in word2index:\\n                    res.append((i, word2index[re_w]))\\n                    \\n        # Space: O(N)\\n        # Time: O(N*W*W), W is the average word size\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2418633,
                "title": "accepted-trie",
                "content": "Submitting the code with comments but submitting without comments accepts successfully!\\nHere there is one assumption that there is no duplicates\\n![image](https://assets.leetcode.com/users/images/94665d70-da9a-4dac-91de-646c7302241d_1660377577.6314101.jpeg)\\n\\nThe third one was with comments\\n```\\n\\tstruct TrieNode{ // storing the index of word at the end of last character instead of boolean endofWord\\n        TrieNode* child[26];\\n        int index;\\n        TrieNode(){\\n            for(int i =  0;i<26;i++)\\n                child[i] = NULL;\\n            index = -1;\\n        }\\n    };\\n    \\n    TrieNode *root;\\n    \\n    void insert(string &w,int &idx){\\n        TrieNode *p = root;\\n        for(auto ch:w){\\n            if(!p->child[ch-\\'a\\'])\\n                p->child[ch-\\'a\\'] = new TrieNode();\\n            p = p->child[ch-\\'a\\'];\\n        }\\n        p->index = idx;\\n    }\\n    \\n    //searching for words in the trie according to their indice(in reverse manner and both strt and end included) and i will store the index of the matched string\\n    // Eg - w = \"abcdc\",strt = 0,end = 1\\n    // We will find the string \"ba\" in the trie\\n    bool search(string &w,int strt,int end,int &i){\\n        TrieNode *p = root;\\n        for(;end>=strt;end--){\\n            char ch = w[end];\\n            if(!p->child[ch-\\'a\\'])\\n                return false;\\n            p = p->child[ch-\\'a\\'];\\n        }\\n        i = p->index;\\n        return p->index!=-1;\\n    }\\n    \\n    // checking whether the w[i:j] string is palindrome or not\\n    // (Here also i and j included)\\n    bool ispalin(string &w,int i,int j)\\n    {\\n        while(i<j)\\n            if(w[i++]!=w[j--])\\n                return false;\\n        return true;\\n    }    \\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        root = new TrieNode();\\n        for(int i = 0;i<words.size();i++)\\n            insert(words[i],i);\\n        \\n        vector<vector<int>>ans;\\n        \\n        // checking if there exists \"\", so every palindrome word will form a pair with it\\n        // Eg - \"abcba\",\"\" , here {1,0} and {0,1} will be inserted\\n        if(root->index!=-1) // if(\"\" exists in our vector of strings)\\n            for(int j = 0;j<words.size();j++)\\n                if(j!=root->index && ispalin(words[j],0,words[j].length()-1)){\\n                    ans.push_back({root->index,j});\\n                    ans.push_back({j,root->index});\\n                }\\n        \\n         for(int i = 0; i < words.size(); i++) {\\n             for(int j = 1; j <= words[i].length(); j++) {\\n                 // partitioning the the word to two strings left and right\\n                 // left part has indice 0,...,leftright (0 and leftright included)\\n                 // right part has indice j,...,rightright (j and rightright included)\\n                 int leftright = j-1;\\n                 int rightright = words[i].length()-1;\\n                 int temp;\\n                 // if we found the reverse of left and right part is palindrome\\n                 if(search(words[i],0,leftright,temp) && ispalin(words[i],j,rightright) && temp != i) {\\n                     ans.push_back({i, temp});     // 2) when j = 0, left = \"\", right = self, so here covers concatenate(self, \"\")\\n                 }\\n                 \\n                 // if j is words[i].length(), than right part is empty string \"\",which is already tackled in previous part\\n                 if(j==words[i].length())continue;\\n                 \\n                 // if left part is palindrome and we found the reverse of right part of string\\n                 if(search(words[i],j,rightright,temp) && ispalin(words[i],0,leftright) && temp != i) {\\n                     ans.push_back({temp, i});\\n                 }\\n             }\\n         }\\n         return ans;        \\n     }\\n```\\n\\nThe below code is without comments, this was easily accepted in each submission\\n```\\n\\tstruct TrieNode{\\n        TrieNode* child[26];\\n        int index;\\n        TrieNode(){\\n            for(int i =  0;i<26;i++)\\n                child[i] = NULL;\\n            index = -1;\\n        }\\n    };\\n    \\n    TrieNode *root;\\n    \\n    void insert(string &w,int &idx){\\n        TrieNode *p = root;\\n        for(auto ch:w){\\n            if(!p->child[ch-\\'a\\'])\\n                p->child[ch-\\'a\\'] = new TrieNode();\\n            p = p->child[ch-\\'a\\'];\\n        }\\n        p->index = idx;\\n    }\\n    \\n    bool search(string &w,int strt,int end,int &i){\\n        TrieNode *p = root;\\n        for(;end>=strt;end--){\\n            char ch = w[end];\\n            if(!p->child[ch-\\'a\\'])\\n                return false;\\n            p = p->child[ch-\\'a\\'];\\n        }\\n        i = p->index;\\n        return p->index!=-1;\\n    }\\n    \\n    bool ispalin(string &w,int i,int j)\\n    {\\n        while(i<j)\\n            if(w[i++]!=w[j--])\\n                return false;\\n        return true;\\n    }    \\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        root = new TrieNode();\\n        for(int i = 0;i<words.size();i++)\\n            insert(words[i],i);\\n        \\n        vector<vector<int>>ans;\\n        \\n        if(root->index!=-1)\\n            for(int j = 0;j<words.size();j++)\\n                if(j!=root->index && ispalin(words[j],0,words[j].length()-1)){\\n                    ans.push_back({root->index,j});\\n                    ans.push_back({j,root->index});\\n                }\\n        \\n         for(int i = 0; i < words.size(); i++)\\n             for(int j = 1; j <= words[i].length(); j++) {\\n                 int leftright = j-1;\\n                 int rightright = words[i].length()-1;\\n                 int temp;\\n                 \\n                 if(search(words[i],0,leftright,temp) && ispalin(words[i],j,rightright) && temp != i) \\n                     ans.push_back({i, temp});\\n                 \\n                 if(j==words[i].length())continue;\\n                 if(search(words[i],j,rightright,temp) && ispalin(words[i],0,leftright) && temp != i) \\n                     ans.push_back({temp, i});\\n                 \\n             }\\n         \\n         return ans;        \\n     }",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\n\\tstruct TrieNode{ // storing the index of word at the end of last character instead of boolean endofWord\\n        TrieNode* child[26];\\n        int index;\\n        TrieNode(){\\n            for(int i =  0;i<26;i++)\\n                child[i] = NULL;\\n            index = -1;\\n        }\\n    };\\n    \\n    TrieNode *root;\\n    \\n    void insert(string &w,int &idx){\\n        TrieNode *p = root;\\n        for(auto ch:w){\\n            if(!p->child[ch-\\'a\\'])\\n                p->child[ch-\\'a\\'] = new TrieNode();\\n            p = p->child[ch-\\'a\\'];\\n        }\\n        p->index = idx;\\n    }\\n    \\n    //searching for words in the trie according to their indice(in reverse manner and both strt and end included) and i will store the index of the matched string\\n    // Eg - w = \"abcdc\",strt = 0,end = 1\\n    // We will find the string \"ba\" in the trie\\n    bool search(string &w,int strt,int end,int &i){\\n        TrieNode *p = root;\\n        for(;end>=strt;end--){\\n            char ch = w[end];\\n            if(!p->child[ch-\\'a\\'])\\n                return false;\\n            p = p->child[ch-\\'a\\'];\\n        }\\n        i = p->index;\\n        return p->index!=-1;\\n    }\\n    \\n    // checking whether the w[i:j] string is palindrome or not\\n    // (Here also i and j included)\\n    bool ispalin(string &w,int i,int j)\\n    {\\n        while(i<j)\\n            if(w[i++]!=w[j--])\\n                return false;\\n        return true;\\n    }    \\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        root = new TrieNode();\\n        for(int i = 0;i<words.size();i++)\\n            insert(words[i],i);\\n        \\n        vector<vector<int>>ans;\\n        \\n        // checking if there exists \"\", so every palindrome word will form a pair with it\\n        // Eg - \"abcba\",\"\" , here {1,0} and {0,1} will be inserted\\n        if(root->index!=-1) // if(\"\" exists in our vector of strings)\\n            for(int j = 0;j<words.size();j++)\\n                if(j!=root->index && ispalin(words[j],0,words[j].length()-1)){\\n                    ans.push_back({root->index,j});\\n                    ans.push_back({j,root->index});\\n                }\\n        \\n         for(int i = 0; i < words.size(); i++) {\\n             for(int j = 1; j <= words[i].length(); j++) {\\n                 // partitioning the the word to two strings left and right\\n                 // left part has indice 0,...,leftright (0 and leftright included)\\n                 // right part has indice j,...,rightright (j and rightright included)\\n                 int leftright = j-1;\\n                 int rightright = words[i].length()-1;\\n                 int temp;\\n                 // if we found the reverse of left and right part is palindrome\\n                 if(search(words[i],0,leftright,temp) && ispalin(words[i],j,rightright) && temp != i) {\\n                     ans.push_back({i, temp});     // 2) when j = 0, left = \"\", right = self, so here covers concatenate(self, \"\")\\n                 }\\n                 \\n                 // if j is words[i].length(), than right part is empty string \"\",which is already tackled in previous part\\n                 if(j==words[i].length())continue;\\n                 \\n                 // if left part is palindrome and we found the reverse of right part of string\\n                 if(search(words[i],j,rightright,temp) && ispalin(words[i],0,leftright) && temp != i) {\\n                     ans.push_back({temp, i});\\n                 }\\n             }\\n         }\\n         return ans;        \\n     }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2368380,
                "title": "faster-than-100-00-easiest-python-solution",
                "content": "```\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        result = []\\n        \\n        # Store all words and reversals.\\n        ws = []\\n        for i, word in enumerate(words):\\n            ws.append((word,       False, i, len(word)))\\n            ws.append((word[::-1], True,  i, len(word)))\\n        ws.sort()\\n        \\n        for i, (a, a_reversed, a_idx, a_len) in enumerate(ws):\\n            for j in range(i + 1, len(ws)):\\n                b, b_reversed, b_idx, _ = ws[j]\\n                if b.startswith(a):\\n                    if a_idx != b_idx and a_reversed != b_reversed:\\n                        rest = b[a_len:]\\n                        if rest == rest[::-1]: \\n                            result.append([a_idx, b_idx] if b_reversed else [b_idx, a_idx])\\n                else:\\n                    break\\n        return result\\n```\\n![image](https://assets.leetcode.com/users/images/28885b32-9324-4a5f-90db-f7de792e0f5f_1659427793.9880486.png)\\n```\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        result = []\\n        \\n        # Store all words and reversals.\\n        ws = []\\n        for i, word in enumerate(words):\\n            ws.append((word,       False, i, len(word)))\\n            ws.append((word[::-1], True,  i, len(word)))\\n        ws.sort()\\n        \\n        for i, (a, a_reversed, a_idx, a_len) in enumerate(ws):\\n            for j in range(i + 1, len(ws)):\\n                b, b_reversed, b_idx, _ = ws[j]\\n                if b.startswith(a):\\n                    if a_idx != b_idx and a_reversed != b_reversed:\\n                        rest = b[a_len:]\\n                        if rest == rest[::-1]: \\n                            result.append([a_idx, b_idx] if b_reversed else [b_idx, a_idx])\\n                else:\\n                    break\\n        return result\\n```\n```\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2174302,
                "title": "c-concise-solution-with-hashing-o-n-k-2-no-tle",
                "content": "```\\nclass Solution {\\npublic:\\n    std::vector<std::vector<int>> palindromePairs(std::vector<std::string> & words)\\n    {\\n        std::vector<std::string> storage;  // Storage for unordered_map that using string_view: can be avoided with C++20 heterogeneous lookup\\n        storage.reserve(std::size(words));\\n        for (auto & word : words)\\n            storage.emplace_back(std::rbegin(word), std::rend(word));\\n        \\n        // Put reversed words with their indices to the dictionary\\n        std::unordered_map<std::string_view, int> m;\\n        for (int i = 0; i < std::size(storage); ++i)\\n            m[storage[i]] = i;\\n\\n        std::vector<std::vector<int>> result;\\n        for (int i = 0; i < std::size(words); ++i)\\n            if (!std::empty(words[i]))            \\n                for (int j = 0; j <= std::size(words[i]); ++j)\\n                {\\n                    const std::string_view left { words[i].c_str(), (size_t)j };\\n                    const std::string_view right { words[i].c_str() + j };\\n\\n                    auto it = m.find(left);\\n                    if (it != std::end(m) && it->second != i && std::equal(std::begin(right), std::begin(right) + (std::size(right) >> 1), std::rbegin(right)))\\n                        result.emplace_back(std::vector<int> { i, it->second });\\n\\n                    it = m.find(right);\\n                    if (it != std::end(m) && it->second != i && j && std::equal(std::begin(left), std::begin(left) + (std::size(left) >> 1), std::rbegin(left)))\\n                        result.emplace_back(std::vector<int> { it->second, i });\\n                }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    std::vector<std::vector<int>> palindromePairs(std::vector<std::string> & words)\\n    {\\n        std::vector<std::string> storage;  // Storage for unordered_map that using string_view: can be avoided with C++20 heterogeneous lookup\\n        storage.reserve(std::size(words));\\n        for (auto & word : words)\\n            storage.emplace_back(std::rbegin(word), std::rend(word));\\n        \\n        // Put reversed words with their indices to the dictionary\\n        std::unordered_map<std::string_view, int> m;\\n        for (int i = 0; i < std::size(storage); ++i)\\n            m[storage[i]] = i;\\n\\n        std::vector<std::vector<int>> result;\\n        for (int i = 0; i < std::size(words); ++i)\\n            if (!std::empty(words[i]))            \\n                for (int j = 0; j <= std::size(words[i]); ++j)\\n                {\\n                    const std::string_view left { words[i].c_str(), (size_t)j };\\n                    const std::string_view right { words[i].c_str() + j };\\n\\n                    auto it = m.find(left);\\n                    if (it != std::end(m) && it->second != i && std::equal(std::begin(right), std::begin(right) + (std::size(right) >> 1), std::rbegin(right)))\\n                        result.emplace_back(std::vector<int> { i, it->second });\\n\\n                    it = m.find(right);\\n                    if (it != std::end(m) && it->second != i && j && std::equal(std::begin(left), std::begin(left) + (std::size(left) >> 1), std::rbegin(left)))\\n                        result.emplace_back(std::vector<int> { it->second, i });\\n                }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170666,
                "title": "time-limit-to-accpeted-solution-code-in-cpp",
                "content": "**Logic**\\n\\n```\\n1) First of all, as in the output we need to return indices corresponding to the\\n possible candidates,so it is very clear that we need to have mapping between\\n word and its index.\\n\\n2 Now, Each string can be divided at particular index into two substrings,\\nfirst is prefix string and second is suffix string,\\nwe first check whether prefix string is a palindrome and if so then there\\nis a possibility that by using this prefix string,we can form a new palindrome.\\n\\nSo, to check whether the palindrome can be formed using prefix string,we need to check \\nwhether the reverse of suffix string is present in the map or not.\\nAnd same goes for the case when we try suffix string as the possible candidate for palindrome.\\n\\n3) If for prefix string , the reverse suffix string\\'s index is different \\n    as of the current string,then we are sure that we found a pair of palindromic strings.\\n\\n4) If for suffix string , the reverse prefix string\\'s index is different \\n    as of the current string, \\n5) then we are sure that we found another pair of palindromic strings.\\n```\\n\\n**Shwoing time limit exceeded can you please help**\\n\\n```\\nclass Solution {\\nprivate:\\n\\tbool isPalin(string &s) {\\n\\t\\tint i = 0, j = s.size() - 1;\\n\\t\\twhile (i < j) {\\n\\t\\t\\tif (s[i] != s[j]) return false;\\n\\t\\t\\ti++, j--;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\npublic:\\n\\tvector<vector<int>> palindromePairs(vector<string>& words) {\\n\\t\\tvector<vector<int>> ans;\\n\\t\\tint n = words.size();\\n        if(n<2) return ans;\\n\\t\\tunordered_map<string, int> m;\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tstring s = words[i];\\n\\t\\t\\treverse(s.begin(), s.end());\\n\\t\\t\\tm[s] = i;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < n; ++i)\\n\\t\\t\\tfor (int j = 0; j <= words[i].size(); ++j) {\\n\\t\\t\\t\\tstring prefix = words[i].substr(0, j);\\n\\t\\t\\t\\tstring suffix = words[i].substr(j);\\n\\t\\t\\t\\tif (isPalin(suffix) && m.count(prefix) && m[prefix] != i) ans.push_back({ i,m[prefix]});\\n\\t\\t\\t\\tif (!prefix.empty() && isPalin(prefix) && m.count(suffix) && m[suffix] != i) ans.push_back({m[suffix], i});\\n\\t\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\\n\\n**Accepted code same logic others code**\\n```\\nclass Solution {\\n    bool is_palindrome(string_view const& s) {\\n        int last = s.size() - 1;\\n        for (int i = 0; i < last-i; ++i) {\\n            if (s[i] != s[last-i]) return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        unordered_map<string_view,int> data;\\n        const int m = words.size();\\n        for (int i = 0; i < m; ++i) {\\n            data[words[i]] = i;\\n        }\\n        vector<vector<int>> result;\\n        for (int i = 0; i < m; ++i) {\\n            string word = words[i];\\n            const int n = word.size();\\n            reverse(word.begin(), word.end());\\n            string_view word_view(word);\\n            \\n            for (int j = 0; j <= n; ++j) {\\n                auto it = data.find(word_view.substr(0, j));\\n                if (it != data.end() && it->second != i && is_palindrome(word_view.substr(j))) {\\n                    result.push_back({it->second, i});\\n                }\\n            }\\n            for (int j = 0; j < n; ++j) {\\n                auto it = data.find(word_view.substr(n-j, j));\\n                if (it != data.end() && is_palindrome(word_view.substr(0, n-j))) {\\n                    result.push_back({i, it->second});\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n\\n**Please feel free to ask questions and please upvote thank you happy coding**",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\n1) First of all, as in the output we need to return indices corresponding to the\\n possible candidates,so it is very clear that we need to have mapping between\\n word and its index.\\n\\n2 Now, Each string can be divided at particular index into two substrings,\\nfirst is prefix string and second is suffix string,\\nwe first check whether prefix string is a palindrome and if so then there\\nis a possibility that by using this prefix string,we can form a new palindrome.\\n\\nSo, to check whether the palindrome can be formed using prefix string,we need to check \\nwhether the reverse of suffix string is present in the map or not.\\nAnd same goes for the case when we try suffix string as the possible candidate for palindrome.\\n\\n3) If for prefix string , the reverse suffix string\\'s index is different \\n    as of the current string,then we are sure that we found a pair of palindromic strings.\\n\\n4) If for suffix string , the reverse prefix string\\'s index is different \\n    as of the current string, \\n5) then we are sure that we found another pair of palindromic strings.\\n```\n```\\nclass Solution {\\nprivate:\\n\\tbool isPalin(string &s) {\\n\\t\\tint i = 0, j = s.size() - 1;\\n\\t\\twhile (i < j) {\\n\\t\\t\\tif (s[i] != s[j]) return false;\\n\\t\\t\\ti++, j--;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\npublic:\\n\\tvector<vector<int>> palindromePairs(vector<string>& words) {\\n\\t\\tvector<vector<int>> ans;\\n\\t\\tint n = words.size();\\n        if(n<2) return ans;\\n\\t\\tunordered_map<string, int> m;\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tstring s = words[i];\\n\\t\\t\\treverse(s.begin(), s.end());\\n\\t\\t\\tm[s] = i;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < n; ++i)\\n\\t\\t\\tfor (int j = 0; j <= words[i].size(); ++j) {\\n\\t\\t\\t\\tstring prefix = words[i].substr(0, j);\\n\\t\\t\\t\\tstring suffix = words[i].substr(j);\\n\\t\\t\\t\\tif (isPalin(suffix) && m.count(prefix) && m[prefix] != i) ans.push_back({ i,m[prefix]});\\n\\t\\t\\t\\tif (!prefix.empty() && isPalin(prefix) && m.count(suffix) && m[suffix] != i) ans.push_back({m[suffix], i});\\n\\t\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\n```\\nclass Solution {\\n    bool is_palindrome(string_view const& s) {\\n        int last = s.size() - 1;\\n        for (int i = 0; i < last-i; ++i) {\\n            if (s[i] != s[last-i]) return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        unordered_map<string_view,int> data;\\n        const int m = words.size();\\n        for (int i = 0; i < m; ++i) {\\n            data[words[i]] = i;\\n        }\\n        vector<vector<int>> result;\\n        for (int i = 0; i < m; ++i) {\\n            string word = words[i];\\n            const int n = word.size();\\n            reverse(word.begin(), word.end());\\n            string_view word_view(word);\\n            \\n            for (int j = 0; j <= n; ++j) {\\n                auto it = data.find(word_view.substr(0, j));\\n                if (it != data.end() && it->second != i && is_palindrome(word_view.substr(j))) {\\n                    result.push_back({it->second, i});\\n                }\\n            }\\n            for (int j = 0; j < n; ++j) {\\n                auto it = data.find(word_view.substr(n-j, j));\\n                if (it != data.end() && is_palindrome(word_view.substr(0, n-j))) {\\n                    result.push_back({i, it->second});\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2129904,
                "title": "c-tried-3-ways-tle-to-80-less-time",
                "content": "1. using map.\\nit is not passing last two test-cases that are very big in size and gives TLE.\\n\\nSo, next tried Trie based approach\\n\\n```\\nclass Solution {\\n    bool isPalindrome(string &word){\\n        int i=0, j=word.size()-1;\\n        while(i<j){\\n            if(word[i]==word[j]){\\n                i++; j--;\\n            }else return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        vector<vector<int>> ans;\\n        const int n = words.size();\\n        unordered_map<string,int> m;\\n        \\n        for(int i=0;i<n;i++){\\n            m.insert({words[i],i});   \\n            reverse(words[i].begin(), words[i].end());//it will reverse all words permanently. let it be. we will deal them accordingly.\\n        }\\n        \\n        //1. empty str + palindromic str\\n        int blankIdx;\\n        if(m.find(\"\")!=m.end()){\\n            blankIdx=m[\"\"];\\n            for(int i=0;i<n;i++){\\n                if(i!=blankIdx && isPalindrome(words[i])){\\n                    ans.push_back({i,blankIdx});//{\"\",\"aba\"}-->gives two ans 1. {1,0} and other {0,1}. 2nd one woll handle in below general scenario.\\n                }\\n            }\\n        }\\n        \\n        //2. word(left+right) and reverse of other word making palindrome. ex->{aabd, db} gives dbaabd\\n        string left, right;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<words[i].length();j++){\\n                left=words[i].substr(0,j);\\n                right=words[i].substr(j);\\n                \\n                if(m.find(right)!=m.end() && m[right]!=i && isPalindrome(left)) ans.push_back({i,m[right]});\\n                if(m.find(left)!=m.end() && m[left]!=i && isPalindrome(right)) ans.push_back({m[left],i});\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n\\n2. I tried trie based approach. it better then first one\\nalthough it is not optimised one. first it concatenates the string then checking is it palindrome or not. apart this, there are many things that can be improved like various big datatypes are passed by value in each function call.\\n\\nstill giving TLE. So, optimised it in almost all possible ways in 3rd solution.\\n```\\nclass Solution {\\n    class node{\\n        public:\\n        int idx;\\n        unordered_map<char,node*> m;\\n        node(int x=-1){\\n            idx=x;\\n        }\\n    };\\n    void insert(string &word, node *root, int idx){\\n        for(int i=0;i<word.length();i++){\\n            if(root->m.find(word[i])!= root->m.end()){//present in trie\\n                root = root->m[word[i]];\\n            }else{\\n                root->m[word[i]] = new node();\\n                root = root->m[word[i]];\\n            }\\n        }\\n        root->idx = idx;\\n        return;\\n    }\\n    \\n    void getbig(vector<int> & big, node * root){\\n        for(int i=0;i<26;i++){//try every possible char\\n            if(root->m.find(\\'a\\'+i)!= root->m.end()){\\n                if(root->m[\\'a\\'+i]->idx!=-1){\\n                    big.push_back(root->m[\\'a\\'+i]->idx);\\n                }\\n                getbig(big, root->m[\\'a\\'+i]);\\n            }\\n        }\\n        return;\\n    }\\n    \\n    void getall(string &word, vector<int> &small, vector<int> & big, int idx, node * root){\\n        for(int i=0;i<word.length();i++){\\n            if(root->m.find(word[i])!= root->m.end()){//present in trie\\n                root = root->m[word[i]];\\n                if(root->idx != -1 && root->idx!=idx){\\n                    small.push_back(root->idx);\\n                }\\n            }else{//not present in trie\\n                return;\\n            }\\n        }\\n        \\n        getbig(big, root);\\n        return;\\n    }\\n    \\n    bool ispal(string & word){\\n        int n=word.length();\\n        if(n==0 || n==1) return true;\\n        n=n-1;\\n        int i=0;\\n        while(i<n){\\n            if(word[i]==word[n]){\\n                i++; n--;\\n            }else return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        vector<vector<int>> ans;\\n        const int n=words.size();\\n        node * root =new node();\\n        \\n        vector<int> p;\\n        int blankIdx=-1;\\n        for(int i=0;i<n;i++){\\n            if(words[i] == \"\"){\\n                blankIdx=i;\\n                continue;\\n            }\\n            string word=words[i];\\n            reverse(begin(word), end(word));\\n            insert(word, root, i);\\n            if(word == words[i]) p.push_back(i);\\n        }\\n        \\n        //1. consider all {\"\", \"aba\"} empty str ans\\n        if(blankIdx!=-1){\\n            for(auto i: p){\\n                ans.push_back({i,blankIdx});\\n                ans.push_back({blankIdx,i});\\n            }\\n        }\\n        \\n        vector<int> big;\\n        vector<int> small;\\n        for(int i=0;i<n;i++){\\n            if(words[i]==\"\") continue;\\n            big.clear();\\n            small.clear();\\n            getall(words[i], small, big, i, root);//gives all valid cases only\\n            string temp;\\n            for(int j=0;j<small.size();j++){\\n                temp = words[i] + words[small[j]];\\n                if(ispal(temp)){\\n                    ans.push_back({i,small[j]});\\n                }\\n            }\\n            for(int j=0;j<big.size();j++){\\n                temp = words[i] + words[big[j]];\\n                if(ispal(temp)){\\n                    ans.push_back({i,big[j]});\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nstill getting TLE\\n3. Now, finally i optimised the 2nd approach in all ways that i found.\\n\\n```\\n\\nclass node{\\n        public:\\n        int idx=-1;\\n        node * m[\\'z\\'-\\'a\\'+1]= {NULL,};\\n    };\\nclass Solution {\\n    vector<vector<int>> ans;\\n    int n=-1;\\n    node * root =new node();\\n    \\n    void insert(string &word, node *root, int idx){\\n        for(int i=0;i<word.length();i++){\\n            if(root->m[word[i]-\\'a\\'] == NULL) root->m[word[i]-\\'a\\'] = new node();\\n            root = root->m[word[i]-\\'a\\'];\\n        }\\n        root->idx = idx;\\n        return;\\n    }\\n    \\n     bool ispal(const string &word){\\n        int end=word.length();\\n        --end;\\n        int s=0;\\n        while(s<end){\\n            if(word[s]!=word[end]) return false;\\n            s++; end--;\\n        }\\n        return true;\\n    }\\n    \\n    void getbig(node * cur, string & t, int idx){\\n        for(int i=0;i<26;i++){//try every possible char\\n            if(cur->m[i] == NULL) continue;\\n            \\n            t.push_back(\\'a\\'+i);\\n            if(cur->m[i]->idx!=-1 && ispal(t)) ans.push_back({idx,cur->m[i]->idx});\\n            getbig(cur->m[i], t, idx);\\n            t.pop_back();\\n        }\\n        return;\\n    }\\n    \\n    void getall(string &word, int idx, node * cur){\\n        for(int i=0;i<word.length();i++){\\n            if(cur->m[word[i]-\\'a\\'] == NULL) return;\\n            //present in trie\\n            cur = cur->m[word[i]-\\'a\\'];\\n            if(cur->idx != -1 && cur->idx!=idx && ((i+1)==word.length() || ispal(word.substr(i+1))))\\n                ans.push_back({idx,cur->idx});\\n        }\\n        string t;\\n        getbig(cur, t, idx);\\n        return;\\n    }\\n    \\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        n=words.size();\\n        vector<int> p;\\n        int blankIdx=-1;\\n        for(int i=0;i<n;i++){\\n            if(words[i] == \"\"){\\n                blankIdx=i;\\n                continue;\\n            }\\n            string word=words[i];\\n            reverse(begin(word), end(word));\\n            insert(word, root, i);\\n            if(word == words[i]) p.push_back(i);\\n        }\\n        \\n        //1. consider all {\"\", \"aba\"} empty str ans\\n        if(blankIdx!=-1){\\n            for(auto i: p){\\n                ans.push_back({i,blankIdx});\\n                ans.push_back({blankIdx,i});\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(words[i]==\"\") continue;\\n            getall(words[i], i, root);//gives all valid cases only\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nFinally, i am happy. it is passing all test cases and beating 80% solutions in time.\\n",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    bool isPalindrome(string &word){\\n        int i=0, j=word.size()-1;\\n        while(i<j){\\n            if(word[i]==word[j]){\\n                i++; j--;\\n            }else return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        vector<vector<int>> ans;\\n        const int n = words.size();\\n        unordered_map<string,int> m;\\n        \\n        for(int i=0;i<n;i++){\\n            m.insert({words[i],i});   \\n            reverse(words[i].begin(), words[i].end());//it will reverse all words permanently. let it be. we will deal them accordingly.\\n        }\\n        \\n        //1. empty str + palindromic str\\n        int blankIdx;\\n        if(m.find(\"\")!=m.end()){\\n            blankIdx=m[\"\"];\\n            for(int i=0;i<n;i++){\\n                if(i!=blankIdx && isPalindrome(words[i])){\\n                    ans.push_back({i,blankIdx});//{\"\",\"aba\"}-->gives two ans 1. {1,0} and other {0,1}. 2nd one woll handle in below general scenario.\\n                }\\n            }\\n        }\\n        \\n        //2. word(left+right) and reverse of other word making palindrome. ex->{aabd, db} gives dbaabd\\n        string left, right;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<words[i].length();j++){\\n                left=words[i].substr(0,j);\\n                right=words[i].substr(j);\\n                \\n                if(m.find(right)!=m.end() && m[right]!=i && isPalindrome(left)) ans.push_back({i,m[right]});\\n                if(m.find(left)!=m.end() && m[left]!=i && isPalindrome(right)) ans.push_back({m[left],i});\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    class node{\\n        public:\\n        int idx;\\n        unordered_map<char,node*> m;\\n        node(int x=-1){\\n            idx=x;\\n        }\\n    };\\n    void insert(string &word, node *root, int idx){\\n        for(int i=0;i<word.length();i++){\\n            if(root->m.find(word[i])!= root->m.end()){//present in trie\\n                root = root->m[word[i]];\\n            }else{\\n                root->m[word[i]] = new node();\\n                root = root->m[word[i]];\\n            }\\n        }\\n        root->idx = idx;\\n        return;\\n    }\\n    \\n    void getbig(vector<int> & big, node * root){\\n        for(int i=0;i<26;i++){//try every possible char\\n            if(root->m.find(\\'a\\'+i)!= root->m.end()){\\n                if(root->m[\\'a\\'+i]->idx!=-1){\\n                    big.push_back(root->m[\\'a\\'+i]->idx);\\n                }\\n                getbig(big, root->m[\\'a\\'+i]);\\n            }\\n        }\\n        return;\\n    }\\n    \\n    void getall(string &word, vector<int> &small, vector<int> & big, int idx, node * root){\\n        for(int i=0;i<word.length();i++){\\n            if(root->m.find(word[i])!= root->m.end()){//present in trie\\n                root = root->m[word[i]];\\n                if(root->idx != -1 && root->idx!=idx){\\n                    small.push_back(root->idx);\\n                }\\n            }else{//not present in trie\\n                return;\\n            }\\n        }\\n        \\n        getbig(big, root);\\n        return;\\n    }\\n    \\n    bool ispal(string & word){\\n        int n=word.length();\\n        if(n==0 || n==1) return true;\\n        n=n-1;\\n        int i=0;\\n        while(i<n){\\n            if(word[i]==word[n]){\\n                i++; n--;\\n            }else return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        vector<vector<int>> ans;\\n        const int n=words.size();\\n        node * root =new node();\\n        \\n        vector<int> p;\\n        int blankIdx=-1;\\n        for(int i=0;i<n;i++){\\n            if(words[i] == \"\"){\\n                blankIdx=i;\\n                continue;\\n            }\\n            string word=words[i];\\n            reverse(begin(word), end(word));\\n            insert(word, root, i);\\n            if(word == words[i]) p.push_back(i);\\n        }\\n        \\n        //1. consider all {\"\", \"aba\"} empty str ans\\n        if(blankIdx!=-1){\\n            for(auto i: p){\\n                ans.push_back({i,blankIdx});\\n                ans.push_back({blankIdx,i});\\n            }\\n        }\\n        \\n        vector<int> big;\\n        vector<int> small;\\n        for(int i=0;i<n;i++){\\n            if(words[i]==\"\") continue;\\n            big.clear();\\n            small.clear();\\n            getall(words[i], small, big, i, root);//gives all valid cases only\\n            string temp;\\n            for(int j=0;j<small.size();j++){\\n                temp = words[i] + words[small[j]];\\n                if(ispal(temp)){\\n                    ans.push_back({i,small[j]});\\n                }\\n            }\\n            for(int j=0;j<big.size();j++){\\n                temp = words[i] + words[big[j]];\\n                if(ispal(temp)){\\n                    ans.push_back({i,big[j]});\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\n\\nclass node{\\n        public:\\n        int idx=-1;\\n        node * m[\\'z\\'-\\'a\\'+1]= {NULL,};\\n    };\\nclass Solution {\\n    vector<vector<int>> ans;\\n    int n=-1;\\n    node * root =new node();\\n    \\n    void insert(string &word, node *root, int idx){\\n        for(int i=0;i<word.length();i++){\\n            if(root->m[word[i]-\\'a\\'] == NULL) root->m[word[i]-\\'a\\'] = new node();\\n            root = root->m[word[i]-\\'a\\'];\\n        }\\n        root->idx = idx;\\n        return;\\n    }\\n    \\n     bool ispal(const string &word){\\n        int end=word.length();\\n        --end;\\n        int s=0;\\n        while(s<end){\\n            if(word[s]!=word[end]) return false;\\n            s++; end--;\\n        }\\n        return true;\\n    }\\n    \\n    void getbig(node * cur, string & t, int idx){\\n        for(int i=0;i<26;i++){//try every possible char\\n            if(cur->m[i] == NULL) continue;\\n            \\n            t.push_back(\\'a\\'+i);\\n            if(cur->m[i]->idx!=-1 && ispal(t)) ans.push_back({idx,cur->m[i]->idx});\\n            getbig(cur->m[i], t, idx);\\n            t.pop_back();\\n        }\\n        return;\\n    }\\n    \\n    void getall(string &word, int idx, node * cur){\\n        for(int i=0;i<word.length();i++){\\n            if(cur->m[word[i]-\\'a\\'] == NULL) return;\\n            //present in trie\\n            cur = cur->m[word[i]-\\'a\\'];\\n            if(cur->idx != -1 && cur->idx!=idx && ((i+1)==word.length() || ispal(word.substr(i+1))))\\n                ans.push_back({idx,cur->idx});\\n        }\\n        string t;\\n        getbig(cur, t, idx);\\n        return;\\n    }\\n    \\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        n=words.size();\\n        vector<int> p;\\n        int blankIdx=-1;\\n        for(int i=0;i<n;i++){\\n            if(words[i] == \"\"){\\n                blankIdx=i;\\n                continue;\\n            }\\n            string word=words[i];\\n            reverse(begin(word), end(word));\\n            insert(word, root, i);\\n            if(word == words[i]) p.push_back(i);\\n        }\\n        \\n        //1. consider all {\"\", \"aba\"} empty str ans\\n        if(blankIdx!=-1){\\n            for(auto i: p){\\n                ans.push_back({i,blankIdx});\\n                ans.push_back({blankIdx,i});\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(words[i]==\"\") continue;\\n            getall(words[i], i, root);//gives all valid cases only\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2120863,
                "title": "c-trie-based-solutions",
                "content": "```\\nclass Solution {\\n    struct Node {\\n        char c;\\n        int idx = -1;\\n        array<Node*, 26> children = {nullptr};\\n        \\n        Node(char c): c(c) {};\\n    };\\n    int empty_idx = -1;\\n    \\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        Node *t = build_trie(words); \\n        vector<vector<int>> ans;\\n        build_answers(t, words, ans);\\n        return ans;\\n    }\\n    \\n    void build_answers(Node const *trie, vector<string> const &words, vector<vector<int>> &ans) {\\n        for (int i=0; i<words.size(); i++) {\\n            // if the prefix can be found and the suffix is a palindrome;\\n            if (words[i] == \"\") continue;\\n            auto t = trie;\\n            int j = 0;\\n            for (j=0; j<words[i].size(); j++) {\\n                if (t->children[words[i][j]-\\'a\\'] == nullptr){\\n                    break;\\n                };\\n                t = t->children[words[i][j]-\\'a\\'];\\n                \\n                if (t->idx != -1) {\\n                    if (t->idx != i && is_palindrome(words[i].substr(j+1, string::npos))) {\\n                        ans.push_back({i, t->idx});\\n                    }\\n                    if (t->idx == i && empty_idx != -1) {\\n                        ans.push_back({i, empty_idx});\\n                        ans.push_back({empty_idx, i});\\n                    }\\n                }\\n            } \\n            \\n            // if the prefix can\\'t be found move on to the next word\\n            if (j < words[i].size()) continue;\\n            \\n            for (auto child : t->children) {\\n                if (!child) continue;\\n                \\n                vector<pair<string, int>> suffixes;\\n                get_suffixes(child, suffixes);\\n                for (auto [suffix, idx] : suffixes) {\\n                    if (is_palindrome(suffix)) {\\n                        ans.push_back({i, idx});\\n                    }\\n                }\\n            }\\n        } \\n    }\\n    \\n    void get_suffixes(Node const *t, vector<pair<string, int>> &suffixes, string const seq = \"\") {\\n        if (t->idx != -1) {\\n            suffixes.emplace_back(seq+t->c, t->idx);\\n        }\\n        for (auto child : t->children) {\\n            if (child) get_suffixes(child, suffixes, seq+t->c); \\n        } \\n    }\\n    \\n    // here we build a prefix tree of reverse words\\n    Node *build_trie(vector<string> const &words) {\\n        Node *ret = new Node(\\'#\\');\\n        for (int n=0; n<words.size(); n++) {\\n            auto t = ret;\\n            if (words[n] == \"\") {\\n                empty_idx = n;\\n                continue;\\n            }\\n            for (int i=words[n].size()-1; i>=0; i--) {\\n                if (t->children[words[n][i]-\\'a\\'] == nullptr) {\\n                    t->children[words[n][i]-\\'a\\'] = new Node(words[n][i]);\\n                }\\n                if (i == 0) {\\n                    t->children[words[n][i]-\\'a\\']->idx = n;\\n                } \\n                t = t->children[words[n][i]-\\'a\\'];\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    bool is_palindrome(string const s) {\\n        int i = 0;\\n        while (i<s.size()/2) {\\n            if (s[i] != s[(s.size()-1)-i]) return false;\\n            i++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    struct Node {\\n        char c;\\n        int idx = -1;\\n        array<Node*, 26> children = {nullptr};\\n        \\n        Node(char c): c(c) {};\\n    };\\n    int empty_idx = -1;\\n    \\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        Node *t = build_trie(words); \\n        vector<vector<int>> ans;\\n        build_answers(t, words, ans);\\n        return ans;\\n    }\\n    \\n    void build_answers(Node const *trie, vector<string> const &words, vector<vector<int>> &ans) {\\n        for (int i=0; i<words.size(); i++) {\\n            // if the prefix can be found and the suffix is a palindrome;\\n            if (words[i] == \"\") continue;\\n            auto t = trie;\\n            int j = 0;\\n            for (j=0; j<words[i].size(); j++) {\\n                if (t->children[words[i][j]-\\'a\\'] == nullptr){\\n                    break;\\n                };\\n                t = t->children[words[i][j]-\\'a\\'];\\n                \\n                if (t->idx != -1) {\\n                    if (t->idx != i && is_palindrome(words[i].substr(j+1, string::npos))) {\\n                        ans.push_back({i, t->idx});\\n                    }\\n                    if (t->idx == i && empty_idx != -1) {\\n                        ans.push_back({i, empty_idx});\\n                        ans.push_back({empty_idx, i});\\n                    }\\n                }\\n            } \\n            \\n            // if the prefix can\\'t be found move on to the next word\\n            if (j < words[i].size()) continue;\\n            \\n            for (auto child : t->children) {\\n                if (!child) continue;\\n                \\n                vector<pair<string, int>> suffixes;\\n                get_suffixes(child, suffixes);\\n                for (auto [suffix, idx] : suffixes) {\\n                    if (is_palindrome(suffix)) {\\n                        ans.push_back({i, idx});\\n                    }\\n                }\\n            }\\n        } \\n    }\\n    \\n    void get_suffixes(Node const *t, vector<pair<string, int>> &suffixes, string const seq = \"\") {\\n        if (t->idx != -1) {\\n            suffixes.emplace_back(seq+t->c, t->idx);\\n        }\\n        for (auto child : t->children) {\\n            if (child) get_suffixes(child, suffixes, seq+t->c); \\n        } \\n    }\\n    \\n    // here we build a prefix tree of reverse words\\n    Node *build_trie(vector<string> const &words) {\\n        Node *ret = new Node(\\'#\\');\\n        for (int n=0; n<words.size(); n++) {\\n            auto t = ret;\\n            if (words[n] == \"\") {\\n                empty_idx = n;\\n                continue;\\n            }\\n            for (int i=words[n].size()-1; i>=0; i--) {\\n                if (t->children[words[n][i]-\\'a\\'] == nullptr) {\\n                    t->children[words[n][i]-\\'a\\'] = new Node(words[n][i]);\\n                }\\n                if (i == 0) {\\n                    t->children[words[n][i]-\\'a\\']->idx = n;\\n                } \\n                t = t->children[words[n][i]-\\'a\\'];\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    bool is_palindrome(string const s) {\\n        int i = 0;\\n        while (i<s.size()/2) {\\n            if (s[i] != s[(s.size()-1)-i]) return false;\\n            i++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934568,
                "title": "java-trie-easy-to-understand-code-explanation",
                "content": "**Explanation:**\\n- We\\'ll not discuss the intuitive approach of O(N^2), where we check every combination of pair of words is a Palindrome or not. Rather we discuss the non-intuitive approach, which I understood from the [Leetcode solution](https://leetcode.com/problems/palindrome-pairs/solution/) that involves Trie.\\n\\n- We build a Trie to store all the words. Because we are interested in the reverse of a word, so we store the words in the Trie after reversing them. This Trie is a special one as each node in the Trie checks if the subsequent characters (i.e. the child nodes of the current Node) till end of the word is a Palindrome or not. \\n\\n- Now comes the search part. Iterate through each character in the word and try to search the same in Trie. If at any point we are not able to find a matching character in Trie then we cannot form a palindrome pair with the current word. Now there are 3 different cases to form a palindrome pairs with the current word - \\n\\t1. Prefix of current word is present in trie & remaining word is a Palindrome\\n\\t2. When mirror image of current word exists in the input list, i.e. Trie contains the exact same word as the current word and is present in a different index\\n\\t3. Suffixes of the current TrieNode are palindromes\\n\\n**Code:**\\n```\\nclass Solution {\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        \\n        Trie trie = new Trie();\\n        int idx = 0;\\n        \\n        // Add all the words in a Trie\\n        for(String word : words){\\n            String reversed = new StringBuilder(word).reverse().toString();\\n            trie.add(reversed, idx++);\\n        }        \\n        \\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        // Search for each word in trie and add them to the list\\n        for(int i=0; i < words.length; i++){\\n            trie.search(words[i], i, result);\\n        }\\n        return result;\\n    }    \\n}\\n\\nclass Trie {\\n    \\n    private TrieNode root;\\n    \\n    Trie(){\\n        this.root = new TrieNode();\\n    }\\n    \\n    // Add words to the trie\\n    public void add(String word, int currWordIdx){\\n        TrieNode currNode = root;\\n        \\n        for(int i=0; i < word.length(); i++){\\n            // If the substring from the ith index is a palindrome, then we add the current index of the word\\n            // to the list of palindromeIdxs for this particular node\\n            if(isRemainingStrPalindrome(word, i))\\n                currNode.palindromeIdxs.add(currWordIdx);\\n            \\n            // Add the current char in Trie if it already doesn\\'t exist\\n            char c = word.charAt(i);\\n            if(!currNode.nodes.containsKey(c))\\n                currNode.nodes.put(c, new TrieNode());\\n            currNode = currNode.nodes.get(c);\\n        }\\n        currNode.wordIdx = currWordIdx;\\n    }\\n    \\n    // Search for pairable Palindromes in Trie with current word and add valid palindrome pairs in the result List\\n    public void search(String word, int currWordIdx, List<List<Integer>> result){\\n        TrieNode currNode = root;\\n        \\n        // Case 1: Prefix of current word is present in trie & remaining word is a Palindrome\\n        // \\n        // Iterate through all the characters in the word and search for the corresponding character in the trie\\n        // - At any point when we don\\'t find the next character in the Trie we break from the loop.\\n        // - If the substring of the word(s1) from the current character is a palindrome, \\n        //   and the current Node forms a word(s2) in the trie, then s1 + s2 is a palindrome\\n        for(int i=0; i < word.length(); i++){            \\n            if(isRemainingStrPalindrome(word, i) && currNode.wordIdx != -1)\\n                result.add(List.of(currWordIdx, currNode.wordIdx));\\n            char c = word.charAt(i);\\n            currNode = currNode.nodes.get(c);\\n            if(currNode == null)\\n                break;\\n        }\\n        \\n        // If we couldn\\'t find a match in the trie, then the current word cannot be paired with any other words to form a palindrome\\n        if(currNode == null)\\n            return;\\n        \\n        // When we have iterated through all the characters in current word and found the same in Trie, \\n        // then only Case 2 & Case 3 will be executed\\n        \\n        // Case 2: When mirror image of current word exists\\n        //\\n        // - When an exact String is present in Trie (i.e. exact reverse of current word) \\n        //   that doesn\\'t match the index of the current word, then the 2 words when concatenated will form a palindrome\\n        if(currNode.wordIdx != -1 && currNode.wordIdx != currWordIdx)\\n            result.add(List.of(currWordIdx, currNode.wordIdx));\\n        \\n        // Case 3: Suffixes of the current Trie Node are palindromes\\n        // \\n        // Because we have come this far, that means current TrieNode char matches with last char in current word\\n        // When there are palindromes from the current TrieNode, the indexes of which we already stored when loading the trie, \\n        // that means if we concatenate the current word with all these words it will also form a palindrome\\n        // Ex - \\n        // String[] words = [\"lls\", \"sssll\", \"sossll\"]\\n        // When current word is \"lls\", since the Trie is storing the words in reverse order, so \"sssll\" will look like this in trie -\\n        //  root -> l -> l -> s -> s -> s\\n        //                    ^     \\\\   \\n        //                           \\\\-> o -> s \\n        // Upto the pointed \"s\", we can match the current word \"lls\", and the remaining String \"ss\" and \"sos\" both are palindromes. \\n        // So if we concatenate current word \"lls\" with \"sssll\" or \"sossll\", they\\'ll form palindromes - \"llssssll\", \"llssossll\"\\n        for(int otherIdx : currNode.palindromeIdxs)\\n            result.add(List.of(currWordIdx, otherIdx));\\n    }\\n    \\n    private boolean isRemainingStrPalindrome(String word, int startIdx){        \\n        for(int i=startIdx, j=word.length()-1; i < j; i++, j--)\\n            if(word.charAt(i) != word.charAt(j))\\n                return false;\\n        return true;\\n    }\\n}\\n\\nclass TrieNode {\\n    Map<Character, TrieNode> nodes = new HashMap<>();\\n    int wordIdx = -1;\\n    List<Integer> palindromeIdxs = new ArrayList<>();\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        \\n        Trie trie = new Trie();\\n        int idx = 0;\\n        \\n        // Add all the words in a Trie\\n        for(String word : words){\\n            String reversed = new StringBuilder(word).reverse().toString();\\n            trie.add(reversed, idx++);\\n        }        \\n        \\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        // Search for each word in trie and add them to the list\\n        for(int i=0; i < words.length; i++){\\n            trie.search(words[i], i, result);\\n        }\\n        return result;\\n    }    \\n}\\n\\nclass Trie {\\n    \\n    private TrieNode root;\\n    \\n    Trie(){\\n        this.root = new TrieNode();\\n    }\\n    \\n    // Add words to the trie\\n    public void add(String word, int currWordIdx){\\n        TrieNode currNode = root;\\n        \\n        for(int i=0; i < word.length(); i++){\\n            // If the substring from the ith index is a palindrome, then we add the current index of the word\\n            // to the list of palindromeIdxs for this particular node\\n            if(isRemainingStrPalindrome(word, i))\\n                currNode.palindromeIdxs.add(currWordIdx);\\n            \\n            // Add the current char in Trie if it already doesn\\'t exist\\n            char c = word.charAt(i);\\n            if(!currNode.nodes.containsKey(c))\\n                currNode.nodes.put(c, new TrieNode());\\n            currNode = currNode.nodes.get(c);\\n        }\\n        currNode.wordIdx = currWordIdx;\\n    }\\n    \\n    // Search for pairable Palindromes in Trie with current word and add valid palindrome pairs in the result List\\n    public void search(String word, int currWordIdx, List<List<Integer>> result){\\n        TrieNode currNode = root;\\n        \\n        // Case 1: Prefix of current word is present in trie & remaining word is a Palindrome\\n        // \\n        // Iterate through all the characters in the word and search for the corresponding character in the trie\\n        // - At any point when we don\\'t find the next character in the Trie we break from the loop.\\n        // - If the substring of the word(s1) from the current character is a palindrome, \\n        //   and the current Node forms a word(s2) in the trie, then s1 + s2 is a palindrome\\n        for(int i=0; i < word.length(); i++){            \\n            if(isRemainingStrPalindrome(word, i) && currNode.wordIdx != -1)\\n                result.add(List.of(currWordIdx, currNode.wordIdx));\\n            char c = word.charAt(i);\\n            currNode = currNode.nodes.get(c);\\n            if(currNode == null)\\n                break;\\n        }\\n        \\n        // If we couldn\\'t find a match in the trie, then the current word cannot be paired with any other words to form a palindrome\\n        if(currNode == null)\\n            return;\\n        \\n        // When we have iterated through all the characters in current word and found the same in Trie, \\n        // then only Case 2 & Case 3 will be executed\\n        \\n        // Case 2: When mirror image of current word exists\\n        //\\n        // - When an exact String is present in Trie (i.e. exact reverse of current word) \\n        //   that doesn\\'t match the index of the current word, then the 2 words when concatenated will form a palindrome\\n        if(currNode.wordIdx != -1 && currNode.wordIdx != currWordIdx)\\n            result.add(List.of(currWordIdx, currNode.wordIdx));\\n        \\n        // Case 3: Suffixes of the current Trie Node are palindromes\\n        // \\n        // Because we have come this far, that means current TrieNode char matches with last char in current word\\n        // When there are palindromes from the current TrieNode, the indexes of which we already stored when loading the trie, \\n        // that means if we concatenate the current word with all these words it will also form a palindrome\\n        // Ex - \\n        // String[] words = [\"lls\", \"sssll\", \"sossll\"]\\n        // When current word is \"lls\", since the Trie is storing the words in reverse order, so \"sssll\" will look like this in trie -\\n        //  root -> l -> l -> s -> s -> s\\n        //                    ^     \\\\   \\n        //                           \\\\-> o -> s \\n        // Upto the pointed \"s\", we can match the current word \"lls\", and the remaining String \"ss\" and \"sos\" both are palindromes. \\n        // So if we concatenate current word \"lls\" with \"sssll\" or \"sossll\", they\\'ll form palindromes - \"llssssll\", \"llssossll\"\\n        for(int otherIdx : currNode.palindromeIdxs)\\n            result.add(List.of(currWordIdx, otherIdx));\\n    }\\n    \\n    private boolean isRemainingStrPalindrome(String word, int startIdx){        \\n        for(int i=startIdx, j=word.length()-1; i < j; i++, j--)\\n            if(word.charAt(i) != word.charAt(j))\\n                return false;\\n        return true;\\n    }\\n}\\n\\nclass TrieNode {\\n    Map<Character, TrieNode> nodes = new HashMap<>();\\n    int wordIdx = -1;\\n    List<Integer> palindromeIdxs = new ArrayList<>();\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921780,
                "title": "simple-javascript-solution-w-comments-trie",
                "content": "```\\n/**\\n * *Time: O(N x M^2)\\n * *Space: O((N + K)^2)\\n */\\n// Runtime: 796 ms, faster than 100.00% of JavaScript online submissions for Palindrome Pairs.\\n// Memory Usage: 128 MB, less than 36.71% of JavaScript online submissions for Palindrome Pairs.\\nconst palindromePairs = words => {\\n\\tconst root = {};\\n\\tconst output = [];\\n\\n\\tconst isPalindrome = word => {\\n\\t\\tlet L = 0;\\n\\t\\tlet R = word.length - 1;\\n\\n\\t\\twhile (L < R) {\\n\\t\\t\\tif (word[L] != word[R]) return false;\\n\\n\\t\\t\\tL++;\\n\\t\\t\\tR--;\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t};\\n\\n\\tconst insertReversed = words => {\\n\\t\\tfor (let i = 0; i < words.length; i++) {\\n\\t\\t\\tconst word = words[i];\\n\\t\\t\\tlet node = root;\\n\\n\\t\\t\\tfor (let j = word.length - 1; j >= 0; j--) {\\n\\t\\t\\t\\tconst char = word[j];\\n\\n\\t\\t\\t\\tif (!node[char]) node[char] = {};\\n\\n\\t\\t\\t\\tnode = node[char];\\n\\t\\t\\t}\\n\\n\\t\\t\\tnode.isEnd = true;\\n\\t\\t\\tnode.index = i;\\n\\t\\t}\\n\\t};\\n\\n\\t// empty string forms palindrome w/ every palindrome in the list\\n\\tconst handleEmptyString = root => {\\n\\t\\tif (root.isEnd) {\\n\\t\\t\\tfor (let i = 0; i < words.length; i++) {\\n\\t\\t\\t\\tconst validPalindrome = isPalindrome(words[i]);\\n\\n\\t\\t\\t\\tif (root.index === i) continue;\\n\\t\\t\\t\\tif (validPalindrome) output.push([i, root.index]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\t// case 2: if word shorter - get last prefix node given the word\\n  // case 3: if word longer - check if suffix is valid palindrome, if not stop\\n\\tconst getLastPrefixNode = (word, i) => {\\n\\t\\tlet node = root;\\n\\n\\t\\tfor (let j = 0; j < word.length; j++) {\\n\\t\\t\\tconst char = word[j];\\n\\t\\t\\tconst child = node[char];\\n\\n\\t\\t\\t// case 3: word is longer\\n\\t\\t\\t// check if rest of the word form valid palindrome\\n\\t\\t\\tif (!child) return;\\n\\t\\t\\tif (child.isEnd && child.index !== i && j < word.length - 1) {\\n\\t\\t\\t\\tconst suffix = word.slice(j + 1);\\n\\t\\t\\t\\tconst validSuffix = isPalindrome(suffix);\\n\\n\\t\\t\\t\\tif (validSuffix) output.push([i, child.index]);\\n\\t\\t\\t}\\n\\n\\t\\t\\tnode = node[char];\\n\\t\\t}\\n\\n\\t\\treturn node;\\n\\t};\\n\\n\\t// starting from lastPrefixNode find valid palindromes AND traverse Trie\\n\\tconst findPalindromes = (node, suffix, i) => {\\n\\t\\t// case 1. same word length\\n\\t\\tif (node.isEnd && node.index !== i) {\\n\\t\\t\\tconst validSuffix = isPalindrome(suffix);\\n\\n\\t\\t\\tif (validSuffix) output.push([i, node.index]);\\n\\t\\t}\\n\\n\\t\\t// case 2. word is shorter\\n\\t\\tfor (const char in node) {\\n\\t\\t\\tfindPalindromes(node[char], suffix + char, i);\\n\\t\\t}\\n\\t};\\n\\n\\tinsertReversed(words);\\n\\thandleEmptyString(root);\\n\\n\\tfor (let i = 0; i < words.length; i++) {\\n\\t\\tconst lastPrefixNode = getLastPrefixNode(words[i], i);\\n\\n\\t\\tif (lastPrefixNode) findPalindromes(lastPrefixNode, \\'\\', i);\\n\\t}\\n\\n\\treturn output;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Trie"
                ],
                "code": "```\\n/**\\n * *Time: O(N x M^2)\\n * *Space: O((N + K)^2)\\n */\\n// Runtime: 796 ms, faster than 100.00% of JavaScript online submissions for Palindrome Pairs.\\n// Memory Usage: 128 MB, less than 36.71% of JavaScript online submissions for Palindrome Pairs.\\nconst palindromePairs = words => {\\n\\tconst root = {};\\n\\tconst output = [];\\n\\n\\tconst isPalindrome = word => {\\n\\t\\tlet L = 0;\\n\\t\\tlet R = word.length - 1;\\n\\n\\t\\twhile (L < R) {\\n\\t\\t\\tif (word[L] != word[R]) return false;\\n\\n\\t\\t\\tL++;\\n\\t\\t\\tR--;\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t};\\n\\n\\tconst insertReversed = words => {\\n\\t\\tfor (let i = 0; i < words.length; i++) {\\n\\t\\t\\tconst word = words[i];\\n\\t\\t\\tlet node = root;\\n\\n\\t\\t\\tfor (let j = word.length - 1; j >= 0; j--) {\\n\\t\\t\\t\\tconst char = word[j];\\n\\n\\t\\t\\t\\tif (!node[char]) node[char] = {};\\n\\n\\t\\t\\t\\tnode = node[char];\\n\\t\\t\\t}\\n\\n\\t\\t\\tnode.isEnd = true;\\n\\t\\t\\tnode.index = i;\\n\\t\\t}\\n\\t};\\n\\n\\t// empty string forms palindrome w/ every palindrome in the list\\n\\tconst handleEmptyString = root => {\\n\\t\\tif (root.isEnd) {\\n\\t\\t\\tfor (let i = 0; i < words.length; i++) {\\n\\t\\t\\t\\tconst validPalindrome = isPalindrome(words[i]);\\n\\n\\t\\t\\t\\tif (root.index === i) continue;\\n\\t\\t\\t\\tif (validPalindrome) output.push([i, root.index]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\t// case 2: if word shorter - get last prefix node given the word\\n  // case 3: if word longer - check if suffix is valid palindrome, if not stop\\n\\tconst getLastPrefixNode = (word, i) => {\\n\\t\\tlet node = root;\\n\\n\\t\\tfor (let j = 0; j < word.length; j++) {\\n\\t\\t\\tconst char = word[j];\\n\\t\\t\\tconst child = node[char];\\n\\n\\t\\t\\t// case 3: word is longer\\n\\t\\t\\t// check if rest of the word form valid palindrome\\n\\t\\t\\tif (!child) return;\\n\\t\\t\\tif (child.isEnd && child.index !== i && j < word.length - 1) {\\n\\t\\t\\t\\tconst suffix = word.slice(j + 1);\\n\\t\\t\\t\\tconst validSuffix = isPalindrome(suffix);\\n\\n\\t\\t\\t\\tif (validSuffix) output.push([i, child.index]);\\n\\t\\t\\t}\\n\\n\\t\\t\\tnode = node[char];\\n\\t\\t}\\n\\n\\t\\treturn node;\\n\\t};\\n\\n\\t// starting from lastPrefixNode find valid palindromes AND traverse Trie\\n\\tconst findPalindromes = (node, suffix, i) => {\\n\\t\\t// case 1. same word length\\n\\t\\tif (node.isEnd && node.index !== i) {\\n\\t\\t\\tconst validSuffix = isPalindrome(suffix);\\n\\n\\t\\t\\tif (validSuffix) output.push([i, node.index]);\\n\\t\\t}\\n\\n\\t\\t// case 2. word is shorter\\n\\t\\tfor (const char in node) {\\n\\t\\t\\tfindPalindromes(node[char], suffix + char, i);\\n\\t\\t}\\n\\t};\\n\\n\\tinsertReversed(words);\\n\\thandleEmptyString(root);\\n\\n\\tfor (let i = 0; i < words.length; i++) {\\n\\t\\tconst lastPrefixNode = getLastPrefixNode(words[i], i);\\n\\n\\t\\tif (lastPrefixNode) findPalindromes(lastPrefixNode, \\'\\', i);\\n\\t}\\n\\n\\treturn output;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1828378,
                "title": "java-solution-with-very-detailed-explanations",
                "content": "```\\nclass Solution\\n{\\n    public class TrieNode\\n    {\\n        TrieNode[] children;            // the next characters in words.\\n        int wordIndex;                  // if current TrieNode is the end of a word, store the index of this word in words.\\n       \\n\\t   // restIsPalindrome: rest of the current branch (substring) is a valid Palindrome substring.\\n\\t   // e.g. abcll, then for c, its restIsPalindrome will store the index of the word \"abcll\";\\n\\t   List<Integer> restIsPalindrome;\\n        \\n        public TrieNode()\\n        {\\n            children = new TrieNode[26];    // only consists of 26 lowercase English letters.\\n            wordIndex = -1;\\n            restIsPalindrome = new ArrayList<>();\\n        }\\n    }\\n    \\n    public class Trie\\n    {\\n        TrieNode root;\\n        \\n        public Trie()\\n        {\\n            root = new TrieNode();\\n        }\\n        \\n        public Trie(String[] words)\\n        {\\n            this();\\n            \\n            // build trie from an array of words.\\n            for (int w = 0; w < words.length; w++)\\n            {\\n                TrieNode curNode = root;    // start from the root of the trie for each word.\\n                char[] chs = words[w].toCharArray();\\n                \\n                // build from the endIndex of each word, why?\\n                // e.g. \\n                // (1) xyzll | zyx; we build from end, then trie will be: l->l->z->y->x and x->y->z(z.wordIndex != -1)\\n                // then for each word we go from the root of trie, for xyzll, we found z.wordIndex != -1 and ll is a palindrome\\n                // then xyzllzyx will form a valid palindrome.\\n                \\n                // (2) llzyx | xyz or llllzyx | xyz; we build from the end, x->y->z->llll is palindrome\\n                // add curWordIndex into Z.restIsPalindrome List.\\n                // then when we are processing with xyz, we can find a branch in the trie: x->y->z\\n                // and we can add all the options in restIsPalindrome will form xyzllzyx, xyzllllzyx palindrome paris.\\n                \\n                // (3) xyz | zyx => easy to know.\\n                for (int i = chs.length - 1; i >= 0; i--)\\n                {\\n                    if (Solution.isPalindrome(chs, 0, i))\\n                        curNode.restIsPalindrome.add(w);\\n                    \\n                    int ch = chs[i] - \\'a\\';\\n                    if (curNode.children[ch] == null)\\n                        curNode.children[ch] = new TrieNode();\\n                    \\n                    curNode = curNode.children[ch];\\n                }\\n                \\n                curNode.wordIndex = w;\\n            }\\n        }\\n    }\\n    \\n    public static boolean isPalindrome(char[] chs, int left, int right)\\n    {\\n        while (left < right)\\n        {\\n            if (chs[left++] != chs[right--])\\n                return false;\\n        }\\n        \\n        return true; \\n    }\\n    \\n    public List<List<Integer>> palindromePairs(String[] words)\\n    {\\n        List<List<Integer>> resultList = new ArrayList<>();\\n        \\n        // first put each word into the trie.\\n        Trie trie = new Trie(words);\\n        \\n        for (int i = 0; i < words.length; i++)\\n            searchPairs(resultList, trie.root, words[i], i);\\n        \\n        return resultList;\\n    }\\n    \\n    private void searchPairs(List<List<Integer>> resultList, TrieNode root, String word, int curIndex)\\n    {\\n        TrieNode curNode = root;\\n        char[] curWord = word.toCharArray();\\n        int len = curWord.length;\\n\\n        for (int c = 0; c < curWord.length; c++)\\n        {\\n            // inside the loop,check if the rest of the word is palindrome.\\n            // xyzll <-> zyx; because we build each word in trie from end index of a word.\\n            // so if we do found the x -> y -> z branch with TrieNode z.wordIndex != -1(zyx is a word), and \"ll\" is palindrome\\n            // then a valid palindrome pair is formed(xyzllzyx);\\n            if (curNode.wordIndex != -1 && Solution.isPalindrome(curWord, c, len - 1))\\n                resultList.add(Arrays.asList(curIndex, curNode.wordIndex));\\n\\n            int childIndex = curWord[c] - \\'a\\';\\n\\n            if (curNode.children[childIndex] == null) return; // no further nodes.\\n\\n            curNode = curNode.children[childIndex];\\n        }\\n            \\n        // the current branch did go to the bottom, meaning there is at least one word in words\\n        // which has a reversed substring of curword. e.g. (1) abcd <-> dcba; (2) Or: xyz <-> llzyx\\n        // (1) abcd <-> dcba.\\n        if (curNode.wordIndex != -1 && curNode.wordIndex != curIndex)\\n            resultList.add(Arrays.asList(curIndex, curNode.wordIndex));\\n        \\n        // (2) xyz <-> llzyx\\n        for (Integer firstIndex : curNode.restIsPalindrome)\\n            resultList.add(Arrays.asList(curIndex, firstIndex));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass Solution\\n{\\n    public class TrieNode\\n    {\\n        TrieNode[] children;            // the next characters in words.\\n        int wordIndex;                  // if current TrieNode is the end of a word, store the index of this word in words.\\n       \\n\\t   // restIsPalindrome: rest of the current branch (substring) is a valid Palindrome substring.\\n\\t   // e.g. abcll, then for c, its restIsPalindrome will store the index of the word \"abcll\";\\n\\t   List<Integer> restIsPalindrome;\\n        \\n        public TrieNode()\\n        {\\n            children = new TrieNode[26];    // only consists of 26 lowercase English letters.\\n            wordIndex = -1;\\n            restIsPalindrome = new ArrayList<>();\\n        }\\n    }\\n    \\n    public class Trie\\n    {\\n        TrieNode root;\\n        \\n        public Trie()\\n        {\\n            root = new TrieNode();\\n        }\\n        \\n        public Trie(String[] words)\\n        {\\n            this();\\n            \\n            // build trie from an array of words.\\n            for (int w = 0; w < words.length; w++)\\n            {\\n                TrieNode curNode = root;    // start from the root of the trie for each word.\\n                char[] chs = words[w].toCharArray();\\n                \\n                // build from the endIndex of each word, why?\\n                // e.g. \\n                // (1) xyzll | zyx; we build from end, then trie will be: l->l->z->y->x and x->y->z(z.wordIndex != -1)\\n                // then for each word we go from the root of trie, for xyzll, we found z.wordIndex != -1 and ll is a palindrome\\n                // then xyzllzyx will form a valid palindrome.\\n                \\n                // (2) llzyx | xyz or llllzyx | xyz; we build from the end, x->y->z->llll is palindrome\\n                // add curWordIndex into Z.restIsPalindrome List.\\n                // then when we are processing with xyz, we can find a branch in the trie: x->y->z\\n                // and we can add all the options in restIsPalindrome will form xyzllzyx, xyzllllzyx palindrome paris.\\n                \\n                // (3) xyz | zyx => easy to know.\\n                for (int i = chs.length - 1; i >= 0; i--)\\n                {\\n                    if (Solution.isPalindrome(chs, 0, i))\\n                        curNode.restIsPalindrome.add(w);\\n                    \\n                    int ch = chs[i] - \\'a\\';\\n                    if (curNode.children[ch] == null)\\n                        curNode.children[ch] = new TrieNode();\\n                    \\n                    curNode = curNode.children[ch];\\n                }\\n                \\n                curNode.wordIndex = w;\\n            }\\n        }\\n    }\\n    \\n    public static boolean isPalindrome(char[] chs, int left, int right)\\n    {\\n        while (left < right)\\n        {\\n            if (chs[left++] != chs[right--])\\n                return false;\\n        }\\n        \\n        return true; \\n    }\\n    \\n    public List<List<Integer>> palindromePairs(String[] words)\\n    {\\n        List<List<Integer>> resultList = new ArrayList<>();\\n        \\n        // first put each word into the trie.\\n        Trie trie = new Trie(words);\\n        \\n        for (int i = 0; i < words.length; i++)\\n            searchPairs(resultList, trie.root, words[i], i);\\n        \\n        return resultList;\\n    }\\n    \\n    private void searchPairs(List<List<Integer>> resultList, TrieNode root, String word, int curIndex)\\n    {\\n        TrieNode curNode = root;\\n        char[] curWord = word.toCharArray();\\n        int len = curWord.length;\\n\\n        for (int c = 0; c < curWord.length; c++)\\n        {\\n            // inside the loop,check if the rest of the word is palindrome.\\n            // xyzll <-> zyx; because we build each word in trie from end index of a word.\\n            // so if we do found the x -> y -> z branch with TrieNode z.wordIndex != -1(zyx is a word), and \"ll\" is palindrome\\n            // then a valid palindrome pair is formed(xyzllzyx);\\n            if (curNode.wordIndex != -1 && Solution.isPalindrome(curWord, c, len - 1))\\n                resultList.add(Arrays.asList(curIndex, curNode.wordIndex));\\n\\n            int childIndex = curWord[c] - \\'a\\';\\n\\n            if (curNode.children[childIndex] == null) return; // no further nodes.\\n\\n            curNode = curNode.children[childIndex];\\n        }\\n            \\n        // the current branch did go to the bottom, meaning there is at least one word in words\\n        // which has a reversed substring of curword. e.g. (1) abcd <-> dcba; (2) Or: xyz <-> llzyx\\n        // (1) abcd <-> dcba.\\n        if (curNode.wordIndex != -1 && curNode.wordIndex != curIndex)\\n            resultList.add(Arrays.asList(curIndex, curNode.wordIndex));\\n        \\n        // (2) xyz <-> llzyx\\n        for (Integer firstIndex : curNode.restIsPalindrome)\\n            resultList.add(Arrays.asList(curIndex, firstIndex));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767380,
                "title": "c-solution-with-trie-structure",
                "content": "```\\npublic class Solution {\\n    private TrieNode root;\\n    public IList<IList<int>> PalindromePairs(string[] words) {\\n        this.root = new TrieNode();\\n        var res = new List<IList<int>>();\\n        for(int i = 0; i < words.Length; i++)\\n        {\\n            this.InsertWordReversely(words[i], i);\\n        }\\n        \\n        for (int i = 0; i < words.Length; i++)\\n        {\\n            this.Search(words[i], i, res);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private void Search(string word, int wordIndex, IList<IList<int>> res)\\n    {\\n        TrieNode cur = this.root;\\n        for (int i = 0; i < word.Length; i++)\\n        {\\n            char c = word[i];\\n            int index = this.GetCharIndex(c);\\n\\n            //case 2: word 1\\u662F\\u957F\\u7684(xyzll)\\uFF0Cword2\\u662F\\u77ED\\u7684(zyx)\\uFF0C\\u56E0\\u4E3ATrie\\u91CC\\u9762\\u662F\\u53CD\\u5411\\u5B58word\\u5BF9\\u5E94\\u7684\\u4E5F\\u5C31\\u662F(xyz)\\uFF0C\\u6240\\u4EE5\\u5F53\\u5728trie\\u91CC\\u9762\\u627E\\u5230\\u4E00\\u4E2A\\u548Cword1 prefix\\u5B8C\\u5168\\u76F8\\u53CD\\u7684word\\u540E\\u53EA\\u9700\\u8981\\u770Bword1\\u5269\\u4E0B\\u7684\\u662F\\u5426\\u662F\\u4E2APalindrome\\n            if (cur.wordIndex != -1 && this.RestIsPalindrome(word, i, word.Length - 1))\\n            {\\n                res.Add(new List<int>() {wordIndex, cur.wordIndex});\\n            }\\n            \\n            cur = cur.chars[index];\\n            if (cur == null)\\n            {\\n                return;\\n            }\\n        }\\n        \\n        //case 1: word1 \\u548C word 2\\u957F\\u5EA6\\u4E00\\u6837\\uFF0C\\u5E76\\u4E14\\u4ED6\\u4EEC\\u662Fpalindrome,\\u53E6\\u5916\\u50CFaaa\\u8FD9\\u79CD\\u81EA\\u5DF1\\u672C\\u8EAB\\u5C31\\u662Fpalindrome\\u8981\\u53BB\\u9664(cur.wordIndex != wordIndex)\\n        if (cur.wordIndex != -1 && cur.wordIndex != wordIndex)\\n        {\\n            res.Add(new List<int>() {wordIndex, cur.wordIndex});\\n        }\\n        \\n        //case 3: word1\\u662F\\u77ED\\u7684(xyz)\\uFF0Cword2\\u662F\\u957F\\u7684(llzyx)\\uFF0C\\u8FD9\\u4E2A\\u65F6\\u5019\\u9700\\u8981\\u628Aword2\\u91CC\\u90A3\\u4E9BRestIsPalindrome\\u7684index\\u4E5F\\u8981\\u52A0\\u5165\\n        foreach(int restIsPalindromeIndex in cur.restIsPalindrome)\\n        {\\n            res.Add(new List<int>() {wordIndex, restIsPalindromeIndex});\\n        }\\n    }\\n    \\n    private void InsertWordReversely(string word, int wordIndex)\\n    {\\n        TrieNode cur = this.root;\\n        for(int i = word.Length - 1; i >=0; i--)\\n        {\\n            char c = word[i];\\n            int index = this.GetCharIndex(c);\\n            \\n            if (this.RestIsPalindrome(word, 0, i))\\n            {\\n                cur.restIsPalindrome.Add(wordIndex);    \\n            }\\n            \\n            if (cur.chars[index] == null)\\n            {\\n                cur.chars[index] = new TrieNode();\\n            }\\n            \\n            cur = cur.chars[index];\\n        }\\n        \\n        cur.wordIndex = wordIndex;\\n    }\\n    \\n    private bool RestIsPalindrome(string word, int start, int end)\\n    {\\n        while (start < end)\\n        {\\n            if (word[start++] != word[end--])\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private int GetCharIndex (char c)\\n    {\\n        return c - \\'a\\';\\n    }\\n}\\n\\npublic class TrieNode{\\n    public TrieNode[] chars;\\n    public int wordIndex;\\n    public List<int> restIsPalindrome;\\n    \\n    public TrieNode()\\n    {\\n        this.chars = new TrieNode[26];\\n        // if -1 means not the end of the word\\n        this.wordIndex = -1;\\n        this.restIsPalindrome = new List<int>();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\npublic class Solution {\\n    private TrieNode root;\\n    public IList<IList<int>> PalindromePairs(string[] words) {\\n        this.root = new TrieNode();\\n        var res = new List<IList<int>>();\\n        for(int i = 0; i < words.Length; i++)\\n        {\\n            this.InsertWordReversely(words[i], i);\\n        }\\n        \\n        for (int i = 0; i < words.Length; i++)\\n        {\\n            this.Search(words[i], i, res);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private void Search(string word, int wordIndex, IList<IList<int>> res)\\n    {\\n        TrieNode cur = this.root;\\n        for (int i = 0; i < word.Length; i++)\\n        {\\n            char c = word[i];\\n            int index = this.GetCharIndex(c);\\n\\n            //case 2: word 1\\u662F\\u957F\\u7684(xyzll)\\uFF0Cword2\\u662F\\u77ED\\u7684(zyx)\\uFF0C\\u56E0\\u4E3ATrie\\u91CC\\u9762\\u662F\\u53CD\\u5411\\u5B58word\\u5BF9\\u5E94\\u7684\\u4E5F\\u5C31\\u662F(xyz)\\uFF0C\\u6240\\u4EE5\\u5F53\\u5728trie\\u91CC\\u9762\\u627E\\u5230\\u4E00\\u4E2A\\u548Cword1 prefix\\u5B8C\\u5168\\u76F8\\u53CD\\u7684word\\u540E\\u53EA\\u9700\\u8981\\u770Bword1\\u5269\\u4E0B\\u7684\\u662F\\u5426\\u662F\\u4E2APalindrome\\n            if (cur.wordIndex != -1 && this.RestIsPalindrome(word, i, word.Length - 1))\\n            {\\n                res.Add(new List<int>() {wordIndex, cur.wordIndex});\\n            }\\n            \\n            cur = cur.chars[index];\\n            if (cur == null)\\n            {\\n                return;\\n            }\\n        }\\n        \\n        //case 1: word1 \\u548C word 2\\u957F\\u5EA6\\u4E00\\u6837\\uFF0C\\u5E76\\u4E14\\u4ED6\\u4EEC\\u662Fpalindrome,\\u53E6\\u5916\\u50CFaaa\\u8FD9\\u79CD\\u81EA\\u5DF1\\u672C\\u8EAB\\u5C31\\u662Fpalindrome\\u8981\\u53BB\\u9664(cur.wordIndex != wordIndex)\\n        if (cur.wordIndex != -1 && cur.wordIndex != wordIndex)\\n        {\\n            res.Add(new List<int>() {wordIndex, cur.wordIndex});\\n        }\\n        \\n        //case 3: word1\\u662F\\u77ED\\u7684(xyz)\\uFF0Cword2\\u662F\\u957F\\u7684(llzyx)\\uFF0C\\u8FD9\\u4E2A\\u65F6\\u5019\\u9700\\u8981\\u628Aword2\\u91CC\\u90A3\\u4E9BRestIsPalindrome\\u7684index\\u4E5F\\u8981\\u52A0\\u5165\\n        foreach(int restIsPalindromeIndex in cur.restIsPalindrome)\\n        {\\n            res.Add(new List<int>() {wordIndex, restIsPalindromeIndex});\\n        }\\n    }\\n    \\n    private void InsertWordReversely(string word, int wordIndex)\\n    {\\n        TrieNode cur = this.root;\\n        for(int i = word.Length - 1; i >=0; i--)\\n        {\\n            char c = word[i];\\n            int index = this.GetCharIndex(c);\\n            \\n            if (this.RestIsPalindrome(word, 0, i))\\n            {\\n                cur.restIsPalindrome.Add(wordIndex);    \\n            }\\n            \\n            if (cur.chars[index] == null)\\n            {\\n                cur.chars[index] = new TrieNode();\\n            }\\n            \\n            cur = cur.chars[index];\\n        }\\n        \\n        cur.wordIndex = wordIndex;\\n    }\\n    \\n    private bool RestIsPalindrome(string word, int start, int end)\\n    {\\n        while (start < end)\\n        {\\n            if (word[start++] != word[end--])\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private int GetCharIndex (char c)\\n    {\\n        return c - \\'a\\';\\n    }\\n}\\n\\npublic class TrieNode{\\n    public TrieNode[] chars;\\n    public int wordIndex;\\n    public List<int> restIsPalindrome;\\n    \\n    public TrieNode()\\n    {\\n        this.chars = new TrieNode[26];\\n        // if -1 means not the end of the word\\n        this.wordIndex = -1;\\n        this.restIsPalindrome = new List<int>();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1698685,
                "title": "palindrome-pairs-python-brute-force-hashmap",
                "content": "**BRUTE FORCE (TLE)**\\n\\n\\tclass Solution:\\n\\t\\t\\tdef palindromePairs(self, words: List[str]) -> List[List[int]]:\\n\\t\\t\\t\\tres=[]\\n\\t\\t\\t\\tfor i in range(len(words)-1):\\n\\t\\t\\t\\t\\tfor j in range(i+1,len(words)):\\n\\t\\t\\t\\t\\t\\tif ispal(words[i]+words[j]):\\n\\t\\t\\t\\t\\t\\t\\tres.append([i,j])\\n\\t\\t\\t\\t\\t\\tif ispal(words[j]+words[i]):\\n\\t\\t\\t\\t\\t\\t\\tres.append([j,i])\\n\\t\\t\\t\\treturn res\\n\\tdef ispal(st):\\n\\t\\treturn st==st[::-1]\\n\\t\\t\\n\\t\\t\\n**HASHMAP (Accepted)**\\n\\n\\tclass Solution:\\n\\t\\tdef palindromePairs(self, words: List[str]) -> List[List[int]]:\\n\\t\\t\\td={}\\n\\t\\t\\tfor i,c in enumerate(words):\\n\\t\\t\\t\\td[c]=i\\n\\t\\t\\tres=[]\\n\\t\\t\\temp=\"\"\\n\\t\\t\\tif emp in d:\\n\\t\\t\\t\\tfor i in range(len(words)):\\n\\t\\t\\t\\t\\tif ispal(words[i]) and words[i]!=emp:\\n\\t\\t\\t\\t\\t\\tres.append([d[emp],i])\\n\\t\\t\\tfor i in range(len(words)):\\n\\t\\t\\t\\tn=len(words[i])\\n\\t\\t\\t\\tch=words[i]\\n\\t\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\t\\tleft=ch[:j]\\n\\t\\t\\t\\t\\tlr=left[::-1]\\n\\t\\t\\t\\t\\tright=ch[j:]\\n\\t\\t\\t\\t\\trr=right[::-1]\\n\\t\\t\\t\\t\\tif ispal(right) and lr in d and d[lr]!=i:\\n\\t\\t\\t\\t\\t\\tres.append([i,d[lr]])\\n\\t\\t\\t\\t\\tif ispal(left) and rr in d and d[rr]!=i:                    \\n\\t\\t\\t\\t\\t\\tres.append([d[rr],i])                   \\n\\t\\t\\treturn res        \\n\\tdef ispal(st):\\n\\t\\treturn st==st[::-1]",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\t\\tdef palindromePairs(self, words: List[str]) -> List[List[int]]:\\n\\t\\t\\t\\tres=[]\\n\\t\\t\\t\\tfor i in range(len(words)-1):\\n\\t\\t\\t\\t\\tfor j in range(i+1,len(words)):\\n\\t\\t\\t\\t\\t\\tif ispal(words[i]+words[j]):\\n\\t\\t\\t\\t\\t\\t\\tres.append([i,j])\\n\\t\\t\\t\\t\\t\\tif ispal(words[j]+words[i]):\\n\\t\\t\\t\\t\\t\\t\\tres.append([j,i])\\n\\t\\t\\t\\treturn res\\n\\tdef ispal(st):\\n\\t\\treturn st==st[::-1]\\n\\t\\t\\n\\t\\t\\n**HASHMAP (Accepted)**\\n\\n\\tclass Solution:\\n\\t\\tdef palindromePairs(self, words: List[str]) -> List[List[int]]:\\n\\t\\t\\td={}",
                "codeTag": "Java"
            },
            {
                "id": 1371345,
                "title": "2-clean-python-solution-explained-o-nl-2-with-other-similar-problems",
                "content": "```python\\n\"\"\"\\nTime: O(N x L^2), assume the average length of word is L. Note that, eversing the string takes O(L).\\nSpace: O(L), beside from ans, need `left` and `right` constantly to store the word.\\n\"\"\"\\nclass Solution(object):\\n    def palindromePairs(self, words):\\n        ans = set()\\n        index = {word:i for i, word in enumerate(words)}\\n        \\n        for i, word in enumerate(words):\\n            for j in xrange(len(word)+1):\\n                left = word[:j]\\n                right = word[j:]\\n                \\n                # check if any other word that concat to the left will make palindrome: \"OTHER_WORD+`left`+`right`\"\\n                # The above will be palindrome only if\\n                # 1. `left` is palindrome (left==left[::-1])\\n                # 2. Exsit an \"OTHER_WORD\" in word in words that equals to the reverse of `right` (right[::-1] in index and index[right[::-1]]!=i).\\n                if left==left[::-1]:\\n                    if right[::-1] in index and index[right[::-1]]!=i:\\n                        ans.add((index[right[::-1]], i))\\n                \\n                # check if any other word that concat to the right will make palindrome: \"`left`+`right`+OTHER_WORD\"\\n                # The above will be palindrome only if\\n                # 1. `rihgt` is palindrome (right==right[::-1])\\n                # 2. Exsit an \"OTHER_WORD\" in words that equals to the reverse of `left` (left[::-1] in index and index[left[::-1]]!=i).\\n                if right==right[::-1]:\\n                    if left[::-1] in index and index[left[::-1]]!=i:\\n                        ans.add((i, index[left[::-1]]))\\n                        \\n        return ans\\n\\n\\n\"\"\"\\nTime: O(N^2 x L), will cause TLE.\\nSpace: O(L), can reduce to O(1) by improving isPalindrome()\\n\"\"\"\\nclass Solution(object):\\n    def palindromePairs(self, words):\\n        N = len(words)\\n        ans = []\\n        \\n        for i in xrange(N):\\n            for j in xrange(N):\\n                if i==j: continue\\n                if self.isPalindrome(words[i]+words[j]):\\n                    ans.append([i, j])\\n        return ans\\n    \\n    def isPalindrome(self, word):\\n        l = 0\\n        r = len(word)-1\\n        \\n        while l<=r:\\n            if word[l]==word[r]:\\n                l += 1\\n                r -= 1\\n            else:\\n                return False\\n        return True\\n           \\n\"\"\"\\nRelated Problems:\\nValid Anagram, Group Shifted Strings\\nPalindrome Pairs\\nLine Reflection\\nIsomorphic Strings\\n\\nFor more other topics similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "solutionTags": [],
                "code": "```python\\n\"\"\"\\nTime: O(N x L^2), assume the average length of word is L. Note that, eversing the string takes O(L).\\nSpace: O(L), beside from ans, need `left` and `right` constantly to store the word.\\n\"\"\"\\nclass Solution(object):\\n    def palindromePairs(self, words):\\n        ans = set()\\n        index = {word:i for i, word in enumerate(words)}\\n        \\n        for i, word in enumerate(words):\\n            for j in xrange(len(word)+1):\\n                left = word[:j]\\n                right = word[j:]\\n                \\n                # check if any other word that concat to the left will make palindrome: \"OTHER_WORD+`left`+`right`\"\\n                # The above will be palindrome only if\\n                # 1. `left` is palindrome (left==left[::-1])\\n                # 2. Exsit an \"OTHER_WORD\" in word in words that equals to the reverse of `right` (right[::-1] in index and index[right[::-1]]!=i).\\n                if left==left[::-1]:\\n                    if right[::-1] in index and index[right[::-1]]!=i:\\n                        ans.add((index[right[::-1]], i))\\n                \\n                # check if any other word that concat to the right will make palindrome: \"`left`+`right`+OTHER_WORD\"\\n                # The above will be palindrome only if\\n                # 1. `rihgt` is palindrome (right==right[::-1])\\n                # 2. Exsit an \"OTHER_WORD\" in words that equals to the reverse of `left` (left[::-1] in index and index[left[::-1]]!=i).\\n                if right==right[::-1]:\\n                    if left[::-1] in index and index[left[::-1]]!=i:\\n                        ans.add((i, index[left[::-1]]))\\n                        \\n        return ans\\n\\n\\n\"\"\"\\nTime: O(N^2 x L), will cause TLE.\\nSpace: O(L), can reduce to O(1) by improving isPalindrome()\\n\"\"\"\\nclass Solution(object):\\n    def palindromePairs(self, words):\\n        N = len(words)\\n        ans = []\\n        \\n        for i in xrange(N):\\n            for j in xrange(N):\\n                if i==j: continue\\n                if self.isPalindrome(words[i]+words[j]):\\n                    ans.append([i, j])\\n        return ans\\n    \\n    def isPalindrome(self, word):\\n        l = 0\\n        r = len(word)-1\\n        \\n        while l<=r:\\n            if word[l]==word[r]:\\n                l += 1\\n                r -= 1\\n            else:\\n                return False\\n        return True\\n           \\n\"\"\"\\nRelated Problems:\\nValid Anagram, Group Shifted Strings\\nPalindrome Pairs\\nLine Reflection\\nIsomorphic Strings\\n\\nFor more other topics similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1366042,
                "title": "simple-explanation-with-intuition-and-code-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    // n: words.length <= 5000, k: words[i].length <= 300, \\n    // 2 options: \\n    // 1) O(n*n*k)-> concatenate each word with all other, check if palindrome\\n    \\n    // 2) O(n*k*k)-> \\n    // O(n): for each word, \\n    // O(k): divide it into all possible left and right half\\n    // O(k): check if right half is palindrome \\n    // and reverse of left half is present in words\\n    // so that on concatenation of left|right|rev(left), a palindrome is obtained\\n    // it accounts for all cases even when concatnated words are of unequal size\\n    // do the same for left as right and right as left\\n    \\n    // since n is much higher than k, will go with 2nd option.\\n\\n    bool ispalin(string s) {\\n        int i=0, j=s.length()-1;\\n        while(i<j) {\\n            if(s[i++]!=s[j--]) { return false; }\\n        }\\n        return true;\\n    }\\n    \\n    vector<vector<int>> palindromePairs(vector<string>& words) {  \\n        vector<vector<int>> res;\\n        \\n        map<string, int> m;\\n        for(int i=0; i<words.size(); i++) {\\n            string rev = words[i];  // reversed here so that don\\'t have to reverse every subarray of each string later\\n            reverse(rev.begin(), rev.end());\\n            m[rev] = i;\\n        }\\n        \\n        for(int j=0; j<words.size(); j++) {\\n            for(int i=0; i<words[j].size(); i++) {\\n                \\n                string left = words[j].substr(0,i);\\n                string right = words[j].substr(i,words[j].size()-i);\\n                \\n                if(ispalin(right) && m.find(left)!=m.end() && m[left]!=j) {\\n                    res.push_back(vector<int>{j, m[left]});\\n                \\n                    // left==\"\" means right, which has entire string, is palindrome.\\n                    // also left is present in map so \"\" string is there.\\n                    // So normally only word+\"\" is captured but \"\"+word isn\\'t captured\\n                    // because right is never empty string to avoid duplicates (abcd, dcba: if left is abcd, we get abcddcba, if right is abcd, we get dcbaabcd; similaryly for string dcba as left and right we get the same 2 strings.)\\n                    // so to include case \"\"+word below line\\n                    if(left==\"\") { res.push_back(vector<int>{m[left], j}); }\\n                }\\n                \\n                if(ispalin(left) && m.find(right)!=m.end() && m[right]!=j) {\\n                    res.push_back(vector<int>{m[right], j});\\n                    if(right==\"\") { res.push_back(vector<int>{m[right]}); }\\n                }\\n            }\\n        }\\n            \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // n: words.length <= 5000, k: words[i].length <= 300, \\n    // 2 options: \\n    // 1) O(n*n*k)-> concatenate each word with all other, check if palindrome\\n    \\n    // 2) O(n*k*k)-> \\n    // O(n): for each word, \\n    // O(k): divide it into all possible left and right half\\n    // O(k): check if right half is palindrome \\n    // and reverse of left half is present in words\\n    // so that on concatenation of left|right|rev(left), a palindrome is obtained\\n    // it accounts for all cases even when concatnated words are of unequal size\\n    // do the same for left as right and right as left\\n    \\n    // since n is much higher than k, will go with 2nd option.\\n\\n    bool ispalin(string s) {\\n        int i=0, j=s.length()-1;\\n        while(i<j) {\\n            if(s[i++]!=s[j--]) { return false; }\\n        }\\n        return true;\\n    }\\n    \\n    vector<vector<int>> palindromePairs(vector<string>& words) {  \\n        vector<vector<int>> res;\\n        \\n        map<string, int> m;\\n        for(int i=0; i<words.size(); i++) {\\n            string rev = words[i];  // reversed here so that don\\'t have to reverse every subarray of each string later\\n            reverse(rev.begin(), rev.end());\\n            m[rev] = i;\\n        }\\n        \\n        for(int j=0; j<words.size(); j++) {\\n            for(int i=0; i<words[j].size(); i++) {\\n                \\n                string left = words[j].substr(0,i);\\n                string right = words[j].substr(i,words[j].size()-i);\\n                \\n                if(ispalin(right) && m.find(left)!=m.end() && m[left]!=j) {\\n                    res.push_back(vector<int>{j, m[left]});\\n                \\n                    // left==\"\" means right, which has entire string, is palindrome.\\n                    // also left is present in map so \"\" string is there.\\n                    // So normally only word+\"\" is captured but \"\"+word isn\\'t captured\\n                    // because right is never empty string to avoid duplicates (abcd, dcba: if left is abcd, we get abcddcba, if right is abcd, we get dcbaabcd; similaryly for string dcba as left and right we get the same 2 strings.)\\n                    // so to include case \"\"+word below line\\n                    if(left==\"\") { res.push_back(vector<int>{m[left], j}); }\\n                }\\n                \\n                if(ispalin(left) && m.find(right)!=m.end() && m[right]!=j) {\\n                    res.push_back(vector<int>{m[right], j});\\n                    if(right==\"\") { res.push_back(vector<int>{m[right]}); }\\n                }\\n            }\\n        }\\n            \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1272756,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPal(string s){\\n        int i=0,j=s.length()-1;\\n        while(i<=j){\\n            if(s[i]!=s[j]){\\n                return false;\\n                \\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        unordered_map<string,int>mp;\\n        vector<vector<int>>v;\\n        for(int i=0;i<words.size();i++){\\n            mp[words[i]]=i;\\n        }\\n        for(int i=0;i<words.size();i++){\\n            for(int j=0;j<=words[i].size();j++){\\n                string prefix=words[i].substr(0,j);\\n                string suffix=words[i].substr(j);\\n                if(isPal(prefix)){\\n                    string rev=suffix;\\n                    reverse(rev.begin(),rev.end());\\n                    if(mp.count(rev) && mp[rev]!=i){\\n                        v.push_back({mp[rev],i});\\n                    }\\n                    \\n                }\\n                 if(isPal(suffix)){\\n                    string rev=prefix;\\n                    reverse(rev.begin(),rev.end());\\n                    if(mp.count(rev) && mp[rev]!=i && !suffix.empty()){\\n                        v.push_back({i,mp[rev]});\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return v;\\n    }\\n};\\ndo upvote if you like it\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPal(string s){\\n        int i=0,j=s.length()-1;\\n        while(i<=j){\\n            if(s[i]!=s[j]){\\n                return false;\\n                \\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        unordered_map<string,int>mp;\\n        vector<vector<int>>v;\\n        for(int i=0;i<words.size();i++){\\n            mp[words[i]]=i;\\n        }\\n        for(int i=0;i<words.size();i++){\\n            for(int j=0;j<=words[i].size();j++){\\n                string prefix=words[i].substr(0,j);\\n                string suffix=words[i].substr(j);\\n                if(isPal(prefix)){\\n                    string rev=suffix;\\n                    reverse(rev.begin(),rev.end());\\n                    if(mp.count(rev) && mp[rev]!=i){\\n                        v.push_back({mp[rev],i});\\n                    }\\n                    \\n                }\\n                 if(isPal(suffix)){\\n                    string rev=prefix;\\n                    reverse(rev.begin(),rev.end());\\n                    if(mp.count(rev) && mp[rev]!=i && !suffix.empty()){\\n                        v.push_back({i,mp[rev]});\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return v;\\n    }\\n};\\ndo upvote if you like it\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1270865,
                "title": "c-python-hash",
                "content": "Approach 1: Hash\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        const int n = words.size();\\n        vector<vector<int>> res;\\n        unordered_map<string, int> m;\\n        for(int i = 0; i < n; i++){\\n            string key = words[i];\\n            reverse(key.begin(), key.end()); // mirror \\n            m[key] = i;\\n        }\\n        \\n        for(int i = 0; i < n; i++){\\n            if(m.count(\"\") && m[\"\"] != i && isPalindrom(words[i]))\\n                res.push_back({i, m[\"\"]});\\n            \\n            for(int j = 1; j <= words[i].size(); j++){\\n                const string left = words[i].substr(0, j);\\n                const string right = words[i].substr(j);\\n                if(m.count(left) && m[left] != i && isPalindrom(right) )\\n                    res.push_back({i, m[left]});\\n                \\n                if(m.count(right) && m[right] != i && isPalindrom(left) )\\n                    res.push_back({m[right], i});\\n            }\\n        }\\n        return res;\\n    }\\n    \\nprivate:\\n    bool isPalindrom(const string& s){\\n        for(int l = 0, r = s.size() - 1; l < r; )\\n            if(s[l++] != s[r--]) return false;\\n        return true;\\n    }\\n};\\n```\\n\\nApproach 2: Hash in Python version[1]\\n```\\nclass Solution:\\n    def palindromePairs(self, words):\\n\\n        def all_valid_prefixes(word):\\n            valid_prefixes = []\\n            for i in range(len(word)):\\n                if word[i:] == word[i:][::-1]:\\n                    valid_prefixes.append(word[:i])\\n            return valid_prefixes\\n\\n        def all_valid_suffixes(word):\\n            valid_suffixes = []\\n            for i in range(len(word)):\\n                if word[:i+1] == word[:i+1][::-1]:\\n                    valid_suffixes.append(word[i + 1:])\\n            return valid_suffixes\\n\\n        word_lookup = {word: i for i, word in enumerate(words)} #dict can be prepared via list comprehension\\n        \\n        solutions = []\\n        for word_index, word in enumerate(words):\\n            reversed_word = word[::-1]\\n\\n            # Build solutions of case #1. This word will be word 1.\\n            if reversed_word in word_lookup and word_index != word_lookup[reversed_word]:\\n                solutions.append([word_index, word_lookup[reversed_word]])\\n\\n            # Build solutions of case #2. This word will be word 2.\\n            for suffix in all_valid_suffixes(word):\\n                reversed_suffix = suffix[::-1]\\n                if reversed_suffix in word_lookup:\\n                    solutions.append([word_lookup[reversed_suffix], word_index])\\n\\n            # Build solutions of case #3. This word will be word 1.\\n            for prefix in all_valid_prefixes(word):\\n                reversed_prefix = prefix[::-1]\\n                if reversed_prefix in word_lookup:\\n                    solutions.append([word_index, word_lookup[reversed_prefix]])\\n\\n        return solutions  \\n```\\nReference:\\n[1] https://leetcode.com/problems/palindrome-pairs/solution/",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        const int n = words.size();\\n        vector<vector<int>> res;\\n        unordered_map<string, int> m;\\n        for(int i = 0; i < n; i++){\\n            string key = words[i];\\n            reverse(key.begin(), key.end()); // mirror \\n            m[key] = i;\\n        }\\n        \\n        for(int i = 0; i < n; i++){\\n            if(m.count(\"\") && m[\"\"] != i && isPalindrom(words[i]))\\n                res.push_back({i, m[\"\"]});\\n            \\n            for(int j = 1; j <= words[i].size(); j++){\\n                const string left = words[i].substr(0, j);\\n                const string right = words[i].substr(j);\\n                if(m.count(left) && m[left] != i && isPalindrom(right) )\\n                    res.push_back({i, m[left]});\\n                \\n                if(m.count(right) && m[right] != i && isPalindrom(left) )\\n                    res.push_back({m[right], i});\\n            }\\n        }\\n        return res;\\n    }\\n    \\nprivate:\\n    bool isPalindrom(const string& s){\\n        for(int l = 0, r = s.size() - 1; l < r; )\\n            if(s[l++] != s[r--]) return false;\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def palindromePairs(self, words):\\n\\n        def all_valid_prefixes(word):\\n            valid_prefixes = []\\n            for i in range(len(word)):\\n                if word[i:] == word[i:][::-1]:\\n                    valid_prefixes.append(word[:i])\\n            return valid_prefixes\\n\\n        def all_valid_suffixes(word):\\n            valid_suffixes = []\\n            for i in range(len(word)):\\n                if word[:i+1] == word[:i+1][::-1]:\\n                    valid_suffixes.append(word[i + 1:])\\n            return valid_suffixes\\n\\n        word_lookup = {word: i for i, word in enumerate(words)} #dict can be prepared via list comprehension\\n        \\n        solutions = []\\n        for word_index, word in enumerate(words):\\n            reversed_word = word[::-1]\\n\\n            # Build solutions of case #1. This word will be word 1.\\n            if reversed_word in word_lookup and word_index != word_lookup[reversed_word]:\\n                solutions.append([word_index, word_lookup[reversed_word]])\\n\\n            # Build solutions of case #2. This word will be word 2.\\n            for suffix in all_valid_suffixes(word):\\n                reversed_suffix = suffix[::-1]\\n                if reversed_suffix in word_lookup:\\n                    solutions.append([word_lookup[reversed_suffix], word_index])\\n\\n            # Build solutions of case #3. This word will be word 1.\\n            for prefix in all_valid_prefixes(word):\\n                reversed_prefix = prefix[::-1]\\n                if reversed_prefix in word_lookup:\\n                    solutions.append([word_index, word_lookup[reversed_prefix]])\\n\\n        return solutions  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1270598,
                "title": "simple-javascript-brut-force-solution-with-o-n-2k",
                "content": "**javascript  brut force solution with O(n^2K)**\\n```\\nvar isValidPalindome =function (s){\\n    let i =0 ; let j = s.length-1;\\n    while(i<j){\\n        if(s[i] !=s[j]) return false;\\n        i++;j--;\\n    }\\n    return true;\\n}\\nvar palindromePairs = function(words) {\\n    let n = words.length;\\nconst result = [];\\n    for(let i = 0 ;i<n-1;i++){\\n        for(let j = i+1 ;j<n;j++){\\n            if(isValidPalindome(words[i]+ words[j])) result.push([i,j]);\\n            if(isValidPalindome(words[j]+words[i])) result.push([j,i]);\\n        }\\n    }\\n    return result;\\n};\\n```\\n\\u0398(n\\xB2 (k+k)) --> \\u0398(n\\xB2 2k)) i.e.  O(n\\xB2k)) \\n",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar isValidPalindome =function (s){\\n    let i =0 ; let j = s.length-1;\\n    while(i<j){\\n        if(s[i] !=s[j]) return false;\\n        i++;j--;\\n    }\\n    return true;\\n}\\nvar palindromePairs = function(words) {\\n    let n = words.length;\\nconst result = [];\\n    for(let i = 0 ;i<n-1;i++){\\n        for(let j = i+1 ;j<n;j++){\\n            if(isValidPalindome(words[i]+ words[j])) result.push([i,j]);\\n            if(isValidPalindome(words[j]+words[i])) result.push([j,i]);\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1270338,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        List<List<Integer>> al=new ArrayList<List<Integer>>();\\n        for(int i=0;i<words.length-1;i++)\\n        {\\n            for(int j=i+1;j<words.length;j++)\\n            {\\n                String k=words[i]+words[j];\\n                String t=words[j]+words[i];\\n                if(ispalin(k))\\n                {\\n                    ArrayList<Integer> l=new ArrayList<Integer>();\\n                    l.add(i);\\n                    l.add(j);\\n                    al.add(l);\\n                }\\n                if(ispalin(t))\\n                {\\n                    ArrayList<Integer> l=new ArrayList<Integer>();\\n                    l.add(j);\\n                    l.add(i);\\n                    al.add(l);\\n                }\\n            }\\n        }\\n        return al;\\n    }\\n    boolean ispalin(String s)\\n    {\\n        int i=0;\\n        int j=s.length()-1;\\n        while(i<j)\\n        {\\n            if(s.charAt(i)!=s.charAt(j))\\n                return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        List<List<Integer>> al=new ArrayList<List<Integer>>();\\n        for(int i=0;i<words.length-1;i++)\\n        {\\n            for(int j=i+1;j<words.length;j++)\\n            {\\n                String k=words[i]+words[j];\\n                String t=words[j]+words[i];\\n                if(ispalin(k))\\n                {\\n                    ArrayList<Integer> l=new ArrayList<Integer>();\\n                    l.add(i);\\n                    l.add(j);\\n                    al.add(l);\\n                }\\n                if(ispalin(t))\\n                {\\n                    ArrayList<Integer> l=new ArrayList<Integer>();\\n                    l.add(j);\\n                    l.add(i);\\n                    al.add(l);\\n                }\\n            }\\n        }\\n        return al;\\n    }\\n    boolean ispalin(String s)\\n    {\\n        int i=0;\\n        int j=s.length()-1;\\n        while(i<j)\\n        {\\n            if(s.charAt(i)!=s.charAt(j))\\n                return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1269428,
                "title": "python-dict-short-some-intuition",
                "content": "So I split words[i] into ```prefix=words[i][:j]``` and ```rest=words[i][j:]``` (j iterates form 0 to len(words[i])+1)\\nif prefix is palindrome, then I can use prefix as middle, and find whether inversed rest exist in words or not\\nfor eaxmple, words[i]=\"fffgh\", then I need to find whether \"hg\",\"hgf\",\"hgff\",\"hgfff\" in the words or not\\nAlso, if rest is palindrome, then I can use rest as middle, and find whether inversed prefix exist in words or not\\nfor eaxmple, words[i]=\"ghfff\", then I need to find whether \"hg\",\"fhg\",\"ffhg\",\"fffhg\" in the words or not\\n\\nI was a bit stuck for the case like\\nwords[i]=\"abcd\", and I though I need to find \"whatever palindrome\"+\"dcba\", but it is not true, \\nbecuase if such \"whatever palindrome\"+\"dcba\" exists, it will be handled when  words[i] =\"whatever palindrome\"+\"dcba\", \\nso I actually only need to focus on the cases where len(words[i])>=len(words[j])\\n\\nAlso this approach causes duplications, for example if \"abcd\" and \"dcba\" both exist in words, so I use set for the answer.\\n\\nThis approach gives complexity O(n*k^2), and the navie approach gives complexity O(n^2 * k), since in this challenge n<5000 and k<300, so this approach is better, but it is not general imo.\\n```\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        \\n        ans =set()\\n        #n = len(words)\\n        val_pos = {w:idx for idx,w in enumerate(words)}\\n        for i,word in enumerate(words):\\n            for j in range(len(word)+1):\\n                pre = word[:j] \\n                rest = word[j:]\\n                inv_pre = pre[::-1]\\n                inv_rest = rest[::-1]\\n                #print(pre,rest,inv_pre,inv_rest,pre==inv_pre)\\n\\t\\t\\t\\t\\n                #case1 :EEEEABCD -> find DCBA,  DCBAE, DCBAEE, ...\\n                if(pre==inv_pre):\\n                    if(inv_rest in val_pos and val_pos[inv_rest]!=i):ans.add((val_pos[inv_rest],i))\\n                \\n                #case2 :ABCDEEEE -> find DCBA, EDCBA, ...\\n                if(rest==inv_rest):\\n                    if(inv_pre in val_pos and val_pos[inv_pre]!=i):ans.add((i,val_pos[inv_pre]))\\n                #print(ans)\\n        return [list(pair) for pair in ans]\\n                \\n                \\n                \\n                \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```prefix=words[i][:j]```\n```rest=words[i][j:]```\n```\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        \\n        ans =set()\\n        #n = len(words)\\n        val_pos = {w:idx for idx,w in enumerate(words)}\\n        for i,word in enumerate(words):\\n            for j in range(len(word)+1):\\n                pre = word[:j] \\n                rest = word[j:]\\n                inv_pre = pre[::-1]\\n                inv_rest = rest[::-1]\\n                #print(pre,rest,inv_pre,inv_rest,pre==inv_pre)\\n\\t\\t\\t\\t\\n                #case1 :EEEEABCD -> find DCBA,  DCBAE, DCBAEE, ...\\n                if(pre==inv_pre):\\n                    if(inv_rest in val_pos and val_pos[inv_rest]!=i):ans.add((val_pos[inv_rest],i))\\n                \\n                #case2 :ABCDEEEE -> find DCBA, EDCBA, ...\\n                if(rest==inv_rest):\\n                    if(inv_pre in val_pos and val_pos[inv_pre]!=i):ans.add((i,val_pos[inv_pre]))\\n                #print(ans)\\n        return [list(pair) for pair in ans]\\n                \\n                \\n                \\n                \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1269382,
                "title": "c-solution-using-cumulative-hash-rabin-karp-string-matching-beats-98-64-in-memory-usage",
                "content": "```\\nclass Solution {\\npublic:\\n    long int pre[5001]={}, suf[5001]={}, p[301]={}, X = 1000000007, Y = 998244353, len[5001]={};\\n    \\n    void init(vector<string>& words){\\n        \\n        int n = words.size();\\n        p[0]=1;\\n        for(int i=1;i<=300;i++){\\n            p[i] = (p[i-1]*Y)%X;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            len[i] = words[i].size();\\n            for(int j=0;j<len[i];j++){\\n                pre[i] = (pre[i] + (words[i][j]*p[j])%X)%X;\\n                suf[i] = (suf[i] + (words[i][j]*p[len[i]-1-j])%X)%X;\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(int a,int b){\\n        \\n        long int x = (pre[a] + (p[len[a]]*pre[b])%X)%X;\\n        long int y = (suf[b] + (p[len[b]]*suf[a])%X)%X;;\\n        \\n        return (x==y) ;\\n    }\\n    \\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        \\n        init(words);\\n        vector<vector<int>> ans;\\n        \\n        int n = words.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i!=j && isPalindrome(i,j)){\\n                    vector<int> temp = {i,j};\\n                    ans.push_back(temp);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long int pre[5001]={}, suf[5001]={}, p[301]={}, X = 1000000007, Y = 998244353, len[5001]={};\\n    \\n    void init(vector<string>& words){\\n        \\n        int n = words.size();\\n        p[0]=1;\\n        for(int i=1;i<=300;i++){\\n            p[i] = (p[i-1]*Y)%X;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            len[i] = words[i].size();\\n            for(int j=0;j<len[i];j++){\\n                pre[i] = (pre[i] + (words[i][j]*p[j])%X)%X;\\n                suf[i] = (suf[i] + (words[i][j]*p[len[i]-1-j])%X)%X;\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(int a,int b){\\n        \\n        long int x = (pre[a] + (p[len[a]]*pre[b])%X)%X;\\n        long int y = (suf[b] + (p[len[b]]*suf[a])%X)%X;;\\n        \\n        return (x==y) ;\\n    }\\n    \\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        \\n        init(words);\\n        vector<vector<int>> ans;\\n        \\n        int n = words.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i!=j && isPalindrome(i,j)){\\n                    vector<int> temp = {i,j};\\n                    ans.push_back(temp);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1148470,
                "title": "c-o-n-k-2-trie-commented-with-some-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    // we will make a reverse trie because we always need to find a pair which is reverse of my current string. We need ordered pairs so we\\'ll cut a string into two parts, left and remaining\\n    \\n    /** a|bcd\\n        ab|cd\\n        abc|d\\n        and then find \\'left\\' in trie as trie already has reversed strings\\n        but also make sure that your \\'remaining\\' is a palindrome as well.\\n        form the string like this left+rem+found\\n        \\n        since we need ordered pairs\\n        one more thing we can do is find \\'remaining\\' in trie, make sure \\'left\\' is a palindrome\\n        and form the string like found + left + rem\\n    \\n    */\\n    struct TrieNode{\\n        unordered_map<char,TrieNode*> child;\\n      \\n        int index =-1;\\n    }*root;\\n    \\n    /** Inserts a word into the trie. */\\n    void insert(string word, int idx) {\\n        TrieNode*temp=root;\\n        \\n        for(auto i: word){\\n            // if there is no pointer to the character in the map then create new node\\n            if(!temp->child.count(i)) temp->child[i]=new TrieNode();\\n            \\n            // go to the child\\n            temp=temp->child[i];\\n        }\\n        \\n        // fix the index as the current else it will be -1\\n        \\n        temp->index= idx;\\n        // cout<<temp->index<<endl;\\n    }\\n    \\n    /** Returns if the word is in the trie. */\\n    int search(string word) {\\n        \\n        // start search from root\\n        TrieNode*temp=root;\\n        for(auto i: word){\\n            // if there is no pointer to the character then return -1\\n            if(!temp->child.count(i)) return -1;\\n            temp=temp->child[i];\\n        }\\n        // if we have traversed the whole string and still it is not a word in trie then return -1\\n        return temp->index;\\n    }\\n    \\n    // check if a string is a palindrome\\n    bool isPal(string&s){\\n        int l = 0, r=s.size()-1;\\n        while(l<=r){\\n            if(s[l]==s[r]) l++,r--;\\n            else return false;\\n        }\\n        return true;\\n    }\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        // string a =\"abcba\";\\n        // if(isPal(a)) return {{1}};\\n        int n = words.size();\\n        \\n        // initialise the root node\\n        root=new TrieNode();\\n        \\n        // insert all reversed words in trie\\n        for(int i=0;i<n;i++){\\n            string s = words[i];\\n            reverse(s.begin(),s.end());\\n          \\n            insert(s,i);\\n        }\\n        set<vector<int> > temp;\\n        // lets start cutting\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=words[i].size();j++){\\n                string left = words[i].substr(0,j), rem = words[i].substr(j);\\n                \\n                int idx = search(left);\\n                if(idx!=-1 && isPal(rem) && idx!=i){\\n                  \\n                   temp.insert({i,idx});\\n                }\\n                \\n                idx = search(rem);\\n                if(idx!=-1 && isPal(left) && idx!=i){\\n                   \\n                   temp.insert({idx,i}); \\n                }\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        for(auto i: temp){\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // we will make a reverse trie because we always need to find a pair which is reverse of my current string. We need ordered pairs so we\\'ll cut a string into two parts, left and remaining\\n    \\n    /** a|bcd\\n        ab|cd\\n        abc|d\\n        and then find \\'left\\' in trie as trie already has reversed strings\\n        but also make sure that your \\'remaining\\' is a palindrome as well.\\n        form the string like this left+rem+found\\n        \\n        since we need ordered pairs\\n        one more thing we can do is find \\'remaining\\' in trie, make sure \\'left\\' is a palindrome\\n        and form the string like found + left + rem\\n    \\n    */\\n    struct TrieNode{\\n        unordered_map<char,TrieNode*> child;\\n      \\n        int index =-1;\\n    }*root;\\n    \\n    /** Inserts a word into the trie. */\\n    void insert(string word, int idx) {\\n        TrieNode*temp=root;\\n        \\n        for(auto i: word){\\n            // if there is no pointer to the character in the map then create new node\\n            if(!temp->child.count(i)) temp->child[i]=new TrieNode();\\n            \\n            // go to the child\\n            temp=temp->child[i];\\n        }\\n        \\n        // fix the index as the current else it will be -1\\n        \\n        temp->index= idx;\\n        // cout<<temp->index<<endl;\\n    }\\n    \\n    /** Returns if the word is in the trie. */\\n    int search(string word) {\\n        \\n        // start search from root\\n        TrieNode*temp=root;\\n        for(auto i: word){\\n            // if there is no pointer to the character then return -1\\n            if(!temp->child.count(i)) return -1;\\n            temp=temp->child[i];\\n        }\\n        // if we have traversed the whole string and still it is not a word in trie then return -1\\n        return temp->index;\\n    }\\n    \\n    // check if a string is a palindrome\\n    bool isPal(string&s){\\n        int l = 0, r=s.size()-1;\\n        while(l<=r){\\n            if(s[l]==s[r]) l++,r--;\\n            else return false;\\n        }\\n        return true;\\n    }\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n        // string a =\"abcba\";\\n        // if(isPal(a)) return {{1}};\\n        int n = words.size();\\n        \\n        // initialise the root node\\n        root=new TrieNode();\\n        \\n        // insert all reversed words in trie\\n        for(int i=0;i<n;i++){\\n            string s = words[i];\\n            reverse(s.begin(),s.end());\\n          \\n            insert(s,i);\\n        }\\n        set<vector<int> > temp;\\n        // lets start cutting\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=words[i].size();j++){\\n                string left = words[i].substr(0,j), rem = words[i].substr(j);\\n                \\n                int idx = search(left);\\n                if(idx!=-1 && isPal(rem) && idx!=i){\\n                  \\n                   temp.insert({i,idx});\\n                }\\n                \\n                idx = search(rem);\\n                if(idx!=-1 && isPal(left) && idx!=i){\\n                   \\n                   temp.insert({idx,i}); \\n                }\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        for(auto i: temp){\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1084997,
                "title": "c-clean-solution-unordered-map",
                "content": "inorder to make palindrome by concatinating the particular string with other string we can find other string by cancatinating it either to front or back and considering palindromic substring present in particular string(s):\\n\\neg: s= \"abcd\"\\nso by concatinating s with a string of same length \"dcba\"\\nor with different length \"cba\"\\n     \"dcb\"  (at back)\\n\\nlet s=\"abcb\"\\n now other string can be \\n    \"bcba\" (front)\\n     \"cba\"\\n\\t \"a\"\\n\\t \"bcba\"  (back)\\n\\t \\nlet s=\"ecer\"\\n        \"rece\"\\n\\t\\t\"ece\"\\n\\t\\t\"rec\"\\n\\t\\t\"r\"\\n\\t \\n\\n```\\nclass Solution {\\n    bool ispalindrome(string s,int start,int end)\\n    {\\n        while(start<end)\\n        {\\n            if(s[start]!=s[end])\\n                return false;\\n           start++;\\n            end--;\\n        }\\n        return true;\\n    }\\npublic:\\n    vector<vector<int>> palindromePairs(vector<string>& words) {\\n      unordered_map<string,int>m;\\n        vector<vector<int>>ans;\\n     for(int i=0;i<words.size();i++)\\n     {\\n         string temp=words[i]; \\n         if(temp!=\"\")\\n             reverse(temp.begin(),temp.end());\\n         m[temp]=i;\\n     }\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(m.find(words[i])!=m.end())   //  for whole string\\n            {\\n               if(i!=m[words[i]])\\n                   ans.push_back({i,m[words[i]]});  \\n            }\\n            for(int j=words[i].length()-1;j>=0;j--)\\n            {\\n                 if(ispalindrome(words[i],j,words[i].length()-1) && m.find(words[i].substr(0,j))!=m.end())\\n                 {\\n                         if(i!=m[words[i].substr(0,j)])\\n                             ans.push_back({i,m[words[i].substr(0,j)]});  //taking front-palindromes in consideration\\n                 }\\n            }\\n            for(int j=0;j<words[i].length();j++)    //taking back-palindromes in consideration\\n            {\\n                 if(ispalindrome(words[i],0,j) && m.find(words[i].substr(j+1))!=m.end())\\n                 {\\n                        if(i!=m[words[i].substr(j+1)])  \\n\\t\\t\\t\\t\\t\\tans.push_back({m[words[i].substr(j+1)],i});\\n                 }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    bool ispalindrome(string s,int start,int end)\\n    {\\n        while(start<end)\\n        {\\n            if(s[start]!=s[end])\\n                return false;\\n           start++;\\n            end--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 917299,
                "title": "clean-kmp-solution-with-o-n-k-2-time",
                "content": "This solution is directly inspired by [214. Shortest Palindrome](https://leetcode.com/problems/shortest-palindrome/) and the impressive [solution](https://leetcode.com/problems/shortest-palindrome/discuss/60113/) by @myfavcat123.\\n\\nAs long as we can find the shortest complement required to make the original string a palindrome by KMP algorihtm in linear time, why can\\'t we find all those complements in the same way?\\n\\nNote that for any concatenation of two strings that form a palindrome, at least one of them can be seen as the other\\'s *complement*.\\n\\nLet\\'s take two examples:\\nCase 1 - `ssl` + `lllss`, in which `ssl` can be seen as `lllss`\\'s complement, and **NOT** vice versa.\\nCase 2 - `abc` + `cba`, in which `abc` can be seen as `cba`\\'s complement, and vice versa.\\n\\nIt\\'s obvious that the complement is either placed before or after the *primary* string. So we can use the aforementioned KMP algorithm to get all the complements in two directions (forward / backward). And then we check whether those complements exist in the given words. If so, they\\'ll form a palindrome.\\n\\nA few caveats concerning the procedure:\\n1. The `substring` method costs O(k) (k is the length of string) time, which is the bottleneck raising the entire time complexity to O(n * k^2) (n is the total of strings).\\n2. To avoid duplicates, use `HashSet` and convert it to a list lastly.\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        Map<String, Integer> wordMap = new HashMap<>();\\n        for (int i = 0; i < words.length; i++) {\\n            wordMap.put(words[i], i);\\n        }\\n        \\n        Set<List<Integer>> res = new HashSet<>();\\n        \\n        for (int i = 0; i < words.length; i++) {\\n            List<List<String>> targets = getPairStrs(words[i]);\\n            for (int j = 0; j < targets.size(); j++) {\\n                for (String target : targets.get(j)) {\\n                    Integer idx = wordMap.get(target);\\n                    if (idx != null && idx != i) {\\n                        res.add(j == 0 ? List.of(i, idx) : List.of(idx, i));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return List.copyOf(res);\\n    }\\n    \\n    private List<List<String>> getPairStrs(String str) {\\n        String reverse = new StringBuilder(str).reverse().toString();\\n        String[] concats = {reverse + \"*\" + str, str + \"*\" + reverse};\\n        \\n        int[][] kmpTables = {getKmpTable(concats[0]), getKmpTable(concats[1])};\\n        \\n        // pairStrs stores strings that can be concatenated with \\'str\\' and form a palindrome\\n        // which are either placed before or after the original \\'str\\'\\n        List<List<String>> pairStrs = List.of(new ArrayList(), new ArrayList());\\n        for (int i = 0; i < concats.length; i++) {\\n            // i == 0 -> Forward concatenation, in which the complement comes after \\'str\\'\\n            // i == 1 -> Backward concatenation, in which the complement comes before \\'str\\'\\n            int curr = kmpTables[i][concats[i].length()];\\n            \\n            while (curr >= 0) {\\n                pairStrs.get(i).add(\\n                    i == 0 ? reverse.substring(curr): reverse.substring(0, reverse.length() - curr)\\n                );\\n                curr = kmpTables[i][curr];\\n            }\\n        }\\n        \\n        return pairStrs;\\n    }\\n    \\n    private int[] getKmpTable(String str) {\\n        int[] table = new int[str.length() + 1];\\n        table[0] = -1;\\n        \\n        for (int i = 0; i < str.length(); i++) {\\n            int curr = table[i];\\n            while (curr >= 0 && str.charAt(curr) != str.charAt(i)) curr = table[curr];\\n            table[i + 1] = curr + 1;\\n        }\\n        \\n        return table;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> palindromePairs(String[] words) {\\n        Map<String, Integer> wordMap = new HashMap<>();\\n        for (int i = 0; i < words.length; i++) {\\n            wordMap.put(words[i], i);\\n        }\\n        \\n        Set<List<Integer>> res = new HashSet<>();\\n        \\n        for (int i = 0; i < words.length; i++) {\\n            List<List<String>> targets = getPairStrs(words[i]);\\n            for (int j = 0; j < targets.size(); j++) {\\n                for (String target : targets.get(j)) {\\n                    Integer idx = wordMap.get(target);\\n                    if (idx != null && idx != i) {\\n                        res.add(j == 0 ? List.of(i, idx) : List.of(idx, i));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return List.copyOf(res);\\n    }\\n    \\n    private List<List<String>> getPairStrs(String str) {\\n        String reverse = new StringBuilder(str).reverse().toString();\\n        String[] concats = {reverse + \"*\" + str, str + \"*\" + reverse};\\n        \\n        int[][] kmpTables = {getKmpTable(concats[0]), getKmpTable(concats[1])};\\n        \\n        // pairStrs stores strings that can be concatenated with \\'str\\' and form a palindrome\\n        // which are either placed before or after the original \\'str\\'\\n        List<List<String>> pairStrs = List.of(new ArrayList(), new ArrayList());\\n        for (int i = 0; i < concats.length; i++) {\\n            // i == 0 -> Forward concatenation, in which the complement comes after \\'str\\'\\n            // i == 1 -> Backward concatenation, in which the complement comes before \\'str\\'\\n            int curr = kmpTables[i][concats[i].length()];\\n            \\n            while (curr >= 0) {\\n                pairStrs.get(i).add(\\n                    i == 0 ? reverse.substring(curr): reverse.substring(0, reverse.length() - curr)\\n                );\\n                curr = kmpTables[i][curr];\\n            }\\n        }\\n        \\n        return pairStrs;\\n    }\\n    \\n    private int[] getKmpTable(String str) {\\n        int[] table = new int[str.length() + 1];\\n        table[0] = -1;\\n        \\n        for (int i = 0; i < str.length(); i++) {\\n            int curr = table[i];\\n            while (curr >= 0 && str.charAt(curr) != str.charAt(i)) curr = table[curr];\\n            table[i + 1] = curr + 1;\\n        }\\n        \\n        return table;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 910908,
                "title": "java-solution-naive-solution",
                "content": "\\tpublic List<List<Integer>> palindromePairs(String[] words) {\\n       List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        if(words == null || words.length < 1)\\n            return result;\\n        int length = words.length;\\n        for(int i=0; i<length-1; i++){\\n            for(int j=i+1; j<length; j++){\\n\\t\\t\\t//check for combining two words for palindrome back to back\\n                String temp = words[i]+words[j];\\n                if(isPalindrome(temp))\\n                    result.add(new ArrayList(Arrays.asList(i,j)));\\n                //check for combining two words for palindrome back to back making second word to come before first\\n\\t\\t\\t\\ttemp = words[j]+words[i];\\n                if(isPalindrome(temp))\\n                    result.add(new ArrayList(Arrays.asList(j,i)));\\n            }\\n        } \\n        return result;\\n    }\\n\\n    boolean isPalindrome(String str){\\n        int length = str.length();\\n        for(int i=0,j = length-1; i<j; i++,j--)\\n            if(str.charAt(i)!=str.charAt(j))\\n                return false;\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "\\tpublic List<List<Integer>> palindromePairs(String[] words) {\\n       List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        if(words == null || words.length < 1)\\n            return result;\\n        int length = words.length;\\n        for(int i=0; i<length-1; i++){\\n            for(int j=i+1; j<length; j++){\\n\\t\\t\\t//check for combining two words for palindrome back to back\\n                String temp = words[i]+words[j];\\n                if(isPalindrome(temp))\\n                    result.add(new ArrayList(Arrays.asList(i,j)));\\n                //check for combining two words for palindrome back to back making second word to come before first\\n\\t\\t\\t\\ttemp = words[j]+words[i];\\n                if(isPalindrome(temp))\\n                    result.add(new ArrayList(Arrays.asList(j,i)));\\n            }\\n        } \\n        return result;\\n    }\\n\\n    boolean isPalindrome(String str){\\n        int length = str.length();\\n        for(int i=0,j = length-1; i<j; i++,j--)\\n            if(str.charAt(i)!=str.charAt(j))\\n                return false;\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 903543,
                "title": "c-hard-level-algorithms-to-go-over-quickly",
                "content": "Oct. 20, 2020\\n336. Palindrome Pairs\\n\\n**Introduction**\\nIt is hard for me to prepare for Nov. 5, 2020 Google phone screen in 4 weeks, so I asked the advice from a friend. I got this tip. \\n\\nWhat I do is to look up Google using keyword \"Leetcode pattern Google\", and go to \"Leetcode Patterns - Sean Prashad\", and go over all 34 hard level algorithms, and then go over all 97 medium level algorithms.  I came cross this hard level algorithm.\\n\\n**Code study**\\nThere are more than two ideas to solve, one is to use hashMap, and second one is to use trie. I like to practice it using hashMap first. \\n\\n**Case study**\\nInput: words = [\"bat\",\"tab\",\"cat\"]\\nOutput: [[0,1],[1,0]]\\n\\nFirst put all reversed words into dictionary, so \"bat\"\\'s reversed word \"tab\" is added to the hashMap, next one is \"bat\", last one is \"tac\". The reversed hashMap has three words: {\"tab\", \"bat\",\"tac\"); \\n\\nNext is to go over each word, and then try to break the word into two pieces. One of two is a palindrome, and the other one can be find in the reversed words\\'s hashMap. \\n\\n**Time complexity**\\nTime is to put all reversed words into hashMap is O(N * M), N is total number of words, M is average length of word. \\nSecond step is to break into two pieces. The time complexity is O(M * M), first part is M choices, M is average length of word, second part M is time to calculate palindrome. \\nIn summary, it should be O(N * M + M * M). \\n\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _336_palindromic_pairs\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n        }\\n\\n        /// <summary>\\n        /// Palindromic - 336\\n        /// Study code\\n        /// https://leetcode.com/problems/palindrome-pairs/discuss/309105/C-dictionary-for-reversedWord-cut-each-word-to-get-left-part-and-right-part\\n        /// </summary>\\n        /// <param name=\"words\"></param>\\n        /// <returns></returns>\\n        public IList<IList<int>> PalindromePairs(string[] words)\\n        {\\n            var result = new List<IList<int>>();\\n\\n            // the hashmap to contain reversed word\\n            var reversedMap = new Dictionary<string, int>();\\n\\n            for (int i = 0; i < words.Length; i++)\\n            {\\n                var word = words[i];\\n\\n                if (word == \"\")\\n                {\\n                    continue;\\n                }\\n\\n                var reverse = new string(word.Reverse().ToArray());\\n                reversedMap[reverse] = i;\\n            }\\n\\n            for (int i = 0; i < words.Length; i++)\\n            {\\n                var word = words[i];               \\n\\n                if (string.IsNullOrEmpty(word))\\n                {\\n                    for (int j = 0; j < words.Length; j++)\\n                    {\\n                        if (i == j)\\n                        {\\n                            continue;\\n                        }\\n\\n                        if (IsPalindrome(words[j]))\\n                        {\\n                            result.Add(new List<int> { i, j });\\n                            result.Add(new List<int> { j, i });\\n                        }\\n                    }\\n                }\\n                else\\n                {\\n                    for (int j = 0; j < word.Length; j++)\\n                    {\\n                        var prefix = word.Substring(0, j);\\n                        var suffix = word.Substring(j);\\n\\n                        // prefix + suffix + reverse(prefix) -> suffix is palindrome\\n                        if (reversedMap.ContainsKey(prefix) && reversedMap[prefix] != i && IsPalindrome(suffix))\\n                        {\\n                            result.Add(new List<int> { i, reversedMap[prefix] });\\n                        }\\n\\n                        // reverse(suffix) + prefix + suffix -> prefix is palindrom\\n                        if (reversedMap.ContainsKey(suffix) && reversedMap[suffix] != i && IsPalindrome(prefix))\\n                        {\\n                            result.Add(new List<int> { reversedMap[suffix], i });\\n                        }\\n                    }\\n                }\\n            }\\n\\n            return result;\\n        }\\n\\n        private bool IsPalindrome(string s)\\n        {\\n            var start = 0;\\n            var end = s.Length - 1;\\n\\n            while (start < end)\\n            {\\n                if (s[start] != s[end])\\n                {\\n                    return false;\\n                }\\n\\n                start++;\\n                end--;\\n            }\\n\\n            return true;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _336_palindromic_pairs\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n        }\\n\\n        /// <summary>\\n        /// Palindromic - 336\\n        /// Study code\\n        /// https://leetcode.com/problems/palindrome-pairs/discuss/309105/C-dictionary-for-reversedWord-cut-each-word-to-get-left-part-and-right-part\\n        /// </summary>\\n        /// <param name=\"words\"></param>\\n        /// <returns></returns>\\n        public IList<IList<int>> PalindromePairs(string[] words)\\n        {\\n            var result = new List<IList<int>>();\\n\\n            // the hashmap to contain reversed word\\n            var reversedMap = new Dictionary<string, int>();\\n\\n            for (int i = 0; i < words.Length; i++)\\n            {\\n                var word = words[i];\\n\\n                if (word == \"\")\\n                {\\n                    continue;\\n                }\\n\\n                var reverse = new string(word.Reverse().ToArray());\\n                reversedMap[reverse] = i;\\n            }\\n\\n            for (int i = 0; i < words.Length; i++)\\n            {\\n                var word = words[i];               \\n\\n                if (string.IsNullOrEmpty(word))\\n                {\\n                    for (int j = 0; j < words.Length; j++)\\n                    {\\n                        if (i == j)\\n                        {\\n                            continue;\\n                        }\\n\\n                        if (IsPalindrome(words[j]))\\n                        {\\n                            result.Add(new List<int> { i, j });\\n                            result.Add(new List<int> { j, i });\\n                        }\\n                    }\\n                }\\n                else\\n                {\\n                    for (int j = 0; j < word.Length; j++)\\n                    {\\n                        var prefix = word.Substring(0, j);\\n                        var suffix = word.Substring(j);\\n\\n                        // prefix + suffix + reverse(prefix) -> suffix is palindrome\\n                        if (reversedMap.ContainsKey(prefix) && reversedMap[prefix] != i && IsPalindrome(suffix))\\n                        {\\n                            result.Add(new List<int> { i, reversedMap[prefix] });\\n                        }\\n\\n                        // reverse(suffix) + prefix + suffix -> prefix is palindrom\\n                        if (reversedMap.ContainsKey(suffix) && reversedMap[suffix] != i && IsPalindrome(prefix))\\n                        {\\n                            result.Add(new List<int> { reversedMap[suffix], i });\\n                        }\\n                    }\\n                }\\n            }\\n\\n            return result;\\n        }\\n\\n        private bool IsPalindrome(string s)\\n        {\\n            var start = 0;\\n            var end = s.Length - 1;\\n\\n            while (start < end)\\n            {\\n                if (s[start] != s[end])\\n                {\\n                    return false;\\n                }\\n\\n                start++;\\n                end--;\\n            }\\n\\n            return true;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566409,
                "content": [
                    {
                        "username": "bodurovmahmud",
                        "content": "**I couldn\\'t believe someone wrote this test case.**\\nhttps://leetcode.com/submissions/detail/594315425/testcase/\\n\\n"
                    },
                    {
                        "username": "tanishq1204",
                        "content": "looks like starts in the night sky!\\n"
                    },
                    {
                        "username": "czeng",
                        "content": "The time complexity of the official solutions will be much worse than simple brute force in some edge test cases, most likely will trigger TLE.  Consider the following test case:\\n\\n[\"aaaaa...(repeat 149 times)**bc**aaaaa(repeat 149 times again)\", \"aaaaa...(repeat 149 times)**bb**aaaaa(repeat 149 times again)\",\"\"]\\n\\nNote this test case has only 3 elements, where the first one is not a palindrome, the second one is a very long palindrome, and the third one is empty (thus is also a palindrome, and will combine with the second one to form a valid output). The answer should be [[1,2],[2,1]].\\n\\nIn brute force the time complexity is O(n^2 x k) = O(3^2 x 300) = O(2700). But in both hashmap and trie solution the time complexity is O(n x k^2) = O(3 x 300^2) = O(270000), which is 100 times of the brute force solution.\\n\\nNow this single case may be ok for the timing of the online judge. But in an extreme scenario if there are 1000 such test cases input to the program, the total runtime will be significantly increased, most likely will trigger TLE.\\n\\nAnother interesting thing is it seems C++ is the primary victim of such timing judge. Sometimes if we just write a quick but dirty code without recycling the resources (e.g. the new TrieNode created during the trie building), the timing will be ok. But if we explicitly record all allocated resource and manually free them at the end of the program, the timing will exceed the limit of the online judge. This sounds very unreasonable -- the timing is too tight which discourages programmers to properly recycle the allocated resources. This maybe fine for Java but will be a disaster for C++ in realworld.\\n"
                    },
                    {
                        "username": "merc14",
                        "content": "For someone who has to find this solution after hearing the question, is it even possible to find a solution AND code it in 45 min\\n\\nfolks who got this in interview and got an offer, please let use know how far you went. Just trying to get an understanding of the expectation"
                    },
                    {
                        "username": "kurtkaiser",
                        "content": "The constraits need to be fixed. Example 3 for the problem directly conflicts with the stated constraints. \\n\\n![image](https://assets.leetcode.com/users/images/05062a1f-ee67-46ac-a5bf-bb4e9fb79346_1651346727.042557.png)\\n"
                    },
                    {
                        "username": "drkato",
                        "content": "My code is right in that it finds the correct indices, but I keep getting a \"too long to execute\" error. When I run the timing in my dev environment for their test case that fails, it take 675ms. Not extraordinary, but not bad either, so what gives? What are we aiming for, there is no feedback or definition at the beginning of the problem."
                    },
                    {
                        "username": "James2009",
                        "content": "The C function prototype is defined as:\\n\\nint** palindromePairs(char** words, int wordsSize, int** columnSizes, int* returnSize)\\n\\nWhy do we need to return a two dimensional array columnSizes? I suppose each (i, j) pair is just a one-dimensional array of int. If we do need to specify the size of each (i,j) pair, should we just copy [2,1] into columnSizes for returnSize times?\\n\\nThanks!"
                    },
                    {
                        "username": "Foristkirito",
                        "content": "the description in this problem is not clear. Judging from the answer, the the number of words is huge, so the O(n*k^2) is ok. but what if the length of each word is also huge?"
                    },
                    {
                        "username": "grvchik",
                        "content": "There was no time limit posted on this question\\nIs there a way the question posters also post the time limit along with problem"
                    },
                    {
                        "username": "sin1080",
                        "content": "In English we do not call an empty string a word. Nor do we do so in other natural languages / programming languages."
                    },
                    {
                        "username": "oneguywithacat",
                        "content": "The description asks for a O(sum of words[i].length) solution but that doesn\\'t consider the quadratic palindrome checks of the remainder of words after matching part of it with the reverse of another word. Is that complexity wrong, or is there a solution that is truly O(sum of words[i].length)?"
                    }
                ]
            },
            {
                "id": 1566204,
                "content": [
                    {
                        "username": "bodurovmahmud",
                        "content": "**I couldn\\'t believe someone wrote this test case.**\\nhttps://leetcode.com/submissions/detail/594315425/testcase/\\n\\n"
                    },
                    {
                        "username": "tanishq1204",
                        "content": "looks like starts in the night sky!\\n"
                    },
                    {
                        "username": "czeng",
                        "content": "The time complexity of the official solutions will be much worse than simple brute force in some edge test cases, most likely will trigger TLE.  Consider the following test case:\\n\\n[\"aaaaa...(repeat 149 times)**bc**aaaaa(repeat 149 times again)\", \"aaaaa...(repeat 149 times)**bb**aaaaa(repeat 149 times again)\",\"\"]\\n\\nNote this test case has only 3 elements, where the first one is not a palindrome, the second one is a very long palindrome, and the third one is empty (thus is also a palindrome, and will combine with the second one to form a valid output). The answer should be [[1,2],[2,1]].\\n\\nIn brute force the time complexity is O(n^2 x k) = O(3^2 x 300) = O(2700). But in both hashmap and trie solution the time complexity is O(n x k^2) = O(3 x 300^2) = O(270000), which is 100 times of the brute force solution.\\n\\nNow this single case may be ok for the timing of the online judge. But in an extreme scenario if there are 1000 such test cases input to the program, the total runtime will be significantly increased, most likely will trigger TLE.\\n\\nAnother interesting thing is it seems C++ is the primary victim of such timing judge. Sometimes if we just write a quick but dirty code without recycling the resources (e.g. the new TrieNode created during the trie building), the timing will be ok. But if we explicitly record all allocated resource and manually free them at the end of the program, the timing will exceed the limit of the online judge. This sounds very unreasonable -- the timing is too tight which discourages programmers to properly recycle the allocated resources. This maybe fine for Java but will be a disaster for C++ in realworld.\\n"
                    },
                    {
                        "username": "merc14",
                        "content": "For someone who has to find this solution after hearing the question, is it even possible to find a solution AND code it in 45 min\\n\\nfolks who got this in interview and got an offer, please let use know how far you went. Just trying to get an understanding of the expectation"
                    },
                    {
                        "username": "kurtkaiser",
                        "content": "The constraits need to be fixed. Example 3 for the problem directly conflicts with the stated constraints. \\n\\n![image](https://assets.leetcode.com/users/images/05062a1f-ee67-46ac-a5bf-bb4e9fb79346_1651346727.042557.png)\\n"
                    },
                    {
                        "username": "drkato",
                        "content": "My code is right in that it finds the correct indices, but I keep getting a \"too long to execute\" error. When I run the timing in my dev environment for their test case that fails, it take 675ms. Not extraordinary, but not bad either, so what gives? What are we aiming for, there is no feedback or definition at the beginning of the problem."
                    },
                    {
                        "username": "James2009",
                        "content": "The C function prototype is defined as:\\n\\nint** palindromePairs(char** words, int wordsSize, int** columnSizes, int* returnSize)\\n\\nWhy do we need to return a two dimensional array columnSizes? I suppose each (i, j) pair is just a one-dimensional array of int. If we do need to specify the size of each (i,j) pair, should we just copy [2,1] into columnSizes for returnSize times?\\n\\nThanks!"
                    },
                    {
                        "username": "Foristkirito",
                        "content": "the description in this problem is not clear. Judging from the answer, the the number of words is huge, so the O(n*k^2) is ok. but what if the length of each word is also huge?"
                    },
                    {
                        "username": "grvchik",
                        "content": "There was no time limit posted on this question\\nIs there a way the question posters also post the time limit along with problem"
                    },
                    {
                        "username": "sin1080",
                        "content": "In English we do not call an empty string a word. Nor do we do so in other natural languages / programming languages."
                    },
                    {
                        "username": "oneguywithacat",
                        "content": "The description asks for a O(sum of words[i].length) solution but that doesn\\'t consider the quadratic palindrome checks of the remainder of words after matching part of it with the reverse of another word. Is that complexity wrong, or is there a solution that is truly O(sum of words[i].length)?"
                    }
                ]
            },
            {
                "id": 1569510,
                "content": [
                    {
                        "username": "bodurovmahmud",
                        "content": "**I couldn\\'t believe someone wrote this test case.**\\nhttps://leetcode.com/submissions/detail/594315425/testcase/\\n\\n"
                    },
                    {
                        "username": "tanishq1204",
                        "content": "looks like starts in the night sky!\\n"
                    },
                    {
                        "username": "czeng",
                        "content": "The time complexity of the official solutions will be much worse than simple brute force in some edge test cases, most likely will trigger TLE.  Consider the following test case:\\n\\n[\"aaaaa...(repeat 149 times)**bc**aaaaa(repeat 149 times again)\", \"aaaaa...(repeat 149 times)**bb**aaaaa(repeat 149 times again)\",\"\"]\\n\\nNote this test case has only 3 elements, where the first one is not a palindrome, the second one is a very long palindrome, and the third one is empty (thus is also a palindrome, and will combine with the second one to form a valid output). The answer should be [[1,2],[2,1]].\\n\\nIn brute force the time complexity is O(n^2 x k) = O(3^2 x 300) = O(2700). But in both hashmap and trie solution the time complexity is O(n x k^2) = O(3 x 300^2) = O(270000), which is 100 times of the brute force solution.\\n\\nNow this single case may be ok for the timing of the online judge. But in an extreme scenario if there are 1000 such test cases input to the program, the total runtime will be significantly increased, most likely will trigger TLE.\\n\\nAnother interesting thing is it seems C++ is the primary victim of such timing judge. Sometimes if we just write a quick but dirty code without recycling the resources (e.g. the new TrieNode created during the trie building), the timing will be ok. But if we explicitly record all allocated resource and manually free them at the end of the program, the timing will exceed the limit of the online judge. This sounds very unreasonable -- the timing is too tight which discourages programmers to properly recycle the allocated resources. This maybe fine for Java but will be a disaster for C++ in realworld.\\n"
                    },
                    {
                        "username": "merc14",
                        "content": "For someone who has to find this solution after hearing the question, is it even possible to find a solution AND code it in 45 min\\n\\nfolks who got this in interview and got an offer, please let use know how far you went. Just trying to get an understanding of the expectation"
                    },
                    {
                        "username": "kurtkaiser",
                        "content": "The constraits need to be fixed. Example 3 for the problem directly conflicts with the stated constraints. \\n\\n![image](https://assets.leetcode.com/users/images/05062a1f-ee67-46ac-a5bf-bb4e9fb79346_1651346727.042557.png)\\n"
                    },
                    {
                        "username": "drkato",
                        "content": "My code is right in that it finds the correct indices, but I keep getting a \"too long to execute\" error. When I run the timing in my dev environment for their test case that fails, it take 675ms. Not extraordinary, but not bad either, so what gives? What are we aiming for, there is no feedback or definition at the beginning of the problem."
                    },
                    {
                        "username": "James2009",
                        "content": "The C function prototype is defined as:\\n\\nint** palindromePairs(char** words, int wordsSize, int** columnSizes, int* returnSize)\\n\\nWhy do we need to return a two dimensional array columnSizes? I suppose each (i, j) pair is just a one-dimensional array of int. If we do need to specify the size of each (i,j) pair, should we just copy [2,1] into columnSizes for returnSize times?\\n\\nThanks!"
                    },
                    {
                        "username": "Foristkirito",
                        "content": "the description in this problem is not clear. Judging from the answer, the the number of words is huge, so the O(n*k^2) is ok. but what if the length of each word is also huge?"
                    },
                    {
                        "username": "grvchik",
                        "content": "There was no time limit posted on this question\\nIs there a way the question posters also post the time limit along with problem"
                    },
                    {
                        "username": "sin1080",
                        "content": "In English we do not call an empty string a word. Nor do we do so in other natural languages / programming languages."
                    },
                    {
                        "username": "oneguywithacat",
                        "content": "The description asks for a O(sum of words[i].length) solution but that doesn\\'t consider the quadratic palindrome checks of the remainder of words after matching part of it with the reverse of another word. Is that complexity wrong, or is there a solution that is truly O(sum of words[i].length)?"
                    }
                ]
            },
            {
                "id": 1576695,
                "content": [
                    {
                        "username": "bodurovmahmud",
                        "content": "**I couldn\\'t believe someone wrote this test case.**\\nhttps://leetcode.com/submissions/detail/594315425/testcase/\\n\\n"
                    },
                    {
                        "username": "tanishq1204",
                        "content": "looks like starts in the night sky!\\n"
                    },
                    {
                        "username": "czeng",
                        "content": "The time complexity of the official solutions will be much worse than simple brute force in some edge test cases, most likely will trigger TLE.  Consider the following test case:\\n\\n[\"aaaaa...(repeat 149 times)**bc**aaaaa(repeat 149 times again)\", \"aaaaa...(repeat 149 times)**bb**aaaaa(repeat 149 times again)\",\"\"]\\n\\nNote this test case has only 3 elements, where the first one is not a palindrome, the second one is a very long palindrome, and the third one is empty (thus is also a palindrome, and will combine with the second one to form a valid output). The answer should be [[1,2],[2,1]].\\n\\nIn brute force the time complexity is O(n^2 x k) = O(3^2 x 300) = O(2700). But in both hashmap and trie solution the time complexity is O(n x k^2) = O(3 x 300^2) = O(270000), which is 100 times of the brute force solution.\\n\\nNow this single case may be ok for the timing of the online judge. But in an extreme scenario if there are 1000 such test cases input to the program, the total runtime will be significantly increased, most likely will trigger TLE.\\n\\nAnother interesting thing is it seems C++ is the primary victim of such timing judge. Sometimes if we just write a quick but dirty code without recycling the resources (e.g. the new TrieNode created during the trie building), the timing will be ok. But if we explicitly record all allocated resource and manually free them at the end of the program, the timing will exceed the limit of the online judge. This sounds very unreasonable -- the timing is too tight which discourages programmers to properly recycle the allocated resources. This maybe fine for Java but will be a disaster for C++ in realworld.\\n"
                    },
                    {
                        "username": "merc14",
                        "content": "For someone who has to find this solution after hearing the question, is it even possible to find a solution AND code it in 45 min\\n\\nfolks who got this in interview and got an offer, please let use know how far you went. Just trying to get an understanding of the expectation"
                    },
                    {
                        "username": "kurtkaiser",
                        "content": "The constraits need to be fixed. Example 3 for the problem directly conflicts with the stated constraints. \\n\\n![image](https://assets.leetcode.com/users/images/05062a1f-ee67-46ac-a5bf-bb4e9fb79346_1651346727.042557.png)\\n"
                    },
                    {
                        "username": "drkato",
                        "content": "My code is right in that it finds the correct indices, but I keep getting a \"too long to execute\" error. When I run the timing in my dev environment for their test case that fails, it take 675ms. Not extraordinary, but not bad either, so what gives? What are we aiming for, there is no feedback or definition at the beginning of the problem."
                    },
                    {
                        "username": "James2009",
                        "content": "The C function prototype is defined as:\\n\\nint** palindromePairs(char** words, int wordsSize, int** columnSizes, int* returnSize)\\n\\nWhy do we need to return a two dimensional array columnSizes? I suppose each (i, j) pair is just a one-dimensional array of int. If we do need to specify the size of each (i,j) pair, should we just copy [2,1] into columnSizes for returnSize times?\\n\\nThanks!"
                    },
                    {
                        "username": "Foristkirito",
                        "content": "the description in this problem is not clear. Judging from the answer, the the number of words is huge, so the O(n*k^2) is ok. but what if the length of each word is also huge?"
                    },
                    {
                        "username": "grvchik",
                        "content": "There was no time limit posted on this question\\nIs there a way the question posters also post the time limit along with problem"
                    },
                    {
                        "username": "sin1080",
                        "content": "In English we do not call an empty string a word. Nor do we do so in other natural languages / programming languages."
                    },
                    {
                        "username": "oneguywithacat",
                        "content": "The description asks for a O(sum of words[i].length) solution but that doesn\\'t consider the quadratic palindrome checks of the remainder of words after matching part of it with the reverse of another word. Is that complexity wrong, or is there a solution that is truly O(sum of words[i].length)?"
                    }
                ]
            },
            {
                "id": 1569086,
                "content": [
                    {
                        "username": "bodurovmahmud",
                        "content": "**I couldn\\'t believe someone wrote this test case.**\\nhttps://leetcode.com/submissions/detail/594315425/testcase/\\n\\n"
                    },
                    {
                        "username": "tanishq1204",
                        "content": "looks like starts in the night sky!\\n"
                    },
                    {
                        "username": "czeng",
                        "content": "The time complexity of the official solutions will be much worse than simple brute force in some edge test cases, most likely will trigger TLE.  Consider the following test case:\\n\\n[\"aaaaa...(repeat 149 times)**bc**aaaaa(repeat 149 times again)\", \"aaaaa...(repeat 149 times)**bb**aaaaa(repeat 149 times again)\",\"\"]\\n\\nNote this test case has only 3 elements, where the first one is not a palindrome, the second one is a very long palindrome, and the third one is empty (thus is also a palindrome, and will combine with the second one to form a valid output). The answer should be [[1,2],[2,1]].\\n\\nIn brute force the time complexity is O(n^2 x k) = O(3^2 x 300) = O(2700). But in both hashmap and trie solution the time complexity is O(n x k^2) = O(3 x 300^2) = O(270000), which is 100 times of the brute force solution.\\n\\nNow this single case may be ok for the timing of the online judge. But in an extreme scenario if there are 1000 such test cases input to the program, the total runtime will be significantly increased, most likely will trigger TLE.\\n\\nAnother interesting thing is it seems C++ is the primary victim of such timing judge. Sometimes if we just write a quick but dirty code without recycling the resources (e.g. the new TrieNode created during the trie building), the timing will be ok. But if we explicitly record all allocated resource and manually free them at the end of the program, the timing will exceed the limit of the online judge. This sounds very unreasonable -- the timing is too tight which discourages programmers to properly recycle the allocated resources. This maybe fine for Java but will be a disaster for C++ in realworld.\\n"
                    },
                    {
                        "username": "merc14",
                        "content": "For someone who has to find this solution after hearing the question, is it even possible to find a solution AND code it in 45 min\\n\\nfolks who got this in interview and got an offer, please let use know how far you went. Just trying to get an understanding of the expectation"
                    },
                    {
                        "username": "kurtkaiser",
                        "content": "The constraits need to be fixed. Example 3 for the problem directly conflicts with the stated constraints. \\n\\n![image](https://assets.leetcode.com/users/images/05062a1f-ee67-46ac-a5bf-bb4e9fb79346_1651346727.042557.png)\\n"
                    },
                    {
                        "username": "drkato",
                        "content": "My code is right in that it finds the correct indices, but I keep getting a \"too long to execute\" error. When I run the timing in my dev environment for their test case that fails, it take 675ms. Not extraordinary, but not bad either, so what gives? What are we aiming for, there is no feedback or definition at the beginning of the problem."
                    },
                    {
                        "username": "James2009",
                        "content": "The C function prototype is defined as:\\n\\nint** palindromePairs(char** words, int wordsSize, int** columnSizes, int* returnSize)\\n\\nWhy do we need to return a two dimensional array columnSizes? I suppose each (i, j) pair is just a one-dimensional array of int. If we do need to specify the size of each (i,j) pair, should we just copy [2,1] into columnSizes for returnSize times?\\n\\nThanks!"
                    },
                    {
                        "username": "Foristkirito",
                        "content": "the description in this problem is not clear. Judging from the answer, the the number of words is huge, so the O(n*k^2) is ok. but what if the length of each word is also huge?"
                    },
                    {
                        "username": "grvchik",
                        "content": "There was no time limit posted on this question\\nIs there a way the question posters also post the time limit along with problem"
                    },
                    {
                        "username": "sin1080",
                        "content": "In English we do not call an empty string a word. Nor do we do so in other natural languages / programming languages."
                    },
                    {
                        "username": "oneguywithacat",
                        "content": "The description asks for a O(sum of words[i].length) solution but that doesn\\'t consider the quadratic palindrome checks of the remainder of words after matching part of it with the reverse of another word. Is that complexity wrong, or is there a solution that is truly O(sum of words[i].length)?"
                    }
                ]
            },
            {
                "id": 1566782,
                "content": [
                    {
                        "username": "bodurovmahmud",
                        "content": "**I couldn\\'t believe someone wrote this test case.**\\nhttps://leetcode.com/submissions/detail/594315425/testcase/\\n\\n"
                    },
                    {
                        "username": "tanishq1204",
                        "content": "looks like starts in the night sky!\\n"
                    },
                    {
                        "username": "czeng",
                        "content": "The time complexity of the official solutions will be much worse than simple brute force in some edge test cases, most likely will trigger TLE.  Consider the following test case:\\n\\n[\"aaaaa...(repeat 149 times)**bc**aaaaa(repeat 149 times again)\", \"aaaaa...(repeat 149 times)**bb**aaaaa(repeat 149 times again)\",\"\"]\\n\\nNote this test case has only 3 elements, where the first one is not a palindrome, the second one is a very long palindrome, and the third one is empty (thus is also a palindrome, and will combine with the second one to form a valid output). The answer should be [[1,2],[2,1]].\\n\\nIn brute force the time complexity is O(n^2 x k) = O(3^2 x 300) = O(2700). But in both hashmap and trie solution the time complexity is O(n x k^2) = O(3 x 300^2) = O(270000), which is 100 times of the brute force solution.\\n\\nNow this single case may be ok for the timing of the online judge. But in an extreme scenario if there are 1000 such test cases input to the program, the total runtime will be significantly increased, most likely will trigger TLE.\\n\\nAnother interesting thing is it seems C++ is the primary victim of such timing judge. Sometimes if we just write a quick but dirty code without recycling the resources (e.g. the new TrieNode created during the trie building), the timing will be ok. But if we explicitly record all allocated resource and manually free them at the end of the program, the timing will exceed the limit of the online judge. This sounds very unreasonable -- the timing is too tight which discourages programmers to properly recycle the allocated resources. This maybe fine for Java but will be a disaster for C++ in realworld.\\n"
                    },
                    {
                        "username": "merc14",
                        "content": "For someone who has to find this solution after hearing the question, is it even possible to find a solution AND code it in 45 min\\n\\nfolks who got this in interview and got an offer, please let use know how far you went. Just trying to get an understanding of the expectation"
                    },
                    {
                        "username": "kurtkaiser",
                        "content": "The constraits need to be fixed. Example 3 for the problem directly conflicts with the stated constraints. \\n\\n![image](https://assets.leetcode.com/users/images/05062a1f-ee67-46ac-a5bf-bb4e9fb79346_1651346727.042557.png)\\n"
                    },
                    {
                        "username": "drkato",
                        "content": "My code is right in that it finds the correct indices, but I keep getting a \"too long to execute\" error. When I run the timing in my dev environment for their test case that fails, it take 675ms. Not extraordinary, but not bad either, so what gives? What are we aiming for, there is no feedback or definition at the beginning of the problem."
                    },
                    {
                        "username": "James2009",
                        "content": "The C function prototype is defined as:\\n\\nint** palindromePairs(char** words, int wordsSize, int** columnSizes, int* returnSize)\\n\\nWhy do we need to return a two dimensional array columnSizes? I suppose each (i, j) pair is just a one-dimensional array of int. If we do need to specify the size of each (i,j) pair, should we just copy [2,1] into columnSizes for returnSize times?\\n\\nThanks!"
                    },
                    {
                        "username": "Foristkirito",
                        "content": "the description in this problem is not clear. Judging from the answer, the the number of words is huge, so the O(n*k^2) is ok. but what if the length of each word is also huge?"
                    },
                    {
                        "username": "grvchik",
                        "content": "There was no time limit posted on this question\\nIs there a way the question posters also post the time limit along with problem"
                    },
                    {
                        "username": "sin1080",
                        "content": "In English we do not call an empty string a word. Nor do we do so in other natural languages / programming languages."
                    },
                    {
                        "username": "oneguywithacat",
                        "content": "The description asks for a O(sum of words[i].length) solution but that doesn\\'t consider the quadratic palindrome checks of the remainder of words after matching part of it with the reverse of another word. Is that complexity wrong, or is there a solution that is truly O(sum of words[i].length)?"
                    }
                ]
            },
            {
                "id": 1567252,
                "content": [
                    {
                        "username": "bodurovmahmud",
                        "content": "**I couldn\\'t believe someone wrote this test case.**\\nhttps://leetcode.com/submissions/detail/594315425/testcase/\\n\\n"
                    },
                    {
                        "username": "tanishq1204",
                        "content": "looks like starts in the night sky!\\n"
                    },
                    {
                        "username": "czeng",
                        "content": "The time complexity of the official solutions will be much worse than simple brute force in some edge test cases, most likely will trigger TLE.  Consider the following test case:\\n\\n[\"aaaaa...(repeat 149 times)**bc**aaaaa(repeat 149 times again)\", \"aaaaa...(repeat 149 times)**bb**aaaaa(repeat 149 times again)\",\"\"]\\n\\nNote this test case has only 3 elements, where the first one is not a palindrome, the second one is a very long palindrome, and the third one is empty (thus is also a palindrome, and will combine with the second one to form a valid output). The answer should be [[1,2],[2,1]].\\n\\nIn brute force the time complexity is O(n^2 x k) = O(3^2 x 300) = O(2700). But in both hashmap and trie solution the time complexity is O(n x k^2) = O(3 x 300^2) = O(270000), which is 100 times of the brute force solution.\\n\\nNow this single case may be ok for the timing of the online judge. But in an extreme scenario if there are 1000 such test cases input to the program, the total runtime will be significantly increased, most likely will trigger TLE.\\n\\nAnother interesting thing is it seems C++ is the primary victim of such timing judge. Sometimes if we just write a quick but dirty code without recycling the resources (e.g. the new TrieNode created during the trie building), the timing will be ok. But if we explicitly record all allocated resource and manually free them at the end of the program, the timing will exceed the limit of the online judge. This sounds very unreasonable -- the timing is too tight which discourages programmers to properly recycle the allocated resources. This maybe fine for Java but will be a disaster for C++ in realworld.\\n"
                    },
                    {
                        "username": "merc14",
                        "content": "For someone who has to find this solution after hearing the question, is it even possible to find a solution AND code it in 45 min\\n\\nfolks who got this in interview and got an offer, please let use know how far you went. Just trying to get an understanding of the expectation"
                    },
                    {
                        "username": "kurtkaiser",
                        "content": "The constraits need to be fixed. Example 3 for the problem directly conflicts with the stated constraints. \\n\\n![image](https://assets.leetcode.com/users/images/05062a1f-ee67-46ac-a5bf-bb4e9fb79346_1651346727.042557.png)\\n"
                    },
                    {
                        "username": "drkato",
                        "content": "My code is right in that it finds the correct indices, but I keep getting a \"too long to execute\" error. When I run the timing in my dev environment for their test case that fails, it take 675ms. Not extraordinary, but not bad either, so what gives? What are we aiming for, there is no feedback or definition at the beginning of the problem."
                    },
                    {
                        "username": "James2009",
                        "content": "The C function prototype is defined as:\\n\\nint** palindromePairs(char** words, int wordsSize, int** columnSizes, int* returnSize)\\n\\nWhy do we need to return a two dimensional array columnSizes? I suppose each (i, j) pair is just a one-dimensional array of int. If we do need to specify the size of each (i,j) pair, should we just copy [2,1] into columnSizes for returnSize times?\\n\\nThanks!"
                    },
                    {
                        "username": "Foristkirito",
                        "content": "the description in this problem is not clear. Judging from the answer, the the number of words is huge, so the O(n*k^2) is ok. but what if the length of each word is also huge?"
                    },
                    {
                        "username": "grvchik",
                        "content": "There was no time limit posted on this question\\nIs there a way the question posters also post the time limit along with problem"
                    },
                    {
                        "username": "sin1080",
                        "content": "In English we do not call an empty string a word. Nor do we do so in other natural languages / programming languages."
                    },
                    {
                        "username": "oneguywithacat",
                        "content": "The description asks for a O(sum of words[i].length) solution but that doesn\\'t consider the quadratic palindrome checks of the remainder of words after matching part of it with the reverse of another word. Is that complexity wrong, or is there a solution that is truly O(sum of words[i].length)?"
                    }
                ]
            },
            {
                "id": 1567959,
                "content": [
                    {
                        "username": "bodurovmahmud",
                        "content": "**I couldn\\'t believe someone wrote this test case.**\\nhttps://leetcode.com/submissions/detail/594315425/testcase/\\n\\n"
                    },
                    {
                        "username": "tanishq1204",
                        "content": "looks like starts in the night sky!\\n"
                    },
                    {
                        "username": "czeng",
                        "content": "The time complexity of the official solutions will be much worse than simple brute force in some edge test cases, most likely will trigger TLE.  Consider the following test case:\\n\\n[\"aaaaa...(repeat 149 times)**bc**aaaaa(repeat 149 times again)\", \"aaaaa...(repeat 149 times)**bb**aaaaa(repeat 149 times again)\",\"\"]\\n\\nNote this test case has only 3 elements, where the first one is not a palindrome, the second one is a very long palindrome, and the third one is empty (thus is also a palindrome, and will combine with the second one to form a valid output). The answer should be [[1,2],[2,1]].\\n\\nIn brute force the time complexity is O(n^2 x k) = O(3^2 x 300) = O(2700). But in both hashmap and trie solution the time complexity is O(n x k^2) = O(3 x 300^2) = O(270000), which is 100 times of the brute force solution.\\n\\nNow this single case may be ok for the timing of the online judge. But in an extreme scenario if there are 1000 such test cases input to the program, the total runtime will be significantly increased, most likely will trigger TLE.\\n\\nAnother interesting thing is it seems C++ is the primary victim of such timing judge. Sometimes if we just write a quick but dirty code without recycling the resources (e.g. the new TrieNode created during the trie building), the timing will be ok. But if we explicitly record all allocated resource and manually free them at the end of the program, the timing will exceed the limit of the online judge. This sounds very unreasonable -- the timing is too tight which discourages programmers to properly recycle the allocated resources. This maybe fine for Java but will be a disaster for C++ in realworld.\\n"
                    },
                    {
                        "username": "merc14",
                        "content": "For someone who has to find this solution after hearing the question, is it even possible to find a solution AND code it in 45 min\\n\\nfolks who got this in interview and got an offer, please let use know how far you went. Just trying to get an understanding of the expectation"
                    },
                    {
                        "username": "kurtkaiser",
                        "content": "The constraits need to be fixed. Example 3 for the problem directly conflicts with the stated constraints. \\n\\n![image](https://assets.leetcode.com/users/images/05062a1f-ee67-46ac-a5bf-bb4e9fb79346_1651346727.042557.png)\\n"
                    },
                    {
                        "username": "drkato",
                        "content": "My code is right in that it finds the correct indices, but I keep getting a \"too long to execute\" error. When I run the timing in my dev environment for their test case that fails, it take 675ms. Not extraordinary, but not bad either, so what gives? What are we aiming for, there is no feedback or definition at the beginning of the problem."
                    },
                    {
                        "username": "James2009",
                        "content": "The C function prototype is defined as:\\n\\nint** palindromePairs(char** words, int wordsSize, int** columnSizes, int* returnSize)\\n\\nWhy do we need to return a two dimensional array columnSizes? I suppose each (i, j) pair is just a one-dimensional array of int. If we do need to specify the size of each (i,j) pair, should we just copy [2,1] into columnSizes for returnSize times?\\n\\nThanks!"
                    },
                    {
                        "username": "Foristkirito",
                        "content": "the description in this problem is not clear. Judging from the answer, the the number of words is huge, so the O(n*k^2) is ok. but what if the length of each word is also huge?"
                    },
                    {
                        "username": "grvchik",
                        "content": "There was no time limit posted on this question\\nIs there a way the question posters also post the time limit along with problem"
                    },
                    {
                        "username": "sin1080",
                        "content": "In English we do not call an empty string a word. Nor do we do so in other natural languages / programming languages."
                    },
                    {
                        "username": "oneguywithacat",
                        "content": "The description asks for a O(sum of words[i].length) solution but that doesn\\'t consider the quadratic palindrome checks of the remainder of words after matching part of it with the reverse of another word. Is that complexity wrong, or is there a solution that is truly O(sum of words[i].length)?"
                    }
                ]
            },
            {
                "id": 1572717,
                "content": [
                    {
                        "username": "bodurovmahmud",
                        "content": "**I couldn\\'t believe someone wrote this test case.**\\nhttps://leetcode.com/submissions/detail/594315425/testcase/\\n\\n"
                    },
                    {
                        "username": "tanishq1204",
                        "content": "looks like starts in the night sky!\\n"
                    },
                    {
                        "username": "czeng",
                        "content": "The time complexity of the official solutions will be much worse than simple brute force in some edge test cases, most likely will trigger TLE.  Consider the following test case:\\n\\n[\"aaaaa...(repeat 149 times)**bc**aaaaa(repeat 149 times again)\", \"aaaaa...(repeat 149 times)**bb**aaaaa(repeat 149 times again)\",\"\"]\\n\\nNote this test case has only 3 elements, where the first one is not a palindrome, the second one is a very long palindrome, and the third one is empty (thus is also a palindrome, and will combine with the second one to form a valid output). The answer should be [[1,2],[2,1]].\\n\\nIn brute force the time complexity is O(n^2 x k) = O(3^2 x 300) = O(2700). But in both hashmap and trie solution the time complexity is O(n x k^2) = O(3 x 300^2) = O(270000), which is 100 times of the brute force solution.\\n\\nNow this single case may be ok for the timing of the online judge. But in an extreme scenario if there are 1000 such test cases input to the program, the total runtime will be significantly increased, most likely will trigger TLE.\\n\\nAnother interesting thing is it seems C++ is the primary victim of such timing judge. Sometimes if we just write a quick but dirty code without recycling the resources (e.g. the new TrieNode created during the trie building), the timing will be ok. But if we explicitly record all allocated resource and manually free them at the end of the program, the timing will exceed the limit of the online judge. This sounds very unreasonable -- the timing is too tight which discourages programmers to properly recycle the allocated resources. This maybe fine for Java but will be a disaster for C++ in realworld.\\n"
                    },
                    {
                        "username": "merc14",
                        "content": "For someone who has to find this solution after hearing the question, is it even possible to find a solution AND code it in 45 min\\n\\nfolks who got this in interview and got an offer, please let use know how far you went. Just trying to get an understanding of the expectation"
                    },
                    {
                        "username": "kurtkaiser",
                        "content": "The constraits need to be fixed. Example 3 for the problem directly conflicts with the stated constraints. \\n\\n![image](https://assets.leetcode.com/users/images/05062a1f-ee67-46ac-a5bf-bb4e9fb79346_1651346727.042557.png)\\n"
                    },
                    {
                        "username": "drkato",
                        "content": "My code is right in that it finds the correct indices, but I keep getting a \"too long to execute\" error. When I run the timing in my dev environment for their test case that fails, it take 675ms. Not extraordinary, but not bad either, so what gives? What are we aiming for, there is no feedback or definition at the beginning of the problem."
                    },
                    {
                        "username": "James2009",
                        "content": "The C function prototype is defined as:\\n\\nint** palindromePairs(char** words, int wordsSize, int** columnSizes, int* returnSize)\\n\\nWhy do we need to return a two dimensional array columnSizes? I suppose each (i, j) pair is just a one-dimensional array of int. If we do need to specify the size of each (i,j) pair, should we just copy [2,1] into columnSizes for returnSize times?\\n\\nThanks!"
                    },
                    {
                        "username": "Foristkirito",
                        "content": "the description in this problem is not clear. Judging from the answer, the the number of words is huge, so the O(n*k^2) is ok. but what if the length of each word is also huge?"
                    },
                    {
                        "username": "grvchik",
                        "content": "There was no time limit posted on this question\\nIs there a way the question posters also post the time limit along with problem"
                    },
                    {
                        "username": "sin1080",
                        "content": "In English we do not call an empty string a word. Nor do we do so in other natural languages / programming languages."
                    },
                    {
                        "username": "oneguywithacat",
                        "content": "The description asks for a O(sum of words[i].length) solution but that doesn\\'t consider the quadratic palindrome checks of the remainder of words after matching part of it with the reverse of another word. Is that complexity wrong, or is there a solution that is truly O(sum of words[i].length)?"
                    }
                ]
            },
            {
                "id": 2033006,
                "content": [
                    {
                        "username": "bodurovmahmud",
                        "content": "**I couldn\\'t believe someone wrote this test case.**\\nhttps://leetcode.com/submissions/detail/594315425/testcase/\\n\\n"
                    },
                    {
                        "username": "tanishq1204",
                        "content": "looks like starts in the night sky!\\n"
                    },
                    {
                        "username": "czeng",
                        "content": "The time complexity of the official solutions will be much worse than simple brute force in some edge test cases, most likely will trigger TLE.  Consider the following test case:\\n\\n[\"aaaaa...(repeat 149 times)**bc**aaaaa(repeat 149 times again)\", \"aaaaa...(repeat 149 times)**bb**aaaaa(repeat 149 times again)\",\"\"]\\n\\nNote this test case has only 3 elements, where the first one is not a palindrome, the second one is a very long palindrome, and the third one is empty (thus is also a palindrome, and will combine with the second one to form a valid output). The answer should be [[1,2],[2,1]].\\n\\nIn brute force the time complexity is O(n^2 x k) = O(3^2 x 300) = O(2700). But in both hashmap and trie solution the time complexity is O(n x k^2) = O(3 x 300^2) = O(270000), which is 100 times of the brute force solution.\\n\\nNow this single case may be ok for the timing of the online judge. But in an extreme scenario if there are 1000 such test cases input to the program, the total runtime will be significantly increased, most likely will trigger TLE.\\n\\nAnother interesting thing is it seems C++ is the primary victim of such timing judge. Sometimes if we just write a quick but dirty code without recycling the resources (e.g. the new TrieNode created during the trie building), the timing will be ok. But if we explicitly record all allocated resource and manually free them at the end of the program, the timing will exceed the limit of the online judge. This sounds very unreasonable -- the timing is too tight which discourages programmers to properly recycle the allocated resources. This maybe fine for Java but will be a disaster for C++ in realworld.\\n"
                    },
                    {
                        "username": "merc14",
                        "content": "For someone who has to find this solution after hearing the question, is it even possible to find a solution AND code it in 45 min\\n\\nfolks who got this in interview and got an offer, please let use know how far you went. Just trying to get an understanding of the expectation"
                    },
                    {
                        "username": "kurtkaiser",
                        "content": "The constraits need to be fixed. Example 3 for the problem directly conflicts with the stated constraints. \\n\\n![image](https://assets.leetcode.com/users/images/05062a1f-ee67-46ac-a5bf-bb4e9fb79346_1651346727.042557.png)\\n"
                    },
                    {
                        "username": "drkato",
                        "content": "My code is right in that it finds the correct indices, but I keep getting a \"too long to execute\" error. When I run the timing in my dev environment for their test case that fails, it take 675ms. Not extraordinary, but not bad either, so what gives? What are we aiming for, there is no feedback or definition at the beginning of the problem."
                    },
                    {
                        "username": "James2009",
                        "content": "The C function prototype is defined as:\\n\\nint** palindromePairs(char** words, int wordsSize, int** columnSizes, int* returnSize)\\n\\nWhy do we need to return a two dimensional array columnSizes? I suppose each (i, j) pair is just a one-dimensional array of int. If we do need to specify the size of each (i,j) pair, should we just copy [2,1] into columnSizes for returnSize times?\\n\\nThanks!"
                    },
                    {
                        "username": "Foristkirito",
                        "content": "the description in this problem is not clear. Judging from the answer, the the number of words is huge, so the O(n*k^2) is ok. but what if the length of each word is also huge?"
                    },
                    {
                        "username": "grvchik",
                        "content": "There was no time limit posted on this question\\nIs there a way the question posters also post the time limit along with problem"
                    },
                    {
                        "username": "sin1080",
                        "content": "In English we do not call an empty string a word. Nor do we do so in other natural languages / programming languages."
                    },
                    {
                        "username": "oneguywithacat",
                        "content": "The description asks for a O(sum of words[i].length) solution but that doesn\\'t consider the quadratic palindrome checks of the remainder of words after matching part of it with the reverse of another word. Is that complexity wrong, or is there a solution that is truly O(sum of words[i].length)?"
                    }
                ]
            },
            {
                "id": 1566409,
                "content": [
                    {
                        "username": "bodurovmahmud",
                        "content": "**I couldn\\'t believe someone wrote this test case.**\\nhttps://leetcode.com/submissions/detail/594315425/testcase/\\n\\n"
                    },
                    {
                        "username": "tanishq1204",
                        "content": "looks like starts in the night sky!\\n"
                    },
                    {
                        "username": "czeng",
                        "content": "The time complexity of the official solutions will be much worse than simple brute force in some edge test cases, most likely will trigger TLE.  Consider the following test case:\\n\\n[\"aaaaa...(repeat 149 times)**bc**aaaaa(repeat 149 times again)\", \"aaaaa...(repeat 149 times)**bb**aaaaa(repeat 149 times again)\",\"\"]\\n\\nNote this test case has only 3 elements, where the first one is not a palindrome, the second one is a very long palindrome, and the third one is empty (thus is also a palindrome, and will combine with the second one to form a valid output). The answer should be [[1,2],[2,1]].\\n\\nIn brute force the time complexity is O(n^2 x k) = O(3^2 x 300) = O(2700). But in both hashmap and trie solution the time complexity is O(n x k^2) = O(3 x 300^2) = O(270000), which is 100 times of the brute force solution.\\n\\nNow this single case may be ok for the timing of the online judge. But in an extreme scenario if there are 1000 such test cases input to the program, the total runtime will be significantly increased, most likely will trigger TLE.\\n\\nAnother interesting thing is it seems C++ is the primary victim of such timing judge. Sometimes if we just write a quick but dirty code without recycling the resources (e.g. the new TrieNode created during the trie building), the timing will be ok. But if we explicitly record all allocated resource and manually free them at the end of the program, the timing will exceed the limit of the online judge. This sounds very unreasonable -- the timing is too tight which discourages programmers to properly recycle the allocated resources. This maybe fine for Java but will be a disaster for C++ in realworld.\\n"
                    },
                    {
                        "username": "merc14",
                        "content": "For someone who has to find this solution after hearing the question, is it even possible to find a solution AND code it in 45 min\\n\\nfolks who got this in interview and got an offer, please let use know how far you went. Just trying to get an understanding of the expectation"
                    },
                    {
                        "username": "kurtkaiser",
                        "content": "The constraits need to be fixed. Example 3 for the problem directly conflicts with the stated constraints. \\n\\n![image](https://assets.leetcode.com/users/images/05062a1f-ee67-46ac-a5bf-bb4e9fb79346_1651346727.042557.png)\\n"
                    },
                    {
                        "username": "drkato",
                        "content": "My code is right in that it finds the correct indices, but I keep getting a \"too long to execute\" error. When I run the timing in my dev environment for their test case that fails, it take 675ms. Not extraordinary, but not bad either, so what gives? What are we aiming for, there is no feedback or definition at the beginning of the problem."
                    },
                    {
                        "username": "James2009",
                        "content": "The C function prototype is defined as:\\n\\nint** palindromePairs(char** words, int wordsSize, int** columnSizes, int* returnSize)\\n\\nWhy do we need to return a two dimensional array columnSizes? I suppose each (i, j) pair is just a one-dimensional array of int. If we do need to specify the size of each (i,j) pair, should we just copy [2,1] into columnSizes for returnSize times?\\n\\nThanks!"
                    },
                    {
                        "username": "Foristkirito",
                        "content": "the description in this problem is not clear. Judging from the answer, the the number of words is huge, so the O(n*k^2) is ok. but what if the length of each word is also huge?"
                    },
                    {
                        "username": "grvchik",
                        "content": "There was no time limit posted on this question\\nIs there a way the question posters also post the time limit along with problem"
                    },
                    {
                        "username": "sin1080",
                        "content": "In English we do not call an empty string a word. Nor do we do so in other natural languages / programming languages."
                    },
                    {
                        "username": "oneguywithacat",
                        "content": "The description asks for a O(sum of words[i].length) solution but that doesn\\'t consider the quadratic palindrome checks of the remainder of words after matching part of it with the reverse of another word. Is that complexity wrong, or is there a solution that is truly O(sum of words[i].length)?"
                    }
                ]
            },
            {
                "id": 1566204,
                "content": [
                    {
                        "username": "bodurovmahmud",
                        "content": "**I couldn\\'t believe someone wrote this test case.**\\nhttps://leetcode.com/submissions/detail/594315425/testcase/\\n\\n"
                    },
                    {
                        "username": "tanishq1204",
                        "content": "looks like starts in the night sky!\\n"
                    },
                    {
                        "username": "czeng",
                        "content": "The time complexity of the official solutions will be much worse than simple brute force in some edge test cases, most likely will trigger TLE.  Consider the following test case:\\n\\n[\"aaaaa...(repeat 149 times)**bc**aaaaa(repeat 149 times again)\", \"aaaaa...(repeat 149 times)**bb**aaaaa(repeat 149 times again)\",\"\"]\\n\\nNote this test case has only 3 elements, where the first one is not a palindrome, the second one is a very long palindrome, and the third one is empty (thus is also a palindrome, and will combine with the second one to form a valid output). The answer should be [[1,2],[2,1]].\\n\\nIn brute force the time complexity is O(n^2 x k) = O(3^2 x 300) = O(2700). But in both hashmap and trie solution the time complexity is O(n x k^2) = O(3 x 300^2) = O(270000), which is 100 times of the brute force solution.\\n\\nNow this single case may be ok for the timing of the online judge. But in an extreme scenario if there are 1000 such test cases input to the program, the total runtime will be significantly increased, most likely will trigger TLE.\\n\\nAnother interesting thing is it seems C++ is the primary victim of such timing judge. Sometimes if we just write a quick but dirty code without recycling the resources (e.g. the new TrieNode created during the trie building), the timing will be ok. But if we explicitly record all allocated resource and manually free them at the end of the program, the timing will exceed the limit of the online judge. This sounds very unreasonable -- the timing is too tight which discourages programmers to properly recycle the allocated resources. This maybe fine for Java but will be a disaster for C++ in realworld.\\n"
                    },
                    {
                        "username": "merc14",
                        "content": "For someone who has to find this solution after hearing the question, is it even possible to find a solution AND code it in 45 min\\n\\nfolks who got this in interview and got an offer, please let use know how far you went. Just trying to get an understanding of the expectation"
                    },
                    {
                        "username": "kurtkaiser",
                        "content": "The constraits need to be fixed. Example 3 for the problem directly conflicts with the stated constraints. \\n\\n![image](https://assets.leetcode.com/users/images/05062a1f-ee67-46ac-a5bf-bb4e9fb79346_1651346727.042557.png)\\n"
                    },
                    {
                        "username": "drkato",
                        "content": "My code is right in that it finds the correct indices, but I keep getting a \"too long to execute\" error. When I run the timing in my dev environment for their test case that fails, it take 675ms. Not extraordinary, but not bad either, so what gives? What are we aiming for, there is no feedback or definition at the beginning of the problem."
                    },
                    {
                        "username": "James2009",
                        "content": "The C function prototype is defined as:\\n\\nint** palindromePairs(char** words, int wordsSize, int** columnSizes, int* returnSize)\\n\\nWhy do we need to return a two dimensional array columnSizes? I suppose each (i, j) pair is just a one-dimensional array of int. If we do need to specify the size of each (i,j) pair, should we just copy [2,1] into columnSizes for returnSize times?\\n\\nThanks!"
                    },
                    {
                        "username": "Foristkirito",
                        "content": "the description in this problem is not clear. Judging from the answer, the the number of words is huge, so the O(n*k^2) is ok. but what if the length of each word is also huge?"
                    },
                    {
                        "username": "grvchik",
                        "content": "There was no time limit posted on this question\\nIs there a way the question posters also post the time limit along with problem"
                    },
                    {
                        "username": "sin1080",
                        "content": "In English we do not call an empty string a word. Nor do we do so in other natural languages / programming languages."
                    },
                    {
                        "username": "oneguywithacat",
                        "content": "The description asks for a O(sum of words[i].length) solution but that doesn\\'t consider the quadratic palindrome checks of the remainder of words after matching part of it with the reverse of another word. Is that complexity wrong, or is there a solution that is truly O(sum of words[i].length)?"
                    }
                ]
            },
            {
                "id": 1569510,
                "content": [
                    {
                        "username": "bodurovmahmud",
                        "content": "**I couldn\\'t believe someone wrote this test case.**\\nhttps://leetcode.com/submissions/detail/594315425/testcase/\\n\\n"
                    },
                    {
                        "username": "tanishq1204",
                        "content": "looks like starts in the night sky!\\n"
                    },
                    {
                        "username": "czeng",
                        "content": "The time complexity of the official solutions will be much worse than simple brute force in some edge test cases, most likely will trigger TLE.  Consider the following test case:\\n\\n[\"aaaaa...(repeat 149 times)**bc**aaaaa(repeat 149 times again)\", \"aaaaa...(repeat 149 times)**bb**aaaaa(repeat 149 times again)\",\"\"]\\n\\nNote this test case has only 3 elements, where the first one is not a palindrome, the second one is a very long palindrome, and the third one is empty (thus is also a palindrome, and will combine with the second one to form a valid output). The answer should be [[1,2],[2,1]].\\n\\nIn brute force the time complexity is O(n^2 x k) = O(3^2 x 300) = O(2700). But in both hashmap and trie solution the time complexity is O(n x k^2) = O(3 x 300^2) = O(270000), which is 100 times of the brute force solution.\\n\\nNow this single case may be ok for the timing of the online judge. But in an extreme scenario if there are 1000 such test cases input to the program, the total runtime will be significantly increased, most likely will trigger TLE.\\n\\nAnother interesting thing is it seems C++ is the primary victim of such timing judge. Sometimes if we just write a quick but dirty code without recycling the resources (e.g. the new TrieNode created during the trie building), the timing will be ok. But if we explicitly record all allocated resource and manually free them at the end of the program, the timing will exceed the limit of the online judge. This sounds very unreasonable -- the timing is too tight which discourages programmers to properly recycle the allocated resources. This maybe fine for Java but will be a disaster for C++ in realworld.\\n"
                    },
                    {
                        "username": "merc14",
                        "content": "For someone who has to find this solution after hearing the question, is it even possible to find a solution AND code it in 45 min\\n\\nfolks who got this in interview and got an offer, please let use know how far you went. Just trying to get an understanding of the expectation"
                    },
                    {
                        "username": "kurtkaiser",
                        "content": "The constraits need to be fixed. Example 3 for the problem directly conflicts with the stated constraints. \\n\\n![image](https://assets.leetcode.com/users/images/05062a1f-ee67-46ac-a5bf-bb4e9fb79346_1651346727.042557.png)\\n"
                    },
                    {
                        "username": "drkato",
                        "content": "My code is right in that it finds the correct indices, but I keep getting a \"too long to execute\" error. When I run the timing in my dev environment for their test case that fails, it take 675ms. Not extraordinary, but not bad either, so what gives? What are we aiming for, there is no feedback or definition at the beginning of the problem."
                    },
                    {
                        "username": "James2009",
                        "content": "The C function prototype is defined as:\\n\\nint** palindromePairs(char** words, int wordsSize, int** columnSizes, int* returnSize)\\n\\nWhy do we need to return a two dimensional array columnSizes? I suppose each (i, j) pair is just a one-dimensional array of int. If we do need to specify the size of each (i,j) pair, should we just copy [2,1] into columnSizes for returnSize times?\\n\\nThanks!"
                    },
                    {
                        "username": "Foristkirito",
                        "content": "the description in this problem is not clear. Judging from the answer, the the number of words is huge, so the O(n*k^2) is ok. but what if the length of each word is also huge?"
                    },
                    {
                        "username": "grvchik",
                        "content": "There was no time limit posted on this question\\nIs there a way the question posters also post the time limit along with problem"
                    },
                    {
                        "username": "sin1080",
                        "content": "In English we do not call an empty string a word. Nor do we do so in other natural languages / programming languages."
                    },
                    {
                        "username": "oneguywithacat",
                        "content": "The description asks for a O(sum of words[i].length) solution but that doesn\\'t consider the quadratic palindrome checks of the remainder of words after matching part of it with the reverse of another word. Is that complexity wrong, or is there a solution that is truly O(sum of words[i].length)?"
                    }
                ]
            },
            {
                "id": 1576695,
                "content": [
                    {
                        "username": "bodurovmahmud",
                        "content": "**I couldn\\'t believe someone wrote this test case.**\\nhttps://leetcode.com/submissions/detail/594315425/testcase/\\n\\n"
                    },
                    {
                        "username": "tanishq1204",
                        "content": "looks like starts in the night sky!\\n"
                    },
                    {
                        "username": "czeng",
                        "content": "The time complexity of the official solutions will be much worse than simple brute force in some edge test cases, most likely will trigger TLE.  Consider the following test case:\\n\\n[\"aaaaa...(repeat 149 times)**bc**aaaaa(repeat 149 times again)\", \"aaaaa...(repeat 149 times)**bb**aaaaa(repeat 149 times again)\",\"\"]\\n\\nNote this test case has only 3 elements, where the first one is not a palindrome, the second one is a very long palindrome, and the third one is empty (thus is also a palindrome, and will combine with the second one to form a valid output). The answer should be [[1,2],[2,1]].\\n\\nIn brute force the time complexity is O(n^2 x k) = O(3^2 x 300) = O(2700). But in both hashmap and trie solution the time complexity is O(n x k^2) = O(3 x 300^2) = O(270000), which is 100 times of the brute force solution.\\n\\nNow this single case may be ok for the timing of the online judge. But in an extreme scenario if there are 1000 such test cases input to the program, the total runtime will be significantly increased, most likely will trigger TLE.\\n\\nAnother interesting thing is it seems C++ is the primary victim of such timing judge. Sometimes if we just write a quick but dirty code without recycling the resources (e.g. the new TrieNode created during the trie building), the timing will be ok. But if we explicitly record all allocated resource and manually free them at the end of the program, the timing will exceed the limit of the online judge. This sounds very unreasonable -- the timing is too tight which discourages programmers to properly recycle the allocated resources. This maybe fine for Java but will be a disaster for C++ in realworld.\\n"
                    },
                    {
                        "username": "merc14",
                        "content": "For someone who has to find this solution after hearing the question, is it even possible to find a solution AND code it in 45 min\\n\\nfolks who got this in interview and got an offer, please let use know how far you went. Just trying to get an understanding of the expectation"
                    },
                    {
                        "username": "kurtkaiser",
                        "content": "The constraits need to be fixed. Example 3 for the problem directly conflicts with the stated constraints. \\n\\n![image](https://assets.leetcode.com/users/images/05062a1f-ee67-46ac-a5bf-bb4e9fb79346_1651346727.042557.png)\\n"
                    },
                    {
                        "username": "drkato",
                        "content": "My code is right in that it finds the correct indices, but I keep getting a \"too long to execute\" error. When I run the timing in my dev environment for their test case that fails, it take 675ms. Not extraordinary, but not bad either, so what gives? What are we aiming for, there is no feedback or definition at the beginning of the problem."
                    },
                    {
                        "username": "James2009",
                        "content": "The C function prototype is defined as:\\n\\nint** palindromePairs(char** words, int wordsSize, int** columnSizes, int* returnSize)\\n\\nWhy do we need to return a two dimensional array columnSizes? I suppose each (i, j) pair is just a one-dimensional array of int. If we do need to specify the size of each (i,j) pair, should we just copy [2,1] into columnSizes for returnSize times?\\n\\nThanks!"
                    },
                    {
                        "username": "Foristkirito",
                        "content": "the description in this problem is not clear. Judging from the answer, the the number of words is huge, so the O(n*k^2) is ok. but what if the length of each word is also huge?"
                    },
                    {
                        "username": "grvchik",
                        "content": "There was no time limit posted on this question\\nIs there a way the question posters also post the time limit along with problem"
                    },
                    {
                        "username": "sin1080",
                        "content": "In English we do not call an empty string a word. Nor do we do so in other natural languages / programming languages."
                    },
                    {
                        "username": "oneguywithacat",
                        "content": "The description asks for a O(sum of words[i].length) solution but that doesn\\'t consider the quadratic palindrome checks of the remainder of words after matching part of it with the reverse of another word. Is that complexity wrong, or is there a solution that is truly O(sum of words[i].length)?"
                    }
                ]
            },
            {
                "id": 1569086,
                "content": [
                    {
                        "username": "bodurovmahmud",
                        "content": "**I couldn\\'t believe someone wrote this test case.**\\nhttps://leetcode.com/submissions/detail/594315425/testcase/\\n\\n"
                    },
                    {
                        "username": "tanishq1204",
                        "content": "looks like starts in the night sky!\\n"
                    },
                    {
                        "username": "czeng",
                        "content": "The time complexity of the official solutions will be much worse than simple brute force in some edge test cases, most likely will trigger TLE.  Consider the following test case:\\n\\n[\"aaaaa...(repeat 149 times)**bc**aaaaa(repeat 149 times again)\", \"aaaaa...(repeat 149 times)**bb**aaaaa(repeat 149 times again)\",\"\"]\\n\\nNote this test case has only 3 elements, where the first one is not a palindrome, the second one is a very long palindrome, and the third one is empty (thus is also a palindrome, and will combine with the second one to form a valid output). The answer should be [[1,2],[2,1]].\\n\\nIn brute force the time complexity is O(n^2 x k) = O(3^2 x 300) = O(2700). But in both hashmap and trie solution the time complexity is O(n x k^2) = O(3 x 300^2) = O(270000), which is 100 times of the brute force solution.\\n\\nNow this single case may be ok for the timing of the online judge. But in an extreme scenario if there are 1000 such test cases input to the program, the total runtime will be significantly increased, most likely will trigger TLE.\\n\\nAnother interesting thing is it seems C++ is the primary victim of such timing judge. Sometimes if we just write a quick but dirty code without recycling the resources (e.g. the new TrieNode created during the trie building), the timing will be ok. But if we explicitly record all allocated resource and manually free them at the end of the program, the timing will exceed the limit of the online judge. This sounds very unreasonable -- the timing is too tight which discourages programmers to properly recycle the allocated resources. This maybe fine for Java but will be a disaster for C++ in realworld.\\n"
                    },
                    {
                        "username": "merc14",
                        "content": "For someone who has to find this solution after hearing the question, is it even possible to find a solution AND code it in 45 min\\n\\nfolks who got this in interview and got an offer, please let use know how far you went. Just trying to get an understanding of the expectation"
                    },
                    {
                        "username": "kurtkaiser",
                        "content": "The constraits need to be fixed. Example 3 for the problem directly conflicts with the stated constraints. \\n\\n![image](https://assets.leetcode.com/users/images/05062a1f-ee67-46ac-a5bf-bb4e9fb79346_1651346727.042557.png)\\n"
                    },
                    {
                        "username": "drkato",
                        "content": "My code is right in that it finds the correct indices, but I keep getting a \"too long to execute\" error. When I run the timing in my dev environment for their test case that fails, it take 675ms. Not extraordinary, but not bad either, so what gives? What are we aiming for, there is no feedback or definition at the beginning of the problem."
                    },
                    {
                        "username": "James2009",
                        "content": "The C function prototype is defined as:\\n\\nint** palindromePairs(char** words, int wordsSize, int** columnSizes, int* returnSize)\\n\\nWhy do we need to return a two dimensional array columnSizes? I suppose each (i, j) pair is just a one-dimensional array of int. If we do need to specify the size of each (i,j) pair, should we just copy [2,1] into columnSizes for returnSize times?\\n\\nThanks!"
                    },
                    {
                        "username": "Foristkirito",
                        "content": "the description in this problem is not clear. Judging from the answer, the the number of words is huge, so the O(n*k^2) is ok. but what if the length of each word is also huge?"
                    },
                    {
                        "username": "grvchik",
                        "content": "There was no time limit posted on this question\\nIs there a way the question posters also post the time limit along with problem"
                    },
                    {
                        "username": "sin1080",
                        "content": "In English we do not call an empty string a word. Nor do we do so in other natural languages / programming languages."
                    },
                    {
                        "username": "oneguywithacat",
                        "content": "The description asks for a O(sum of words[i].length) solution but that doesn\\'t consider the quadratic palindrome checks of the remainder of words after matching part of it with the reverse of another word. Is that complexity wrong, or is there a solution that is truly O(sum of words[i].length)?"
                    }
                ]
            },
            {
                "id": 1566782,
                "content": [
                    {
                        "username": "bodurovmahmud",
                        "content": "**I couldn\\'t believe someone wrote this test case.**\\nhttps://leetcode.com/submissions/detail/594315425/testcase/\\n\\n"
                    },
                    {
                        "username": "tanishq1204",
                        "content": "looks like starts in the night sky!\\n"
                    },
                    {
                        "username": "czeng",
                        "content": "The time complexity of the official solutions will be much worse than simple brute force in some edge test cases, most likely will trigger TLE.  Consider the following test case:\\n\\n[\"aaaaa...(repeat 149 times)**bc**aaaaa(repeat 149 times again)\", \"aaaaa...(repeat 149 times)**bb**aaaaa(repeat 149 times again)\",\"\"]\\n\\nNote this test case has only 3 elements, where the first one is not a palindrome, the second one is a very long palindrome, and the third one is empty (thus is also a palindrome, and will combine with the second one to form a valid output). The answer should be [[1,2],[2,1]].\\n\\nIn brute force the time complexity is O(n^2 x k) = O(3^2 x 300) = O(2700). But in both hashmap and trie solution the time complexity is O(n x k^2) = O(3 x 300^2) = O(270000), which is 100 times of the brute force solution.\\n\\nNow this single case may be ok for the timing of the online judge. But in an extreme scenario if there are 1000 such test cases input to the program, the total runtime will be significantly increased, most likely will trigger TLE.\\n\\nAnother interesting thing is it seems C++ is the primary victim of such timing judge. Sometimes if we just write a quick but dirty code without recycling the resources (e.g. the new TrieNode created during the trie building), the timing will be ok. But if we explicitly record all allocated resource and manually free them at the end of the program, the timing will exceed the limit of the online judge. This sounds very unreasonable -- the timing is too tight which discourages programmers to properly recycle the allocated resources. This maybe fine for Java but will be a disaster for C++ in realworld.\\n"
                    },
                    {
                        "username": "merc14",
                        "content": "For someone who has to find this solution after hearing the question, is it even possible to find a solution AND code it in 45 min\\n\\nfolks who got this in interview and got an offer, please let use know how far you went. Just trying to get an understanding of the expectation"
                    },
                    {
                        "username": "kurtkaiser",
                        "content": "The constraits need to be fixed. Example 3 for the problem directly conflicts with the stated constraints. \\n\\n![image](https://assets.leetcode.com/users/images/05062a1f-ee67-46ac-a5bf-bb4e9fb79346_1651346727.042557.png)\\n"
                    },
                    {
                        "username": "drkato",
                        "content": "My code is right in that it finds the correct indices, but I keep getting a \"too long to execute\" error. When I run the timing in my dev environment for their test case that fails, it take 675ms. Not extraordinary, but not bad either, so what gives? What are we aiming for, there is no feedback or definition at the beginning of the problem."
                    },
                    {
                        "username": "James2009",
                        "content": "The C function prototype is defined as:\\n\\nint** palindromePairs(char** words, int wordsSize, int** columnSizes, int* returnSize)\\n\\nWhy do we need to return a two dimensional array columnSizes? I suppose each (i, j) pair is just a one-dimensional array of int. If we do need to specify the size of each (i,j) pair, should we just copy [2,1] into columnSizes for returnSize times?\\n\\nThanks!"
                    },
                    {
                        "username": "Foristkirito",
                        "content": "the description in this problem is not clear. Judging from the answer, the the number of words is huge, so the O(n*k^2) is ok. but what if the length of each word is also huge?"
                    },
                    {
                        "username": "grvchik",
                        "content": "There was no time limit posted on this question\\nIs there a way the question posters also post the time limit along with problem"
                    },
                    {
                        "username": "sin1080",
                        "content": "In English we do not call an empty string a word. Nor do we do so in other natural languages / programming languages."
                    },
                    {
                        "username": "oneguywithacat",
                        "content": "The description asks for a O(sum of words[i].length) solution but that doesn\\'t consider the quadratic palindrome checks of the remainder of words after matching part of it with the reverse of another word. Is that complexity wrong, or is there a solution that is truly O(sum of words[i].length)?"
                    }
                ]
            },
            {
                "id": 1567252,
                "content": [
                    {
                        "username": "bodurovmahmud",
                        "content": "**I couldn\\'t believe someone wrote this test case.**\\nhttps://leetcode.com/submissions/detail/594315425/testcase/\\n\\n"
                    },
                    {
                        "username": "tanishq1204",
                        "content": "looks like starts in the night sky!\\n"
                    },
                    {
                        "username": "czeng",
                        "content": "The time complexity of the official solutions will be much worse than simple brute force in some edge test cases, most likely will trigger TLE.  Consider the following test case:\\n\\n[\"aaaaa...(repeat 149 times)**bc**aaaaa(repeat 149 times again)\", \"aaaaa...(repeat 149 times)**bb**aaaaa(repeat 149 times again)\",\"\"]\\n\\nNote this test case has only 3 elements, where the first one is not a palindrome, the second one is a very long palindrome, and the third one is empty (thus is also a palindrome, and will combine with the second one to form a valid output). The answer should be [[1,2],[2,1]].\\n\\nIn brute force the time complexity is O(n^2 x k) = O(3^2 x 300) = O(2700). But in both hashmap and trie solution the time complexity is O(n x k^2) = O(3 x 300^2) = O(270000), which is 100 times of the brute force solution.\\n\\nNow this single case may be ok for the timing of the online judge. But in an extreme scenario if there are 1000 such test cases input to the program, the total runtime will be significantly increased, most likely will trigger TLE.\\n\\nAnother interesting thing is it seems C++ is the primary victim of such timing judge. Sometimes if we just write a quick but dirty code without recycling the resources (e.g. the new TrieNode created during the trie building), the timing will be ok. But if we explicitly record all allocated resource and manually free them at the end of the program, the timing will exceed the limit of the online judge. This sounds very unreasonable -- the timing is too tight which discourages programmers to properly recycle the allocated resources. This maybe fine for Java but will be a disaster for C++ in realworld.\\n"
                    },
                    {
                        "username": "merc14",
                        "content": "For someone who has to find this solution after hearing the question, is it even possible to find a solution AND code it in 45 min\\n\\nfolks who got this in interview and got an offer, please let use know how far you went. Just trying to get an understanding of the expectation"
                    },
                    {
                        "username": "kurtkaiser",
                        "content": "The constraits need to be fixed. Example 3 for the problem directly conflicts with the stated constraints. \\n\\n![image](https://assets.leetcode.com/users/images/05062a1f-ee67-46ac-a5bf-bb4e9fb79346_1651346727.042557.png)\\n"
                    },
                    {
                        "username": "drkato",
                        "content": "My code is right in that it finds the correct indices, but I keep getting a \"too long to execute\" error. When I run the timing in my dev environment for their test case that fails, it take 675ms. Not extraordinary, but not bad either, so what gives? What are we aiming for, there is no feedback or definition at the beginning of the problem."
                    },
                    {
                        "username": "James2009",
                        "content": "The C function prototype is defined as:\\n\\nint** palindromePairs(char** words, int wordsSize, int** columnSizes, int* returnSize)\\n\\nWhy do we need to return a two dimensional array columnSizes? I suppose each (i, j) pair is just a one-dimensional array of int. If we do need to specify the size of each (i,j) pair, should we just copy [2,1] into columnSizes for returnSize times?\\n\\nThanks!"
                    },
                    {
                        "username": "Foristkirito",
                        "content": "the description in this problem is not clear. Judging from the answer, the the number of words is huge, so the O(n*k^2) is ok. but what if the length of each word is also huge?"
                    },
                    {
                        "username": "grvchik",
                        "content": "There was no time limit posted on this question\\nIs there a way the question posters also post the time limit along with problem"
                    },
                    {
                        "username": "sin1080",
                        "content": "In English we do not call an empty string a word. Nor do we do so in other natural languages / programming languages."
                    },
                    {
                        "username": "oneguywithacat",
                        "content": "The description asks for a O(sum of words[i].length) solution but that doesn\\'t consider the quadratic palindrome checks of the remainder of words after matching part of it with the reverse of another word. Is that complexity wrong, or is there a solution that is truly O(sum of words[i].length)?"
                    }
                ]
            },
            {
                "id": 1567959,
                "content": [
                    {
                        "username": "bodurovmahmud",
                        "content": "**I couldn\\'t believe someone wrote this test case.**\\nhttps://leetcode.com/submissions/detail/594315425/testcase/\\n\\n"
                    },
                    {
                        "username": "tanishq1204",
                        "content": "looks like starts in the night sky!\\n"
                    },
                    {
                        "username": "czeng",
                        "content": "The time complexity of the official solutions will be much worse than simple brute force in some edge test cases, most likely will trigger TLE.  Consider the following test case:\\n\\n[\"aaaaa...(repeat 149 times)**bc**aaaaa(repeat 149 times again)\", \"aaaaa...(repeat 149 times)**bb**aaaaa(repeat 149 times again)\",\"\"]\\n\\nNote this test case has only 3 elements, where the first one is not a palindrome, the second one is a very long palindrome, and the third one is empty (thus is also a palindrome, and will combine with the second one to form a valid output). The answer should be [[1,2],[2,1]].\\n\\nIn brute force the time complexity is O(n^2 x k) = O(3^2 x 300) = O(2700). But in both hashmap and trie solution the time complexity is O(n x k^2) = O(3 x 300^2) = O(270000), which is 100 times of the brute force solution.\\n\\nNow this single case may be ok for the timing of the online judge. But in an extreme scenario if there are 1000 such test cases input to the program, the total runtime will be significantly increased, most likely will trigger TLE.\\n\\nAnother interesting thing is it seems C++ is the primary victim of such timing judge. Sometimes if we just write a quick but dirty code without recycling the resources (e.g. the new TrieNode created during the trie building), the timing will be ok. But if we explicitly record all allocated resource and manually free them at the end of the program, the timing will exceed the limit of the online judge. This sounds very unreasonable -- the timing is too tight which discourages programmers to properly recycle the allocated resources. This maybe fine for Java but will be a disaster for C++ in realworld.\\n"
                    },
                    {
                        "username": "merc14",
                        "content": "For someone who has to find this solution after hearing the question, is it even possible to find a solution AND code it in 45 min\\n\\nfolks who got this in interview and got an offer, please let use know how far you went. Just trying to get an understanding of the expectation"
                    },
                    {
                        "username": "kurtkaiser",
                        "content": "The constraits need to be fixed. Example 3 for the problem directly conflicts with the stated constraints. \\n\\n![image](https://assets.leetcode.com/users/images/05062a1f-ee67-46ac-a5bf-bb4e9fb79346_1651346727.042557.png)\\n"
                    },
                    {
                        "username": "drkato",
                        "content": "My code is right in that it finds the correct indices, but I keep getting a \"too long to execute\" error. When I run the timing in my dev environment for their test case that fails, it take 675ms. Not extraordinary, but not bad either, so what gives? What are we aiming for, there is no feedback or definition at the beginning of the problem."
                    },
                    {
                        "username": "James2009",
                        "content": "The C function prototype is defined as:\\n\\nint** palindromePairs(char** words, int wordsSize, int** columnSizes, int* returnSize)\\n\\nWhy do we need to return a two dimensional array columnSizes? I suppose each (i, j) pair is just a one-dimensional array of int. If we do need to specify the size of each (i,j) pair, should we just copy [2,1] into columnSizes for returnSize times?\\n\\nThanks!"
                    },
                    {
                        "username": "Foristkirito",
                        "content": "the description in this problem is not clear. Judging from the answer, the the number of words is huge, so the O(n*k^2) is ok. but what if the length of each word is also huge?"
                    },
                    {
                        "username": "grvchik",
                        "content": "There was no time limit posted on this question\\nIs there a way the question posters also post the time limit along with problem"
                    },
                    {
                        "username": "sin1080",
                        "content": "In English we do not call an empty string a word. Nor do we do so in other natural languages / programming languages."
                    },
                    {
                        "username": "oneguywithacat",
                        "content": "The description asks for a O(sum of words[i].length) solution but that doesn\\'t consider the quadratic palindrome checks of the remainder of words after matching part of it with the reverse of another word. Is that complexity wrong, or is there a solution that is truly O(sum of words[i].length)?"
                    }
                ]
            },
            {
                "id": 1572717,
                "content": [
                    {
                        "username": "bodurovmahmud",
                        "content": "**I couldn\\'t believe someone wrote this test case.**\\nhttps://leetcode.com/submissions/detail/594315425/testcase/\\n\\n"
                    },
                    {
                        "username": "tanishq1204",
                        "content": "looks like starts in the night sky!\\n"
                    },
                    {
                        "username": "czeng",
                        "content": "The time complexity of the official solutions will be much worse than simple brute force in some edge test cases, most likely will trigger TLE.  Consider the following test case:\\n\\n[\"aaaaa...(repeat 149 times)**bc**aaaaa(repeat 149 times again)\", \"aaaaa...(repeat 149 times)**bb**aaaaa(repeat 149 times again)\",\"\"]\\n\\nNote this test case has only 3 elements, where the first one is not a palindrome, the second one is a very long palindrome, and the third one is empty (thus is also a palindrome, and will combine with the second one to form a valid output). The answer should be [[1,2],[2,1]].\\n\\nIn brute force the time complexity is O(n^2 x k) = O(3^2 x 300) = O(2700). But in both hashmap and trie solution the time complexity is O(n x k^2) = O(3 x 300^2) = O(270000), which is 100 times of the brute force solution.\\n\\nNow this single case may be ok for the timing of the online judge. But in an extreme scenario if there are 1000 such test cases input to the program, the total runtime will be significantly increased, most likely will trigger TLE.\\n\\nAnother interesting thing is it seems C++ is the primary victim of such timing judge. Sometimes if we just write a quick but dirty code without recycling the resources (e.g. the new TrieNode created during the trie building), the timing will be ok. But if we explicitly record all allocated resource and manually free them at the end of the program, the timing will exceed the limit of the online judge. This sounds very unreasonable -- the timing is too tight which discourages programmers to properly recycle the allocated resources. This maybe fine for Java but will be a disaster for C++ in realworld.\\n"
                    },
                    {
                        "username": "merc14",
                        "content": "For someone who has to find this solution after hearing the question, is it even possible to find a solution AND code it in 45 min\\n\\nfolks who got this in interview and got an offer, please let use know how far you went. Just trying to get an understanding of the expectation"
                    },
                    {
                        "username": "kurtkaiser",
                        "content": "The constraits need to be fixed. Example 3 for the problem directly conflicts with the stated constraints. \\n\\n![image](https://assets.leetcode.com/users/images/05062a1f-ee67-46ac-a5bf-bb4e9fb79346_1651346727.042557.png)\\n"
                    },
                    {
                        "username": "drkato",
                        "content": "My code is right in that it finds the correct indices, but I keep getting a \"too long to execute\" error. When I run the timing in my dev environment for their test case that fails, it take 675ms. Not extraordinary, but not bad either, so what gives? What are we aiming for, there is no feedback or definition at the beginning of the problem."
                    },
                    {
                        "username": "James2009",
                        "content": "The C function prototype is defined as:\\n\\nint** palindromePairs(char** words, int wordsSize, int** columnSizes, int* returnSize)\\n\\nWhy do we need to return a two dimensional array columnSizes? I suppose each (i, j) pair is just a one-dimensional array of int. If we do need to specify the size of each (i,j) pair, should we just copy [2,1] into columnSizes for returnSize times?\\n\\nThanks!"
                    },
                    {
                        "username": "Foristkirito",
                        "content": "the description in this problem is not clear. Judging from the answer, the the number of words is huge, so the O(n*k^2) is ok. but what if the length of each word is also huge?"
                    },
                    {
                        "username": "grvchik",
                        "content": "There was no time limit posted on this question\\nIs there a way the question posters also post the time limit along with problem"
                    },
                    {
                        "username": "sin1080",
                        "content": "In English we do not call an empty string a word. Nor do we do so in other natural languages / programming languages."
                    },
                    {
                        "username": "oneguywithacat",
                        "content": "The description asks for a O(sum of words[i].length) solution but that doesn\\'t consider the quadratic palindrome checks of the remainder of words after matching part of it with the reverse of another word. Is that complexity wrong, or is there a solution that is truly O(sum of words[i].length)?"
                    }
                ]
            },
            {
                "id": 2033006,
                "content": [
                    {
                        "username": "bodurovmahmud",
                        "content": "**I couldn\\'t believe someone wrote this test case.**\\nhttps://leetcode.com/submissions/detail/594315425/testcase/\\n\\n"
                    },
                    {
                        "username": "tanishq1204",
                        "content": "looks like starts in the night sky!\\n"
                    },
                    {
                        "username": "czeng",
                        "content": "The time complexity of the official solutions will be much worse than simple brute force in some edge test cases, most likely will trigger TLE.  Consider the following test case:\\n\\n[\"aaaaa...(repeat 149 times)**bc**aaaaa(repeat 149 times again)\", \"aaaaa...(repeat 149 times)**bb**aaaaa(repeat 149 times again)\",\"\"]\\n\\nNote this test case has only 3 elements, where the first one is not a palindrome, the second one is a very long palindrome, and the third one is empty (thus is also a palindrome, and will combine with the second one to form a valid output). The answer should be [[1,2],[2,1]].\\n\\nIn brute force the time complexity is O(n^2 x k) = O(3^2 x 300) = O(2700). But in both hashmap and trie solution the time complexity is O(n x k^2) = O(3 x 300^2) = O(270000), which is 100 times of the brute force solution.\\n\\nNow this single case may be ok for the timing of the online judge. But in an extreme scenario if there are 1000 such test cases input to the program, the total runtime will be significantly increased, most likely will trigger TLE.\\n\\nAnother interesting thing is it seems C++ is the primary victim of such timing judge. Sometimes if we just write a quick but dirty code without recycling the resources (e.g. the new TrieNode created during the trie building), the timing will be ok. But if we explicitly record all allocated resource and manually free them at the end of the program, the timing will exceed the limit of the online judge. This sounds very unreasonable -- the timing is too tight which discourages programmers to properly recycle the allocated resources. This maybe fine for Java but will be a disaster for C++ in realworld.\\n"
                    },
                    {
                        "username": "merc14",
                        "content": "For someone who has to find this solution after hearing the question, is it even possible to find a solution AND code it in 45 min\\n\\nfolks who got this in interview and got an offer, please let use know how far you went. Just trying to get an understanding of the expectation"
                    },
                    {
                        "username": "kurtkaiser",
                        "content": "The constraits need to be fixed. Example 3 for the problem directly conflicts with the stated constraints. \\n\\n![image](https://assets.leetcode.com/users/images/05062a1f-ee67-46ac-a5bf-bb4e9fb79346_1651346727.042557.png)\\n"
                    },
                    {
                        "username": "drkato",
                        "content": "My code is right in that it finds the correct indices, but I keep getting a \"too long to execute\" error. When I run the timing in my dev environment for their test case that fails, it take 675ms. Not extraordinary, but not bad either, so what gives? What are we aiming for, there is no feedback or definition at the beginning of the problem."
                    },
                    {
                        "username": "James2009",
                        "content": "The C function prototype is defined as:\\n\\nint** palindromePairs(char** words, int wordsSize, int** columnSizes, int* returnSize)\\n\\nWhy do we need to return a two dimensional array columnSizes? I suppose each (i, j) pair is just a one-dimensional array of int. If we do need to specify the size of each (i,j) pair, should we just copy [2,1] into columnSizes for returnSize times?\\n\\nThanks!"
                    },
                    {
                        "username": "Foristkirito",
                        "content": "the description in this problem is not clear. Judging from the answer, the the number of words is huge, so the O(n*k^2) is ok. but what if the length of each word is also huge?"
                    },
                    {
                        "username": "grvchik",
                        "content": "There was no time limit posted on this question\\nIs there a way the question posters also post the time limit along with problem"
                    },
                    {
                        "username": "sin1080",
                        "content": "In English we do not call an empty string a word. Nor do we do so in other natural languages / programming languages."
                    },
                    {
                        "username": "oneguywithacat",
                        "content": "The description asks for a O(sum of words[i].length) solution but that doesn\\'t consider the quadratic palindrome checks of the remainder of words after matching part of it with the reverse of another word. Is that complexity wrong, or is there a solution that is truly O(sum of words[i].length)?"
                    }
                ]
            },
            {
                "id": 1571603,
                "content": [
                    {
                        "username": "aaron66",
                        "content": "My understanding of the problem is that the indexes should be distinct but not the palindromes found. In this input why isn't **[1,0]** part of the expected solution?\\n\\nYour input\\n\\n[\"a\", \"a\"]\\nYour answer\\n\\n[[0,1],[1,0]]\\n\\nExpected answer\\n\\n[[0,1]]"
                    },
                    {
                        "username": "flow7f",
                        "content": "According to description the words should be **unique**. So, your input doesn\\'t match the precondition. Garbage in - garbage out."
                    },
                    {
                        "username": "IIIIIIIVVVI",
                        "content": "use a Manacher  algorithm O(nk) we can identify wether a substring within a word is a palindrome in O(1).\\nThen we use a trie to save all word O(nk), then for each word x , we  reverse it,  and search it in the Trie character by character, at each time, we see if there is some word y and the rest  part of x is palindrome. \\n\\n\\nTLE????"
                    },
                    {
                        "username": "heisen",
                        "content": "I have a solution but I get [[0, 1], [1, 0], [2, 4], [3, 2]]"
                    },
                    {
                        "username": "sksumit1",
                        "content": "Hello All,\\n\\nI really don't understand how 3,2 and 5,3 are not a pair\\nPlease help me understand\\n\\nYour input\\n\\n[\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\",\"s\",\"ll\"]\\nYour answer\\n\\n[[0,1],[1,0],[3,2],[2,4],[5,2],[2,6],[3,5],[5,3],[6,4]]\\nExpected answer\\n\\n[[0,1],[1,0],[2,6],[5,2],[3,5],[2,4],[6,4]]\\n\\nThanks"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I see complexities like \"O(kn^2)\" all over the place without being clear what n/N/k/K/... refer to. Should be specified."
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "very challenging if we talk about optimizing i tried something related to anagrams but it fails on more than half of test cases"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE !!! come on guys... testcases  are infinitely large and complexity of problem itself is large \\nI got tle at 61/136\\nis anyone like me ?"
                    },
                    {
                        "username": "kirsty",
                        "content": "This took me several hours but I FINALLY got it and didn\\'t look at the solutions. \\nHopefully if I ever get asked this in an interview they will give me all 4 hours for this one question...   "
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "ok but you should try your self dum "
                    },
                    {
                        "username": "ravishankar_gp",
                        "content": "@leetcode https://leetcode.com/problems/palindrome-pairs/submissions/887052172/ My trie solution in ruby is TLE ? Can you help me with understanding the same ?"
                    },
                    {
                        "username": "sbansal2499",
                        "content": "At best I am able to get 134/136 cases tested before TLE."
                    }
                ]
            },
            {
                "id": 1571604,
                "content": [
                    {
                        "username": "aaron66",
                        "content": "My understanding of the problem is that the indexes should be distinct but not the palindromes found. In this input why isn't **[1,0]** part of the expected solution?\\n\\nYour input\\n\\n[\"a\", \"a\"]\\nYour answer\\n\\n[[0,1],[1,0]]\\n\\nExpected answer\\n\\n[[0,1]]"
                    },
                    {
                        "username": "flow7f",
                        "content": "According to description the words should be **unique**. So, your input doesn\\'t match the precondition. Garbage in - garbage out."
                    },
                    {
                        "username": "IIIIIIIVVVI",
                        "content": "use a Manacher  algorithm O(nk) we can identify wether a substring within a word is a palindrome in O(1).\\nThen we use a trie to save all word O(nk), then for each word x , we  reverse it,  and search it in the Trie character by character, at each time, we see if there is some word y and the rest  part of x is palindrome. \\n\\n\\nTLE????"
                    },
                    {
                        "username": "heisen",
                        "content": "I have a solution but I get [[0, 1], [1, 0], [2, 4], [3, 2]]"
                    },
                    {
                        "username": "sksumit1",
                        "content": "Hello All,\\n\\nI really don't understand how 3,2 and 5,3 are not a pair\\nPlease help me understand\\n\\nYour input\\n\\n[\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\",\"s\",\"ll\"]\\nYour answer\\n\\n[[0,1],[1,0],[3,2],[2,4],[5,2],[2,6],[3,5],[5,3],[6,4]]\\nExpected answer\\n\\n[[0,1],[1,0],[2,6],[5,2],[3,5],[2,4],[6,4]]\\n\\nThanks"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I see complexities like \"O(kn^2)\" all over the place without being clear what n/N/k/K/... refer to. Should be specified."
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "very challenging if we talk about optimizing i tried something related to anagrams but it fails on more than half of test cases"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE !!! come on guys... testcases  are infinitely large and complexity of problem itself is large \\nI got tle at 61/136\\nis anyone like me ?"
                    },
                    {
                        "username": "kirsty",
                        "content": "This took me several hours but I FINALLY got it and didn\\'t look at the solutions. \\nHopefully if I ever get asked this in an interview they will give me all 4 hours for this one question...   "
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "ok but you should try your self dum "
                    },
                    {
                        "username": "ravishankar_gp",
                        "content": "@leetcode https://leetcode.com/problems/palindrome-pairs/submissions/887052172/ My trie solution in ruby is TLE ? Can you help me with understanding the same ?"
                    },
                    {
                        "username": "sbansal2499",
                        "content": "At best I am able to get 134/136 cases tested before TLE."
                    }
                ]
            },
            {
                "id": 1571606,
                "content": [
                    {
                        "username": "aaron66",
                        "content": "My understanding of the problem is that the indexes should be distinct but not the palindromes found. In this input why isn't **[1,0]** part of the expected solution?\\n\\nYour input\\n\\n[\"a\", \"a\"]\\nYour answer\\n\\n[[0,1],[1,0]]\\n\\nExpected answer\\n\\n[[0,1]]"
                    },
                    {
                        "username": "flow7f",
                        "content": "According to description the words should be **unique**. So, your input doesn\\'t match the precondition. Garbage in - garbage out."
                    },
                    {
                        "username": "IIIIIIIVVVI",
                        "content": "use a Manacher  algorithm O(nk) we can identify wether a substring within a word is a palindrome in O(1).\\nThen we use a trie to save all word O(nk), then for each word x , we  reverse it,  and search it in the Trie character by character, at each time, we see if there is some word y and the rest  part of x is palindrome. \\n\\n\\nTLE????"
                    },
                    {
                        "username": "heisen",
                        "content": "I have a solution but I get [[0, 1], [1, 0], [2, 4], [3, 2]]"
                    },
                    {
                        "username": "sksumit1",
                        "content": "Hello All,\\n\\nI really don't understand how 3,2 and 5,3 are not a pair\\nPlease help me understand\\n\\nYour input\\n\\n[\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\",\"s\",\"ll\"]\\nYour answer\\n\\n[[0,1],[1,0],[3,2],[2,4],[5,2],[2,6],[3,5],[5,3],[6,4]]\\nExpected answer\\n\\n[[0,1],[1,0],[2,6],[5,2],[3,5],[2,4],[6,4]]\\n\\nThanks"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I see complexities like \"O(kn^2)\" all over the place without being clear what n/N/k/K/... refer to. Should be specified."
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "very challenging if we talk about optimizing i tried something related to anagrams but it fails on more than half of test cases"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE !!! come on guys... testcases  are infinitely large and complexity of problem itself is large \\nI got tle at 61/136\\nis anyone like me ?"
                    },
                    {
                        "username": "kirsty",
                        "content": "This took me several hours but I FINALLY got it and didn\\'t look at the solutions. \\nHopefully if I ever get asked this in an interview they will give me all 4 hours for this one question...   "
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "ok but you should try your self dum "
                    },
                    {
                        "username": "ravishankar_gp",
                        "content": "@leetcode https://leetcode.com/problems/palindrome-pairs/submissions/887052172/ My trie solution in ruby is TLE ? Can you help me with understanding the same ?"
                    },
                    {
                        "username": "sbansal2499",
                        "content": "At best I am able to get 134/136 cases tested before TLE."
                    }
                ]
            },
            {
                "id": 1571602,
                "content": [
                    {
                        "username": "aaron66",
                        "content": "My understanding of the problem is that the indexes should be distinct but not the palindromes found. In this input why isn't **[1,0]** part of the expected solution?\\n\\nYour input\\n\\n[\"a\", \"a\"]\\nYour answer\\n\\n[[0,1],[1,0]]\\n\\nExpected answer\\n\\n[[0,1]]"
                    },
                    {
                        "username": "flow7f",
                        "content": "According to description the words should be **unique**. So, your input doesn\\'t match the precondition. Garbage in - garbage out."
                    },
                    {
                        "username": "IIIIIIIVVVI",
                        "content": "use a Manacher  algorithm O(nk) we can identify wether a substring within a word is a palindrome in O(1).\\nThen we use a trie to save all word O(nk), then for each word x , we  reverse it,  and search it in the Trie character by character, at each time, we see if there is some word y and the rest  part of x is palindrome. \\n\\n\\nTLE????"
                    },
                    {
                        "username": "heisen",
                        "content": "I have a solution but I get [[0, 1], [1, 0], [2, 4], [3, 2]]"
                    },
                    {
                        "username": "sksumit1",
                        "content": "Hello All,\\n\\nI really don't understand how 3,2 and 5,3 are not a pair\\nPlease help me understand\\n\\nYour input\\n\\n[\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\",\"s\",\"ll\"]\\nYour answer\\n\\n[[0,1],[1,0],[3,2],[2,4],[5,2],[2,6],[3,5],[5,3],[6,4]]\\nExpected answer\\n\\n[[0,1],[1,0],[2,6],[5,2],[3,5],[2,4],[6,4]]\\n\\nThanks"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I see complexities like \"O(kn^2)\" all over the place without being clear what n/N/k/K/... refer to. Should be specified."
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "very challenging if we talk about optimizing i tried something related to anagrams but it fails on more than half of test cases"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE !!! come on guys... testcases  are infinitely large and complexity of problem itself is large \\nI got tle at 61/136\\nis anyone like me ?"
                    },
                    {
                        "username": "kirsty",
                        "content": "This took me several hours but I FINALLY got it and didn\\'t look at the solutions. \\nHopefully if I ever get asked this in an interview they will give me all 4 hours for this one question...   "
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "ok but you should try your self dum "
                    },
                    {
                        "username": "ravishankar_gp",
                        "content": "@leetcode https://leetcode.com/problems/palindrome-pairs/submissions/887052172/ My trie solution in ruby is TLE ? Can you help me with understanding the same ?"
                    },
                    {
                        "username": "sbansal2499",
                        "content": "At best I am able to get 134/136 cases tested before TLE."
                    }
                ]
            },
            {
                "id": 1571605,
                "content": [
                    {
                        "username": "aaron66",
                        "content": "My understanding of the problem is that the indexes should be distinct but not the palindromes found. In this input why isn't **[1,0]** part of the expected solution?\\n\\nYour input\\n\\n[\"a\", \"a\"]\\nYour answer\\n\\n[[0,1],[1,0]]\\n\\nExpected answer\\n\\n[[0,1]]"
                    },
                    {
                        "username": "flow7f",
                        "content": "According to description the words should be **unique**. So, your input doesn\\'t match the precondition. Garbage in - garbage out."
                    },
                    {
                        "username": "IIIIIIIVVVI",
                        "content": "use a Manacher  algorithm O(nk) we can identify wether a substring within a word is a palindrome in O(1).\\nThen we use a trie to save all word O(nk), then for each word x , we  reverse it,  and search it in the Trie character by character, at each time, we see if there is some word y and the rest  part of x is palindrome. \\n\\n\\nTLE????"
                    },
                    {
                        "username": "heisen",
                        "content": "I have a solution but I get [[0, 1], [1, 0], [2, 4], [3, 2]]"
                    },
                    {
                        "username": "sksumit1",
                        "content": "Hello All,\\n\\nI really don't understand how 3,2 and 5,3 are not a pair\\nPlease help me understand\\n\\nYour input\\n\\n[\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\",\"s\",\"ll\"]\\nYour answer\\n\\n[[0,1],[1,0],[3,2],[2,4],[5,2],[2,6],[3,5],[5,3],[6,4]]\\nExpected answer\\n\\n[[0,1],[1,0],[2,6],[5,2],[3,5],[2,4],[6,4]]\\n\\nThanks"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I see complexities like \"O(kn^2)\" all over the place without being clear what n/N/k/K/... refer to. Should be specified."
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "very challenging if we talk about optimizing i tried something related to anagrams but it fails on more than half of test cases"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE !!! come on guys... testcases  are infinitely large and complexity of problem itself is large \\nI got tle at 61/136\\nis anyone like me ?"
                    },
                    {
                        "username": "kirsty",
                        "content": "This took me several hours but I FINALLY got it and didn\\'t look at the solutions. \\nHopefully if I ever get asked this in an interview they will give me all 4 hours for this one question...   "
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "ok but you should try your self dum "
                    },
                    {
                        "username": "ravishankar_gp",
                        "content": "@leetcode https://leetcode.com/problems/palindrome-pairs/submissions/887052172/ My trie solution in ruby is TLE ? Can you help me with understanding the same ?"
                    },
                    {
                        "username": "sbansal2499",
                        "content": "At best I am able to get 134/136 cases tested before TLE."
                    }
                ]
            },
            {
                "id": 2012794,
                "content": [
                    {
                        "username": "aaron66",
                        "content": "My understanding of the problem is that the indexes should be distinct but not the palindromes found. In this input why isn't **[1,0]** part of the expected solution?\\n\\nYour input\\n\\n[\"a\", \"a\"]\\nYour answer\\n\\n[[0,1],[1,0]]\\n\\nExpected answer\\n\\n[[0,1]]"
                    },
                    {
                        "username": "flow7f",
                        "content": "According to description the words should be **unique**. So, your input doesn\\'t match the precondition. Garbage in - garbage out."
                    },
                    {
                        "username": "IIIIIIIVVVI",
                        "content": "use a Manacher  algorithm O(nk) we can identify wether a substring within a word is a palindrome in O(1).\\nThen we use a trie to save all word O(nk), then for each word x , we  reverse it,  and search it in the Trie character by character, at each time, we see if there is some word y and the rest  part of x is palindrome. \\n\\n\\nTLE????"
                    },
                    {
                        "username": "heisen",
                        "content": "I have a solution but I get [[0, 1], [1, 0], [2, 4], [3, 2]]"
                    },
                    {
                        "username": "sksumit1",
                        "content": "Hello All,\\n\\nI really don't understand how 3,2 and 5,3 are not a pair\\nPlease help me understand\\n\\nYour input\\n\\n[\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\",\"s\",\"ll\"]\\nYour answer\\n\\n[[0,1],[1,0],[3,2],[2,4],[5,2],[2,6],[3,5],[5,3],[6,4]]\\nExpected answer\\n\\n[[0,1],[1,0],[2,6],[5,2],[3,5],[2,4],[6,4]]\\n\\nThanks"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I see complexities like \"O(kn^2)\" all over the place without being clear what n/N/k/K/... refer to. Should be specified."
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "very challenging if we talk about optimizing i tried something related to anagrams but it fails on more than half of test cases"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE !!! come on guys... testcases  are infinitely large and complexity of problem itself is large \\nI got tle at 61/136\\nis anyone like me ?"
                    },
                    {
                        "username": "kirsty",
                        "content": "This took me several hours but I FINALLY got it and didn\\'t look at the solutions. \\nHopefully if I ever get asked this in an interview they will give me all 4 hours for this one question...   "
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "ok but you should try your self dum "
                    },
                    {
                        "username": "ravishankar_gp",
                        "content": "@leetcode https://leetcode.com/problems/palindrome-pairs/submissions/887052172/ My trie solution in ruby is TLE ? Can you help me with understanding the same ?"
                    },
                    {
                        "username": "sbansal2499",
                        "content": "At best I am able to get 134/136 cases tested before TLE."
                    }
                ]
            },
            {
                "id": 1925448,
                "content": [
                    {
                        "username": "aaron66",
                        "content": "My understanding of the problem is that the indexes should be distinct but not the palindromes found. In this input why isn't **[1,0]** part of the expected solution?\\n\\nYour input\\n\\n[\"a\", \"a\"]\\nYour answer\\n\\n[[0,1],[1,0]]\\n\\nExpected answer\\n\\n[[0,1]]"
                    },
                    {
                        "username": "flow7f",
                        "content": "According to description the words should be **unique**. So, your input doesn\\'t match the precondition. Garbage in - garbage out."
                    },
                    {
                        "username": "IIIIIIIVVVI",
                        "content": "use a Manacher  algorithm O(nk) we can identify wether a substring within a word is a palindrome in O(1).\\nThen we use a trie to save all word O(nk), then for each word x , we  reverse it,  and search it in the Trie character by character, at each time, we see if there is some word y and the rest  part of x is palindrome. \\n\\n\\nTLE????"
                    },
                    {
                        "username": "heisen",
                        "content": "I have a solution but I get [[0, 1], [1, 0], [2, 4], [3, 2]]"
                    },
                    {
                        "username": "sksumit1",
                        "content": "Hello All,\\n\\nI really don't understand how 3,2 and 5,3 are not a pair\\nPlease help me understand\\n\\nYour input\\n\\n[\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\",\"s\",\"ll\"]\\nYour answer\\n\\n[[0,1],[1,0],[3,2],[2,4],[5,2],[2,6],[3,5],[5,3],[6,4]]\\nExpected answer\\n\\n[[0,1],[1,0],[2,6],[5,2],[3,5],[2,4],[6,4]]\\n\\nThanks"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I see complexities like \"O(kn^2)\" all over the place without being clear what n/N/k/K/... refer to. Should be specified."
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "very challenging if we talk about optimizing i tried something related to anagrams but it fails on more than half of test cases"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE !!! come on guys... testcases  are infinitely large and complexity of problem itself is large \\nI got tle at 61/136\\nis anyone like me ?"
                    },
                    {
                        "username": "kirsty",
                        "content": "This took me several hours but I FINALLY got it and didn\\'t look at the solutions. \\nHopefully if I ever get asked this in an interview they will give me all 4 hours for this one question...   "
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "ok but you should try your self dum "
                    },
                    {
                        "username": "ravishankar_gp",
                        "content": "@leetcode https://leetcode.com/problems/palindrome-pairs/submissions/887052172/ My trie solution in ruby is TLE ? Can you help me with understanding the same ?"
                    },
                    {
                        "username": "sbansal2499",
                        "content": "At best I am able to get 134/136 cases tested before TLE."
                    }
                ]
            },
            {
                "id": 1804020,
                "content": [
                    {
                        "username": "aaron66",
                        "content": "My understanding of the problem is that the indexes should be distinct but not the palindromes found. In this input why isn't **[1,0]** part of the expected solution?\\n\\nYour input\\n\\n[\"a\", \"a\"]\\nYour answer\\n\\n[[0,1],[1,0]]\\n\\nExpected answer\\n\\n[[0,1]]"
                    },
                    {
                        "username": "flow7f",
                        "content": "According to description the words should be **unique**. So, your input doesn\\'t match the precondition. Garbage in - garbage out."
                    },
                    {
                        "username": "IIIIIIIVVVI",
                        "content": "use a Manacher  algorithm O(nk) we can identify wether a substring within a word is a palindrome in O(1).\\nThen we use a trie to save all word O(nk), then for each word x , we  reverse it,  and search it in the Trie character by character, at each time, we see if there is some word y and the rest  part of x is palindrome. \\n\\n\\nTLE????"
                    },
                    {
                        "username": "heisen",
                        "content": "I have a solution but I get [[0, 1], [1, 0], [2, 4], [3, 2]]"
                    },
                    {
                        "username": "sksumit1",
                        "content": "Hello All,\\n\\nI really don't understand how 3,2 and 5,3 are not a pair\\nPlease help me understand\\n\\nYour input\\n\\n[\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\",\"s\",\"ll\"]\\nYour answer\\n\\n[[0,1],[1,0],[3,2],[2,4],[5,2],[2,6],[3,5],[5,3],[6,4]]\\nExpected answer\\n\\n[[0,1],[1,0],[2,6],[5,2],[3,5],[2,4],[6,4]]\\n\\nThanks"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I see complexities like \"O(kn^2)\" all over the place without being clear what n/N/k/K/... refer to. Should be specified."
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "very challenging if we talk about optimizing i tried something related to anagrams but it fails on more than half of test cases"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE !!! come on guys... testcases  are infinitely large and complexity of problem itself is large \\nI got tle at 61/136\\nis anyone like me ?"
                    },
                    {
                        "username": "kirsty",
                        "content": "This took me several hours but I FINALLY got it and didn\\'t look at the solutions. \\nHopefully if I ever get asked this in an interview they will give me all 4 hours for this one question...   "
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "ok but you should try your self dum "
                    },
                    {
                        "username": "ravishankar_gp",
                        "content": "@leetcode https://leetcode.com/problems/palindrome-pairs/submissions/887052172/ My trie solution in ruby is TLE ? Can you help me with understanding the same ?"
                    },
                    {
                        "username": "sbansal2499",
                        "content": "At best I am able to get 134/136 cases tested before TLE."
                    }
                ]
            },
            {
                "id": 1778195,
                "content": [
                    {
                        "username": "aaron66",
                        "content": "My understanding of the problem is that the indexes should be distinct but not the palindromes found. In this input why isn't **[1,0]** part of the expected solution?\\n\\nYour input\\n\\n[\"a\", \"a\"]\\nYour answer\\n\\n[[0,1],[1,0]]\\n\\nExpected answer\\n\\n[[0,1]]"
                    },
                    {
                        "username": "flow7f",
                        "content": "According to description the words should be **unique**. So, your input doesn\\'t match the precondition. Garbage in - garbage out."
                    },
                    {
                        "username": "IIIIIIIVVVI",
                        "content": "use a Manacher  algorithm O(nk) we can identify wether a substring within a word is a palindrome in O(1).\\nThen we use a trie to save all word O(nk), then for each word x , we  reverse it,  and search it in the Trie character by character, at each time, we see if there is some word y and the rest  part of x is palindrome. \\n\\n\\nTLE????"
                    },
                    {
                        "username": "heisen",
                        "content": "I have a solution but I get [[0, 1], [1, 0], [2, 4], [3, 2]]"
                    },
                    {
                        "username": "sksumit1",
                        "content": "Hello All,\\n\\nI really don't understand how 3,2 and 5,3 are not a pair\\nPlease help me understand\\n\\nYour input\\n\\n[\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\",\"s\",\"ll\"]\\nYour answer\\n\\n[[0,1],[1,0],[3,2],[2,4],[5,2],[2,6],[3,5],[5,3],[6,4]]\\nExpected answer\\n\\n[[0,1],[1,0],[2,6],[5,2],[3,5],[2,4],[6,4]]\\n\\nThanks"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I see complexities like \"O(kn^2)\" all over the place without being clear what n/N/k/K/... refer to. Should be specified."
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "very challenging if we talk about optimizing i tried something related to anagrams but it fails on more than half of test cases"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE !!! come on guys... testcases  are infinitely large and complexity of problem itself is large \\nI got tle at 61/136\\nis anyone like me ?"
                    },
                    {
                        "username": "kirsty",
                        "content": "This took me several hours but I FINALLY got it and didn\\'t look at the solutions. \\nHopefully if I ever get asked this in an interview they will give me all 4 hours for this one question...   "
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "ok but you should try your self dum "
                    },
                    {
                        "username": "ravishankar_gp",
                        "content": "@leetcode https://leetcode.com/problems/palindrome-pairs/submissions/887052172/ My trie solution in ruby is TLE ? Can you help me with understanding the same ?"
                    },
                    {
                        "username": "sbansal2499",
                        "content": "At best I am able to get 134/136 cases tested before TLE."
                    }
                ]
            },
            {
                "id": 1772963,
                "content": [
                    {
                        "username": "aaron66",
                        "content": "My understanding of the problem is that the indexes should be distinct but not the palindromes found. In this input why isn't **[1,0]** part of the expected solution?\\n\\nYour input\\n\\n[\"a\", \"a\"]\\nYour answer\\n\\n[[0,1],[1,0]]\\n\\nExpected answer\\n\\n[[0,1]]"
                    },
                    {
                        "username": "flow7f",
                        "content": "According to description the words should be **unique**. So, your input doesn\\'t match the precondition. Garbage in - garbage out."
                    },
                    {
                        "username": "IIIIIIIVVVI",
                        "content": "use a Manacher  algorithm O(nk) we can identify wether a substring within a word is a palindrome in O(1).\\nThen we use a trie to save all word O(nk), then for each word x , we  reverse it,  and search it in the Trie character by character, at each time, we see if there is some word y and the rest  part of x is palindrome. \\n\\n\\nTLE????"
                    },
                    {
                        "username": "heisen",
                        "content": "I have a solution but I get [[0, 1], [1, 0], [2, 4], [3, 2]]"
                    },
                    {
                        "username": "sksumit1",
                        "content": "Hello All,\\n\\nI really don't understand how 3,2 and 5,3 are not a pair\\nPlease help me understand\\n\\nYour input\\n\\n[\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\",\"s\",\"ll\"]\\nYour answer\\n\\n[[0,1],[1,0],[3,2],[2,4],[5,2],[2,6],[3,5],[5,3],[6,4]]\\nExpected answer\\n\\n[[0,1],[1,0],[2,6],[5,2],[3,5],[2,4],[6,4]]\\n\\nThanks"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I see complexities like \"O(kn^2)\" all over the place without being clear what n/N/k/K/... refer to. Should be specified."
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "very challenging if we talk about optimizing i tried something related to anagrams but it fails on more than half of test cases"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE !!! come on guys... testcases  are infinitely large and complexity of problem itself is large \\nI got tle at 61/136\\nis anyone like me ?"
                    },
                    {
                        "username": "kirsty",
                        "content": "This took me several hours but I FINALLY got it and didn\\'t look at the solutions. \\nHopefully if I ever get asked this in an interview they will give me all 4 hours for this one question...   "
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "ok but you should try your self dum "
                    },
                    {
                        "username": "ravishankar_gp",
                        "content": "@leetcode https://leetcode.com/problems/palindrome-pairs/submissions/887052172/ My trie solution in ruby is TLE ? Can you help me with understanding the same ?"
                    },
                    {
                        "username": "sbansal2499",
                        "content": "At best I am able to get 134/136 cases tested before TLE."
                    }
                ]
            }
        ]
    }
]