[
    {
        "title": "Same Tree",
        "question_content": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\n&nbsp;\nExample 1:\n\nInput: p = [1,2,3], q = [1,2,3]\nOutput: true\n\nExample 2:\n\nInput: p = [1,2], q = [1,null,2]\nOutput: false\n\nExample 3:\n\nInput: p = [1,2,1], q = [1,1,2]\nOutput: false\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in both trees is in the range [0, 100].\n\t-104 <= Node.val <= 104",
        "solutions": [
            {
                "id": 32729,
                "title": "shortest-simplest-python",
                "content": "The \"proper\" way:\\n\\n    def isSameTree(self, p, q):\\n        if p and q:\\n            return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q\\n\\nThe \"tupleify\" way:\\n\\n    def isSameTree(self, p, q):\\n        def t(n):\\n            return n and (n.val, t(n.left), t(n.right))\\n        return t(p) == t(q)\\n\\nThe first way as one-liner:\\n\\n    def isSameTree(self, p, q):\\n        return p and q and p.val == q.val and all(map(self.isSameTree, (p.left, p.right), (q.left, q.right))) or p is q",
                "solutionTags": [
                    "Python"
                ],
                "code": "The \"proper\" way:\\n\\n    def isSameTree(self, p, q):\\n        if p and q:\\n            return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q\\n\\nThe \"tupleify\" way:\\n\\n    def isSameTree(self, p, q):\\n        def t(n):\\n            return n and (n.val, t(n.left), t(n.right))\\n        return t(p) == t(q)\\n\\nThe first way as one-liner:\\n\\n    def isSameTree(self, p, q):\\n        return p and q and p.val == q.val and all(map(self.isSameTree, (p.left, p.right), (q.left, q.right))) or p is q",
                "codeTag": "Python3"
            },
            {
                "id": 32687,
                "title": "five-line-java-solution-with-recursion",
                "content": "    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null) return true;\\n        if(p == null || q == null) return false;\\n        if(p.val == q.val)\\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null) return true;\\n        if(p == null || q == null) return false;\\n        if(p.val == q.val)\\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 32685,
                "title": "here-s-a-c-recursion-solution-in-minimal-lines-of-code",
                "content": "    //\\n    // Algorithm for the recursion:\\n    // 1)\\n    // If one of the node is NULL then return the equality result of p an q.\\n    // This boils down to if both are NULL then return true, \\n    // but if one of them is NULL but not the other one then return false\\n    // 2)\\n    // At this point both root nodes represent valid pointers.\\n    // Return true if the root nodes have same value and \\n    // the left tree of the roots are same (recursion)\\n    // and the right tree of the roots are same (recursion). \\n    // Otherwise return false. \\n    //\\n    \\n    bool isSameTree(TreeNode *p, TreeNode *q) {\\n        if (p == NULL || q == NULL) return (p == q);\\n        return (p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right));\\n    }",
                "solutionTags": [],
                "code": "    //\\n    // Algorithm for the recursion:\\n    // 1)\\n    // If one of the node is NULL then return the equality result of p an q.\\n    // This boils down to if both are NULL then return true, \\n    // but if one of them is NULL but not the other one then return false\\n    // 2)\\n    // At this point both root nodes represent valid pointers.\\n    // Return true if the root nodes have same value and \\n    // the left tree of the roots are same (recursion)\\n    // and the right tree of the roots are same (recursion). \\n    // Otherwise return false. \\n    //\\n    \\n    bool isSameTree(TreeNode *p, TreeNode *q) {\\n        if (p == NULL || q == NULL) return (p == q);\\n        return (p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3746149,
                "title": "recursive-approach-with-easy-steps",
                "content": "## ***Please Upvote my solution, if you find it helpful ;)***\\n\\n# Intuition\\nThe intuition behind the solution is to recursively check if two binary trees are identical. If both trees are empty (null), they are considered identical. If only one tree is empty or the values of the current nodes are different, the trees are not identical. Otherwise, we recursively check if the left and right subtrees of both trees are identical.\\n\\n# Approach\\n1. Check the base case: if both trees are null, return true.\\n1. Check if only one tree is null or the values of the current nodes are different, return false.\\n1. Recursively check if the left subtrees of both trees are identical.\\n1. Recursively check if the right subtrees of both trees are identical.\\n1. Return the logical AND of the results from steps 3 and 4.\\n\\n Complexity\\n- Time complexity:\\nThe time complexity of the solution is $$O(min(N, M))$$, where N and M are the number of nodes in the two trees, respectively. This is because we need to visit each node once in order to compare their values. In the worst case, where both trees have the same number of nodes, the time complexity would be O(N).\\n\\n- Space complexity:\\nThe space complexity of the solution is$$O(min(H1, H2))$$, where H1 and H2 are the heights of the two trees, respectively. This is because the space used by the recursive stack is determined by the height of the smaller tree. In the worst case, where one tree is significantly larger than the other, the space complexity would be closer to O(N) or O(M), depending on which tree is larger.\\n\\n# Code\\n```java []\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // Base case: if both trees are null, they are identical\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        // If only one tree is null or the values are different, they are not identical\\n        if (p == null || q == null || p.val != q.val) {\\n            return false;\\n        }\\n        // Recursively check if the left and right subtrees are identical\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n\\n```\\n```python []\\nclass Solution:\\n    def isSameTree(self, p, q):\\n        # If both nodes are None, they are identical\\n        if p is None and q is None:\\n            return True\\n        # If only one of the nodes is None, they are not identical\\n        if p is None or q is None:\\n            return False\\n        # Check if values are equal and recursively check left and right subtrees\\n        if p.val == q.val:\\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        # Values are not equal, they are not identical\\n        return False\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        // If both nodes are NULL, they are identical\\n        if (p == NULL && q == NULL) {\\n            return true;\\n        }\\n        // If only one of the nodes is NULL, they are not identical\\n        if (p == NULL || q == NULL) {\\n            return false;\\n        }\\n        // Check if values are equal and recursively check left and right subtrees\\n        if (p->val == q->val) {\\n            return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n        }\\n        // Values are not equal, they are not identical\\n        return false;\\n    }\\n};\\n```\\n## ***Please Upvote my solution, if you find it helpful ;)***\\n![6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpeg](https://assets.leetcode.com/users/images/779ca60d-af64-404b-8240-038c7cee76af_1689003011.760921.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```java []\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // Base case: if both trees are null, they are identical\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        // If only one tree is null or the values are different, they are not identical\\n        if (p == null || q == null || p.val != q.val) {\\n            return false;\\n        }\\n        // Recursively check if the left and right subtrees are identical\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n\\n```\n```python []\\nclass Solution:\\n    def isSameTree(self, p, q):\\n        # If both nodes are None, they are identical\\n        if p is None and q is None:\\n            return True\\n        # If only one of the nodes is None, they are not identical\\n        if p is None or q is None:\\n            return False\\n        # Check if values are equal and recursively check left and right subtrees\\n        if p.val == q.val:\\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        # Values are not equal, they are not identical\\n        return False\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        // If both nodes are NULL, they are identical\\n        if (p == NULL && q == NULL) {\\n            return true;\\n        }\\n        // If only one of the nodes is NULL, they are not identical\\n        if (p == NULL || q == NULL) {\\n            return false;\\n        }\\n        // Check if values are equal and recursively check left and right subtrees\\n        if (p->val == q->val) {\\n            return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n        }\\n        // Values are not equal, they are not identical\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32894,
                "title": "python-recursive-solution-and-dfs-iterative-solution-with-stack-and-bfs-iterative-solution-with-queue",
                "content": "    def isSameTree1(self, p, q):\\n        if p and q:\\n            return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        else:\\n            return p == q\\n    \\n    # DFS with stack        \\n    def isSameTree2(self, p, q):\\n        stack = [(p, q)]\\n        while stack:\\n            node1, node2 = stack.pop()\\n            if not node1 and not node2:\\n                continue\\n            elif None in [node1, node2]:\\n                return False\\n            else:\\n                if node1.val != node2.val:\\n                    return False\\n                stack.append((node1.right, node2.right))\\n                stack.append((node1.left, node2.left))\\n        return True\\n     \\n    # BFS with queue    \\n    def isSameTree3(self, p, q):\\n        queue = [(p, q)]\\n        while queue:\\n            node1, node2 = queue.pop(0)\\n            if not node1 and not node2:\\n                continue\\n            elif None in [node1, node2]:\\n                return False\\n            else:\\n                if node1.val != node2.val:\\n                    return False\\n                queue.append((node1.left, node2.left))\\n                queue.append((node1.right, node2.right))\\n        return True",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "    def isSameTree1(self, p, q):\\n        if p and q:\\n            return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        else:\\n            return p == q\\n    \\n    # DFS with stack        \\n    def isSameTree2(self, p, q):\\n        stack = [(p, q)]\\n        while stack:\\n            node1, node2 = stack.pop()\\n            if not node1 and not node2:\\n                continue\\n            elif None in [node1, node2]:\\n                return False\\n            else:\\n                if node1.val != node2.val:\\n                    return False\\n                stack.append((node1.right, node2.right))\\n                stack.append((node1.left, node2.left))\\n        return True\\n     \\n    # BFS with queue    \\n    def isSameTree3(self, p, q):\\n        queue = [(p, q)]\\n        while queue:\\n            node1, node2 = queue.pop(0)\\n            if not node1 and not node2:\\n                continue\\n            elif None in [node1, node2]:\\n                return False\\n            else:\\n                if node1.val != node2.val:\\n                    return False\\n                queue.append((node1.left, node2.left))\\n                queue.append((node1.right, node2.right))\\n        return True",
                "codeTag": "Python3"
            },
            {
                "id": 32684,
                "title": "my-non-recursive-method",
                "content": "the idea is to use stack for preorder traverse \\n\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n    \\t     Stack<TreeNode> stack_p = new Stack <> ();       \\n    \\t     Stack<TreeNode> stack_q = new Stack <> ();\\n    \\t     if (p != null) stack_p.push( p ) ;\\n    \\t     if (q != null) stack_q.push( q ) ;\\n    \\t     while (!stack_p.isEmpty() && !stack_q.isEmpty()) {\\n    \\t    \\t TreeNode pn = stack_p.pop() ;\\n    \\t    \\t TreeNode qn = stack_q.pop() ;\\t    \\t\\n    \\t    \\t if (pn.val != qn.val) return false ;\\n    \\t    \\t if (pn.right != null) stack_p.push(pn.right) ;\\n    \\t    \\t if (qn.right != null) stack_q.push(qn.right) ;\\n    \\t    \\t if (stack_p.size() != stack_q.size()) return false ;\\n    \\t    \\t if (pn.left != null) stack_p.push(pn.left) ;\\t    \\t \\t    \\t \\n    \\t    \\t if (qn.left != null) stack_q.push(qn.left) ;\\n    \\t    \\t if (stack_p.size() != stack_q.size()) return false ;\\n    \\t     }\\t\\t     \\n    \\t     return stack_p.size() == stack_q.size() ;\\t \\n    \\t }",
                "solutionTags": [],
                "code": "the idea is to use stack for preorder traverse \\n\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n    \\t     Stack<TreeNode> stack_p = new Stack <> ();       \\n    \\t     Stack<TreeNode> stack_q = new Stack <> ();\\n    \\t     if (p != null) stack_p.push( p ) ;\\n    \\t     if (q != null) stack_q.push( q ) ;\\n    \\t     while (!stack_p.isEmpty() && !stack_q.isEmpty()) {\\n    \\t    \\t TreeNode pn = stack_p.pop() ;\\n    \\t    \\t TreeNode qn = stack_q.pop() ;\\t    \\t\\n    \\t    \\t if (pn.val != qn.val) return false ;\\n    \\t    \\t if (pn.right != null) stack_p.push(pn.right) ;\\n    \\t    \\t if (qn.right != null) stack_q.push(qn.right) ;\\n    \\t    \\t if (stack_p.size() != stack_q.size()) return false ;\\n    \\t    \\t if (pn.left != null) stack_p.push(pn.left) ;\\t    \\t \\t    \\t \\n    \\t    \\t if (qn.left != null) stack_q.push(qn.left) ;\\n    \\t    \\t if (stack_p.size() != stack_q.size()) return false ;\\n    \\t     }\\t\\t     \\n    \\t     return stack_p.size() == stack_q.size() ;\\t \\n    \\t }",
                "codeTag": "Unknown"
            },
            {
                "id": 826280,
                "title": "recursive-and-iterative-easy-understanding",
                "content": "\\n\\t //iterative\\n\\n      class Solution {\\n      public:\\n          bool isSameTree(TreeNode* p, TreeNode* q) {\\n              queue<TreeNode *> queue;\\n              queue.push(p);\\n              queue.push(q);\\n              while (queue.size()!=0){\\n                  TreeNode * q2=queue.front();\\n                  queue.pop();\\n                  TreeNode * q1=queue.front();\\n                  queue.pop();\\n                  if (q1==nullptr && q2==nullptr) continue;\\n                  if (q1==nullptr || q2==nullptr) return false;\\n                  if (q1->val!=q2->val) return false;\\n                  queue.push(q1->left);\\n                  queue.push(q2->left);\\n                  queue.push(q1->right);\\n                  queue.push(q2->right);\\n              }\\n              return true;\\n          }\\n      };\\n\\t  \\n    //recursive\\n\\n      class Solution {\\n      public:\\n          bool isSameTree(TreeNode* p, TreeNode* q) {\\n              if(p==nullptr && q==nullptr) return true;\\n              if(p==nullptr || q==nullptr) return false;\\n              if(q->val!=p->val) return false;\\n              return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n          }\\n      };\\n\\t  \\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n      public:\\n          bool isSameTree(TreeNode* p, TreeNode* q) {\\n              queue<TreeNode *> queue;\\n              queue.push(p);\\n              queue.push(q);\\n              while (queue.size()!=0){\\n                  TreeNode * q2=queue.front();\\n                  queue.pop();\\n                  TreeNode * q1=queue.front();\\n                  queue.pop();\\n                  if (q1==nullptr && q2==nullptr) continue;\\n                  if (q1==nullptr || q2==nullptr) return false;\\n                  if (q1->val!=q2->val) return false;\\n                  queue.push(q1->left);\\n                  queue.push(q2->left);\\n                  queue.push(q1->right);\\n                  queue.push(q2->right);\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 3027456,
                "title": "c-recursion-one-line-and-iterative-solution-with-explaination",
                "content": "\\uD83C\\uDFA5\\uD83D\\uDD25 Exciting News! Join my Coding Journey! Subscribe Now! \\uD83D\\uDD25\\uD83C\\uDFA5\\n\\n\\uD83D\\uDD17 Link in the leetcode profile \\n\\nNew coding channel alert! \\uD83D\\uDE80\\uD83D\\uDCBB Subscribe to unlock amazing coding content and tutorials. Help me reach 1K subs to start posting more videos! Join now! \\uD83C\\uDF1F\\uD83D\\uDCAA\\n\\nThanks for your support! \\uD83D\\uDE4F\\n# Intuition\\nWe well use 2 method to solve this problem\\n1. Recursive method\\n2. Iterative method\\n\\n# Approach\\n# method 1. Recursion\\n1. If one of the node is NULL then return the equality result of p an q.\\n     a. This boils down to if both are NULL then return true, \\n     b. if one of them is NULL but not the other one then return false\\n  \\n2.  At this point both root nodes represent valid pointers(after checking the if condition).\\n    - Return true if the root nodes have same value  (p->val==q->val)\\n    - Recursively check right subtrees of both trees p and q\\n    - Recursively check left subtrees of both trees p and q\\n3. If the left or right subtrees are different, return false \\n\\nHere is image for more clearity\\n![leetcode.png](https://assets.leetcode.com/users/images/09b47818-50d3-40e3-8c4b-05ea129abf09_1673315076.6926653.png)\\n\\n\\n# Complexity\\n- Time complexity -->O(N)\\n\\n- Space complexity -->O(H)H=height of binary tree\\n\\n# Method 2. Iterative solution\\n1. Create a stack and push the roots of both trees onto the stack as pairs.\\n2. While the stack is not empty\\n    - Pop a pair of nodes from the stack.\\n    -  If both nodes are null, continue.\\n    -  If one node is null or the values at the nodes are different, return false.\\n    -  Push the left and right children of both nodes onto the stack as pairs.\\n3. If the loop completes, return true.\\n\\n# Complexity\\n- Time complexity -->O(N)\\n\\n- Space complexity -->O(N)\\n\\n\\n# Code(Recursion)\\n```\\n\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(!p && !q)    return true;\\n        if(!p || !q)    return false;\\n            return (p->val == q->val && isSameTree(p->right, q->right) && isSameTree(p->left, q->left));\\n    }\\n};\\n```\\n# Code(Iterative)\\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q)\\n    {\\n        stack<pair<TreeNode*, TreeNode*>> st;\\n        st.push({p, q});\\n        while (!st.empty()) {\\n            auto [node1, node2] = st.top();\\n            st.pop();\\n            if (!node1 && !node2) continue;\\n            if (!node1 || !node2 || node1->val != node2->val) return false;\\n            st.push({node1->left, node2->left});\\n            st.push({node1->right, node2->right});\\n        }\\n        return true;\\n    }\\n};\\n```\\n# [MY LINKDIN](https://www.linkedin.com/in/mahesh-vishnoi-a4a47a193/)\\nIf you really found my solution helpful **please upvote it**, as it motivates me to post such kind of codes.\\n*Let me know in comment if i can do better*.\\nLets connect on # [Linkdin](https://www.linkedin.com/in/mahesh-vishnoi-a4a47a193/)\\n",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(!p && !q)    return true;\\n        if(!p || !q)    return false;\\n            return (p->val == q->val && isSameTree(p->right, q->right) && isSameTree(p->left, q->left));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q)\\n    {\\n        stack<pair<TreeNode*, TreeNode*>> st;\\n        st.push({p, q});\\n        while (!st.empty()) {\\n            auto [node1, node2] = st.top();\\n            st.pop();\\n            if (!node1 && !node2) continue;\\n            if (!node1 || !node2 || node1->val != node2->val) return false;\\n            st.push({node1->left, node2->left});\\n            st.push({node1->right, node2->right});\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32935,
                "title": "javascript-solution",
                "content": "```js\\nfunction isSameTree(p, q) {\\n  if (!p && !q) return true;\\n  if (!p || !q || p.val !== q.val) return false;\\n  \\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nfunction isSameTree(p, q) {\\n  if (!p && !q) return true;\\n  if (!p || !q || p.val !== q.val) return false;\\n  \\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 607631,
                "title": "javascript-too-easy",
                "content": "````\\nvar isSameTree = function(p, q) {\\n     return JSON.stringify(p)===JSON.stringify(q)\\n};\\n````",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "````\\nvar isSameTree = function(p, q) {\\n     return JSON.stringify(p)===JSON.stringify(q)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3027900,
                "title": "java-solution-with-explanation",
                "content": "\\n# Approach and Explanation\\n<!-- Describe your approach to solving the problem. -->\\n1. This code is checking if two trees are the same by comparing their structure and node values. The function takes in the root nodes of the two trees, p and q, as arguments.\\n\\n2. The function first checks if both trees are null - if they are, then the function returns true, because two null trees are considered to be the same. If only one of the trees is null (and the other isn\\'t), the function returns false, because a tree with nodes is not the same as a null tree.\\n\\n3. If both trees are non-null, the function compares the values of their root nodes. If the values are not the same, the function returns false, because the trees are not the same. If the values are the same, the function recursively calls itself on the left and right children of the two root nodes. The function returns true if the left and right subtrees of both trees are the same, and false otherwise.\\n\\n4. Overall, the function checks the structure and node values of the two trees in a recursive manner, starting from the root nodes and moving down to the leaf nodes. If the structure and values of both trees are the same at every level, the function returns true, indicating that the trees are the same. If any differences are found, the function returns false, indicating that the trees are not the same.\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n   public boolean isSameTree(TreeNode p, TreeNode q) {\\n    \\n    // If both p and q are null, then they are the same tree\\n    if (p == null && q == null) return true;\\n    \\n    // If only one of p and q is null, then they are not the same tree\\n    if (p == null || q == null) return false;\\n    \\n    // If the values of p and q are different, then they are not the same tree\\n    if (p.val != q.val) return false;\\n    \\n    // Recursively check the left and right subtrees of p and q\\n    // If both the left and right subtrees are the same, then p and q are the same tree\\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n   public boolean isSameTree(TreeNode p, TreeNode q) {\\n    \\n    // If both p and q are null, then they are the same tree\\n    if (p == null && q == null) return true;\\n    \\n    // If only one of p and q is null, then they are not the same tree\\n    if (p == null || q == null) return false;\\n    \\n    // If the values of p and q are different, then they are not the same tree\\n    if (p.val != q.val) return false;\\n    \\n    // Recursively check the left and right subtrees of p and q\\n    // If both the left and right subtrees are the same, then p and q are the same tree\\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1376495,
                "title": "c-solution-recursive-approach",
                "content": "Time complexity - O(N)\\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL &&  q== NULL) return true;\\n        if(p == NULL ||  q== NULL) return false;\\n        if(p->val != q->val) return false;\\n        return isSameTree(p->right, q->right) && isSameTree(p->left, q->left) ;\\n    }\\n};\\n```\\nPlease Upvote if you like the solution and comment if have doubts",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL &&  q== NULL) return true;\\n        if(p == NULL ||  q== NULL) return false;\\n        if(p->val != q->val) return false;\\n        return isSameTree(p->right, q->right) && isSameTree(p->left, q->left) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32733,
                "title": "simple-java-solution-both-recurison-and-iteration",
                "content": "\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // recurision method\\n        if (p == null && q == null) return true;\\n        if (p == null && q != null || p != null && q == null) return false;\\n        if (p.val != q.val) return false;\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n\\n\\n----------\\n\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // iteration method\\n        if (p == null && q == null) return true;\\n        if (p == null && q != null || p != null && q == null) return false;\\n        Stack<TreeNode> stackP = new Stack<>();\\n        Stack<TreeNode> stackQ = new Stack<>();\\n        stackP.add(p);\\n        stackQ.add(q);\\n        while (!stackP.isEmpty() && !stackQ.isEmpty()) {\\n            TreeNode tmpP = stackP.pop();\\n            TreeNode tmpQ = stackQ.pop();\\n            if (tmpP.val != tmpQ.val) return false;\\n            if (tmpP.left != null && tmpQ.left != null) {\\n                stackP.push(tmpP.left);\\n                stackQ.push(tmpQ.left);\\n            } else if (tmpP.left == null && tmpQ.left == null) {\\n            } else {\\n                return false;\\n            }\\n            if (tmpP.right != null && tmpQ.right != null) {\\n                stackP.push(tmpP.right);\\n                stackQ.push(tmpQ.right);\\n            } else if (tmpP.right == null && tmpQ.right == null) {\\n            } else {\\n                return false;\\n            }\\n        }\\n        if (!stackP.isEmpty() || !stackQ.isEmpty()) return false;\\n        return true;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // recurision method\\n        if (p == null && q == null) return true;\\n        if (p == null && q != null || p != null && q == null) return false;\\n        if (p.val != q.val) return false;\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n\\n\\n----------\\n\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // iteration method\\n        if (p == null && q == null) return true;\\n        if (p == null && q != null || p != null && q == null) return false;\\n        Stack<TreeNode> stackP = new Stack<>();\\n        Stack<TreeNode> stackQ = new Stack<>();\\n        stackP.add(p);\\n        stackQ.add(q);\\n        while (!stackP.isEmpty() && !stackQ.isEmpty()) {\\n            TreeNode tmpP = stackP.pop();\\n            TreeNode tmpQ = stackQ.pop();\\n            if (tmpP.val != tmpQ.val) return false;\\n            if (tmpP.left != null && tmpQ.left != null) {\\n                stackP.push(tmpP.left);\\n                stackQ.push(tmpQ.left);\\n            } else if (tmpP.left == null && tmpQ.left == null) {\\n            } else {\\n                return false;\\n            }\\n            if (tmpP.right != null && tmpQ.right != null) {\\n                stackP.push(tmpP.right);\\n                stackQ.push(tmpQ.right);\\n            } else if (tmpP.right == null && tmpQ.right == null) {\\n            } else {\\n                return false;\\n            }\\n        }\\n        if (!stackP.isEmpty() || !stackQ.isEmpty()) return false;\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3027608,
                "title": "python3-dfs-explained-chatgpt-solutions",
                "content": "\\n**Logic:**\\n(1) If both ```p``` and ```q``` are None, we have reched the end on the branches from both trees, so return True.\\n(2) If both nodes are not None, then their values has to be the same, and if so we keep check their left and right nodes.\\n(3) If both nodes are not None, but their values are different, retun False.\\n(4) If one of the node is None and the other one is not, we return False.\\n\\nAs you can see (3) and (4) are just in the else condition from (2). \\n\\n**DFS (Recursive)**\\n```python\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if not p and not q:\\t\\t\\t\\t\\t#(1)\\n            return True\\n        if p and q and p.val == q.val:\\t\\t#(2)\\n            return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n        else:\\t\\t\\t\\t\\t\\t\\t\\t#(3)\\n            return False\\n```\\n\\n**DFS (Iterative)** Applying the same logic but using stack.\\n```python\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        stack = [[p,q]]\\n        while stack:\\n            p,q = stack.pop()\\n            if not p and not q:\\t\\t\\t\\t\\t#(1)\\n                continue\\n            elif p and q and p.val == q.val:\\t#(2)\\n                stack.append([p.left, q.left])\\n                stack.append([p.right, q.right])\\n            else:\\t\\t\\t\\t\\t\\t\\t\\t#(3)\\n                return False\\n        return True\\n```\\n\\n**Solution and explination from ChatGPT** (I\\'m sure ChatGPT has seen this question before, and the answer it gives is the same as the offical one)\\n\\nTo check if two binary trees are the same, we can do a pre-order traversal of both trees and compare the nodes at each level. If at any point the nodes are different or one of the trees has no more nodes, we can return false. Otherwise, we can return true.\\n\\nThis function will have a time complexity of O(n) where n is the number of nodes in the tree, since it needs to visit each node exactly once. The space complexity is also O(n) since at worst case the recursive call stack could contain all the nodes in one of the trees.\\n\\n```python\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        # base case: both nodes are null\\n        if not p and not q:\\n            return True\\n        # base case: one node is null\\n        if not p or not q:\\n            return False\\n        # check if the values of the nodes are the same\\n        if p.val != q.val:\\n            return False\\n        # check if the left and right subtrees are the same\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```\\n\\n**Me: can you do it without recursion?**\\n\\n**ChatGPT:** Yes, it is also possible to implement this function without recursion using an iterative approach. One way to do this is to use a breadth-first search (BFS) to traverse the trees level by level, and compare the nodes at each level.\\n\\n```python\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        # base case: if both trees are None, they are the same\\n        if not p and not q:\\n            return True\\n        # base case: if only one tree is None, they are not the same\\n        if not p or not q:\\n            return False\\n\\n        # create a queue to hold the nodes at each level\\n        queue = [(p, q)]\\n\\n        # do a BFS of the trees\\n        while queue:\\n            # get the next nodes to compare\\n            node1, node2 = queue.pop(0)\\n            # check if the nodes are the same\\n            if node1.val != node2.val:\\n                return False\\n            # add the left and right children of the nodes to the queue if they exist\\n            if node1.left and node2.left:\\n                queue.append((node1.left, node2.left))\\n            elif node1.left or node2.left:\\n                # if only one of the nodes has a left child, the trees are not the same\\n                return False\\n            if node1.right and node2.right:\\n                queue.append((node1.right, node2.right))\\n            elif node1.right or node2.right:\\n                # if only one of the nodes has a right child, the trees are not the same\\n                return False\\n        # if we made it through the loop, the trees are the same\\n        return True\\n```\\n\\nFrom what I tested, ChatGPT can only do easy problem if it has never seen it before, and will fail on the medium ones. Note that since the training data for ChatGPT is the data before 2021, so for these harder questions on LeetCode before 2021, ChatGPT can also do it.\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**\\n\\n",
                "solutionTags": [],
                "code": "```p```\n```q```\n```python\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if not p and not q:\\t\\t\\t\\t\\t#(1)\\n            return True\\n        if p and q and p.val == q.val:\\t\\t#(2)\\n            return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n        else:\\t\\t\\t\\t\\t\\t\\t\\t#(3)\\n            return False\\n```\n```python\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        stack = [[p,q]]\\n        while stack:\\n            p,q = stack.pop()\\n            if not p and not q:\\t\\t\\t\\t\\t#(1)\\n                continue\\n            elif p and q and p.val == q.val:\\t#(2)\\n                stack.append([p.left, q.left])\\n                stack.append([p.right, q.right])\\n            else:\\t\\t\\t\\t\\t\\t\\t\\t#(3)\\n                return False\\n        return True\\n```\n```python\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        # base case: both nodes are null\\n        if not p and not q:\\n            return True\\n        # base case: one node is null\\n        if not p or not q:\\n            return False\\n        # check if the values of the nodes are the same\\n        if p.val != q.val:\\n            return False\\n        # check if the left and right subtrees are the same\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```\n```python\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        # base case: if both trees are None, they are the same\\n        if not p and not q:\\n            return True\\n        # base case: if only one tree is None, they are not the same\\n        if not p or not q:\\n            return False\\n\\n        # create a queue to hold the nodes at each level\\n        queue = [(p, q)]\\n\\n        # do a BFS of the trees\\n        while queue:\\n            # get the next nodes to compare\\n            node1, node2 = queue.pop(0)\\n            # check if the nodes are the same\\n            if node1.val != node2.val:\\n                return False\\n            # add the left and right children of the nodes to the queue if they exist\\n            if node1.left and node2.left:\\n                queue.append((node1.left, node2.left))\\n            elif node1.left or node2.left:\\n                # if only one of the nodes has a left child, the trees are not the same\\n                return False\\n            if node1.right and node2.right:\\n                queue.append((node1.right, node2.right))\\n            elif node1.right or node2.right:\\n                # if only one of the nodes has a right child, the trees are not the same\\n                return False\\n        # if we made it through the loop, the trees are the same\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 642761,
                "title": "easy-to-understand-faster-simple-recursive-iterative-dfs-python-solution",
                "content": "```\\n    def recursive(self, p, q):\\n        if not p and not q:\\n            return True\\n        elif not p or not q:\\n            return False\\n        else:\\n            return p.val == q.val and self.recursive(p.left, q.left) and self.recursive(p.right, q.right)\\n        \\n    def iterative(self, p, q):\\n        stack = [(p, q)]\\n        while len(stack):\\n            first, second = stack.pop()\\n            if not first and not second: pass\\n            elif not first or not second: return False\\n            else:\\n                if first.val != second.val: return False\\n                stack.append((first.left, second.left))\\n                stack.append((first.right, second.right))\\n        return True\\n        \\n    \\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n    def recursive(self, p, q):\\n        if not p and not q:\\n            return True\\n        elif not p or not q:\\n            return False\\n        else:\\n            return p.val == q.val and self.recursive(p.left, q.left) and self.recursive(p.right, q.right)\\n        \\n    def iterative(self, p, q):\\n        stack = [(p, q)]\\n        while len(stack):\\n            first, second = stack.pop()\\n            if not first and not second: pass\\n            elif not first or not second: return False\\n            else:\\n                if first.val != second.val: return False\\n                stack.append((first.left, second.left))\\n                stack.append((first.right, second.right))\\n        return True\\n        \\n    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3028777,
                "title": "java-without-recursion-100-faster",
                "content": "Upvote if it helps \\u270C\\uFE0F\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t     Stack<TreeNode> stack_p = new Stack <> ();       \\n\\t     Stack<TreeNode> stack_q = new Stack <> ();\\n\\t     if (p != null) stack_p.push( p ) ;\\n\\t     if (q != null) stack_q.push( q ) ;\\n\\t     while (!stack_p.isEmpty() && !stack_q.isEmpty()) {\\n\\t    \\t TreeNode pn = stack_p.pop() ;\\n\\t    \\t TreeNode qn = stack_q.pop() ;\\t    \\t\\n\\t    \\t if (pn.val != qn.val) return false ;\\n\\t    \\t if (pn.right != null) stack_p.push(pn.right) ;\\n\\t    \\t if (qn.right != null) stack_q.push(qn.right) ;\\n\\t    \\t if (stack_p.size() != stack_q.size()) return false ;\\n\\t    \\t if (pn.left != null) stack_p.push(pn.left) ;\\t    \\t \\t    \\t \\n\\t    \\t if (qn.left != null) stack_q.push(qn.left) ;\\n\\t    \\t if (stack_p.size() != stack_q.size()) return false ;\\n\\t     }\\t\\t     \\n\\t     return stack_p.size() == stack_q.size() ;\\t \\n\\t }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t     Stack<TreeNode> stack_p = new Stack <> ();       \\n\\t     Stack<TreeNode> stack_q = new Stack <> ();\\n\\t     if (p != null) stack_p.push( p ) ;\\n\\t     if (q != null) stack_q.push( q ) ;\\n\\t     while (!stack_p.isEmpty() && !stack_q.isEmpty()) {\\n\\t    \\t TreeNode pn = stack_p.pop() ;\\n\\t    \\t TreeNode qn = stack_q.pop() ;\\t    \\t\\n\\t    \\t if (pn.val != qn.val) return false ;\\n\\t    \\t if (pn.right != null) stack_p.push(pn.right) ;\\n\\t    \\t if (qn.right != null) stack_q.push(qn.right) ;\\n\\t    \\t if (stack_p.size() != stack_q.size()) return false ;\\n\\t    \\t if (pn.left != null) stack_p.push(pn.left) ;\\t    \\t \\t    \\t \\n\\t    \\t if (qn.left != null) stack_q.push(qn.left) ;\\n\\t    \\t if (stack_p.size() != stack_q.size()) return false ;\\n\\t     }\\t\\t     \\n\\t     return stack_p.size() == stack_q.size() ;\\t \\n\\t }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 158580,
                "title": "python-dfs-stack-queue",
                "content": "### 100. Same Tree\\n```\\n> \\u7C7B\\u578B\\uFF1ADFSF\\u5206\\u5236\\n> Time Complexity O(N)\\n> Space Complexity O(h)\\n```\\n\\n\\u5728\\u6BCF\\u4E00\\u5C42\\u5148\\u68C0\\u67E5\\u518D\\u9012\\u5F52\\uFF0C\\u6240\\u4EE5\\u8FD9\\u662Fpre-order\\u7684\\u601D\\u8DEF\\u3002\\n\\u6BD4\\u5BF9\\u76F8\\u7B49\\u7684\\u6761\\u4EF6\\uFF1A\\n1. `p.val == q.val`\\n2. `if not p or not q: return p == q`\\n\\u5982\\u6709\\u4E0D\\u7B49\\uFF0C\\u76F4\\u63A5\\u8FD4\\u56DEFalse\\uFF0C\\u5C31\\u4E0D\\u7528\\u7EE7\\u7EED\\u9012\\u5F52\\u4E86\\u3002\\u6700\\u540E\\u5DE6\\u53F3\\u5B69\\u5B50\\u8FD4\\u56DE\\u7ED9Root\\uFF1A`return left and right`\\n\\n\\np.s. \\u4E0A\\u9762\\u7684\\u7B2C\\u4E8C\\u4E2A\\u76F8\\u7B49\\u6761\\u4EF6\\uFF0C\\u68C0\\u67E5\\u4E862\\u79CD\\u60C5\\u51B5\\uFF1A\\n1.`if not p and not q: return True`\\n2.`if not p or not q: return False`\\n\\n#### DFS\\n```python     \\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        if not p or not q: return p == q\\n        if p.val != q.val: return False\\n        \\n        left = self.isSameTree(p.left, q.left)\\n        right = self.isSameTree(p.right, q.right)\\n        return left and right\\n```\\n\\n#### Stack\\n```python\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        stack = [(p, q)]\\n        while stack:\\n            n1, n2 = stack.pop()\\n            if not n1 and not n2: continue\\n            if not n1 or not n2: return n1 == n2\\n            if n1.val != n2.val: return False\\n            stack.append((n1.right, n2.right))\\n            stack.append((n1.left, n2.left))\\n        return True\\n```\\n\\n#### Queue\\n```python\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        queue = collections.deque([(p, q)])\\n        while queue:\\n            n1, n2 = queue.popleft()\\n            if not n1 and not n2: continue\\n            if not n1 or not n2: return n1 == n2\\n            if n1.val != n2.val: return False\\n            queue.append((n1.left, n2.left))\\n            queue.append((n1.right, n2.right))\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\n> \\u7C7B\\u578B\\uFF1ADFSF\\u5206\\u5236\\n> Time Complexity O(N)\\n> Space Complexity O(h)\\n```\n```python     \\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        if not p or not q: return p == q\\n        if p.val != q.val: return False\\n        \\n        left = self.isSameTree(p.left, q.left)\\n        right = self.isSameTree(p.right, q.right)\\n        return left and right\\n```\n```python\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        stack = [(p, q)]\\n        while stack:\\n            n1, n2 = stack.pop()\\n            if not n1 and not n2: continue\\n            if not n1 or not n2: return n1 == n2\\n            if n1.val != n2.val: return False\\n            stack.append((n1.right, n2.right))\\n            stack.append((n1.left, n2.left))\\n        return True\\n```\n```python\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        queue = collections.deque([(p, q)])\\n        while queue:\\n            n1, n2 = queue.popleft()\\n            if not n1 and not n2: continue\\n            if not n1 or not n2: return n1 == n2\\n            if n1.val != n2.val: return False\\n            queue.append((n1.left, n2.left))\\n            queue.append((n1.right, n2.right))\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32926,
                "title": "2-lines-c-simple-solution-easy-understanding",
                "content": "    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (!p || !q) return q == p;\\n        return p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (!p || !q) return q == p;\\n        return p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 733783,
                "title": "python-3-lines-recursion-explained",
                "content": "As it given in problem statement: two binary trees are considered the same if they are structurally identical and the nodes have the same value. So all we need to do is to check this condition recursively:\\n\\nIf we reached node `p` in one tree and `q` in another tree (we allow to reach `None` nodes), we need to consider 3 cases:\\n\\n1. If one of them do not exist and another exist, we return `False`.\\n2. If two of them are equal to `None`, we return `True`.\\n3. If none of two above condition holds, we look at children and return `True` only if values of nodes are equal and if `True` holds for left and right subtrees.\\n\\n**Complexity**: time complexity is `O(n)`, because we traverse all tree. Space complexity is `O(h)` to keep recursion stack. Time complexity can be imporved a bit, if we use helper function and directly return `False` if we found difference between trees. \\n\\n```\\nclass Solution:\\n    def isSameTree(self, p, q):\\n        if p and not q or q and not p: return False\\n        if not p and not q: return True\\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def isSameTree(self, p, q):\\n        if p and not q or q and not p: return False\\n        if not p and not q: return True\\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32910,
                "title": "python-recursive-solution-within-36ms",
                "content": "    class Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not q and not p:\\n            return True\\n        elif not p or not q:\\n            return False\\n        elif p.val!=q.val:\\n            return False\\n        else:\\n            return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)",
                "solutionTags": [],
                "code": "    class Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not q and not p:\\n            return True\\n        elif not p or not q:\\n            return False\\n        elif p.val!=q.val:\\n            return False\\n        else:\\n            return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)",
                "codeTag": "Java"
            },
            {
                "id": 3029585,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (p == NULL && q == NULL) {\\n            return true;\\n        }\\n        if (p == NULL || q == NULL) {\\n            return false;\\n        }\\n        if (p->val != q->val) {\\n            return false;\\n        }\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p and q:\\n            return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q\\n```\\n\\n```Java []\\nclass Solution {\\n  public boolean isSameTree(TreeNode p, TreeNode q) {\\n    if (p == null || q == null)\\n      return p == q;\\n    return p.val == q.val &&\\n           isSameTree(p.left, q.left) &&\\n           isSameTree(p.right, q.right);\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (p == NULL && q == NULL) {\\n            return true;\\n        }\\n        if (p == NULL || q == NULL) {\\n            return false;\\n        }\\n        if (p->val != q->val) {\\n            return false;\\n        }\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p and q:\\n            return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q\\n```\n```Java []\\nclass Solution {\\n  public boolean isSameTree(TreeNode p, TreeNode q) {\\n    if (p == null || q == null)\\n      return p == q;\\n    return p.val == q.val &&\\n           isSameTree(p.left, q.left) &&\\n           isSameTree(p.right, q.right);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32721,
                "title": "2-lines-java-code",
                "content": "    public class Solution {\\n        public boolean isSameTree(TreeNode p, TreeNode q) {\\n            if (p == null && q == null) return true;\\n            return p != null && q != null && p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n        } }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isSameTree(TreeNode p, TreeNode q) {\\n            if (p == null && q == null) return true;\\n            return p != null && q != null && p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 32703,
                "title": "javascript-solution",
                "content": "Nothing fancy, just perform a preorder traversal for both trees at the same pace, simply return `false` whenever we found a mismatch, otherwise continue the traversal on both left and right subtrees.\\n\\nTime complexity: `O(n)`\\nSpace complexity: `O(1)` (ignore recursion stack, otherwise the height of the tree)\\n```\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n    if (!p && !q) {\\n        return true;\\n    }\\n    if (!p || !q || p.val !== q.val) {\\n        return false;\\n    }\\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n    if (!p && !q) {\\n        return true;\\n    }\\n    if (!p || !q || p.val !== q.val) {\\n        return false;\\n    }\\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1724190,
                "title": "python-3-30ms-recursive-dfs-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p is None and q is None:\\n            return True\\n        if p is None or q is None:\\n            return False\\n        if p.val==q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right):\\n            return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p is None and q is None:\\n            return True\\n        if p is None or q is None:\\n            return False\\n        if p.val==q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right):\\n            return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32936,
                "title": "c-solutions-recursively-bfs-queue-dfs-stack",
                "content": "     \\n    // Recursively\\n    bool isSameTree1(TreeNode* p, TreeNode* q) {\\n        if (p && q)\\n            return p->val==q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n        return p == q;\\n    }\\n    \\n    // BFS + queue\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        queue<pair<TreeNode*, TreeNode*>> myQueue;\\n        myQueue.push(pair<TreeNode*, TreeNode*>(p, q));\\n        while (!myQueue.empty()) {\\n            p = myQueue.front().first;\\n            q = myQueue.front().second;\\n            if(!p ^ !q || (p && q && p->val != q->val))\\n                break;\\n            myQueue.pop();\\n            if(p && q) {\\n                myQueue.push(pair<TreeNode*, TreeNode*>(p->left, q->left));\\n                myQueue.push(pair<TreeNode*, TreeNode*>(p->right, q->right));\\n            }\\n        }\\n        return myQueue.empty();\\n    }\\n    \\n    // DFS + stack\\n    bool isSameTree3(TreeNode* p, TreeNode* q) {\\n        stack<pair<TreeNode*, TreeNode* >> myStack;\\n        myStack.push(pair<TreeNode*, TreeNode*>(p, q));\\n        while (!myStack.empty()) {\\n            p = myStack.top().first;\\n            q = myStack.top().second;\\n            if (!p ^ !q || (p && q && p->val != q->val))\\n                break;\\n            myStack.pop();\\n            if (p && q) {\\n                myStack.push(pair<TreeNode*, TreeNode*> (p->right, q->right));\\n                myStack.push(pair<TreeNode*, TreeNode*> (p->left, q->left));\\n            }\\n        }\\n        return myStack.empty();\\n    }",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "     \\n    // Recursively\\n    bool isSameTree1(TreeNode* p, TreeNode* q) {\\n        if (p && q)\\n            return p->val==q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n        return p == q;\\n    }\\n    \\n    // BFS + queue\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        queue<pair<TreeNode*, TreeNode*>> myQueue;\\n        myQueue.push(pair<TreeNode*, TreeNode*>(p, q));\\n        while (!myQueue.empty()) {\\n            p = myQueue.front().first;\\n            q = myQueue.front().second;\\n            if(!p ^ !q || (p && q && p->val != q->val))\\n                break;\\n            myQueue.pop();\\n            if(p && q) {\\n                myQueue.push(pair<TreeNode*, TreeNode*>(p->left, q->left));\\n                myQueue.push(pair<TreeNode*, TreeNode*>(p->right, q->right));\\n            }\\n        }\\n        return myQueue.empty();\\n    }\\n    \\n    // DFS + stack\\n    bool isSameTree3(TreeNode* p, TreeNode* q) {\\n        stack<pair<TreeNode*, TreeNode* >> myStack;\\n        myStack.push(pair<TreeNode*, TreeNode*>(p, q));\\n        while (!myStack.empty()) {\\n            p = myStack.top().first;\\n            q = myStack.top().second;\\n            if (!p ^ !q || (p && q && p->val != q->val))\\n                break;\\n            myStack.pop();\\n            if (p && q) {\\n                myStack.push(pair<TreeNode*, TreeNode*> (p->right, q->right));\\n                myStack.push(pair<TreeNode*, TreeNode*> (p->left, q->left));\\n            }\\n        }\\n        return myStack.empty();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 32749,
                "title": "intuitive-javascript-solution",
                "content": "```\\nvar isSameTree = function(p, q) {\\n    // the same if both nodes are null\\n    if (!p && !q) return true;\\n    // not the same if either of the nodes is null or the values are different\\n    if ((!p && q) || (p && !q) || p.val !== q.val) return false;\\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvar isSameTree = function(p, q) {\\n    // the same if both nodes are null\\n    if (!p && !q) return true;\\n    // not the same if either of the nodes is null or the values are different\\n    if ((!p && q) || (p && !q) || p.val !== q.val) return false;\\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32916,
                "title": "recursive-non-recursive-recommend-for-beginners-clean-c-implementation",
                "content": "> Non-recursive solution\\n\\n    class Solution {\\n    public:\\n        bool isSameTree(TreeNode* p, TreeNode* q) {\\n            stack<TreeNode*> stack_p;\\n            stack<TreeNode*> stack_q;\\n            if(p)   stack_p.push(p);\\n            if(q)   stack_q.push(q);\\n            while(!stack_p.empty() && !stack_q.empty()){\\n                TreeNode* cur_p=stack_p.top();\\n                TreeNode* cur_q=stack_q.top();\\n                stack_p.pop();\\n                stack_q.pop();\\n                if(cur_p->val!=cur_q->val) return false;\\n                if(cur_p->left) stack_p.push(cur_p->left);\\n                if(cur_q->left) stack_q.push(cur_q->left);\\n                if(stack_p.size() != stack_q.size())    return false;\\n                if(cur_p->right) stack_p.push(cur_p->right);\\n                if(cur_q->right) stack_q.push(cur_q->right);\\n                if(stack_p.size() != stack_q.size())    return false;\\n            }\\n            return stack_p.size() == stack_q.size();\\n        }\\n    };\\n\\n\\n> Recursive Solution\\n\\n    class Solution {\\n    public:\\n        bool isSameTree(TreeNode* p, TreeNode* q) {\\n            if(!p && !q)    return true;\\n            if(!p || !q)    return false;\\n            return p->val==q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isSameTree(TreeNode* p, TreeNode* q) {\\n            stack<TreeNode*> stack_p;\\n            stack<TreeNode*> stack_q;\\n            if(p)   stack_p.push(p);\\n            if(q)   stack_q.push(q);\\n            while(!stack_p.empty() && !stack_q.empty()){\\n                TreeNode* cur_p=stack_p.top();\\n                TreeNode* cur_q=stack_q.top();\\n                stack_p.pop();\\n                stack_q.pop();\\n                if(cur_p->val!=cur_q->val) return false;\\n                if(cur_p->left) stack_p.push(cur_p->left);\\n                if(cur_q->left) stack_q.push(cur_q->left);\\n                if(stack_p.size() != stack_q.size())    return false;\\n                if(cur_p->right) stack_p.push(cur_p->right);\\n                if(cur_q->right) stack_q.push(cur_q->right);\\n                if(stack_p.size() != stack_q.size())    return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 463101,
                "title": "c-short-and-easy-o-n-iterative-solution",
                "content": "```\\n bool isSameTree(TreeNode* p, TreeNode* q) {\\n    queue<TreeNode*> queue;\\n    if(p==NULL || q==NULL) return p==q;\\n    queue.push(p); queue.push(q);\\n    while(!queue.empty())  {\\n        TreeNode* left = queue.front(); queue.pop();\\n        TreeNode *right = queue.front(); queue.pop();\\n        if(left==NULL && right==NULL) continue;\\n        if(left==NULL || right==NULL) return false;\\n        if(left->val != right->val) return false;\\n        queue.push(left->left);\\n        queue.push(right->left);\\n        queue.push(left->right);\\n        queue.push(right->right);\\n    }\\n    return true;  \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue",
                    "Iterator"
                ],
                "code": "```\\n bool isSameTree(TreeNode* p, TreeNode* q) {\\n    queue<TreeNode*> queue;\\n    if(p==NULL || q==NULL) return p==q;\\n    queue.push(p); queue.push(q);\\n    while(!queue.empty())  {\\n        TreeNode* left = queue.front(); queue.pop();\\n        TreeNode *right = queue.front(); queue.pop();\\n        if(left==NULL && right==NULL) continue;\\n        if(left==NULL || right==NULL) return false;\\n        if(left->val != right->val) return false;\\n        queue.push(left->left);\\n        queue.push(right->left);\\n        queue.push(left->right);\\n        queue.push(right->right);\\n    }\\n    return true;  \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 361737,
                "title": "python3-recursively-and-bfs-and-dfs-iteratively",
                "content": "* recursively\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"    \\n        # p and q are both None\\n        if not p and not q:\\n            return True\\n        # one of p and q is None\\n        if (not q or not p) or (p.val != q.val):\\n            return False\\n        return self.isSameTree(p.right, q.right) and self.isSameTree(p.left, q.left)\\n```\\n* DFS iteratively\\n```\\n# iterative DFS\\ndef isSameTree(p,q):\\n    stack =[(p,q)]\\n    while stack:\\n        p,q = stack.pop()\\n        if not p and not q:\\n            continue\\n        elif (not p or not q) or (p.val !=q.val):\\n            return False\\n        stack.extend([(q.right,p.right),(q.left,p.left)])\\n    return True\\n```\\n\\n* BFS iteratively\\n```\\n# iterative BFS\\ndef isSameTreeBFS(p,q):\\n    queue = collections.deque([p,q])\\n    while queue:\\n        p,q = queue.popleft()\\n        if not p and not q:\\n            continue\\n        elif (not p or not q) or (p.val != q.val):\\n            return False\\n        queue.extend([(p.left,q.left),(p.right,q.right)])\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"    \\n        # p and q are both None\\n        if not p and not q:\\n            return True\\n        # one of p and q is None\\n        if (not q or not p) or (p.val != q.val):\\n            return False\\n        return self.isSameTree(p.right, q.right) and self.isSameTree(p.left, q.left)\\n```\n```\\n# iterative DFS\\ndef isSameTree(p,q):\\n    stack =[(p,q)]\\n    while stack:\\n        p,q = stack.pop()\\n        if not p and not q:\\n            continue\\n        elif (not p or not q) or (p.val !=q.val):\\n            return False\\n        stack.extend([(q.right,p.right),(q.left,p.left)])\\n    return True\\n```\n```\\n# iterative BFS\\ndef isSameTreeBFS(p,q):\\n    queue = collections.deque([p,q])\\n    while queue:\\n        p,q = queue.popleft()\\n        if not p and not q:\\n            continue\\n        elif (not p or not q) or (p.val != q.val):\\n            return False\\n        queue.extend([(p.left,q.left),(p.right,q.right)])\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028413,
                "title": "funny-one-liner-py",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        return str(p) == str(q)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        return str(p) == str(q)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 301998,
                "title": "rust-one-line-solution",
                "content": "```Rust\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn is_same_tree(p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        p == q\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Rust\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn is_same_tree(p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        p == q\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32969,
                "title": "three-lines-java-solution",
                "content": "public class Same_Tree {\\n\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if (p == null || q == null) return p == q; // if they are null at the same time\\n\\n        if (p.val != q.val) return false;\\n\\n        return isSameTree(p.right, q.right) && isSameTree(p.left, q.left);\\n    }\\n}",
                "solutionTags": [],
                "code": "public class Same_Tree {\\n\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if (p == null || q == null) return p == q; // if they are null at the same time\\n\\n        if (p.val != q.val) return false;\\n\\n        return isSameTree(p.right, q.right) && isSameTree(p.left, q.left);\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 3028332,
                "title": "python-simple-python-solution-using-dfs-recursion",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 35 ms, faster than 73.56% of Python3 online submissions for Same Tree.\\n# Memory Usage: 13.8 MB, less than 72.95% of Python3 online submissions for Same Tree.\\n\\n\\tclass Solution:\\n\\t\\tdef isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n\\n\\t\\t\\tdef DFS(node1 , node2):\\n\\n\\t\\t\\t\\tif node1 == None and node2 == None:\\n\\t\\t\\t\\t\\treturn True\\n\\n\\t\\t\\t\\telif node1 == None or node2 == None:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\telif node1.val != node2.val:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\treturn DFS(node1.left , node2.left) and DFS(node1.right , node2.right)\\n\\n\\t\\t\\treturn DFS(p , q)\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 35 ms, faster than 73.56% of Python3 online submissions for Same Tree.\\n# Memory Usage: 13.8 MB, less than 72.95% of Python3 online submissions for Same Tree.\\n\\n\\tclass Solution:\\n\\t\\tdef isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n\\n\\t\\t\\tdef DFS(node1 , node2):\\n\\n\\t\\t\\t\\tif node1 == None and node2 == None:\\n\\t\\t\\t\\t\\treturn True\\n\\n\\t\\t\\t\\telif node1 == None or node2 == None:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\telif node1.val != node2.val:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\treturn DFS(node1.left , node2.left) and DFS(node1.right , node2.right)\\n\\n\\t\\t\\treturn DFS(p , q)\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 3027467,
                "title": "c-java-c-python-explained-beats-100-0ms",
                "content": "\\n# Appraoch (Recursive)\\n1. If both trees reach their end, then every node in them was checked (return True)\\n1. If one tree ends before the other (return False)\\n2. If a node is different than another (return False)\\n3. Call the function to check the left & right subtrees\\n4. return their conjunction (AND)\\n\\n![image.png](https://assets.leetcode.com/users/images/0c52c091-11e8-46d5-9868-93da969328cf_1673313225.8125043.png)\\n\\n# Explained Code\\n```cpp []\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == nullptr && q == nullptr) // Same tree\\n            return true; \\n        if(p == nullptr || q == nullptr) // Different size\\n            return false; \\n        if(p->val != q->val) // Different Nodes\\n            return false; \\n        return isSameTree(p->left,q->left) && // check left subtree\\n               isSameTree(p->right,q->right); // check right subtree\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null) // Same Tree\\n            return true;\\n        if(p == null || q == null) // Different Size\\n            return false;\\n        if(p.val != q.val) // Different Nodes\\n            return false;\\n        return  isSameTree(p.left,q.left) && // check left subtree\\n                isSameTree(p.right,q.right); // check right subtree\\n    }\\n}\\n```\\n```C []\\nbool isSameTree(struct TreeNode* p, struct TreeNode* q){\\n        if(p == NULL && q == NULL) // Same Tree\\n            return true;\\n        if(p == NULL || q == NULL) // Different Size\\n            return false;\\n        if(p->val != q->val) // Different Nodes\\n            return false;\\n        return isSameTree(p->left,q->left) &&// check left subtree\\n               isSameTree(p->right,q->right);// check right subtree\\n}\\n```\\n```Python []\\nclass Solution(object):\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p == None and q == None : # Same Tree\\n            return True\\n        if p == None or q == None : # Different Size\\n            return False\\n        if p.val != q.val : # Different Nodes \\n            return False\\n        return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n\\n```\\n# Raw Code\\n```cpp []\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == nullptr && q == nullptr) return true; \\n        if(p == nullptr || q == nullptr) return false; \\n        if(p->val != q->val) return false; \\n        return  isSameTree(p->left,q->left) &&\\n                isSameTree(p->right,q->right);\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null) return true;\\n        if(p == null || q == null) return false;\\n        if(p.val != q.val) return false;\\n        return  isSameTree(p.left,q.left) &&\\n                isSameTree(p.right,q.right);\\n    }\\n}\\n```\\n```C []\\nbool isSameTree(struct TreeNode* p, struct TreeNode* q){\\n        if(p == NULL && q == NULL) return true;\\n        if(p == NULL || q == NULL) return false;\\n        if(p->val != q->val) return false;\\n        return  isSameTree(p->left,q->left) &&\\n                isSameTree(p->right,q->right);\\n}\\n```\\n```Python []\\nclass Solution(object):\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p == None and q == None : return True\\n        if p == None or q == None : return False\\n        if p.val != q.val : return False\\n        return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n\\n```\\nTime Complexity : $$O(n)$$\\nSpace Complexity : $$O(n)$$\\n![image.png](https://assets.leetcode.com/users/images/5e74b192-b0fc-4ce2-a284-6be226aec420_1673312476.8145483.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C",
                    "Recursion"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == nullptr && q == nullptr) // Same tree\\n            return true; \\n        if(p == nullptr || q == nullptr) // Different size\\n            return false; \\n        if(p->val != q->val) // Different Nodes\\n            return false; \\n        return isSameTree(p->left,q->left) && // check left subtree\\n               isSameTree(p->right,q->right); // check right subtree\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null) // Same Tree\\n            return true;\\n        if(p == null || q == null) // Different Size\\n            return false;\\n        if(p.val != q.val) // Different Nodes\\n            return false;\\n        return  isSameTree(p.left,q.left) && // check left subtree\\n                isSameTree(p.right,q.right); // check right subtree\\n    }\\n}\\n```\n```C []\\nbool isSameTree(struct TreeNode* p, struct TreeNode* q){\\n        if(p == NULL && q == NULL) // Same Tree\\n            return true;\\n        if(p == NULL || q == NULL) // Different Size\\n            return false;\\n        if(p->val != q->val) // Different Nodes\\n            return false;\\n        return isSameTree(p->left,q->left) &&// check left subtree\\n               isSameTree(p->right,q->right);// check right subtree\\n}\\n```\n```Python []\\nclass Solution(object):\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p == None and q == None : # Same Tree\\n            return True\\n        if p == None or q == None : # Different Size\\n            return False\\n        if p.val != q.val : # Different Nodes \\n            return False\\n        return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n\\n```\n```cpp []\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == nullptr && q == nullptr) return true; \\n        if(p == nullptr || q == nullptr) return false; \\n        if(p->val != q->val) return false; \\n        return  isSameTree(p->left,q->left) &&\\n                isSameTree(p->right,q->right);\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null) return true;\\n        if(p == null || q == null) return false;\\n        if(p.val != q.val) return false;\\n        return  isSameTree(p.left,q.left) &&\\n                isSameTree(p.right,q.right);\\n    }\\n}\\n```\n```C []\\nbool isSameTree(struct TreeNode* p, struct TreeNode* q){\\n        if(p == NULL && q == NULL) return true;\\n        if(p == NULL || q == NULL) return false;\\n        if(p->val != q->val) return false;\\n        return  isSameTree(p->left,q->left) &&\\n                isSameTree(p->right,q->right);\\n}\\n```\n```Python []\\nclass Solution(object):\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p == None and q == None : return True\\n        if p == None or q == None : return False\\n        if p.val != q.val : return False\\n        return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1508218,
                "title": "c-python-simple-solution",
                "content": "**C++ :**\\n\\n```\\nbool isSameTree(TreeNode* p, TreeNode* q) {\\n\\tif(!p || !q)\\n\\t\\treturn (p == q);\\n\\n\\treturn (p -> val == q -> val) && isSameTree(p -> left, q -> left) && isSameTree(p -> right, q -> right);\\n}\\n```\\n\\n**Python :**\\n\\n```\\ndef isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n\\tif not p or not q:\\n\\t\\treturn p == q\\n\\n\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q. right)\\n```\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nbool isSameTree(TreeNode* p, TreeNode* q) {\\n\\tif(!p || !q)\\n\\t\\treturn (p == q);\\n\\n\\treturn (p -> val == q -> val) && isSameTree(p -> left, q -> left) && isSameTree(p -> right, q -> right);\\n}\\n```\n```\\ndef isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n\\tif not p or not q:\\n\\t\\treturn p == q\\n\\n\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q. right)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 32856,
                "title": "3-lines-java-solution",
                "content": "    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p==null && q==null) return true;\\n        if(p==null || q==null) return false;\\n        return (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n\\nrecursion",
                "solutionTags": [],
                "code": "    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p==null && q==null) return true;\\n        if(p==null || q==null) return false;\\n        return (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n\\nrecursion",
                "codeTag": "Unknown"
            },
            {
                "id": 33026,
                "title": "java-one-liner-and-the-more-readable-solution-it-was-derived-from",
                "content": "Just for fun;\\n\\n    return p == null || q == null ? p == null && q == null : p.val != q.val ? false : \\n         isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n\\n\\nThis is a ternary-if abusing version of the following (much more sensible) solution.\\n\\n    if (p == null || q == null) {\\n        return p == null && q == null;\\n    } else if (p.val == q.val) {\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n    return false;\\n\\nThere's not a whole lot of magic here. We know that if either p or q is null, then if they're not both null, the trees do not share the same shape. \\n\\nOtherwise we go on to recursively check the node's children iff the values of p and q are equal, returning false otherwise.",
                "solutionTags": [
                    "Java"
                ],
                "code": "Just for fun;\\n\\n    return p == null || q == null ? p == null && q == null : p.val != q.val ? false : \\n         isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n\\n\\nThis is a ternary-if abusing version of the following (much more sensible) solution.\\n\\n    if (p == null || q == null) {\\n        return p == null && q == null;\\n    } else if (p.val == q.val) {\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n    return false;\\n\\nThere's not a whole lot of magic here. We know that if either p or q is null, then if they're not both null, the trees do not share the same shape. \\n\\nOtherwise we go on to recursively check the node's children iff the values of p and q are equal, returning false otherwise.",
                "codeTag": "Unknown"
            },
            {
                "id": 2778173,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL &&  q== NULL) return true;\\n        if(p == NULL ||  q== NULL) return false;\\n        if(p->val != q->val) return false;\\n        return isSameTree(p->right, q->right) && isSameTree(p->left, q->left) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL &&  q== NULL) return true;\\n        if(p == NULL ||  q== NULL) return false;\\n        if(p->val != q->val) return false;\\n        return isSameTree(p->right, q->right) && isSameTree(p->left, q->left) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919297,
                "title": "c-100-faster-100-memory-efficient-easy-code",
                "content": "If one of the tree is NULL, then ans is \\'false\\'\\nIf both the trees are NULL, then ans is \\'true\\'\\n\\n**1. Recursive approach :**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isSameTree(TreeNode* p, TreeNode* q) {\\n\\t\\t\\t\\n\\t\\t\\tif(p==NULL && q!=NULL)return false;\\n\\t\\t\\tif(q==NULL && p!=NULL)return false;\\n\\n\\t\\t\\tif(p==NULL && q==NULL)return true;\\n\\n\\t\\t\\tbool l=false;\\n\\t\\t\\tbool r = false;\\n\\n\\t\\t\\tif(p->val == q->val){\\n\\t\\t\\t\\tl = isSameTree(p->left,q->left);\\n\\t\\t\\t\\tr = isSameTree(p->right,q->right);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn l&r;        \\n\\t\\t}\\n\\t};\\n\\t\\n**2. Iterative approach:**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isSameTree(TreeNode* p, TreeNode* q) {\\n\\n\\t\\t\\t//for iterative approach, we generally follow the 4 major steps:\\n\\t\\t\\t//1. Make a queue \\n\\t\\t\\t//2. Push the current Node in the queue (starting from the root node)\\n\\t\\t\\t//3. Process the queue, while its not empty (by adding its left & right child)\\n\\t\\t\\t//4. Once the queue is empty, then alorithm has finished\\n\\n\\t\\t\\t//Step 1\\n\\t\\t\\tqueue<TreeNode*> qu;  \\n\\n\\t\\t\\t//Step 2\\n\\t\\t\\tqu.push(p);\\n\\t\\t\\tqu.push(q);\\n\\n\\t\\t\\t//step 3\\n\\t\\t\\twhile(qu.size() != 0){\\n\\t\\t\\t\\tTreeNode* n1 = qu.front();\\n\\t\\t\\t\\tqu.pop();\\n\\t\\t\\t\\tTreeNode* n2 = qu.front();\\n\\t\\t\\t\\tqu.pop();\\n\\n\\t\\t\\t\\t//meet the question conditions\\n\\t\\t\\t\\tif(n1 == NULL && n2 == NULL) continue;\\n\\t\\t\\t\\tif(n1 == NULL || n2 == NULL) return false;\\n\\t\\t\\t\\tif(n1->val != n2->val) return false;\\n\\n\\t\\t\\t\\tqu.push(n1->left);\\n\\t\\t\\t\\tqu.push(n2->left);\\n\\t\\t\\t\\tqu.push(n1->right);\\n\\t\\t\\t\\tqu.push(n2->right);\\n\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t//Step 4\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool isSameTree(TreeNode* p, TreeNode* q) {\\n\\t\\t\\t\\n\\t\\t\\tif(p==NULL && q!=NULL)return false;\\n\\t\\t\\tif(q==NULL && p!=NULL)return false;\\n\\n\\t\\t\\tif(p==NULL && q==NULL)return true;\\n\\n\\t\\t\\tbool l=false;\\n\\t\\t\\tbool r = false;\\n\\n\\t\\t\\tif(p->val == q->val){\\n\\t\\t\\t\\tl = isSameTree(p->left,q->left);\\n\\t\\t\\t\\tr = isSameTree(p->right,q->right);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3027471,
                "title": "javascript-simple-video-explanation-dfs",
                "content": "# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\nhttps://youtu.be/37Q-F5qqsXw\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nvar isSameTree = function(p, q) {\\n    if (!p && !q) return true\\n    if (!p || !q || p.val !== q.val) return false\\n    return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right))\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvar isSameTree = function(p, q) {\\n    if (!p && !q) return true\\n    if (!p || !q || p.val !== q.val) return false\\n    return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right))\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1926231,
                "title": "100-fastest-swift-solution-time-o-min-n-m-space-o-min-n-m",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(min(n, m)), where n is the number of nodes in p and m is the number of nodes in q.\\n    //   - space: O(min(n, m)), where n is the number of nodes in p and m is the number of nodes in q.\\n    \\n    func isSameTree(_ p: TreeNode?, _ q: TreeNode?) -> Bool {\\n        guard p != nil || q != nil else { return true }\\n        \\n        guard let p = p, let q = q else { return false }\\n        \\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(min(n, m)), where n is the number of nodes in p and m is the number of nodes in q.\\n    //   - space: O(min(n, m)), where n is the number of nodes in p and m is the number of nodes in q.\\n    \\n    func isSameTree(_ p: TreeNode?, _ q: TreeNode?) -> Bool {\\n        guard p != nil || q != nil else { return true }\\n        \\n        guard let p = p, let q = q else { return false }\\n        \\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028320,
                "title": "explanation-with-images-clean-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst, think from the smallest part. The smallest part or the base case of a tree to consider is when it is null.\\n\\n- If both trees are null, they are the same. So, we will return true.\\n- If one of them is null, then they cannot be equal. So, we will return false.\\n\\n![image.png](https://assets.leetcode.com/users/images/a0233f35-a325-4a35-84d2-6ce2767a81dc_1673326587.6208208.png)\\n\\n- When both nodes are not null, we first need to check if the values are equal. Then we will traverse the left subtree and the right subtree of the both tree sequentially.\\n\\n- Check if `p.val == q.val`:\\n\\n![image.png](https://assets.leetcode.com/users/images/7c934401-4552-40ff-8b3c-d1ad64758202_1673326852.0365388.png)\\n\\n- Recursively call the left and right subtree:\\n\\n- Left Subtree `isSameTree(p.left, q.left)` :\\n\\n![image.png](https://assets.leetcode.com/users/images/a359591a-bcf4-4b46-8e47-3ee1d7c598cc_1673326981.6579647.png)\\n\\n- Right Subtree `isSameTree(p.right, q.right)` :\\n\\n![image.png](https://assets.leetcode.com/users/images/5e6e7bfb-a2e2-4114-8085-9175430c08de_1673327073.0911453.png)\\n\\n\\n- Now, all of these must return true. So, the recursive call should return:\\n\\n`p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right)`\\n\\nIf one of them is not true, it will be false. That\\'s why we need the && operation.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAs we visit every node of the tree.\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe recursion stack is called n times in worst case. So, it will need $$O(n)$$ memory.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null){\\n            return true;\\n        }\\n        if(p == null || q == null){\\n            return false;\\n        }\\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null){\\n            return true;\\n        }\\n        if(p == null || q == null){\\n            return false;\\n        }\\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028316,
                "title": "rust-derive-eq",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe defination of TreeNode derived the Eq trait so the answer is just use it.\\n\\n# Code\\n```\\nuse std::cell::RefCell;\\nuse std::rc::Rc;\\n\\nimpl Solution {\\n    pub fn is_same_tree(\\n        p: Option<Rc<RefCell<TreeNode>>>,\\n        q: Option<Rc<RefCell<TreeNode>>>,\\n    ) -> bool {\\n        p == q\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cell::RefCell;\\nuse std::rc::Rc;\\n\\nimpl Solution {\\n    pub fn is_same_tree(\\n        p: Option<Rc<RefCell<TreeNode>>>,\\n        q: Option<Rc<RefCell<TreeNode>>>,\\n    ) -> bool {\\n        p == q\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 766257,
                "title": "rust-recursive-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Rust online submissions for Same Tree.\\nMemory Usage: 2 MB, less than 100.00% of Rust online submissions for Same Tree.\\n```\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn is_same_tree(p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        match (p, q) {\\n            (None, None) => true,\\n            (Some(p), Some(q)) => {\\n                let p = p.borrow();\\n                let q = q.borrow();\\n                p.val == q.val\\n                    && Self::is_same_tree(p.left.clone(), q.left.clone())\\n                    && Self::is_same_tree(p.right.clone(), q.right.clone())\\n            }\\n            _ => false,\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn is_same_tree(p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        match (p, q) {\\n            (None, None) => true,\\n            (Some(p), Some(q)) => {\\n                let p = p.borrow();\\n                let q = q.borrow();\\n                p.val == q.val\\n                    && Self::is_same_tree(p.left.clone(), q.left.clone())\\n                    && Self::is_same_tree(p.right.clone(), q.right.clone())\\n            }\\n            _ => false,\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 560321,
                "title": "python-js-go-c-o-n-sol-by-dfs-w-visualization",
                "content": "[\\u4E2D\\u6587\\u8A73\\u89E3\\u89E3\\u984C\\u6587\\u7AE0](https://vocus.cc/article/6506b5dbfd89780001901407)\\n\\nO(n) sol by DFS\\n\\n---\\n\\n**Diagram** and **Abstract Model**:\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1585824141.png)\\n\\n\\n---\\n\\n\\n**Implementation** by DFS:\\n\\nPython:\\n\\n```\\n\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        \\n        if p and q:\\n            \\n            # Both p and q are non-empty\\n            # Check equality on both subtree\\n            return (p.val == q.val) and self.isSameTree( p.left, q.left) and self.isSameTree( p.right, q.right )\\n        \\n        else:\\n            \\n            # At least one of them is empty\\n            # Check whether both p and q are empty or not\\n            return p == q\\n```\\n\\n---\\n\\nJavascript:\\n\\n```\\nvar isSameTree = function(p, q) {\\n\\n    if( p && q ){\\n        \\n        // Both p and q are non-empty\\n        // Check equality on both subtree\\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n        \\n    }else{\\n        \\n        // At least one of them is empty\\n        // Check whether both p and q are empty or not\\n        return p == q;    \\n    }\\n    \\n};\\n```\\n\\n---\\n\\nGo:\\n\\n```\\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\\n    \\n    if( (p!=nil) && (q!=nil) ){\\n        \\n        // Both p and q are non-empty\\n        // Check equality on both subtree\\n        return (p.Val == q.Val) && isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)\\n        \\n    }else{\\n        \\n        // At least one of them is empty\\n        // Check whether both p and q are empty or not\\n        return p == q\\n    }\\n    \\n}\\n```\\n\\n---\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n     \\n        if( p && q){\\n            \\n            // Both p and q are non-empty\\n            // Check equality on both subtree\\n            return p->val == q->val && isSameTree( p->left, q->left) && isSameTree( p->right, q->right);\\n            \\n        }else{\\n            \\n            // At least one of them is empty\\n            // Check whether both p and q are empty or not\\n            return p == q;\\n        }\\n    }\\n};\\n```\\n\\n\\n---\\n\\nAnother **Implementation** by BFS :\\n\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n\\n        def bfs( node: TreeNode ):\\n            \\n            cur_queue = [ node ] if node else [ None ]\\n\\n            while cur_queue:\\n                \\n                next_queue = []\\n                \\n                for cur_node in cur_queue:\\n                    \\n                    if cur_node:\\n                        \\n                        yield cur_node.val\\n                        \\n                        next_queue.append( cur_node.left )\\n                        next_queue.append( cur_node.right )\\n                        \\n                    else:\\n                        yield None\\n            \\n                cur_queue = next_queue\\n            \\n        # -----------------------------------------------------\\n        \\n        iterator_p =  bfs( p ) \\n        iterator_q =  bfs( q ) \\n        \\n        while True:\\n            try:\\n                if next(iterator_p) != next(iterator_q):\\n                    return False\\n            except StopIteration:\\n                break\\n        \\n        return True\\n```\\n\\n---\\n\\n\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #101 Symmetric Tree](https://leetcode.com/problems/symmetric-tree/)\\n\\n[Leetcode #144 Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal)\\n\\n---\\n\\nReference:\\n\\n[Wiki: Pre-order traversal of binary tree](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR))\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Go",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        \\n        if p and q:\\n            \\n            # Both p and q are non-empty\\n            # Check equality on both subtree\\n            return (p.val == q.val) and self.isSameTree( p.left, q.left) and self.isSameTree( p.right, q.right )\\n        \\n        else:\\n            \\n            # At least one of them is empty\\n            # Check whether both p and q are empty or not\\n            return p == q\\n```\n```\\nvar isSameTree = function(p, q) {\\n\\n    if( p && q ){\\n        \\n        // Both p and q are non-empty\\n        // Check equality on both subtree\\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n        \\n    }else{\\n        \\n        // At least one of them is empty\\n        // Check whether both p and q are empty or not\\n        return p == q;    \\n    }\\n    \\n};\\n```\n```\\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\\n    \\n    if( (p!=nil) && (q!=nil) ){\\n        \\n        // Both p and q are non-empty\\n        // Check equality on both subtree\\n        return (p.Val == q.Val) && isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)\\n        \\n    }else{\\n        \\n        // At least one of them is empty\\n        // Check whether both p and q are empty or not\\n        return p == q\\n    }\\n    \\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n     \\n        if( p && q){\\n            \\n            // Both p and q are non-empty\\n            // Check equality on both subtree\\n            return p->val == q->val && isSameTree( p->left, q->left) && isSameTree( p->right, q->right);\\n            \\n        }else{\\n            \\n            // At least one of them is empty\\n            // Check whether both p and q are empty or not\\n            return p == q;\\n        }\\n    }\\n};\\n```\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n\\n        def bfs( node: TreeNode ):\\n            \\n            cur_queue = [ node ] if node else [ None ]\\n\\n            while cur_queue:\\n                \\n                next_queue = []\\n                \\n                for cur_node in cur_queue:\\n                    \\n                    if cur_node:\\n                        \\n                        yield cur_node.val\\n                        \\n                        next_queue.append( cur_node.left )\\n                        next_queue.append( cur_node.right )\\n                        \\n                    else:\\n                        yield None\\n            \\n                cur_queue = next_queue\\n            \\n        # -----------------------------------------------------\\n        \\n        iterator_p =  bfs( p ) \\n        iterator_q =  bfs( q ) \\n        \\n        while True:\\n            try:\\n                if next(iterator_p) != next(iterator_q):\\n                    return False\\n            except StopIteration:\\n                break\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 543621,
                "title": "javascript-recursion-iterative",
                "content": "- Time Complexity: O(N)\\n- Space Complexity: O(H)\\n```JavaScript\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n    if (!p && !q) return true;\\n    if (!p || !q) return false;\\n    return p.val === q.val\\n        && isSameTree(p.left, q.left)\\n        && isSameTree(p.right, q.right);\\n};\\n```\\n```JavaScript\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n    const stack1 = [], stack2 = [];\\n    while (p || q || stack1.length || stack2.length) {\\n        while (p) {\\n            stack1.push(p);\\n            p = p.left\\n        }\\n        while (q) {\\n            stack2.push(q);\\n            q = q.left;\\n        }\\n        p = stack1.pop();\\n        q = stack2.pop();\\n        if (!p && !q) {\\n            continue;\\n        }\\n        if (!p || !q || p.val !== q.val) {\\n            return false;\\n        }\\n        stack1.push(null);\\n        stack2.push(null);\\n        p = p.right;\\n        q = q.right;\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```JavaScript\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n    if (!p && !q) return true;\\n    if (!p || !q) return false;\\n    return p.val === q.val\\n        && isSameTree(p.left, q.left)\\n        && isSameTree(p.right, q.right);\\n};\\n```\n```JavaScript\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n    const stack1 = [], stack2 = [];\\n    while (p || q || stack1.length || stack2.length) {\\n        while (p) {\\n            stack1.push(p);\\n            p = p.left\\n        }\\n        while (q) {\\n            stack2.push(q);\\n            q = q.left;\\n        }\\n        p = stack1.pop();\\n        q = stack2.pop();\\n        if (!p && !q) {\\n            continue;\\n        }\\n        if (!p || !q || p.val !== q.val) {\\n            return false;\\n        }\\n        stack1.push(null);\\n        stack2.push(null);\\n        p = p.right;\\n        q = q.right;\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 456229,
                "title": "python-recursion-iteration",
                "content": "# Recursion:\\n```python\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        if not p or not q: return p == q\\n        if p.val != q.val: return False\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```\\nRuntime: 24 ms, faster than 95.22% of Python3 online submissions for Same Tree.\\nMemory Usage: 12.8 MB, less than 100.00% of Python3 online submissions for Same Tree.\\n\\n\\n# Iteration:\\none function\\n```python\\nfrom collections import deque\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        def check(p,q):\\n            if not p and not q:  return True\\n            if not p or not q:  return False\\n            if p.val != q.val: return False\\n            return True\\n        deq = deque([(p , q),])\\n        while deq:\\n            p , q = deq.popleft()\\n            if not check(p , q): return False\\n            if p:\\n                deq.append((p.left , q.left))\\n                deq.append((p.right , q.right))\\n        return True\\n```\\nRuntime: 28 ms, faster than 85.04% of Python3 online submissions for Same Tree.\\nMemory Usage: 12.7 MB, less than 100.00% of Python3 online submissions for Same Tree.\\n\\ntwo function , which is more easy to understand\\n```python\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        stack = [(p, q)]\\n        while stack:\\n            n1, n2 = stack.pop()\\n            if not n1 and not n2: continue\\n            if not n1 or not n2: return n1 == n2\\n            if n1.val != n2.val: return False\\n            stack.append((n1.right, n2.right))\\n            stack.append((n1.left, n2.left))\\n        return True\\n```\\nRuntime: 28 ms, faster than 85.04% of Python3 online submissions for Same Tree.\\nMemory Usage: 12.8 MB, less than 100.00% of Python3 online submissions for Same Tree.\\n\\nRecursion is faster a little \\n\\n**If it helps you , \\nPlease give me a vote star\\nThanls**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        if not p or not q: return p == q\\n        if p.val != q.val: return False\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```\n```python\\nfrom collections import deque\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        def check(p,q):\\n            if not p and not q:  return True\\n            if not p or not q:  return False\\n            if p.val != q.val: return False\\n            return True\\n        deq = deque([(p , q),])\\n        while deq:\\n            p , q = deq.popleft()\\n            if not check(p , q): return False\\n            if p:\\n                deq.append((p.left , q.left))\\n                deq.append((p.right , q.right))\\n        return True\\n```\n```python\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        stack = [(p, q)]\\n        while stack:\\n            n1, n2 = stack.pop()\\n            if not n1 and not n2: continue\\n            if not n1 or not n2: return n1 == n2\\n            if n1.val != n2.val: return False\\n            stack.append((n1.right, n2.right))\\n            stack.append((n1.left, n2.left))\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 432219,
                "title": "python-20ms-beats-99-64",
                "content": "```\\n\\nclass Solution:\\n    def preOrder(self,a,l):\\n        if not a:\\n            l.append(None)\\n        else:\\n            l.append(a.val)\\n            self.preOrder(a.left,l)\\n            self.preOrder(a.right,l)\\n        return l\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        pl=self.preOrder(p,[])\\n        ql=self.preOrder(q,[])\\n        return(pl==ql)\\n\\t\\t\\n```\\n   \\n        \\n        \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def preOrder(self,a,l):\\n        if not a:\\n            l.append(None)\\n        else:\\n            l.append(a.val)\\n            self.preOrder(a.left,l)\\n            self.preOrder(a.right,l)\\n        return l\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        pl=self.preOrder(p,[])\\n        ql=self.preOrder(q,[])\\n        return(pl==ql)\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293440,
                "title": "just-3-lines-of-code-superb-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:----->90%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:---->99%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        def iss(p,q):\\n            if p==None and q==None: return True\\n            if p==None or q==None: return False\\n            return p.val==q.val and iss(p.left,q.left) and iss(p.right,q.right)\\n        return iss(p,q)\\n    #please upvote me it would encourage me alot\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        def iss(p,q):\\n            if p==None and q==None: return True\\n            if p==None or q==None: return False\\n            return p.val==q.val and iss(p.left,q.left) and iss(p.right,q.right)\\n        return iss(p,q)\\n    #please upvote me it would encourage me alot\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027571,
                "title": "c-easy-solution",
                "content": "```re\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(!p and !q)\\n        return true;\\n        if(!p || !q)\\n        return false;\\n        if(p->val!=q->val)\\n        return false;\\n        return isSameTree(p->left,q->left) and isSameTree(p->right, q->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree"
                ],
                "code": "```re\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(!p and !q)\\n        return true;\\n        if(!p || !q)\\n        return false;\\n        if(p->val!=q->val)\\n        return false;\\n        return isSameTree(p->left,q->left) and isSameTree(p->right, q->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 733818,
                "title": "c-simple-one-line-performing-100-time-90-space-recursive-solution-explained",
                "content": "First of all I check if both nodes are `NULL`, in which case I return `true`; if it is `false`, then I move to the right term of my `||` statement as follows.\\n\\nIf at least one of them is not `NULL`, then I make sure that they both are valid (ie: non terminal, non `NULL`) nodes (`p && q`,  I can stop there if see that one is `NULL` and other is not). If that is `true` (both are valid nodes), then I can access their properties without fearing errors and first of all I compare their `val`s; if they match, I progress onwars, calling the function recursively on their `left` and then `right` branches.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        return !p && !q || p && q && p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    }\\n};\\n```\\n\\nThe kind of sweet problem that you solve in one line, first attempt and that sets your mood for the day (and hopefully the week as well!) - thanks LC :)\\n\\nEdit: now that I posted, I see that actually this solution is giving me consistenly 100% time - title updated!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        return !p && !q || p && q && p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 33022,
                "title": "simple-iterative-solution",
                "content": "    public class Solution {\\n        public boolean isSameTree(TreeNode p, TreeNode q) {\\n            if(p == null && q == null){\\n    \\t\\t\\treturn true;\\n    \\t\\t}\\n    \\t\\t//structure\\n    \\t\\tif(p == null || q == null){\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\t//val\\n    \\t\\tif(p.val != q.val){\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tStack<TreeNode> stk1 = new Stack<TreeNode>();\\n    \\t\\tStack<TreeNode> stk2 = new Stack<TreeNode>();\\n    \\t\\tstk1.push(p);\\n    \\t\\tstk2.push(q);\\n    \\t\\t\\n    \\t\\twhile( !stk1.isEmpty() && !stk2.isEmpty() ){\\n    \\t\\t\\tTreeNode tn1 = stk1.pop();\\n    \\t\\t\\tTreeNode tn2 = stk2.pop();\\n    \\t\\t\\t\\n    \\t\\t\\tif(tn1.val != tn2.val){\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t\\t}\\n    \\t\\t\\t//structure different\\n    \\t\\t\\tif(tn1.left == null && tn2.left != null){\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t\\t}else if (tn1.left != null && tn2.left == null){\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t\\t}else if (tn1.right == null && tn2.right != null){\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t\\t}else if (tn1.right != null && tn2.right == null) {\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t\\t}\\n    \\t\\t\\t\\n    \\t\\t\\tif(tn1.left != null && tn2.left != null){\\n    \\t\\t\\t\\tstk1.push(tn1.left);\\n    \\t\\t\\t\\tstk2.push(tn2.left);\\n    \\t\\t\\t}\\n    \\t\\t\\t\\n    \\t\\t\\tif(tn1.right != null && tn2.right != null){\\n    \\t\\t\\t\\tstk1.push(tn1.right);\\n    \\t\\t\\t\\tstk2.push(tn2.right);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn true;\\n            \\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "class Solution {\\n        public boolean isSameTree(TreeNode p, TreeNode q) {\\n            if(p == null && q == null){\\n    \\t\\t\\treturn true;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1300535,
                "title": "c-3-statements-only-easily-understand-recursion",
                "content": "Here we simply trasverse each node of both the given trees and compare if each of their child is similar with current root. If all of them returns `true` then keep on checking and at any time if we get `false` we return the answer.\\n```\\nclass Solution {\\npublic:\\n    \\n    bool isSameTree(TreeNode* p, TreeNode* q) \\n    {\\n        if(p == NULL && q == NULL)\\n            return true;\\n        \\n        if(p == NULL || q == NULL)\\n            return false;\\n        \\n        return (p->val == q->val) && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n\\t\\t//If value at root and both childs are same\\n    }\\n};\\n```\\n\\u2728 PS : I am learning and trying to help the community ! Still not sure if my solution is the best one, even after 0ms. Feel free to give your suggestions or correct me in the comments :slight_smile:. Thanks for reading.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isSameTree(TreeNode* p, TreeNode* q) \\n    {\\n        if(p == NULL && q == NULL)\\n            return true;\\n        \\n        if(p == NULL || q == NULL)\\n            return false;\\n        \\n        return (p->val == q->val) && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n\\t\\t//If value at root and both childs are same\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1083292,
                "title": "non-recursive-javscript",
                "content": "```\\nvar isSameTree = function(p, q) {\\n    let stack = [[p,q]];\\n    \\n    while (stack.length){\\n        let [x,y] = stack.shift();\\n\\t\\t\\n        // if both leaves\\n        if (x==null && y==null) continue; \\n        if(!x || !y) return false;\\n        if(x.val == y.val){\\n            stack.push([x.left, y.left]);\\n            stack.push([x.right, y.right]);\\n        }\\n        else return false;\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isSameTree = function(p, q) {\\n    let stack = [[p,q]];\\n    \\n    while (stack.length){\\n        let [x,y] = stack.shift();\\n\\t\\t\\n        // if both leaves\\n        if (x==null && y==null) continue; \\n        if(!x || !y) return false;\\n        if(x.val == y.val){\\n            stack.push([x.left, y.left]);\\n            stack.push([x.right, y.right]);\\n        }\\n        else return false;\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 557390,
                "title": "c-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of C online submissions for Same Tree.\\nMemory Usage: 5.3 MB, less than 100.00% of C online submissions for Same Tree.\\n\\n```c\\nbool isSameTree(struct TreeNode* p, struct TreeNode* q){\\n    if (p == NULL && q == NULL) {\\n        return true;\\n    } else if (p == NULL || q == NULL) {\\n        return false;\\n    }\\n    \\n    if (p->val == q->val) {\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    } else {\\n        return false;\\n    }\\n} \\n```",
                "solutionTags": [],
                "code": "```c\\nbool isSameTree(struct TreeNode* p, struct TreeNode* q){\\n    if (p == NULL && q == NULL) {\\n        return true;\\n    } else if (p == NULL || q == NULL) {\\n        return false;\\n    }\\n    \\n    if (p->val == q->val) {\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    } else {\\n        return false;\\n    }\\n} \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32884,
                "title": "oh-java-thou-beauty",
                "content": "    public class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p==null && q==null) return true;\\n        if((q==null || p==null)) return false\\n        return (p.val == q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p==null && q==null) return true;\\n        if((q==null || p==null)) return false\\n        return (p.val == q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3187804,
                "title": "100-same-tree-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis problem can be solved recursively. We first check if the roots of the two trees are equal. Then we check recursively if the left and right subtrees of the two trees are equal.\\n\\n# Complexity\\n- Time complexity:\\nO(N) where N is the number of nodes in the larger tree.\\n\\n- Space complexity:\\nO(H) where H is the height of the larger tree. In the worst case, the space complexity can be O(N) when the tree is completely unbalanced.\\n\\n# Code\\n```\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        # if both nodes are None, return True\\n        if not p and not q:\\n            return True\\n        # if one of the nodes is None, return False\\n        if not p or not q:\\n            return False\\n        # if the values of the nodes are not equal, return False\\n        if p.val != q.val:\\n            return False\\n        # check recursively if the left and right subtrees are equal\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        # if both nodes are None, return True\\n        if not p and not q:\\n            return True\\n        # if one of the nodes is None, return False\\n        if not p or not q:\\n            return False\\n        # if the values of the nodes are not equal, return False\\n        if p.val != q.val:\\n            return False\\n        # check recursively if the left and right subtrees are equal\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036465,
                "title": "c-solution-with-video",
                "content": "# Video\\nhttps://youtu.be/m_oZLz8tk8g\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (!p && !q) return true;\\n        if (!p || !q) return false;\\n        \\n        return (\\n            p->val == q->val &&\\n            isSameTree(p->left, q->left) &&\\n            isSameTree(p->right, q->right)\\n        );\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (!p && !q) return true;\\n        if (!p || !q) return false;\\n        \\n        return (\\n            p->val == q->val &&\\n            isSameTree(p->left, q->left) &&\\n            isSameTree(p->right, q->right)\\n        );\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028181,
                "title": "simple-recursive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL&&q==NULL)\\n        return true;\\n        if((p==NULL&&q!=NULL)||(p!=NULL&&q==NULL)||(p->val!=q->val))\\n        return false;\\n        if(isSameTree(p->left, q->left)==false||isSameTree(p->right, q->right)==false)\\n        return false;\\n        return true;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL&&q==NULL)\\n        return true;\\n        if((p==NULL&&q!=NULL)||(p!=NULL&&q==NULL)||(p->val!=q->val))\\n        return false;\\n        if(isSameTree(p->left, q->left)==false||isSameTree(p->right, q->right)==false)\\n        return false;\\n        return true;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2419286,
                "title": "very-easy-0-ms-100-fully-explained-c-java-python-js-c-python3",
                "content": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\\n# **Java Solution:**\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Same Tree.\\n```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // If both trees are empty then return true...\\n        if(p == null && q == null) {\\n            return true;\\n        }\\n        // If one of the tree is empty and the other is not then return false...\\n        else if(p == null || q == null) {\\n            return false;\\n        }\\n        // If the value of p tree is equal to the value of q tree...\\n        if(p.val == q.val){\\n            // Check left subtrees and right subtrees recursively...\\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n        }\\n        // If the value is different, false is returned\\n        else{\\n            return false;\\n        }\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\nRuntime: 2 ms, faster than 89.56% of C++ online submissions for Same Tree.\\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        // If both trees are empty then return true...\\n        if(p == NULL && q == NULL)\\n            return true;\\n        // If one of the tree is empty and the other is not or the value of p tree is not equal to the value of q tree, then return false...\\n        if(p == NULL || q == NULL || p->val != q->val)\\n            return false;\\n        // If both trees are non empty and the value of p tree is equal to the value of q tree...\\n        // Check left subtrees and right subtrees recursively...\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    }\\n};\\n```\\n\\n# **Python Solution:**\\n```\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        # If both trees are empty then return true...\\n        if p == None and q == None:\\n            return True\\n        # If one of the tree is empty and the other is not then return false...\\n        elif p == None or q == None:\\n            return False\\n        # If the value of p tree is equal to the value of q tree...\\n        elif p.val == q.val:\\n            # continue to judge the value of the left and right subtrees\\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        # If the value is different, false is returned\\n        return False\\n```\\n        \\n# **JavaSript Solution:**\\n```\\nvar isSameTree = function(p, q) {\\n    // If both trees are empty then return true...\\n    if(p == null && q == null) {\\n        return true;\\n    }\\n    // If one of the tree is empty and the other is not then return false...\\n    else if(p == null || q == null) {\\n        return false;\\n    }\\n    // If the value of p tree is equal to the value of q tree...\\n    if(p.val == q.val){\\n        // Check left subtrees and right subtrees recursively...\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n    // If the value is different, false is returned\\n    else{\\n        return false;\\n    }\\n};\\n```\\n\\n# **C Language:**\\n```\\nbool isSameTree(struct TreeNode* p, struct TreeNode* q){\\n    // If both trees are empty then return true...\\n    if(p == NULL && q == NULL)\\n        return true;\\n    // If one of the tree is empty and the other is not or the value of p tree is not equal to the value of q tree, then return false...\\n    if(p == NULL || q == NULL || p->val != q->val)\\n        return false;\\n    // If both trees are non empty and the value of p tree is equal to the value of q tree...\\n    // Check left subtrees and right subtrees recursively...\\n    return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n}\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        # If both trees are empty then return true...\\n        if p == None and q == None:\\n            return True\\n        # If one of the tree is empty and the other is not then return false...\\n        elif p == None or q == None:\\n            return False\\n        # If the value of p tree is equal to the value of q tree...\\n        elif p.val == q.val:\\n            # continue to judge the value of the left and right subtrees\\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        # If the value is different, false is returned\\n        return False\\n```\\n**I am working hard for you guys...\\nPlease upvote if you find any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // If both trees are empty then return true...\\n        if(p == null && q == null) {\\n            return true;\\n        }\\n        // If one of the tree is empty and the other is not then return false...\\n        else if(p == null || q == null) {\\n            return false;\\n        }\\n        // If the value of p tree is equal to the value of q tree...\\n        if(p.val == q.val){\\n            // Check left subtrees and right subtrees recursively...\\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n        }\\n        // If the value is different, false is returned\\n        else{\\n            return false;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        // If both trees are empty then return true...\\n        if(p == NULL && q == NULL)\\n            return true;\\n        // If one of the tree is empty and the other is not or the value of p tree is not equal to the value of q tree, then return false...\\n        if(p == NULL || q == NULL || p->val != q->val)\\n            return false;\\n        // If both trees are non empty and the value of p tree is equal to the value of q tree...\\n        // Check left subtrees and right subtrees recursively...\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        # If both trees are empty then return true...\\n        if p == None and q == None:\\n            return True\\n        # If one of the tree is empty and the other is not then return false...\\n        elif p == None or q == None:\\n            return False\\n        # If the value of p tree is equal to the value of q tree...\\n        elif p.val == q.val:\\n            # continue to judge the value of the left and right subtrees\\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        # If the value is different, false is returned\\n        return False\\n```\n```\\nvar isSameTree = function(p, q) {\\n    // If both trees are empty then return true...\\n    if(p == null && q == null) {\\n        return true;\\n    }\\n    // If one of the tree is empty and the other is not then return false...\\n    else if(p == null || q == null) {\\n        return false;\\n    }\\n    // If the value of p tree is equal to the value of q tree...\\n    if(p.val == q.val){\\n        // Check left subtrees and right subtrees recursively...\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n    // If the value is different, false is returned\\n    else{\\n        return false;\\n    }\\n};\\n```\n```\\nbool isSameTree(struct TreeNode* p, struct TreeNode* q){\\n    // If both trees are empty then return true...\\n    if(p == NULL && q == NULL)\\n        return true;\\n    // If one of the tree is empty and the other is not or the value of p tree is not equal to the value of q tree, then return false...\\n    if(p == NULL || q == NULL || p->val != q->val)\\n        return false;\\n    // If both trees are non empty and the value of p tree is equal to the value of q tree...\\n    // Check left subtrees and right subtrees recursively...\\n    return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n}\\n```\n```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        # If both trees are empty then return true...\\n        if p == None and q == None:\\n            return True\\n        # If one of the tree is empty and the other is not then return false...\\n        elif p == None or q == None:\\n            return False\\n        # If the value of p tree is equal to the value of q tree...\\n        elif p.val == q.val:\\n            # continue to judge the value of the left and right subtrees\\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        # If the value is different, false is returned\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1726340,
                "title": "100-faster-and-elegant-c-solution",
                "content": "Dear All,\\n\\nPlease find below 100% faster and elegant C++ Solution:\\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if( p == nullptr && q == nullptr ) return true;\\n        if( p == nullptr || q == nullptr ) return false;\\n        if( p->val != q->val ) return false;\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    }\\n};\\n```\\n\\nHope you found this solution useful.\\n\\nThank you and have a good day.\\n\\nBest regards, Yevhen.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if( p == nullptr && q == nullptr ) return true;\\n        if( p == nullptr || q == nullptr ) return false;\\n        if( p->val != q->val ) return false;\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471532,
                "title": "2-liner-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL && q==NULL) return true;\\n        return (p!=NULL && q!=NULL) ? (p->val == q->val) && isSameTree(p->left, q->left) && isSameTree(p->right, q->right) : false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL && q==NULL) return true;\\n        return (p!=NULL && q!=NULL) ? (p->val == q->val) && isSameTree(p->left, q->left) && isSameTree(p->right, q->right) : false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 872029,
                "title": "python3-dfs-easy-solution",
                "content": "```\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        if p is None and q is None:\\n            return True\\n        elif p is None or q is None:\\n            return False\\n\\n        if p.val != q.val:\\n            return False\\n\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        if p is None and q is None:\\n            return True\\n        elif p is None or q is None:\\n            return False\\n\\n        if p.val != q.val:\\n            return False\\n\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)",
                "codeTag": "Java"
            },
            {
                "id": 428859,
                "title": "rust-0-ms-iterative-recursive-and-native-solutions",
                "content": "Nobody posted yet an iterative solution for Rust, so here\\'s mine.\\n\\n**Iteration**\\n\\nQuite complex but still 0 ms runtime.\\n\\nBecause of the borrow checker I couldn\\'t push to the queue references to the left and right nodes Options from inside the while loop, so I had to clone the Rcs and wrap them in new Options.\\n\\nDoes anyone have a better solution?\\n\\n```\\nuse std::rc::Rc;\\nuse std::cell::Ref;\\nuse std::cell::RefCell;\\nuse std::collections::VecDeque;\\n\\nimpl Solution {\\n    pub fn is_same_tree(p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        let mut deque: VecDeque<(Option<Rc<RefCell<TreeNode>>>, Option<Rc<RefCell<TreeNode>>>)> =\\n            VecDeque::new();\\n        match (p, q) {\\n            (Some(p), Some(q)) => {\\n                deque.push_back((Some(Rc::clone(&p)), Some(Rc::clone(&q))));\\n            }\\n            (None, None) => return true,\\n            _ => return false,\\n        }\\n        while !deque.is_empty() {\\n            let (p, q) = deque.pop_front().unwrap();\\n            if !match (&p, &q) {\\n                (Some(p), Some(q)) => p.borrow().val == q.borrow().val,\\n                (None, None) => true,\\n                _ => false,\\n            } {\\n                return false;\\n            }\\n            if let (Some(p), Some(q)) = (p, q) {\\n                let (p, q) = (\\n                    Solution::clone_nodes(p.borrow()),\\n                    Solution::clone_nodes(q.borrow()),\\n                );\\n                deque.push_back((p.0, q.0));\\n                deque.push_back((p.1, q.1));\\n            }\\n        }\\n        true\\n    }\\n    \\n    fn clone_nodes(\\n        tree: Ref<TreeNode>,\\n    ) -> (Option<Rc<RefCell<TreeNode>>>, Option<Rc<RefCell<TreeNode>>>) {\\n        (\\n            if tree.left.is_some() {\\n                Some(Rc::clone(tree.left.as_ref().unwrap()))\\n            } else {\\n                None\\n            },\\n            if tree.right.is_some() {\\n                Some(Rc::clone(tree.right.as_ref().unwrap()))\\n            } else {\\n                None\\n            },\\n        )\\n    }\\n}\\n```\\n\\nAnd for reference, much simplifier solutions.\\n\\n**Recursion**\\n\\n```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn is_same_tree(p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        Solution::compare(&p, &q)\\n    }\\n    \\n    fn compare(p: &Option<Rc<RefCell<TreeNode>>>, q: &Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        match (p, q) {\\n            (Some(p), Some(q)) => {\\n                let (p, q) = (p.borrow(), q.borrow());\\n                p.val == q.val\\n                    && Solution::compare(&p.left, &q.left)\\n                    && Solution::compare(&p.right, &q.right)\\n            }\\n            (None, None) => true,\\n            _ => false,\\n        }\\n    }\\n}\\n```\\n\\n**Native**\\n\\nRust can compare by itself the structs because of `derive(PartialEq)`. Not very interesting for learning purpose but quite handy in real life situations. :)\\n\\n```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn is_same_tree(p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        p == q\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nuse std::rc::Rc;\\nuse std::cell::Ref;\\nuse std::cell::RefCell;\\nuse std::collections::VecDeque;\\n\\nimpl Solution {\\n    pub fn is_same_tree(p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        let mut deque: VecDeque<(Option<Rc<RefCell<TreeNode>>>, Option<Rc<RefCell<TreeNode>>>)> =\\n            VecDeque::new();\\n        match (p, q) {\\n            (Some(p), Some(q)) => {\\n                deque.push_back((Some(Rc::clone(&p)), Some(Rc::clone(&q))));\\n            }\\n            (None, None) => return true,\\n            _ => return false,\\n        }\\n        while !deque.is_empty() {\\n            let (p, q) = deque.pop_front().unwrap();\\n            if !match (&p, &q) {\\n                (Some(p), Some(q)) => p.borrow().val == q.borrow().val,\\n                (None, None) => true,\\n                _ => false,\\n            } {\\n                return false;\\n            }\\n            if let (Some(p), Some(q)) = (p, q) {\\n                let (p, q) = (\\n                    Solution::clone_nodes(p.borrow()),\\n                    Solution::clone_nodes(q.borrow()),\\n                );\\n                deque.push_back((p.0, q.0));\\n                deque.push_back((p.1, q.1));\\n            }\\n        }\\n        true\\n    }\\n    \\n    fn clone_nodes(\\n        tree: Ref<TreeNode>,\\n    ) -> (Option<Rc<RefCell<TreeNode>>>, Option<Rc<RefCell<TreeNode>>>) {\\n        (\\n            if tree.left.is_some() {\\n                Some(Rc::clone(tree.left.as_ref().unwrap()))\\n            } else {\\n                None\\n            },\\n            if tree.right.is_some() {\\n                Some(Rc::clone(tree.right.as_ref().unwrap()))\\n            } else {\\n                None\\n            },\\n        )\\n    }\\n}\\n```\n```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn is_same_tree(p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        Solution::compare(&p, &q)\\n    }\\n    \\n    fn compare(p: &Option<Rc<RefCell<TreeNode>>>, q: &Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        match (p, q) {\\n            (Some(p), Some(q)) => {\\n                let (p, q) = (p.borrow(), q.borrow());\\n                p.val == q.val\\n                    && Solution::compare(&p.left, &q.left)\\n                    && Solution::compare(&p.right, &q.right)\\n            }\\n            (None, None) => true,\\n            _ => false,\\n        }\\n    }\\n}\\n```\n```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn is_same_tree(p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        p == q\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32915,
                "title": "0ms-simple-java-solution",
                "content": "public class Solution {\\n    \\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p==null && q==null) {\\n            return true;\\n        }\\n        \\n        if(p==null || q==null) {\\n            return false;\\n        }\\n        \\n        if(p.val == q.val) {\\n            boolean left = isSameTree(p.left, q.left);\\n            boolean right = isSameTree(p.right, q.right);\\n            return (left & right);\\n        }\\n\\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p==null && q==null) {\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 33034,
                "title": "my-one-line-recursive-solutions-in-3-languages",
                "content": "I use syntactic sugar to combine stop condition and recursive call together.\\n\\nJava:\\n\\n    return (p == null || q == null) ? p == q : p.val == q.val && this.isSameTree(p.left, q.left) && this.isSameTree(p.right, q.right);\\n\\nC++:\\n\\n    return (p == NULL || q == NULL) ? p == q : p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n\\nPython:\\n\\n    return p == q if p is None or q is None else p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "I use syntactic sugar to combine stop condition and recursive call together.\\n\\nJava:\\n\\n    return (p == null || q == null) ? p == q : p.val == q.val && this.isSameTree(p.left, q.left) && this.isSameTree(p.right, q.right);\\n\\nC++:\\n\\n    return (p == NULL || q == NULL) ? p == q : p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n\\nPython:\\n\\n    return p == q if p is None or q is None else p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)",
                "codeTag": "Unknown"
            },
            {
                "id": 3483205,
                "title": "easy-bfs",
                "content": "1. The algorithm will look as follows:\\n\\n1. We create a queue, in which we add the root nodes of both trees.\\n\\n1. As long as the queue is not empty, retrieve an element from the beginning of the queue:\\n\\n1. If the elements are null, then move on to the next element in the queue.\\n\\n1. If the node values are not equal, the trees are not identical.\\n\\n1. If the node values are equal, then add the left and right children for both nodes to the queue.\\n\\n1. If all nodes pass the check, then the trees are identical.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(p);\\n        queue.offer(q);\\n\\n        while(!queue.isEmpty()) {\\n            TreeNode node1 = queue.poll();\\n            TreeNode node2 = queue.poll();\\n\\n            if (node1 == null && node2 == null) {\\n                continue;\\n            }\\n\\n            if (node1 == null || node2 == null) {\\n                return false;\\n            }\\n\\n            if (node1.val != node2.val) {\\n                return false;\\n            }\\n\\n            queue.offer(node1.left);\\n            queue.offer(node2.left);\\n            queue.offer(node1.right);\\n            queue.offer(node2.right);\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(p);\\n        queue.offer(q);\\n\\n        while(!queue.isEmpty()) {\\n            TreeNode node1 = queue.poll();\\n            TreeNode node2 = queue.poll();\\n\\n            if (node1 == null && node2 == null) {\\n                continue;\\n            }\\n\\n            if (node1 == null || node2 == null) {\\n                return false;\\n            }\\n\\n            if (node1.val != node2.val) {\\n                return false;\\n            }\\n\\n            queue.offer(node1.left);\\n            queue.offer(node2.left);\\n            queue.offer(node1.right);\\n            queue.offer(node2.right);\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030595,
                "title": "python-iterative-solution-visual-explanation",
                "content": "Here is the visual explanation for the iterative version.\\nI\\'m waiting for your comments\\uD83D\\uDCA1\\nThanks for your Upvote\\uD83D\\uDE4F\\n\\nSample 1:\\n![leet code (2).png](https://assets.leetcode.com/users/images/026ba740-aa53-469a-ae64-0b4afd374a30_1673365031.5457146.png)\\n\\n___\\nSample 2:\\n![leet code (1).png](https://assets.leetcode.com/users/images/604e96a3-5e42-455c-8793-dc5ee57da7fc_1673358122.7690244.png)\\n\\n\\n```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        stack = [(p, q)]\\n\\n        while stack:\\n            u, v = stack.pop()\\n            if not u and not v:\\n                continue\\n            if not u or not v:\\n                return False\\n            if u.val != v.val:\\n                return False\\n            \\n            stack.append((u.right, v.right))\\n            stack.append((u.left, v.left))\\n\\n        return True\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        stack = [(p, q)]\\n\\n        while stack:\\n            u, v = stack.pop()\\n            if not u and not v:\\n                continue\\n            if not u or not v:\\n                return False\\n            if u.val != v.val:\\n                return False\\n            \\n            stack.append((u.right, v.right))\\n            stack.append((u.left, v.left))\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028026,
                "title": "easy-c-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL && q == NULL)\\n        {\\n            return true;\\n        }\\n        if(p == NULL && q != NULL)\\n        {\\n            return false;\\n        }\\n        if(p != NULL && q == NULL)\\n        {\\n            return false;\\n        }\\n        bool left = isSameTree(p->left,q->left);//check for left\\n        bool right = isSameTree(p->right,q->right);//check for right\\n        bool value = p->val == q->val;//check the value\\n        if(left && right && value)//if all are true\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL && q == NULL)\\n        {\\n            return true;\\n        }\\n        if(p == NULL && q != NULL)\\n        {\\n            return false;\\n        }\\n        if(p != NULL && q == NULL)\\n        {\\n            return false;\\n        }\\n        bool left = isSameTree(p->left,q->left);//check for left\\n        bool right = isSameTree(p->right,q->right);//check for right\\n        bool value = p->val == q->val;//check the value\\n        if(left && right && value)//if all are true\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2249745,
                "title": "python-dfs-recursion-time-o-n-space-o-n",
                "content": "# Explaination:\\nWe are given two trees and we need to find out if they are the same tree. Meaning they have the same height, same node values in the same places, and same structure.\\n\\nWe will be traversing through both trees at the same exact time and in the same way. Meaning we will check the left side of both trees first to see if they match and then the right side. As we go down the tree we will compare the current node we are at for both trees and see if they have matching values, if at any point they do not match, we return `False`. \\nIf everything matches and we reach `None` when checking the leaf nodes children, if both trees match and they both reach the leaf node and reach the `None` at the same time, we return `True`\\n\\n**Solution Breakdown:**\\n1. We check if either trees `p` or `q` are `None`, if either of them or both of them are, then we return `p == q` to check if they are both `None`, if they are it will return `True` meaning they match, if only one is `None`, we return `False` and say the trees don\\'t match.\\n2. Each time we visit a node we compare the node we are currently visiting on both trees and return `False` if they don\\'t match.\\n3. If they match we check the left and then the right of both trees.\\n4. Then we return `left == right` which means, if all the nodes on the left side for both trees match and all the nodes on the right side for both trees match, we return `True`, if we got `False` on either side of the traversals, we return `False`.\\n\\n**Time O(N) | Space O(N):**\\nTime is O(N) since we need to traverse through all the nodes of both trees, since we are doing it at the same time for both its O(N), since in the worst case both trees match and we visited all nodes to confirm they matched.\\nSpace is O(N) due to the recursive stack and in the worst case we can have an unbalanced tree which will look like a linked list.\\n\\n```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if not p or not q:\\n            return p == q\\n        if p.val != q.val:\\n            return False\\n        \\n        left = self.isSameTree(p.left, q.left)\\n        right = self.isSameTree(p.right, q.right)\\n        \\n        return left and right\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if not p or not q:\\n            return p == q\\n        if p.val != q.val:\\n            return False\\n        \\n        left = self.isSameTree(p.left, q.left)\\n        right = self.isSameTree(p.right, q.right)\\n        \\n        return left and right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1536269,
                "title": "c-0ms-faster-than-100-1-line-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n    \\n        return (!p || !q) ? p==q : (p->val != q->val) ? false : isSameTree(p->left,q->left) && isSameTree(p->right , q->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n    \\n        return (!p || !q) ? p==q : (p->val != q->val) ? false : isSameTree(p->left,q->left) && isSameTree(p->right , q->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 733770,
                "title": "c-easy-to-understand-with-explanation",
                "content": "### Approach 1 - DFS\\nWe have to perform DFS on both the trees simultaneously and at any point if the value is not same we can return false\\n1. If p or q is null - IF both are null return true otherwise return false\\n2. Both are non-null so if p->val != q->val, return false\\n3. perform DFS on left and right children and return true only if both are true otherwise return false (left && right);\\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(!p || !q) return p == q; \\n        if(p->val != q->val) return false;\\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n    }\\n};\\n```\\n\\n### Approach 2 - BFS (level order traversal)\\nWe will use a queue for this purpose\\n1. Check if the initial p and q are valid. If not return false.\\n2. insert them in the queue - qu (pair - {p,q})\\n3. while qu is not empty (qu is empty - last level)\\n4. store the current size of q in sz - the elements we have to check in current level\\n5. Perform the checks if both are valid. If not return false.\\n6. If both are valid insert their left and right children as pair in the queue\\n7. Perform the same operation using loop for the level then we go to next level and so on\\n8. If the entire tree is valid the loop ends and return true;\\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(!p || !q) return p == q;\\n        if(p->val != q->val) return false;\\n        queue<pair<TreeNode*,TreeNode*>> qu;\\n        qu.push({p,q});\\n        while(!qu.empty()){\\n            int sz = qu.size();\\n            while(sz--){\\n                auto pu = qu.front();qu.pop();           \\n                if((!pu.first || !pu.second) && (pu.first != pu.second))  return false;\\n                if(!pu.first && !pu.second) continue;\\n                if(pu.first->val != pu.second->val) return false;\\n                qu.push({pu.first->left,pu.second->left});\\n                qu.push({pu.first->right,pu.second->right});\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(!p || !q) return p == q; \\n        if(p->val != q->val) return false;\\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(!p || !q) return p == q;\\n        if(p->val != q->val) return false;\\n        queue<pair<TreeNode*,TreeNode*>> qu;\\n        qu.push({p,q});\\n        while(!qu.empty()){\\n            int sz = qu.size();\\n            while(sz--){\\n                auto pu = qu.front();qu.pop();           \\n                if((!pu.first || !pu.second) && (pu.first != pu.second))  return false;\\n                if(!pu.first && !pu.second) continue;\\n                if(pu.first->val != pu.second->val) return false;\\n                qu.push({pu.first->left,pu.second->left});\\n                qu.push({pu.first->right,pu.second->right});\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32784,
                "title": "c-non-recursive-o-1-space-based-on-morris-traversal",
                "content": "Not a fan of recursive. Stack space is also space, otherwise we wouldn't have the \"STACKOVERFLOW\".\\n```\\nclass Solution {\\npublic:\\n    int m(TreeNode *&h) {\\n        int v = 0;\\n        if (h) {\\n            v = h->val;\\n            if (TreeNode *p = h->left) {\\n                while (p->right && p->right != h) p = p->right;\\n                if (p->right) {\\n                    h = h->right;\\n                    p->right = NULL;\\n                } else {\\n                    p->right = h;\\n                    h = h->left;\\n                }\\n            } else {\\n                h = h->right;\\n            }\\n        }\\n        return v;\\n    }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        bool o = true;\\n        while (p || q) {\\n            if (!(p&&q)) o = false;\\n            if (m(p) != m(q)) o = false;\\n        }\\n        return o;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int m(TreeNode *&h) {\\n        int v = 0;\\n        if (h) {\\n            v = h->val;\\n            if (TreeNode *p = h->left) {\\n                while (p->right && p->right != h) p = p->right;\\n                if (p->right) {\\n                    h = h->right;\\n                    p->right = NULL;\\n                } else {\\n                    p->right = h;\\n                    h = h->left;\\n                }\\n            } else {\\n                h = h->right;\\n            }\\n        }\\n        return v;\\n    }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        bool o = true;\\n        while (p || q) {\\n            if (!(p&&q)) o = false;\\n            if (m(p) != m(q)) o = false;\\n        }\\n        return o;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32947,
                "title": "two-line-java-code",
                "content": "    public class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null) return true; \\n        return p!=null && q!= null && p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null) return true; \\n        return p!=null && q!= null && p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3672457,
                "title": "easy-approach-2-lines-inorder-traversal-beats-100",
                "content": "# Intuition \\uD83D\\uDCA1\\nTo determine if two binary trees are the same, we can compare their nodes recursively. If the current nodes have the same value and the left and right subtrees are also the same, then the trees are considered the same.\\n\\n# Approach \\uD83D\\uDD0D\\nHere is the step-by-step approach to solve the problem:\\n\\n1. Write a recursive function `isSameTree` that takes two parameters, `p` and `q`, representing the root nodes of the two binary trees.\\n2. Check if either `p` or `q` is null. If one is null and the other is not, return false since they cannot be the same.\\n3. Check if the values of the current nodes, `p.val` and `q.val`, are equal.\\n4. Recursively call the `isSameTree` function on the left subtrees, `p.left` and `q.left`.\\n5. Recursively call the `isSameTree` function on the right subtrees, `p.right` and `q.right`.\\n6. Return the logical AND of all the conditions checked above.\\n\\n> Feel free to post your doubts in the commen section :) \\n# Code \\nThe Java code implementing the above approach is as follows:\\n\\n```java\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        \\n        if (p == null || q == null) { return p == q;}\\n        \\n        return (p.val == q.val) && isSameTree(p.left, q.left) && isSameTree(p.right, q.right); \\n    }\\n}```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```java\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        \\n        if (p == null || q == null) { return p == q;}\\n        \\n        return (p.val == q.val) && isSameTree(p.left, q.left) && isSameTree(p.right, q.right); \\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 3532284,
                "title": "c-dfs-beats-92-100",
                "content": "# Intuition\\nTraversing branches by recursion\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (p == nullptr && q == nullptr) return true;\\n        else if (p == nullptr || q == nullptr) return false;\\n        else if (p -> val != q -> val) return false;\\n        else {\\n            bool res_right = isSameTree(p -> right, q -> right);\\n            bool res_left = isSameTree(p -> left, q -> left);\\n            return (res_right && res_left);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (p == nullptr && q == nullptr) return true;\\n        else if (p == nullptr || q == nullptr) return false;\\n        else if (p -> val != q -> val) return false;\\n        else {\\n            bool res_right = isSameTree(p -> right, q -> right);\\n            bool res_left = isSameTree(p -> left, q -> left);\\n            return (res_right && res_left);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029302,
                "title": "clear-and-concise-recursive-solution",
                "content": "Sorry for the lambda syntax, but I could not resist using it:\\n```csharp\\npublic class Solution\\n{\\n    public bool IsSameTree(TreeNode p, TreeNode q) =>\\n        p is null || q is null\\n        ? p is null && q is null\\n        : p.val == q.val && IsSameTree(p.left, q.left) && IsSameTree(p.right, q.right);\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public bool IsSameTree(TreeNode p, TreeNode q) =>\\n        p is null || q is null\\n        ? p is null && q is null\\n        : p.val == q.val && IsSameTree(p.left, q.left) && IsSameTree(p.right, q.right);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028873,
                "title": "simple-recursive-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nto check if the two trees are same we need to make sure that value at each node is same.That is we can check each node at a time via recursion\\n\\n# Approach\\n   passing each node recursively and if their value are not same i return false, i fthey are same we pass one call to check the left subtree and then another call to check the same for right subtree and return true if both left and right are true.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nlet the height of the tree be h=log(n) (approximately)\\nso the time copmplexity of the above code is O(2^h) since at each level we have two options put h=log(n) we get the time complexity to be O(n).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nhere the space complexity is O(h) that is O(log(n)) and this space is due to the recursive stack space in the compiler if we do not consider the recurasive stack space then space complexity is O(1).\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* t1, TreeNode* t2) {\\n         if(t1==NULL){\\n            if(t2!=NULL){\\n                return false;\\n            }\\n            else{\\n                return true;\\n            }\\n        }\\n        if(t2==NULL){\\n            if(t1!=NULL){\\n                return false;\\n            }\\n            else{\\n                return true;\\n            }\\n        }\\n        if(t1->val!=t2->val){\\n            return false;\\n        }\\n        bool left=isSameTree(t1->left,t2->left);\\n        bool right=isSameTree(t1->right,t2->right);\\n        return left && right;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* t1, TreeNode* t2) {\\n         if(t1==NULL){\\n            if(t2!=NULL){\\n                return false;\\n            }\\n            else{\\n                return true;\\n            }\\n        }\\n        if(t2==NULL){\\n            if(t1!=NULL){\\n                return false;\\n            }\\n            else{\\n                return true;\\n            }\\n        }\\n        if(t1->val!=t2->val){\\n            return false;\\n        }\\n        bool left=isSameTree(t1->left,t2->left);\\n        bool right=isSameTree(t1->right,t2->right);\\n        return left && right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028868,
                "title": "c-solution-100-faster-simple-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n__The Idea is to match all the nodes of one tree with the other one, and whenever there is no match possible, return false__\\n\\n# Approach\\n__The idea her is to recursive map nodes of one tree with the nodes of the other tree__\\n\\n>__Check if the nodes reach null together (base case),__ \\n  If yes, return true\\n  Else, execute other statements \\n\\n>__Check if only either of the nodes reach an end point__\\n If yes, Return false\\n Else, execute other statements\\n\\n>__If the nodes are not the end points, check if the values they are storing are same or not?__\\nIf different, return false\\nElse, continue with the code\\n\\n>Recursive structure: \\n__[match the left subtree of the current node with the left subtree of the other current node]__\\n__&&  (logical operator)__\\n__[match the right subtree of the current node with the right subtree of the other current node]__\\n\\n# Complexity\\n- Time complexity:\\nO(N) :- N => Number of nodes in the tree\\n\\n- Space complexity:\\nO(1), ignoring the recursive stack, otherwise the space = O(N)\\n\\n# Code\\n```\\nclass Solution //100% faster, 95.24% better space\\n{\\npublic:\\n    bool chc(TreeNode *p, TreeNode *q)\\n    {\\n        if (p == NULL && q == NULL) // If the node reach an endpoint together, say true\\n            return true;\\n        if (p == NULL && q != NULL || q == NULL && p != NULL) // If only either of the nodes reach an end point, say false\\n            return false;\\n        if (p->val != q->val) // If none of the nodes are at the end points but there values differ, say false\\n            return false;\\n        return (chc(p->left, q->left) && chc(p->right, q->right));   \\n        // && is used instead of & as it short circuits the condition\\n        // i.e. it stops checking the conditions when a false is received (in the case of &&)\\n        // and in the case of ||, it stops checking when a true value is received\\n    }\\n    bool isSameTree(TreeNode *p, TreeNode *q)\\n    {\\n        return chc(p, q);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution //100% faster, 95.24% better space\\n{\\npublic:\\n    bool chc(TreeNode *p, TreeNode *q)\\n    {\\n        if (p == NULL && q == NULL) // If the node reach an endpoint together, say true\\n            return true;\\n        if (p == NULL && q != NULL || q == NULL && p != NULL) // If only either of the nodes reach an end point, say false\\n            return false;\\n        if (p->val != q->val) // If none of the nodes are at the end points but there values differ, say false\\n            return false;\\n        return (chc(p->left, q->left) && chc(p->right, q->right));   \\n        // && is used instead of & as it short circuits the condition\\n        // i.e. it stops checking the conditions when a false is received (in the case of &&)\\n        // and in the case of ||, it stops checking when a true value is received\\n    }\\n    bool isSameTree(TreeNode *p, TreeNode *q)\\n    {\\n        return chc(p, q);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027524,
                "title": "java-solution-with-explanation-beat-100",
                "content": "# Intuition\\nIf tree is same it must have nodes with same value at same place\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are using recursion to solve this problem \\n1)if p is null and q is null then it\\'s same we will return true\\n2)if any of p or q is null then we will return false\\n3) if value of p and q is not same then it\\'s not same tree so we will return false\\nNow check for above cases for left subtree and right subtree and if we get false we will return false otherwise the trees are same\\n\\n# Complexity\\n- Time complexity:\\nO(min(N, M)), Where N and M are the sizes of the trees\\n\\n- Space complexity:\\n O(log min(N, M)), due to auxiliary stack space used by recursion calls\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p==null && q==null){\\n            return true;\\n        }\\n        if(p==null || q==null || p.val!=q.val){\\n            return false;\\n        }\\n\\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n\\n    }\\n}\\n```\\n\\nI hope you guys understand the solution,Keep coding.\\n\\nJai Shree Krishna\\u2764\\uFE0F\\uD83D\\uDE4F....",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p==null && q==null){\\n            return true;\\n        }\\n        if(p==null || q==null || p.val!=q.val){\\n            return false;\\n        }\\n\\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027419,
                "title": "c-2-different-approaches-recursive-one-liner-iterative",
                "content": "# Approach 1: recursive\\n\\nIt\\'s a long one-liner though:\\n\\n```cpp\\n    static bool isSameTree(const TreeNode* p, const TreeNode* q) noexcept {\\n        return p && q ? p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right) : p == q;\\n    }\\n```\\n\\nclang-formatted and with comments:\\n\\n```cpp\\n  return\\n      // If both pointers are valid ...\\n      p && q ?\\n             // ... then the values need to be the same, and ...\\n             p->val == q->val &&\\n             // ... both subtrees need to be the same.\\n             isSameTree(p->left, q->left) && isSameTree(p->right, q->right)\\n             // If at least one of the pointers was a nullptr, both need to be\\n             // nullptr, i.e. equal.\\n             : p == q;\\n```\\n\\nSimilar idea, slightly different implementation:\\n\\n```cpp\\n    return p && q && p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right) || !p && !q;\\n```\\n\\nA slightly more readable version could look like this:\\n\\n```cpp\\n    static bool isSameTree(const TreeNode* p, const TreeNode* q) noexcept {\\n        // If one of the pointers is a nullptr, then both need to be a nullptr.\\n        if (!p || !q) return !p && !q;\\n        \\n        return\\n            p->val == q->val &&\\n            isSameTree(p->left, q->left) &&\\n            isSameTree(p->right, q->right);\\n    }\\n```\\n\\n**Complexity Analysis**\\nLet $$n$$ be the number of nodes in the tree and $$h$$ the height, which can vary from $$\\\\log n$$ to $$n$$ then the\\n  * Time complexity is $$O(n)$$ we need to visit all the nodes and the\\n  * Space complexity is $$O(h)$$\\n\\n# Approach 2: iterative\\nThe benefit of the iterative approach could be that we have better control and catch situtations if the input isn\\'t a actually a tree and contains a loop.\\n\\n```cpp\\npublic:\\n    static bool isSameTree(const TreeNode* p, const TreeNode* q) {\\n        stack<pair<const TreeNode*, const TreeNode*>> st;\\n        st.push({p, q});\\n        while (!empty(st)) {\\n            auto [r, s] = st.top(); st.pop();\\n            if (r && s) {\\n                if (r->val != s->val) return false;\\n                st.push({r->left, s->left});\\n                st.push({r->right, s->right});\\n            } else if (!r != !s) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```\\n\\n**Complexity Analysis**\\nIs the same as for the recursive version.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```cpp\\n    static bool isSameTree(const TreeNode* p, const TreeNode* q) noexcept {\\n        return p && q ? p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right) : p == q;\\n    }\\n```\n```cpp\\n  return\\n      // If both pointers are valid ...\\n      p && q ?\\n             // ... then the values need to be the same, and ...\\n             p->val == q->val &&\\n             // ... both subtrees need to be the same.\\n             isSameTree(p->left, q->left) && isSameTree(p->right, q->right)\\n             // If at least one of the pointers was a nullptr, both need to be\\n             // nullptr, i.e. equal.\\n             : p == q;\\n```\n```cpp\\n    return p && q && p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right) || !p && !q;\\n```\n```cpp\\n    static bool isSameTree(const TreeNode* p, const TreeNode* q) noexcept {\\n        // If one of the pointers is a nullptr, then both need to be a nullptr.\\n        if (!p || !q) return !p && !q;\\n        \\n        return\\n            p->val == q->val &&\\n            isSameTree(p->left, q->left) &&\\n            isSameTree(p->right, q->right);\\n    }\\n```\n```cpp\\npublic:\\n    static bool isSameTree(const TreeNode* p, const TreeNode* q) {\\n        stack<pair<const TreeNode*, const TreeNode*>> st;\\n        st.push({p, q});\\n        while (!empty(st)) {\\n            auto [r, s] = st.top(); st.pop();\\n            if (r && s) {\\n                if (r->val != s->val) return false;\\n                st.push({r->left, s->left});\\n                st.push({r->right, s->right});\\n            } else if (!r != !s) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3027357,
                "title": "explained-recursive-solution-o-n",
                "content": "#### Approach\\n\\nThe simplest strategy here is to use recursion. Check if p and q nodes are not None, and their values are equal. If all checks are OK, do the same for the child nodes recursively.\\n\\n#### Complexity Analysis\\n\\n**Time complexity** : O(n), where n is a number of nodes in the tree, since one visits each node exactly once.\\n\\n**Space complexity** : O(n) in the worst case of completely unbalanced tree, to keep a recursion stack.\\n\\n```\\nclass Solution \\n{\\n    public boolean isSameTree(TreeNode p, TreeNode q) \\n    {\\n        if(p == null && q == null) return true;\\n        if(p == null || q == null) return false;\\n        if(p.val == q.val)\\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public boolean isSameTree(TreeNode p, TreeNode q) \\n    {\\n        if(p == null && q == null) return true;\\n        if(p == null || q == null) return false;\\n        if(p.val == q.val)\\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857536,
                "title": "0ms-solution-recursion-java",
                "content": "```\\nIf you find this solution easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public boolean isSameTree(TreeNode p, TreeNode q) \\n    {\\n        if(p==null && q==null)\\n         return true;\\n        if(p==null || q==null)\\n          return false;\\n        if(p.val==q.val)\\n        {\\n            return isSameTree(p.left,q.left) &&isSameTree(p.right,q.right);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nIf you find this solution easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\n```\\nclass Solution \\n{\\n    public boolean isSameTree(TreeNode p, TreeNode q) \\n    {\\n        if(p==null && q==null)\\n         return true;\\n        if(p==null || q==null)\\n          return false;\\n        if(p.val==q.val)\\n        {\\n            return isSameTree(p.left,q.left) &&isSameTree(p.right,q.right);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780859,
                "title": "c-0-ms-faster-than-100-recursive-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf root of p and q is same, then check again for the root of left subtree of p and q. Again repeat the same process until you reach NULL.\\nRepeat this process for the right subtrees also.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We are following a bottom to top approach where we go to the bottom of the tree and then come to top and keep checking whether p and q are same or not. If at any point, they are not same, return false, otherwise keep returning true.\\n- Also if p and q both are NULL at the same time, then it will return true because it implies that both are equal.\\nBut if either p is null or q is null (but not both at the same time), then it implies that they are not equal and we return false.\\n- Also note that at any point of time, if the actual value of p and q are not equal, then also we have to return false. Here, we cannot write `p!=q`. Instead, we have to write `p->val != q->val` because we have to compare the values of p and q, but `p!=q` will compare the pointers, which can obviously never be equal because both p and q are present at different memory locations, although the value present inside both of them maybe same.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\nBecause we traverse each node only once.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Auxiliary $$O(n)$$\\nBecause in the worst case i.e. for a skew tree, the maximum stack space required will be equal to total number of nodes.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL && q == NULL){\\n            return true;\\n        }\\n        if(p == NULL || q == NULL){\\n            return false;\\n        }\\n        if(p->val!=q->val){\\n            return false;\\n        }\\n        bool l = isSameTree(p->left,q->left);    //left subtrees\\n        bool r = isSameTree(p->right,q->right);  //right subtrees\\n        return l&&r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL && q == NULL){\\n            return true;\\n        }\\n        if(p == NULL || q == NULL){\\n            return false;\\n        }\\n        if(p->val!=q->val){\\n            return false;\\n        }\\n        bool l = isSameTree(p->left,q->left);    //left subtrees\\n        bool r = isSameTree(p->right,q->right);  //right subtrees\\n        return l&&r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2365177,
                "title": "c-solution-using-recursion-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL && q == NULL)\\n        {\\n            return true;\\n        }\\n        else if(p == NULL && q != NULL)\\n        {\\n            return false;\\n        }\\n        else if(p != NULL && q == NULL)\\n        {\\n            return false;\\n        }\\n        else if(p->val != q->val)\\n        {\\n            return false;\\n        }\\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL && q == NULL)\\n        {\\n            return true;\\n        }\\n        else if(p == NULL && q != NULL)\\n        {\\n            return false;\\n        }\\n        else if(p != NULL && q == NULL)\\n        {\\n            return false;\\n        }\\n        else if(p->val != q->val)\\n        {\\n            return false;\\n        }\\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936835,
                "title": "js-simple-explained-recursive-pre-order",
                "content": "# 100. Same Tree \\uD83D\\uDE80\\n***\\n### Solution Developed In:\\n![JavaScript](https://img.shields.io/badge/javascript-%23323330.svg?style=for-the-badge&logo=javascript&logoColor=%23F7DF1E)\\n\\n<!-- ### Index:\\n1. [Explaining the Question](#explaining-the-question)\\n2. [Recommended Knowledge](#what-do-we-know)\\n3. [What do we know](#recommended-knowledge)\\n4. [Solution Explanation](#how-were-going-to-do-it)\\n5. [Big *O* Notation](#big-o-notation)\\n6. [Leetcode Results](#leetcode-results)\\n7. [Solution](#the-solution) -->\\n\\n## Explaining The Question\\nThe question explains itself pretty well here. All we need to do is to go to each node in both trees at the same time and ensure they\\'re the same exact node as each other. \\n\\n##  Recommended Knowledge\\n1. Binary Trees\\n2. Depth First Search (Recursive)\\n3. Javascript Stack (Bubbles up in DFS)\\n4. Recursion\\n\\n## What do we know?\\n1. That we have 2 trees and we need to check that they\\'re the same\\n2. The max number of nodes a tree can have is 100.\\n\\n## How we\\'re going to do it:\\n1. We\\'re going to do this recursively. Meaning, that at each node in the both trees, we\\'re going to be visiting at one point. We do this by recalling the ***isSameTree*** function with the left or right pointers\\n2.  We\\'re going to go to each node in both trees at the same time. That is to say, in tree 1, when we go left, we also go left in tree 2. Until we reach the very end of that right tree. We will also do this with the right tree too.\\n3.  Each time we visit a new node, we will make a check, are both nodes empty? In this case, both trees are empty and are at the end and thus correct.\\n4. Are any of the pointers null that aren\\'t supposed to be? Meaning the mirror node isn\\'t null? In this case, it\\'s a invalid tree.\\n5. We then check the values. Are they not the same? Then it\\'s a invalid tree\\n6. Repeat this until all nodes are exhausted, comparing that both the left and right trees are valid.\\n\\n## Big O Notation:\\n* Time Complexity:   *O(**n**)* | Where ***n*** is equal to the number of nodes in both trees. | We visit every node in worst case\\n* Space Complexity: *O(**h**)* | Where ***h*** is the height of the tallest tree. This is within the Call Stack | In the worst case, a tree\\'s number of nodes is it\\'s height. \\n\\n## Leetcode Results:\\n\\nSee Submission Link: \\n\\n* Runtime: 64 ms, faster than ***84.15%*** of JavaScript online submissions for Same Tree.\\n* Memory Usage: 42.3 MB, less than ***58.35%*** of JavaScript online submissions for Same Tree.\\n\\n[![LeetCode](https://img.shields.io/badge/LeetCode-000000?style=for-the-badge&logo=LeetCode&logoColor=#d16c06)](https://leetcode.com/submissions/detail/678388505/)\\n\\n\\n***\\n\\n# The Solution\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n * this.val   = (val===undefined ? 0 : val)\\n * this.left  = (left===undefined ? null : left)\\n * this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function (p, q) {\\n\\t/* -------------------------------------------------------------------------- */\\n\\t/*                               100. Same Tree                               */\\n\\t/* -------------------------------------------------------------------------- */\\n\\n\\t/**\\n\\t * @author  Samuel Hinchliffe\\n\\t * @see    {@link linkedin.com/in/samuel-hinchliffe-\\uD83D\\uDE80-2bb5801a5/ | Author\\'s Linkedin }\\n\\t * @see    {@link github.com/Samuel-Hinchliffe}\\n\\t */\\n\\n\\t// What do we know:\\n\\t// 1 - That we have 2 trees and we need to check that they\\'re the same\\n\\t// 2 - The max number of nodes a tree can have is 100.\\n\\n\\t// What do you need to know to understand?\\n\\t// 1 - Binary Trees\\n\\t// 2 - Depth First Search (Recursive)\\n\\t// 3 - Javascript Stack (Bubbles up in DFS)\\n\\t// 4 - Recursion\\n\\n\\t// How we\\'re going to do it:\\n\\t// 1 - We\\'re going to do this recursively. Meaning, that at each node\\n\\t//   - in the both trees, we\\'re going to be visiting at one point.\\n\\t//   - we do this by recalling the isSameTree function with the left or right pointers\\n\\t// 2 - We\\'re going to go to each node in both trees at the same time.\\n\\t//   - That is to say, in tree 1, when we go left, we also go left in tree 2.\\n\\t//   - Until we reach the very end of that right tree.\\n\\t//   - We will also do this with the right tree too.\\n\\t// 3 - Each time we visit a new node, we will make a check, are both nodes empty?\\n\\t//   - in this case, both trees are empty and are at the end and thus correct.\\n\\t// 4 - Are any of the pointers null that aren\\'t supposed to be?\\n\\t//   -  meaning the mirror node isn\\'t null? In this case, it\\'s a invalid tree.\\n\\t// 5 - We then check the values. Are they not the same? Then it\\'s a invalid tree\\n\\t// 6 - Repeat this until all nodes are exhausted, comparing that both the left and right\\n\\t//   - trees are valid.\\n\\n\\t// Big O Notation:\\n\\t// Time Complexity:  O(n) | Where n is equal to the number of nodes in both trees.\\n\\t// Space Complexity: O(h) | Where h is the height of the tallest tree. This is within the Call Stack\\n\\n\\t// Leetcode Results:\\n\\t// Runtime: 64 ms, faster than 84.15% of JavaScript online submissions for Same Tree.\\n\\t// Memory Usage: 42.3 MB, less than 58.35% of JavaScript online submissions for Same Tree.\\n\\t// https://leetcode.com/submissions/detail/678388505/\\n\\n\\t/* ----------------------------- Solution Below ----------------------------- */\\n\\n\\t// So both our trees current node is null\\n\\t// This mean\\'s they both reached the end of the tree\\n\\t// at the same time without error\\n\\tif (p == null && q == null) {\\n\\t\\treturn true;\\n\\t}\\n\\n\\t// One of the pointers are null when another is not\\n\\t// This mean\\'s one of our pointers has traversed to a correct node\\n\\t// but another has reached the end of the list too early and thus\\n\\t// cannot be a valid mirror tree\\n\\tif ((p == null && q != null) || (q == null && p != null)) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\t// As we have moved nodes\\n\\t// Are they the same value?\\n\\tif (p.val != q.val) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\t// Get both left nodes\\n\\t// We will traverse the left nodes in a DFS fashion\\n\\t// to be able to compare both left nodes at the same time\\n\\t// So we move left at the same time on both trees.\\n\\tlet good_lefts = isSameTree(p.left, q.left);\\n\\n\\t// Get both right nodes\\n\\t// We will traverse the right nodes in a DFS fashion\\n\\t// to be able to compare both right nodes at the same time\\n\\t// So we move right at the same time on both trees.\\n\\tlet good_rights = isSameTree(p.right, q.right);\\n\\n\\t// So are both sides good?\\n\\treturn good_lefts && good_rights;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n * this.val   = (val===undefined ? 0 : val)\\n * this.left  = (left===undefined ? null : left)\\n * this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function (p, q) {\\n\\t/* -------------------------------------------------------------------------- */\\n\\t/*                               100. Same Tree                               */\\n\\t/* -------------------------------------------------------------------------- */\\n\\n\\t/**\\n\\t * @author  Samuel Hinchliffe\\n\\t * @see    {@link linkedin.com/in/samuel-hinchliffe-\\uD83D\\uDE80-2bb5801a5/ | Author\\'s Linkedin }\\n\\t * @see    {@link github.com/Samuel-Hinchliffe}\\n\\t */\\n\\n\\t// What do we know:\\n\\t// 1 - That we have 2 trees and we need to check that they\\'re the same\\n\\t// 2 - The max number of nodes a tree can have is 100.\\n\\n\\t// What do you need to know to understand?\\n\\t// 1 - Binary Trees\\n\\t// 2 - Depth First Search (Recursive)\\n\\t// 3 - Javascript Stack (Bubbles up in DFS)\\n\\t// 4 - Recursion\\n\\n\\t// How we\\'re going to do it:\\n\\t// 1 - We\\'re going to do this recursively. Meaning, that at each node\\n\\t//   - in the both trees, we\\'re going to be visiting at one point.\\n\\t//   - we do this by recalling the isSameTree function with the left or right pointers\\n\\t// 2 - We\\'re going to go to each node in both trees at the same time.\\n\\t//   - That is to say, in tree 1, when we go left, we also go left in tree 2.\\n\\t//   - Until we reach the very end of that right tree.\\n\\t//   - We will also do this with the right tree too.\\n\\t// 3 - Each time we visit a new node, we will make a check, are both nodes empty?\\n\\t//   - in this case, both trees are empty and are at the end and thus correct.\\n\\t// 4 - Are any of the pointers null that aren\\'t supposed to be?\\n\\t//   -  meaning the mirror node isn\\'t null? In this case, it\\'s a invalid tree.\\n\\t// 5 - We then check the values. Are they not the same? Then it\\'s a invalid tree\\n\\t// 6 - Repeat this until all nodes are exhausted, comparing that both the left and right\\n\\t//   - trees are valid.\\n\\n\\t// Big O Notation:\\n\\t// Time Complexity:  O(n) | Where n is equal to the number of nodes in both trees.\\n\\t// Space Complexity: O(h) | Where h is the height of the tallest tree. This is within the Call Stack\\n\\n\\t// Leetcode Results:\\n\\t// Runtime: 64 ms, faster than 84.15% of JavaScript online submissions for Same Tree.\\n\\t// Memory Usage: 42.3 MB, less than 58.35% of JavaScript online submissions for Same Tree.\\n\\t// https://leetcode.com/submissions/detail/678388505/\\n\\n\\t/* ----------------------------- Solution Below ----------------------------- */\\n\\n\\t// So both our trees current node is null\\n\\t// This mean\\'s they both reached the end of the tree\\n\\t// at the same time without error\\n\\tif (p == null && q == null) {\\n\\t\\treturn true;\\n\\t}\\n\\n\\t// One of the pointers are null when another is not\\n\\t// This mean\\'s one of our pointers has traversed to a correct node\\n\\t// but another has reached the end of the list too early and thus\\n\\t// cannot be a valid mirror tree\\n\\tif ((p == null && q != null) || (q == null && p != null)) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\t// As we have moved nodes\\n\\t// Are they the same value?\\n\\tif (p.val != q.val) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\t// Get both left nodes\\n\\t// We will traverse the left nodes in a DFS fashion\\n\\t// to be able to compare both left nodes at the same time\\n\\t// So we move left at the same time on both trees.\\n\\tlet good_lefts = isSameTree(p.left, q.left);\\n\\n\\t// Get both right nodes\\n\\t// We will traverse the right nodes in a DFS fashion\\n\\t// to be able to compare both right nodes at the same time\\n\\t// So we move right at the same time on both trees.\\n\\tlet good_rights = isSameTree(p.right, q.right);\\n\\n\\t// So are both sides good?\\n\\treturn good_lefts && good_rights;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1338775,
                "title": "faster-than-100-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL && q==NULL){\\n            return true;\\n        }\\n        else if(p==NULL || q==NULL){\\n            return false;\\n        }\\n        else{\\n            bool c1= p->val == q->val;\\n            bool c2=isSameTree(p->left,q->left);\\n            bool c3=isSameTree(p->right,q->right);\\n            \\n            if(c1 && c2 && c3){\\n                return true;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL && q==NULL){\\n            return true;\\n        }\\n        else if(p==NULL || q==NULL){\\n            return false;\\n        }\\n        else{\\n            bool c1= p->val == q->val;\\n            bool c2=isSameTree(p->left,q->left);\\n            bool c3=isSameTree(p->right,q->right);\\n            \\n            if(c1 && c2 && c3){\\n                return true;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 734211,
                "title": "python-3-5-lines-recursive-solution",
                "content": "```\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        if p is None and q is not None: return False\\n        if q is None and p is not None: return False\\n        if p is None and q is None: return True\\n        if p.val != q.val: return False\\n        \\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        \\n```\\n\\nUPD: In 4 lines\\n```\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        if not p and not q: return True\\n        if not p or not q: return False\\n        if p.val != q.val: return False\\n\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        if p is None and q is not None: return False\\n        if q is None and p is not None: return False\\n        if p is None and q is None: return True\\n        if p.val != q.val: return False\\n        \\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        \\n```\n```\\nclass Solution:\\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\\n        if not p and not q: return True\\n        if not p or not q: return False\\n        if p.val != q.val: return False\\n\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 327852,
                "title": "golang-recursive-and-bfs-solutions",
                "content": "```\\n// t: O(n)\\n// s: O(height)\\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\\n    if p == nil && q == nil {\\n        return true\\n    } else if p == nil || q == nil {\\n        return false\\n    }\\n    \\n    if p.Val != q.Val {\\n        return false\\n    } \\n    return isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)\\n}\\n```\\n\\n```\\n// t: O(n)\\n// s: O(n)\\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\\n    qP := []*TreeNode{p}\\n    qQ := []*TreeNode{q}\\n    \\n    for len(qP) !=  0 && len(qQ) != 0 {\\n        pNode := qP[0]\\n        qP = qP[1:]\\n        \\n        qNode := qQ[0]\\n        qQ = qQ[1:]\\n        \\n        if pNode == nil && qNode == nil {\\n            continue\\n        }\\n        if pNode == nil && qNode != nil || pNode != nil && qNode == nil {\\n            return false\\n        }\\n        if pNode.Val != qNode.Val {\\n            return false\\n        }\\n        \\n        qP = append(qP, pNode.Left, pNode.Right)\\n        qQ = append(qQ, qNode.Left, qNode.Right)\\n    }\\n    \\n    if len(qP) == 0 && len(qQ) == 0 {\\n        return true\\n    }\\n    return false\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\n// t: O(n)\\n// s: O(height)\\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\\n    if p == nil && q == nil {\\n        return true\\n    } else if p == nil || q == nil {\\n        return false\\n    }\\n    \\n    if p.Val != q.Val {\\n        return false\\n    } \\n    return isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)\\n}\\n```\n```\\n// t: O(n)\\n// s: O(n)\\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\\n    qP := []*TreeNode{p}\\n    qQ := []*TreeNode{q}\\n    \\n    for len(qP) !=  0 && len(qQ) != 0 {\\n        pNode := qP[0]\\n        qP = qP[1:]\\n        \\n        qNode := qQ[0]\\n        qQ = qQ[1:]\\n        \\n        if pNode == nil && qNode == nil {\\n            continue\\n        }\\n        if pNode == nil && qNode != nil || pNode != nil && qNode == nil {\\n            return false\\n        }\\n        if pNode.Val != qNode.Val {\\n            return false\\n        }\\n        \\n        qP = append(qP, pNode.Left, pNode.Right)\\n        qQ = append(qQ, qNode.Left, qNode.Right)\\n    }\\n    \\n    if len(qP) == 0 && len(qQ) == 0 {\\n        return true\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32683,
                "title": "java-intuitive-and-easy-to-understand-non-recursive-solutions-both-bfs-and-dfs-no-size-checking",
                "content": "Hi here are my non-recursive solutions. I think it is more intuitive as I only deal with properties of nodes pushed/polled and don't check queue/stack's status in the while loop.\\n\\nIn this question the iterative DFS and  iterative BFS are exactly the same thing. I think it is because we're doing the graph search, so it doesn't matter which sequence we are following to check nodes, as long as the checking for two trees are synchronized. \\n\\nIterative DFS:\\n```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        Stack<TreeNode> pstack = new Stack<>();\\n        Stack<TreeNode> qstack = new Stack<>();\\n        pstack.push(p);\\n        qstack.push(q);\\n        while(!pstack.isEmpty() && !qstack.isEmpty()){\\n            TreeNode t1 = pstack.pop();\\n            TreeNode t2 = qstack.pop();\\n            if(t1 == null && t2 == null) continue;\\n            if(t1 == null || t2 == null) return false;\\n            if(t1.val != t2.val) return false;\\n            pstack.push(t1.left);\\n            pstack.push(t1.right);\\n            qstack.push(t2.left);\\n            qstack.push(t2.right);\\n        }\\n        if(pstack.isEmpty() && qstack.isEmpty()) return true;\\n        else return false;\\n    }\\n}\\n```\\n\\n\\nIterative BFS:\\n```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        Queue<TreeNode> q1 = new LinkedList<>();\\n        Queue<TreeNode> q2 = new LinkedList<>();\\n        q1.offer(p);\\n        q2.offer(q);\\n        while(!q1.isEmpty() && !q2.isEmpty()){\\n            TreeNode t1 = q1.poll();\\n            TreeNode t2 = q2.poll();\\n            if(t1 == null && t2 == null) continue;\\n            if(t1 == null || t2 == null) return false;\\n            if(t1.val != t2.val) return false;\\n            q1.offer(t1.left);\\n            q1.offer(t1.right);\\n            q2.offer(t2.left);\\n            q2.offer(t2.right);\\n        }\\n        if(q1.isEmpty() && q2.isEmpty()) return true;\\n        else return false;\\n    }\\n}\\n```\\n\\nThough I have to say that the time performance of these two iterative solutions are pretty bad... below 5%. \\n\\nidk if it is because how I wrote my for loop.. anyway this format seems to be more intuitive to me!\\n\\nHope it helps!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        Stack<TreeNode> pstack = new Stack<>();\\n        Stack<TreeNode> qstack = new Stack<>();\\n        pstack.push(p);\\n        qstack.push(q);\\n        while(!pstack.isEmpty() && !qstack.isEmpty()){\\n            TreeNode t1 = pstack.pop();\\n            TreeNode t2 = qstack.pop();\\n            if(t1 == null && t2 == null) continue;\\n            if(t1 == null || t2 == null) return false;\\n            if(t1.val != t2.val) return false;\\n            pstack.push(t1.left);\\n            pstack.push(t1.right);\\n            qstack.push(t2.left);\\n            qstack.push(t2.right);\\n        }\\n        if(pstack.isEmpty() && qstack.isEmpty()) return true;\\n        else return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        Queue<TreeNode> q1 = new LinkedList<>();\\n        Queue<TreeNode> q2 = new LinkedList<>();\\n        q1.offer(p);\\n        q2.offer(q);\\n        while(!q1.isEmpty() && !q2.isEmpty()){\\n            TreeNode t1 = q1.poll();\\n            TreeNode t2 = q2.poll();\\n            if(t1 == null && t2 == null) continue;\\n            if(t1 == null || t2 == null) return false;\\n            if(t1.val != t2.val) return false;\\n            q1.offer(t1.left);\\n            q1.offer(t1.right);\\n            q2.offer(t2.left);\\n            q2.offer(t2.right);\\n        }\\n        if(q1.isEmpty() && q2.isEmpty()) return true;\\n        else return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32908,
                "title": "one-line-java-with-recursive",
                "content": "        return((p==null||q==null)?(p==q):(p.val==q.val && isSameTree(p.left,q.left) && isSameTree(p.right,q.right)));\\n\\nNot the fastest though...",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "        return((p==null||q==null)?(p==q):(p.val==q.val && isSameTree(p.left,q.left) && isSameTree(p.right,q.right)));\\n\\nNot the fastest though...",
                "codeTag": "Unknown"
            },
            {
                "id": 4047543,
                "title": "python-3line-code-simple-approach",
                "content": "**Plz Upvote ..if you got help from this.**\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p is None or q is None:\\n            return p == q\\n        return (p.val== q.val) and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p is None or q is None:\\n            return p == q\\n        return (p.val== q.val) and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513811,
                "title": "python-easy-3-line-code",
                "content": "```\\ndef isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p==None or q==None:\\n            return p==q\\n        return (p.val==q.val) and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\ndef isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p==None or q==None:\\n            return p==q\\n        return (p.val==q.val) and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3484336,
                "title": "simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (!p && !q) return true;\\n        if (!p || !q) return false;\\n        if (p->val != q->val) return false;\\n\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right); \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (!p && !q) return true;\\n        if (!p || !q) return false;\\n        if (p->val != q->val) return false;\\n\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right); \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430835,
                "title": "4-lines-of-code-100-faster-optimal",
                "content": "# Explantion\\n1. if both the nodes are null return *true*\\n2. one of the nodes are null return *false*\\n3. if values of both nodes are not same return *false*\\n4. call left and right child for both the nodes.\\n# Complexity\\n- Time complexity: O(n), where, n is the number of nodes\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL && q==NULL) return true;\\n        if(p==NULL || q==NULL) return false;\\n        if(p->val != q->val) return false;\\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL && q==NULL) return true;\\n        if(p==NULL || q==NULL) return false;\\n        if(p->val != q->val) return false;\\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030035,
                "title": "beats-100-simple-c-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust check if current nodes data of both trees is same and check for left subtree and rightsubtree respectively by simply doing  recusrive calls for both\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n# Complexity\\n- Time complexity:O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL and q==NULL)return true;\\n        if(p==NULL or q==NULL)return false;\\n        return (p->val==q->val and isSameTree(p->left,q->left) and isSameTree(p->right,q->right) );\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL and q==NULL)return true;\\n        if(p==NULL or q==NULL)return false;\\n        return (p->val==q->val and isSameTree(p->left,q->left) and isSameTree(p->right,q->right) );\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029914,
                "title": "java-3-solutions-commented",
                "content": "# Please Upvote :D\\n---\\n##### 1. Preorder traversal + extra space:\\n\\n``` java []\\n// do any type of traversal on both the trees and store it in lists\\n// check if the lists are equal\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        List<Integer> pList = new ArrayList<>();\\n        List<Integer> qList = new ArrayList<>();\\n        dfs(p, pList); dfs(q, qList);\\n        return pList.equals(qList);\\n    }\\n\\n    void dfs(TreeNode root, List<Integer> list) {\\n        if (root == null) {\\n            list.add(null);\\n            return;\\n        }\\n        list.add(root.val);\\n        dfs(root.left, list);\\n        dfs(root.right, list);\\n    }\\n}\\n\\n// TC: O(n), SC: O(n + h)\\n```\\n##### 2. Recursive approach (No extra space):\\n``` java []\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // either one of them is null or both of them is\\n        if (p == null || q == null) {\\n            return p == q;\\n        }\\n        // check if values are equal\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        // call the functions for left and right subtrees\\n        boolean left = isSameTree(p.left, q.left);\\n        boolean right = isSameTree(p.right, q.right);\\n        return left && right;   // return what the subtrees return\\n    }\\n}\\n\\n// TC: O(n), SC: O(h)\\n```\\n---\\n##### 3. Iterative approach:\\n``` java []\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // condition checking for root nodes\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        if ((p == null && q != null) || (p != null && q == null)) {\\n            return false;\\n        }\\n\\n        Stack<TreeNode> st1 = new Stack<>();\\n        Stack<TreeNode> st2 = new Stack<>();\\n        st1.push(p);\\n        st2.push(q);\\n\\n        while (!st1.empty() && !st2.empty()) {\\n            TreeNode n1 = st1.pop();\\n            TreeNode n2 = st2.pop();\\n\\n            // check if values are equal\\n            if (n1.val != n2.val) {\\n                return false;\\n            }\\n            // condition checking for children nodes\\n            if ((n1.left != null && n2.left == null) || (n1.left == null && n2.left != null)) {\\n                return false;\\n            }\\n            if ((n1.right != null && n2.right == null) || (n1.right == null && n2.right != null)) {\\n                return false;\\n            }\\n\\n            // add the children to the stacks\\n            if (n1.left != null && n2.left != null) {\\n                st1.push(n1.left);\\n                st2.push(n2.left);\\n            }\\n            if (n1.right != null && n2.right != null) {\\n                st1.push(n1.right);\\n                st2.push(n2.right);\\n            }\\n        }\\n\\n        // any dissimilarity if encountered above, would\\'ve returned false already\\n        // no dissimilarity encountered means trees are same, so return true\\n        return true;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "``` java []\\n// do any type of traversal on both the trees and store it in lists\\n// check if the lists are equal\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        List<Integer> pList = new ArrayList<>();\\n        List<Integer> qList = new ArrayList<>();\\n        dfs(p, pList); dfs(q, qList);\\n        return pList.equals(qList);\\n    }\\n\\n    void dfs(TreeNode root, List<Integer> list) {\\n        if (root == null) {\\n            list.add(null);\\n            return;\\n        }\\n        list.add(root.val);\\n        dfs(root.left, list);\\n        dfs(root.right, list);\\n    }\\n}\\n\\n// TC: O(n), SC: O(n + h)\\n```\n``` java []\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // either one of them is null or both of them is\\n        if (p == null || q == null) {\\n            return p == q;\\n        }\\n        // check if values are equal\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        // call the functions for left and right subtrees\\n        boolean left = isSameTree(p.left, q.left);\\n        boolean right = isSameTree(p.right, q.right);\\n        return left && right;   // return what the subtrees return\\n    }\\n}\\n\\n// TC: O(n), SC: O(h)\\n```\n``` java []\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // condition checking for root nodes\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        if ((p == null && q != null) || (p != null && q == null)) {\\n            return false;\\n        }\\n\\n        Stack<TreeNode> st1 = new Stack<>();\\n        Stack<TreeNode> st2 = new Stack<>();\\n        st1.push(p);\\n        st2.push(q);\\n\\n        while (!st1.empty() && !st2.empty()) {\\n            TreeNode n1 = st1.pop();\\n            TreeNode n2 = st2.pop();\\n\\n            // check if values are equal\\n            if (n1.val != n2.val) {\\n                return false;\\n            }\\n            // condition checking for children nodes\\n            if ((n1.left != null && n2.left == null) || (n1.left == null && n2.left != null)) {\\n                return false;\\n            }\\n            if ((n1.right != null && n2.right == null) || (n1.right == null && n2.right != null)) {\\n                return false;\\n            }\\n\\n            // add the children to the stacks\\n            if (n1.left != null && n2.left != null) {\\n                st1.push(n1.left);\\n                st2.push(n2.left);\\n            }\\n            if (n1.right != null && n2.right != null) {\\n                st1.push(n1.right);\\n                st2.push(n2.right);\\n            }\\n        }\\n\\n        // any dissimilarity if encountered above, would\\'ve returned false already\\n        // no dissimilarity encountered means trees are same, so return true\\n        return true;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029147,
                "title": "java-beats-100",
                "content": "![image.png](https://assets.leetcode.com/users/images/11922000-a384-41a2-85fb-a6bfedcea97f_1673336288.9135783.png)\\n\\n\\n# Intuition\\nThe problem is straightforward. First, compare both trees\\' root node values with each other, and continue this procedure going right and left.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null) return true; // both empty\\n        if(p == null || q == null) return false; // of the the trees empty\\n        if(p.val != q.val) return false; // value equality\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null) return true; // both empty\\n        if(p == null || q == null) return false; // of the the trees empty\\n        if(p.val != q.val) return false; // value equality\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027740,
                "title": "c-100-faster-1-liner-solution-must-watch",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        return (p==NULL || q==NULL) ? (p==q) : (p->val == q->val && isSameTree(p->left,q->left) && isSameTree(p->right,q->right));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        return (p==NULL || q==NULL) ? (p==q) : (p->val == q->val && isSameTree(p->left,q->left) && isSameTree(p->right,q->right));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027461,
                "title": "c-solution-in-recursive-and-iterative-approach",
                "content": "## Explanation:\\n\\n### Solution 01\\n\\n- Using ***Recursive solution.***\\n- If both trees are null, return true\\n- If one tree is null and the other is not, return false\\n- If the values at the roots of the trees are different, return false\\n- Recursively check the left and right subtrees of both trees\\n    - If the left or right subtrees are different, return false\\n- If the function has not yet returned false, return true\\n- **Time complexity:** O(n).\\n- **Space complexity:** O(n).\\n\\n### Solution 02\\n\\n- Using ***Iterative solution.***\\n- Create a stack and push the roots of both trees onto the stack as pairs.\\n- While the stack is not empty:\\n    - Pop a pair of nodes from the stack.\\n    - If both nodes are null, continue.\\n    - If one node is null or the values at the nodes are different, return false.\\n    - Push the left and right children of both nodes onto the stack as pairs.\\n- If the loop completes, return true.\\n- **Time complexity:** O(n).\\n- **Space complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL || q == NULL) return p==q;\\n        \\n        return (p->val == q->val) && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q)\\n    {\\n        stack<pair<TreeNode*, TreeNode*>> st;\\n        st.push({p, q});\\n        while (!st.empty()) {\\n            auto [node1, node2] = st.top();\\n            st.pop();\\n            if (!node1 && !node2) continue;\\n            if (!node1 || !node2 || node1->val != node2->val) return false;\\n            st.push({node1->left, node2->left});\\n            st.push({node1->right, node2->right});\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL || q == NULL) return p==q;\\n        \\n        return (p->val == q->val) && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q)\\n    {\\n        stack<pair<TreeNode*, TreeNode*>> st;\\n        st.push({p, q});\\n        while (!st.empty()) {\\n            auto [node1, node2] = st.top();\\n            st.pop();\\n            if (!node1 && !node2) continue;\\n            if (!node1 || !node2 || node1->val != node2->val) return false;\\n            st.push({node1->left, node2->left});\\n            st.push({node1->right, node2->right});\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027352,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* p,TreeNode* q)\\n    {\\n        if(p==NULL||q==NULL)\\n        {\\n            return (p==NULL&&q==NULL);\\n        }\\n        if(p->val==q->val)\\n        {\\n            bool left=isSymmetric(p->left,q->left);\\n            bool right=isSymmetric(p->right,q->right);\\n            return left&&right;\\n        }\\n            return false;\\n    }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        return isSymmetric(p,q);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* p,TreeNode* q)\\n    {\\n        if(p==NULL||q==NULL)\\n        {\\n            return (p==NULL&&q==NULL);\\n        }\\n        if(p->val==q->val)\\n        {\\n            bool left=isSymmetric(p->left,q->left);\\n            bool right=isSymmetric(p->right,q->right);\\n            return left&&right;\\n        }\\n            return false;\\n    }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        return isSymmetric(p,q);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830951,
                "title": "shortest-simplest-c-2-lines",
                "content": "```\\nbool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL || q==NULL) return p==q;\\n        return p->val==q->val && isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nbool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL || q==NULL) return p==q;\\n        return p->val==q->val && isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2765177,
                "title": "python-bfs",
                "content": "```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if not p and not q:\\n            return 1\\n        if not p or not q:\\n            return 0\\n        return p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if not p and not q:\\n            return 1\\n        if not p or not q:\\n            return 0\\n        return p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726706,
                "title": "python-bt-beginners-solution-easy",
                "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if not p and not q:\\n            return 1\\n        if not p or not q:\\n            return 0\\n        return p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if not p and not q:\\n            return 1\\n        if not p or not q:\\n            return 0\\n        return p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2714988,
                "title": "0ms-runtime-easy-3-lines-c-solution",
                "content": "``` C++ []\\nclass Solution {\\npublic:\\n\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (!p && !q) return true;\\n        // if both nodes are null,then both are technically equal\\n\\n        if ((!p || !q) || p->val != q->val) return false;\\n        // if either of them is null then they aren\\'t equal, or if their values are not equal, we return false\\n\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n        // we break the tree into smaller parts ie, trees from the left and right nodes and if either of them returns false, then we know there is a difference in the trees somewhere down there]\\n    }\\n};\\n```\\n*If this code helps please upvote, it motivates to write more solutions to help the community*\\n\\n## My GitHub: https://github.com/crimsonKn1ght",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (!p && !q) return true;\\n        // if both nodes are null,then both are technically equal\\n\\n        if ((!p || !q) || p->val != q->val) return false;\\n        // if either of them is null then they aren\\'t equal, or if their values are not equal, we return false\\n\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n        // we break the tree into smaller parts ie, trees from the left and right nodes and if either of them returns false, then we know there is a difference in the trees somewhere down there]\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2690285,
                "title": "stack-queue-approach",
                "content": "**Stack**\\n```\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        stack = [(p, q)]\\n        while stack:\\n            n1, n2 = stack.pop()\\n            if not n1 and not n2: continue\\n            if not n1 or not n2: return n1 == n2\\n            if n1.val != n2.val: return False\\n            stack.append((n1.right, n2.right))\\n            stack.append((n1.left, n2.left))\\n        return True\\n```\\n\\n\\n**Queue**\\n\\n```\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        queue = collections.deque([(p, q)])\\n        while queue:\\n            n1, n2 = queue.popleft()\\n            if not n1 and not n2: continue\\n            if not n1 or not n2: return n1 == n2\\n            if n1.val != n2.val: return False\\n            queue.append((n1.left, n2.left))\\n            queue.append((n1.right, n2.right))\\n        return True\\n```",
                "solutionTags": [
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        stack = [(p, q)]\\n        while stack:\\n            n1, n2 = stack.pop()\\n            if not n1 and not n2: continue\\n            if not n1 or not n2: return n1 == n2\\n            if n1.val != n2.val: return False\\n            stack.append((n1.right, n2.right))\\n            stack.append((n1.left, n2.left))\\n        return True\\n```\n```\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        queue = collections.deque([(p, q)])\\n        while queue:\\n            n1, n2 = queue.popleft()\\n            if not n1 and not n2: continue\\n            if not n1 or not n2: return n1 == n2\\n            if n1.val != n2.val: return False\\n            queue.append((n1.left, n2.left))\\n            queue.append((n1.right, n2.right))\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2656522,
                "title": "o-n-time-and-o-n-space-recursion",
                "content": "```\\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\\n    if p==nil || q==nil{\\n        return p==q\\n    }\\n    \\n    return p.Val==q.Val && isSameTree(p.Left,q.Left) && isSameTree(p.Right,q.Right)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\\n    if p==nil || q==nil{\\n        return p==q\\n    }\\n    \\n    return p.Val==q.Val && isSameTree(p.Left,q.Left) && isSameTree(p.Right,q.Right)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2640564,
                "title": "c-solution-same-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL && q == NULL)\\n            return true;\\n        if(p==NULL && q!=NULL)\\n            return false;\\n        if(p!=NULL && q==NULL)\\n            return false;\\n        \\n        bool left = isSameTree(p->left , q->left);\\n        bool right = isSameTree(p->right , q->right);\\n        \\n        bool curr = p->val == q->val;\\n        \\n        if(left && right && curr)\\n            return true;\\n        else\\n            return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL && q == NULL)\\n            return true;\\n        if(p==NULL && q!=NULL)\\n            return false;\\n        if(p!=NULL && q==NULL)\\n            return false;\\n        \\n        bool left = isSameTree(p->left , q->left);\\n        bool right = isSameTree(p->right , q->right);\\n        \\n        bool curr = p->val == q->val;\\n        \\n        if(left && right && curr)\\n            return true;\\n        else\\n            return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2197519,
                "title": "elixir-a-solution-that-cannot-be-simpler",
                "content": "```elixir\\ndefmodule Solution do\\n  @spec is_same_tree(p :: TreeNode.t | nil, q :: TreeNode.t | nil) :: boolean\\n  def is_same_tree(p, q) do\\n    p == q\\n  end\\nend\\n```\\n\\nWe can do so because in Elixir, everything is immutable, so if two things initially look the same, they\\'ll never become different; if they are initially different, they\\'ll never become the same either. Thus, comparing references is meaningless. So, in Elixir, `==` compares whole data structures.",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```elixir\\ndefmodule Solution do\\n  @spec is_same_tree(p :: TreeNode.t | nil, q :: TreeNode.t | nil) :: boolean\\n  def is_same_tree(p, q) do\\n    p == q\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1769465,
                "title": "3-lines-clean-easy-c-recursion",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isSameTree(TreeNode* p, TreeNode* q) {\\n\\t\\t\\tif(p==NULL || q==NULL)\\n\\t\\t\\t\\treturn (p==q);\\n\\n\\t\\t\\treturn (p->val == q->val) && isSameTree(p->left ,q->left) && isSameTree(p->right ,q->right);\\n\\n\\t\\t}\\n\\t};\\n\\n\\tfeel free to ask your doubts :)\\n\\tand pls upvote if it was helpful :)",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool isSameTree(TreeNode* p, TreeNode* q) {\\n\\t\\t\\tif(p==NULL || q==NULL)\\n\\t\\t\\t\\treturn (p==q);\\n\\n\\t\\t\\treturn (p->val == q->val) && isSameTree(p->left ,q->left) && isSameTree(p->right ,q->right);\\n\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1393461,
                "title": "bfs-c",
                "content": "\\n**Implementation**\\n\\nTime Complexity = O(N), Space Complexity = O(W) where W is the width of the Binary Tree\\n\\n```\\nbool isSameTree(TreeNode* p, TreeNode* q) {        \\n    \\n    if(p != NULL && q != NULL){\\n        queue<TreeNode*> pq;\\n        queue<TreeNode*> qq;\\n        \\n        pq.push(p);\\n        qq.push(q);\\n        \\n        while(pq.empty() == false && qq.empty() == false){\\n            TreeNode* cur1 = pq.front(); pq.pop();\\n            TreeNode* cur2 = qq.front(); qq.pop();\\n            \\n            if(cur1->val != cur2->val) return false;\\n                                            \\n            if(cur1->left != NULL && cur2->left != NULL) {\\n                pq.push(cur1->left);\\n                qq.push(cur2->left);\\n            }\\n            else if(cur1->left != cur2->left) return false;\\n            \\n            if(cur1->right != NULL && cur2->right != NULL){\\n                pq.push(cur1->right);\\n                qq.push(cur2->right);\\n            }\\n            else if(cur1->right != cur2->right) return false;\\n        }            \\n        if(pq.empty() != qq.empty()) return false;\\n        else return true;\\n    }\\n    else if(q != p) return false; \\n    else return true;\\n}\\n```\\nIf you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nbool isSameTree(TreeNode* p, TreeNode* q) {        \\n    \\n    if(p != NULL && q != NULL){\\n        queue<TreeNode*> pq;\\n        queue<TreeNode*> qq;\\n        \\n        pq.push(p);\\n        qq.push(q);\\n        \\n        while(pq.empty() == false && qq.empty() == false){\\n            TreeNode* cur1 = pq.front(); pq.pop();\\n            TreeNode* cur2 = qq.front(); qq.pop();\\n            \\n            if(cur1->val != cur2->val) return false;\\n                                            \\n            if(cur1->left != NULL && cur2->left != NULL) {\\n                pq.push(cur1->left);\\n                qq.push(cur2->left);\\n            }\\n            else if(cur1->left != cur2->left) return false;\\n            \\n            if(cur1->right != NULL && cur2->right != NULL){\\n                pq.push(cur1->right);\\n                qq.push(cur2->right);\\n            }\\n            else if(cur1->right != cur2->right) return false;\\n        }            \\n        if(pq.empty() != qq.empty()) return false;\\n        else return true;\\n    }\\n    else if(q != p) return false; \\n    else return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1038971,
                "title": "95-faster-python-3-code-recursive",
                "content": "```\\nif (p==None and q==None):\\n\\treturn True\\n\\nif p and q:\\n\\tif p.val==q.val:\\n\\t\\treturn self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\nelse:\\n\\treturn False\\n```",
                "solutionTags": [],
                "code": "```\\nif (p==None and q==None):\\n\\treturn True\\n\\nif p and q:\\n\\tif p.val==q.val:\\n\\t\\treturn self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\nelse:\\n\\treturn False\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 956314,
                "title": "java-0-ms-100-faster-queues-iterative-solution",
                "content": "```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        Queue<TreeNode> queue = new LinkedList();\\n        queue.add(p);\\n        queue.add(q);\\n        while(!queue.isEmpty()){\\n            TreeNode root1 = queue.poll();\\n            TreeNode root2 = queue.poll();\\n            if(root1==null && root2==null) continue;\\n            if(root1==null || root2==null || root1.val!=root2.val) return false;\\n            queue.add(root1.left);\\n            queue.add(root2.left);\\n            queue.add(root1.right);\\n            queue.add(root2.right);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        Queue<TreeNode> queue = new LinkedList();\\n        queue.add(p);\\n        queue.add(q);\\n        while(!queue.isEmpty()){\\n            TreeNode root1 = queue.poll();\\n            TreeNode root2 = queue.poll();\\n            if(root1==null && root2==null) continue;\\n            if(root1==null || root2==null || root1.val!=root2.val) return false;\\n            queue.add(root1.left);\\n            queue.add(root2.left);\\n            queue.add(root1.right);\\n            queue.add(root2.right);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796604,
                "title": "c-recursive-solution",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    bool isSameTree(TreeNode* r1, TreeNode* r2) \\n\\t{\\n        if (r1 == nullptr && r2 == nullptr)\\n            return true;\\n\\t\\t\\t\\n        if ((r1 != nullptr && r2 == nullptr)\\n          || (r1 == nullptr && r2 != nullptr))\\n            return false;\\n\\t\\t\\t\\n        if (r1->val != r2->val)\\n            return false;\\n\\t\\t\\t\\n        return isSameTree(r1->left, r2->left) && isSameTree(r1->right, r2->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool isSameTree(TreeNode* r1, TreeNode* r2) \\n\\t{\\n        if (r1 == nullptr && r2 == nullptr)\\n            return true;\\n\\t\\t\\t\\n        if ((r1 != nullptr && r2 == nullptr)\\n          || (r1 == nullptr && r2 != nullptr))\\n            return false;\\n\\t\\t\\t\\n        if (r1->val != r2->val)\\n            return false;\\n\\t\\t\\t\\n        return isSameTree(r1->left, r2->left) && isSameTree(r1->right, r2->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794503,
                "title": "c-simple-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if ((!p) || (!q))\\n        {\\n            if ((!p) && (!q))\\n                return true;\\n            else return false;\\n        }\\n        if (p->val != q->val)\\n            return false;\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if ((!p) || (!q))\\n        {\\n            if ((!p) && (!q))\\n                return true;\\n            else return false;\\n        }\\n        if (p->val != q->val)\\n            return false;\\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 765093,
                "title": "esay-understand-of-interative",
                "content": "It is dfs with stack,i think it is very easy to understand,use only one stack can success it ,better than the offical answer\\n```java\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        LinkedList<TreeNode> queue=new LinkedList<>();\\n        queue.addLast(p);\\n        queue.addLast(q);\\n        while (queue.size()!=0){\\n            TreeNode q2=queue.removeLast();\\n            TreeNode q1=queue.removeLast();\\n            if (q1==null && q2==null) continue;\\n            if (q1==null || q2==null) return false;\\n            if (q1.val!=q2.val) return false;\\n            queue.addLast(q1.left);\\n            queue.addLast(q2.left);\\n            queue.addLast(q1.right);\\n            queue.addLast(q2.right);\\n        }\\n        return true;\\n    }\\n}```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```java\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        LinkedList<TreeNode> queue=new LinkedList<>();\\n        queue.addLast(p);\\n        queue.addLast(q);\\n        while (queue.size()!=0){\\n            TreeNode q2=queue.removeLast();\\n            TreeNode q1=queue.removeLast();\\n            if (q1==null && q2==null) continue;\\n            if (q1==null || q2==null) return false;\\n            if (q1.val!=q2.val) return false;\\n            queue.addLast(q1.left);\\n            queue.addLast(q2.left);\\n            queue.addLast(q1.right);\\n            queue.addLast(q2.right);\\n        }\\n        return true;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 735223,
                "title": "java-2-lines",
                "content": "```\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if (p == null || q == null) return p == null && q == null;\\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if (p == null || q == null) return p == null && q == null;\\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 345623,
                "title": "go-recursive-solution",
                "content": "```\\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\\n\\tif p == nil && q == nil {\\n\\t\\treturn true\\n\\t} else if p == nil || q == nil || p.Val != q.Val {\\n\\t\\treturn false\\n\\t} else {\\n\\t\\treturn isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\\n\\tif p == nil && q == nil {\\n\\t\\treturn true\\n\\t} else if p == nil || q == nil || p.Val != q.Val {\\n\\t\\treturn false\\n\\t} else {\\n\\t\\treturn isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 234255,
                "title": "go-100-0ms",
                "content": "```\\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\\n\\tif p == nil && q == nil {\\n\\t\\treturn true\\n\\t}\\n\\tif p == nil || q == nil || p.Val != q.Val {\\n\\t\\treturn false\\n\\t}\\n\\treturn isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\\n\\tif p == nil && q == nil {\\n\\t\\treturn true\\n\\t}\\n\\tif p == nil || q == nil || p.Val != q.Val {\\n\\t\\treturn false\\n\\t}\\n\\treturn isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 222099,
                "title": "python-fast-and-simple-solution-both-recursion-and-iterative",
                "content": "### Recursion\\n```python\\nclass Solution:\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not p and not q:\\n            return True\\n        if not p or not q or p.val != q.val:\\n            return False\\n\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```\\n\\n### Iterative\\n```python\\nclass Solution:\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        stack = [(p, q)]\\n        \\n        while stack:\\n            p, q = stack.pop()\\n            \\n            if not p and not q:\\n                continue\\n            if not p or not q or p.val != q.val:\\n                return False\\n            stack.append((p.right, q.right))\\n            stack.append((p.left, q.left))\\n            \\n        return True\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not p and not q:\\n            return True\\n        if not p or not q or p.val != q.val:\\n            return False\\n\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```\n```python\\nclass Solution:\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        stack = [(p, q)]\\n        \\n        while stack:\\n            p, q = stack.pop()\\n            \\n            if not p and not q:\\n                continue\\n            if not p or not q or p.val != q.val:\\n                return False\\n            stack.append((p.right, q.right))\\n            stack.append((p.left, q.left))\\n            \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189672,
                "title": "python-clean-iterative-solution",
                "content": "```python\\nclass Solution(object):\\n    def isSameTree(self, head1, head2):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        \\n        stack = [(head1, head2)]\\n\\n        while stack:\\n            root1, root2 = stack.pop()\\n            if (root1 and not root2) or (not root1 and root2) or (root1 and root2 and root1.val != root2.val):\\n                return False\\n\\n            if root1 and root2:\\n                stack.append((root1.left, root2.left))\\n                stack.append((root1.right, root2.right))\\n\\n        return True\\n\\t\\t\\t\\t```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def isSameTree(self, head1, head2):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        \\n        stack = [(head1, head2)]\\n\\n        while stack:\\n            root1, root2 = stack.pop()\\n            if (root1 and not root2) or (not root1 and root2) or (root1 and root2 and root1.val != root2.val):\\n                return False\\n\\n            if root1 and root2:\\n                stack.append((root1.left, root2.left))\\n                stack.append((root1.right, root2.right))\\n\\n        return True\\n\\t\\t\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 181179,
                "title": "simple-python-solution-beats-99-95",
                "content": "```\\ndef isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not p and not q:\\n            return True\\n        if p and q:\\n            if p.val != q.val:\\n                return False\\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        else:\\n            return False\\n```",
                "solutionTags": [],
                "code": "```\\ndef isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not p and not q:\\n            return True\\n        if p and q:\\n            if p.val != q.val:\\n                return False\\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        else:\\n            return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 161608,
                "title": "python-solution",
                "content": "Iterative:\\n```\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        queue = collections.deque([p,q])\\n        while queue:\\n            u1 = queue.popleft()\\n            u2 = queue.popleft()\\n            if u1 == None and u2 != None:\\n                return False\\n            if u1 != None and u2 == None:\\n                return False\\n            if u1 != None and u2 != None:\\n                if u1.val != u2.val:\\n                    return False\\n                else:\\n                    queue.append(u1.left)\\n                    queue.append(u2.left)\\n                    queue.append(u1.right)\\n                    queue.append(u2.right)\\n        return True\\n```\\nRecursive:\\n```\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if p == None and q == None:\\n            return True\\n        elif p == None and q != None:\\n            return False\\n        elif p != None and q == None:\\n            return False\\n        else:\\n            if p.val != q.val:\\n                return False\\n            else:\\n                return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        queue = collections.deque([p,q])\\n        while queue:\\n            u1 = queue.popleft()\\n            u2 = queue.popleft()\\n            if u1 == None and u2 != None:\\n                return False\\n            if u1 != None and u2 == None:\\n                return False\\n            if u1 != None and u2 != None:\\n                if u1.val != u2.val:\\n                    return False\\n                else:\\n                    queue.append(u1.left)\\n                    queue.append(u2.left)\\n                    queue.append(u1.right)\\n                    queue.append(u2.right)\\n        return True\\n```\n```\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if p == None and q == None:\\n            return True\\n        elif p == None and q != None:\\n            return False\\n        elif p != None and q == None:\\n            return False\\n        else:\\n            if p.val != q.val:\\n                return False\\n            else:\\n                return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32862,
                "title": "java-0ms-3-line-recursive-solution",
                "content": "    public class Solution {\\n        public boolean isSameTree(TreeNode p, TreeNode q) {\\n            if (p == q) return true;\\n            if ((p == null && q != null) || (p != null && q == null) || (p.val != q.val)) return false;\\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n        public boolean isSameTree(TreeNode p, TreeNode q) {\\n            if (p == q) return true;\\n            if ((p == null && q != null) || (p != null && q == null) || (p.val != q.val)) return false;\\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 32940,
                "title": "easy-java-solution",
                "content": "    public class Solution {\\n    \\n    boolean isSame = true;\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        \\n        //two nodes are null , return true\\n        if(p==null && q==null)\\n            return true;\\n            \\n            \\n        //one node is null, and the other node is not null, return false    \\n        if(p==null || q==null)\\n            return false;\\n        \\n    \\n        return (p.val == q.val) && isSameTree(p.left, q.left) && isSameTree(p.right, q.right) ;\\n        \\n\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    boolean isSame = true;\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        \\n        //two nodes are null , return true\\n        if(p==null && q==null)\\n            return true;\\n            \\n            \\n        //one node is null, and the other node is not null, return false    \\n        if(p==null || q==null)\\n            return false;\\n        \\n    \\n        return (p.val == q.val) && isSameTree(p.left, q.left) && isSameTree(p.right, q.right) ;\\n        \\n\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 32867,
                "title": "0-ms-c-solution",
                "content": "    bool isSameTree(struct TreeNode* p, struct TreeNode* q) {\\n    if(p == NULL && q == NULL) \\n        return true;\\n    if(p != NULL && q == NULL) \\n        return false;\\n    if(p == NULL && q != NULL) \\n        return false;\\n    if(p->val != q->val)\\n        return false;\\n    return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n    }",
                "solutionTags": [],
                "code": "    bool isSameTree(struct TreeNode* p, struct TreeNode* q) {\\n    if(p == NULL && q == NULL) \\n        return true;\\n    if(p != NULL && q == NULL) \\n        return false;\\n    if(p == NULL && q != NULL) \\n        return false;\\n    if(p->val != q->val)\\n        return false;\\n    return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 32972,
                "title": "my-44ms-python-solution",
                "content": "\\n    class Solution:\\n        # @param {TreeNode} p\\n        # @param {TreeNode} q\\n        # @return {boolean}\\n        def isSameTree(self, p, q):\\n            if p==q==None:\\n                return True\\n            if None in [p,q]:\\n                return False\\n            if p.val!=q.val:\\n                return False\\n            return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {TreeNode}",
                "codeTag": "Java"
            },
            {
                "id": 3885554,
                "title": "simple-optimised-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p==null && q==null)\\n        return true;\\n        if(p!=null&&q!=null)\\n        {\\n            return ( (p.val==q.val)&&(isSameTree(p.left,q.left))&& (isSameTree(p.right,q.right)));\\n        }\\n        return false;\\n      }\\n      \\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p==null && q==null)\\n        return true;\\n        if(p!=null&&q!=null)\\n        {\\n            return ( (p.val==q.val)&&(isSameTree(p.left,q.left))&& (isSameTree(p.right,q.right)));\\n        }\\n        return false;\\n      }\\n      \\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808320,
                "title": "simplest-python-recursive-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if not p and not q:\\n            return True\\n        if not p or not q:\\n            return False\\n        if p.val != q.val:\\n            return False\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if not p and not q:\\n            return True\\n        if not p or not q:\\n            return False\\n        if p.val != q.val:\\n            return False\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483195,
                "title": "java-solution",
                "content": "Follow the given steps to solve the problem:\\n\\n    - If both trees are empty then return 1(Base case)\\n    - Else If both trees are non-empty\\n    - Check data of the root nodes (tree1->data ==  tree2->data)\\n    - Check left subtrees recursively\\n    - Check right subtrees recursively\\n    - If the above three statements are true then return 1\\n    - Else return 0 (one is empty and the other is not)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n\\n        if (p == null || q == null) {\\n            return false;\\n        }\\n\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n\\n        if (p == null || q == null) {\\n            return false;\\n        }\\n\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391761,
                "title": "pyhton3-dfs-recursion",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if not p and not q:\\n            return True\\n        if not p or not q or p.val != q.val:\\n            return False\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if not p and not q:\\n            return True\\n        if not p or not q or p.val != q.val:\\n            return False\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363285,
                "title": "this-java-solution-beats-everyone",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(H) where h is height of the tree\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/1b42ccef-6f00-4aa8-9c48-986edd079a88_1680286752.4062045.png)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n       \\n       // If both trees are empty, return true\\n        if(p == null && q == null){\\n            return true;\\n        }\\n        // If one of the trees is empty and the other is not, return false\\n        if(p == null || q == null){\\n            return false;\\n        }\\n\\n        // If the values at the current nodes of the two trees are different, return false\\n        if(p.val != q.val){\\n            return false;\\n        }\\n\\n        // Recursively compare the left and right subtrees of the two trees\\n        // If both subtrees are the same, the two trees are the same\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n       \\n       // If both trees are empty, return true\\n        if(p == null && q == null){\\n            return true;\\n        }\\n        // If one of the trees is empty and the other is not, return false\\n        if(p == null || q == null){\\n            return false;\\n        }\\n\\n        // If the values at the current nodes of the two trees are different, return false\\n        if(p.val != q.val){\\n            return false;\\n        }\\n\\n        // Recursively compare the left and right subtrees of the two trees\\n        // If both subtrees are the same, the two trees are the same\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3217719,
                "title": "best-o-n-solution",
                "content": "# Approach\\nWe can use any traversal.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (p == NULL && q == NULL)\\n            return true;\\n        if (p == NULL || q == NULL)\\n            return false;\\n        if (p->val != q->val)\\n            return false;\\n        bool l = isSameTree(p->left, q->left); \\n        bool r = isSameTree(p->right, q->right);\\n        if (l != true || r != true)\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if (p == NULL && q == NULL)\\n            return true;\\n        if (p == NULL || q == NULL)\\n            return false;\\n        if (p->val != q->val)\\n            return false;\\n        bool l = isSameTree(p->left, q->left); \\n        bool r = isSameTree(p->right, q->right);\\n        if (l != true || r != true)\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030043,
                "title": "python-easy-to-unserstand-well-explained",
                "content": "# Intuition\\nTo recursively check for the structural and value similarity between each node of both trees\\n\\n# Approach\\nDepth-first search (DFS) traversal\\n\\n# Complexity\\n- Time complexity:\\n    O(n)\\n\\n- Space complexity:\\n    O(n)        \\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        # if both trees are None, return True\\n        if not p and not q:\\n            return True\\n        # if one tree is None and the other is not, return False\\n        if not p or not q:\\n            return False\\n        # if the values of the current nodes are not the same, return False\\n        if p.val != q.val:\\n            return False\\n        # recursively check the left and right subtrees\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        # if both trees are None, return True\\n        if not p and not q:\\n            return True\\n        # if one tree is None and the other is not, return False\\n        if not p or not q:\\n            return False\\n        # if the values of the current nodes are not the same, return False\\n        if p.val != q.val:\\n            return False\\n        # recursively check the left and right subtrees\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028642,
                "title": "c-easy-solution-with-two-easy-approch",
                "content": "# Intuition\\nSo Main Intution of this Question is just we have to check for each node in both the tree if node has same value then check for left subtree and right subtree and all nodes have same value with other tree so return 1 else return 0.\\n\\n# Approach\\nFor this Question we have a two approch.\\n1) First just check a node for both tree and compare its value if the value is same so go for left and right subtree for that purpose we can use any traversal method.\\n2) and in second approch just do any one traversal in both tree and store in a vector and at the end just compare two vector if that vector is same so bothe the tree is same otherwise not.\\n\\n# Complexity\\n- Time complexity:\\n\\n1) O(N) where N is number of node.\\n2) 2O(N) N is number of node.\\n\\n- Space complexity:\\n1) only auxilary stack space\\n2) O(N)+ auxilary stack space\\n\\n# Code\\n```\\nThis is first approch\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nbool checkforsame(TreeNode *p,TreeNode *q)\\n{\\n    int checkl=0,checkr=0;\\n    if(p==NULL&&q==NULL)\\n    {\\n        return 1;\\n    }\\n    if(p==NULL&&q!=NULL)return 0;\\n    if(p!=NULL&&q==NULL)return 0;\\n    if(p->val==q->val)\\n    {\\n        checkl=checkforsame(p->left,q->left);\\n        checkr=checkforsame(p->right,q->right);\\n\\n    }\\n    else return 0;\\n    return checkl&&checkr;\\n\\n\\n}\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        return checkforsame(p,q);\\n        \\n    }\\n};\\n```\\n\\n# code\\n```\\nsecond Approch\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(vector<int> &res,TreeNode *root)\\n    {\\n       if(root==NULL){\\n           res.push_back(-1);\\n           return;\\n       }\\n        res.push_back(root->val);\\n        solve(res,root->left);\\n        solve(res,root->right);\\n    }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        vector<int> res1;\\n        vector<int> res2;\\n        solve(res1,p);\\n        solve(res2,q);\\n        if(res1.size()!=res2.size())return false;\\n        for(int i=0;i<res1.size();i++)\\n        {\\n            if(res1[i]!=res2[i])\\n            {\\n                return false;\\n                \\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nThis is first approch\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nbool checkforsame(TreeNode *p,TreeNode *q)\\n{\\n    int checkl=0,checkr=0;\\n    if(p==NULL&&q==NULL)\\n    {\\n        return 1;\\n    }\\n    if(p==NULL&&q!=NULL)return 0;\\n    if(p!=NULL&&q==NULL)return 0;\\n    if(p->val==q->val)\\n    {\\n        checkl=checkforsame(p->left,q->left);\\n        checkr=checkforsame(p->right,q->right);\\n\\n    }\\n    else return 0;\\n    return checkl&&checkr;\\n\\n\\n}\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        return checkforsame(p,q);\\n        \\n    }\\n};\\n```\n```\\nsecond Approch\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(vector<int> &res,TreeNode *root)\\n    {\\n       if(root==NULL){\\n           res.push_back(-1);\\n           return;\\n       }\\n        res.push_back(root->val);\\n        solve(res,root->left);\\n        solve(res,root->right);\\n    }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        vector<int> res1;\\n        vector<int> res2;\\n        solve(res1,p);\\n        solve(res2,q);\\n        if(res1.size()!=res2.size())return false;\\n        for(int i=0;i<res1.size();i++)\\n        {\\n            if(res1[i]!=res2[i])\\n            {\\n                return false;\\n                \\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028358,
                "title": "3-js-solutions",
                "content": "\\n# Code BFS\\n```\\nvar isSameTree = function (p, q) {\\n  const stk = [p, q];\\n  while (stk.length) {\\n    const n1 = stk.pop(), n2 = stk.pop();\\n    if (!n1 && !n2) continue;\\n    if (!n1 || !n2 || n1.val !== n2.val) return false;\\n    stk.push(n1.left, n2.left, n1.right, n2.right);\\n  }\\n  return true;\\n};\\n\\n```\\n\\n# Code DFS\\n```\\nvar isSameTree = function (p, q) {\\n  if (!p && !q) return true;\\n  if ((p && !q) || (q && !p) || p.val !== q.val) return false;\\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n};\\n\\n```\\n\\n# Code JSON\\n```\\nvar isSameTree = function (p, q) {\\n  return JSON.stringify(p) === JSON.stringify(q)\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isSameTree = function (p, q) {\\n  const stk = [p, q];\\n  while (stk.length) {\\n    const n1 = stk.pop(), n2 = stk.pop();\\n    if (!n1 && !n2) continue;\\n    if (!n1 || !n2 || n1.val !== n2.val) return false;\\n    stk.push(n1.left, n2.left, n1.right, n2.right);\\n  }\\n  return true;\\n};\\n\\n```\n```\\nvar isSameTree = function (p, q) {\\n  if (!p && !q) return true;\\n  if ((p && !q) || (q && !p) || p.val !== q.val) return false;\\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n};\\n\\n```\n```\\nvar isSameTree = function (p, q) {\\n  return JSON.stringify(p) === JSON.stringify(q)\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3028273,
                "title": "efficiently-comparing-structurally-identical-binary-trees-o-n-time",
                "content": "The function takes two TreeNode objects as input, p and q. It first checks if p and q are the same object (i.e., if they are both null or if they are the same instance). If they are, it returns true. If either p or q is null, it returns false. If the values of p and q are different, it also returns false. If none of these conditions are true, it recursively checks if the left and right subtrees of p and q are the same.\\n\\n# Approach\\nRecursion\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool IsSameTree(TreeNode p, TreeNode q) {\\n        if (p == q) return true;\\n        if (p == null || q == null) return false;\\n        if (p.val != q.val) return false;\\n        return IsSameTree(p.left, q.left) && IsSameTree(p.right, q.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool IsSameTree(TreeNode p, TreeNode q) {\\n        if (p == q) return true;\\n        if (p == null || q == null) return false;\\n        if (p.val != q.val) return false;\\n        return IsSameTree(p.left, q.left) && IsSameTree(p.right, q.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028256,
                "title": "simple-approach-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhat should be true for them to be same???\\n(1) Value of root should be same \\n(2) Left subtree should also be same \\n(3) Same for the right subtree\\n\\n# Code\\n```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p == None or q == None:\\n            return p == q\\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p == None or q == None:\\n            return p == q\\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028165,
                "title": "solved-using-pre-order-traversal-python3-solutiont",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf I Traverse through both trees and develop a list of their values, Then if the list of both the trees is same, then  those two trees will be Same\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe apply inorder Traversal through the tree, and store the values in the seperate lists for both the trees, Note, when an intermediate tree node has Null value we store `-` in the list to differentiate between the empty node. At the end we compare two list so obtained and return True if the lists are same or else False..\\nHope it helps!!\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\ndef preorder_list(root):\\n    global ans\\n    ans =[]\\n    def preorder(root):\\n        if root:    \\n            ans.append(root.val)\\n            preorder(root.left)\\n            preorder(root.right)\\n        else:\\n            ans.append(\\'-\\')\\n    preorder(root)\\n    return ans\\n\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n\\n        x = preorder_list(p)\\n        y = preorder_list(q)      \\n        return x == y\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\ndef preorder_list(root):\\n    global ans\\n    ans =[]\\n    def preorder(root):\\n        if root:    \\n            ans.append(root.val)\\n            preorder(root.left)\\n            preorder(root.right)\\n        else:\\n            ans.append(\\'-\\')\\n    preorder(root)\\n    return ans\\n\\nclass Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n\\n        x = preorder_list(p)\\n        y = preorder_list(q)      \\n        return x == y\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028020,
                "title": "c-short-code",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL||q==NULL)\\n        {\\n            return p==q;\\n        }\\n        return (p->val==q->val) && isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p==NULL||q==NULL)\\n        {\\n            return p==q;\\n        }\\n        return (p->val==q->val) && isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027663,
                "title": "c-recursion-approach-with-explanation",
                "content": "# Intuition\\n- Recursion\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- The idea is to traverse both trees and compare values at their root node. If the value matches, recursively check if the first tree\\u2019s left subtree is identical to the left subtree of the second tree and the right subtree of the first tree is identical to the right subtree of the second tree. If the value at their root node differs, the trees violate data property. If at any point in the recursion, the first tree is empty and the second tree is non-empty, or the second tree is empty and the first tree is non-empty, the trees violate structural property, and they cannot be identical.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(min(n,m))$$\\n   - Where n & m are the size of tree.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(log (min(n, m)))$$\\n   - Due to auxiliary stack space used by recursion calls\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n\\n        // Base cases:\\n        if(p==NULL && q==NULL)\\n            return true;\\n        if(p==NULL && q!=NULL)\\n            return false;\\n        if(p!=NULL && q==NULL)\\n            return false;\\n\\n        // recursion to check left & right subtrees\\n        bool Left=isSameTree(p->left,q->left);\\n        bool Right=isSameTree(p->right,q->right);\\n\\n        bool ans=p->val==q->val;\\n\\n        if(Left && Right && ans)\\n            return true;\\n        else\\n            return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n\\n        // Base cases:\\n        if(p==NULL && q==NULL)\\n            return true;\\n        if(p==NULL && q!=NULL)\\n            return false;\\n        if(p!=NULL && q==NULL)\\n            return false;\\n\\n        // recursion to check left & right subtrees\\n        bool Left=isSameTree(p->left,q->left);\\n        bool Right=isSameTree(p->right,q->right);\\n\\n        bool ans=p->val==q->val;\\n\\n        if(Left && Right && ans)\\n            return true;\\n        else\\n            return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027484,
                "title": "java-iterative-recursive-0-ms-beats-100-with-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We just have to traverse through the trees and just check whether at every instance \\n    1. If the current node of `p` is null then so must be the current node of `q`\\n    2. If any one of them is null and not both then we return false\\n    3. If the values of current nodes don\\'t match we return false\\n    4. If we successfully traversed both the tree without hitting any roadblocks mentioned above we return true.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- One possible approach is recursion, by traversing through the depth of the tree. Use the points mentioned in the intuition section to build the base case.\\n- For Iterative appraoch, we can use Breadth-First-Search. Even for BFS we keep in mind the 4 steps mentioned above.\\n\\n\\n# Code\\n\\n### Recursive\\n```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null) return true;\\n        if(p == null || q == null || (p.val != q.val)) return false;\\n\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n```\\n\\n### Iterative\\n\\n``` \\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if((p == null && q != null) || (p != null && q == null)) return false;\\n\\n        Queue<TreeNode> tq1 = new LinkedList<>();\\n        Queue<TreeNode> tq2 = new LinkedList<>();\\n\\n        if(p!= null) tq1.offer(p);\\n        if(q!= null) tq2.offer(q);\\n\\n        while(!tq1.isEmpty() && !tq2.isEmpty()){\\n             TreeNode temp1 = tq1.poll();\\n             TreeNode temp2 = tq2.poll();\\n\\n             if(temp1.val != temp2.val) return false;\\n\\n             if(temp1.left != null && temp2.left != null){\\n                 tq1.offer(temp1.left);\\n                 tq2.offer(temp2.left);\\n             }\\n             else if((temp1.left == null && temp2.left != null) || (temp1.left != null && temp2.left == null)) return false;\\n\\n             if(temp1.right != null && temp2.right != null){\\n                 tq1.offer(temp1.right);\\n                 tq2.offer(temp2.right);\\n             }\\n             else if((temp1.right == null && temp2.right != null) || (temp1.right != null && temp2.right == null)) return false;\\n\\n         }\\n         return true; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null) return true;\\n        if(p == null || q == null || (p.val != q.val)) return false;\\n\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n```\n``` \\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if((p == null && q != null) || (p != null && q == null)) return false;\\n\\n        Queue<TreeNode> tq1 = new LinkedList<>();\\n        Queue<TreeNode> tq2 = new LinkedList<>();\\n\\n        if(p!= null) tq1.offer(p);\\n        if(q!= null) tq2.offer(q);\\n\\n        while(!tq1.isEmpty() && !tq2.isEmpty()){\\n             TreeNode temp1 = tq1.poll();\\n             TreeNode temp2 = tq2.poll();\\n\\n             if(temp1.val != temp2.val) return false;\\n\\n             if(temp1.left != null && temp2.left != null){\\n                 tq1.offer(temp1.left);\\n                 tq2.offer(temp2.left);\\n             }\\n             else if((temp1.left == null && temp2.left != null) || (temp1.left != null && temp2.left == null)) return false;\\n\\n             if(temp1.right != null && temp2.right != null){\\n                 tq1.offer(temp1.right);\\n                 tq2.offer(temp2.right);\\n             }\\n             else if((temp1.right == null && temp2.right != null) || (temp1.right != null && temp2.right == null)) return false;\\n\\n         }\\n         return true; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027375,
                "title": "c-easy-to-understand-best-and-easiest-solution-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL && q == NULL)\\n        {\\n            return true;     // case 1\\n        }\\n        else if(p && q== NULL || q && p== NULL)\\n        {\\n            return false;   //case2\\n        }\\n        \\n        else{\\n            if(p->val == q->val)  //when both value is equal\\n            {\\n                if(isSameTree(p->left,q->left) && isSameTree(p->right, q->right))    //recursively call for left and right for both tree\\n                {\\n                    return true;\\n                }\\n            }\\n            \\n        }\\n        return false;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(p == NULL && q == NULL)\\n        {\\n            return true;     // case 1\\n        }\\n        else if(p && q== NULL || q && p== NULL)\\n        {\\n            return false;   //case2\\n        }\\n        \\n        else{\\n            if(p->val == q->val)  //when both value is equal\\n            {\\n                if(isSameTree(p->left,q->left) && isSameTree(p->right, q->right))    //recursively call for left and right for both tree\\n                {\\n                    return true;\\n                }\\n            }\\n            \\n        }\\n        return false;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027351,
                "title": "daily-leetcoding-challenge-january-day-10",
                "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/same-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/same-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2812678,
                "title": "the-same-tree",
                "content": "```\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n\\n        def is_same(p,q):\\n            if not p and not q:\\n                return True\\n            if not p or not q:\\n                return False\\n            return is_same(p.left,q.left) and p.val == q.val and is_same(p.right, q.right)\\n        return is_same(p,q)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n\\n        def is_same(p,q):\\n            if not p and not q:\\n                return True\\n            if not p or not q:\\n                return False\\n            return is_same(p.left,q.left) and p.val == q.val and is_same(p.right, q.right)\\n        return is_same(p,q)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754146,
                "title": "very-easy-java-solution-0ms-100-faster-5lines-of-code",
                "content": "**very simplified solution for same tree**\\n\\t\\t\\n\\t\\tclass Solution {\\n\\t\\t\\t   public boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\t\\t\\t\\tif(p==null && q==null) {\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(p==null||q==null || p.val!=q.val) {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\t\\t   public boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\t\\t\\t\\tif(p==null && q==null) {\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2747446,
                "title": "easy-to-understand-javascript-solution",
                "content": "\\n\\n``` \\nvar isSameTree = function(p, q) {\\n\\t// A FLAG VARIABLE TO KEEP TRACK OF IF THE TREES ARE SAME OR NOT\\n    let isSame = true;\\n    \\n\\t// IF THE ROOT NODES ARE BOTH NULL THEN THEY\\'RE THE SAME TREE\\n    if (!p && !q) {\\n        return true;\\n    }\\n    \\n\\t// IF EITHER OF THE ROOT NODES ARE NULL AND THE OTHER ISNT, THEN THEY\\'RE NOT THE SAME TREE\\n    if ((p && !q) || (!p && q)) {\\n        return false;\\n    }\\n    \\n\\t// HELPER TRAVERSAL FUNCTION FOR DEPTH FIRST SEARCH\\n\\t// TAKES IN THE NODES FROM BOTH TREES AS PARAMETERS\\n    let traverse = (a, b) => {\\n\\t\\n\\t\\t// IF THE TWO NODES VALUES ARE NOT THE SAME, THEN THEY\\'RE NOT THE SAME TREE\\n        if (a.val !== b.val) {\\n            isSame = false;\\n        }\\n        \\n\\t\\t// IF BOTH TREES HAVE LEFT NODES, RUN HELPER FUNCTION\\n        if (a.left && b.left) {\\n            traverse(a.left, b.left)\\n        }\\n        \\n\\t\\t// IF BOTH TREES HAVE RIGHT NODES, RUN HELPER FUNCTION\\n        if (a.right && b.right) {\\n            traverse(a.right, b.right)\\n        }\\n        \\n\\t\\t// IF ONE TREE HAS A LEFT NODE AND THE OTHER DOESN\\'T, THEY\\'RE NOT THE SAME TREE\\n        if ((a.left && !b.left) || (!a.left && b.left)) {\\n            isSame = false\\n        }\\n        \\n\\t\\t// IF ONE TREE HAS A RIGHT NODE AND THE OTHER DOESN\\'T, THEY\\'RE NOT THE SAME TREE\\n        if ((a.right && !b.right) || (!a.right && b.right)) {\\n            isSame = false;\\n        }\\n    }\\n    \\n\\t// INVOKE THE HELPER FUNCTION WITH THE ROOT NODES\\n    traverse(p, q)\\n    \\n    return isSame;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "``` \\nvar isSameTree = function(p, q) {\\n\\t// A FLAG VARIABLE TO KEEP TRACK OF IF THE TREES ARE SAME OR NOT\\n    let isSame = true;\\n    \\n\\t// IF THE ROOT NODES ARE BOTH NULL THEN THEY\\'RE THE SAME TREE\\n    if (!p && !q) {\\n        return true;\\n    }\\n    \\n\\t// IF EITHER OF THE ROOT NODES ARE NULL AND THE OTHER ISNT, THEN THEY\\'RE NOT THE SAME TREE\\n    if ((p && !q) || (!p && q)) {\\n        return false;\\n    }\\n    \\n\\t// HELPER TRAVERSAL FUNCTION FOR DEPTH FIRST SEARCH\\n\\t// TAKES IN THE NODES FROM BOTH TREES AS PARAMETERS\\n    let traverse = (a, b) => {\\n\\t\\n\\t\\t// IF THE TWO NODES VALUES ARE NOT THE SAME, THEN THEY\\'RE NOT THE SAME TREE\\n        if (a.val !== b.val) {\\n            isSame = false;\\n        }\\n        \\n\\t\\t// IF BOTH TREES HAVE LEFT NODES, RUN HELPER FUNCTION\\n        if (a.left && b.left) {\\n            traverse(a.left, b.left)\\n        }\\n        \\n\\t\\t// IF BOTH TREES HAVE RIGHT NODES, RUN HELPER FUNCTION\\n        if (a.right && b.right) {\\n            traverse(a.right, b.right)\\n        }\\n        \\n\\t\\t// IF ONE TREE HAS A LEFT NODE AND THE OTHER DOESN\\'T, THEY\\'RE NOT THE SAME TREE\\n        if ((a.left && !b.left) || (!a.left && b.left)) {\\n            isSame = false\\n        }\\n        \\n\\t\\t// IF ONE TREE HAS A RIGHT NODE AND THE OTHER DOESN\\'T, THEY\\'RE NOT THE SAME TREE\\n        if ((a.right && !b.right) || (!a.right && b.right)) {\\n            isSame = false;\\n        }\\n    }\\n    \\n\\t// INVOKE THE HELPER FUNCTION WITH THE ROOT NODES\\n    traverse(p, q)\\n    \\n    return isSame;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2698286,
                "title": "java-single-line-code-runtime-0-ms",
                "content": "```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q==null){\\n            return true;\\n        }   \\n        if(p==null || q==null){\\n            return false;\\n        }\\n        return p.val == q.val && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q==null){\\n            return true;\\n        }   \\n        if(p==null || q==null){\\n            return false;\\n        }\\n        return p.val == q.val && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2377267,
                "title": "c-bfs-esay-to-understand",
                "content": "\\nclass Solution {\\npublic:\\n\\n    \\n    bool isSameTree(TreeNode* root1, TreeNode* root2) {\\n        \\n        queue<TreeNode*> q1;\\n        queue<TreeNode*> q2;\\n        \\n        q1.push(root1);\\n        q2.push(root2);\\n        \\n        while(!q1.empty() and !q2.empty()){\\n            \\n            auto node1 = q1.front();\\n            auto node2 = q2.front();\\n            q1.pop();\\n            q2.pop();\\n            \\n            if(node1 == NULL or node2 == NULL){\\n                if(node1 != node2) return false;\\n                continue;\\n            }\\n            \\n            if(node1->val != node2->val) return false;\\n            \\n            q1.push(node1->left);\\n            q1.push(node1->right);\\n            \\n            q2.push(node2->left);\\n            q2.push(node2->right);\\n            \\n        }\\n        \\n        \\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n\\n    \\n    bool isSameTree(TreeNode* root1, TreeNode* root2) {\\n        \\n        queue<TreeNode*> q1;\\n        queue<TreeNode*> q2;\\n        \\n        q1.push(root1);\\n        q2.push(root2);\\n        \\n        while(!q1.empty() and !q2.empty()){\\n            \\n            auto node1 = q1.front();\\n            auto node2 = q2.front();\\n            q1.pop();\\n            q2.pop();\\n            \\n            if(node1 == NULL or node2 == NULL){\\n                if(node1 != node2) return false;\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2250107,
                "title": "c-simple-and-clean-solution",
                "content": "**Please Upvote if it helped you \\nHappy Coding :)**\\n```\\n bool isSameTree(TreeNode* p, TreeNode* q) \\n    {\\n        if(p==NULL && q==NULL)\\n            return true;\\n        if(p==NULL || q==NULL)\\n            return false;\\n        if(p->val != q->val)\\n            return false;\\n        return isSameTree(p->left,q->left) && isSameTree( p->right, q->right);\\n    }\\n```\\t",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n bool isSameTree(TreeNode* p, TreeNode* q) \\n    {\\n        if(p==NULL && q==NULL)\\n            return true;\\n        if(p==NULL || q==NULL)\\n            return false;\\n        if(p->val != q->val)\\n            return false;\\n        return isSameTree(p->left,q->left) && isSameTree( p->right, q->right);\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1750693,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1574703,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1722899,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1568922,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1575136,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1568923,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1849628,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1574744,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1576370,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1751506,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1750693,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1574703,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1722899,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1568922,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1575136,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1568923,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1849628,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1574744,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1576370,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1751506,
                "content": [
                    {
                        "username": "ankitbora31",
                        "content": "from having no knowledge of trees few months back to solving this in less than a minute.."
                    },
                    {
                        "username": "newvaruntanwar",
                        "content": "Please stop spamming the discussion section.\\nThis section is not for blowing your own trumpet. "
                    },
                    {
                        "username": "sandwichcreator",
                        "content": "any tips on getting better with trees dfs? stuck on tree diameter"
                    },
                    {
                        "username": "cloudvy",
                        "content": "[@agentile](/agentile) copy-paste code for tree class in your IDE. Uncomment it and instantiate an object of the class."
                    },
                    {
                        "username": "agentile",
                        "content": "Congratulations! May I ask as someone with zero knowledge of trees, how do you instance TreeNode objects given the test cases?"
                    },
                    {
                        "username": "abdullahalazaidy",
                        "content": "return str(p) == str(q)\\n"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "nice hack.. but it doesn\\'t help with problem-solving.."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@nishant7372](/nishant7372)  Yes @nishant7372 but it depends on the toString() implementation. There is no toString() implementation for our TreeNode class here. Hence it won\\'t work if you try toString() here."
                    },
                    {
                        "username": "kk_harjeeth",
                        "content": "Yaar ! \\uD83E\\uDD2F"
                    },
                    {
                        "username": "nishant7372",
                        "content": "Is str here .toString() method?"
                    },
                    {
                        "username": "Morice",
                        "content": "It took me some time to solve this, and I was hung up on how the test cases are organized, which I realized it does not matter. But what I mean is, I was wondering if the test cases are in order, post, or pre order. I mean is it [root,left,right], [left,root,right], or [left, right, root]. I am not sure if anyone has any thought on this. It did not end up being an issue since the state is only relevant to the current node if that makes sense."
                    },
                    {
                        "username": "kandiana",
                        "content": "It\\'s actually neither)\\nIf you are still interested, you can read this article: https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\\nIt explains binary trees\\' input/output format that leetcode uses"
                    },
                    {
                        "username": "RoyalPen",
                        "content": "Thanks for clicking!!!"
                    },
                    {
                        "username": "MakarovS",
                        "content": "So I didn\\'t read this problem right and thought that what we need is to find whether `q` is a subtree of `p` (basically what this https://leetcode.com/problems/subtree-of-another-tree/ problem is about). So I wrote a subtree solution for this and it worked, there are no tests that check for a subtree case (e.g. `[1,2,3] [2]`). You can copypaste a solution from the problem I linked and it will work here. I wonder if there is a way to add a test for this problem?"
                    },
                    {
                        "username": "mrping_11",
                        "content": "you cant , current problem is a special case of what you subtree problem ie both tree are equal ."
                    },
                    {
                        "username": "therealfakebatman",
                        "content": "\\tpublic static boolean isSameTree(TreeNode p, TreeNode q) {\\n\\t\\tif(p==null&&q==null) return true;\\n\\t\\tif(p==null || q==null)return false;\\n\\t\\treturn (p.val==q.val)&&isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\\n\\t}"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Thank you for spoiling my fun for the day, I had exactly the same solution in mind. Please don\\'t post solutions here."
                    },
                    {
                        "username": "neopraveen",
                        "content": "Please don\\'t spoil other\\'s fun. As per instructions it is not good practice to share code in discussion."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "Why there is not a **Hint** for this question."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tif p and q:\\n\\t\\treturn p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n\\treturn p is q"
                    },
                    {
                        "username": "mojgan1987",
                        "content": "Please don\\'t post any solutions in this discussion tab. X("
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This is one of the slick solution ever!"
                    },
                    {
                        "username": "seankala",
                        "content": "I tried printing `p == q` for the first test case (i.e., `TreeNode{val: 1, left: TreeNode{val: 2, left: None, right: None}, right: TreeNode{val: 3, left: None, right: None}}`) and it\\'s returning False. Isn\\'t it supposed to return True?"
                    },
                    {
                        "username": "shashi675",
                        "content": "here, you have given only one tree: 1->leftnode: 2, 1->rightnode:3;\\nyou have to pass two trees, p and q;"
                    },
                    {
                        "username": "acchang4",
                        "content": "[@iSyqozz512](/iSyqozz512) How does this happen? Did leetcode change what happens when you hit \"run\" as opposed to other types of problems?"
                    },
                    {
                        "username": "iSyqozz512",
                        "content": "\\'==\\' here will default to the \\'is\\' operator which will check identity of both objects/memory address."
                    },
                    {
                        "username": "solankera2001",
                        "content": "\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if((p==NULL && q==NULL)){\\n            return 1;\\n        }\\n        else if( (p==NULL || q==NULL) || (p->val!=q->val) ){\\n            return 0;\\n        }\\n        \\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1751251,
                "content": [
                    {
                        "username": "jahidulhossainmekat",
                        "content": "```\nPython Solve\n```\n```\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p==None and q==None:\n            return True\n        if p==None or q==None:\n            return False\n        else:\n            return (p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right))\n```"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "Thank you so much. My idea was very similar to yours but I was just missing one thing. Realised it once I saw your code. Implemented it and my solution worked too. Thanks!!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**don\\'t post codes here..\\nuse solution section for that**"
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Check out solution with explanation\\n[Both 3 line and 1 line solution](https://qr.ae/pNs1d5)"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/059388a8-75ba-470f-8648-54f443700e16_1626241605.4358785.png)\\n"
                    },
                    {
                        "username": "wwww",
                        "content": "got the answer already, i forget something.thanks guys"
                    },
                    {
                        "username": "pavloslav",
                        "content": "In Rust #[derive(PartialEq)] is a bit over top :)"
                    },
                    {
                        "username": "ncn-ends",
                        "content": "Why is there a test case with null p and null q when it doesn\\'t specify anywhere in the description that it can be null, and the types for the parameters are non-null (at least for C#)? I understand it\\'s based on older version of C#, but then it should specify it in the description. \\nFailed the initial submit for no reason."
                    },
                    {
                        "username": "KaikE2345",
                        "content": "Where could I get educated on trees? I\\'m struggling to understand where the method isSameTree() comes from. "
                    },
                    {
                        "username": "hani98",
                        "content": "why in this code I give this error:\\n     AttributeError: \\'NoneType\\' object has no attribute \\'val\\'\\n          p1= [p.val] + preorder(p.left) + preorder(p.right)\\n\\ncode: `class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        p1=[]\\n        q1=[]\\n        def preorder(p):\\n            p1= [p.val] + preorder(p.left) + preorder(p.right)\\n        return preorder(p)==preorder(q)`\\n"
                    },
                    {
                        "username": "geometrygaming8",
                        "content": "Made an iterative solution if y'all interested:\n \n        stack = [p, q]\n\n        while stack:\n            q1 = stack.pop()\n            p1 = stack.pop()\n\n            if not p1 and not q1:\n                continue\n            elif not p1 or not q1:\n                return False\n\n            if p1.val != q1.val: return False\n\n            stack.append(p1.left)\n            stack.append(q1.left)\n            stack.append(p1.right)\n            stack.append(q1.right)\n\n        return True"
                    }
                ]
            },
            {
                "id": 1750475,
                "content": [
                    {
                        "username": "jahidulhossainmekat",
                        "content": "```\nPython Solve\n```\n```\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p==None and q==None:\n            return True\n        if p==None or q==None:\n            return False\n        else:\n            return (p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right))\n```"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "Thank you so much. My idea was very similar to yours but I was just missing one thing. Realised it once I saw your code. Implemented it and my solution worked too. Thanks!!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**don\\'t post codes here..\\nuse solution section for that**"
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Check out solution with explanation\\n[Both 3 line and 1 line solution](https://qr.ae/pNs1d5)"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/059388a8-75ba-470f-8648-54f443700e16_1626241605.4358785.png)\\n"
                    },
                    {
                        "username": "wwww",
                        "content": "got the answer already, i forget something.thanks guys"
                    },
                    {
                        "username": "pavloslav",
                        "content": "In Rust #[derive(PartialEq)] is a bit over top :)"
                    },
                    {
                        "username": "ncn-ends",
                        "content": "Why is there a test case with null p and null q when it doesn\\'t specify anywhere in the description that it can be null, and the types for the parameters are non-null (at least for C#)? I understand it\\'s based on older version of C#, but then it should specify it in the description. \\nFailed the initial submit for no reason."
                    },
                    {
                        "username": "KaikE2345",
                        "content": "Where could I get educated on trees? I\\'m struggling to understand where the method isSameTree() comes from. "
                    },
                    {
                        "username": "hani98",
                        "content": "why in this code I give this error:\\n     AttributeError: \\'NoneType\\' object has no attribute \\'val\\'\\n          p1= [p.val] + preorder(p.left) + preorder(p.right)\\n\\ncode: `class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        p1=[]\\n        q1=[]\\n        def preorder(p):\\n            p1= [p.val] + preorder(p.left) + preorder(p.right)\\n        return preorder(p)==preorder(q)`\\n"
                    },
                    {
                        "username": "geometrygaming8",
                        "content": "Made an iterative solution if y'all interested:\n \n        stack = [p, q]\n\n        while stack:\n            q1 = stack.pop()\n            p1 = stack.pop()\n\n            if not p1 and not q1:\n                continue\n            elif not p1 or not q1:\n                return False\n\n            if p1.val != q1.val: return False\n\n            stack.append(p1.left)\n            stack.append(q1.left)\n            stack.append(p1.right)\n            stack.append(q1.right)\n\n        return True"
                    }
                ]
            },
            {
                "id": 1574051,
                "content": [
                    {
                        "username": "jahidulhossainmekat",
                        "content": "```\nPython Solve\n```\n```\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p==None and q==None:\n            return True\n        if p==None or q==None:\n            return False\n        else:\n            return (p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right))\n```"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "Thank you so much. My idea was very similar to yours but I was just missing one thing. Realised it once I saw your code. Implemented it and my solution worked too. Thanks!!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**don\\'t post codes here..\\nuse solution section for that**"
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Check out solution with explanation\\n[Both 3 line and 1 line solution](https://qr.ae/pNs1d5)"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/059388a8-75ba-470f-8648-54f443700e16_1626241605.4358785.png)\\n"
                    },
                    {
                        "username": "wwww",
                        "content": "got the answer already, i forget something.thanks guys"
                    },
                    {
                        "username": "pavloslav",
                        "content": "In Rust #[derive(PartialEq)] is a bit over top :)"
                    },
                    {
                        "username": "ncn-ends",
                        "content": "Why is there a test case with null p and null q when it doesn\\'t specify anywhere in the description that it can be null, and the types for the parameters are non-null (at least for C#)? I understand it\\'s based on older version of C#, but then it should specify it in the description. \\nFailed the initial submit for no reason."
                    },
                    {
                        "username": "KaikE2345",
                        "content": "Where could I get educated on trees? I\\'m struggling to understand where the method isSameTree() comes from. "
                    },
                    {
                        "username": "hani98",
                        "content": "why in this code I give this error:\\n     AttributeError: \\'NoneType\\' object has no attribute \\'val\\'\\n          p1= [p.val] + preorder(p.left) + preorder(p.right)\\n\\ncode: `class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        p1=[]\\n        q1=[]\\n        def preorder(p):\\n            p1= [p.val] + preorder(p.left) + preorder(p.right)\\n        return preorder(p)==preorder(q)`\\n"
                    },
                    {
                        "username": "geometrygaming8",
                        "content": "Made an iterative solution if y'all interested:\n \n        stack = [p, q]\n\n        while stack:\n            q1 = stack.pop()\n            p1 = stack.pop()\n\n            if not p1 and not q1:\n                continue\n            elif not p1 or not q1:\n                return False\n\n            if p1.val != q1.val: return False\n\n            stack.append(p1.left)\n            stack.append(q1.left)\n            stack.append(p1.right)\n            stack.append(q1.right)\n\n        return True"
                    }
                ]
            },
            {
                "id": 1575533,
                "content": [
                    {
                        "username": "jahidulhossainmekat",
                        "content": "```\nPython Solve\n```\n```\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p==None and q==None:\n            return True\n        if p==None or q==None:\n            return False\n        else:\n            return (p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right))\n```"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "Thank you so much. My idea was very similar to yours but I was just missing one thing. Realised it once I saw your code. Implemented it and my solution worked too. Thanks!!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**don\\'t post codes here..\\nuse solution section for that**"
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Check out solution with explanation\\n[Both 3 line and 1 line solution](https://qr.ae/pNs1d5)"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/059388a8-75ba-470f-8648-54f443700e16_1626241605.4358785.png)\\n"
                    },
                    {
                        "username": "wwww",
                        "content": "got the answer already, i forget something.thanks guys"
                    },
                    {
                        "username": "pavloslav",
                        "content": "In Rust #[derive(PartialEq)] is a bit over top :)"
                    },
                    {
                        "username": "ncn-ends",
                        "content": "Why is there a test case with null p and null q when it doesn\\'t specify anywhere in the description that it can be null, and the types for the parameters are non-null (at least for C#)? I understand it\\'s based on older version of C#, but then it should specify it in the description. \\nFailed the initial submit for no reason."
                    },
                    {
                        "username": "KaikE2345",
                        "content": "Where could I get educated on trees? I\\'m struggling to understand where the method isSameTree() comes from. "
                    },
                    {
                        "username": "hani98",
                        "content": "why in this code I give this error:\\n     AttributeError: \\'NoneType\\' object has no attribute \\'val\\'\\n          p1= [p.val] + preorder(p.left) + preorder(p.right)\\n\\ncode: `class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        p1=[]\\n        q1=[]\\n        def preorder(p):\\n            p1= [p.val] + preorder(p.left) + preorder(p.right)\\n        return preorder(p)==preorder(q)`\\n"
                    },
                    {
                        "username": "geometrygaming8",
                        "content": "Made an iterative solution if y'all interested:\n \n        stack = [p, q]\n\n        while stack:\n            q1 = stack.pop()\n            p1 = stack.pop()\n\n            if not p1 and not q1:\n                continue\n            elif not p1 or not q1:\n                return False\n\n            if p1.val != q1.val: return False\n\n            stack.append(p1.left)\n            stack.append(q1.left)\n            stack.append(p1.right)\n            stack.append(q1.right)\n\n        return True"
                    }
                ]
            },
            {
                "id": 1571213,
                "content": [
                    {
                        "username": "jahidulhossainmekat",
                        "content": "```\nPython Solve\n```\n```\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p==None and q==None:\n            return True\n        if p==None or q==None:\n            return False\n        else:\n            return (p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right))\n```"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "Thank you so much. My idea was very similar to yours but I was just missing one thing. Realised it once I saw your code. Implemented it and my solution worked too. Thanks!!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**don\\'t post codes here..\\nuse solution section for that**"
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Check out solution with explanation\\n[Both 3 line and 1 line solution](https://qr.ae/pNs1d5)"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/059388a8-75ba-470f-8648-54f443700e16_1626241605.4358785.png)\\n"
                    },
                    {
                        "username": "wwww",
                        "content": "got the answer already, i forget something.thanks guys"
                    },
                    {
                        "username": "pavloslav",
                        "content": "In Rust #[derive(PartialEq)] is a bit over top :)"
                    },
                    {
                        "username": "ncn-ends",
                        "content": "Why is there a test case with null p and null q when it doesn\\'t specify anywhere in the description that it can be null, and the types for the parameters are non-null (at least for C#)? I understand it\\'s based on older version of C#, but then it should specify it in the description. \\nFailed the initial submit for no reason."
                    },
                    {
                        "username": "KaikE2345",
                        "content": "Where could I get educated on trees? I\\'m struggling to understand where the method isSameTree() comes from. "
                    },
                    {
                        "username": "hani98",
                        "content": "why in this code I give this error:\\n     AttributeError: \\'NoneType\\' object has no attribute \\'val\\'\\n          p1= [p.val] + preorder(p.left) + preorder(p.right)\\n\\ncode: `class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        p1=[]\\n        q1=[]\\n        def preorder(p):\\n            p1= [p.val] + preorder(p.left) + preorder(p.right)\\n        return preorder(p)==preorder(q)`\\n"
                    },
                    {
                        "username": "geometrygaming8",
                        "content": "Made an iterative solution if y'all interested:\n \n        stack = [p, q]\n\n        while stack:\n            q1 = stack.pop()\n            p1 = stack.pop()\n\n            if not p1 and not q1:\n                continue\n            elif not p1 or not q1:\n                return False\n\n            if p1.val != q1.val: return False\n\n            stack.append(p1.left)\n            stack.append(q1.left)\n            stack.append(p1.right)\n            stack.append(q1.right)\n\n        return True"
                    }
                ]
            },
            {
                "id": 2056465,
                "content": [
                    {
                        "username": "jahidulhossainmekat",
                        "content": "```\nPython Solve\n```\n```\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p==None and q==None:\n            return True\n        if p==None or q==None:\n            return False\n        else:\n            return (p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right))\n```"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "Thank you so much. My idea was very similar to yours but I was just missing one thing. Realised it once I saw your code. Implemented it and my solution worked too. Thanks!!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**don\\'t post codes here..\\nuse solution section for that**"
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Check out solution with explanation\\n[Both 3 line and 1 line solution](https://qr.ae/pNs1d5)"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/059388a8-75ba-470f-8648-54f443700e16_1626241605.4358785.png)\\n"
                    },
                    {
                        "username": "wwww",
                        "content": "got the answer already, i forget something.thanks guys"
                    },
                    {
                        "username": "pavloslav",
                        "content": "In Rust #[derive(PartialEq)] is a bit over top :)"
                    },
                    {
                        "username": "ncn-ends",
                        "content": "Why is there a test case with null p and null q when it doesn\\'t specify anywhere in the description that it can be null, and the types for the parameters are non-null (at least for C#)? I understand it\\'s based on older version of C#, but then it should specify it in the description. \\nFailed the initial submit for no reason."
                    },
                    {
                        "username": "KaikE2345",
                        "content": "Where could I get educated on trees? I\\'m struggling to understand where the method isSameTree() comes from. "
                    },
                    {
                        "username": "hani98",
                        "content": "why in this code I give this error:\\n     AttributeError: \\'NoneType\\' object has no attribute \\'val\\'\\n          p1= [p.val] + preorder(p.left) + preorder(p.right)\\n\\ncode: `class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        p1=[]\\n        q1=[]\\n        def preorder(p):\\n            p1= [p.val] + preorder(p.left) + preorder(p.right)\\n        return preorder(p)==preorder(q)`\\n"
                    },
                    {
                        "username": "geometrygaming8",
                        "content": "Made an iterative solution if y'all interested:\n \n        stack = [p, q]\n\n        while stack:\n            q1 = stack.pop()\n            p1 = stack.pop()\n\n            if not p1 and not q1:\n                continue\n            elif not p1 or not q1:\n                return False\n\n            if p1.val != q1.val: return False\n\n            stack.append(p1.left)\n            stack.append(q1.left)\n            stack.append(p1.right)\n            stack.append(q1.right)\n\n        return True"
                    }
                ]
            },
            {
                "id": 2035545,
                "content": [
                    {
                        "username": "jahidulhossainmekat",
                        "content": "```\nPython Solve\n```\n```\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p==None and q==None:\n            return True\n        if p==None or q==None:\n            return False\n        else:\n            return (p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right))\n```"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "Thank you so much. My idea was very similar to yours but I was just missing one thing. Realised it once I saw your code. Implemented it and my solution worked too. Thanks!!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**don\\'t post codes here..\\nuse solution section for that**"
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Check out solution with explanation\\n[Both 3 line and 1 line solution](https://qr.ae/pNs1d5)"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/059388a8-75ba-470f-8648-54f443700e16_1626241605.4358785.png)\\n"
                    },
                    {
                        "username": "wwww",
                        "content": "got the answer already, i forget something.thanks guys"
                    },
                    {
                        "username": "pavloslav",
                        "content": "In Rust #[derive(PartialEq)] is a bit over top :)"
                    },
                    {
                        "username": "ncn-ends",
                        "content": "Why is there a test case with null p and null q when it doesn\\'t specify anywhere in the description that it can be null, and the types for the parameters are non-null (at least for C#)? I understand it\\'s based on older version of C#, but then it should specify it in the description. \\nFailed the initial submit for no reason."
                    },
                    {
                        "username": "KaikE2345",
                        "content": "Where could I get educated on trees? I\\'m struggling to understand where the method isSameTree() comes from. "
                    },
                    {
                        "username": "hani98",
                        "content": "why in this code I give this error:\\n     AttributeError: \\'NoneType\\' object has no attribute \\'val\\'\\n          p1= [p.val] + preorder(p.left) + preorder(p.right)\\n\\ncode: `class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        p1=[]\\n        q1=[]\\n        def preorder(p):\\n            p1= [p.val] + preorder(p.left) + preorder(p.right)\\n        return preorder(p)==preorder(q)`\\n"
                    },
                    {
                        "username": "geometrygaming8",
                        "content": "Made an iterative solution if y'all interested:\n \n        stack = [p, q]\n\n        while stack:\n            q1 = stack.pop()\n            p1 = stack.pop()\n\n            if not p1 and not q1:\n                continue\n            elif not p1 or not q1:\n                return False\n\n            if p1.val != q1.val: return False\n\n            stack.append(p1.left)\n            stack.append(q1.left)\n            stack.append(p1.right)\n            stack.append(q1.right)\n\n        return True"
                    }
                ]
            },
            {
                "id": 2034620,
                "content": [
                    {
                        "username": "jahidulhossainmekat",
                        "content": "```\nPython Solve\n```\n```\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p==None and q==None:\n            return True\n        if p==None or q==None:\n            return False\n        else:\n            return (p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right))\n```"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "Thank you so much. My idea was very similar to yours but I was just missing one thing. Realised it once I saw your code. Implemented it and my solution worked too. Thanks!!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**don\\'t post codes here..\\nuse solution section for that**"
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Check out solution with explanation\\n[Both 3 line and 1 line solution](https://qr.ae/pNs1d5)"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/059388a8-75ba-470f-8648-54f443700e16_1626241605.4358785.png)\\n"
                    },
                    {
                        "username": "wwww",
                        "content": "got the answer already, i forget something.thanks guys"
                    },
                    {
                        "username": "pavloslav",
                        "content": "In Rust #[derive(PartialEq)] is a bit over top :)"
                    },
                    {
                        "username": "ncn-ends",
                        "content": "Why is there a test case with null p and null q when it doesn\\'t specify anywhere in the description that it can be null, and the types for the parameters are non-null (at least for C#)? I understand it\\'s based on older version of C#, but then it should specify it in the description. \\nFailed the initial submit for no reason."
                    },
                    {
                        "username": "KaikE2345",
                        "content": "Where could I get educated on trees? I\\'m struggling to understand where the method isSameTree() comes from. "
                    },
                    {
                        "username": "hani98",
                        "content": "why in this code I give this error:\\n     AttributeError: \\'NoneType\\' object has no attribute \\'val\\'\\n          p1= [p.val] + preorder(p.left) + preorder(p.right)\\n\\ncode: `class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        p1=[]\\n        q1=[]\\n        def preorder(p):\\n            p1= [p.val] + preorder(p.left) + preorder(p.right)\\n        return preorder(p)==preorder(q)`\\n"
                    },
                    {
                        "username": "geometrygaming8",
                        "content": "Made an iterative solution if y'all interested:\n \n        stack = [p, q]\n\n        while stack:\n            q1 = stack.pop()\n            p1 = stack.pop()\n\n            if not p1 and not q1:\n                continue\n            elif not p1 or not q1:\n                return False\n\n            if p1.val != q1.val: return False\n\n            stack.append(p1.left)\n            stack.append(q1.left)\n            stack.append(p1.right)\n            stack.append(q1.right)\n\n        return True"
                    }
                ]
            },
            {
                "id": 2032553,
                "content": [
                    {
                        "username": "jahidulhossainmekat",
                        "content": "```\nPython Solve\n```\n```\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p==None and q==None:\n            return True\n        if p==None or q==None:\n            return False\n        else:\n            return (p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right))\n```"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "Thank you so much. My idea was very similar to yours but I was just missing one thing. Realised it once I saw your code. Implemented it and my solution worked too. Thanks!!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**don\\'t post codes here..\\nuse solution section for that**"
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Check out solution with explanation\\n[Both 3 line and 1 line solution](https://qr.ae/pNs1d5)"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/059388a8-75ba-470f-8648-54f443700e16_1626241605.4358785.png)\\n"
                    },
                    {
                        "username": "wwww",
                        "content": "got the answer already, i forget something.thanks guys"
                    },
                    {
                        "username": "pavloslav",
                        "content": "In Rust #[derive(PartialEq)] is a bit over top :)"
                    },
                    {
                        "username": "ncn-ends",
                        "content": "Why is there a test case with null p and null q when it doesn\\'t specify anywhere in the description that it can be null, and the types for the parameters are non-null (at least for C#)? I understand it\\'s based on older version of C#, but then it should specify it in the description. \\nFailed the initial submit for no reason."
                    },
                    {
                        "username": "KaikE2345",
                        "content": "Where could I get educated on trees? I\\'m struggling to understand where the method isSameTree() comes from. "
                    },
                    {
                        "username": "hani98",
                        "content": "why in this code I give this error:\\n     AttributeError: \\'NoneType\\' object has no attribute \\'val\\'\\n          p1= [p.val] + preorder(p.left) + preorder(p.right)\\n\\ncode: `class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        p1=[]\\n        q1=[]\\n        def preorder(p):\\n            p1= [p.val] + preorder(p.left) + preorder(p.right)\\n        return preorder(p)==preorder(q)`\\n"
                    },
                    {
                        "username": "geometrygaming8",
                        "content": "Made an iterative solution if y'all interested:\n \n        stack = [p, q]\n\n        while stack:\n            q1 = stack.pop()\n            p1 = stack.pop()\n\n            if not p1 and not q1:\n                continue\n            elif not p1 or not q1:\n                return False\n\n            if p1.val != q1.val: return False\n\n            stack.append(p1.left)\n            stack.append(q1.left)\n            stack.append(p1.right)\n            stack.append(q1.right)\n\n        return True"
                    }
                ]
            },
            {
                "id": 2017649,
                "content": [
                    {
                        "username": "jahidulhossainmekat",
                        "content": "```\nPython Solve\n```\n```\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p==None and q==None:\n            return True\n        if p==None or q==None:\n            return False\n        else:\n            return (p.val==q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right))\n```"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "Thank you so much. My idea was very similar to yours but I was just missing one thing. Realised it once I saw your code. Implemented it and my solution worked too. Thanks!!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**don\\'t post codes here..\\nuse solution section for that**"
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Check out solution with explanation\\n[Both 3 line and 1 line solution](https://qr.ae/pNs1d5)"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/059388a8-75ba-470f-8648-54f443700e16_1626241605.4358785.png)\\n"
                    },
                    {
                        "username": "wwww",
                        "content": "got the answer already, i forget something.thanks guys"
                    },
                    {
                        "username": "pavloslav",
                        "content": "In Rust #[derive(PartialEq)] is a bit over top :)"
                    },
                    {
                        "username": "ncn-ends",
                        "content": "Why is there a test case with null p and null q when it doesn\\'t specify anywhere in the description that it can be null, and the types for the parameters are non-null (at least for C#)? I understand it\\'s based on older version of C#, but then it should specify it in the description. \\nFailed the initial submit for no reason."
                    },
                    {
                        "username": "KaikE2345",
                        "content": "Where could I get educated on trees? I\\'m struggling to understand where the method isSameTree() comes from. "
                    },
                    {
                        "username": "hani98",
                        "content": "why in this code I give this error:\\n     AttributeError: \\'NoneType\\' object has no attribute \\'val\\'\\n          p1= [p.val] + preorder(p.left) + preorder(p.right)\\n\\ncode: `class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        p1=[]\\n        q1=[]\\n        def preorder(p):\\n            p1= [p.val] + preorder(p.left) + preorder(p.right)\\n        return preorder(p)==preorder(q)`\\n"
                    },
                    {
                        "username": "geometrygaming8",
                        "content": "Made an iterative solution if y'all interested:\n \n        stack = [p, q]\n\n        while stack:\n            q1 = stack.pop()\n            p1 = stack.pop()\n\n            if not p1 and not q1:\n                continue\n            elif not p1 or not q1:\n                return False\n\n            if p1.val != q1.val: return False\n\n            stack.append(p1.left)\n            stack.append(q1.left)\n            stack.append(p1.right)\n            stack.append(q1.right)\n\n        return True"
                    }
                ]
            },
            {
                "id": 1950698,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "I read the question wrong and was wondering why my code wasn\\'t passing. Wasted 30m, gg"
                    },
                    {
                        "username": "Meabu",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void preOrder(TreeNode p,ArrayList list){\\n        if (p==null) return;\\n        list.add(p.val);\\n        preOrder(p.left,list);\\n        preOrder(p.right,list);\\n    }\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList list_p=new ArrayList<>();\\n        ArrayList list_q=new ArrayList<>(); \\n        preOrder(p,list_p);\\n        preOrder(q,list_q);\\n        return list_p==list_q;        \\n    }\\n}\\n\\nHow did test case 1 wrong !?"
                    },
                    {
                        "username": "abhi_bittu2525",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  void inorder1(TreeNode* p,vector<int>&ans1){\\n      if(p==NULL){\\n         // ans1.push_back(-1);\\n          return ;\\n      }\\n      inorder1(p->left,ans1);\\n      ans1.push_back(p->val);\\n      inorder1(p->right,ans1);\\n  }\\n   void inorder2(TreeNode* q,vector<int>&ans2){\\n      if(q==NULL){\\n        //  ans2.push_back(-1);\\n          return ;\\n      }\\n      inorder1(q->left,ans2);\\n      ans2.push_back(q->val);\\n      inorder1(q->right,ans2);\\n  }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        vector<int>ans1;\\n        vector<int>ans2;\\n        inorder1(p,ans1);\\n        inorder2(q,ans2);\\n        if(ans1.size()!=ans2.size()){\\n            return false;\\n        }\\n        for(int i =0;i<ans1.size();i++){\\n            if(ans1[i]!=ans2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n};\\n\\n\\none case is giving wrong output can anyone help"
                    },
                    {
                        "username": "telomelonia",
                        "content": "As per the code, it seems your assertion is: If the output of inorder traversal(or any DFS) of 2 BST matches then they are same tree.\nBut consider the test case:\nBST 1:\n```\n      2\n    /   \\\n   1    3\n```\nBST 2:\n```\n1\n  \\\n    2\n      \\\n        3\n```\nTheir inorder traversal is same, though they are not same.\nI wonder if output of BFS is also considered along with the DFS, I think it might pass."
                    },
                    {
                        "username": "telomelonia",
                        "content": "I have doubt ... Is it save to say that if output of DFS and BFS of both tree matches then both are same tree?"
                    },
                    {
                        "username": "20bcs2613",
                        "content": "C++ Solution"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anybody have a good reference to why in-order traversal does not work for same tree comparison?"
                    },
                    {
                        "username": "Almazino",
                        "content": "why are the answers in my vscode and on the site different?"
                    },
                    {
                        "username": "TheSuperFastOne",
                        "content": "public class Solution {\n    public bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        isSameForOneNode(firstTree, secondTree)\n    }\n\n    public bool isSameForOneNode(TreeNode node1, TreeNode node2)\n    {\n        bool res = true;\n        if (node1.right == null && node2.right != null)\n        {\n            return false;\n        }\n        if (node1.left == null && node2.left != null)\n        {\n            return false;\n        }\n        if (node2.left == null && node1.left != null)\n        {\n            return false;\n        }\n        if (node2.right == null && node1.right != null)\n        {\n            return false;\n        }\n        if (node1.right != null && node2.right != null)\n        {\n            if (node1.right.val != node2.right.val)\n            {\n                return false;\n            }\n        }\n        if (node1.left != null && node2.left != null)\n        {\n            if (node1.left.val != node2.left.val)\n            {\n                return false;\n            }\n        }\n        if (isSameForOneNode(node1.right, node2.right) != true || isSameForOneNode(node1.left, node2.left) != true)\n        {\n            res = false;\n        }\n        return res;\n    }\n}\nFunction:\npublic bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        return isSameForOneNode(firstTree, secondTree);\n    }\n\n\nError Message:\nUnhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt __Driver__.Main(String[] args)"
                    },
                    {
                        "username": "mitulchadha",
                        "content": "i tried comparing the in-order traversals for both the trees but it only passed 57/60 test cases, can someone tell me why is the code failing, i am new to trees, thanks"
                    },
                    {
                        "username": "ash030",
                        "content": "because for the same inorder traversals the tree structures can be different, for eg [1, 2, 3] and [3, 1, null, 2] they have different structures but inorder is same - [2,1, 3]"
                    },
                    {
                        "username": "Balajisaketh",
                        "content": "below is my code i am getting \\nError:Cannot read properties of null (reading \\'val\\')\\nplz help me \\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n  \\n         \\nfunction check(p ,q)\\n\\n{\\n    let status=true\\n    if(p==null || q==null)\\n    {\\n        status=false\\n    }\\n     if(p.val==q.val)\\n     {\\n         status=true\\n         check(p.left,q.left)\\n         check(p.right,q.right)\\n\\n     }\\n     else\\n     {\\n         status=false\\n     }\\n     return status\\n    \\n}\\nconst data=check(p,q)\\nreturn data\\n   \\n}"
                    }
                ]
            },
            {
                "id": 1920118,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "I read the question wrong and was wondering why my code wasn\\'t passing. Wasted 30m, gg"
                    },
                    {
                        "username": "Meabu",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void preOrder(TreeNode p,ArrayList list){\\n        if (p==null) return;\\n        list.add(p.val);\\n        preOrder(p.left,list);\\n        preOrder(p.right,list);\\n    }\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList list_p=new ArrayList<>();\\n        ArrayList list_q=new ArrayList<>(); \\n        preOrder(p,list_p);\\n        preOrder(q,list_q);\\n        return list_p==list_q;        \\n    }\\n}\\n\\nHow did test case 1 wrong !?"
                    },
                    {
                        "username": "abhi_bittu2525",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  void inorder1(TreeNode* p,vector<int>&ans1){\\n      if(p==NULL){\\n         // ans1.push_back(-1);\\n          return ;\\n      }\\n      inorder1(p->left,ans1);\\n      ans1.push_back(p->val);\\n      inorder1(p->right,ans1);\\n  }\\n   void inorder2(TreeNode* q,vector<int>&ans2){\\n      if(q==NULL){\\n        //  ans2.push_back(-1);\\n          return ;\\n      }\\n      inorder1(q->left,ans2);\\n      ans2.push_back(q->val);\\n      inorder1(q->right,ans2);\\n  }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        vector<int>ans1;\\n        vector<int>ans2;\\n        inorder1(p,ans1);\\n        inorder2(q,ans2);\\n        if(ans1.size()!=ans2.size()){\\n            return false;\\n        }\\n        for(int i =0;i<ans1.size();i++){\\n            if(ans1[i]!=ans2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n};\\n\\n\\none case is giving wrong output can anyone help"
                    },
                    {
                        "username": "telomelonia",
                        "content": "As per the code, it seems your assertion is: If the output of inorder traversal(or any DFS) of 2 BST matches then they are same tree.\nBut consider the test case:\nBST 1:\n```\n      2\n    /   \\\n   1    3\n```\nBST 2:\n```\n1\n  \\\n    2\n      \\\n        3\n```\nTheir inorder traversal is same, though they are not same.\nI wonder if output of BFS is also considered along with the DFS, I think it might pass."
                    },
                    {
                        "username": "telomelonia",
                        "content": "I have doubt ... Is it save to say that if output of DFS and BFS of both tree matches then both are same tree?"
                    },
                    {
                        "username": "20bcs2613",
                        "content": "C++ Solution"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anybody have a good reference to why in-order traversal does not work for same tree comparison?"
                    },
                    {
                        "username": "Almazino",
                        "content": "why are the answers in my vscode and on the site different?"
                    },
                    {
                        "username": "TheSuperFastOne",
                        "content": "public class Solution {\n    public bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        isSameForOneNode(firstTree, secondTree)\n    }\n\n    public bool isSameForOneNode(TreeNode node1, TreeNode node2)\n    {\n        bool res = true;\n        if (node1.right == null && node2.right != null)\n        {\n            return false;\n        }\n        if (node1.left == null && node2.left != null)\n        {\n            return false;\n        }\n        if (node2.left == null && node1.left != null)\n        {\n            return false;\n        }\n        if (node2.right == null && node1.right != null)\n        {\n            return false;\n        }\n        if (node1.right != null && node2.right != null)\n        {\n            if (node1.right.val != node2.right.val)\n            {\n                return false;\n            }\n        }\n        if (node1.left != null && node2.left != null)\n        {\n            if (node1.left.val != node2.left.val)\n            {\n                return false;\n            }\n        }\n        if (isSameForOneNode(node1.right, node2.right) != true || isSameForOneNode(node1.left, node2.left) != true)\n        {\n            res = false;\n        }\n        return res;\n    }\n}\nFunction:\npublic bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        return isSameForOneNode(firstTree, secondTree);\n    }\n\n\nError Message:\nUnhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt __Driver__.Main(String[] args)"
                    },
                    {
                        "username": "mitulchadha",
                        "content": "i tried comparing the in-order traversals for both the trees but it only passed 57/60 test cases, can someone tell me why is the code failing, i am new to trees, thanks"
                    },
                    {
                        "username": "ash030",
                        "content": "because for the same inorder traversals the tree structures can be different, for eg [1, 2, 3] and [3, 1, null, 2] they have different structures but inorder is same - [2,1, 3]"
                    },
                    {
                        "username": "Balajisaketh",
                        "content": "below is my code i am getting \\nError:Cannot read properties of null (reading \\'val\\')\\nplz help me \\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n  \\n         \\nfunction check(p ,q)\\n\\n{\\n    let status=true\\n    if(p==null || q==null)\\n    {\\n        status=false\\n    }\\n     if(p.val==q.val)\\n     {\\n         status=true\\n         check(p.left,q.left)\\n         check(p.right,q.right)\\n\\n     }\\n     else\\n     {\\n         status=false\\n     }\\n     return status\\n    \\n}\\nconst data=check(p,q)\\nreturn data\\n   \\n}"
                    }
                ]
            },
            {
                "id": 1914194,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "I read the question wrong and was wondering why my code wasn\\'t passing. Wasted 30m, gg"
                    },
                    {
                        "username": "Meabu",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void preOrder(TreeNode p,ArrayList list){\\n        if (p==null) return;\\n        list.add(p.val);\\n        preOrder(p.left,list);\\n        preOrder(p.right,list);\\n    }\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList list_p=new ArrayList<>();\\n        ArrayList list_q=new ArrayList<>(); \\n        preOrder(p,list_p);\\n        preOrder(q,list_q);\\n        return list_p==list_q;        \\n    }\\n}\\n\\nHow did test case 1 wrong !?"
                    },
                    {
                        "username": "abhi_bittu2525",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  void inorder1(TreeNode* p,vector<int>&ans1){\\n      if(p==NULL){\\n         // ans1.push_back(-1);\\n          return ;\\n      }\\n      inorder1(p->left,ans1);\\n      ans1.push_back(p->val);\\n      inorder1(p->right,ans1);\\n  }\\n   void inorder2(TreeNode* q,vector<int>&ans2){\\n      if(q==NULL){\\n        //  ans2.push_back(-1);\\n          return ;\\n      }\\n      inorder1(q->left,ans2);\\n      ans2.push_back(q->val);\\n      inorder1(q->right,ans2);\\n  }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        vector<int>ans1;\\n        vector<int>ans2;\\n        inorder1(p,ans1);\\n        inorder2(q,ans2);\\n        if(ans1.size()!=ans2.size()){\\n            return false;\\n        }\\n        for(int i =0;i<ans1.size();i++){\\n            if(ans1[i]!=ans2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n};\\n\\n\\none case is giving wrong output can anyone help"
                    },
                    {
                        "username": "telomelonia",
                        "content": "As per the code, it seems your assertion is: If the output of inorder traversal(or any DFS) of 2 BST matches then they are same tree.\nBut consider the test case:\nBST 1:\n```\n      2\n    /   \\\n   1    3\n```\nBST 2:\n```\n1\n  \\\n    2\n      \\\n        3\n```\nTheir inorder traversal is same, though they are not same.\nI wonder if output of BFS is also considered along with the DFS, I think it might pass."
                    },
                    {
                        "username": "telomelonia",
                        "content": "I have doubt ... Is it save to say that if output of DFS and BFS of both tree matches then both are same tree?"
                    },
                    {
                        "username": "20bcs2613",
                        "content": "C++ Solution"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anybody have a good reference to why in-order traversal does not work for same tree comparison?"
                    },
                    {
                        "username": "Almazino",
                        "content": "why are the answers in my vscode and on the site different?"
                    },
                    {
                        "username": "TheSuperFastOne",
                        "content": "public class Solution {\n    public bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        isSameForOneNode(firstTree, secondTree)\n    }\n\n    public bool isSameForOneNode(TreeNode node1, TreeNode node2)\n    {\n        bool res = true;\n        if (node1.right == null && node2.right != null)\n        {\n            return false;\n        }\n        if (node1.left == null && node2.left != null)\n        {\n            return false;\n        }\n        if (node2.left == null && node1.left != null)\n        {\n            return false;\n        }\n        if (node2.right == null && node1.right != null)\n        {\n            return false;\n        }\n        if (node1.right != null && node2.right != null)\n        {\n            if (node1.right.val != node2.right.val)\n            {\n                return false;\n            }\n        }\n        if (node1.left != null && node2.left != null)\n        {\n            if (node1.left.val != node2.left.val)\n            {\n                return false;\n            }\n        }\n        if (isSameForOneNode(node1.right, node2.right) != true || isSameForOneNode(node1.left, node2.left) != true)\n        {\n            res = false;\n        }\n        return res;\n    }\n}\nFunction:\npublic bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        return isSameForOneNode(firstTree, secondTree);\n    }\n\n\nError Message:\nUnhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt __Driver__.Main(String[] args)"
                    },
                    {
                        "username": "mitulchadha",
                        "content": "i tried comparing the in-order traversals for both the trees but it only passed 57/60 test cases, can someone tell me why is the code failing, i am new to trees, thanks"
                    },
                    {
                        "username": "ash030",
                        "content": "because for the same inorder traversals the tree structures can be different, for eg [1, 2, 3] and [3, 1, null, 2] they have different structures but inorder is same - [2,1, 3]"
                    },
                    {
                        "username": "Balajisaketh",
                        "content": "below is my code i am getting \\nError:Cannot read properties of null (reading \\'val\\')\\nplz help me \\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n  \\n         \\nfunction check(p ,q)\\n\\n{\\n    let status=true\\n    if(p==null || q==null)\\n    {\\n        status=false\\n    }\\n     if(p.val==q.val)\\n     {\\n         status=true\\n         check(p.left,q.left)\\n         check(p.right,q.right)\\n\\n     }\\n     else\\n     {\\n         status=false\\n     }\\n     return status\\n    \\n}\\nconst data=check(p,q)\\nreturn data\\n   \\n}"
                    }
                ]
            },
            {
                "id": 1911901,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "I read the question wrong and was wondering why my code wasn\\'t passing. Wasted 30m, gg"
                    },
                    {
                        "username": "Meabu",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void preOrder(TreeNode p,ArrayList list){\\n        if (p==null) return;\\n        list.add(p.val);\\n        preOrder(p.left,list);\\n        preOrder(p.right,list);\\n    }\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList list_p=new ArrayList<>();\\n        ArrayList list_q=new ArrayList<>(); \\n        preOrder(p,list_p);\\n        preOrder(q,list_q);\\n        return list_p==list_q;        \\n    }\\n}\\n\\nHow did test case 1 wrong !?"
                    },
                    {
                        "username": "abhi_bittu2525",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  void inorder1(TreeNode* p,vector<int>&ans1){\\n      if(p==NULL){\\n         // ans1.push_back(-1);\\n          return ;\\n      }\\n      inorder1(p->left,ans1);\\n      ans1.push_back(p->val);\\n      inorder1(p->right,ans1);\\n  }\\n   void inorder2(TreeNode* q,vector<int>&ans2){\\n      if(q==NULL){\\n        //  ans2.push_back(-1);\\n          return ;\\n      }\\n      inorder1(q->left,ans2);\\n      ans2.push_back(q->val);\\n      inorder1(q->right,ans2);\\n  }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        vector<int>ans1;\\n        vector<int>ans2;\\n        inorder1(p,ans1);\\n        inorder2(q,ans2);\\n        if(ans1.size()!=ans2.size()){\\n            return false;\\n        }\\n        for(int i =0;i<ans1.size();i++){\\n            if(ans1[i]!=ans2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n};\\n\\n\\none case is giving wrong output can anyone help"
                    },
                    {
                        "username": "telomelonia",
                        "content": "As per the code, it seems your assertion is: If the output of inorder traversal(or any DFS) of 2 BST matches then they are same tree.\nBut consider the test case:\nBST 1:\n```\n      2\n    /   \\\n   1    3\n```\nBST 2:\n```\n1\n  \\\n    2\n      \\\n        3\n```\nTheir inorder traversal is same, though they are not same.\nI wonder if output of BFS is also considered along with the DFS, I think it might pass."
                    },
                    {
                        "username": "telomelonia",
                        "content": "I have doubt ... Is it save to say that if output of DFS and BFS of both tree matches then both are same tree?"
                    },
                    {
                        "username": "20bcs2613",
                        "content": "C++ Solution"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anybody have a good reference to why in-order traversal does not work for same tree comparison?"
                    },
                    {
                        "username": "Almazino",
                        "content": "why are the answers in my vscode and on the site different?"
                    },
                    {
                        "username": "TheSuperFastOne",
                        "content": "public class Solution {\n    public bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        isSameForOneNode(firstTree, secondTree)\n    }\n\n    public bool isSameForOneNode(TreeNode node1, TreeNode node2)\n    {\n        bool res = true;\n        if (node1.right == null && node2.right != null)\n        {\n            return false;\n        }\n        if (node1.left == null && node2.left != null)\n        {\n            return false;\n        }\n        if (node2.left == null && node1.left != null)\n        {\n            return false;\n        }\n        if (node2.right == null && node1.right != null)\n        {\n            return false;\n        }\n        if (node1.right != null && node2.right != null)\n        {\n            if (node1.right.val != node2.right.val)\n            {\n                return false;\n            }\n        }\n        if (node1.left != null && node2.left != null)\n        {\n            if (node1.left.val != node2.left.val)\n            {\n                return false;\n            }\n        }\n        if (isSameForOneNode(node1.right, node2.right) != true || isSameForOneNode(node1.left, node2.left) != true)\n        {\n            res = false;\n        }\n        return res;\n    }\n}\nFunction:\npublic bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        return isSameForOneNode(firstTree, secondTree);\n    }\n\n\nError Message:\nUnhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt __Driver__.Main(String[] args)"
                    },
                    {
                        "username": "mitulchadha",
                        "content": "i tried comparing the in-order traversals for both the trees but it only passed 57/60 test cases, can someone tell me why is the code failing, i am new to trees, thanks"
                    },
                    {
                        "username": "ash030",
                        "content": "because for the same inorder traversals the tree structures can be different, for eg [1, 2, 3] and [3, 1, null, 2] they have different structures but inorder is same - [2,1, 3]"
                    },
                    {
                        "username": "Balajisaketh",
                        "content": "below is my code i am getting \\nError:Cannot read properties of null (reading \\'val\\')\\nplz help me \\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n  \\n         \\nfunction check(p ,q)\\n\\n{\\n    let status=true\\n    if(p==null || q==null)\\n    {\\n        status=false\\n    }\\n     if(p.val==q.val)\\n     {\\n         status=true\\n         check(p.left,q.left)\\n         check(p.right,q.right)\\n\\n     }\\n     else\\n     {\\n         status=false\\n     }\\n     return status\\n    \\n}\\nconst data=check(p,q)\\nreturn data\\n   \\n}"
                    }
                ]
            },
            {
                "id": 1888531,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "I read the question wrong and was wondering why my code wasn\\'t passing. Wasted 30m, gg"
                    },
                    {
                        "username": "Meabu",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void preOrder(TreeNode p,ArrayList list){\\n        if (p==null) return;\\n        list.add(p.val);\\n        preOrder(p.left,list);\\n        preOrder(p.right,list);\\n    }\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList list_p=new ArrayList<>();\\n        ArrayList list_q=new ArrayList<>(); \\n        preOrder(p,list_p);\\n        preOrder(q,list_q);\\n        return list_p==list_q;        \\n    }\\n}\\n\\nHow did test case 1 wrong !?"
                    },
                    {
                        "username": "abhi_bittu2525",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  void inorder1(TreeNode* p,vector<int>&ans1){\\n      if(p==NULL){\\n         // ans1.push_back(-1);\\n          return ;\\n      }\\n      inorder1(p->left,ans1);\\n      ans1.push_back(p->val);\\n      inorder1(p->right,ans1);\\n  }\\n   void inorder2(TreeNode* q,vector<int>&ans2){\\n      if(q==NULL){\\n        //  ans2.push_back(-1);\\n          return ;\\n      }\\n      inorder1(q->left,ans2);\\n      ans2.push_back(q->val);\\n      inorder1(q->right,ans2);\\n  }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        vector<int>ans1;\\n        vector<int>ans2;\\n        inorder1(p,ans1);\\n        inorder2(q,ans2);\\n        if(ans1.size()!=ans2.size()){\\n            return false;\\n        }\\n        for(int i =0;i<ans1.size();i++){\\n            if(ans1[i]!=ans2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n};\\n\\n\\none case is giving wrong output can anyone help"
                    },
                    {
                        "username": "telomelonia",
                        "content": "As per the code, it seems your assertion is: If the output of inorder traversal(or any DFS) of 2 BST matches then they are same tree.\nBut consider the test case:\nBST 1:\n```\n      2\n    /   \\\n   1    3\n```\nBST 2:\n```\n1\n  \\\n    2\n      \\\n        3\n```\nTheir inorder traversal is same, though they are not same.\nI wonder if output of BFS is also considered along with the DFS, I think it might pass."
                    },
                    {
                        "username": "telomelonia",
                        "content": "I have doubt ... Is it save to say that if output of DFS and BFS of both tree matches then both are same tree?"
                    },
                    {
                        "username": "20bcs2613",
                        "content": "C++ Solution"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anybody have a good reference to why in-order traversal does not work for same tree comparison?"
                    },
                    {
                        "username": "Almazino",
                        "content": "why are the answers in my vscode and on the site different?"
                    },
                    {
                        "username": "TheSuperFastOne",
                        "content": "public class Solution {\n    public bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        isSameForOneNode(firstTree, secondTree)\n    }\n\n    public bool isSameForOneNode(TreeNode node1, TreeNode node2)\n    {\n        bool res = true;\n        if (node1.right == null && node2.right != null)\n        {\n            return false;\n        }\n        if (node1.left == null && node2.left != null)\n        {\n            return false;\n        }\n        if (node2.left == null && node1.left != null)\n        {\n            return false;\n        }\n        if (node2.right == null && node1.right != null)\n        {\n            return false;\n        }\n        if (node1.right != null && node2.right != null)\n        {\n            if (node1.right.val != node2.right.val)\n            {\n                return false;\n            }\n        }\n        if (node1.left != null && node2.left != null)\n        {\n            if (node1.left.val != node2.left.val)\n            {\n                return false;\n            }\n        }\n        if (isSameForOneNode(node1.right, node2.right) != true || isSameForOneNode(node1.left, node2.left) != true)\n        {\n            res = false;\n        }\n        return res;\n    }\n}\nFunction:\npublic bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        return isSameForOneNode(firstTree, secondTree);\n    }\n\n\nError Message:\nUnhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt __Driver__.Main(String[] args)"
                    },
                    {
                        "username": "mitulchadha",
                        "content": "i tried comparing the in-order traversals for both the trees but it only passed 57/60 test cases, can someone tell me why is the code failing, i am new to trees, thanks"
                    },
                    {
                        "username": "ash030",
                        "content": "because for the same inorder traversals the tree structures can be different, for eg [1, 2, 3] and [3, 1, null, 2] they have different structures but inorder is same - [2,1, 3]"
                    },
                    {
                        "username": "Balajisaketh",
                        "content": "below is my code i am getting \\nError:Cannot read properties of null (reading \\'val\\')\\nplz help me \\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n  \\n         \\nfunction check(p ,q)\\n\\n{\\n    let status=true\\n    if(p==null || q==null)\\n    {\\n        status=false\\n    }\\n     if(p.val==q.val)\\n     {\\n         status=true\\n         check(p.left,q.left)\\n         check(p.right,q.right)\\n\\n     }\\n     else\\n     {\\n         status=false\\n     }\\n     return status\\n    \\n}\\nconst data=check(p,q)\\nreturn data\\n   \\n}"
                    }
                ]
            },
            {
                "id": 1873892,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "I read the question wrong and was wondering why my code wasn\\'t passing. Wasted 30m, gg"
                    },
                    {
                        "username": "Meabu",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void preOrder(TreeNode p,ArrayList list){\\n        if (p==null) return;\\n        list.add(p.val);\\n        preOrder(p.left,list);\\n        preOrder(p.right,list);\\n    }\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList list_p=new ArrayList<>();\\n        ArrayList list_q=new ArrayList<>(); \\n        preOrder(p,list_p);\\n        preOrder(q,list_q);\\n        return list_p==list_q;        \\n    }\\n}\\n\\nHow did test case 1 wrong !?"
                    },
                    {
                        "username": "abhi_bittu2525",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  void inorder1(TreeNode* p,vector<int>&ans1){\\n      if(p==NULL){\\n         // ans1.push_back(-1);\\n          return ;\\n      }\\n      inorder1(p->left,ans1);\\n      ans1.push_back(p->val);\\n      inorder1(p->right,ans1);\\n  }\\n   void inorder2(TreeNode* q,vector<int>&ans2){\\n      if(q==NULL){\\n        //  ans2.push_back(-1);\\n          return ;\\n      }\\n      inorder1(q->left,ans2);\\n      ans2.push_back(q->val);\\n      inorder1(q->right,ans2);\\n  }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        vector<int>ans1;\\n        vector<int>ans2;\\n        inorder1(p,ans1);\\n        inorder2(q,ans2);\\n        if(ans1.size()!=ans2.size()){\\n            return false;\\n        }\\n        for(int i =0;i<ans1.size();i++){\\n            if(ans1[i]!=ans2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n};\\n\\n\\none case is giving wrong output can anyone help"
                    },
                    {
                        "username": "telomelonia",
                        "content": "As per the code, it seems your assertion is: If the output of inorder traversal(or any DFS) of 2 BST matches then they are same tree.\nBut consider the test case:\nBST 1:\n```\n      2\n    /   \\\n   1    3\n```\nBST 2:\n```\n1\n  \\\n    2\n      \\\n        3\n```\nTheir inorder traversal is same, though they are not same.\nI wonder if output of BFS is also considered along with the DFS, I think it might pass."
                    },
                    {
                        "username": "telomelonia",
                        "content": "I have doubt ... Is it save to say that if output of DFS and BFS of both tree matches then both are same tree?"
                    },
                    {
                        "username": "20bcs2613",
                        "content": "C++ Solution"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anybody have a good reference to why in-order traversal does not work for same tree comparison?"
                    },
                    {
                        "username": "Almazino",
                        "content": "why are the answers in my vscode and on the site different?"
                    },
                    {
                        "username": "TheSuperFastOne",
                        "content": "public class Solution {\n    public bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        isSameForOneNode(firstTree, secondTree)\n    }\n\n    public bool isSameForOneNode(TreeNode node1, TreeNode node2)\n    {\n        bool res = true;\n        if (node1.right == null && node2.right != null)\n        {\n            return false;\n        }\n        if (node1.left == null && node2.left != null)\n        {\n            return false;\n        }\n        if (node2.left == null && node1.left != null)\n        {\n            return false;\n        }\n        if (node2.right == null && node1.right != null)\n        {\n            return false;\n        }\n        if (node1.right != null && node2.right != null)\n        {\n            if (node1.right.val != node2.right.val)\n            {\n                return false;\n            }\n        }\n        if (node1.left != null && node2.left != null)\n        {\n            if (node1.left.val != node2.left.val)\n            {\n                return false;\n            }\n        }\n        if (isSameForOneNode(node1.right, node2.right) != true || isSameForOneNode(node1.left, node2.left) != true)\n        {\n            res = false;\n        }\n        return res;\n    }\n}\nFunction:\npublic bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        return isSameForOneNode(firstTree, secondTree);\n    }\n\n\nError Message:\nUnhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt __Driver__.Main(String[] args)"
                    },
                    {
                        "username": "mitulchadha",
                        "content": "i tried comparing the in-order traversals for both the trees but it only passed 57/60 test cases, can someone tell me why is the code failing, i am new to trees, thanks"
                    },
                    {
                        "username": "ash030",
                        "content": "because for the same inorder traversals the tree structures can be different, for eg [1, 2, 3] and [3, 1, null, 2] they have different structures but inorder is same - [2,1, 3]"
                    },
                    {
                        "username": "Balajisaketh",
                        "content": "below is my code i am getting \\nError:Cannot read properties of null (reading \\'val\\')\\nplz help me \\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n  \\n         \\nfunction check(p ,q)\\n\\n{\\n    let status=true\\n    if(p==null || q==null)\\n    {\\n        status=false\\n    }\\n     if(p.val==q.val)\\n     {\\n         status=true\\n         check(p.left,q.left)\\n         check(p.right,q.right)\\n\\n     }\\n     else\\n     {\\n         status=false\\n     }\\n     return status\\n    \\n}\\nconst data=check(p,q)\\nreturn data\\n   \\n}"
                    }
                ]
            },
            {
                "id": 1833960,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "I read the question wrong and was wondering why my code wasn\\'t passing. Wasted 30m, gg"
                    },
                    {
                        "username": "Meabu",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void preOrder(TreeNode p,ArrayList list){\\n        if (p==null) return;\\n        list.add(p.val);\\n        preOrder(p.left,list);\\n        preOrder(p.right,list);\\n    }\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList list_p=new ArrayList<>();\\n        ArrayList list_q=new ArrayList<>(); \\n        preOrder(p,list_p);\\n        preOrder(q,list_q);\\n        return list_p==list_q;        \\n    }\\n}\\n\\nHow did test case 1 wrong !?"
                    },
                    {
                        "username": "abhi_bittu2525",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  void inorder1(TreeNode* p,vector<int>&ans1){\\n      if(p==NULL){\\n         // ans1.push_back(-1);\\n          return ;\\n      }\\n      inorder1(p->left,ans1);\\n      ans1.push_back(p->val);\\n      inorder1(p->right,ans1);\\n  }\\n   void inorder2(TreeNode* q,vector<int>&ans2){\\n      if(q==NULL){\\n        //  ans2.push_back(-1);\\n          return ;\\n      }\\n      inorder1(q->left,ans2);\\n      ans2.push_back(q->val);\\n      inorder1(q->right,ans2);\\n  }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        vector<int>ans1;\\n        vector<int>ans2;\\n        inorder1(p,ans1);\\n        inorder2(q,ans2);\\n        if(ans1.size()!=ans2.size()){\\n            return false;\\n        }\\n        for(int i =0;i<ans1.size();i++){\\n            if(ans1[i]!=ans2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n};\\n\\n\\none case is giving wrong output can anyone help"
                    },
                    {
                        "username": "telomelonia",
                        "content": "As per the code, it seems your assertion is: If the output of inorder traversal(or any DFS) of 2 BST matches then they are same tree.\nBut consider the test case:\nBST 1:\n```\n      2\n    /   \\\n   1    3\n```\nBST 2:\n```\n1\n  \\\n    2\n      \\\n        3\n```\nTheir inorder traversal is same, though they are not same.\nI wonder if output of BFS is also considered along with the DFS, I think it might pass."
                    },
                    {
                        "username": "telomelonia",
                        "content": "I have doubt ... Is it save to say that if output of DFS and BFS of both tree matches then both are same tree?"
                    },
                    {
                        "username": "20bcs2613",
                        "content": "C++ Solution"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anybody have a good reference to why in-order traversal does not work for same tree comparison?"
                    },
                    {
                        "username": "Almazino",
                        "content": "why are the answers in my vscode and on the site different?"
                    },
                    {
                        "username": "TheSuperFastOne",
                        "content": "public class Solution {\n    public bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        isSameForOneNode(firstTree, secondTree)\n    }\n\n    public bool isSameForOneNode(TreeNode node1, TreeNode node2)\n    {\n        bool res = true;\n        if (node1.right == null && node2.right != null)\n        {\n            return false;\n        }\n        if (node1.left == null && node2.left != null)\n        {\n            return false;\n        }\n        if (node2.left == null && node1.left != null)\n        {\n            return false;\n        }\n        if (node2.right == null && node1.right != null)\n        {\n            return false;\n        }\n        if (node1.right != null && node2.right != null)\n        {\n            if (node1.right.val != node2.right.val)\n            {\n                return false;\n            }\n        }\n        if (node1.left != null && node2.left != null)\n        {\n            if (node1.left.val != node2.left.val)\n            {\n                return false;\n            }\n        }\n        if (isSameForOneNode(node1.right, node2.right) != true || isSameForOneNode(node1.left, node2.left) != true)\n        {\n            res = false;\n        }\n        return res;\n    }\n}\nFunction:\npublic bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        return isSameForOneNode(firstTree, secondTree);\n    }\n\n\nError Message:\nUnhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt __Driver__.Main(String[] args)"
                    },
                    {
                        "username": "mitulchadha",
                        "content": "i tried comparing the in-order traversals for both the trees but it only passed 57/60 test cases, can someone tell me why is the code failing, i am new to trees, thanks"
                    },
                    {
                        "username": "ash030",
                        "content": "because for the same inorder traversals the tree structures can be different, for eg [1, 2, 3] and [3, 1, null, 2] they have different structures but inorder is same - [2,1, 3]"
                    },
                    {
                        "username": "Balajisaketh",
                        "content": "below is my code i am getting \\nError:Cannot read properties of null (reading \\'val\\')\\nplz help me \\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n  \\n         \\nfunction check(p ,q)\\n\\n{\\n    let status=true\\n    if(p==null || q==null)\\n    {\\n        status=false\\n    }\\n     if(p.val==q.val)\\n     {\\n         status=true\\n         check(p.left,q.left)\\n         check(p.right,q.right)\\n\\n     }\\n     else\\n     {\\n         status=false\\n     }\\n     return status\\n    \\n}\\nconst data=check(p,q)\\nreturn data\\n   \\n}"
                    }
                ]
            },
            {
                "id": 1801300,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "I read the question wrong and was wondering why my code wasn\\'t passing. Wasted 30m, gg"
                    },
                    {
                        "username": "Meabu",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void preOrder(TreeNode p,ArrayList list){\\n        if (p==null) return;\\n        list.add(p.val);\\n        preOrder(p.left,list);\\n        preOrder(p.right,list);\\n    }\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList list_p=new ArrayList<>();\\n        ArrayList list_q=new ArrayList<>(); \\n        preOrder(p,list_p);\\n        preOrder(q,list_q);\\n        return list_p==list_q;        \\n    }\\n}\\n\\nHow did test case 1 wrong !?"
                    },
                    {
                        "username": "abhi_bittu2525",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  void inorder1(TreeNode* p,vector<int>&ans1){\\n      if(p==NULL){\\n         // ans1.push_back(-1);\\n          return ;\\n      }\\n      inorder1(p->left,ans1);\\n      ans1.push_back(p->val);\\n      inorder1(p->right,ans1);\\n  }\\n   void inorder2(TreeNode* q,vector<int>&ans2){\\n      if(q==NULL){\\n        //  ans2.push_back(-1);\\n          return ;\\n      }\\n      inorder1(q->left,ans2);\\n      ans2.push_back(q->val);\\n      inorder1(q->right,ans2);\\n  }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        vector<int>ans1;\\n        vector<int>ans2;\\n        inorder1(p,ans1);\\n        inorder2(q,ans2);\\n        if(ans1.size()!=ans2.size()){\\n            return false;\\n        }\\n        for(int i =0;i<ans1.size();i++){\\n            if(ans1[i]!=ans2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n};\\n\\n\\none case is giving wrong output can anyone help"
                    },
                    {
                        "username": "telomelonia",
                        "content": "As per the code, it seems your assertion is: If the output of inorder traversal(or any DFS) of 2 BST matches then they are same tree.\nBut consider the test case:\nBST 1:\n```\n      2\n    /   \\\n   1    3\n```\nBST 2:\n```\n1\n  \\\n    2\n      \\\n        3\n```\nTheir inorder traversal is same, though they are not same.\nI wonder if output of BFS is also considered along with the DFS, I think it might pass."
                    },
                    {
                        "username": "telomelonia",
                        "content": "I have doubt ... Is it save to say that if output of DFS and BFS of both tree matches then both are same tree?"
                    },
                    {
                        "username": "20bcs2613",
                        "content": "C++ Solution"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anybody have a good reference to why in-order traversal does not work for same tree comparison?"
                    },
                    {
                        "username": "Almazino",
                        "content": "why are the answers in my vscode and on the site different?"
                    },
                    {
                        "username": "TheSuperFastOne",
                        "content": "public class Solution {\n    public bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        isSameForOneNode(firstTree, secondTree)\n    }\n\n    public bool isSameForOneNode(TreeNode node1, TreeNode node2)\n    {\n        bool res = true;\n        if (node1.right == null && node2.right != null)\n        {\n            return false;\n        }\n        if (node1.left == null && node2.left != null)\n        {\n            return false;\n        }\n        if (node2.left == null && node1.left != null)\n        {\n            return false;\n        }\n        if (node2.right == null && node1.right != null)\n        {\n            return false;\n        }\n        if (node1.right != null && node2.right != null)\n        {\n            if (node1.right.val != node2.right.val)\n            {\n                return false;\n            }\n        }\n        if (node1.left != null && node2.left != null)\n        {\n            if (node1.left.val != node2.left.val)\n            {\n                return false;\n            }\n        }\n        if (isSameForOneNode(node1.right, node2.right) != true || isSameForOneNode(node1.left, node2.left) != true)\n        {\n            res = false;\n        }\n        return res;\n    }\n}\nFunction:\npublic bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        return isSameForOneNode(firstTree, secondTree);\n    }\n\n\nError Message:\nUnhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt __Driver__.Main(String[] args)"
                    },
                    {
                        "username": "mitulchadha",
                        "content": "i tried comparing the in-order traversals for both the trees but it only passed 57/60 test cases, can someone tell me why is the code failing, i am new to trees, thanks"
                    },
                    {
                        "username": "ash030",
                        "content": "because for the same inorder traversals the tree structures can be different, for eg [1, 2, 3] and [3, 1, null, 2] they have different structures but inorder is same - [2,1, 3]"
                    },
                    {
                        "username": "Balajisaketh",
                        "content": "below is my code i am getting \\nError:Cannot read properties of null (reading \\'val\\')\\nplz help me \\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n  \\n         \\nfunction check(p ,q)\\n\\n{\\n    let status=true\\n    if(p==null || q==null)\\n    {\\n        status=false\\n    }\\n     if(p.val==q.val)\\n     {\\n         status=true\\n         check(p.left,q.left)\\n         check(p.right,q.right)\\n\\n     }\\n     else\\n     {\\n         status=false\\n     }\\n     return status\\n    \\n}\\nconst data=check(p,q)\\nreturn data\\n   \\n}"
                    }
                ]
            },
            {
                "id": 1793045,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "I read the question wrong and was wondering why my code wasn\\'t passing. Wasted 30m, gg"
                    },
                    {
                        "username": "Meabu",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void preOrder(TreeNode p,ArrayList list){\\n        if (p==null) return;\\n        list.add(p.val);\\n        preOrder(p.left,list);\\n        preOrder(p.right,list);\\n    }\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList list_p=new ArrayList<>();\\n        ArrayList list_q=new ArrayList<>(); \\n        preOrder(p,list_p);\\n        preOrder(q,list_q);\\n        return list_p==list_q;        \\n    }\\n}\\n\\nHow did test case 1 wrong !?"
                    },
                    {
                        "username": "abhi_bittu2525",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  void inorder1(TreeNode* p,vector<int>&ans1){\\n      if(p==NULL){\\n         // ans1.push_back(-1);\\n          return ;\\n      }\\n      inorder1(p->left,ans1);\\n      ans1.push_back(p->val);\\n      inorder1(p->right,ans1);\\n  }\\n   void inorder2(TreeNode* q,vector<int>&ans2){\\n      if(q==NULL){\\n        //  ans2.push_back(-1);\\n          return ;\\n      }\\n      inorder1(q->left,ans2);\\n      ans2.push_back(q->val);\\n      inorder1(q->right,ans2);\\n  }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        vector<int>ans1;\\n        vector<int>ans2;\\n        inorder1(p,ans1);\\n        inorder2(q,ans2);\\n        if(ans1.size()!=ans2.size()){\\n            return false;\\n        }\\n        for(int i =0;i<ans1.size();i++){\\n            if(ans1[i]!=ans2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n};\\n\\n\\none case is giving wrong output can anyone help"
                    },
                    {
                        "username": "telomelonia",
                        "content": "As per the code, it seems your assertion is: If the output of inorder traversal(or any DFS) of 2 BST matches then they are same tree.\nBut consider the test case:\nBST 1:\n```\n      2\n    /   \\\n   1    3\n```\nBST 2:\n```\n1\n  \\\n    2\n      \\\n        3\n```\nTheir inorder traversal is same, though they are not same.\nI wonder if output of BFS is also considered along with the DFS, I think it might pass."
                    },
                    {
                        "username": "telomelonia",
                        "content": "I have doubt ... Is it save to say that if output of DFS and BFS of both tree matches then both are same tree?"
                    },
                    {
                        "username": "20bcs2613",
                        "content": "C++ Solution"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anybody have a good reference to why in-order traversal does not work for same tree comparison?"
                    },
                    {
                        "username": "Almazino",
                        "content": "why are the answers in my vscode and on the site different?"
                    },
                    {
                        "username": "TheSuperFastOne",
                        "content": "public class Solution {\n    public bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        isSameForOneNode(firstTree, secondTree)\n    }\n\n    public bool isSameForOneNode(TreeNode node1, TreeNode node2)\n    {\n        bool res = true;\n        if (node1.right == null && node2.right != null)\n        {\n            return false;\n        }\n        if (node1.left == null && node2.left != null)\n        {\n            return false;\n        }\n        if (node2.left == null && node1.left != null)\n        {\n            return false;\n        }\n        if (node2.right == null && node1.right != null)\n        {\n            return false;\n        }\n        if (node1.right != null && node2.right != null)\n        {\n            if (node1.right.val != node2.right.val)\n            {\n                return false;\n            }\n        }\n        if (node1.left != null && node2.left != null)\n        {\n            if (node1.left.val != node2.left.val)\n            {\n                return false;\n            }\n        }\n        if (isSameForOneNode(node1.right, node2.right) != true || isSameForOneNode(node1.left, node2.left) != true)\n        {\n            res = false;\n        }\n        return res;\n    }\n}\nFunction:\npublic bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        return isSameForOneNode(firstTree, secondTree);\n    }\n\n\nError Message:\nUnhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt __Driver__.Main(String[] args)"
                    },
                    {
                        "username": "mitulchadha",
                        "content": "i tried comparing the in-order traversals for both the trees but it only passed 57/60 test cases, can someone tell me why is the code failing, i am new to trees, thanks"
                    },
                    {
                        "username": "ash030",
                        "content": "because for the same inorder traversals the tree structures can be different, for eg [1, 2, 3] and [3, 1, null, 2] they have different structures but inorder is same - [2,1, 3]"
                    },
                    {
                        "username": "Balajisaketh",
                        "content": "below is my code i am getting \\nError:Cannot read properties of null (reading \\'val\\')\\nplz help me \\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n  \\n         \\nfunction check(p ,q)\\n\\n{\\n    let status=true\\n    if(p==null || q==null)\\n    {\\n        status=false\\n    }\\n     if(p.val==q.val)\\n     {\\n         status=true\\n         check(p.left,q.left)\\n         check(p.right,q.right)\\n\\n     }\\n     else\\n     {\\n         status=false\\n     }\\n     return status\\n    \\n}\\nconst data=check(p,q)\\nreturn data\\n   \\n}"
                    }
                ]
            },
            {
                "id": 1783411,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "I read the question wrong and was wondering why my code wasn\\'t passing. Wasted 30m, gg"
                    },
                    {
                        "username": "Meabu",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void preOrder(TreeNode p,ArrayList list){\\n        if (p==null) return;\\n        list.add(p.val);\\n        preOrder(p.left,list);\\n        preOrder(p.right,list);\\n    }\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList list_p=new ArrayList<>();\\n        ArrayList list_q=new ArrayList<>(); \\n        preOrder(p,list_p);\\n        preOrder(q,list_q);\\n        return list_p==list_q;        \\n    }\\n}\\n\\nHow did test case 1 wrong !?"
                    },
                    {
                        "username": "abhi_bittu2525",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  void inorder1(TreeNode* p,vector<int>&ans1){\\n      if(p==NULL){\\n         // ans1.push_back(-1);\\n          return ;\\n      }\\n      inorder1(p->left,ans1);\\n      ans1.push_back(p->val);\\n      inorder1(p->right,ans1);\\n  }\\n   void inorder2(TreeNode* q,vector<int>&ans2){\\n      if(q==NULL){\\n        //  ans2.push_back(-1);\\n          return ;\\n      }\\n      inorder1(q->left,ans2);\\n      ans2.push_back(q->val);\\n      inorder1(q->right,ans2);\\n  }\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        vector<int>ans1;\\n        vector<int>ans2;\\n        inorder1(p,ans1);\\n        inorder2(q,ans2);\\n        if(ans1.size()!=ans2.size()){\\n            return false;\\n        }\\n        for(int i =0;i<ans1.size();i++){\\n            if(ans1[i]!=ans2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n};\\n\\n\\none case is giving wrong output can anyone help"
                    },
                    {
                        "username": "telomelonia",
                        "content": "As per the code, it seems your assertion is: If the output of inorder traversal(or any DFS) of 2 BST matches then they are same tree.\nBut consider the test case:\nBST 1:\n```\n      2\n    /   \\\n   1    3\n```\nBST 2:\n```\n1\n  \\\n    2\n      \\\n        3\n```\nTheir inorder traversal is same, though they are not same.\nI wonder if output of BFS is also considered along with the DFS, I think it might pass."
                    },
                    {
                        "username": "telomelonia",
                        "content": "I have doubt ... Is it save to say that if output of DFS and BFS of both tree matches then both are same tree?"
                    },
                    {
                        "username": "20bcs2613",
                        "content": "C++ Solution"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Does anybody have a good reference to why in-order traversal does not work for same tree comparison?"
                    },
                    {
                        "username": "Almazino",
                        "content": "why are the answers in my vscode and on the site different?"
                    },
                    {
                        "username": "TheSuperFastOne",
                        "content": "public class Solution {\n    public bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        isSameForOneNode(firstTree, secondTree)\n    }\n\n    public bool isSameForOneNode(TreeNode node1, TreeNode node2)\n    {\n        bool res = true;\n        if (node1.right == null && node2.right != null)\n        {\n            return false;\n        }\n        if (node1.left == null && node2.left != null)\n        {\n            return false;\n        }\n        if (node2.left == null && node1.left != null)\n        {\n            return false;\n        }\n        if (node2.right == null && node1.right != null)\n        {\n            return false;\n        }\n        if (node1.right != null && node2.right != null)\n        {\n            if (node1.right.val != node2.right.val)\n            {\n                return false;\n            }\n        }\n        if (node1.left != null && node2.left != null)\n        {\n            if (node1.left.val != node2.left.val)\n            {\n                return false;\n            }\n        }\n        if (isSameForOneNode(node1.right, node2.right) != true || isSameForOneNode(node1.left, node2.left) != true)\n        {\n            res = false;\n        }\n        return res;\n    }\n}\nFunction:\npublic bool IsSameTree(TreeNode firstTree, TreeNode secondTree) {\n        return isSameForOneNode(firstTree, secondTree);\n    }\n\n\nError Message:\nUnhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt Solution.isSameForOneNode(TreeNode node1, TreeNode node2)\nAt __Driver__.Main(String[] args)"
                    },
                    {
                        "username": "mitulchadha",
                        "content": "i tried comparing the in-order traversals for both the trees but it only passed 57/60 test cases, can someone tell me why is the code failing, i am new to trees, thanks"
                    },
                    {
                        "username": "ash030",
                        "content": "because for the same inorder traversals the tree structures can be different, for eg [1, 2, 3] and [3, 1, null, 2] they have different structures but inorder is same - [2,1, 3]"
                    },
                    {
                        "username": "Balajisaketh",
                        "content": "below is my code i am getting \\nError:Cannot read properties of null (reading \\'val\\')\\nplz help me \\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {boolean}\\n */\\nvar isSameTree = function(p, q) {\\n  \\n         \\nfunction check(p ,q)\\n\\n{\\n    let status=true\\n    if(p==null || q==null)\\n    {\\n        status=false\\n    }\\n     if(p.val==q.val)\\n     {\\n         status=true\\n         check(p.left,q.left)\\n         check(p.right,q.right)\\n\\n     }\\n     else\\n     {\\n         status=false\\n     }\\n     return status\\n    \\n}\\nconst data=check(p,q)\\nreturn data\\n   \\n}"
                    }
                ]
            },
            {
                "id": 1778166,
                "content": [
                    {
                        "username": "HJ2310",
                        "content": "class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list_p=new ArrayList<>();\\n        ArrayList<Integer> list_q=new ArrayList<>();\\n        inOrderTrav(p,list_p);\\n        inOrderTrav(q,list_q);\\n        return list_p==list_q;\\n        }\\n        static void inOrderTrav(TreeNode root, ArrayList<Integer> list){\\n            if(root==null){\\n                return;\\n            }\\n            inOrderTrav(root.left,list);\\n            list.add(root.val);\\n            inOrderTrav(root.right,list);\\n\\n        }\\n}\\n\\ncan anyone tell why this is not working? thank you."
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Can anyone teach me how to solve it, please."
                    },
                    {
                        "username": "constablensw",
                        "content": "So frustrated... so many little problems. Then this: aren't {1, null,2,3} and {1, null, 2, null, 3} equal??"
                    },
                    {
                        "username": "constablensw",
                        "content": "[@kandiana](/kandiana) I see it now. Thanks so much!"
                    },
                    {
                        "username": "kandiana",
                        "content": "In terms of binary trees, they aren't, since it matters whether child node is left or right\n[1,null,2,3] is a tree where node 2 has node 3 as its left node and no right node\n[1,null,2,null,3] is a tree where node 2 has no left node and node 3 as its right node\n\n"
                    },
                    {
                        "username": "TYork",
                        "content": "I\\'ve implemented an inorder traversal as well as __len__ method to reflect the data structure stated in the question.\\nThe code has passed all the leetcode test case on my editor even when p == [] and q ==[], however leetcode compiler didn\\'t like it. . My implementation passed 57/60 Does anyone why on Earth is that the case?\\n\\n\\nclass Solution(TreeNode):\\n    output =[].copy()\\n\\n    def __init__(self, val=None, left=None, right=None):\\n        super().__init__(val, left, right)\\n    \\n        \\n\\n    def inorder(self,root:TreeNode):\\n        if root is None:\\n            return []\\n        else:\\n            return (self.inorder(root.left)+[root.val])+self.inorder(root.right)\\n\\n\\n        \\n    def lengthtree(self,root):\\n        if root is None:\\n            return 0 \\n        return len(self.inorder(root.left)+[root.val]+self.inorder(root.right))\\n\\n\\n    def isSameTree(self,p:TreeNode,q:TreeNode):\\n        \\n        if self.lengthtree(p) < (1)/(10**4) or self.lengthtree(q) > 10**4:\\n            return False\\n\\n        if self.lengthtree(p) != self.lengthtree(q):\\n            return False\\n        elif self.inorder(p) == [] and self.inorder(q)==[]:\\n            return True\\n        return list(self.inorder(p))== list(self.inorder(q))\\n\\n"
                    },
                    {
                        "username": "ishuthakur",
                        "content": "JAVA SOLUTION\\n\\nclass Solution {\\n    private List<Integer> leftTree  = new ArrayList<>();\\n    private List<Integer> rightTree = new ArrayList<>();\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        leftTreePreOrder(p);\\n        rightTreePreOrder(q);\\n        System.out.print(leftTree);\\n        System.out.print(rightTree);\\n        return leftTree.equals(rightTree);\\n    }\\n    private void leftTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            leftTree.add(0);\\n            return ;\\n        }\\n        leftTree.add(root.val);\\n        leftTreePreOrder(root.left);\\n        leftTreePreOrder(root.right);\\n    }\\n    private void rightTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            rightTree.add(0);\\n            return;\\n        }\\n        rightTree.add(root.val);\\n        rightTreePreOrder(root.left);\\n        rightTreePreOrder(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "hey_adi_01",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "I have zero knowledge in trees and linked lists, where should I start learning it can someone help me?\\nThanks in Advance."
                    },
                    {
                        "username": "kandiana",
                        "content": "You can try going through these:\\nhttps://leetcode.com/explore/learn/card/linked-list/\\nhttps://leetcode.com/explore/learn/card/data-structure-tree/\\nThere are some premium only problems, but the theory is free and there are enough free problems for practice"
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "First, check the nodes are null or not then check the values of nodes are equal or not on both tree. If not return false and return the isSameTree with left && right nodes."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Come on, another nice day!"
                    },
                    {
                        "username": "Shivam_rastogi",
                        "content": "Java code: very simple code which beats 100% \\n\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n       if(p==null || q==null)\\n            return p==q;\\n        return (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1768687,
                "content": [
                    {
                        "username": "HJ2310",
                        "content": "class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list_p=new ArrayList<>();\\n        ArrayList<Integer> list_q=new ArrayList<>();\\n        inOrderTrav(p,list_p);\\n        inOrderTrav(q,list_q);\\n        return list_p==list_q;\\n        }\\n        static void inOrderTrav(TreeNode root, ArrayList<Integer> list){\\n            if(root==null){\\n                return;\\n            }\\n            inOrderTrav(root.left,list);\\n            list.add(root.val);\\n            inOrderTrav(root.right,list);\\n\\n        }\\n}\\n\\ncan anyone tell why this is not working? thank you."
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Can anyone teach me how to solve it, please."
                    },
                    {
                        "username": "constablensw",
                        "content": "So frustrated... so many little problems. Then this: aren't {1, null,2,3} and {1, null, 2, null, 3} equal??"
                    },
                    {
                        "username": "constablensw",
                        "content": "[@kandiana](/kandiana) I see it now. Thanks so much!"
                    },
                    {
                        "username": "kandiana",
                        "content": "In terms of binary trees, they aren't, since it matters whether child node is left or right\n[1,null,2,3] is a tree where node 2 has node 3 as its left node and no right node\n[1,null,2,null,3] is a tree where node 2 has no left node and node 3 as its right node\n\n"
                    },
                    {
                        "username": "TYork",
                        "content": "I\\'ve implemented an inorder traversal as well as __len__ method to reflect the data structure stated in the question.\\nThe code has passed all the leetcode test case on my editor even when p == [] and q ==[], however leetcode compiler didn\\'t like it. . My implementation passed 57/60 Does anyone why on Earth is that the case?\\n\\n\\nclass Solution(TreeNode):\\n    output =[].copy()\\n\\n    def __init__(self, val=None, left=None, right=None):\\n        super().__init__(val, left, right)\\n    \\n        \\n\\n    def inorder(self,root:TreeNode):\\n        if root is None:\\n            return []\\n        else:\\n            return (self.inorder(root.left)+[root.val])+self.inorder(root.right)\\n\\n\\n        \\n    def lengthtree(self,root):\\n        if root is None:\\n            return 0 \\n        return len(self.inorder(root.left)+[root.val]+self.inorder(root.right))\\n\\n\\n    def isSameTree(self,p:TreeNode,q:TreeNode):\\n        \\n        if self.lengthtree(p) < (1)/(10**4) or self.lengthtree(q) > 10**4:\\n            return False\\n\\n        if self.lengthtree(p) != self.lengthtree(q):\\n            return False\\n        elif self.inorder(p) == [] and self.inorder(q)==[]:\\n            return True\\n        return list(self.inorder(p))== list(self.inorder(q))\\n\\n"
                    },
                    {
                        "username": "ishuthakur",
                        "content": "JAVA SOLUTION\\n\\nclass Solution {\\n    private List<Integer> leftTree  = new ArrayList<>();\\n    private List<Integer> rightTree = new ArrayList<>();\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        leftTreePreOrder(p);\\n        rightTreePreOrder(q);\\n        System.out.print(leftTree);\\n        System.out.print(rightTree);\\n        return leftTree.equals(rightTree);\\n    }\\n    private void leftTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            leftTree.add(0);\\n            return ;\\n        }\\n        leftTree.add(root.val);\\n        leftTreePreOrder(root.left);\\n        leftTreePreOrder(root.right);\\n    }\\n    private void rightTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            rightTree.add(0);\\n            return;\\n        }\\n        rightTree.add(root.val);\\n        rightTreePreOrder(root.left);\\n        rightTreePreOrder(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "hey_adi_01",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "I have zero knowledge in trees and linked lists, where should I start learning it can someone help me?\\nThanks in Advance."
                    },
                    {
                        "username": "kandiana",
                        "content": "You can try going through these:\\nhttps://leetcode.com/explore/learn/card/linked-list/\\nhttps://leetcode.com/explore/learn/card/data-structure-tree/\\nThere are some premium only problems, but the theory is free and there are enough free problems for practice"
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "First, check the nodes are null or not then check the values of nodes are equal or not on both tree. If not return false and return the isSameTree with left && right nodes."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Come on, another nice day!"
                    },
                    {
                        "username": "Shivam_rastogi",
                        "content": "Java code: very simple code which beats 100% \\n\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n       if(p==null || q==null)\\n            return p==q;\\n        return (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1753213,
                "content": [
                    {
                        "username": "HJ2310",
                        "content": "class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list_p=new ArrayList<>();\\n        ArrayList<Integer> list_q=new ArrayList<>();\\n        inOrderTrav(p,list_p);\\n        inOrderTrav(q,list_q);\\n        return list_p==list_q;\\n        }\\n        static void inOrderTrav(TreeNode root, ArrayList<Integer> list){\\n            if(root==null){\\n                return;\\n            }\\n            inOrderTrav(root.left,list);\\n            list.add(root.val);\\n            inOrderTrav(root.right,list);\\n\\n        }\\n}\\n\\ncan anyone tell why this is not working? thank you."
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Can anyone teach me how to solve it, please."
                    },
                    {
                        "username": "constablensw",
                        "content": "So frustrated... so many little problems. Then this: aren't {1, null,2,3} and {1, null, 2, null, 3} equal??"
                    },
                    {
                        "username": "constablensw",
                        "content": "[@kandiana](/kandiana) I see it now. Thanks so much!"
                    },
                    {
                        "username": "kandiana",
                        "content": "In terms of binary trees, they aren't, since it matters whether child node is left or right\n[1,null,2,3] is a tree where node 2 has node 3 as its left node and no right node\n[1,null,2,null,3] is a tree where node 2 has no left node and node 3 as its right node\n\n"
                    },
                    {
                        "username": "TYork",
                        "content": "I\\'ve implemented an inorder traversal as well as __len__ method to reflect the data structure stated in the question.\\nThe code has passed all the leetcode test case on my editor even when p == [] and q ==[], however leetcode compiler didn\\'t like it. . My implementation passed 57/60 Does anyone why on Earth is that the case?\\n\\n\\nclass Solution(TreeNode):\\n    output =[].copy()\\n\\n    def __init__(self, val=None, left=None, right=None):\\n        super().__init__(val, left, right)\\n    \\n        \\n\\n    def inorder(self,root:TreeNode):\\n        if root is None:\\n            return []\\n        else:\\n            return (self.inorder(root.left)+[root.val])+self.inorder(root.right)\\n\\n\\n        \\n    def lengthtree(self,root):\\n        if root is None:\\n            return 0 \\n        return len(self.inorder(root.left)+[root.val]+self.inorder(root.right))\\n\\n\\n    def isSameTree(self,p:TreeNode,q:TreeNode):\\n        \\n        if self.lengthtree(p) < (1)/(10**4) or self.lengthtree(q) > 10**4:\\n            return False\\n\\n        if self.lengthtree(p) != self.lengthtree(q):\\n            return False\\n        elif self.inorder(p) == [] and self.inorder(q)==[]:\\n            return True\\n        return list(self.inorder(p))== list(self.inorder(q))\\n\\n"
                    },
                    {
                        "username": "ishuthakur",
                        "content": "JAVA SOLUTION\\n\\nclass Solution {\\n    private List<Integer> leftTree  = new ArrayList<>();\\n    private List<Integer> rightTree = new ArrayList<>();\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        leftTreePreOrder(p);\\n        rightTreePreOrder(q);\\n        System.out.print(leftTree);\\n        System.out.print(rightTree);\\n        return leftTree.equals(rightTree);\\n    }\\n    private void leftTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            leftTree.add(0);\\n            return ;\\n        }\\n        leftTree.add(root.val);\\n        leftTreePreOrder(root.left);\\n        leftTreePreOrder(root.right);\\n    }\\n    private void rightTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            rightTree.add(0);\\n            return;\\n        }\\n        rightTree.add(root.val);\\n        rightTreePreOrder(root.left);\\n        rightTreePreOrder(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "hey_adi_01",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "I have zero knowledge in trees and linked lists, where should I start learning it can someone help me?\\nThanks in Advance."
                    },
                    {
                        "username": "kandiana",
                        "content": "You can try going through these:\\nhttps://leetcode.com/explore/learn/card/linked-list/\\nhttps://leetcode.com/explore/learn/card/data-structure-tree/\\nThere are some premium only problems, but the theory is free and there are enough free problems for practice"
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "First, check the nodes are null or not then check the values of nodes are equal or not on both tree. If not return false and return the isSameTree with left && right nodes."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Come on, another nice day!"
                    },
                    {
                        "username": "Shivam_rastogi",
                        "content": "Java code: very simple code which beats 100% \\n\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n       if(p==null || q==null)\\n            return p==q;\\n        return (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1752974,
                "content": [
                    {
                        "username": "HJ2310",
                        "content": "class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list_p=new ArrayList<>();\\n        ArrayList<Integer> list_q=new ArrayList<>();\\n        inOrderTrav(p,list_p);\\n        inOrderTrav(q,list_q);\\n        return list_p==list_q;\\n        }\\n        static void inOrderTrav(TreeNode root, ArrayList<Integer> list){\\n            if(root==null){\\n                return;\\n            }\\n            inOrderTrav(root.left,list);\\n            list.add(root.val);\\n            inOrderTrav(root.right,list);\\n\\n        }\\n}\\n\\ncan anyone tell why this is not working? thank you."
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Can anyone teach me how to solve it, please."
                    },
                    {
                        "username": "constablensw",
                        "content": "So frustrated... so many little problems. Then this: aren't {1, null,2,3} and {1, null, 2, null, 3} equal??"
                    },
                    {
                        "username": "constablensw",
                        "content": "[@kandiana](/kandiana) I see it now. Thanks so much!"
                    },
                    {
                        "username": "kandiana",
                        "content": "In terms of binary trees, they aren't, since it matters whether child node is left or right\n[1,null,2,3] is a tree where node 2 has node 3 as its left node and no right node\n[1,null,2,null,3] is a tree where node 2 has no left node and node 3 as its right node\n\n"
                    },
                    {
                        "username": "TYork",
                        "content": "I\\'ve implemented an inorder traversal as well as __len__ method to reflect the data structure stated in the question.\\nThe code has passed all the leetcode test case on my editor even when p == [] and q ==[], however leetcode compiler didn\\'t like it. . My implementation passed 57/60 Does anyone why on Earth is that the case?\\n\\n\\nclass Solution(TreeNode):\\n    output =[].copy()\\n\\n    def __init__(self, val=None, left=None, right=None):\\n        super().__init__(val, left, right)\\n    \\n        \\n\\n    def inorder(self,root:TreeNode):\\n        if root is None:\\n            return []\\n        else:\\n            return (self.inorder(root.left)+[root.val])+self.inorder(root.right)\\n\\n\\n        \\n    def lengthtree(self,root):\\n        if root is None:\\n            return 0 \\n        return len(self.inorder(root.left)+[root.val]+self.inorder(root.right))\\n\\n\\n    def isSameTree(self,p:TreeNode,q:TreeNode):\\n        \\n        if self.lengthtree(p) < (1)/(10**4) or self.lengthtree(q) > 10**4:\\n            return False\\n\\n        if self.lengthtree(p) != self.lengthtree(q):\\n            return False\\n        elif self.inorder(p) == [] and self.inorder(q)==[]:\\n            return True\\n        return list(self.inorder(p))== list(self.inorder(q))\\n\\n"
                    },
                    {
                        "username": "ishuthakur",
                        "content": "JAVA SOLUTION\\n\\nclass Solution {\\n    private List<Integer> leftTree  = new ArrayList<>();\\n    private List<Integer> rightTree = new ArrayList<>();\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        leftTreePreOrder(p);\\n        rightTreePreOrder(q);\\n        System.out.print(leftTree);\\n        System.out.print(rightTree);\\n        return leftTree.equals(rightTree);\\n    }\\n    private void leftTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            leftTree.add(0);\\n            return ;\\n        }\\n        leftTree.add(root.val);\\n        leftTreePreOrder(root.left);\\n        leftTreePreOrder(root.right);\\n    }\\n    private void rightTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            rightTree.add(0);\\n            return;\\n        }\\n        rightTree.add(root.val);\\n        rightTreePreOrder(root.left);\\n        rightTreePreOrder(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "hey_adi_01",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "I have zero knowledge in trees and linked lists, where should I start learning it can someone help me?\\nThanks in Advance."
                    },
                    {
                        "username": "kandiana",
                        "content": "You can try going through these:\\nhttps://leetcode.com/explore/learn/card/linked-list/\\nhttps://leetcode.com/explore/learn/card/data-structure-tree/\\nThere are some premium only problems, but the theory is free and there are enough free problems for practice"
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "First, check the nodes are null or not then check the values of nodes are equal or not on both tree. If not return false and return the isSameTree with left && right nodes."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Come on, another nice day!"
                    },
                    {
                        "username": "Shivam_rastogi",
                        "content": "Java code: very simple code which beats 100% \\n\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n       if(p==null || q==null)\\n            return p==q;\\n        return (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1752507,
                "content": [
                    {
                        "username": "HJ2310",
                        "content": "class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list_p=new ArrayList<>();\\n        ArrayList<Integer> list_q=new ArrayList<>();\\n        inOrderTrav(p,list_p);\\n        inOrderTrav(q,list_q);\\n        return list_p==list_q;\\n        }\\n        static void inOrderTrav(TreeNode root, ArrayList<Integer> list){\\n            if(root==null){\\n                return;\\n            }\\n            inOrderTrav(root.left,list);\\n            list.add(root.val);\\n            inOrderTrav(root.right,list);\\n\\n        }\\n}\\n\\ncan anyone tell why this is not working? thank you."
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Can anyone teach me how to solve it, please."
                    },
                    {
                        "username": "constablensw",
                        "content": "So frustrated... so many little problems. Then this: aren't {1, null,2,3} and {1, null, 2, null, 3} equal??"
                    },
                    {
                        "username": "constablensw",
                        "content": "[@kandiana](/kandiana) I see it now. Thanks so much!"
                    },
                    {
                        "username": "kandiana",
                        "content": "In terms of binary trees, they aren't, since it matters whether child node is left or right\n[1,null,2,3] is a tree where node 2 has node 3 as its left node and no right node\n[1,null,2,null,3] is a tree where node 2 has no left node and node 3 as its right node\n\n"
                    },
                    {
                        "username": "TYork",
                        "content": "I\\'ve implemented an inorder traversal as well as __len__ method to reflect the data structure stated in the question.\\nThe code has passed all the leetcode test case on my editor even when p == [] and q ==[], however leetcode compiler didn\\'t like it. . My implementation passed 57/60 Does anyone why on Earth is that the case?\\n\\n\\nclass Solution(TreeNode):\\n    output =[].copy()\\n\\n    def __init__(self, val=None, left=None, right=None):\\n        super().__init__(val, left, right)\\n    \\n        \\n\\n    def inorder(self,root:TreeNode):\\n        if root is None:\\n            return []\\n        else:\\n            return (self.inorder(root.left)+[root.val])+self.inorder(root.right)\\n\\n\\n        \\n    def lengthtree(self,root):\\n        if root is None:\\n            return 0 \\n        return len(self.inorder(root.left)+[root.val]+self.inorder(root.right))\\n\\n\\n    def isSameTree(self,p:TreeNode,q:TreeNode):\\n        \\n        if self.lengthtree(p) < (1)/(10**4) or self.lengthtree(q) > 10**4:\\n            return False\\n\\n        if self.lengthtree(p) != self.lengthtree(q):\\n            return False\\n        elif self.inorder(p) == [] and self.inorder(q)==[]:\\n            return True\\n        return list(self.inorder(p))== list(self.inorder(q))\\n\\n"
                    },
                    {
                        "username": "ishuthakur",
                        "content": "JAVA SOLUTION\\n\\nclass Solution {\\n    private List<Integer> leftTree  = new ArrayList<>();\\n    private List<Integer> rightTree = new ArrayList<>();\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        leftTreePreOrder(p);\\n        rightTreePreOrder(q);\\n        System.out.print(leftTree);\\n        System.out.print(rightTree);\\n        return leftTree.equals(rightTree);\\n    }\\n    private void leftTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            leftTree.add(0);\\n            return ;\\n        }\\n        leftTree.add(root.val);\\n        leftTreePreOrder(root.left);\\n        leftTreePreOrder(root.right);\\n    }\\n    private void rightTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            rightTree.add(0);\\n            return;\\n        }\\n        rightTree.add(root.val);\\n        rightTreePreOrder(root.left);\\n        rightTreePreOrder(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "hey_adi_01",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "I have zero knowledge in trees and linked lists, where should I start learning it can someone help me?\\nThanks in Advance."
                    },
                    {
                        "username": "kandiana",
                        "content": "You can try going through these:\\nhttps://leetcode.com/explore/learn/card/linked-list/\\nhttps://leetcode.com/explore/learn/card/data-structure-tree/\\nThere are some premium only problems, but the theory is free and there are enough free problems for practice"
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "First, check the nodes are null or not then check the values of nodes are equal or not on both tree. If not return false and return the isSameTree with left && right nodes."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Come on, another nice day!"
                    },
                    {
                        "username": "Shivam_rastogi",
                        "content": "Java code: very simple code which beats 100% \\n\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n       if(p==null || q==null)\\n            return p==q;\\n        return (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1752124,
                "content": [
                    {
                        "username": "HJ2310",
                        "content": "class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list_p=new ArrayList<>();\\n        ArrayList<Integer> list_q=new ArrayList<>();\\n        inOrderTrav(p,list_p);\\n        inOrderTrav(q,list_q);\\n        return list_p==list_q;\\n        }\\n        static void inOrderTrav(TreeNode root, ArrayList<Integer> list){\\n            if(root==null){\\n                return;\\n            }\\n            inOrderTrav(root.left,list);\\n            list.add(root.val);\\n            inOrderTrav(root.right,list);\\n\\n        }\\n}\\n\\ncan anyone tell why this is not working? thank you."
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Can anyone teach me how to solve it, please."
                    },
                    {
                        "username": "constablensw",
                        "content": "So frustrated... so many little problems. Then this: aren't {1, null,2,3} and {1, null, 2, null, 3} equal??"
                    },
                    {
                        "username": "constablensw",
                        "content": "[@kandiana](/kandiana) I see it now. Thanks so much!"
                    },
                    {
                        "username": "kandiana",
                        "content": "In terms of binary trees, they aren't, since it matters whether child node is left or right\n[1,null,2,3] is a tree where node 2 has node 3 as its left node and no right node\n[1,null,2,null,3] is a tree where node 2 has no left node and node 3 as its right node\n\n"
                    },
                    {
                        "username": "TYork",
                        "content": "I\\'ve implemented an inorder traversal as well as __len__ method to reflect the data structure stated in the question.\\nThe code has passed all the leetcode test case on my editor even when p == [] and q ==[], however leetcode compiler didn\\'t like it. . My implementation passed 57/60 Does anyone why on Earth is that the case?\\n\\n\\nclass Solution(TreeNode):\\n    output =[].copy()\\n\\n    def __init__(self, val=None, left=None, right=None):\\n        super().__init__(val, left, right)\\n    \\n        \\n\\n    def inorder(self,root:TreeNode):\\n        if root is None:\\n            return []\\n        else:\\n            return (self.inorder(root.left)+[root.val])+self.inorder(root.right)\\n\\n\\n        \\n    def lengthtree(self,root):\\n        if root is None:\\n            return 0 \\n        return len(self.inorder(root.left)+[root.val]+self.inorder(root.right))\\n\\n\\n    def isSameTree(self,p:TreeNode,q:TreeNode):\\n        \\n        if self.lengthtree(p) < (1)/(10**4) or self.lengthtree(q) > 10**4:\\n            return False\\n\\n        if self.lengthtree(p) != self.lengthtree(q):\\n            return False\\n        elif self.inorder(p) == [] and self.inorder(q)==[]:\\n            return True\\n        return list(self.inorder(p))== list(self.inorder(q))\\n\\n"
                    },
                    {
                        "username": "ishuthakur",
                        "content": "JAVA SOLUTION\\n\\nclass Solution {\\n    private List<Integer> leftTree  = new ArrayList<>();\\n    private List<Integer> rightTree = new ArrayList<>();\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        leftTreePreOrder(p);\\n        rightTreePreOrder(q);\\n        System.out.print(leftTree);\\n        System.out.print(rightTree);\\n        return leftTree.equals(rightTree);\\n    }\\n    private void leftTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            leftTree.add(0);\\n            return ;\\n        }\\n        leftTree.add(root.val);\\n        leftTreePreOrder(root.left);\\n        leftTreePreOrder(root.right);\\n    }\\n    private void rightTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            rightTree.add(0);\\n            return;\\n        }\\n        rightTree.add(root.val);\\n        rightTreePreOrder(root.left);\\n        rightTreePreOrder(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "hey_adi_01",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "I have zero knowledge in trees and linked lists, where should I start learning it can someone help me?\\nThanks in Advance."
                    },
                    {
                        "username": "kandiana",
                        "content": "You can try going through these:\\nhttps://leetcode.com/explore/learn/card/linked-list/\\nhttps://leetcode.com/explore/learn/card/data-structure-tree/\\nThere are some premium only problems, but the theory is free and there are enough free problems for practice"
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "First, check the nodes are null or not then check the values of nodes are equal or not on both tree. If not return false and return the isSameTree with left && right nodes."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Come on, another nice day!"
                    },
                    {
                        "username": "Shivam_rastogi",
                        "content": "Java code: very simple code which beats 100% \\n\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n       if(p==null || q==null)\\n            return p==q;\\n        return (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1751778,
                "content": [
                    {
                        "username": "HJ2310",
                        "content": "class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list_p=new ArrayList<>();\\n        ArrayList<Integer> list_q=new ArrayList<>();\\n        inOrderTrav(p,list_p);\\n        inOrderTrav(q,list_q);\\n        return list_p==list_q;\\n        }\\n        static void inOrderTrav(TreeNode root, ArrayList<Integer> list){\\n            if(root==null){\\n                return;\\n            }\\n            inOrderTrav(root.left,list);\\n            list.add(root.val);\\n            inOrderTrav(root.right,list);\\n\\n        }\\n}\\n\\ncan anyone tell why this is not working? thank you."
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Can anyone teach me how to solve it, please."
                    },
                    {
                        "username": "constablensw",
                        "content": "So frustrated... so many little problems. Then this: aren't {1, null,2,3} and {1, null, 2, null, 3} equal??"
                    },
                    {
                        "username": "constablensw",
                        "content": "[@kandiana](/kandiana) I see it now. Thanks so much!"
                    },
                    {
                        "username": "kandiana",
                        "content": "In terms of binary trees, they aren't, since it matters whether child node is left or right\n[1,null,2,3] is a tree where node 2 has node 3 as its left node and no right node\n[1,null,2,null,3] is a tree where node 2 has no left node and node 3 as its right node\n\n"
                    },
                    {
                        "username": "TYork",
                        "content": "I\\'ve implemented an inorder traversal as well as __len__ method to reflect the data structure stated in the question.\\nThe code has passed all the leetcode test case on my editor even when p == [] and q ==[], however leetcode compiler didn\\'t like it. . My implementation passed 57/60 Does anyone why on Earth is that the case?\\n\\n\\nclass Solution(TreeNode):\\n    output =[].copy()\\n\\n    def __init__(self, val=None, left=None, right=None):\\n        super().__init__(val, left, right)\\n    \\n        \\n\\n    def inorder(self,root:TreeNode):\\n        if root is None:\\n            return []\\n        else:\\n            return (self.inorder(root.left)+[root.val])+self.inorder(root.right)\\n\\n\\n        \\n    def lengthtree(self,root):\\n        if root is None:\\n            return 0 \\n        return len(self.inorder(root.left)+[root.val]+self.inorder(root.right))\\n\\n\\n    def isSameTree(self,p:TreeNode,q:TreeNode):\\n        \\n        if self.lengthtree(p) < (1)/(10**4) or self.lengthtree(q) > 10**4:\\n            return False\\n\\n        if self.lengthtree(p) != self.lengthtree(q):\\n            return False\\n        elif self.inorder(p) == [] and self.inorder(q)==[]:\\n            return True\\n        return list(self.inorder(p))== list(self.inorder(q))\\n\\n"
                    },
                    {
                        "username": "ishuthakur",
                        "content": "JAVA SOLUTION\\n\\nclass Solution {\\n    private List<Integer> leftTree  = new ArrayList<>();\\n    private List<Integer> rightTree = new ArrayList<>();\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        leftTreePreOrder(p);\\n        rightTreePreOrder(q);\\n        System.out.print(leftTree);\\n        System.out.print(rightTree);\\n        return leftTree.equals(rightTree);\\n    }\\n    private void leftTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            leftTree.add(0);\\n            return ;\\n        }\\n        leftTree.add(root.val);\\n        leftTreePreOrder(root.left);\\n        leftTreePreOrder(root.right);\\n    }\\n    private void rightTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            rightTree.add(0);\\n            return;\\n        }\\n        rightTree.add(root.val);\\n        rightTreePreOrder(root.left);\\n        rightTreePreOrder(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "hey_adi_01",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "I have zero knowledge in trees and linked lists, where should I start learning it can someone help me?\\nThanks in Advance."
                    },
                    {
                        "username": "kandiana",
                        "content": "You can try going through these:\\nhttps://leetcode.com/explore/learn/card/linked-list/\\nhttps://leetcode.com/explore/learn/card/data-structure-tree/\\nThere are some premium only problems, but the theory is free and there are enough free problems for practice"
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "First, check the nodes are null or not then check the values of nodes are equal or not on both tree. If not return false and return the isSameTree with left && right nodes."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Come on, another nice day!"
                    },
                    {
                        "username": "Shivam_rastogi",
                        "content": "Java code: very simple code which beats 100% \\n\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n       if(p==null || q==null)\\n            return p==q;\\n        return (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1751329,
                "content": [
                    {
                        "username": "HJ2310",
                        "content": "class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list_p=new ArrayList<>();\\n        ArrayList<Integer> list_q=new ArrayList<>();\\n        inOrderTrav(p,list_p);\\n        inOrderTrav(q,list_q);\\n        return list_p==list_q;\\n        }\\n        static void inOrderTrav(TreeNode root, ArrayList<Integer> list){\\n            if(root==null){\\n                return;\\n            }\\n            inOrderTrav(root.left,list);\\n            list.add(root.val);\\n            inOrderTrav(root.right,list);\\n\\n        }\\n}\\n\\ncan anyone tell why this is not working? thank you."
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Can anyone teach me how to solve it, please."
                    },
                    {
                        "username": "constablensw",
                        "content": "So frustrated... so many little problems. Then this: aren't {1, null,2,3} and {1, null, 2, null, 3} equal??"
                    },
                    {
                        "username": "constablensw",
                        "content": "[@kandiana](/kandiana) I see it now. Thanks so much!"
                    },
                    {
                        "username": "kandiana",
                        "content": "In terms of binary trees, they aren't, since it matters whether child node is left or right\n[1,null,2,3] is a tree where node 2 has node 3 as its left node and no right node\n[1,null,2,null,3] is a tree where node 2 has no left node and node 3 as its right node\n\n"
                    },
                    {
                        "username": "TYork",
                        "content": "I\\'ve implemented an inorder traversal as well as __len__ method to reflect the data structure stated in the question.\\nThe code has passed all the leetcode test case on my editor even when p == [] and q ==[], however leetcode compiler didn\\'t like it. . My implementation passed 57/60 Does anyone why on Earth is that the case?\\n\\n\\nclass Solution(TreeNode):\\n    output =[].copy()\\n\\n    def __init__(self, val=None, left=None, right=None):\\n        super().__init__(val, left, right)\\n    \\n        \\n\\n    def inorder(self,root:TreeNode):\\n        if root is None:\\n            return []\\n        else:\\n            return (self.inorder(root.left)+[root.val])+self.inorder(root.right)\\n\\n\\n        \\n    def lengthtree(self,root):\\n        if root is None:\\n            return 0 \\n        return len(self.inorder(root.left)+[root.val]+self.inorder(root.right))\\n\\n\\n    def isSameTree(self,p:TreeNode,q:TreeNode):\\n        \\n        if self.lengthtree(p) < (1)/(10**4) or self.lengthtree(q) > 10**4:\\n            return False\\n\\n        if self.lengthtree(p) != self.lengthtree(q):\\n            return False\\n        elif self.inorder(p) == [] and self.inorder(q)==[]:\\n            return True\\n        return list(self.inorder(p))== list(self.inorder(q))\\n\\n"
                    },
                    {
                        "username": "ishuthakur",
                        "content": "JAVA SOLUTION\\n\\nclass Solution {\\n    private List<Integer> leftTree  = new ArrayList<>();\\n    private List<Integer> rightTree = new ArrayList<>();\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        leftTreePreOrder(p);\\n        rightTreePreOrder(q);\\n        System.out.print(leftTree);\\n        System.out.print(rightTree);\\n        return leftTree.equals(rightTree);\\n    }\\n    private void leftTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            leftTree.add(0);\\n            return ;\\n        }\\n        leftTree.add(root.val);\\n        leftTreePreOrder(root.left);\\n        leftTreePreOrder(root.right);\\n    }\\n    private void rightTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            rightTree.add(0);\\n            return;\\n        }\\n        rightTree.add(root.val);\\n        rightTreePreOrder(root.left);\\n        rightTreePreOrder(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "hey_adi_01",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "I have zero knowledge in trees and linked lists, where should I start learning it can someone help me?\\nThanks in Advance."
                    },
                    {
                        "username": "kandiana",
                        "content": "You can try going through these:\\nhttps://leetcode.com/explore/learn/card/linked-list/\\nhttps://leetcode.com/explore/learn/card/data-structure-tree/\\nThere are some premium only problems, but the theory is free and there are enough free problems for practice"
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "First, check the nodes are null or not then check the values of nodes are equal or not on both tree. If not return false and return the isSameTree with left && right nodes."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Come on, another nice day!"
                    },
                    {
                        "username": "Shivam_rastogi",
                        "content": "Java code: very simple code which beats 100% \\n\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n       if(p==null || q==null)\\n            return p==q;\\n        return (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1751191,
                "content": [
                    {
                        "username": "HJ2310",
                        "content": "class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list_p=new ArrayList<>();\\n        ArrayList<Integer> list_q=new ArrayList<>();\\n        inOrderTrav(p,list_p);\\n        inOrderTrav(q,list_q);\\n        return list_p==list_q;\\n        }\\n        static void inOrderTrav(TreeNode root, ArrayList<Integer> list){\\n            if(root==null){\\n                return;\\n            }\\n            inOrderTrav(root.left,list);\\n            list.add(root.val);\\n            inOrderTrav(root.right,list);\\n\\n        }\\n}\\n\\ncan anyone tell why this is not working? thank you."
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Can anyone teach me how to solve it, please."
                    },
                    {
                        "username": "constablensw",
                        "content": "So frustrated... so many little problems. Then this: aren't {1, null,2,3} and {1, null, 2, null, 3} equal??"
                    },
                    {
                        "username": "constablensw",
                        "content": "[@kandiana](/kandiana) I see it now. Thanks so much!"
                    },
                    {
                        "username": "kandiana",
                        "content": "In terms of binary trees, they aren't, since it matters whether child node is left or right\n[1,null,2,3] is a tree where node 2 has node 3 as its left node and no right node\n[1,null,2,null,3] is a tree where node 2 has no left node and node 3 as its right node\n\n"
                    },
                    {
                        "username": "TYork",
                        "content": "I\\'ve implemented an inorder traversal as well as __len__ method to reflect the data structure stated in the question.\\nThe code has passed all the leetcode test case on my editor even when p == [] and q ==[], however leetcode compiler didn\\'t like it. . My implementation passed 57/60 Does anyone why on Earth is that the case?\\n\\n\\nclass Solution(TreeNode):\\n    output =[].copy()\\n\\n    def __init__(self, val=None, left=None, right=None):\\n        super().__init__(val, left, right)\\n    \\n        \\n\\n    def inorder(self,root:TreeNode):\\n        if root is None:\\n            return []\\n        else:\\n            return (self.inorder(root.left)+[root.val])+self.inorder(root.right)\\n\\n\\n        \\n    def lengthtree(self,root):\\n        if root is None:\\n            return 0 \\n        return len(self.inorder(root.left)+[root.val]+self.inorder(root.right))\\n\\n\\n    def isSameTree(self,p:TreeNode,q:TreeNode):\\n        \\n        if self.lengthtree(p) < (1)/(10**4) or self.lengthtree(q) > 10**4:\\n            return False\\n\\n        if self.lengthtree(p) != self.lengthtree(q):\\n            return False\\n        elif self.inorder(p) == [] and self.inorder(q)==[]:\\n            return True\\n        return list(self.inorder(p))== list(self.inorder(q))\\n\\n"
                    },
                    {
                        "username": "ishuthakur",
                        "content": "JAVA SOLUTION\\n\\nclass Solution {\\n    private List<Integer> leftTree  = new ArrayList<>();\\n    private List<Integer> rightTree = new ArrayList<>();\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        leftTreePreOrder(p);\\n        rightTreePreOrder(q);\\n        System.out.print(leftTree);\\n        System.out.print(rightTree);\\n        return leftTree.equals(rightTree);\\n    }\\n    private void leftTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            leftTree.add(0);\\n            return ;\\n        }\\n        leftTree.add(root.val);\\n        leftTreePreOrder(root.left);\\n        leftTreePreOrder(root.right);\\n    }\\n    private void rightTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            rightTree.add(0);\\n            return;\\n        }\\n        rightTree.add(root.val);\\n        rightTreePreOrder(root.left);\\n        rightTreePreOrder(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "hey_adi_01",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "I have zero knowledge in trees and linked lists, where should I start learning it can someone help me?\\nThanks in Advance."
                    },
                    {
                        "username": "kandiana",
                        "content": "You can try going through these:\\nhttps://leetcode.com/explore/learn/card/linked-list/\\nhttps://leetcode.com/explore/learn/card/data-structure-tree/\\nThere are some premium only problems, but the theory is free and there are enough free problems for practice"
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "First, check the nodes are null or not then check the values of nodes are equal or not on both tree. If not return false and return the isSameTree with left && right nodes."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Come on, another nice day!"
                    },
                    {
                        "username": "Shivam_rastogi",
                        "content": "Java code: very simple code which beats 100% \\n\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n       if(p==null || q==null)\\n            return p==q;\\n        return (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1751137,
                "content": [
                    {
                        "username": "HJ2310",
                        "content": "class Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list_p=new ArrayList<>();\\n        ArrayList<Integer> list_q=new ArrayList<>();\\n        inOrderTrav(p,list_p);\\n        inOrderTrav(q,list_q);\\n        return list_p==list_q;\\n        }\\n        static void inOrderTrav(TreeNode root, ArrayList<Integer> list){\\n            if(root==null){\\n                return;\\n            }\\n            inOrderTrav(root.left,list);\\n            list.add(root.val);\\n            inOrderTrav(root.right,list);\\n\\n        }\\n}\\n\\ncan anyone tell why this is not working? thank you."
                    },
                    {
                        "username": "vrarjun2004",
                        "content": "Can anyone teach me how to solve it, please."
                    },
                    {
                        "username": "constablensw",
                        "content": "So frustrated... so many little problems. Then this: aren't {1, null,2,3} and {1, null, 2, null, 3} equal??"
                    },
                    {
                        "username": "constablensw",
                        "content": "[@kandiana](/kandiana) I see it now. Thanks so much!"
                    },
                    {
                        "username": "kandiana",
                        "content": "In terms of binary trees, they aren't, since it matters whether child node is left or right\n[1,null,2,3] is a tree where node 2 has node 3 as its left node and no right node\n[1,null,2,null,3] is a tree where node 2 has no left node and node 3 as its right node\n\n"
                    },
                    {
                        "username": "TYork",
                        "content": "I\\'ve implemented an inorder traversal as well as __len__ method to reflect the data structure stated in the question.\\nThe code has passed all the leetcode test case on my editor even when p == [] and q ==[], however leetcode compiler didn\\'t like it. . My implementation passed 57/60 Does anyone why on Earth is that the case?\\n\\n\\nclass Solution(TreeNode):\\n    output =[].copy()\\n\\n    def __init__(self, val=None, left=None, right=None):\\n        super().__init__(val, left, right)\\n    \\n        \\n\\n    def inorder(self,root:TreeNode):\\n        if root is None:\\n            return []\\n        else:\\n            return (self.inorder(root.left)+[root.val])+self.inorder(root.right)\\n\\n\\n        \\n    def lengthtree(self,root):\\n        if root is None:\\n            return 0 \\n        return len(self.inorder(root.left)+[root.val]+self.inorder(root.right))\\n\\n\\n    def isSameTree(self,p:TreeNode,q:TreeNode):\\n        \\n        if self.lengthtree(p) < (1)/(10**4) or self.lengthtree(q) > 10**4:\\n            return False\\n\\n        if self.lengthtree(p) != self.lengthtree(q):\\n            return False\\n        elif self.inorder(p) == [] and self.inorder(q)==[]:\\n            return True\\n        return list(self.inorder(p))== list(self.inorder(q))\\n\\n"
                    },
                    {
                        "username": "ishuthakur",
                        "content": "JAVA SOLUTION\\n\\nclass Solution {\\n    private List<Integer> leftTree  = new ArrayList<>();\\n    private List<Integer> rightTree = new ArrayList<>();\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        leftTreePreOrder(p);\\n        rightTreePreOrder(q);\\n        System.out.print(leftTree);\\n        System.out.print(rightTree);\\n        return leftTree.equals(rightTree);\\n    }\\n    private void leftTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            leftTree.add(0);\\n            return ;\\n        }\\n        leftTree.add(root.val);\\n        leftTreePreOrder(root.left);\\n        leftTreePreOrder(root.right);\\n    }\\n    private void rightTreePreOrder(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            rightTree.add(0);\\n            return;\\n        }\\n        rightTree.add(root.val);\\n        rightTreePreOrder(root.left);\\n        rightTreePreOrder(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "hey_adi_01",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "I have zero knowledge in trees and linked lists, where should I start learning it can someone help me?\\nThanks in Advance."
                    },
                    {
                        "username": "kandiana",
                        "content": "You can try going through these:\\nhttps://leetcode.com/explore/learn/card/linked-list/\\nhttps://leetcode.com/explore/learn/card/data-structure-tree/\\nThere are some premium only problems, but the theory is free and there are enough free problems for practice"
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "First, check the nodes are null or not then check the values of nodes are equal or not on both tree. If not return false and return the isSameTree with left && right nodes."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Come on, another nice day!"
                    },
                    {
                        "username": "Shivam_rastogi",
                        "content": "Java code: very simple code which beats 100% \\n\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n       if(p==null || q==null)\\n            return p==q;\\n        return (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1751123,
                "content": [
                    {
                        "username": "Islam_Mesabah",
                        "content": "\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if (p.val == q.val) return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n        return false;\n    }\n"
                    },
                    {
                        "username": "RashidAnsari",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // If both trees are null, they are the same\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        // If one tree is null and the other is not, they are not the same\\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        // If the values at the current nodes are not the same, the trees are not the same\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        // Recursively check the left and right subtrees\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n\\n\\nThis solution uses a recursive approach to check if the two trees are the same. It starts by checking if both trees are null, in which case they are considered to be the same. It then checks if one tree is null and the other is not, in which case they are considered to be different. If neither of these cases apply, it compares the values at the current nodes of the two trees. If they are not the same, the function returns false. If the values are the same, the function recursively checks the left and right subtrees of both trees. If both left subtrees and both right subtrees are the same, the function returns true. Otherwise, it returns false.\\n\\nThis solution has a time complexity of O(n) where n is the total number of nodes in the tree. The reason is that it needs to visit all nodes in the tree. Additionally, it has a space complexity of O(log n) in best case and O(n) in worst case, due to the depth of the recursion.\\n\\n\\n\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/same-tree/solutions/3028172/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "oxke",
                        "content": "how beautiful and satisfying is it to write\n`if (!p || !q) return p == q;`"
                    },
                    {
                        "username": "Prince__7",
                        "content": "C++ approach beats 100%\n\nbool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q){\n            return true;\n        }\n        else if(!p && q){\n            return false;\n        }\n        else if(p && !q){\n            return false;\n        }\n        else if(p->val !=q->val){\n            return false;\n        }\n        bool ans=true;\n        ans&=isSameTree(p->left,q->left);\n        ans&=isSameTree(p->right,q->right);\n        return ans;\n        \n    } "
                    },
                    {
                        "username": "Msey",
                        "content": "One-liner with one condition https://leetcode.com/problems/same-tree/solutions/3029022/c-one-liner-beats-99\n"
                    },
                    {
                        "username": "coder_for_sure",
                        "content": "this can be used as solution:-\\n`class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        return str(p) == str(q) `\\n     "
                    },
                    {
                        "username": "pawangupta",
                        "content": "Work it out for three use cases:\\n1. If both trees are empty, then it means both trees are same so return True.\\n2. If either of the tree is empty but the other tree is not empty, then both trees are not same so return False.\\n3. If both trees are non-empty, then check for the root value in both the trees. If the root value is same, then recursively check for the left subtrees in both trees and right subtrees in both the trees. If all node values are same, then they are same trees so return True."
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "Simply apply any of the traversal approach and check whether both the trees are equal or not .\\nif equal return true otherwise return false ."
                    },
                    {
                        "username": "neopraveen",
                        "content": "And here is an exact similar question what we solved yesterday. "
                    }
                ]
            },
            {
                "id": 1751121,
                "content": [
                    {
                        "username": "Islam_Mesabah",
                        "content": "\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if (p.val == q.val) return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n        return false;\n    }\n"
                    },
                    {
                        "username": "RashidAnsari",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // If both trees are null, they are the same\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        // If one tree is null and the other is not, they are not the same\\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        // If the values at the current nodes are not the same, the trees are not the same\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        // Recursively check the left and right subtrees\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n\\n\\nThis solution uses a recursive approach to check if the two trees are the same. It starts by checking if both trees are null, in which case they are considered to be the same. It then checks if one tree is null and the other is not, in which case they are considered to be different. If neither of these cases apply, it compares the values at the current nodes of the two trees. If they are not the same, the function returns false. If the values are the same, the function recursively checks the left and right subtrees of both trees. If both left subtrees and both right subtrees are the same, the function returns true. Otherwise, it returns false.\\n\\nThis solution has a time complexity of O(n) where n is the total number of nodes in the tree. The reason is that it needs to visit all nodes in the tree. Additionally, it has a space complexity of O(log n) in best case and O(n) in worst case, due to the depth of the recursion.\\n\\n\\n\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/same-tree/solutions/3028172/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "oxke",
                        "content": "how beautiful and satisfying is it to write\n`if (!p || !q) return p == q;`"
                    },
                    {
                        "username": "Prince__7",
                        "content": "C++ approach beats 100%\n\nbool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q){\n            return true;\n        }\n        else if(!p && q){\n            return false;\n        }\n        else if(p && !q){\n            return false;\n        }\n        else if(p->val !=q->val){\n            return false;\n        }\n        bool ans=true;\n        ans&=isSameTree(p->left,q->left);\n        ans&=isSameTree(p->right,q->right);\n        return ans;\n        \n    } "
                    },
                    {
                        "username": "Msey",
                        "content": "One-liner with one condition https://leetcode.com/problems/same-tree/solutions/3029022/c-one-liner-beats-99\n"
                    },
                    {
                        "username": "coder_for_sure",
                        "content": "this can be used as solution:-\\n`class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        return str(p) == str(q) `\\n     "
                    },
                    {
                        "username": "pawangupta",
                        "content": "Work it out for three use cases:\\n1. If both trees are empty, then it means both trees are same so return True.\\n2. If either of the tree is empty but the other tree is not empty, then both trees are not same so return False.\\n3. If both trees are non-empty, then check for the root value in both the trees. If the root value is same, then recursively check for the left subtrees in both trees and right subtrees in both the trees. If all node values are same, then they are same trees so return True."
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "Simply apply any of the traversal approach and check whether both the trees are equal or not .\\nif equal return true otherwise return false ."
                    },
                    {
                        "username": "neopraveen",
                        "content": "And here is an exact similar question what we solved yesterday. "
                    }
                ]
            },
            {
                "id": 1751090,
                "content": [
                    {
                        "username": "Islam_Mesabah",
                        "content": "\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if (p.val == q.val) return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n        return false;\n    }\n"
                    },
                    {
                        "username": "RashidAnsari",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // If both trees are null, they are the same\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        // If one tree is null and the other is not, they are not the same\\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        // If the values at the current nodes are not the same, the trees are not the same\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        // Recursively check the left and right subtrees\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n\\n\\nThis solution uses a recursive approach to check if the two trees are the same. It starts by checking if both trees are null, in which case they are considered to be the same. It then checks if one tree is null and the other is not, in which case they are considered to be different. If neither of these cases apply, it compares the values at the current nodes of the two trees. If they are not the same, the function returns false. If the values are the same, the function recursively checks the left and right subtrees of both trees. If both left subtrees and both right subtrees are the same, the function returns true. Otherwise, it returns false.\\n\\nThis solution has a time complexity of O(n) where n is the total number of nodes in the tree. The reason is that it needs to visit all nodes in the tree. Additionally, it has a space complexity of O(log n) in best case and O(n) in worst case, due to the depth of the recursion.\\n\\n\\n\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/same-tree/solutions/3028172/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "oxke",
                        "content": "how beautiful and satisfying is it to write\n`if (!p || !q) return p == q;`"
                    },
                    {
                        "username": "Prince__7",
                        "content": "C++ approach beats 100%\n\nbool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q){\n            return true;\n        }\n        else if(!p && q){\n            return false;\n        }\n        else if(p && !q){\n            return false;\n        }\n        else if(p->val !=q->val){\n            return false;\n        }\n        bool ans=true;\n        ans&=isSameTree(p->left,q->left);\n        ans&=isSameTree(p->right,q->right);\n        return ans;\n        \n    } "
                    },
                    {
                        "username": "Msey",
                        "content": "One-liner with one condition https://leetcode.com/problems/same-tree/solutions/3029022/c-one-liner-beats-99\n"
                    },
                    {
                        "username": "coder_for_sure",
                        "content": "this can be used as solution:-\\n`class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        return str(p) == str(q) `\\n     "
                    },
                    {
                        "username": "pawangupta",
                        "content": "Work it out for three use cases:\\n1. If both trees are empty, then it means both trees are same so return True.\\n2. If either of the tree is empty but the other tree is not empty, then both trees are not same so return False.\\n3. If both trees are non-empty, then check for the root value in both the trees. If the root value is same, then recursively check for the left subtrees in both trees and right subtrees in both the trees. If all node values are same, then they are same trees so return True."
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "Simply apply any of the traversal approach and check whether both the trees are equal or not .\\nif equal return true otherwise return false ."
                    },
                    {
                        "username": "neopraveen",
                        "content": "And here is an exact similar question what we solved yesterday. "
                    }
                ]
            },
            {
                "id": 1751067,
                "content": [
                    {
                        "username": "Islam_Mesabah",
                        "content": "\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if (p.val == q.val) return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n        return false;\n    }\n"
                    },
                    {
                        "username": "RashidAnsari",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // If both trees are null, they are the same\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        // If one tree is null and the other is not, they are not the same\\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        // If the values at the current nodes are not the same, the trees are not the same\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        // Recursively check the left and right subtrees\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n\\n\\nThis solution uses a recursive approach to check if the two trees are the same. It starts by checking if both trees are null, in which case they are considered to be the same. It then checks if one tree is null and the other is not, in which case they are considered to be different. If neither of these cases apply, it compares the values at the current nodes of the two trees. If they are not the same, the function returns false. If the values are the same, the function recursively checks the left and right subtrees of both trees. If both left subtrees and both right subtrees are the same, the function returns true. Otherwise, it returns false.\\n\\nThis solution has a time complexity of O(n) where n is the total number of nodes in the tree. The reason is that it needs to visit all nodes in the tree. Additionally, it has a space complexity of O(log n) in best case and O(n) in worst case, due to the depth of the recursion.\\n\\n\\n\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/same-tree/solutions/3028172/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "oxke",
                        "content": "how beautiful and satisfying is it to write\n`if (!p || !q) return p == q;`"
                    },
                    {
                        "username": "Prince__7",
                        "content": "C++ approach beats 100%\n\nbool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q){\n            return true;\n        }\n        else if(!p && q){\n            return false;\n        }\n        else if(p && !q){\n            return false;\n        }\n        else if(p->val !=q->val){\n            return false;\n        }\n        bool ans=true;\n        ans&=isSameTree(p->left,q->left);\n        ans&=isSameTree(p->right,q->right);\n        return ans;\n        \n    } "
                    },
                    {
                        "username": "Msey",
                        "content": "One-liner with one condition https://leetcode.com/problems/same-tree/solutions/3029022/c-one-liner-beats-99\n"
                    },
                    {
                        "username": "coder_for_sure",
                        "content": "this can be used as solution:-\\n`class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        return str(p) == str(q) `\\n     "
                    },
                    {
                        "username": "pawangupta",
                        "content": "Work it out for three use cases:\\n1. If both trees are empty, then it means both trees are same so return True.\\n2. If either of the tree is empty but the other tree is not empty, then both trees are not same so return False.\\n3. If both trees are non-empty, then check for the root value in both the trees. If the root value is same, then recursively check for the left subtrees in both trees and right subtrees in both the trees. If all node values are same, then they are same trees so return True."
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "Simply apply any of the traversal approach and check whether both the trees are equal or not .\\nif equal return true otherwise return false ."
                    },
                    {
                        "username": "neopraveen",
                        "content": "And here is an exact similar question what we solved yesterday. "
                    }
                ]
            },
            {
                "id": 1751003,
                "content": [
                    {
                        "username": "Islam_Mesabah",
                        "content": "\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if (p.val == q.val) return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n        return false;\n    }\n"
                    },
                    {
                        "username": "RashidAnsari",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // If both trees are null, they are the same\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        // If one tree is null and the other is not, they are not the same\\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        // If the values at the current nodes are not the same, the trees are not the same\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        // Recursively check the left and right subtrees\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n\\n\\nThis solution uses a recursive approach to check if the two trees are the same. It starts by checking if both trees are null, in which case they are considered to be the same. It then checks if one tree is null and the other is not, in which case they are considered to be different. If neither of these cases apply, it compares the values at the current nodes of the two trees. If they are not the same, the function returns false. If the values are the same, the function recursively checks the left and right subtrees of both trees. If both left subtrees and both right subtrees are the same, the function returns true. Otherwise, it returns false.\\n\\nThis solution has a time complexity of O(n) where n is the total number of nodes in the tree. The reason is that it needs to visit all nodes in the tree. Additionally, it has a space complexity of O(log n) in best case and O(n) in worst case, due to the depth of the recursion.\\n\\n\\n\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/same-tree/solutions/3028172/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "oxke",
                        "content": "how beautiful and satisfying is it to write\n`if (!p || !q) return p == q;`"
                    },
                    {
                        "username": "Prince__7",
                        "content": "C++ approach beats 100%\n\nbool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q){\n            return true;\n        }\n        else if(!p && q){\n            return false;\n        }\n        else if(p && !q){\n            return false;\n        }\n        else if(p->val !=q->val){\n            return false;\n        }\n        bool ans=true;\n        ans&=isSameTree(p->left,q->left);\n        ans&=isSameTree(p->right,q->right);\n        return ans;\n        \n    } "
                    },
                    {
                        "username": "Msey",
                        "content": "One-liner with one condition https://leetcode.com/problems/same-tree/solutions/3029022/c-one-liner-beats-99\n"
                    },
                    {
                        "username": "coder_for_sure",
                        "content": "this can be used as solution:-\\n`class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        return str(p) == str(q) `\\n     "
                    },
                    {
                        "username": "pawangupta",
                        "content": "Work it out for three use cases:\\n1. If both trees are empty, then it means both trees are same so return True.\\n2. If either of the tree is empty but the other tree is not empty, then both trees are not same so return False.\\n3. If both trees are non-empty, then check for the root value in both the trees. If the root value is same, then recursively check for the left subtrees in both trees and right subtrees in both the trees. If all node values are same, then they are same trees so return True."
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "Simply apply any of the traversal approach and check whether both the trees are equal or not .\\nif equal return true otherwise return false ."
                    },
                    {
                        "username": "neopraveen",
                        "content": "And here is an exact similar question what we solved yesterday. "
                    }
                ]
            },
            {
                "id": 1750994,
                "content": [
                    {
                        "username": "Islam_Mesabah",
                        "content": "\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if (p.val == q.val) return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n        return false;\n    }\n"
                    },
                    {
                        "username": "RashidAnsari",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // If both trees are null, they are the same\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        // If one tree is null and the other is not, they are not the same\\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        // If the values at the current nodes are not the same, the trees are not the same\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        // Recursively check the left and right subtrees\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n\\n\\nThis solution uses a recursive approach to check if the two trees are the same. It starts by checking if both trees are null, in which case they are considered to be the same. It then checks if one tree is null and the other is not, in which case they are considered to be different. If neither of these cases apply, it compares the values at the current nodes of the two trees. If they are not the same, the function returns false. If the values are the same, the function recursively checks the left and right subtrees of both trees. If both left subtrees and both right subtrees are the same, the function returns true. Otherwise, it returns false.\\n\\nThis solution has a time complexity of O(n) where n is the total number of nodes in the tree. The reason is that it needs to visit all nodes in the tree. Additionally, it has a space complexity of O(log n) in best case and O(n) in worst case, due to the depth of the recursion.\\n\\n\\n\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/same-tree/solutions/3028172/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "oxke",
                        "content": "how beautiful and satisfying is it to write\n`if (!p || !q) return p == q;`"
                    },
                    {
                        "username": "Prince__7",
                        "content": "C++ approach beats 100%\n\nbool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q){\n            return true;\n        }\n        else if(!p && q){\n            return false;\n        }\n        else if(p && !q){\n            return false;\n        }\n        else if(p->val !=q->val){\n            return false;\n        }\n        bool ans=true;\n        ans&=isSameTree(p->left,q->left);\n        ans&=isSameTree(p->right,q->right);\n        return ans;\n        \n    } "
                    },
                    {
                        "username": "Msey",
                        "content": "One-liner with one condition https://leetcode.com/problems/same-tree/solutions/3029022/c-one-liner-beats-99\n"
                    },
                    {
                        "username": "coder_for_sure",
                        "content": "this can be used as solution:-\\n`class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        return str(p) == str(q) `\\n     "
                    },
                    {
                        "username": "pawangupta",
                        "content": "Work it out for three use cases:\\n1. If both trees are empty, then it means both trees are same so return True.\\n2. If either of the tree is empty but the other tree is not empty, then both trees are not same so return False.\\n3. If both trees are non-empty, then check for the root value in both the trees. If the root value is same, then recursively check for the left subtrees in both trees and right subtrees in both the trees. If all node values are same, then they are same trees so return True."
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "Simply apply any of the traversal approach and check whether both the trees are equal or not .\\nif equal return true otherwise return false ."
                    },
                    {
                        "username": "neopraveen",
                        "content": "And here is an exact similar question what we solved yesterday. "
                    }
                ]
            },
            {
                "id": 1750940,
                "content": [
                    {
                        "username": "Islam_Mesabah",
                        "content": "\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if (p.val == q.val) return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n        return false;\n    }\n"
                    },
                    {
                        "username": "RashidAnsari",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // If both trees are null, they are the same\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        // If one tree is null and the other is not, they are not the same\\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        // If the values at the current nodes are not the same, the trees are not the same\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        // Recursively check the left and right subtrees\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n\\n\\nThis solution uses a recursive approach to check if the two trees are the same. It starts by checking if both trees are null, in which case they are considered to be the same. It then checks if one tree is null and the other is not, in which case they are considered to be different. If neither of these cases apply, it compares the values at the current nodes of the two trees. If they are not the same, the function returns false. If the values are the same, the function recursively checks the left and right subtrees of both trees. If both left subtrees and both right subtrees are the same, the function returns true. Otherwise, it returns false.\\n\\nThis solution has a time complexity of O(n) where n is the total number of nodes in the tree. The reason is that it needs to visit all nodes in the tree. Additionally, it has a space complexity of O(log n) in best case and O(n) in worst case, due to the depth of the recursion.\\n\\n\\n\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/same-tree/solutions/3028172/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "oxke",
                        "content": "how beautiful and satisfying is it to write\n`if (!p || !q) return p == q;`"
                    },
                    {
                        "username": "Prince__7",
                        "content": "C++ approach beats 100%\n\nbool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q){\n            return true;\n        }\n        else if(!p && q){\n            return false;\n        }\n        else if(p && !q){\n            return false;\n        }\n        else if(p->val !=q->val){\n            return false;\n        }\n        bool ans=true;\n        ans&=isSameTree(p->left,q->left);\n        ans&=isSameTree(p->right,q->right);\n        return ans;\n        \n    } "
                    },
                    {
                        "username": "Msey",
                        "content": "One-liner with one condition https://leetcode.com/problems/same-tree/solutions/3029022/c-one-liner-beats-99\n"
                    },
                    {
                        "username": "coder_for_sure",
                        "content": "this can be used as solution:-\\n`class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        return str(p) == str(q) `\\n     "
                    },
                    {
                        "username": "pawangupta",
                        "content": "Work it out for three use cases:\\n1. If both trees are empty, then it means both trees are same so return True.\\n2. If either of the tree is empty but the other tree is not empty, then both trees are not same so return False.\\n3. If both trees are non-empty, then check for the root value in both the trees. If the root value is same, then recursively check for the left subtrees in both trees and right subtrees in both the trees. If all node values are same, then they are same trees so return True."
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "Simply apply any of the traversal approach and check whether both the trees are equal or not .\\nif equal return true otherwise return false ."
                    },
                    {
                        "username": "neopraveen",
                        "content": "And here is an exact similar question what we solved yesterday. "
                    }
                ]
            },
            {
                "id": 1750912,
                "content": [
                    {
                        "username": "Islam_Mesabah",
                        "content": "\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if (p.val == q.val) return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n        return false;\n    }\n"
                    },
                    {
                        "username": "RashidAnsari",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // If both trees are null, they are the same\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        // If one tree is null and the other is not, they are not the same\\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        // If the values at the current nodes are not the same, the trees are not the same\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        // Recursively check the left and right subtrees\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n\\n\\nThis solution uses a recursive approach to check if the two trees are the same. It starts by checking if both trees are null, in which case they are considered to be the same. It then checks if one tree is null and the other is not, in which case they are considered to be different. If neither of these cases apply, it compares the values at the current nodes of the two trees. If they are not the same, the function returns false. If the values are the same, the function recursively checks the left and right subtrees of both trees. If both left subtrees and both right subtrees are the same, the function returns true. Otherwise, it returns false.\\n\\nThis solution has a time complexity of O(n) where n is the total number of nodes in the tree. The reason is that it needs to visit all nodes in the tree. Additionally, it has a space complexity of O(log n) in best case and O(n) in worst case, due to the depth of the recursion.\\n\\n\\n\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/same-tree/solutions/3028172/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "oxke",
                        "content": "how beautiful and satisfying is it to write\n`if (!p || !q) return p == q;`"
                    },
                    {
                        "username": "Prince__7",
                        "content": "C++ approach beats 100%\n\nbool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q){\n            return true;\n        }\n        else if(!p && q){\n            return false;\n        }\n        else if(p && !q){\n            return false;\n        }\n        else if(p->val !=q->val){\n            return false;\n        }\n        bool ans=true;\n        ans&=isSameTree(p->left,q->left);\n        ans&=isSameTree(p->right,q->right);\n        return ans;\n        \n    } "
                    },
                    {
                        "username": "Msey",
                        "content": "One-liner with one condition https://leetcode.com/problems/same-tree/solutions/3029022/c-one-liner-beats-99\n"
                    },
                    {
                        "username": "coder_for_sure",
                        "content": "this can be used as solution:-\\n`class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        return str(p) == str(q) `\\n     "
                    },
                    {
                        "username": "pawangupta",
                        "content": "Work it out for three use cases:\\n1. If both trees are empty, then it means both trees are same so return True.\\n2. If either of the tree is empty but the other tree is not empty, then both trees are not same so return False.\\n3. If both trees are non-empty, then check for the root value in both the trees. If the root value is same, then recursively check for the left subtrees in both trees and right subtrees in both the trees. If all node values are same, then they are same trees so return True."
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "Simply apply any of the traversal approach and check whether both the trees are equal or not .\\nif equal return true otherwise return false ."
                    },
                    {
                        "username": "neopraveen",
                        "content": "And here is an exact similar question what we solved yesterday. "
                    }
                ]
            },
            {
                "id": 1750873,
                "content": [
                    {
                        "username": "Islam_Mesabah",
                        "content": "\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if (p.val == q.val) return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n        return false;\n    }\n"
                    },
                    {
                        "username": "RashidAnsari",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // If both trees are null, they are the same\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        // If one tree is null and the other is not, they are not the same\\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        // If the values at the current nodes are not the same, the trees are not the same\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        // Recursively check the left and right subtrees\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n\\n\\nThis solution uses a recursive approach to check if the two trees are the same. It starts by checking if both trees are null, in which case they are considered to be the same. It then checks if one tree is null and the other is not, in which case they are considered to be different. If neither of these cases apply, it compares the values at the current nodes of the two trees. If they are not the same, the function returns false. If the values are the same, the function recursively checks the left and right subtrees of both trees. If both left subtrees and both right subtrees are the same, the function returns true. Otherwise, it returns false.\\n\\nThis solution has a time complexity of O(n) where n is the total number of nodes in the tree. The reason is that it needs to visit all nodes in the tree. Additionally, it has a space complexity of O(log n) in best case and O(n) in worst case, due to the depth of the recursion.\\n\\n\\n\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/same-tree/solutions/3028172/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "oxke",
                        "content": "how beautiful and satisfying is it to write\n`if (!p || !q) return p == q;`"
                    },
                    {
                        "username": "Prince__7",
                        "content": "C++ approach beats 100%\n\nbool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q){\n            return true;\n        }\n        else if(!p && q){\n            return false;\n        }\n        else if(p && !q){\n            return false;\n        }\n        else if(p->val !=q->val){\n            return false;\n        }\n        bool ans=true;\n        ans&=isSameTree(p->left,q->left);\n        ans&=isSameTree(p->right,q->right);\n        return ans;\n        \n    } "
                    },
                    {
                        "username": "Msey",
                        "content": "One-liner with one condition https://leetcode.com/problems/same-tree/solutions/3029022/c-one-liner-beats-99\n"
                    },
                    {
                        "username": "coder_for_sure",
                        "content": "this can be used as solution:-\\n`class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        return str(p) == str(q) `\\n     "
                    },
                    {
                        "username": "pawangupta",
                        "content": "Work it out for three use cases:\\n1. If both trees are empty, then it means both trees are same so return True.\\n2. If either of the tree is empty but the other tree is not empty, then both trees are not same so return False.\\n3. If both trees are non-empty, then check for the root value in both the trees. If the root value is same, then recursively check for the left subtrees in both trees and right subtrees in both the trees. If all node values are same, then they are same trees so return True."
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "Simply apply any of the traversal approach and check whether both the trees are equal or not .\\nif equal return true otherwise return false ."
                    },
                    {
                        "username": "neopraveen",
                        "content": "And here is an exact similar question what we solved yesterday. "
                    }
                ]
            },
            {
                "id": 1750872,
                "content": [
                    {
                        "username": "Islam_Mesabah",
                        "content": "\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if (p.val == q.val) return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n        return false;\n    }\n"
                    },
                    {
                        "username": "RashidAnsari",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n        // If both trees are null, they are the same\\n        if (p == null && q == null) {\\n            return true;\\n        }\\n        // If one tree is null and the other is not, they are not the same\\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        // If the values at the current nodes are not the same, the trees are not the same\\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        // Recursively check the left and right subtrees\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    }\\n}\\n\\n\\nThis solution uses a recursive approach to check if the two trees are the same. It starts by checking if both trees are null, in which case they are considered to be the same. It then checks if one tree is null and the other is not, in which case they are considered to be different. If neither of these cases apply, it compares the values at the current nodes of the two trees. If they are not the same, the function returns false. If the values are the same, the function recursively checks the left and right subtrees of both trees. If both left subtrees and both right subtrees are the same, the function returns true. Otherwise, it returns false.\\n\\nThis solution has a time complexity of O(n) where n is the total number of nodes in the tree. The reason is that it needs to visit all nodes in the tree. Additionally, it has a space complexity of O(log n) in best case and O(n) in worst case, due to the depth of the recursion.\\n\\n\\n\\n"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime || Easy to understand\\nhttps://leetcode.com/problems/same-tree/solutions/3028172/simple-java-0-ms-beats-100-runtime-easy-to-understand/"
                    },
                    {
                        "username": "oxke",
                        "content": "how beautiful and satisfying is it to write\n`if (!p || !q) return p == q;`"
                    },
                    {
                        "username": "Prince__7",
                        "content": "C++ approach beats 100%\n\nbool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q){\n            return true;\n        }\n        else if(!p && q){\n            return false;\n        }\n        else if(p && !q){\n            return false;\n        }\n        else if(p->val !=q->val){\n            return false;\n        }\n        bool ans=true;\n        ans&=isSameTree(p->left,q->left);\n        ans&=isSameTree(p->right,q->right);\n        return ans;\n        \n    } "
                    },
                    {
                        "username": "Msey",
                        "content": "One-liner with one condition https://leetcode.com/problems/same-tree/solutions/3029022/c-one-liner-beats-99\n"
                    },
                    {
                        "username": "coder_for_sure",
                        "content": "this can be used as solution:-\\n`class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        return str(p) == str(q) `\\n     "
                    },
                    {
                        "username": "pawangupta",
                        "content": "Work it out for three use cases:\\n1. If both trees are empty, then it means both trees are same so return True.\\n2. If either of the tree is empty but the other tree is not empty, then both trees are not same so return False.\\n3. If both trees are non-empty, then check for the root value in both the trees. If the root value is same, then recursively check for the left subtrees in both trees and right subtrees in both the trees. If all node values are same, then they are same trees so return True."
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "Simply apply any of the traversal approach and check whether both the trees are equal or not .\\nif equal return true otherwise return false ."
                    },
                    {
                        "username": "neopraveen",
                        "content": "And here is an exact similar question what we solved yesterday. "
                    }
                ]
            },
            {
                "id": 1750863,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "check if value in two root nodes is same or not, \\nif not same return false \\nelse go to left node and right node.\\n\\ndo this process till both or one of the root is null.\\n\\nreturn true if both roots are null,\\notherwise return false.\\n"
                    },
                    {
                        "username": "de-pesh",
                        "content": "short  C++  solution \\n`if(p == nullptr || q == nullptr) `\\n `         return (p == q);`\\n `return ((p->val == q->val) && (isSameTree(p->left, q->left)) && isSameTree(p->right, q->right));`"
                    },
                    {
                        "username": "biswa1947",
                        "content": "there can be 2 scenarios -\\n1)both roots have same value then we will check two left subtrees and two right subtrees recursively ,whether they are equal or not.\\n2)both roots are null ,that is base case we should return true.\\n2)  one of the root is null but other one is not, that is another base case in that case we should return false.\\nmy java code \\n if(p==null ) return q==null;\\n else if(q==null) return p==null;        \\nreturn (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);"
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of way to iterate over both tree at the same time through recursion."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-10 10.33.56.jpg](https://assets.leetcode.com/users/images/15f86bb6-0c17-401f-8fbe-6dbba291dbc4_1673328972.3129807.jpeg)\\n"
                    },
                    {
                        "username": "qazwsx92284",
                        "content": "For someone who is looking for the hints, think about the cases where it should return true and false. Obviously we need to check if they have the same value of the node. But before we check the node.val, we need to check if it is null or not (might throw null pointer exception). And think of cases when one node is null. should it always return false? or it depends on the corresponding node of the other tree?"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p and q:\\n\\t        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Leetcode is apologizing by giving 2 Consecutive days of easy  problems to make up for one weird problem (Max points on line)"
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "1. Check if both the roots are null. If they are, then return true.\n2. If one of them is null then return false.\n3. Check if the values of the current roots are same. return true/false accordingly.\n4. Call the same function for left and right sub-trees of both the roots recursively."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Pretty trivial if your language supports comparing structures by values..."
                    }
                ]
            },
            {
                "id": 1750853,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "check if value in two root nodes is same or not, \\nif not same return false \\nelse go to left node and right node.\\n\\ndo this process till both or one of the root is null.\\n\\nreturn true if both roots are null,\\notherwise return false.\\n"
                    },
                    {
                        "username": "de-pesh",
                        "content": "short  C++  solution \\n`if(p == nullptr || q == nullptr) `\\n `         return (p == q);`\\n `return ((p->val == q->val) && (isSameTree(p->left, q->left)) && isSameTree(p->right, q->right));`"
                    },
                    {
                        "username": "biswa1947",
                        "content": "there can be 2 scenarios -\\n1)both roots have same value then we will check two left subtrees and two right subtrees recursively ,whether they are equal or not.\\n2)both roots are null ,that is base case we should return true.\\n2)  one of the root is null but other one is not, that is another base case in that case we should return false.\\nmy java code \\n if(p==null ) return q==null;\\n else if(q==null) return p==null;        \\nreturn (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);"
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of way to iterate over both tree at the same time through recursion."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-10 10.33.56.jpg](https://assets.leetcode.com/users/images/15f86bb6-0c17-401f-8fbe-6dbba291dbc4_1673328972.3129807.jpeg)\\n"
                    },
                    {
                        "username": "qazwsx92284",
                        "content": "For someone who is looking for the hints, think about the cases where it should return true and false. Obviously we need to check if they have the same value of the node. But before we check the node.val, we need to check if it is null or not (might throw null pointer exception). And think of cases when one node is null. should it always return false? or it depends on the corresponding node of the other tree?"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p and q:\\n\\t        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Leetcode is apologizing by giving 2 Consecutive days of easy  problems to make up for one weird problem (Max points on line)"
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "1. Check if both the roots are null. If they are, then return true.\n2. If one of them is null then return false.\n3. Check if the values of the current roots are same. return true/false accordingly.\n4. Call the same function for left and right sub-trees of both the roots recursively."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Pretty trivial if your language supports comparing structures by values..."
                    }
                ]
            },
            {
                "id": 1750781,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "check if value in two root nodes is same or not, \\nif not same return false \\nelse go to left node and right node.\\n\\ndo this process till both or one of the root is null.\\n\\nreturn true if both roots are null,\\notherwise return false.\\n"
                    },
                    {
                        "username": "de-pesh",
                        "content": "short  C++  solution \\n`if(p == nullptr || q == nullptr) `\\n `         return (p == q);`\\n `return ((p->val == q->val) && (isSameTree(p->left, q->left)) && isSameTree(p->right, q->right));`"
                    },
                    {
                        "username": "biswa1947",
                        "content": "there can be 2 scenarios -\\n1)both roots have same value then we will check two left subtrees and two right subtrees recursively ,whether they are equal or not.\\n2)both roots are null ,that is base case we should return true.\\n2)  one of the root is null but other one is not, that is another base case in that case we should return false.\\nmy java code \\n if(p==null ) return q==null;\\n else if(q==null) return p==null;        \\nreturn (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);"
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of way to iterate over both tree at the same time through recursion."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-10 10.33.56.jpg](https://assets.leetcode.com/users/images/15f86bb6-0c17-401f-8fbe-6dbba291dbc4_1673328972.3129807.jpeg)\\n"
                    },
                    {
                        "username": "qazwsx92284",
                        "content": "For someone who is looking for the hints, think about the cases where it should return true and false. Obviously we need to check if they have the same value of the node. But before we check the node.val, we need to check if it is null or not (might throw null pointer exception). And think of cases when one node is null. should it always return false? or it depends on the corresponding node of the other tree?"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p and q:\\n\\t        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Leetcode is apologizing by giving 2 Consecutive days of easy  problems to make up for one weird problem (Max points on line)"
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "1. Check if both the roots are null. If they are, then return true.\n2. If one of them is null then return false.\n3. Check if the values of the current roots are same. return true/false accordingly.\n4. Call the same function for left and right sub-trees of both the roots recursively."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Pretty trivial if your language supports comparing structures by values..."
                    }
                ]
            },
            {
                "id": 1750710,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "check if value in two root nodes is same or not, \\nif not same return false \\nelse go to left node and right node.\\n\\ndo this process till both or one of the root is null.\\n\\nreturn true if both roots are null,\\notherwise return false.\\n"
                    },
                    {
                        "username": "de-pesh",
                        "content": "short  C++  solution \\n`if(p == nullptr || q == nullptr) `\\n `         return (p == q);`\\n `return ((p->val == q->val) && (isSameTree(p->left, q->left)) && isSameTree(p->right, q->right));`"
                    },
                    {
                        "username": "biswa1947",
                        "content": "there can be 2 scenarios -\\n1)both roots have same value then we will check two left subtrees and two right subtrees recursively ,whether they are equal or not.\\n2)both roots are null ,that is base case we should return true.\\n2)  one of the root is null but other one is not, that is another base case in that case we should return false.\\nmy java code \\n if(p==null ) return q==null;\\n else if(q==null) return p==null;        \\nreturn (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);"
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of way to iterate over both tree at the same time through recursion."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-10 10.33.56.jpg](https://assets.leetcode.com/users/images/15f86bb6-0c17-401f-8fbe-6dbba291dbc4_1673328972.3129807.jpeg)\\n"
                    },
                    {
                        "username": "qazwsx92284",
                        "content": "For someone who is looking for the hints, think about the cases where it should return true and false. Obviously we need to check if they have the same value of the node. But before we check the node.val, we need to check if it is null or not (might throw null pointer exception). And think of cases when one node is null. should it always return false? or it depends on the corresponding node of the other tree?"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p and q:\\n\\t        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Leetcode is apologizing by giving 2 Consecutive days of easy  problems to make up for one weird problem (Max points on line)"
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "1. Check if both the roots are null. If they are, then return true.\n2. If one of them is null then return false.\n3. Check if the values of the current roots are same. return true/false accordingly.\n4. Call the same function for left and right sub-trees of both the roots recursively."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Pretty trivial if your language supports comparing structures by values..."
                    }
                ]
            },
            {
                "id": 1750704,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "check if value in two root nodes is same or not, \\nif not same return false \\nelse go to left node and right node.\\n\\ndo this process till both or one of the root is null.\\n\\nreturn true if both roots are null,\\notherwise return false.\\n"
                    },
                    {
                        "username": "de-pesh",
                        "content": "short  C++  solution \\n`if(p == nullptr || q == nullptr) `\\n `         return (p == q);`\\n `return ((p->val == q->val) && (isSameTree(p->left, q->left)) && isSameTree(p->right, q->right));`"
                    },
                    {
                        "username": "biswa1947",
                        "content": "there can be 2 scenarios -\\n1)both roots have same value then we will check two left subtrees and two right subtrees recursively ,whether they are equal or not.\\n2)both roots are null ,that is base case we should return true.\\n2)  one of the root is null but other one is not, that is another base case in that case we should return false.\\nmy java code \\n if(p==null ) return q==null;\\n else if(q==null) return p==null;        \\nreturn (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);"
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of way to iterate over both tree at the same time through recursion."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-10 10.33.56.jpg](https://assets.leetcode.com/users/images/15f86bb6-0c17-401f-8fbe-6dbba291dbc4_1673328972.3129807.jpeg)\\n"
                    },
                    {
                        "username": "qazwsx92284",
                        "content": "For someone who is looking for the hints, think about the cases where it should return true and false. Obviously we need to check if they have the same value of the node. But before we check the node.val, we need to check if it is null or not (might throw null pointer exception). And think of cases when one node is null. should it always return false? or it depends on the corresponding node of the other tree?"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p and q:\\n\\t        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Leetcode is apologizing by giving 2 Consecutive days of easy  problems to make up for one weird problem (Max points on line)"
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "1. Check if both the roots are null. If they are, then return true.\n2. If one of them is null then return false.\n3. Check if the values of the current roots are same. return true/false accordingly.\n4. Call the same function for left and right sub-trees of both the roots recursively."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Pretty trivial if your language supports comparing structures by values..."
                    }
                ]
            },
            {
                "id": 1750662,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "check if value in two root nodes is same or not, \\nif not same return false \\nelse go to left node and right node.\\n\\ndo this process till both or one of the root is null.\\n\\nreturn true if both roots are null,\\notherwise return false.\\n"
                    },
                    {
                        "username": "de-pesh",
                        "content": "short  C++  solution \\n`if(p == nullptr || q == nullptr) `\\n `         return (p == q);`\\n `return ((p->val == q->val) && (isSameTree(p->left, q->left)) && isSameTree(p->right, q->right));`"
                    },
                    {
                        "username": "biswa1947",
                        "content": "there can be 2 scenarios -\\n1)both roots have same value then we will check two left subtrees and two right subtrees recursively ,whether they are equal or not.\\n2)both roots are null ,that is base case we should return true.\\n2)  one of the root is null but other one is not, that is another base case in that case we should return false.\\nmy java code \\n if(p==null ) return q==null;\\n else if(q==null) return p==null;        \\nreturn (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);"
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of way to iterate over both tree at the same time through recursion."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-10 10.33.56.jpg](https://assets.leetcode.com/users/images/15f86bb6-0c17-401f-8fbe-6dbba291dbc4_1673328972.3129807.jpeg)\\n"
                    },
                    {
                        "username": "qazwsx92284",
                        "content": "For someone who is looking for the hints, think about the cases where it should return true and false. Obviously we need to check if they have the same value of the node. But before we check the node.val, we need to check if it is null or not (might throw null pointer exception). And think of cases when one node is null. should it always return false? or it depends on the corresponding node of the other tree?"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p and q:\\n\\t        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Leetcode is apologizing by giving 2 Consecutive days of easy  problems to make up for one weird problem (Max points on line)"
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "1. Check if both the roots are null. If they are, then return true.\n2. If one of them is null then return false.\n3. Check if the values of the current roots are same. return true/false accordingly.\n4. Call the same function for left and right sub-trees of both the roots recursively."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Pretty trivial if your language supports comparing structures by values..."
                    }
                ]
            },
            {
                "id": 1750655,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "check if value in two root nodes is same or not, \\nif not same return false \\nelse go to left node and right node.\\n\\ndo this process till both or one of the root is null.\\n\\nreturn true if both roots are null,\\notherwise return false.\\n"
                    },
                    {
                        "username": "de-pesh",
                        "content": "short  C++  solution \\n`if(p == nullptr || q == nullptr) `\\n `         return (p == q);`\\n `return ((p->val == q->val) && (isSameTree(p->left, q->left)) && isSameTree(p->right, q->right));`"
                    },
                    {
                        "username": "biswa1947",
                        "content": "there can be 2 scenarios -\\n1)both roots have same value then we will check two left subtrees and two right subtrees recursively ,whether they are equal or not.\\n2)both roots are null ,that is base case we should return true.\\n2)  one of the root is null but other one is not, that is another base case in that case we should return false.\\nmy java code \\n if(p==null ) return q==null;\\n else if(q==null) return p==null;        \\nreturn (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);"
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of way to iterate over both tree at the same time through recursion."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-10 10.33.56.jpg](https://assets.leetcode.com/users/images/15f86bb6-0c17-401f-8fbe-6dbba291dbc4_1673328972.3129807.jpeg)\\n"
                    },
                    {
                        "username": "qazwsx92284",
                        "content": "For someone who is looking for the hints, think about the cases where it should return true and false. Obviously we need to check if they have the same value of the node. But before we check the node.val, we need to check if it is null or not (might throw null pointer exception). And think of cases when one node is null. should it always return false? or it depends on the corresponding node of the other tree?"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p and q:\\n\\t        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Leetcode is apologizing by giving 2 Consecutive days of easy  problems to make up for one weird problem (Max points on line)"
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "1. Check if both the roots are null. If they are, then return true.\n2. If one of them is null then return false.\n3. Check if the values of the current roots are same. return true/false accordingly.\n4. Call the same function for left and right sub-trees of both the roots recursively."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Pretty trivial if your language supports comparing structures by values..."
                    }
                ]
            },
            {
                "id": 1750631,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "check if value in two root nodes is same or not, \\nif not same return false \\nelse go to left node and right node.\\n\\ndo this process till both or one of the root is null.\\n\\nreturn true if both roots are null,\\notherwise return false.\\n"
                    },
                    {
                        "username": "de-pesh",
                        "content": "short  C++  solution \\n`if(p == nullptr || q == nullptr) `\\n `         return (p == q);`\\n `return ((p->val == q->val) && (isSameTree(p->left, q->left)) && isSameTree(p->right, q->right));`"
                    },
                    {
                        "username": "biswa1947",
                        "content": "there can be 2 scenarios -\\n1)both roots have same value then we will check two left subtrees and two right subtrees recursively ,whether they are equal or not.\\n2)both roots are null ,that is base case we should return true.\\n2)  one of the root is null but other one is not, that is another base case in that case we should return false.\\nmy java code \\n if(p==null ) return q==null;\\n else if(q==null) return p==null;        \\nreturn (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);"
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of way to iterate over both tree at the same time through recursion."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-10 10.33.56.jpg](https://assets.leetcode.com/users/images/15f86bb6-0c17-401f-8fbe-6dbba291dbc4_1673328972.3129807.jpeg)\\n"
                    },
                    {
                        "username": "qazwsx92284",
                        "content": "For someone who is looking for the hints, think about the cases where it should return true and false. Obviously we need to check if they have the same value of the node. But before we check the node.val, we need to check if it is null or not (might throw null pointer exception). And think of cases when one node is null. should it always return false? or it depends on the corresponding node of the other tree?"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p and q:\\n\\t        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Leetcode is apologizing by giving 2 Consecutive days of easy  problems to make up for one weird problem (Max points on line)"
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "1. Check if both the roots are null. If they are, then return true.\n2. If one of them is null then return false.\n3. Check if the values of the current roots are same. return true/false accordingly.\n4. Call the same function for left and right sub-trees of both the roots recursively."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Pretty trivial if your language supports comparing structures by values..."
                    }
                ]
            },
            {
                "id": 1750572,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "check if value in two root nodes is same or not, \\nif not same return false \\nelse go to left node and right node.\\n\\ndo this process till both or one of the root is null.\\n\\nreturn true if both roots are null,\\notherwise return false.\\n"
                    },
                    {
                        "username": "de-pesh",
                        "content": "short  C++  solution \\n`if(p == nullptr || q == nullptr) `\\n `         return (p == q);`\\n `return ((p->val == q->val) && (isSameTree(p->left, q->left)) && isSameTree(p->right, q->right));`"
                    },
                    {
                        "username": "biswa1947",
                        "content": "there can be 2 scenarios -\\n1)both roots have same value then we will check two left subtrees and two right subtrees recursively ,whether they are equal or not.\\n2)both roots are null ,that is base case we should return true.\\n2)  one of the root is null but other one is not, that is another base case in that case we should return false.\\nmy java code \\n if(p==null ) return q==null;\\n else if(q==null) return p==null;        \\nreturn (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);"
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of way to iterate over both tree at the same time through recursion."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-10 10.33.56.jpg](https://assets.leetcode.com/users/images/15f86bb6-0c17-401f-8fbe-6dbba291dbc4_1673328972.3129807.jpeg)\\n"
                    },
                    {
                        "username": "qazwsx92284",
                        "content": "For someone who is looking for the hints, think about the cases where it should return true and false. Obviously we need to check if they have the same value of the node. But before we check the node.val, we need to check if it is null or not (might throw null pointer exception). And think of cases when one node is null. should it always return false? or it depends on the corresponding node of the other tree?"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p and q:\\n\\t        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Leetcode is apologizing by giving 2 Consecutive days of easy  problems to make up for one weird problem (Max points on line)"
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "1. Check if both the roots are null. If they are, then return true.\n2. If one of them is null then return false.\n3. Check if the values of the current roots are same. return true/false accordingly.\n4. Call the same function for left and right sub-trees of both the roots recursively."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Pretty trivial if your language supports comparing structures by values..."
                    }
                ]
            },
            {
                "id": 1750559,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "check if value in two root nodes is same or not, \\nif not same return false \\nelse go to left node and right node.\\n\\ndo this process till both or one of the root is null.\\n\\nreturn true if both roots are null,\\notherwise return false.\\n"
                    },
                    {
                        "username": "de-pesh",
                        "content": "short  C++  solution \\n`if(p == nullptr || q == nullptr) `\\n `         return (p == q);`\\n `return ((p->val == q->val) && (isSameTree(p->left, q->left)) && isSameTree(p->right, q->right));`"
                    },
                    {
                        "username": "biswa1947",
                        "content": "there can be 2 scenarios -\\n1)both roots have same value then we will check two left subtrees and two right subtrees recursively ,whether they are equal or not.\\n2)both roots are null ,that is base case we should return true.\\n2)  one of the root is null but other one is not, that is another base case in that case we should return false.\\nmy java code \\n if(p==null ) return q==null;\\n else if(q==null) return p==null;        \\nreturn (p.val==q.val) && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);"
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of way to iterate over both tree at the same time through recursion."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-10 10.33.56.jpg](https://assets.leetcode.com/users/images/15f86bb6-0c17-401f-8fbe-6dbba291dbc4_1673328972.3129807.jpeg)\\n"
                    },
                    {
                        "username": "qazwsx92284",
                        "content": "For someone who is looking for the hints, think about the cases where it should return true and false. Obviously we need to check if they have the same value of the node. But before we check the node.val, we need to check if it is null or not (might throw null pointer exception). And think of cases when one node is null. should it always return false? or it depends on the corresponding node of the other tree?"
                    },
                    {
                        "username": "gecjmanish",
                        "content": "class Solution:\\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\\n        if p and q:\\n\\t        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n        return p is q"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Leetcode is apologizing by giving 2 Consecutive days of easy  problems to make up for one weird problem (Max points on line)"
                    },
                    {
                        "username": "manishrasal2000",
                        "content": "1. Check if both the roots are null. If they are, then return true.\n2. If one of them is null then return false.\n3. Check if the values of the current roots are same. return true/false accordingly.\n4. Call the same function for left and right sub-trees of both the roots recursively."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Pretty trivial if your language supports comparing structures by values..."
                    }
                ]
            },
            {
                "id": 1750533,
                "content": [
                    {
                        "username": "mkprajapati1614",
                        "content": "Only 4 conditions seems to be important here\\n1st -> when (p == NULL && q == NULL) return TRUE;  (because both nodes are same)\\n2nd-> when ( (p==NULL && q!=NULL) `||` (q==NULL && p!=NULL) `||` (p!=NULL && q!=NULL && p->val != q->val) return FALSE\\n\\n`p==NULL && q!=NULL`   ... p is pointing to NULL but q is pointing to some valid node\\n`q==NULL && p!=NULL`   ... p is pointing to some valid node but q is NULL\\n`p!=NULL && q!=NULL && p->val != q->val`   ... both p and q are pointing to valid node but the values are different."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "Why does python speed have a very wide range, same code but very inconsistent speed, why?"
                    },
                    {
                        "username": "hemasai",
                        "content": "can\\'t we use traversal and compare the traversal arrays or list?\\n"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: Same trees has same left sub tree and right sub tree, and same root!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Are isSameTree and isSubtree Problem codes similar?\\nDid you find this!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it can be one liner \\uD83D\\uDE01\\nneed an idea, post a query pls.."
                    },
                    {
                        "username": "XiaoChow",
                        "content": "Kotlin one line:\\n```\\n    fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean {\\n        return p==q || p?.`val` == q?.`val` && isSameTree(p?.left, q?.left) && isSameTree(p?.right, q?.right)         \\n    }\\n```"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Check if nodes have the same value and also same no of nodes in both trees recusively"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Easy peasy leetcode days!!"
                    },
                    {
                        "username": "yusseef",
                        "content": "Hint:\\nIf both trees are empty they are the same tree.\\n\\nPut this condition on:\\n `if not p and not q:\\n         return True`\\n"
                    }
                ]
            },
            {
                "id": 1750512,
                "content": [
                    {
                        "username": "mkprajapati1614",
                        "content": "Only 4 conditions seems to be important here\\n1st -> when (p == NULL && q == NULL) return TRUE;  (because both nodes are same)\\n2nd-> when ( (p==NULL && q!=NULL) `||` (q==NULL && p!=NULL) `||` (p!=NULL && q!=NULL && p->val != q->val) return FALSE\\n\\n`p==NULL && q!=NULL`   ... p is pointing to NULL but q is pointing to some valid node\\n`q==NULL && p!=NULL`   ... p is pointing to some valid node but q is NULL\\n`p!=NULL && q!=NULL && p->val != q->val`   ... both p and q are pointing to valid node but the values are different."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "Why does python speed have a very wide range, same code but very inconsistent speed, why?"
                    },
                    {
                        "username": "hemasai",
                        "content": "can\\'t we use traversal and compare the traversal arrays or list?\\n"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: Same trees has same left sub tree and right sub tree, and same root!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Are isSameTree and isSubtree Problem codes similar?\\nDid you find this!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it can be one liner \\uD83D\\uDE01\\nneed an idea, post a query pls.."
                    },
                    {
                        "username": "XiaoChow",
                        "content": "Kotlin one line:\\n```\\n    fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean {\\n        return p==q || p?.`val` == q?.`val` && isSameTree(p?.left, q?.left) && isSameTree(p?.right, q?.right)         \\n    }\\n```"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Check if nodes have the same value and also same no of nodes in both trees recusively"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Easy peasy leetcode days!!"
                    },
                    {
                        "username": "yusseef",
                        "content": "Hint:\\nIf both trees are empty they are the same tree.\\n\\nPut this condition on:\\n `if not p and not q:\\n         return True`\\n"
                    }
                ]
            },
            {
                "id": 1750508,
                "content": [
                    {
                        "username": "mkprajapati1614",
                        "content": "Only 4 conditions seems to be important here\\n1st -> when (p == NULL && q == NULL) return TRUE;  (because both nodes are same)\\n2nd-> when ( (p==NULL && q!=NULL) `||` (q==NULL && p!=NULL) `||` (p!=NULL && q!=NULL && p->val != q->val) return FALSE\\n\\n`p==NULL && q!=NULL`   ... p is pointing to NULL but q is pointing to some valid node\\n`q==NULL && p!=NULL`   ... p is pointing to some valid node but q is NULL\\n`p!=NULL && q!=NULL && p->val != q->val`   ... both p and q are pointing to valid node but the values are different."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "Why does python speed have a very wide range, same code but very inconsistent speed, why?"
                    },
                    {
                        "username": "hemasai",
                        "content": "can\\'t we use traversal and compare the traversal arrays or list?\\n"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: Same trees has same left sub tree and right sub tree, and same root!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Are isSameTree and isSubtree Problem codes similar?\\nDid you find this!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it can be one liner \\uD83D\\uDE01\\nneed an idea, post a query pls.."
                    },
                    {
                        "username": "XiaoChow",
                        "content": "Kotlin one line:\\n```\\n    fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean {\\n        return p==q || p?.`val` == q?.`val` && isSameTree(p?.left, q?.left) && isSameTree(p?.right, q?.right)         \\n    }\\n```"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Check if nodes have the same value and also same no of nodes in both trees recusively"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Easy peasy leetcode days!!"
                    },
                    {
                        "username": "yusseef",
                        "content": "Hint:\\nIf both trees are empty they are the same tree.\\n\\nPut this condition on:\\n `if not p and not q:\\n         return True`\\n"
                    }
                ]
            },
            {
                "id": 1750501,
                "content": [
                    {
                        "username": "mkprajapati1614",
                        "content": "Only 4 conditions seems to be important here\\n1st -> when (p == NULL && q == NULL) return TRUE;  (because both nodes are same)\\n2nd-> when ( (p==NULL && q!=NULL) `||` (q==NULL && p!=NULL) `||` (p!=NULL && q!=NULL && p->val != q->val) return FALSE\\n\\n`p==NULL && q!=NULL`   ... p is pointing to NULL but q is pointing to some valid node\\n`q==NULL && p!=NULL`   ... p is pointing to some valid node but q is NULL\\n`p!=NULL && q!=NULL && p->val != q->val`   ... both p and q are pointing to valid node but the values are different."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "Why does python speed have a very wide range, same code but very inconsistent speed, why?"
                    },
                    {
                        "username": "hemasai",
                        "content": "can\\'t we use traversal and compare the traversal arrays or list?\\n"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: Same trees has same left sub tree and right sub tree, and same root!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Are isSameTree and isSubtree Problem codes similar?\\nDid you find this!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it can be one liner \\uD83D\\uDE01\\nneed an idea, post a query pls.."
                    },
                    {
                        "username": "XiaoChow",
                        "content": "Kotlin one line:\\n```\\n    fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean {\\n        return p==q || p?.`val` == q?.`val` && isSameTree(p?.left, q?.left) && isSameTree(p?.right, q?.right)         \\n    }\\n```"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Check if nodes have the same value and also same no of nodes in both trees recusively"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Easy peasy leetcode days!!"
                    },
                    {
                        "username": "yusseef",
                        "content": "Hint:\\nIf both trees are empty they are the same tree.\\n\\nPut this condition on:\\n `if not p and not q:\\n         return True`\\n"
                    }
                ]
            },
            {
                "id": 1750489,
                "content": [
                    {
                        "username": "mkprajapati1614",
                        "content": "Only 4 conditions seems to be important here\\n1st -> when (p == NULL && q == NULL) return TRUE;  (because both nodes are same)\\n2nd-> when ( (p==NULL && q!=NULL) `||` (q==NULL && p!=NULL) `||` (p!=NULL && q!=NULL && p->val != q->val) return FALSE\\n\\n`p==NULL && q!=NULL`   ... p is pointing to NULL but q is pointing to some valid node\\n`q==NULL && p!=NULL`   ... p is pointing to some valid node but q is NULL\\n`p!=NULL && q!=NULL && p->val != q->val`   ... both p and q are pointing to valid node but the values are different."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "Why does python speed have a very wide range, same code but very inconsistent speed, why?"
                    },
                    {
                        "username": "hemasai",
                        "content": "can\\'t we use traversal and compare the traversal arrays or list?\\n"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: Same trees has same left sub tree and right sub tree, and same root!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Are isSameTree and isSubtree Problem codes similar?\\nDid you find this!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it can be one liner \\uD83D\\uDE01\\nneed an idea, post a query pls.."
                    },
                    {
                        "username": "XiaoChow",
                        "content": "Kotlin one line:\\n```\\n    fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean {\\n        return p==q || p?.`val` == q?.`val` && isSameTree(p?.left, q?.left) && isSameTree(p?.right, q?.right)         \\n    }\\n```"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Check if nodes have the same value and also same no of nodes in both trees recusively"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Easy peasy leetcode days!!"
                    },
                    {
                        "username": "yusseef",
                        "content": "Hint:\\nIf both trees are empty they are the same tree.\\n\\nPut this condition on:\\n `if not p and not q:\\n         return True`\\n"
                    }
                ]
            },
            {
                "id": 1750472,
                "content": [
                    {
                        "username": "mkprajapati1614",
                        "content": "Only 4 conditions seems to be important here\\n1st -> when (p == NULL && q == NULL) return TRUE;  (because both nodes are same)\\n2nd-> when ( (p==NULL && q!=NULL) `||` (q==NULL && p!=NULL) `||` (p!=NULL && q!=NULL && p->val != q->val) return FALSE\\n\\n`p==NULL && q!=NULL`   ... p is pointing to NULL but q is pointing to some valid node\\n`q==NULL && p!=NULL`   ... p is pointing to some valid node but q is NULL\\n`p!=NULL && q!=NULL && p->val != q->val`   ... both p and q are pointing to valid node but the values are different."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "Why does python speed have a very wide range, same code but very inconsistent speed, why?"
                    },
                    {
                        "username": "hemasai",
                        "content": "can\\'t we use traversal and compare the traversal arrays or list?\\n"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: Same trees has same left sub tree and right sub tree, and same root!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Are isSameTree and isSubtree Problem codes similar?\\nDid you find this!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it can be one liner \\uD83D\\uDE01\\nneed an idea, post a query pls.."
                    },
                    {
                        "username": "XiaoChow",
                        "content": "Kotlin one line:\\n```\\n    fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean {\\n        return p==q || p?.`val` == q?.`val` && isSameTree(p?.left, q?.left) && isSameTree(p?.right, q?.right)         \\n    }\\n```"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Check if nodes have the same value and also same no of nodes in both trees recusively"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Easy peasy leetcode days!!"
                    },
                    {
                        "username": "yusseef",
                        "content": "Hint:\\nIf both trees are empty they are the same tree.\\n\\nPut this condition on:\\n `if not p and not q:\\n         return True`\\n"
                    }
                ]
            },
            {
                "id": 1750432,
                "content": [
                    {
                        "username": "mkprajapati1614",
                        "content": "Only 4 conditions seems to be important here\\n1st -> when (p == NULL && q == NULL) return TRUE;  (because both nodes are same)\\n2nd-> when ( (p==NULL && q!=NULL) `||` (q==NULL && p!=NULL) `||` (p!=NULL && q!=NULL && p->val != q->val) return FALSE\\n\\n`p==NULL && q!=NULL`   ... p is pointing to NULL but q is pointing to some valid node\\n`q==NULL && p!=NULL`   ... p is pointing to some valid node but q is NULL\\n`p!=NULL && q!=NULL && p->val != q->val`   ... both p and q are pointing to valid node but the values are different."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "Why does python speed have a very wide range, same code but very inconsistent speed, why?"
                    },
                    {
                        "username": "hemasai",
                        "content": "can\\'t we use traversal and compare the traversal arrays or list?\\n"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: Same trees has same left sub tree and right sub tree, and same root!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Are isSameTree and isSubtree Problem codes similar?\\nDid you find this!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it can be one liner \\uD83D\\uDE01\\nneed an idea, post a query pls.."
                    },
                    {
                        "username": "XiaoChow",
                        "content": "Kotlin one line:\\n```\\n    fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean {\\n        return p==q || p?.`val` == q?.`val` && isSameTree(p?.left, q?.left) && isSameTree(p?.right, q?.right)         \\n    }\\n```"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Check if nodes have the same value and also same no of nodes in both trees recusively"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Easy peasy leetcode days!!"
                    },
                    {
                        "username": "yusseef",
                        "content": "Hint:\\nIf both trees are empty they are the same tree.\\n\\nPut this condition on:\\n `if not p and not q:\\n         return True`\\n"
                    }
                ]
            },
            {
                "id": 1750386,
                "content": [
                    {
                        "username": "mkprajapati1614",
                        "content": "Only 4 conditions seems to be important here\\n1st -> when (p == NULL && q == NULL) return TRUE;  (because both nodes are same)\\n2nd-> when ( (p==NULL && q!=NULL) `||` (q==NULL && p!=NULL) `||` (p!=NULL && q!=NULL && p->val != q->val) return FALSE\\n\\n`p==NULL && q!=NULL`   ... p is pointing to NULL but q is pointing to some valid node\\n`q==NULL && p!=NULL`   ... p is pointing to some valid node but q is NULL\\n`p!=NULL && q!=NULL && p->val != q->val`   ... both p and q are pointing to valid node but the values are different."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "Why does python speed have a very wide range, same code but very inconsistent speed, why?"
                    },
                    {
                        "username": "hemasai",
                        "content": "can\\'t we use traversal and compare the traversal arrays or list?\\n"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: Same trees has same left sub tree and right sub tree, and same root!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Are isSameTree and isSubtree Problem codes similar?\\nDid you find this!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it can be one liner \\uD83D\\uDE01\\nneed an idea, post a query pls.."
                    },
                    {
                        "username": "XiaoChow",
                        "content": "Kotlin one line:\\n```\\n    fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean {\\n        return p==q || p?.`val` == q?.`val` && isSameTree(p?.left, q?.left) && isSameTree(p?.right, q?.right)         \\n    }\\n```"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Check if nodes have the same value and also same no of nodes in both trees recusively"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Easy peasy leetcode days!!"
                    },
                    {
                        "username": "yusseef",
                        "content": "Hint:\\nIf both trees are empty they are the same tree.\\n\\nPut this condition on:\\n `if not p and not q:\\n         return True`\\n"
                    }
                ]
            },
            {
                "id": 1750384,
                "content": [
                    {
                        "username": "mkprajapati1614",
                        "content": "Only 4 conditions seems to be important here\\n1st -> when (p == NULL && q == NULL) return TRUE;  (because both nodes are same)\\n2nd-> when ( (p==NULL && q!=NULL) `||` (q==NULL && p!=NULL) `||` (p!=NULL && q!=NULL && p->val != q->val) return FALSE\\n\\n`p==NULL && q!=NULL`   ... p is pointing to NULL but q is pointing to some valid node\\n`q==NULL && p!=NULL`   ... p is pointing to some valid node but q is NULL\\n`p!=NULL && q!=NULL && p->val != q->val`   ... both p and q are pointing to valid node but the values are different."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "Why does python speed have a very wide range, same code but very inconsistent speed, why?"
                    },
                    {
                        "username": "hemasai",
                        "content": "can\\'t we use traversal and compare the traversal arrays or list?\\n"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: Same trees has same left sub tree and right sub tree, and same root!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Are isSameTree and isSubtree Problem codes similar?\\nDid you find this!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it can be one liner \\uD83D\\uDE01\\nneed an idea, post a query pls.."
                    },
                    {
                        "username": "XiaoChow",
                        "content": "Kotlin one line:\\n```\\n    fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean {\\n        return p==q || p?.`val` == q?.`val` && isSameTree(p?.left, q?.left) && isSameTree(p?.right, q?.right)         \\n    }\\n```"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Check if nodes have the same value and also same no of nodes in both trees recusively"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Easy peasy leetcode days!!"
                    },
                    {
                        "username": "yusseef",
                        "content": "Hint:\\nIf both trees are empty they are the same tree.\\n\\nPut this condition on:\\n `if not p and not q:\\n         return True`\\n"
                    }
                ]
            },
            {
                "id": 1750380,
                "content": [
                    {
                        "username": "mkprajapati1614",
                        "content": "Only 4 conditions seems to be important here\\n1st -> when (p == NULL && q == NULL) return TRUE;  (because both nodes are same)\\n2nd-> when ( (p==NULL && q!=NULL) `||` (q==NULL && p!=NULL) `||` (p!=NULL && q!=NULL && p->val != q->val) return FALSE\\n\\n`p==NULL && q!=NULL`   ... p is pointing to NULL but q is pointing to some valid node\\n`q==NULL && p!=NULL`   ... p is pointing to some valid node but q is NULL\\n`p!=NULL && q!=NULL && p->val != q->val`   ... both p and q are pointing to valid node but the values are different."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "Why does python speed have a very wide range, same code but very inconsistent speed, why?"
                    },
                    {
                        "username": "hemasai",
                        "content": "can\\'t we use traversal and compare the traversal arrays or list?\\n"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Tips: Same trees has same left sub tree and right sub tree, and same root!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Are isSameTree and isSubtree Problem codes similar?\\nDid you find this!!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it can be one liner \\uD83D\\uDE01\\nneed an idea, post a query pls.."
                    },
                    {
                        "username": "XiaoChow",
                        "content": "Kotlin one line:\\n```\\n    fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean {\\n        return p==q || p?.`val` == q?.`val` && isSameTree(p?.left, q?.left) && isSameTree(p?.right, q?.right)         \\n    }\\n```"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Check if nodes have the same value and also same no of nodes in both trees recusively"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Easy peasy leetcode days!!"
                    },
                    {
                        "username": "yusseef",
                        "content": "Hint:\\nIf both trees are empty they are the same tree.\\n\\nPut this condition on:\\n `if not p and not q:\\n         return True`\\n"
                    }
                ]
            },
            {
                "id": 1742029,
                "content": [
                    {
                        "username": "g1patil",
                        "content": "From the test cases, looked like they are mirror image of each other. Not sure how still solution is accepted."
                    },
                    {
                        "username": "athxrva",
                        "content": "This doesn't work: \n 1]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (q == null || p == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nbut this works:\n2]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nwhy does the condition in approach 1] fails:\n` if (q == null || p == null) return false;`aren't we are just comparing them ?"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "I tried your approach 1 and it works for me. What error are you getting"
                    },
                    {
                        "username": "barmanchayan10",
                        "content": " why this approach giving me error.... please help \\n\\n\\npublic boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list1 = new ArrayList<Integer>(); \\n        ArrayList<Integer> list2 = new ArrayList<Integer>(); \\n        inOrder(p, list1) ; \\n        inOrder(q, list2); \\n       if(!list1.equals(list2)) return false ; \\n       return true ;  \\n    }\\n    public static void inOrder(TreeNode tree, ArrayList<Integer> list){\\n       if(tree == null){\\n           \\n           return ; \\n       }\\n       inOrder(tree.left, list); \\n        list.add(tree.val) ;\\n       inOrder(tree.right, list); \\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "try\nArrayList \\<Integer> list1 = new ArrayList<>(); \ninstead"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Recursion ease ups a lot of problems (But kind of difficult to understand sometimes)."
                    },
                    {
                        "username": "maansrt8",
                        "content": "How can this be accepted?\n[1,2,4] and [1,2,4,4] my solution is return true but it was accepted. \n `public boolean isSameTree(TreeNode p, TreeNode q) {`\n  `....boolean R_Status = true, L_Status = true;`\n  `....if ((p == null) && (q == null)) {`\n  `........return true;`\n  `....}`\n  `....if ((((p == null) && (q != null)) || ((q == null) && (p != null))) || (p.val != q.val)){`\n  `........return false;`\n  `....}`\n  `....return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right));`\n  `}`"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "My testcase p=[0,-5] and q=[0,-8] is not getting passed, rest all passed. Please help.\n\n\nclass Solution {\npublic:\n bool result;\n    void traversal(TreeNode* p, TreeNode* q)\n    {   \n\n        \n        if (p==NULL && q==NULL)\n        {\n            result=true;\n            return;\n        }\n        if (p==NULL || q==NULL)\n        {\n            result=false;\n            return;\n        }\n        if(p->val!=q->val) \n        {   \n            result=false;\n            return;\n        }\n            \n        traversal(p->left,q->left);\n        traversal(p->right,q->right);\n    }\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        result=true;\n        traversal(p,q);\n        return result;\n    }\n\n\n        \n    \n};"
                    },
                    {
                        "username": "weaam87",
                        "content": "\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n\\n        # inOrder traversal \\n        # base case\\n        if not p and not q: \\n            return True \\n\\n        # if one tree has next level and the other doesn\\'t -> return false\\n        if not p or not q: \\n            return False\\n\\n        if p.val != q.val:\\n            return False \\n    \\n        # check left subtree and check right subtree\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n"
                    },
                    {
                        "username": "786raees",
                        "content": "```class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) "
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Java\n\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null && q==null) return true;\n        if((p==null || q==null) || (q.val!=p.val) ) return false;\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n  }"
                    }
                ]
            },
            {
                "id": 1734679,
                "content": [
                    {
                        "username": "g1patil",
                        "content": "From the test cases, looked like they are mirror image of each other. Not sure how still solution is accepted."
                    },
                    {
                        "username": "athxrva",
                        "content": "This doesn't work: \n 1]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (q == null || p == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nbut this works:\n2]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nwhy does the condition in approach 1] fails:\n` if (q == null || p == null) return false;`aren't we are just comparing them ?"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "I tried your approach 1 and it works for me. What error are you getting"
                    },
                    {
                        "username": "barmanchayan10",
                        "content": " why this approach giving me error.... please help \\n\\n\\npublic boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list1 = new ArrayList<Integer>(); \\n        ArrayList<Integer> list2 = new ArrayList<Integer>(); \\n        inOrder(p, list1) ; \\n        inOrder(q, list2); \\n       if(!list1.equals(list2)) return false ; \\n       return true ;  \\n    }\\n    public static void inOrder(TreeNode tree, ArrayList<Integer> list){\\n       if(tree == null){\\n           \\n           return ; \\n       }\\n       inOrder(tree.left, list); \\n        list.add(tree.val) ;\\n       inOrder(tree.right, list); \\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "try\nArrayList \\<Integer> list1 = new ArrayList<>(); \ninstead"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Recursion ease ups a lot of problems (But kind of difficult to understand sometimes)."
                    },
                    {
                        "username": "maansrt8",
                        "content": "How can this be accepted?\n[1,2,4] and [1,2,4,4] my solution is return true but it was accepted. \n `public boolean isSameTree(TreeNode p, TreeNode q) {`\n  `....boolean R_Status = true, L_Status = true;`\n  `....if ((p == null) && (q == null)) {`\n  `........return true;`\n  `....}`\n  `....if ((((p == null) && (q != null)) || ((q == null) && (p != null))) || (p.val != q.val)){`\n  `........return false;`\n  `....}`\n  `....return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right));`\n  `}`"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "My testcase p=[0,-5] and q=[0,-8] is not getting passed, rest all passed. Please help.\n\n\nclass Solution {\npublic:\n bool result;\n    void traversal(TreeNode* p, TreeNode* q)\n    {   \n\n        \n        if (p==NULL && q==NULL)\n        {\n            result=true;\n            return;\n        }\n        if (p==NULL || q==NULL)\n        {\n            result=false;\n            return;\n        }\n        if(p->val!=q->val) \n        {   \n            result=false;\n            return;\n        }\n            \n        traversal(p->left,q->left);\n        traversal(p->right,q->right);\n    }\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        result=true;\n        traversal(p,q);\n        return result;\n    }\n\n\n        \n    \n};"
                    },
                    {
                        "username": "weaam87",
                        "content": "\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n\\n        # inOrder traversal \\n        # base case\\n        if not p and not q: \\n            return True \\n\\n        # if one tree has next level and the other doesn\\'t -> return false\\n        if not p or not q: \\n            return False\\n\\n        if p.val != q.val:\\n            return False \\n    \\n        # check left subtree and check right subtree\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n"
                    },
                    {
                        "username": "786raees",
                        "content": "```class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) "
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Java\n\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null && q==null) return true;\n        if((p==null || q==null) || (q.val!=p.val) ) return false;\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n  }"
                    }
                ]
            },
            {
                "id": 1732046,
                "content": [
                    {
                        "username": "g1patil",
                        "content": "From the test cases, looked like they are mirror image of each other. Not sure how still solution is accepted."
                    },
                    {
                        "username": "athxrva",
                        "content": "This doesn't work: \n 1]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (q == null || p == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nbut this works:\n2]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nwhy does the condition in approach 1] fails:\n` if (q == null || p == null) return false;`aren't we are just comparing them ?"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "I tried your approach 1 and it works for me. What error are you getting"
                    },
                    {
                        "username": "barmanchayan10",
                        "content": " why this approach giving me error.... please help \\n\\n\\npublic boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list1 = new ArrayList<Integer>(); \\n        ArrayList<Integer> list2 = new ArrayList<Integer>(); \\n        inOrder(p, list1) ; \\n        inOrder(q, list2); \\n       if(!list1.equals(list2)) return false ; \\n       return true ;  \\n    }\\n    public static void inOrder(TreeNode tree, ArrayList<Integer> list){\\n       if(tree == null){\\n           \\n           return ; \\n       }\\n       inOrder(tree.left, list); \\n        list.add(tree.val) ;\\n       inOrder(tree.right, list); \\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "try\nArrayList \\<Integer> list1 = new ArrayList<>(); \ninstead"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Recursion ease ups a lot of problems (But kind of difficult to understand sometimes)."
                    },
                    {
                        "username": "maansrt8",
                        "content": "How can this be accepted?\n[1,2,4] and [1,2,4,4] my solution is return true but it was accepted. \n `public boolean isSameTree(TreeNode p, TreeNode q) {`\n  `....boolean R_Status = true, L_Status = true;`\n  `....if ((p == null) && (q == null)) {`\n  `........return true;`\n  `....}`\n  `....if ((((p == null) && (q != null)) || ((q == null) && (p != null))) || (p.val != q.val)){`\n  `........return false;`\n  `....}`\n  `....return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right));`\n  `}`"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "My testcase p=[0,-5] and q=[0,-8] is not getting passed, rest all passed. Please help.\n\n\nclass Solution {\npublic:\n bool result;\n    void traversal(TreeNode* p, TreeNode* q)\n    {   \n\n        \n        if (p==NULL && q==NULL)\n        {\n            result=true;\n            return;\n        }\n        if (p==NULL || q==NULL)\n        {\n            result=false;\n            return;\n        }\n        if(p->val!=q->val) \n        {   \n            result=false;\n            return;\n        }\n            \n        traversal(p->left,q->left);\n        traversal(p->right,q->right);\n    }\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        result=true;\n        traversal(p,q);\n        return result;\n    }\n\n\n        \n    \n};"
                    },
                    {
                        "username": "weaam87",
                        "content": "\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n\\n        # inOrder traversal \\n        # base case\\n        if not p and not q: \\n            return True \\n\\n        # if one tree has next level and the other doesn\\'t -> return false\\n        if not p or not q: \\n            return False\\n\\n        if p.val != q.val:\\n            return False \\n    \\n        # check left subtree and check right subtree\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n"
                    },
                    {
                        "username": "786raees",
                        "content": "```class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) "
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Java\n\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null && q==null) return true;\n        if((p==null || q==null) || (q.val!=p.val) ) return false;\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n  }"
                    }
                ]
            },
            {
                "id": 1728203,
                "content": [
                    {
                        "username": "g1patil",
                        "content": "From the test cases, looked like they are mirror image of each other. Not sure how still solution is accepted."
                    },
                    {
                        "username": "athxrva",
                        "content": "This doesn't work: \n 1]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (q == null || p == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nbut this works:\n2]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nwhy does the condition in approach 1] fails:\n` if (q == null || p == null) return false;`aren't we are just comparing them ?"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "I tried your approach 1 and it works for me. What error are you getting"
                    },
                    {
                        "username": "barmanchayan10",
                        "content": " why this approach giving me error.... please help \\n\\n\\npublic boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list1 = new ArrayList<Integer>(); \\n        ArrayList<Integer> list2 = new ArrayList<Integer>(); \\n        inOrder(p, list1) ; \\n        inOrder(q, list2); \\n       if(!list1.equals(list2)) return false ; \\n       return true ;  \\n    }\\n    public static void inOrder(TreeNode tree, ArrayList<Integer> list){\\n       if(tree == null){\\n           \\n           return ; \\n       }\\n       inOrder(tree.left, list); \\n        list.add(tree.val) ;\\n       inOrder(tree.right, list); \\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "try\nArrayList \\<Integer> list1 = new ArrayList<>(); \ninstead"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Recursion ease ups a lot of problems (But kind of difficult to understand sometimes)."
                    },
                    {
                        "username": "maansrt8",
                        "content": "How can this be accepted?\n[1,2,4] and [1,2,4,4] my solution is return true but it was accepted. \n `public boolean isSameTree(TreeNode p, TreeNode q) {`\n  `....boolean R_Status = true, L_Status = true;`\n  `....if ((p == null) && (q == null)) {`\n  `........return true;`\n  `....}`\n  `....if ((((p == null) && (q != null)) || ((q == null) && (p != null))) || (p.val != q.val)){`\n  `........return false;`\n  `....}`\n  `....return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right));`\n  `}`"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "My testcase p=[0,-5] and q=[0,-8] is not getting passed, rest all passed. Please help.\n\n\nclass Solution {\npublic:\n bool result;\n    void traversal(TreeNode* p, TreeNode* q)\n    {   \n\n        \n        if (p==NULL && q==NULL)\n        {\n            result=true;\n            return;\n        }\n        if (p==NULL || q==NULL)\n        {\n            result=false;\n            return;\n        }\n        if(p->val!=q->val) \n        {   \n            result=false;\n            return;\n        }\n            \n        traversal(p->left,q->left);\n        traversal(p->right,q->right);\n    }\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        result=true;\n        traversal(p,q);\n        return result;\n    }\n\n\n        \n    \n};"
                    },
                    {
                        "username": "weaam87",
                        "content": "\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n\\n        # inOrder traversal \\n        # base case\\n        if not p and not q: \\n            return True \\n\\n        # if one tree has next level and the other doesn\\'t -> return false\\n        if not p or not q: \\n            return False\\n\\n        if p.val != q.val:\\n            return False \\n    \\n        # check left subtree and check right subtree\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n"
                    },
                    {
                        "username": "786raees",
                        "content": "```class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) "
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Java\n\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null && q==null) return true;\n        if((p==null || q==null) || (q.val!=p.val) ) return false;\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n  }"
                    }
                ]
            },
            {
                "id": 1714471,
                "content": [
                    {
                        "username": "g1patil",
                        "content": "From the test cases, looked like they are mirror image of each other. Not sure how still solution is accepted."
                    },
                    {
                        "username": "athxrva",
                        "content": "This doesn't work: \n 1]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (q == null || p == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nbut this works:\n2]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nwhy does the condition in approach 1] fails:\n` if (q == null || p == null) return false;`aren't we are just comparing them ?"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "I tried your approach 1 and it works for me. What error are you getting"
                    },
                    {
                        "username": "barmanchayan10",
                        "content": " why this approach giving me error.... please help \\n\\n\\npublic boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list1 = new ArrayList<Integer>(); \\n        ArrayList<Integer> list2 = new ArrayList<Integer>(); \\n        inOrder(p, list1) ; \\n        inOrder(q, list2); \\n       if(!list1.equals(list2)) return false ; \\n       return true ;  \\n    }\\n    public static void inOrder(TreeNode tree, ArrayList<Integer> list){\\n       if(tree == null){\\n           \\n           return ; \\n       }\\n       inOrder(tree.left, list); \\n        list.add(tree.val) ;\\n       inOrder(tree.right, list); \\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "try\nArrayList \\<Integer> list1 = new ArrayList<>(); \ninstead"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Recursion ease ups a lot of problems (But kind of difficult to understand sometimes)."
                    },
                    {
                        "username": "maansrt8",
                        "content": "How can this be accepted?\n[1,2,4] and [1,2,4,4] my solution is return true but it was accepted. \n `public boolean isSameTree(TreeNode p, TreeNode q) {`\n  `....boolean R_Status = true, L_Status = true;`\n  `....if ((p == null) && (q == null)) {`\n  `........return true;`\n  `....}`\n  `....if ((((p == null) && (q != null)) || ((q == null) && (p != null))) || (p.val != q.val)){`\n  `........return false;`\n  `....}`\n  `....return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right));`\n  `}`"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "My testcase p=[0,-5] and q=[0,-8] is not getting passed, rest all passed. Please help.\n\n\nclass Solution {\npublic:\n bool result;\n    void traversal(TreeNode* p, TreeNode* q)\n    {   \n\n        \n        if (p==NULL && q==NULL)\n        {\n            result=true;\n            return;\n        }\n        if (p==NULL || q==NULL)\n        {\n            result=false;\n            return;\n        }\n        if(p->val!=q->val) \n        {   \n            result=false;\n            return;\n        }\n            \n        traversal(p->left,q->left);\n        traversal(p->right,q->right);\n    }\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        result=true;\n        traversal(p,q);\n        return result;\n    }\n\n\n        \n    \n};"
                    },
                    {
                        "username": "weaam87",
                        "content": "\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n\\n        # inOrder traversal \\n        # base case\\n        if not p and not q: \\n            return True \\n\\n        # if one tree has next level and the other doesn\\'t -> return false\\n        if not p or not q: \\n            return False\\n\\n        if p.val != q.val:\\n            return False \\n    \\n        # check left subtree and check right subtree\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n"
                    },
                    {
                        "username": "786raees",
                        "content": "```class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) "
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Java\n\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null && q==null) return true;\n        if((p==null || q==null) || (q.val!=p.val) ) return false;\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n  }"
                    }
                ]
            },
            {
                "id": 1713647,
                "content": [
                    {
                        "username": "g1patil",
                        "content": "From the test cases, looked like they are mirror image of each other. Not sure how still solution is accepted."
                    },
                    {
                        "username": "athxrva",
                        "content": "This doesn't work: \n 1]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (q == null || p == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nbut this works:\n2]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nwhy does the condition in approach 1] fails:\n` if (q == null || p == null) return false;`aren't we are just comparing them ?"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "I tried your approach 1 and it works for me. What error are you getting"
                    },
                    {
                        "username": "barmanchayan10",
                        "content": " why this approach giving me error.... please help \\n\\n\\npublic boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list1 = new ArrayList<Integer>(); \\n        ArrayList<Integer> list2 = new ArrayList<Integer>(); \\n        inOrder(p, list1) ; \\n        inOrder(q, list2); \\n       if(!list1.equals(list2)) return false ; \\n       return true ;  \\n    }\\n    public static void inOrder(TreeNode tree, ArrayList<Integer> list){\\n       if(tree == null){\\n           \\n           return ; \\n       }\\n       inOrder(tree.left, list); \\n        list.add(tree.val) ;\\n       inOrder(tree.right, list); \\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "try\nArrayList \\<Integer> list1 = new ArrayList<>(); \ninstead"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Recursion ease ups a lot of problems (But kind of difficult to understand sometimes)."
                    },
                    {
                        "username": "maansrt8",
                        "content": "How can this be accepted?\n[1,2,4] and [1,2,4,4] my solution is return true but it was accepted. \n `public boolean isSameTree(TreeNode p, TreeNode q) {`\n  `....boolean R_Status = true, L_Status = true;`\n  `....if ((p == null) && (q == null)) {`\n  `........return true;`\n  `....}`\n  `....if ((((p == null) && (q != null)) || ((q == null) && (p != null))) || (p.val != q.val)){`\n  `........return false;`\n  `....}`\n  `....return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right));`\n  `}`"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "My testcase p=[0,-5] and q=[0,-8] is not getting passed, rest all passed. Please help.\n\n\nclass Solution {\npublic:\n bool result;\n    void traversal(TreeNode* p, TreeNode* q)\n    {   \n\n        \n        if (p==NULL && q==NULL)\n        {\n            result=true;\n            return;\n        }\n        if (p==NULL || q==NULL)\n        {\n            result=false;\n            return;\n        }\n        if(p->val!=q->val) \n        {   \n            result=false;\n            return;\n        }\n            \n        traversal(p->left,q->left);\n        traversal(p->right,q->right);\n    }\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        result=true;\n        traversal(p,q);\n        return result;\n    }\n\n\n        \n    \n};"
                    },
                    {
                        "username": "weaam87",
                        "content": "\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n\\n        # inOrder traversal \\n        # base case\\n        if not p and not q: \\n            return True \\n\\n        # if one tree has next level and the other doesn\\'t -> return false\\n        if not p or not q: \\n            return False\\n\\n        if p.val != q.val:\\n            return False \\n    \\n        # check left subtree and check right subtree\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n"
                    },
                    {
                        "username": "786raees",
                        "content": "```class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) "
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Java\n\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null && q==null) return true;\n        if((p==null || q==null) || (q.val!=p.val) ) return false;\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n  }"
                    }
                ]
            },
            {
                "id": 1710568,
                "content": [
                    {
                        "username": "g1patil",
                        "content": "From the test cases, looked like they are mirror image of each other. Not sure how still solution is accepted."
                    },
                    {
                        "username": "athxrva",
                        "content": "This doesn't work: \n 1]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (q == null || p == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nbut this works:\n2]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nwhy does the condition in approach 1] fails:\n` if (q == null || p == null) return false;`aren't we are just comparing them ?"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "I tried your approach 1 and it works for me. What error are you getting"
                    },
                    {
                        "username": "barmanchayan10",
                        "content": " why this approach giving me error.... please help \\n\\n\\npublic boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list1 = new ArrayList<Integer>(); \\n        ArrayList<Integer> list2 = new ArrayList<Integer>(); \\n        inOrder(p, list1) ; \\n        inOrder(q, list2); \\n       if(!list1.equals(list2)) return false ; \\n       return true ;  \\n    }\\n    public static void inOrder(TreeNode tree, ArrayList<Integer> list){\\n       if(tree == null){\\n           \\n           return ; \\n       }\\n       inOrder(tree.left, list); \\n        list.add(tree.val) ;\\n       inOrder(tree.right, list); \\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "try\nArrayList \\<Integer> list1 = new ArrayList<>(); \ninstead"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Recursion ease ups a lot of problems (But kind of difficult to understand sometimes)."
                    },
                    {
                        "username": "maansrt8",
                        "content": "How can this be accepted?\n[1,2,4] and [1,2,4,4] my solution is return true but it was accepted. \n `public boolean isSameTree(TreeNode p, TreeNode q) {`\n  `....boolean R_Status = true, L_Status = true;`\n  `....if ((p == null) && (q == null)) {`\n  `........return true;`\n  `....}`\n  `....if ((((p == null) && (q != null)) || ((q == null) && (p != null))) || (p.val != q.val)){`\n  `........return false;`\n  `....}`\n  `....return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right));`\n  `}`"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "My testcase p=[0,-5] and q=[0,-8] is not getting passed, rest all passed. Please help.\n\n\nclass Solution {\npublic:\n bool result;\n    void traversal(TreeNode* p, TreeNode* q)\n    {   \n\n        \n        if (p==NULL && q==NULL)\n        {\n            result=true;\n            return;\n        }\n        if (p==NULL || q==NULL)\n        {\n            result=false;\n            return;\n        }\n        if(p->val!=q->val) \n        {   \n            result=false;\n            return;\n        }\n            \n        traversal(p->left,q->left);\n        traversal(p->right,q->right);\n    }\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        result=true;\n        traversal(p,q);\n        return result;\n    }\n\n\n        \n    \n};"
                    },
                    {
                        "username": "weaam87",
                        "content": "\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n\\n        # inOrder traversal \\n        # base case\\n        if not p and not q: \\n            return True \\n\\n        # if one tree has next level and the other doesn\\'t -> return false\\n        if not p or not q: \\n            return False\\n\\n        if p.val != q.val:\\n            return False \\n    \\n        # check left subtree and check right subtree\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n"
                    },
                    {
                        "username": "786raees",
                        "content": "```class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) "
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Java\n\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null && q==null) return true;\n        if((p==null || q==null) || (q.val!=p.val) ) return false;\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n  }"
                    }
                ]
            },
            {
                "id": 1697147,
                "content": [
                    {
                        "username": "g1patil",
                        "content": "From the test cases, looked like they are mirror image of each other. Not sure how still solution is accepted."
                    },
                    {
                        "username": "athxrva",
                        "content": "This doesn't work: \n 1]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (q == null || p == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nbut this works:\n2]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nwhy does the condition in approach 1] fails:\n` if (q == null || p == null) return false;`aren't we are just comparing them ?"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "I tried your approach 1 and it works for me. What error are you getting"
                    },
                    {
                        "username": "barmanchayan10",
                        "content": " why this approach giving me error.... please help \\n\\n\\npublic boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list1 = new ArrayList<Integer>(); \\n        ArrayList<Integer> list2 = new ArrayList<Integer>(); \\n        inOrder(p, list1) ; \\n        inOrder(q, list2); \\n       if(!list1.equals(list2)) return false ; \\n       return true ;  \\n    }\\n    public static void inOrder(TreeNode tree, ArrayList<Integer> list){\\n       if(tree == null){\\n           \\n           return ; \\n       }\\n       inOrder(tree.left, list); \\n        list.add(tree.val) ;\\n       inOrder(tree.right, list); \\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "try\nArrayList \\<Integer> list1 = new ArrayList<>(); \ninstead"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Recursion ease ups a lot of problems (But kind of difficult to understand sometimes)."
                    },
                    {
                        "username": "maansrt8",
                        "content": "How can this be accepted?\n[1,2,4] and [1,2,4,4] my solution is return true but it was accepted. \n `public boolean isSameTree(TreeNode p, TreeNode q) {`\n  `....boolean R_Status = true, L_Status = true;`\n  `....if ((p == null) && (q == null)) {`\n  `........return true;`\n  `....}`\n  `....if ((((p == null) && (q != null)) || ((q == null) && (p != null))) || (p.val != q.val)){`\n  `........return false;`\n  `....}`\n  `....return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right));`\n  `}`"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "My testcase p=[0,-5] and q=[0,-8] is not getting passed, rest all passed. Please help.\n\n\nclass Solution {\npublic:\n bool result;\n    void traversal(TreeNode* p, TreeNode* q)\n    {   \n\n        \n        if (p==NULL && q==NULL)\n        {\n            result=true;\n            return;\n        }\n        if (p==NULL || q==NULL)\n        {\n            result=false;\n            return;\n        }\n        if(p->val!=q->val) \n        {   \n            result=false;\n            return;\n        }\n            \n        traversal(p->left,q->left);\n        traversal(p->right,q->right);\n    }\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        result=true;\n        traversal(p,q);\n        return result;\n    }\n\n\n        \n    \n};"
                    },
                    {
                        "username": "weaam87",
                        "content": "\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n\\n        # inOrder traversal \\n        # base case\\n        if not p and not q: \\n            return True \\n\\n        # if one tree has next level and the other doesn\\'t -> return false\\n        if not p or not q: \\n            return False\\n\\n        if p.val != q.val:\\n            return False \\n    \\n        # check left subtree and check right subtree\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n"
                    },
                    {
                        "username": "786raees",
                        "content": "```class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) "
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Java\n\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null && q==null) return true;\n        if((p==null || q==null) || (q.val!=p.val) ) return false;\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n  }"
                    }
                ]
            },
            {
                "id": 1676250,
                "content": [
                    {
                        "username": "g1patil",
                        "content": "From the test cases, looked like they are mirror image of each other. Not sure how still solution is accepted."
                    },
                    {
                        "username": "athxrva",
                        "content": "This doesn't work: \n 1]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (q == null || p == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nbut this works:\n2]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nwhy does the condition in approach 1] fails:\n` if (q == null || p == null) return false;`aren't we are just comparing them ?"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "I tried your approach 1 and it works for me. What error are you getting"
                    },
                    {
                        "username": "barmanchayan10",
                        "content": " why this approach giving me error.... please help \\n\\n\\npublic boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list1 = new ArrayList<Integer>(); \\n        ArrayList<Integer> list2 = new ArrayList<Integer>(); \\n        inOrder(p, list1) ; \\n        inOrder(q, list2); \\n       if(!list1.equals(list2)) return false ; \\n       return true ;  \\n    }\\n    public static void inOrder(TreeNode tree, ArrayList<Integer> list){\\n       if(tree == null){\\n           \\n           return ; \\n       }\\n       inOrder(tree.left, list); \\n        list.add(tree.val) ;\\n       inOrder(tree.right, list); \\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "try\nArrayList \\<Integer> list1 = new ArrayList<>(); \ninstead"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Recursion ease ups a lot of problems (But kind of difficult to understand sometimes)."
                    },
                    {
                        "username": "maansrt8",
                        "content": "How can this be accepted?\n[1,2,4] and [1,2,4,4] my solution is return true but it was accepted. \n `public boolean isSameTree(TreeNode p, TreeNode q) {`\n  `....boolean R_Status = true, L_Status = true;`\n  `....if ((p == null) && (q == null)) {`\n  `........return true;`\n  `....}`\n  `....if ((((p == null) && (q != null)) || ((q == null) && (p != null))) || (p.val != q.val)){`\n  `........return false;`\n  `....}`\n  `....return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right));`\n  `}`"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "My testcase p=[0,-5] and q=[0,-8] is not getting passed, rest all passed. Please help.\n\n\nclass Solution {\npublic:\n bool result;\n    void traversal(TreeNode* p, TreeNode* q)\n    {   \n\n        \n        if (p==NULL && q==NULL)\n        {\n            result=true;\n            return;\n        }\n        if (p==NULL || q==NULL)\n        {\n            result=false;\n            return;\n        }\n        if(p->val!=q->val) \n        {   \n            result=false;\n            return;\n        }\n            \n        traversal(p->left,q->left);\n        traversal(p->right,q->right);\n    }\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        result=true;\n        traversal(p,q);\n        return result;\n    }\n\n\n        \n    \n};"
                    },
                    {
                        "username": "weaam87",
                        "content": "\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n\\n        # inOrder traversal \\n        # base case\\n        if not p and not q: \\n            return True \\n\\n        # if one tree has next level and the other doesn\\'t -> return false\\n        if not p or not q: \\n            return False\\n\\n        if p.val != q.val:\\n            return False \\n    \\n        # check left subtree and check right subtree\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n"
                    },
                    {
                        "username": "786raees",
                        "content": "```class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) "
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Java\n\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null && q==null) return true;\n        if((p==null || q==null) || (q.val!=p.val) ) return false;\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n  }"
                    }
                ]
            },
            {
                "id": 1675088,
                "content": [
                    {
                        "username": "g1patil",
                        "content": "From the test cases, looked like they are mirror image of each other. Not sure how still solution is accepted."
                    },
                    {
                        "username": "athxrva",
                        "content": "This doesn't work: \n 1]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (q == null || p == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nbut this works:\n2]\n```\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n```\n\nwhy does the condition in approach 1] fails:\n` if (q == null || p == null) return false;`aren't we are just comparing them ?"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "I tried your approach 1 and it works for me. What error are you getting"
                    },
                    {
                        "username": "barmanchayan10",
                        "content": " why this approach giving me error.... please help \\n\\n\\npublic boolean isSameTree(TreeNode p, TreeNode q) {\\n        ArrayList<Integer> list1 = new ArrayList<Integer>(); \\n        ArrayList<Integer> list2 = new ArrayList<Integer>(); \\n        inOrder(p, list1) ; \\n        inOrder(q, list2); \\n       if(!list1.equals(list2)) return false ; \\n       return true ;  \\n    }\\n    public static void inOrder(TreeNode tree, ArrayList<Integer> list){\\n       if(tree == null){\\n           \\n           return ; \\n       }\\n       inOrder(tree.left, list); \\n        list.add(tree.val) ;\\n       inOrder(tree.right, list); \\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "try\nArrayList \\<Integer> list1 = new ArrayList<>(); \ninstead"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Recursion ease ups a lot of problems (But kind of difficult to understand sometimes)."
                    },
                    {
                        "username": "maansrt8",
                        "content": "How can this be accepted?\n[1,2,4] and [1,2,4,4] my solution is return true but it was accepted. \n `public boolean isSameTree(TreeNode p, TreeNode q) {`\n  `....boolean R_Status = true, L_Status = true;`\n  `....if ((p == null) && (q == null)) {`\n  `........return true;`\n  `....}`\n  `....if ((((p == null) && (q != null)) || ((q == null) && (p != null))) || (p.val != q.val)){`\n  `........return false;`\n  `....}`\n  `....return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right));`\n  `}`"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "My testcase p=[0,-5] and q=[0,-8] is not getting passed, rest all passed. Please help.\n\n\nclass Solution {\npublic:\n bool result;\n    void traversal(TreeNode* p, TreeNode* q)\n    {   \n\n        \n        if (p==NULL && q==NULL)\n        {\n            result=true;\n            return;\n        }\n        if (p==NULL || q==NULL)\n        {\n            result=false;\n            return;\n        }\n        if(p->val!=q->val) \n        {   \n            result=false;\n            return;\n        }\n            \n        traversal(p->left,q->left);\n        traversal(p->right,q->right);\n    }\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        result=true;\n        traversal(p,q);\n        return result;\n    }\n\n\n        \n    \n};"
                    },
                    {
                        "username": "weaam87",
                        "content": "\\nclass Solution(object):\\n    def isSameTree(self, p, q):\\n        \"\"\"\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n\\n        # inOrder traversal \\n        # base case\\n        if not p and not q: \\n            return True \\n\\n        # if one tree has next level and the other doesn\\'t -> return false\\n        if not p or not q: \\n            return False\\n\\n        if p.val != q.val:\\n            return False \\n    \\n        # check left subtree and check right subtree\\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\\n"
                    },
                    {
                        "username": "786raees",
                        "content": "```class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) "
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Java\n\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null && q==null) return true;\n        if((p==null || q==null) || (q.val!=p.val) ) return false;\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n  }"
                    }
                ]
            }
        ]
    },
    {
        "title": "Number of Islands",
        "question_content": "<p>Given an <code>m x n</code> 2D binary grid <code>grid</code> which represents a map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), return <em>the number of islands</em>.</p>\n\n<p>An <strong>island</strong> is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [\n  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],\n  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],\n  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],\n  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]\n]\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [\n  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],\n  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],\n  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],\n  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]\n]\n<strong>Output:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 300</code></li>\n\t<li><code>grid[i][j]</code> is <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 56340,
                "title": "python-simple-dfs-solution",
                "content": "Iterate through each of the cell and if it is an island, do dfs to mark all adjacent islands, then increase the counter by 1.\\n\\n    def numIslands(self, grid):\\n        if not grid:\\n            return 0\\n            \\n        count = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == '1':\\n                    self.dfs(grid, i, j)\\n                    count += 1\\n        return count\\n    \\n    def dfs(self, grid, i, j):\\n        if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j] != '1':\\n            return\\n        grid[i][j] = '#'\\n        self.dfs(grid, i+1, j)\\n        self.dfs(grid, i-1, j)\\n        self.dfs(grid, i, j+1)\\n        self.dfs(grid, i, j-1)",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "Iterate through each of the cell and if it is an island, do dfs to mark all adjacent islands, then increase the counter by 1.\\n\\n    def numIslands(self, grid):\\n        if not grid:\\n            return 0\\n            \\n        count = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == '1':\\n                    self.dfs(grid, i, j)\\n                    count += 1\\n        return count\\n    \\n    def dfs(self, grid, i, j):\\n        if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j] != '1':\\n            return\\n        grid[i][j] = '#'\\n        self.dfs(grid, i+1, j)\\n        self.dfs(grid, i-1, j)\\n        self.dfs(grid, i, j+1)\\n        self.dfs(grid, i, j-1)",
                "codeTag": "Python3"
            },
            {
                "id": 56359,
                "title": "very-concise-java-ac-solution",
                "content": "    public class Solution {\\n    \\n    private int n;\\n    private int m;\\n    \\n    public int numIslands(char[][] grid) {\\n        int count = 0;\\n        n = grid.length;\\n        if (n == 0) return 0;\\n        m = grid[0].length;\\n        for (int i = 0; i < n; i++){\\n            for (int j = 0; j < m; j++)\\n                if (grid[i][j] == '1') {\\n                    DFSMarking(grid, i, j);\\n                    ++count;\\n                }\\n        }    \\n        return count;\\n    }\\n    \\n    private void DFSMarking(char[][] grid, int i, int j) {\\n        if (i < 0 || j < 0 || i >= n || j >= m || grid[i][j] != '1') return;\\n        grid[i][j] = '0';\\n        DFSMarking(grid, i + 1, j);\\n        DFSMarking(grid, i - 1, j);\\n        DFSMarking(grid, i, j + 1);\\n        DFSMarking(grid, i, j - 1);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    private int n;\\n    private int m;\\n    \\n    public int numIslands(char[][] grid) {\\n        int count = 0;\\n        n = grid.length;\\n        if (n == 0) return 0;\\n        m = grid[0].length;\\n        for (int i = 0; i < n; i++){\\n            for (int j = 0; j < m; j++)\\n                if (grid[i][j] == '1') {\\n                    DFSMarking(grid, i, j);\\n                    ++count;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 56589,
                "title": "c-bfs-dfs",
                "content": "I saw many peope post DFS solutions but fewer BFS ones. So I wrote one below. Each time when I see a `\\'1\\'`, I increment the counter and then erase all connected `\\'1\\'`s using a `queue`.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = m ? grid[0].size() : 0, islands = 0, offsets[] = {0, 1, 0, -1, 0};\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    islands++;\\n                    grid[i][j] = \\'0\\';\\n                    queue<pair<int, int>> todo;\\n                    todo.push({i, j});\\n                    while (!todo.empty()) {\\n                        pair<int, int> p = todo.front();\\n                        todo.pop();\\n                        for (int k = 0; k < 4; k++) {\\n                            int r = p.first + offsets[k], c = p.second + offsets[k + 1];\\n                            if (r >= 0 && r < m && c >= 0 && c < n && grid[r][c] == \\'1\\') {\\n                                grid[r][c] = \\'0\\';\\n                                todo.push({r, c});\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n};\\n```\\n\\nOr I can erase all the connected `\\'1\\'`s using DFS.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = m ? grid[0].size() : 0, islands = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    islands++;\\n                    eraseIslands(grid, i, j);\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\nprivate:\\n    void eraseIslands(vector<vector<char>>& grid, int i, int j) {\\n        int m = grid.size(), n = grid[0].size();\\n        if (i < 0 || i == m || j < 0 || j == n || grid[i][j] == \\'0\\') {\\n            return;\\n        }\\n        grid[i][j] = \\'0\\';\\n        eraseIslands(grid, i - 1, j);\\n        eraseIslands(grid, i + 1, j);\\n        eraseIslands(grid, i, j - 1);\\n        eraseIslands(grid, i, j + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = m ? grid[0].size() : 0, islands = 0, offsets[] = {0, 1, 0, -1, 0};\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    islands++;\\n                    grid[i][j] = \\'0\\';\\n                    queue<pair<int, int>> todo;\\n                    todo.push({i, j});\\n                    while (!todo.empty()) {\\n                        pair<int, int> p = todo.front();\\n                        todo.pop();\\n                        for (int k = 0; k < 4; k++) {\\n                            int r = p.first + offsets[k], c = p.second + offsets[k + 1];\\n                            if (r >= 0 && r < m && c >= 0 && c < n && grid[r][c] == \\'1\\') {\\n                                grid[r][c] = \\'0\\';\\n                                todo.push({r, c});\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = m ? grid[0].size() : 0, islands = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    islands++;\\n                    eraseIslands(grid, i, j);\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\nprivate:\\n    void eraseIslands(vector<vector<char>>& grid, int i, int j) {\\n        int m = grid.size(), n = grid[0].size();\\n        if (i < 0 || i == m || j < 0 || j == n || grid[i][j] == \\'0\\') {\\n            return;\\n        }\\n        grid[i][j] = \\'0\\';\\n        eraseIslands(grid, i - 1, j);\\n        eraseIslands(grid, i + 1, j);\\n        eraseIslands(grid, i, j - 1);\\n        eraseIslands(grid, i, j + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56349,
                "title": "7-lines-python-14-lines-java",
                "content": "Sink and count the islands.\\n\\n---\\n\\n**Python Solution**\\n\\n    def numIslands(self, grid):\\n        def sink(i, j):\\n            if 0 <= i < len(grid) and 0 <= j < len(grid[i]) and grid[i][j] == '1':\\n                grid[i][j] = '0'\\n                map(sink, (i+1, i-1, i, i), (j, j, j+1, j-1))\\n                return 1\\n            return 0\\n        return sum(sink(i, j) for i in range(len(grid)) for j in range(len(grid[i])))\\n\\n---\\n\\n**Java Solution 1**\\n\\n    public class Solution {\\n        char[][] g;\\n        public int numIslands(char[][] grid) {\\n            int islands = 0;\\n            g = grid;\\n            for (int i=0; i<g.length; i++)\\n                for (int j=0; j<g[i].length; j++)\\n                    islands += sink(i, j);\\n            return islands;\\n        }\\n        int sink(int i, int j) {\\n            if (i < 0 || i == g.length || j < 0 || j == g[i].length || g[i][j] == '0')\\n                return 0;\\n            g[i][j] = '0';\\n            sink(i+1, j); sink(i-1, j); sink(i, j+1); sink(i, j-1);\\n            return 1;\\n        }\\n    }\\n\\n---\\n\\n**Java Solution 2**\\n\\n    public class Solution {\\n        public int numIslands(char[][] grid) {\\n            int islands = 0;\\n            for (int i=0; i<grid.length; i++)\\n                for (int j=0; j<grid[i].length; j++)\\n                    islands += sink(grid, i, j);\\n            return islands;\\n        }\\n        int sink(char[][] grid, int i, int j) {\\n            if (i < 0 || i == grid.length || j < 0 || j == grid[i].length || grid[i][j] == '0')\\n                return 0;\\n            grid[i][j] = '0';\\n            for (int k=0; k<4; k++)\\n                sink(grid, i+d[k], j+d[k+1]);\\n            return 1;\\n        }\\n        int[] d = {0, 1, 0, -1, 0};\\n    }",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "class Solution {\\n        char[][] g;\\n        public int numIslands(char[][] grid) {\\n            int islands = 0;\\n            g = grid;\\n            for (int i=0; i<g.length; i++)\\n                for (int j=0; j<g[i].length; j++)\\n                    islands += sink(i, j);\\n            return islands;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 56354,
                "title": "1d-union-find-java-solution-easily-generalized-to-other-problems",
                "content": "For any problem I work on, I will try to generalize some reusable template out for future use.  We have limited time during interview and too much to worry about, so having some code template to use is very handy.  For this problem, although it is easier  and probably suggested to use BFS, but Union find also comes handy and can be easily extended to solve Island 2 and Surrounded regions.  \\n\\nI separate all the union find logic in a separate class and use 1d version to make the code clear.  I also use a 2d array for the 4 direction visit.  `int[][] distance = {{1,0},{-1,0},{0,1},{0,-1}};`\\n\\n\\n        int[][] distance = {{1,0},{-1,0},{0,1},{0,-1}};\\n        public int numIslands(char[][] grid) {  \\n            if (grid == null || grid.length == 0 || grid[0].length == 0)  {\\n                return 0;  \\n            }\\n            UnionFind uf = new UnionFind(grid);  \\n            int rows = grid.length;  \\n            int cols = grid[0].length;  \\n            for (int i = 0; i < rows; i++) {  \\n                for (int j = 0; j < cols; j++) {  \\n                    if (grid[i][j] == '1') {  \\n                        for (int[] d : distance) {\\n                            int x = i + d[0];\\n                            int y = j + d[1];\\n                            if (x >= 0 && x < rows && y >= 0 && y < cols && grid[x][y] == '1') {  \\n                                int id1 = i*cols+j;\\n                                int id2 = x*cols+y;\\n                                uf.union(id1, id2);  \\n                            }  \\n                        }  \\n                    }  \\n                }  \\n            }  \\n            return uf.count;  \\n        }\\n        \\nUnion Find:\\n\\n        class UnionFind {\\n            int[] father;  \\n            int m, n;\\n            int count = 0;\\n            UnionFind(char[][] grid) {  \\n                m = grid.length;  \\n                n = grid[0].length;  \\n                father = new int[m*n];  \\n                for (int i = 0; i < m; i++) {  \\n                    for (int j = 0; j < n; j++) {  \\n                        if (grid[i][j] == '1') {\\n                            int id = i * n + j;\\n                            father[id] = id;\\n                            count++;\\n                        }\\n                    }  \\n                }  \\n            }\\n            public void union(int node1, int node2) {  \\n                int find1 = find(node1);\\n                int find2 = find(node2);\\n                if(find1 != find2) {\\n                    father[find1] = find2;\\n                    count--;\\n                }\\n            }\\n            public int find (int node) {  \\n                if (father[node] == node) {  \\n                    return node;\\n                }\\n                father[node] = find(father[node]);  \\n                return father[node];\\n            }\\n        }",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "For any problem I work on, I will try to generalize some reusable template out for future use.  We have limited time during interview and too much to worry about, so having some code template to use is very handy.  For this problem, although it is easier  and probably suggested to use BFS, but Union find also comes handy and can be easily extended to solve Island 2 and Surrounded regions.  \\n\\nI separate all the union find logic in a separate class and use 1d version to make the code clear.  I also use a 2d array for the 4 direction visit.  `int[][] distance = {{1,0},{-1,0},{0,1},{0,-1}};`\\n\\n\\n        int[][] distance = {{1,0},{-1,0},{0,1},{0,-1}};\\n        public int numIslands(char[][] grid) {  \\n            if (grid == null || grid.length == 0 || grid[0].length == 0)  {\\n                return 0;  \\n            }\\n            UnionFind uf = new UnionFind(grid);  \\n            int rows = grid.length;  \\n            int cols = grid[0].length;  \\n            for (int i = 0; i < rows; i++) {  \\n                for (int j = 0; j < cols; j++) {  \\n                    if (grid[i][j] == '1') {  \\n                        for (int[] d : distance) {\\n                            int x = i + d[0];\\n                            int y = j + d[1];\\n                            if (x >= 0 && x < rows && y >= 0 && y < cols && grid[x][y] == '1') {  \\n                                int id1 = i*cols+j;\\n                                int id2 = x*cols+y;\\n                                uf.union(id1, id2);  \\n                            }  \\n                        }  \\n                    }  \\n                }  \\n            }  \\n            return uf.count;  \\n        }\\n        \\nUnion Find:\\n\\n        class UnionFind {\\n            int[] father;  \\n            int m, n;\\n            int count = 0;\\n            UnionFind(char[][] grid) {  \\n                m = grid.length;  \\n                n = grid[0].length;  \\n                father = new int[m*n];  \\n                for (int i = 0; i < m; i++) {  \\n                    for (int j = 0; j < n; j++) {  \\n                        if (grid[i][j] == '1') {\\n                            int id = i * n + j;\\n                            father[id] = id;\\n                            count++;\\n                        }\\n                    }  \\n                }  \\n            }\\n            public void union(int node1, int node2) {  \\n                int find1 = find(node1);\\n                int find2 = find(node2);\\n                if(find1 != find2) {\\n                    father[find1] = find2;\\n                    count--;\\n                }\\n            }\\n            public int find (int node) {  \\n                if (father[node] == node) {  \\n                    return node;\\n                }\\n                father[node] = find(father[node]);  \\n                return father[node];\\n            }\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 345981,
                "title": "python3-number-of-islands-bfs-dfs",
                "content": "Explanation:\\nIn the grid, we need to record 1 peice of information of one point, grid[i][j], i.e., if grid[i][j] has been visited or not.\\nWe initialize the check matrix with all False. It means none of the elements in the check matrix has been visited.\\nIf one point grid[i][j] has not been visited, check[i][j] == False, it means we haven\\'t count this point into one islands.\\nIf one point grid[i][j] has been visited, check[i][j] == True, it means we already count this point into one islands.\\nSearch function:\\n\\nSearch function:\\nEach time you call search function, the search function will end until all the neighbors of grid[i][j] have value \"1\" been visited, i.e., those points are labeled True in check matrix.\\n\\n```\\nExample:\\ngrid = [ 1 ,  1 ,  1,\\n\\t\\t 1,   1,   0,\\n\\t\\t 0,   0,   1]\\n\\t\\t \\nIntial check:\\ncheck = [ False, False, False,\\n\\t\\t  False, False, False,\\n\\t\\t  False, False, False]\\n\\t\\t  \\n# the first time call  search function:\\ngrid[0][0] == \\'1\\' and check[0][0] == False:\\ncheck = [ True, True, True,\\n\\t\\t  True, True, False,\\n\\t\\t False, False, False ]\\ncount = 1\\n# the second time call check function:\\ngrid[2][2] = \\'1\\' and check[2][2] == False:\\ncheck = [ True, True, True,\\n\\t\\t  True, True, False,\\n\\t\\t False, False, True]\\nCount = 2\\n```\\n   \\n   \\n\\n\\nsearch function takes one point as input.\\n```\\nfrom collections import deque\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid:\\n            return 0   \\n        count = 0\\n        check = [[False for _ in range(len(grid[0]))] for _ in range(len(grid))]\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] ==\\'1\\' and check[i][j]== False:\\n                    count += 1\\n                    self.search(grid,check,i,j)\\n        return count       \\n    def search(self,grid,check,i,j):\\n        qu = deque([(i,j)])\\n        while qu:\\n            i, j = qu.popleft()\\n            if 0<=i<len(grid) and 0<=j<len(grid[0]) and grid[i][j]==\\'1\\' and check[i][j]==False:\\n                check[i][j] = True\\n                qu.extend([(i-1,j),(i+1,j),(i,j-1),(i,j+1)])\\n```\\n* Improve space complexity to O(1): we can improve the algorithm by replacing the check matrix by flip the visited \\'1\\' to \\'0\\'. We can flip the visited \\'1\\' to \\'0\\' since we are only adding the index of \\'1\\' into the queue. The connected \\'1\\' already flip into \\'0\\', so we don\\'t need to worry about duplicate calculation. \\n```\\nfrom collections import deque\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        count = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == \\'1\\':\\n                    #print(i,j,grid)\\n                    grid[i][j] = \\'0\\'\\n                    self.helper(grid,i,j)\\n                    count += 1\\n        return count\\n    # use a helper function to flip connected \\'1\\'s to 0\\n    def helper(self,grid,i,j):\\n        queue = deque([(i,j)])\\n        while queue:\\n            I,J = queue.popleft()\\n            for i,j in [I+1,J],[I,J+1],[I-1,J],[I,J-1]:\\n                if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == \\'1\\':\\n                    #print(i,j, queue)\\n                    grid[i][j] = \\'0\\'\\n                    queue.append((i,j))\\n```\\n\\n```\\nfrom collections import deque\\nclass Solution:\\n    def numIslands(self, grid):\\n        count = 0\\n        queue = deque([])\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == \\'1\\':\\n                    grid[i][j] = 0\\n                    queue.append((i,j))\\n                    self.helper(grid,queue) # turn the adjancent \\'1\\' to \\'0\\'\\n                    count += 1\\n        print(grid)\\n        return count\\n    \\n    def helper(self,grid,queue):\\n        while queue:\\n            I,J = queue.popleft()\\n            for i,j in [I-1,J],[I+1,J],[I,J-1],[I,J+1]:\\n                if 0<= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == \\'1\\':\\n                    queue.append((i,j))\\n                    grid[i][j] = 0 #0\\n```\\n* DFS\\n```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        count = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == \\'1\\':\\n                    print(i,j)\\n                    self.dfs(grid,i,j)\\n                    count  += 1\\n        #print(grid)\\n        return count\\n    # use a helper function to flip connected \\'1\\'s to 0\\n    def dfs(self,grid,i,j):\\n        grid[i][j] = 0\\n        for dr,dc in (1,0), (-1,0), (0,-1), (0,1):\\n            r = i + dr\\n            c = j + dc\\n            if 0 <= r < len(grid) and 0 <= c < len(grid[0]) and grid[r][c]==\\'1\\':\\n                self.dfs(grid,r,c)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nExample:\\ngrid = [ 1 ,  1 ,  1,\\n\\t\\t 1,   1,   0,\\n\\t\\t 0,   0,   1]\\n\\t\\t \\nIntial check:\\ncheck = [ False, False, False,\\n\\t\\t  False, False, False,\\n\\t\\t  False, False, False]\\n\\t\\t  \\n# the first time call  search function:\\ngrid[0][0] == \\'1\\' and check[0][0] == False:\\ncheck = [ True, True, True,\\n\\t\\t  True, True, False,\\n\\t\\t False, False, False ]\\ncount = 1\\n# the second time call check function:\\ngrid[2][2] = \\'1\\' and check[2][2] == False:\\ncheck = [ True, True, True,\\n\\t\\t  True, True, False,\\n\\t\\t False, False, True]\\nCount = 2\\n```\n```\\nfrom collections import deque\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid:\\n            return 0   \\n        count = 0\\n        check = [[False for _ in range(len(grid[0]))] for _ in range(len(grid))]\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] ==\\'1\\' and check[i][j]== False:\\n                    count += 1\\n                    self.search(grid,check,i,j)\\n        return count       \\n    def search(self,grid,check,i,j):\\n        qu = deque([(i,j)])\\n        while qu:\\n            i, j = qu.popleft()\\n            if 0<=i<len(grid) and 0<=j<len(grid[0]) and grid[i][j]==\\'1\\' and check[i][j]==False:\\n                check[i][j] = True\\n                qu.extend([(i-1,j),(i+1,j),(i,j-1),(i,j+1)])\\n```\n```\\nfrom collections import deque\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        count = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == \\'1\\':\\n                    #print(i,j,grid)\\n                    grid[i][j] = \\'0\\'\\n                    self.helper(grid,i,j)\\n                    count += 1\\n        return count\\n    # use a helper function to flip connected \\'1\\'s to 0\\n    def helper(self,grid,i,j):\\n        queue = deque([(i,j)])\\n        while queue:\\n            I,J = queue.popleft()\\n            for i,j in [I+1,J],[I,J+1],[I-1,J],[I,J-1]:\\n                if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == \\'1\\':\\n                    #print(i,j, queue)\\n                    grid[i][j] = \\'0\\'\\n                    queue.append((i,j))\\n```\n```\\nfrom collections import deque\\nclass Solution:\\n    def numIslands(self, grid):\\n        count = 0\\n        queue = deque([])\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == \\'1\\':\\n                    grid[i][j] = 0\\n                    queue.append((i,j))\\n                    self.helper(grid,queue) # turn the adjancent \\'1\\' to \\'0\\'\\n                    count += 1\\n        print(grid)\\n        return count\\n    \\n    def helper(self,grid,queue):\\n        while queue:\\n            I,J = queue.popleft()\\n            for i,j in [I-1,J],[I+1,J],[I,J-1],[I,J+1]:\\n                if 0<= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == \\'1\\':\\n                    queue.append((i,j))\\n                    grid[i][j] = 0 #0\\n```\n```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        count = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == \\'1\\':\\n                    print(i,j)\\n                    self.dfs(grid,i,j)\\n                    count  += 1\\n        #print(grid)\\n        return count\\n    # use a helper function to flip connected \\'1\\'s to 0\\n    def dfs(self,grid,i,j):\\n        grid[i][j] = 0\\n        for dr,dc in (1,0), (-1,0), (0,-1), (0,1):\\n            r = i + dr\\n            c = j + dc\\n            if 0 <= r < len(grid) and 0 <= c < len(grid[0]) and grid[r][c]==\\'1\\':\\n                self.dfs(grid,r,c)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 501000,
                "title": "c-simple-dfs-beats-100-in-memory-detailed-explanantion",
                "content": "```\\n/*\\n    https://leetcode.com/problems/number-of-islands/\\n    TC: O(V^2)\\n*/\\nclass Solution {\\npublic:\\n    void DFS(vector<vector<char>>& grid, int i, int j) {\\n        // boundary checking\\n        if(i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size())\\n            return;\\n        // return if current position is of water or is already visited\\n        if(grid[i][j] == \\'2\\' || grid[i][j] == \\'0\\')\\n            return;\\n        \\n        // mark the current as visited\\n        grid[i][j] = \\'2\\';\\n        \\n        // do DFS in all 4 directions\\n        DFS(grid, i+1, j);\\n        DFS(grid, i, j-1);\\n        DFS(grid, i-1, j);\\n        DFS(grid, i, j+1);\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        // We can treat the matrix grid as a grid. Each Island is a\\n        // connected component. The task is to find no. of disconnectedd components\\n        // in the graph.\\n        \\n        int islands = 0;\\n        // We make each 1 as 2 in when it is visited\\n        for(int i = 0; i < grid.size(); i++) {\\n            for(int j = 0; j < grid[0].size(); j++) {\\n                // do DFS in case has not been visited and there is land\\n                if(grid[i][j] == \\'1\\') {\\n                    DFS(grid, i, j);\\n                    ++islands;\\n                } \\n            }\\n        }\\n        return islands;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/number-of-islands/\\n    TC: O(V^2)\\n*/\\nclass Solution {\\npublic:\\n    void DFS(vector<vector<char>>& grid, int i, int j) {\\n        // boundary checking\\n        if(i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size())\\n            return;\\n        // return if current position is of water or is already visited\\n        if(grid[i][j] == \\'2\\' || grid[i][j] == \\'0\\')\\n            return;\\n        \\n        // mark the current as visited\\n        grid[i][j] = \\'2\\';\\n        \\n        // do DFS in all 4 directions\\n        DFS(grid, i+1, j);\\n        DFS(grid, i, j-1);\\n        DFS(grid, i-1, j);\\n        DFS(grid, i, j+1);\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        // We can treat the matrix grid as a grid. Each Island is a\\n        // connected component. The task is to find no. of disconnectedd components\\n        // in the graph.\\n        \\n        int islands = 0;\\n        // We make each 1 as 2 in when it is visited\\n        for(int i = 0; i < grid.size(); i++) {\\n            for(int j = 0; j < grid[0].size(); j++) {\\n                // do DFS in case has not been visited and there is land\\n                if(grid[i][j] == \\'1\\') {\\n                    DFS(grid, i, j);\\n                    ++islands;\\n                } \\n            }\\n        }\\n        return islands;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56338,
                "title": "java-dfs-and-bfs-solution",
                "content": "Using Flood Fill algorithm:\\n\\nDFS:\\n\\n    public int numIslands(char[][] grid) {\\n        int count=0;\\n        for(int i=0;i<grid.length;i++)\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]=='1'){\\n                    dfsFill(grid,i,j);\\n                    count++;\\n                }\\n            }\\n        return count;\\n    }\\n    private void dfsFill(char[][] grid,int i, int j){\\n        if(i>=0 && j>=0 && i<grid.length && j<grid[0].length&&grid[i][j]=='1'){\\n            grid[i][j]='0';\\n            dfsFill(grid, i + 1, j);\\n            dfsFill(grid, i - 1, j);\\n            dfsFill(grid, i, j + 1);\\n            dfsFill(grid, i, j - 1);\\n        }\\n    }\\n\\nBFS:\\n\\n    public int numIslands(char[][] grid) {\\n        int count=0;\\n        for(int i=0;i<grid.length;i++)\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]=='1'){\\n                    bfsFill(grid,i,j);\\n                    count++;\\n                }\\n            }\\n        return count;\\n    }\\n    private void bfsFill(char[][] grid,int x, int y){\\n        grid[x][y]='0';\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        LinkedList<Integer> queue = new LinkedList<Integer>();  \\n        int code = x*m+y;  \\n        queue.offer(code);  \\n        while(!queue.isEmpty())  \\n        {  \\n            code = queue.poll();  \\n            int i = code/m;  \\n            int j = code%m;  \\n            if(i>0 && grid[i-1][j]=='1')    //search upward and mark adjacent '1's as '0'.\\n            {  \\n                queue.offer((i-1)*m+j);  \\n                grid[i-1][j]='0';  \\n            }  \\n            if(i<n-1 && grid[i+1][j]=='1')  //down\\n            {  \\n                queue.offer((i+1)*m+j);  \\n                grid[i+1][j]='0';  \\n            }  \\n            if(j>0 && grid[i][j-1]=='1')  //left\\n            {  \\n                queue.offer(i*m+j-1);  \\n                grid[i][j-1]='0';  \\n            }  \\n            if(j<m-1 && grid[i][j+1]=='1')  //right\\n            {  \\n                queue.offer(i*m+j+1);  \\n                grid[i][j+1]='0';  \\n            }\\n        } \\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "Using Flood Fill algorithm:\\n\\nDFS:\\n\\n    public int numIslands(char[][] grid) {\\n        int count=0;\\n        for(int i=0;i<grid.length;i++)\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]=='1'){\\n                    dfsFill(grid,i,j);\\n                    count++;\\n                }\\n            }\\n        return count;\\n    }\\n    private void dfsFill(char[][] grid,int i, int j){\\n        if(i>=0 && j>=0 && i<grid.length && j<grid[0].length&&grid[i][j]=='1'){\\n            grid[i][j]='0';\\n            dfsFill(grid, i + 1, j);\\n            dfsFill(grid, i - 1, j);\\n            dfsFill(grid, i, j + 1);\\n            dfsFill(grid, i, j - 1);\\n        }\\n    }\\n\\nBFS:\\n\\n    public int numIslands(char[][] grid) {\\n        int count=0;\\n        for(int i=0;i<grid.length;i++)\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]=='1'){\\n                    bfsFill(grid,i,j);\\n                    count++;\\n                }\\n            }\\n        return count;\\n    }\\n    private void bfsFill(char[][] grid,int x, int y){\\n        grid[x][y]='0';\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        LinkedList<Integer> queue = new LinkedList<Integer>();  \\n        int code = x*m+y;  \\n        queue.offer(code);  \\n        while(!queue.isEmpty())  \\n        {  \\n            code = queue.poll();  \\n            int i = code/m;  \\n            int j = code%m;  \\n            if(i>0 && grid[i-1][j]=='1')    //search upward and mark adjacent '1's as '0'.\\n            {  \\n                queue.offer((i-1)*m+j);  \\n                grid[i-1][j]='0';  \\n            }  \\n            if(i<n-1 && grid[i+1][j]=='1')  //down\\n            {  \\n                queue.offer((i+1)*m+j);  \\n                grid[i+1][j]='0';  \\n            }  \\n            if(j>0 && grid[i][j-1]=='1')  //left\\n            {  \\n                queue.offer(i*m+j-1);  \\n                grid[i][j-1]='0';  \\n            }  \\n            if(j<m-1 && grid[i][j+1]=='1')  //right\\n            {  \\n                queue.offer(i*m+j+1);  \\n                grid[i][j+1]='0';  \\n            }\\n        } \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2497954,
                "title": "java-easy-solution-98-faster-code",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\npublic class Solution {\\n    public int numIslands(char[][] grid) {\\n        int count = 0;\\n        \\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    count++;\\n                    clearRestOfLand(grid, i, j);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    private void clearRestOfLand(char[][] grid, int i, int j) {\\n        if (i < 0 || j < 0 || i >= grid.length || j >= grid[i].length || grid[i][j] == \\'0\\') return;\\n        \\n        grid[i][j] = \\'0\\';\\n        clearRestOfLand(grid, i+1, j);\\n        clearRestOfLand(grid, i-1, j);\\n        clearRestOfLand(grid, i, j+1);\\n        clearRestOfLand(grid, i, j-1);\\n        return;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public int numIslands(char[][] grid) {\\n        int count = 0;\\n        \\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    count++;\\n                    clearRestOfLand(grid, i, j);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    private void clearRestOfLand(char[][] grid, int i, int j) {\\n        if (i < 0 || j < 0 || i >= grid.length || j >= grid[i].length || grid[i][j] == \\'0\\') return;\\n        \\n        grid[i][j] = \\'0\\';\\n        clearRestOfLand(grid, i+1, j);\\n        clearRestOfLand(grid, i-1, j);\\n        clearRestOfLand(grid, i, j+1);\\n        clearRestOfLand(grid, i, j-1);\\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56519,
                "title": "union-find-in-python",
                "content": "    class Solution(object):\\n        def numIslands(self, grid):\\n            \"\"\"\\n            :type grid: List[List[str]]\\n            :rtype: int\\n            \"\"\"\\n            if len(grid) == 0: return 0\\n            row = len(grid); col = len(grid[0])\\n            self.count = sum(grid[i][j]=='1' for i in range(row) for j in range(col))\\n            parent = [i for i in range(row*col)]\\n            \\n            def find(x):\\n                if parent[x]!= x:\\n                    return find(parent[x])\\n                return parent[x]\\n            \\n            def union(x,y):\\n                xroot, yroot = find(x),find(y)\\n                if xroot == yroot: return \\n                parent[xroot] = yroot\\n                self.count -= 1\\n            \\n            \\n            \\n            for i in range(row):\\n                for j in range(col):\\n                    if grid[i][j] == '0':\\n                        continue\\n                    index = i*col + j\\n                    if j < col-1 and grid[i][j+1] == '1':\\n                        union(index, index+1)\\n                    if i < row-1 and grid[i+1][j] == '1':\\n                        union(index, index+col)\\n            return self.count",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "    class Solution(object):\\n        def numIslands(self, grid):\\n            \"\"\"\\n            :type grid: List[List[str]]\\n            :rtype: int\\n            \"\"\"\\n            if len(grid) == 0: return 0\\n            row = len(grid); col = len(grid[0])\\n            self.count = sum(grid[i][j]=='1' for i in range(row) for j in range(col))\\n            parent = [i for i in range(row*col)]\\n            \\n            def find(x):\\n                if parent[x]!= x:\\n                    return find(parent[x])\\n                return parent[x]\\n            \\n            def union(x,y):\\n                xroot, yroot = find(x),find(y)\\n                if xroot == yroot: return \\n                parent[xroot] = yroot\\n                self.count -= 1\\n            \\n            \\n            \\n            for i in range(row):\\n                for j in range(col):\\n                    if grid[i][j] == '0':\\n                        continue\\n                    index = i*col + j\\n                    if j < col-1 and grid[i][j+1] == '1':\\n                        union(index, index+1)\\n                    if i < row-1 and grid[i+1][j] == '1':\\n                        union(index, index+col)\\n            return self.count",
                "codeTag": "Java"
            },
            {
                "id": 583745,
                "title": "python-3-solutions-dfs-bfs-union-find-concise-clean",
                "content": "**\\u2714\\uFE0F Solution 1: DFS**\\n```python\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        DIR = [0, 1, 0, -1, 0]\\n        \\n        def dfs(r, c):\\n            if r < 0 or r == m or c < 0 or c == n or grid[r][c] == \"0\": return 0\\n            grid[r][c] = \"0\"  # Mark as visited\\n            for i in range(4):\\n                dfs(r + DIR[i], c + DIR[i+1])\\n            return 1\\n        \\n        ans = 0\\n        for r in range(m):\\n            for c in range(n):\\n                ans += dfs(r, c)\\n        return ans\\n```\\n**Complexity**\\n- Time: `O(M*N)`, where `M <= 300` is number of rows, `N <= 300` is number of columns in the matrix.\\n- Space: `O(M*N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: BFS**\\n```python\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        DIR = [0, 1, 0, -1, 0]\\n    \\n        def bfs(r, c):\\n            if grid[r][c] == \"0\": return 0\\n            q = deque([(r, c)])\\n            while q:\\n                r, c = q.popleft()\\n                for i in range(4):\\n                    nr, nc = r + DIR[i], c + DIR[i+1]\\n                    if nr < 0 or nr == m or nc < 0 or nc == n or grid[nr][nc] == \"0\": continue\\n                    grid[nr][nc] = \"0\"  # Mark as visited\\n                    q.append([nr, nc])\\n            return 1\\n    \\n        ans = 0\\n        for r in range(m):\\n            for c in range(n):\\n                ans += bfs(r, c)\\n        return ans\\n```\\n**Complexity**\\n- Time: `O(M*N)`, where `M <= 300` is number of rows, `N <= 300` is number of columns in the matrix.\\n- Space: `O(M*N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 3a: Union-Find (Naive)**\\n```python\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n)]\\n        \\n    def find(self, u):\\n        while u != self.parent[u]:\\n            u = self.parent[u]\\n        return u\\n    \\n    def union(self, u, v):\\n        pu, pv = self.find(u), self.find(v)\\n        if pu == pv: return False\\n        self.parent[pu] = pv\\n        return True\\n\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        DIR = [0, 1, 0, -1, 0]\\n        m, n = len(grid), len(grid[0])\\n        uf = UnionFind(m*n)\\n        \\n        component = 0\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] == \"0\": continue\\n                component += 1\\n                curId = r * n + c\\n                for i in range(4):\\n                    nr, nc = r + DIR[i], c + DIR[i+1]\\n                    if nr < 0 or nr == m or nc < 0 or nc == n or grid[nr][nc] == \"0\": continue\\n                    neiId = nr * n + nc\\n                    if uf.union(curId, neiId):\\n                        component -= 1\\n        return component\\n```\\n**Complexity**\\n- Time: `O(MN^2)`, where `M <= 300` is number of rows, `N <= 300` is number of columns in the matrix.\\n- Space: `O(M*N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 3b: Union-Find (Path Compression)**\\n```python\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n)]\\n        \\n    def find(self, u):\\n        if u != self.parent[u]:\\n            self.parent[u] = self.find(self.parent[u])  # Path compression\\n        return self.parent[u]\\n    \\n    def union(self, u, v):\\n        pu, pv = self.find(u), self.find(v)\\n        if pu == pv: return False\\n        self.parent[pu] = pv\\n        return True\\n\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        DIR = [0, 1, 0, -1, 0]\\n        m, n = len(grid), len(grid[0])\\n        uf = UnionFind(m*n)\\n        \\n        component = 0\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] == \"0\": continue\\n                component += 1\\n                curId = r * n + c\\n                for i in range(4):\\n                    nr, nc = r + DIR[i], c + DIR[i+1]\\n                    if nr < 0 or nr == m or nc < 0 or nc == n or grid[nr][nc] == \"0\": continue\\n                    neiId = nr * n + nc\\n                    if uf.union(curId, neiId):\\n                        component -= 1\\n        return component\\n```\\n**Complexity**\\n- Time: `O(MN * logMN)`, where `M <= 300` is number of rows, `N <= 300` is number of columns in the matrix.\\n- Space: `O(M*N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 3c: Union-Find (Path Compression & Union by Size)**\\n```python\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n)]\\n        self.size = [1] * n\\n        \\n    def find(self, u):\\n        if u != self.parent[u]:\\n            self.parent[u] = self.find(self.parent[u])  # Path compression\\n        return self.parent[u]\\n    \\n    def union(self, u, v):\\n        pu, pv = self.find(u), self.find(v)\\n        if pu == pv: return False\\n        if self.size[pu] < self.size[pv]:  # Merge pu to pv\\n            self.size[pv] += self.size[pu]\\n            self.parent[pu] = pv\\n        else:\\n            self.size[pu] += self.size[pv]\\n            self.parent[pv] = pu\\n        return True\\n\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        DIR = [0, 1, 0, -1, 0]\\n        m, n = len(grid), len(grid[0])\\n        uf = UnionFind(m*n)\\n        \\n        component = 0\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] == \"0\": continue\\n                component += 1\\n                curId = r * n + c\\n                for i in range(4):\\n                    nr, nc = r + DIR[i], c + DIR[i+1]\\n                    if nr < 0 or nr == m or nc < 0 or nc == n or grid[nr][nc] == \"0\": continue\\n                    neiId = nr * n + nc\\n                    if uf.union(curId, neiId):\\n                        component -= 1\\n        return component\\n```\\n**Complexity**\\n- Time: `O(MN * \\u03B1(MN))`, where `M <= 300` is number of rows, `N <= 300` is number of columns in the matrix.\\n   Explanation: Using both **path compression** and **union by size** ensures that the **amortized time** per **UnionFind** operation is only `\\u03B1(n)`, which is optimal, where `\\u03B1(n)` is the inverse Ackermann function. This function has a value `\\u03B1(n) < 5` for any value of n that can be written in this physical universe, so the disjoint-set operations take place in essentially constant time.\\nReference: https://en.wikipedia.org/wiki/Disjoint-set_data_structure or https://www.slideshare.net/WeiLi73/time-complexity-of-union-find-55858534 for more information.\\n- Space: `O(M*N)`",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```python\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        DIR = [0, 1, 0, -1, 0]\\n        \\n        def dfs(r, c):\\n            if r < 0 or r == m or c < 0 or c == n or grid[r][c] == \"0\": return 0\\n            grid[r][c] = \"0\"  # Mark as visited\\n            for i in range(4):\\n                dfs(r + DIR[i], c + DIR[i+1])\\n            return 1\\n        \\n        ans = 0\\n        for r in range(m):\\n            for c in range(n):\\n                ans += dfs(r, c)\\n        return ans\\n```\n```python\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        DIR = [0, 1, 0, -1, 0]\\n    \\n        def bfs(r, c):\\n            if grid[r][c] == \"0\": return 0\\n            q = deque([(r, c)])\\n            while q:\\n                r, c = q.popleft()\\n                for i in range(4):\\n                    nr, nc = r + DIR[i], c + DIR[i+1]\\n                    if nr < 0 or nr == m or nc < 0 or nc == n or grid[nr][nc] == \"0\": continue\\n                    grid[nr][nc] = \"0\"  # Mark as visited\\n                    q.append([nr, nc])\\n            return 1\\n    \\n        ans = 0\\n        for r in range(m):\\n            for c in range(n):\\n                ans += bfs(r, c)\\n        return ans\\n```\n```python\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n)]\\n        \\n    def find(self, u):\\n        while u != self.parent[u]:\\n            u = self.parent[u]\\n        return u\\n    \\n    def union(self, u, v):\\n        pu, pv = self.find(u), self.find(v)\\n        if pu == pv: return False\\n        self.parent[pu] = pv\\n        return True\\n\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        DIR = [0, 1, 0, -1, 0]\\n        m, n = len(grid), len(grid[0])\\n        uf = UnionFind(m*n)\\n        \\n        component = 0\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] == \"0\": continue\\n                component += 1\\n                curId = r * n + c\\n                for i in range(4):\\n                    nr, nc = r + DIR[i], c + DIR[i+1]\\n                    if nr < 0 or nr == m or nc < 0 or nc == n or grid[nr][nc] == \"0\": continue\\n                    neiId = nr * n + nc\\n                    if uf.union(curId, neiId):\\n                        component -= 1\\n        return component\\n```\n```python\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n)]\\n        \\n    def find(self, u):\\n        if u != self.parent[u]:\\n            self.parent[u] = self.find(self.parent[u])  # Path compression\\n        return self.parent[u]\\n    \\n    def union(self, u, v):\\n        pu, pv = self.find(u), self.find(v)\\n        if pu == pv: return False\\n        self.parent[pu] = pv\\n        return True\\n\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        DIR = [0, 1, 0, -1, 0]\\n        m, n = len(grid), len(grid[0])\\n        uf = UnionFind(m*n)\\n        \\n        component = 0\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] == \"0\": continue\\n                component += 1\\n                curId = r * n + c\\n                for i in range(4):\\n                    nr, nc = r + DIR[i], c + DIR[i+1]\\n                    if nr < 0 or nr == m or nc < 0 or nc == n or grid[nr][nc] == \"0\": continue\\n                    neiId = nr * n + nc\\n                    if uf.union(curId, neiId):\\n                        component -= 1\\n        return component\\n```\n```python\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n)]\\n        self.size = [1] * n\\n        \\n    def find(self, u):\\n        if u != self.parent[u]:\\n            self.parent[u] = self.find(self.parent[u])  # Path compression\\n        return self.parent[u]\\n    \\n    def union(self, u, v):\\n        pu, pv = self.find(u), self.find(v)\\n        if pu == pv: return False\\n        if self.size[pu] < self.size[pv]:  # Merge pu to pv\\n            self.size[pv] += self.size[pu]\\n            self.parent[pu] = pv\\n        else:\\n            self.size[pu] += self.size[pv]\\n            self.parent[pv] = pu\\n        return True\\n\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        DIR = [0, 1, 0, -1, 0]\\n        m, n = len(grid), len(grid[0])\\n        uf = UnionFind(m*n)\\n        \\n        component = 0\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] == \"0\": continue\\n                component += 1\\n                curId = r * n + c\\n                for i in range(4):\\n                    nr, nc = r + DIR[i], c + DIR[i+1]\\n                    if nr < 0 or nr == m or nc < 0 or nc == n or grid[nr][nc] == \"0\": continue\\n                    neiId = nr * n + nc\\n                    if uf.union(curId, neiId):\\n                        component -= 1\\n        return component\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56364,
                "title": "java-union-find-solution",
                "content": "class UF {\\n\\n    public int count = 0;\\n    public int[] id = null;\\n    \\n    public UF(int m, int n, char[][] grid) {\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] == '1') count++;\\n            }\\n        }\\n        id = new int[m * n];\\n        for(int i = 0; i < m * n; i++) {\\n            id[i] = i;\\n        }\\n    }\\n    \\n    public int find(int p) {\\n        while(p != id[p]) {\\n            id[p] = id[id[p]];\\n            p = id[p];\\n        }\\n        return p;\\n    }\\n    \\n    public boolean isConnected(int p, int q) {\\n        int pRoot = find(p);\\n        int qRoot = find(q);\\n        if(pRoot != qRoot) return false;\\n        else return true;\\n    }\\n    \\n    public void union(int p, int q) {\\n        int pRoot = find(p);\\n        int qRoot = find(q);\\n        if(pRoot == qRoot) return;\\n        id[pRoot] = qRoot;\\n        count--;\\n    }\\n}\\n\\n    public int numIslands(char[][] grid) {\\n        if(grid.length == 0 || grid[0].length == 0) return 0;\\n        int m = grid.length, n = grid[0].length;\\n        UF uf = new UF(m , n, grid);\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] == '0') continue;\\n                int p = i * n + j;\\n                int q;\\n                if(i > 0 && grid[i - 1][j] == '1') {\\n                    q = p - n;\\n                    uf.union(p, q);\\n                }\\n                if(i < m - 1 && grid[i + 1][j] == '1') {\\n                    q = p + n;\\n                    uf.union(p, q);\\n                }\\n                if(j > 0 && grid[i][j - 1] == '1') {\\n                    q = p - 1;\\n                    uf.union(p, q);\\n                }\\n                if(j < n - 1 && grid[i][j + 1] == '1') {\\n                    q = p + 1;\\n                    uf.union(p, q);\\n                }\\n            }\\n        }\\n        return uf.count;\\n    }",
                "solutionTags": [],
                "code": "class UF {\\n\\n    public int count = 0;\\n    public int[] id = null;\\n    \\n    public UF(int m, int n, char[][] grid) {\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] == '1') count++;\\n            }\\n        }\\n        id = new int[m * n];\\n        for(int i = 0; i < m * n; i++) {\\n            id[i] = i;\\n        }\\n    }\\n    \\n    public int find(int p) {\\n        while(p != id[p]) {\\n            id[p] = id[id[p]];\\n            p = id[p];\\n        }\\n        return p;\\n    }\\n    \\n    public boolean isConnected(int p, int q) {\\n        int pRoot = find(p);\\n        int qRoot = find(q);\\n        if(pRoot != qRoot) return false;\\n        else return true;\\n    }\\n    \\n    public void union(int p, int q) {\\n        int pRoot = find(p);\\n        int qRoot = find(q);\\n        if(pRoot == qRoot) return;\\n        id[pRoot] = qRoot;\\n        count--;\\n    }\\n}\\n\\n    public int numIslands(char[][] grid) {\\n        if(grid.length == 0 || grid[0].length == 0) return 0;\\n        int m = grid.length, n = grid[0].length;\\n        UF uf = new UF(m , n, grid);\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] == '0') continue;\\n                int p = i * n + j;\\n                int q;\\n                if(i > 0 && grid[i - 1][j] == '1') {\\n                    q = p - n;\\n                    uf.union(p, q);\\n                }\\n                if(i < m - 1 && grid[i + 1][j] == '1') {\\n                    q = p + n;\\n                    uf.union(p, q);\\n                }\\n                if(j > 0 && grid[i][j - 1] == '1') {\\n                    q = p - 1;\\n                    uf.union(p, q);\\n                }\\n                if(j < n - 1 && grid[i][j + 1] == '1') {\\n                    q = p + 1;\\n                    uf.union(p, q);\\n                }\\n            }\\n        }\\n        return uf.count;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 121164,
                "title": "python-bfs-and-dfs-solution",
                "content": "```\\nclass Solution(object):\\n    def is_valid(self, grid, r, c):\\n        m, n = len(grid), len(grid[0])\\n        if r < 0 or c < 0 or r >= m or c >= n:\\n            return False\\n        return True\\n\\n    def numIslandsDFS(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid or not grid[0]:\\n            return 0\\n\\n        m, n = len(grid), len(grid[0])\\n        count = 0\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                if grid[i][j] == \\'1\\':\\n                    self.dfs(grid, i, j)\\n                    count += 1\\n        return count\\n\\n    def dfs(self, grid, r, c):\\n        grid[r][c] = \\'0\\'\\n        directions = [(0,1), (0,-1), (-1,0), (1,0)]\\n        for d in directions:\\n            nr, nc = r + d[0], c + d[1]    \\n            if self.is_valid(grid, nr, nc) and grid[nr][nc] == \\'1\\':\\n                self.dfs(grid, nr, nc)\\n\\n    def numIslandsBFS(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid or not grid[0]:\\n            return 0\\n\\n        m, n = len(grid), len(grid[0])\\n        count = 0\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                if grid[i][j] == \\'1\\':\\n                    self.bfs(grid, i, j)\\n                    count += 1\\n        return count\\n\\n    def bfs(self, grid, r, c):\\n        queue = collections.deque()\\n        queue.append((r, c))\\n        grid[r][c] = \\'0\\'\\n        while queue:\\n            directions = [(0,1), (0,-1), (-1,0), (1,0)]\\n            r, c = queue.popleft()\\n            for d in directions:\\n                nr, nc = r + d[0], c + d[1]    \\n                if self.is_valid(grid, nr, nc) and grid[nr][nc] == \\'1\\':\\n                    queue.append((nr, nc))\\n                    grid[nr][nc] = \\'0\\'\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def is_valid(self, grid, r, c):\\n        m, n = len(grid), len(grid[0])\\n        if r < 0 or c < 0 or r >= m or c >= n:\\n            return False\\n        return True\\n\\n    def numIslandsDFS(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid or not grid[0]:\\n            return 0\\n\\n        m, n = len(grid), len(grid[0])\\n        count = 0\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                if grid[i][j] == \\'1\\':\\n                    self.dfs(grid, i, j)\\n                    count += 1\\n        return count\\n\\n    def dfs(self, grid, r, c):\\n        grid[r][c] = \\'0\\'\\n        directions = [(0,1), (0,-1), (-1,0), (1,0)]\\n        for d in directions:\\n            nr, nc = r + d[0], c + d[1]    \\n            if self.is_valid(grid, nr, nc) and grid[nr][nc] == \\'1\\':\\n                self.dfs(grid, nr, nc)\\n\\n    def numIslandsBFS(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid or not grid[0]:\\n            return 0\\n\\n        m, n = len(grid), len(grid[0])\\n        count = 0\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                if grid[i][j] == \\'1\\':\\n                    self.bfs(grid, i, j)\\n                    count += 1\\n        return count\\n\\n    def bfs(self, grid, r, c):\\n        queue = collections.deque()\\n        queue.append((r, c))\\n        grid[r][c] = \\'0\\'\\n        while queue:\\n            directions = [(0,1), (0,-1), (-1,0), (1,0)]\\n            r, c = queue.popleft()\\n            for d in directions:\\n                nr, nc = r + d[0], c + d[1]    \\n                if self.is_valid(grid, nr, nc) and grid[nr][nc] == \\'1\\':\\n                    queue.append((nr, nc))\\n                    grid[nr][nc] = \\'0\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2497909,
                "title": "c-python-explained",
                "content": "**UPVOTE IF HELPFuuL**\\n\\nWe need to count ```number of groups of \\'1\\'```.  But only single ```\"1\"``` is to be counted from one island.\\n\\n**APPROACH**\\nWe traverse the ```grid``` element by element.\\nWhen :\\n* ```grid[i][j] == \"0\"``` -> Do nothing\\n* ```grid[i][j] == \"1\"``` ->There is an island.\\n* * Increase the count of islands by one.\\n* * Now we need to remove the island from the grid. ```[ WHY : It is done to prevent counting the rest of \"1\" that belong to same island ]```\\n* * We can use **DFS** to traverse through the island, where :\\n* * * If ```\"1\"``` is there, make it ```\"0\"```.\\n* * * Break out if we reach out of boundaries or we encounter ```\"0\"``` -> water.\\n* * * And to the same for neighbouring cells. ```[ i + 1 , i - 1 , j + 1 , j - 1 ]```\\n\\n**UPVOTE IF HELPFuuL**\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    \\n    void turn_to_dust(vector<vector<char>>& grid, int i, int j, int m, int n){\\n        if (i<0 || j<0 || i==m || j==n || grid[i][j]==\\'0\\') return;\\n        grid[i][j]=\\'0\\';\\n        turn_to_dust(grid,i+1,j,m,n);\\n        turn_to_dust(grid,i,j+1,m,n);\\n        turn_to_dust(grid,i-1,j,m,n);\\n        turn_to_dust(grid,i,j-1,m,n);\\n        return;\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int res=0;\\n        for (int i=0; i<m; i++){\\n            for (int j=0; j<n; j++){\\n                if (grid[i][j]==\\'1\\'){\\n                    res++;\\n                    turn_to_dust(grid,i,j,m,n);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**PYTHON**\\n```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        \\n        def turn_to_dust(i,j):\\n            if (i<0 or j<0 or i==len(grid) or j==len(grid[0]) or grid[i][j]==\"0\"):\\n                return\\n            grid[i][j]=\"0\"\\n            turn_to_dust(i,j+1)\\n            turn_to_dust(i,j-1)\\n            turn_to_dust(i+1,j)\\n            turn_to_dust(i-1,j)\\n            return\\n        res=0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]==\"1\":\\n                    res+=1\\n                    turn_to_dust(i,j)\\n        return res\\n```\\n![image](https://assets.leetcode.com/users/images/482ee389-ecd1-44f0-a898-414316dc069d_1661737467.6832316.webp)\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```number of groups of \\'1\\'```\n```\"1\"```\n```grid```\n```grid[i][j] == \"0\"```\n```grid[i][j] == \"1\"```\n```[ WHY : It is done to prevent counting the rest of \"1\" that belong to same island ]```\n```\"1\"```\n```\"0\"```\n```\"0\"```\n```[ i + 1 , i - 1 , j + 1 , j - 1 ]```\n```\\nclass Solution {\\npublic:\\n    \\n    void turn_to_dust(vector<vector<char>>& grid, int i, int j, int m, int n){\\n        if (i<0 || j<0 || i==m || j==n || grid[i][j]==\\'0\\') return;\\n        grid[i][j]=\\'0\\';\\n        turn_to_dust(grid,i+1,j,m,n);\\n        turn_to_dust(grid,i,j+1,m,n);\\n        turn_to_dust(grid,i-1,j,m,n);\\n        turn_to_dust(grid,i,j-1,m,n);\\n        return;\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int res=0;\\n        for (int i=0; i<m; i++){\\n            for (int j=0; j<n; j++){\\n                if (grid[i][j]==\\'1\\'){\\n                    res++;\\n                    turn_to_dust(grid,i,j,m,n);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        \\n        def turn_to_dust(i,j):\\n            if (i<0 or j<0 or i==len(grid) or j==len(grid[0]) or grid[i][j]==\"0\"):\\n                return\\n            grid[i][j]=\"0\"\\n            turn_to_dust(i,j+1)\\n            turn_to_dust(i,j-1)\\n            turn_to_dust(i+1,j)\\n            turn_to_dust(i-1,j)\\n            return\\n        res=0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]==\"1\":\\n                    res+=1\\n                    turn_to_dust(i,j)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56460,
                "title": "clear-easy-java-solution",
                "content": "    public class Solution {\\n        public int numIslands(char[][] grid) {\\n            int count = 0;\\n            \\n            for (int i = 0; i < grid.length; i++) {\\n                for (int j = 0; j < grid[i].length; j++) {\\n                    if (grid[i][j] == '1') {\\n                        count++;\\n                        clearRestOfLand(grid, i, j);\\n                    }\\n                }\\n            }\\n            return count;\\n        }\\n        \\n        private void clearRestOfLand(char[][] grid, int i, int j) {\\n            if (i < 0 || j < 0 || i >= grid.length || j >= grid[i].length || grid[i][j] == '0') return;\\n            \\n            grid[i][j] = '0';\\n            clearRestOfLand(grid, i+1, j);\\n            clearRestOfLand(grid, i-1, j);\\n            clearRestOfLand(grid, i, j+1);\\n            clearRestOfLand(grid, i, j-1);\\n            return;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int numIslands(char[][] grid) {\\n            int count = 0;\\n            \\n            for (int i = 0; i < grid.length; i++) {\\n                for (int j = 0; j < grid[i].length; j++) {\\n                    if (grid[i][j] == '1') {\\n                        count++;\\n                        clearRestOfLand(grid, i, j);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 429842,
                "title": "javascript-dfs-commented-thought-process-beats-100-time-and-space",
                "content": "Below is what I typed out on a google doc in preparation for a google phone interview.\\nI thought it may be helpful for others to see and  give feedback on my thought process, and if it makes sense/is followable. After all, that\\'s what I want my interviewer to do, understand me. \\nGoal: Count number of islands\\nRules: \\n1) An island is surrounded by water(0\\'s)\\n2) We count things apart of our island if it is horizontal or vertical connected\\nPlan: \\nStart at the top left of the 2d array, and visit the first row, and all its columns, trying to find the start of the first island\\nOnce we find a 1, we can increment the number of islands, but we want to know where the island ends. So let\\u2019s look and follow any of the horizontal or vertical spots near the current position we are on. \\nFirst, let\\u2019s mark the current start/visited parts of the islands as visited by turning them into a 0,\\nSecond, explore all the adjacent possibilities,\\nIf one of them is a 1, recursively turn it into a 0 and check its children\\nOnce we are done, we should have gotten rid of the island that we discovered and can move on to the next island, if it exists in the 2d array\\n```\\nconst numIslands =  (grid) => {\\n\\tlet count = 0 // the counted islands\\n\\t//Go though each cell of the 2d array/grid \\n\\tfor(let row = 0; row < grid.length; row++){\\n\\tfor(let col = 0; col < grid[row].length; col ++){\\n\\tif(grid[row][col] == \\'1\\'){\\n\\t\\tcount ++\\n\\t\\texplore(row,col, grid)\\n            }\\n        }\\n    }\\n    return count\\n}\\n\\n\\n\\n// Takes a cell in a grid with a \\u201C1\\u201D , turns it into a \\u201C0\\u201D and explores (DFS) any of the left, right, up, down 1\\u2019s\\nfunction explore(row, col, grid){\\n    //Let\\'s return IF\\n    // row < 0 OR col < 0 OR row is out of bounds(meaning the row is larger than the number of arrays in the 2d array) OR col is at/out of bounds (meaning the current col is at/over the number of elements a row has.)\\n     if (row < 0 || col < 0 || row >= grid.length  \\n         || col >= grid[row].length || grid[row][col] === \\'0\\')  {\\n        return\\n    }\\n    \\n    //Otherwise, we should explore it!\\n    //First let\\'s set the current spot to \"0\"\\n    grid[row][col]=\\'0\\'\\n    \\n\\t//Possibilites:\\n\\t// 1) 1 to the right, left, top, bottom\\n\\t//right\\n\\texplore(row, col+1, grid)   \\n    //Left\\n\\texplore(row, col-1, grid)  \\n    //Down\\n\\texplore(row+1, col, grid) \\n    //Up\\n\\texplore(row-1, col, grid)   \\n\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nconst numIslands =  (grid) => {\\n\\tlet count = 0 // the counted islands\\n\\t//Go though each cell of the 2d array/grid \\n\\tfor(let row = 0; row < grid.length; row++){\\n\\tfor(let col = 0; col < grid[row].length; col ++){\\n\\tif(grid[row][col] == \\'1\\'){\\n\\t\\tcount ++\\n\\t\\texplore(row,col, grid)\\n            }\\n        }\\n    }\\n    return count\\n}\\n\\n\\n\\n// Takes a cell in a grid with a \\u201C1\\u201D , turns it into a \\u201C0\\u201D and explores (DFS) any of the left, right, up, down 1\\u2019s\\nfunction explore(row, col, grid){\\n    //Let\\'s return IF\\n    // row < 0 OR col < 0 OR row is out of bounds(meaning the row is larger than the number of arrays in the 2d array) OR col is at/out of bounds (meaning the current col is at/over the number of elements a row has.)\\n     if (row < 0 || col < 0 || row >= grid.length  \\n         || col >= grid[row].length || grid[row][col] === \\'0\\')  {\\n        return\\n    }\\n    \\n    //Otherwise, we should explore it!\\n    //First let\\'s set the current spot to \"0\"\\n    grid[row][col]=\\'0\\'\\n    \\n\\t//Possibilites:\\n\\t// 1) 1 to the right, left, top, bottom\\n\\t//right\\n\\texplore(row, col+1, grid)   \\n    //Left\\n\\texplore(row, col-1, grid)  \\n    //Down\\n\\texplore(row+1, col, grid) \\n    //Up\\n\\texplore(row-1, col, grid)   \\n\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 56347,
                "title": "simple-java-solution",
                "content": "    public class NumberofIslands {\\n    \\tstatic int[] dx = {-1,0,0,1};\\n    \\tstatic int[] dy = {0,1,-1,0};\\n    \\tpublic static int numIslands(char[][] grid) {\\n    \\t\\tif(grid==null || grid.length==0) return 0;\\n    \\t\\tint islands = 0;\\n    \\t\\tfor(int i=0;i<grid.length;i++) {\\n    \\t\\t\\tfor(int j=0;j<grid[i].length;j++) {\\n    \\t\\t\\t\\tif(grid[i][j]=='1') {\\n    \\t\\t\\t\\t\\texplore(grid,i,j);\\n    \\t\\t\\t\\t\\tislands++;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn islands;\\n    \\t}\\n    \\tpublic static void explore(char[][] grid, int i, int j) {\\n    \\t\\tgrid[i][j]='x';\\n    \\t\\tfor(int d=0;d<dx.length;d++) {\\n    \\t\\t\\tif(i+dy[d]<grid.length && i+dy[d]>=0 && j+dx[d]<grid[0].length && j+dx[d]>=0 && grid[i+dy[d]][j+dx[d]]=='1') {\\n    \\t\\t\\t\\texplore(grid,i+dy[d],j+dx[d]);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    }\\n\\nThe algorithm works as follow:\\n\\n 1. Scan each cell in the grid.\\n 2. If the cell value is '1' explore that island.\\n 3. Mark the explored island cells with 'x'.\\n 4. Once finished exploring that island, increment islands counter.\\n\\nThe arrays dx[], dy[] store the possible moves from the current cell. Two land cells ['1'] are considered from the same island if they are horizontally or vertically adjacent (possible moves (-1,0),(0,1),(0,-1),(1,0)). Two '1' diagonally adjacent are not considered from the same island.",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public class NumberofIslands {\\n    \\tstatic int[] dx = {-1,0,0,1};\\n    \\tstatic int[] dy = {0,1,-1,0};\\n    \\tpublic static int numIslands(char[][] grid) {\\n    \\t\\tif(grid==null || grid.length==0) return 0;\\n    \\t\\tint islands = 0;\\n    \\t\\tfor(int i=0;i<grid.length;i++) {\\n    \\t\\t\\tfor(int j=0;j<grid[i].length;j++) {\\n    \\t\\t\\t\\tif(grid[i][j]=='1') {\\n    \\t\\t\\t\\t\\texplore(grid,i,j);\\n    \\t\\t\\t\\t\\tislands++;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn islands;\\n    \\t}\\n    \\tpublic static void explore(char[][] grid, int i, int j) {\\n    \\t\\tgrid[i][j]='x';\\n    \\t\\tfor(int d=0;d<dx.length;d++) {\\n    \\t\\t\\tif(i+dy[d]<grid.length && i+dy[d]>=0 && j+dx[d]<grid[0].length && j+dx[d]>=0 && grid[i+dy[d]][j+dx[d]]=='1') {\\n    \\t\\t\\t\\texplore(grid,i+dy[d],j+dx[d]);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    }\\n\\nThe algorithm works as follow:\\n\\n 1. Scan each cell in the grid.\\n 2. If the cell value is '1' explore that island.\\n 3. Mark the explored island cells with 'x'.\\n 4. Once finished exploring that island, increment islands counter.\\n\\nThe arrays dx[], dy[] store the possible moves from the current cell. Two land cells ['1'] are considered from the same island if they are horizontally or vertically adjacent (possible moves (-1,0),(0,1),(0,-1),(1,0)). Two '1' diagonally adjacent are not considered from the same island.",
                "codeTag": "Java"
            },
            {
                "id": 863366,
                "title": "python-3-dfs-bfs-union-find-all-3-methods-explanation",
                "content": "### Approach \\\\#1. DFS\\n- Iterate over the matrix and DFS at each point whenever a point is land (`1`)\\n- Mark visited as `2` to avoid revisit\\n- Increment `ans` each time need to do a DFS (original, not recursive)\\n```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        if not grid: return 0\\n        m, n = len(grid), len(grid[0])\\n        ans = 0\\n        def dfs(i, j):\\n            grid[i][j] = \\'2\\'\\n            for di, dj in (0, 1), (0, -1), (1, 0), (-1, 0):\\n                ii, jj = i+di, j+dj\\n                if 0 <= ii < m and 0 <= jj < n and grid[ii][jj] == \\'1\\':\\n                    dfs(ii, jj)\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \\'1\\':\\n                    dfs(i, j)\\n                    ans += 1\\n        return ans\\n```\\n\\n### Approach \\\\#2. BFS\\n- Iterate over the matrix and BFS at each point whenever a point is land (`1`)\\n- Mark visited as `2` to avoid revisit\\n- Increment `ans` each time need to do a BFS (original, not recursive)\\n```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        if not grid: return 0\\n        m, n = len(grid), len(grid[0])\\n        ans = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \\'1\\':\\n                    q = collections.deque([(i, j)])\\n                    grid[i][j] = \\'2\\'\\n                    while q:\\n                        x, y = q.popleft()\\n                        for dx, dy in (0, 1), (0, -1), (1, 0), (-1, 0):\\n                            xx, yy = x+dx, y+dy\\n                            if 0 <= xx < m and 0 <= yy < n and grid[xx][yy] == \\'1\\':\\n                                q.append((xx, yy))\\n                                grid[xx][yy] = \\'2\\'\\n                    ans += 1            \\n        return ans\\n```\\n\\n### Approach \\\\#3. Union Find\\n- Create dictionary `d[(i,j)] = idx`, give `(x,y)` an id number, for eaiser union find\\n- Create a Union Find object with length of number of `\"1\"` (say length is `n` or `size`)\\n- Iterate over matrix, from left to right, from top to bottom\\n\\t- Union current and left or right, if they are both `1`\\n\\t- For each union, decrement `size`\\n- Return `size`\\n```\\nclass UF:\\n    def __init__(self, n):\\n        self.p = [i for i in range(n)]\\n        self.n = n\\n        self.size = n\\n\\n    def union(self, i, j):\\n        pi, pj = self.find(i), self.find(j)\\n        if pi != pj:\\n            self.size -= 1\\n            self.p[pj] = pi\\n\\n    def find(self, i):\\n        if i != self.p[i]:\\n            self.p[i] = self.find(self.p[i])\\n        return self.p[i]\\n\\n\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        if not grid:\\n            return 0\\n        m, n = len(grid), len(grid[0])\\n        d = dict()\\n        idx = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \\'1\\':\\n                    d[i, j] = idx\\n                    idx += 1\\n        uf = UF(idx)\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \\'1\\':\\n                    if i > 0 and grid[i-1][j] == \\'1\\':\\n                        uf.union(d[i-1, j], d[i, j])\\n                    if j > 0 and grid[i][j-1] == \\'1\\':\\n                        uf.union(d[i, j-1], d[i, j])\\n        return uf.size\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        if not grid: return 0\\n        m, n = len(grid), len(grid[0])\\n        ans = 0\\n        def dfs(i, j):\\n            grid[i][j] = \\'2\\'\\n            for di, dj in (0, 1), (0, -1), (1, 0), (-1, 0):\\n                ii, jj = i+di, j+dj\\n                if 0 <= ii < m and 0 <= jj < n and grid[ii][jj] == \\'1\\':\\n                    dfs(ii, jj)\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \\'1\\':\\n                    dfs(i, j)\\n                    ans += 1\\n        return ans\\n```\n```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        if not grid: return 0\\n        m, n = len(grid), len(grid[0])\\n        ans = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \\'1\\':\\n                    q = collections.deque([(i, j)])\\n                    grid[i][j] = \\'2\\'\\n                    while q:\\n                        x, y = q.popleft()\\n                        for dx, dy in (0, 1), (0, -1), (1, 0), (-1, 0):\\n                            xx, yy = x+dx, y+dy\\n                            if 0 <= xx < m and 0 <= yy < n and grid[xx][yy] == \\'1\\':\\n                                q.append((xx, yy))\\n                                grid[xx][yy] = \\'2\\'\\n                    ans += 1            \\n        return ans\\n```\n```\\nclass UF:\\n    def __init__(self, n):\\n        self.p = [i for i in range(n)]\\n        self.n = n\\n        self.size = n\\n\\n    def union(self, i, j):\\n        pi, pj = self.find(i), self.find(j)\\n        if pi != pj:\\n            self.size -= 1\\n            self.p[pj] = pi\\n\\n    def find(self, i):\\n        if i != self.p[i]:\\n            self.p[i] = self.find(self.p[i])\\n        return self.p[i]\\n\\n\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        if not grid:\\n            return 0\\n        m, n = len(grid), len(grid[0])\\n        d = dict()\\n        idx = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \\'1\\':\\n                    d[i, j] = idx\\n                    idx += 1\\n        uf = UF(idx)\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \\'1\\':\\n                    if i > 0 and grid[i-1][j] == \\'1\\':\\n                        uf.union(d[i-1, j], d[i, j])\\n                    if j > 0 and grid[i][j-1] == \\'1\\':\\n                        uf.union(d[i, j-1], d[i, j])\\n        return uf.size\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2497897,
                "title": "python-c-c-95-easy-dfs-explained-beginner-friendly",
                "content": "**Idea:**\\n1. loop through\\n2. do dfs for every island, mark down visited island\\n3. increase the counter by 1\\n\\n<iframe src=\"https://leetcode.com/playground/bMUsJpSD/shared\" frameBorder=\"0\" width=\"1000\" height=\"500\"></iframe>\\n\\n**Please UPVOTE if you LIKE!!!**",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "**Idea:**\\n1. loop through\\n2. do dfs for every island, mark down visited island\\n3. increase the counter by 1\\n\\n<iframe src=\"https://leetcode.com/playground/bMUsJpSD/shared\" frameBorder=\"0\" width=\"1000\" height=\"500\"></iframe>\\n\\n**Please UPVOTE if you LIKE!!!**",
                "codeTag": "Unknown"
            },
            {
                "id": 1511737,
                "title": "c-all-3-methods-dfs-bfs-union-find",
                "content": "**Method 1: DFS**\\nTime Complexity : O(n x m)\\nSpace Complexity: O(n x m)\\n\\n```\\nclass Solution {\\npublic:\\n    int DR[4]={1, 0, -1, 0};\\n    int DC[4]={0, -1, 0, 1};\\n    \\n    bool valid_index(int i, int j, vector<vector<char>>& grid) {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size())\\n            return false;\\n        return true;\\n    }\\n    \\n    void dfs(int i, int j, vector<vector<char>>& grid) {\\n        grid[i][j]=\\'0\\';\\n        for(int k=0; k<4; k++) {\\n            int ci=DR[k]+i;\\n            int cj=DC[k]+j;\\n            if(!valid_index(ci, cj, grid))\\n                continue;\\n            if(grid[ci][cj]==\\'1\\')\\n                dfs(ci, cj, grid);\\n        }\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int no_of_islands=0;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(grid[i][j]==\\'1\\') {\\n                    no_of_islands++;\\n                    dfs(i, j, grid);\\n                }\\n            }\\n        }\\n        return no_of_islands;\\n    }\\n};\\n```\\n\\n**Method 2: BFS**\\nTime Complexity : O(n x m)\\nSpace Complexity: O(n x m)\\n\\n```\\nclass Solution {\\npublic:\\n    int DR[4]={1, 0, -1, 0};\\n    int DC[4]={0, -1, 0, 1};\\n    \\n    bool valid_index(int i, int j, vector<vector<char>>& grid) {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size())\\n            return false;\\n        return true;\\n    }\\n    \\n    void bfs(int i, int j, vector<vector<char>>& grid) {\\n        grid[i][j]=\\'0\\';\\n        queue<pair<int, int>> q;\\n        q.push({i, j});\\n        while(!q.empty()) {\\n            int i=q.front().first;\\n            int j=q.front().second;\\n            q.pop();\\n            for(int k=0; k<4; k++) {\\n                int ci=DR[k]+i;\\n                int cj=DC[k]+j;\\n                if(!valid_index(ci, cj, grid))\\n                    continue;\\n                if(grid[ci][cj]==\\'1\\') {\\n                    q.push({ci, cj});\\n                    grid[ci][cj]=\\'0\\';\\n                }\\n            }\\n        }\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int no_of_islands=0;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(grid[i][j]==\\'1\\') {\\n                    no_of_islands++;\\n                    bfs(i, j, grid);\\n                }\\n            }\\n        }\\n        return no_of_islands;\\n    }\\n};\\n```\\n\\n**Method 3: Union Find**\\nTime Complexity : O(n x m)\\nSpace Complexity: O(n x m)\\n\\n```\\nclass Solution {\\npublic:\\n    int no_of_islands=0;\\n    int DC[4]={0, 1, 0, -1};\\n    int DR[4]={1, 0, -1, 0};\\n    \\n    int find_parent(int a, vector<int> &parent) {\\n        if(parent[a]==a) return a;\\n        return parent[a]=find_parent(parent[a], parent);\\n    }\\n    \\n    void union_(int a, int b, vector<int> &parent) {\\n        int pa=find_parent(a, parent);\\n        int pb=find_parent(b, parent);\\n        if(pa==pb) return;\\n        parent[pa]=pb;\\n        no_of_islands--;\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int> parent(n*m);        \\n        for(int i=0; i<n*m; i++)\\n            parent[i]=i;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(grid[i][j]==\\'1\\') {\\n                    no_of_islands++;\\n                    for(int k=0; k<4; k++) {\\n                        int ci=DR[k]+i;\\n                        int cj=DC[k]+j;\\n                        if(ci<0 || cj<0 || ci>=n || cj>=m)\\n                            continue;\\n                        if(grid[ci][cj]==\\'1\\') {\\n                            union_((i*m)+j, (ci*m)+cj, parent);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return no_of_islands;\\n    }\\n};\\n```\\n\\n*Please upvote if you find it helpful*",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int DR[4]={1, 0, -1, 0};\\n    int DC[4]={0, -1, 0, 1};\\n    \\n    bool valid_index(int i, int j, vector<vector<char>>& grid) {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size())\\n            return false;\\n        return true;\\n    }\\n    \\n    void dfs(int i, int j, vector<vector<char>>& grid) {\\n        grid[i][j]=\\'0\\';\\n        for(int k=0; k<4; k++) {\\n            int ci=DR[k]+i;\\n            int cj=DC[k]+j;\\n            if(!valid_index(ci, cj, grid))\\n                continue;\\n            if(grid[ci][cj]==\\'1\\')\\n                dfs(ci, cj, grid);\\n        }\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int no_of_islands=0;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(grid[i][j]==\\'1\\') {\\n                    no_of_islands++;\\n                    dfs(i, j, grid);\\n                }\\n            }\\n        }\\n        return no_of_islands;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int DR[4]={1, 0, -1, 0};\\n    int DC[4]={0, -1, 0, 1};\\n    \\n    bool valid_index(int i, int j, vector<vector<char>>& grid) {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size())\\n            return false;\\n        return true;\\n    }\\n    \\n    void bfs(int i, int j, vector<vector<char>>& grid) {\\n        grid[i][j]=\\'0\\';\\n        queue<pair<int, int>> q;\\n        q.push({i, j});\\n        while(!q.empty()) {\\n            int i=q.front().first;\\n            int j=q.front().second;\\n            q.pop();\\n            for(int k=0; k<4; k++) {\\n                int ci=DR[k]+i;\\n                int cj=DC[k]+j;\\n                if(!valid_index(ci, cj, grid))\\n                    continue;\\n                if(grid[ci][cj]==\\'1\\') {\\n                    q.push({ci, cj});\\n                    grid[ci][cj]=\\'0\\';\\n                }\\n            }\\n        }\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int no_of_islands=0;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(grid[i][j]==\\'1\\') {\\n                    no_of_islands++;\\n                    bfs(i, j, grid);\\n                }\\n            }\\n        }\\n        return no_of_islands;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int no_of_islands=0;\\n    int DC[4]={0, 1, 0, -1};\\n    int DR[4]={1, 0, -1, 0};\\n    \\n    int find_parent(int a, vector<int> &parent) {\\n        if(parent[a]==a) return a;\\n        return parent[a]=find_parent(parent[a], parent);\\n    }\\n    \\n    void union_(int a, int b, vector<int> &parent) {\\n        int pa=find_parent(a, parent);\\n        int pb=find_parent(b, parent);\\n        if(pa==pb) return;\\n        parent[pa]=pb;\\n        no_of_islands--;\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int> parent(n*m);        \\n        for(int i=0; i<n*m; i++)\\n            parent[i]=i;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(grid[i][j]==\\'1\\') {\\n                    no_of_islands++;\\n                    for(int k=0; k<4; k++) {\\n                        int ci=DR[k]+i;\\n                        int cj=DC[k]+j;\\n                        if(ci<0 || cj<0 || ci>=n || cj>=m)\\n                            continue;\\n                        if(grid[ci][cj]==\\'1\\') {\\n                            union_((i*m)+j, (ci*m)+cj, parent);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return no_of_islands;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 391717,
                "title": "javascript-dfs-56ms-very-easy-to-understand",
                "content": "```javascript\\n/**\\n * @param {character[][]} grid\\n * @return {number}\\n */\\nvar numIslands = function(grid) {\\n    let count = 0;\\n    \\n    function depthSearch(x, y) {\\n        if (grid[x][y] === \\'1\\') {\\n            grid[x][y] = \\'0\\';\\n        } else {\\n            return;\\n        }\\n\\n        if (x < grid.length - 1) {\\n            depthSearch(x+1, y);\\n        }\\n        \\n        if (y < grid[x].length - 1) {\\n            depthSearch(x, y+1);\\n        }\\n        \\n        if (x > 0 && x < grid.length) {\\n            depthSearch(x-1, y);\\n        }\\n        \\n        if (y > 0 && y < grid[x].length) {\\n            depthSearch(x, y-1);\\n        }\\n    }\\n    \\n    for (let i = 0; i < grid.length; i++) {\\n        for (let j = 0; j < grid[i].length; j++) {\\n            if (grid[i][j] === \\'1\\') {\\n                count++;\\n                depthSearch(i, j);\\n            }\\n        }\\n    }\\n    \\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```javascript\\n/**\\n * @param {character[][]} grid\\n * @return {number}\\n */\\nvar numIslands = function(grid) {\\n    let count = 0;\\n    \\n    function depthSearch(x, y) {\\n        if (grid[x][y] === \\'1\\') {\\n            grid[x][y] = \\'0\\';\\n        } else {\\n            return;\\n        }\\n\\n        if (x < grid.length - 1) {\\n            depthSearch(x+1, y);\\n        }\\n        \\n        if (y < grid[x].length - 1) {\\n            depthSearch(x, y+1);\\n        }\\n        \\n        if (x > 0 && x < grid.length) {\\n            depthSearch(x-1, y);\\n        }\\n        \\n        if (y > 0 && y < grid[x].length) {\\n            depthSearch(x, y-1);\\n        }\\n    }\\n    \\n    for (let i = 0; i < grid.length; i++) {\\n        for (let j = 0; j < grid[i].length; j++) {\\n            if (grid[i][j] === \\'1\\') {\\n                count++;\\n                depthSearch(i, j);\\n            }\\n        }\\n    }\\n    \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 121174,
                "title": "python-union-find-solution-with-both-path-compression-and-union-by-rank",
                "content": "```\\nclass UnionFind(object):\\n    def __init__(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        self.count = 0\\n        self.parent = [-1] * (m*n)\\n        self.rank = [0] * (m*n)\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                if grid[i][j] == \\'1\\':\\n                    self.parent[i*n + j] = i*n + j\\n                    self.count += 1\\n\\n    def find(self, i):\\n        if self.parent[i] != i:\\n            self.parent[i] = self.find(self.parent[i])\\n        return self.parent[i]\\n\\n    def union(self, x, y):\\n        rootx = self.find(x)\\n        rooty = self.find(y)\\n        if rootx != rooty:\\n            if self.rank[rootx] > self.rank[rooty]:\\n                self.parent[rooty] = rootx\\n            elif self.rank[rootx] < self.rank[rooty]:\\n                self.parent[rootx] = rooty\\n            else:\\n                self.parent[rooty] = rootx\\n                self.rank[rootx] += 1\\n            self.count -= 1\\n\\nclass Solution(object):\\n    def is_valid(self, grid, r, c):\\n        m, n = len(grid), len(grid[0])\\n        if r < 0 or c < 0 or r >= m or c >= n:\\n            return False\\n        return True\\n\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid or not grid[0]:\\n            return 0\\n\\n        uf = UnionFind(grid)\\n\\n        directions = [(0,1), (0,-1), (-1,0), (1,0)]\\n        m, n = len(grid), len(grid[0])\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                if grid[i][j] == \\'1\\':\\n                    for d in directions:\\n                        nr, nc = i + d[0], j + d[1]\\n                        if self.is_valid(grid, nr, nc) and grid[nr][nc] == \\'1\\':\\n                            uf.union(i*n+j, nr*n+nc)\\n        return uf.count\\n```",
                "solutionTags": [],
                "code": "```\\nclass UnionFind(object):\\n    def __init__(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        self.count = 0\\n        self.parent = [-1] * (m*n)\\n        self.rank = [0] * (m*n)\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                if grid[i][j] == \\'1\\':\\n                    self.parent[i*n + j] = i*n + j\\n                    self.count += 1\\n\\n    def find(self, i):\\n        if self.parent[i] != i:\\n            self.parent[i] = self.find(self.parent[i])\\n        return self.parent[i]\\n\\n    def union(self, x, y):\\n        rootx = self.find(x)\\n        rooty = self.find(y)\\n        if rootx != rooty:\\n            if self.rank[rootx] > self.rank[rooty]:\\n                self.parent[rooty] = rootx\\n            elif self.rank[rootx] < self.rank[rooty]:\\n                self.parent[rootx] = rooty\\n            else:\\n                self.parent[rooty] = rootx\\n                self.rank[rootx] += 1\\n            self.count -= 1\\n\\nclass Solution(object):\\n    def is_valid(self, grid, r, c):\\n        m, n = len(grid), len(grid[0])\\n        if r < 0 or c < 0 or r >= m or c >= n:\\n            return False\\n        return True\\n\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid or not grid[0]:\\n            return 0\\n\\n        uf = UnionFind(grid)\\n\\n        directions = [(0,1), (0,-1), (-1,0), (1,0)]\\n        m, n = len(grid), len(grid[0])\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                if grid[i][j] == \\'1\\':\\n                    for d in directions:\\n                        nr, nc = i + d[0], j + d[1]\\n                        if self.is_valid(grid, nr, nc) and grid[nr][nc] == \\'1\\':\\n                            uf.union(i*n+j, nr*n+nc)\\n        return uf.count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56356,
                "title": "dfs-and-bfs-in-c",
                "content": "When we met a '1', the answer add 1, we also need to search all '1' which connected to it directly or indirectly, and change it to '0'. And we can use DFS or BFS to search.\\n\\n1. DFS\\n======\\n    class Solution\\n    {\\n    public:\\n        int numIslands(vector<vector<char>> &grid)\\n        {\\n            if(grid.size() == 0 || grid[0].size() == 0)\\n                return 0;\\n            \\n            int res = 0;\\n            for(int i = 0; i < grid.size(); ++ i)\\n                for(int j = 0; j < grid[0].size(); ++ j)\\n                    if(grid[i][j] == '1')\\n                    {\\n                        ++ res;\\n                        DFS(grid, i, j);\\n                    }\\n            return res;\\n        }\\n    private:\\n        void DFS(vector<vector<char>> &grid, int x, int y)\\n        {\\n            grid[x][y] = '0';\\n            if(x > 0 && grid[x - 1][y] == '1')\\n                DFS(grid, x - 1, y);\\n            if(x < grid.size() - 1 && grid[x + 1][y] == '1')\\n                DFS(grid, x + 1, y);\\n            if(y > 0 && grid[x][y - 1] == '1')\\n                DFS(grid, x, y - 1);\\n            if(y < grid[0].size() - 1 && grid[x][y + 1] == '1')\\n                DFS(grid, x, y + 1);\\n        }\\n    };\\n\\n2. BFS\\n======\\n\\n    class Solution\\n    {\\n    public:\\n        int numIslands(vector<vector<char>> &grid)\\n        {\\n            if(grid.size() == 0 || grid[0].size() == 0)\\n                return 0;\\n            \\n            int res = 0;\\n            for(int i = 0; i < grid.size(); ++ i)\\n                for(int j = 0; j < grid[0].size(); ++ j)\\n                    if(grid[i][j] == '1')\\n                    {\\n                        ++ res;\\n                        BFS(grid, i, j);\\n                    }\\n            return res;\\n        }\\n    private:\\n        void BFS(vector<vector<char>> &grid, int x, int y)\\n        {\\n            queue<vector<int>> q;\\n            q.push({x, y});\\n            grid[x][y] = '0';\\n            \\n            while(!q.empty())\\n            {\\n                x = q.front()[0], y = q.front()[1];\\n                q.pop();\\n                \\n                if(x > 0 && grid[x - 1][y] == '1')\\n                {\\n                    q.push({x - 1, y});\\n                    grid[x - 1][y] = '0';\\n                }\\n                if(x < grid.size() - 1 && grid[x + 1][y] == '1')\\n                {\\n                    q.push({x + 1, y});\\n                    grid[x + 1][y] = '0';\\n                }\\n                if(y > 0 && grid[x][y - 1] == '1')\\n                {\\n                    q.push({x, y - 1});\\n                    grid[x][y - 1] = '0';\\n                }\\n                if(y < grid[0].size() - 1 && grid[x][y + 1] == '1')\\n                {\\n                    q.push({x, y + 1});\\n                    grid[x][y + 1] = '0';\\n                }\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n    public:\\n        int numIslands(vector<vector<char>> &grid)\\n        {\\n            if(grid.size() == 0 || grid[0].size() == 0)\\n                return 0;\\n            \\n            int res = 0;\\n            for(int i = 0; i < grid.size(); ++ i)\\n                for(int j = 0; j < grid[0].size(); ++ j)\\n                    if(grid[i][j] == '1')\\n                    {\\n                        ++ res;\\n                        DFS(grid, i, j);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 151858,
                "title": "javascript-dfs",
                "content": "```js\\nfunction numIslands(grid) {\\n  const H = grid.length;\\n  const W = H && grid[0].length;\\n  let count = 0;\\n  \\n  for (let r = 0; r < H; r++) {\\n    for (let c = 0; c < W; c++) {\\n      if (grid[r][c] === \\'0\\') continue;\\n      \\n      count++;\\n      dfs(r, c);\\n    }\\n  }\\n  return count;\\n  \\n  function dfs(r, c) {\\n    if (r < 0 || c < 0 || r === H || c === W) return;\\n    if (grid[r][c] === \\'0\\') return;\\n    \\n    grid[r][c] = \\'0\\';\\n    dfs(r-1, c);\\n    dfs(r+1, c);\\n    dfs(r, c-1);\\n    dfs(r, c+1);\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction numIslands(grid) {\\n  const H = grid.length;\\n  const W = H && grid[0].length;\\n  let count = 0;\\n  \\n  for (let r = 0; r < H; r++) {\\n    for (let c = 0; c < W; c++) {\\n      if (grid[r][c] === \\'0\\') continue;\\n      \\n      count++;\\n      dfs(r, c);\\n    }\\n  }\\n  return count;\\n  \\n  function dfs(r, c) {\\n    if (r < 0 || c < 0 || r === H || c === W) return;\\n    if (grid[r][c] === \\'0\\') return;\\n    \\n    grid[r][c] = \\'0\\';\\n    dfs(r-1, c);\\n    dfs(r+1, c);\\n    dfs(r, c-1);\\n    dfs(r, c+1);\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 640295,
                "title": "optimized-by-memory-follow-up-question-what-if-matrix-is-too-big",
                "content": "There is this follow-up for this task: \"what if the input data is too big (and sparse)\"\\n\\nLets say the input data is such big that we can not even load it in memory so instead we want to read it line-by-line (for example, from file). Lets say we have a method `readR(int r)` that returns *r* row of the matrix;\\nSay `currLine` is a row we are checking, `prevLine` - one before it;\\nNow we can read line-by-line and follow these rules:\\n - if `currLine[i-1] && prevLine[i]` are not set, we consider i as a start of the new island;\\n - if `currLine[i-1]` is set but `prevLine[i]` is not we consider i belongs to island `currLine[i-1]`\\n - if `prevLine[i]` is set but `currLine[i-1]` is not  we consider i belongs to island `prevLine[i]`\\n - if both `currLine[i-1] && prevLine[i]` are set, we conider i belongs to `currLine[i-1]` **AND** we update `prevLine[i]` island to be `currLine[i-1]`.\\n \\nFor keeping track / updating indices of islands we use Union-Find: keep a `map(k,v)` where island k is considered connected to island v.  When we create a new island, we create `k->k` record, when updating k, we recursively traverse through all connected islands and update their values to the new one;\\n\\ncode:\\n```\\n\\npublic int numIslands(char[][] grid) {\\n        if (grid.length < 1) return 0;\\n        int[] firstR = readFirtsR(grid);\\n        Map<Integer, Integer> sets = new HashMap<>();\\n        int count = 0;\\n        // read first row and create first islands:\\n\\t\\t// [0 1 0 0 1 0 1] => [0 1 0 0 2 0 3]\\n\\t\\tfor (int n: firstR) if (n != 0) {\\n            sets.put(n, n);\\n            count = n;\\n        }\\n        int r = 1;\\n        while (r < grid.length) {\\n            char[] line = readR(r, grid);\\n            int[] secondR = new int[line.length];\\n            for (int i = 0; i < line.length; i++) {\\n                if (line[i] == \\'1\\') {\\n                    if (i != 0 && secondR[i - 1] != 0) {\\n                        secondR[i] = getRoot(secondR[i - 1],sets);\\n                    }\\n                    else if (firstR[i] != 0) {\\n                        secondR[i] = getRoot(firstR[i], sets);\\n                    }\\n                    else {\\n                        count++;\\n                        secondR[i] = count;\\n                        sets.put(count, count);\\n                    }\\n                    if (firstR[i] != secondR[i] && firstR[i] != 0) {\\n                        updateRoots(sets.get(firstR[i]), secondR[i], sets);\\n                    }\\n                }\\n            }\\n            firstR = secondR;\\n            r++;\\n        }\\n        int res = 0;\\n        for (int k : sets.keySet()) if (sets.get(k) == k) res++;\\n        return res;\\n    }\\n\\t\\n    // union-find \"find\" part\\n    private int getRoot(int v, Map<Integer, Integer> sets) {\\n        int k = v;\\n        while (k != sets.get(k)) k = sets.get(k);\\n        return k;\\n    }\\n\\n    // connect island k to island newVal\\n    private void updateRoots(int k, int newVal, Map<Integer, Integer> sets) {\\n        while (k != newVal) {\\n            int v = sets.get(k);\\n            sets.put(k, newVal);\\n            k = v;\\n        }\\n    }\\n\\n    private char[] readR(int i, char[][] grid) {\\n        return grid[i];\\n    }\\n\\n    //  this is ugly and probably can be done better:\\n\\t// read first line and connect adjusted \\'1\\' \\n    private int[] readFirtsR(char[][] grid) {\\n        int[] first = new int[grid[0].length];\\n        char[] r = readR(0, grid);\\n        int count = 1;\\n        int start = 0;\\n\\n        while (start < first.length) {\\n            if (r[start] == \\'1\\' &&\\n                    (start == 0 || r[start - 1] != \\'1\\')) first[start] = count++;\\n            if (start != 0 && r[start] == \\'1\\' && r[start - 1] == \\'1\\') first[start] = first[start - 1];\\n            start++;\\n        }\\n        return first;\\n    }\\n```\\n\\nMemory should be `O(max(grig[0].length, res))` \\nwhere `res` is number of islands. Worst-case `res` will be `n/2` (if islands consist of one-element cells adjusted by diagonals only). Hovewer in case of sparse matrix we can probably assume `grig[0].length >> res`.\\n",
                "solutionTags": [],
                "code": "```\\n\\npublic int numIslands(char[][] grid) {\\n        if (grid.length < 1) return 0;\\n        int[] firstR = readFirtsR(grid);\\n        Map<Integer, Integer> sets = new HashMap<>();\\n        int count = 0;\\n        // read first row and create first islands:\\n\\t\\t// [0 1 0 0 1 0 1] => [0 1 0 0 2 0 3]\\n\\t\\tfor (int n: firstR) if (n != 0) {\\n            sets.put(n, n);\\n            count = n;\\n        }\\n        int r = 1;\\n        while (r < grid.length) {\\n            char[] line = readR(r, grid);\\n            int[] secondR = new int[line.length];\\n            for (int i = 0; i < line.length; i++) {\\n                if (line[i] == \\'1\\') {\\n                    if (i != 0 && secondR[i - 1] != 0) {\\n                        secondR[i] = getRoot(secondR[i - 1],sets);\\n                    }\\n                    else if (firstR[i] != 0) {\\n                        secondR[i] = getRoot(firstR[i], sets);\\n                    }\\n                    else {\\n                        count++;\\n                        secondR[i] = count;\\n                        sets.put(count, count);\\n                    }\\n                    if (firstR[i] != secondR[i] && firstR[i] != 0) {\\n                        updateRoots(sets.get(firstR[i]), secondR[i], sets);\\n                    }\\n                }\\n            }\\n            firstR = secondR;\\n            r++;\\n        }\\n        int res = 0;\\n        for (int k : sets.keySet()) if (sets.get(k) == k) res++;\\n        return res;\\n    }\\n\\t\\n    // union-find \"find\" part\\n    private int getRoot(int v, Map<Integer, Integer> sets) {\\n        int k = v;\\n        while (k != sets.get(k)) k = sets.get(k);\\n        return k;\\n    }\\n\\n    // connect island k to island newVal\\n    private void updateRoots(int k, int newVal, Map<Integer, Integer> sets) {\\n        while (k != newVal) {\\n            int v = sets.get(k);\\n            sets.put(k, newVal);\\n            k = v;\\n        }\\n    }\\n\\n    private char[] readR(int i, char[][] grid) {\\n        return grid[i];\\n    }\\n\\n    //  this is ugly and probably can be done better:\\n\\t// read first line and connect adjusted \\'1\\' \\n    private int[] readFirtsR(char[][] grid) {\\n        int[] first = new int[grid[0].length];\\n        char[] r = readR(0, grid);\\n        int count = 1;\\n        int start = 0;\\n\\n        while (start < first.length) {\\n            if (r[start] == \\'1\\' &&\\n                    (start == 0 || r[start - 1] != \\'1\\')) first[start] = count++;\\n            if (start != 0 && r[start] == \\'1\\' && r[start - 1] == \\'1\\') first[start] = first[start - 1];\\n            start++;\\n        }\\n        return first;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 56585,
                "title": "simple-dfs-python-code-beat-90",
                "content": "    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid:\\n            return 0\\n            \\n        m = len(grid)\\n        n = len(grid[0])\\n        sum  = 0\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                \\n                if grid[i][j] == \"0\":\\n                    continue\\n                else:\\n                    \\n                    #sum up only once per chance of meeting \"1\"\\n                    sum += 1\\n                    stack = list()\\n                    stack.append([i,j])\\n                    \\n                    #visit each \"1\" in the adjacent area using a stack\\n                    while len(stack) != 0:\\n                        \\n                        [p,q] = stack.pop()\\n                        \\n                        if p >= 1 and grid[p-1][q] == \"1\":\\n                            stack.append([p-1,q])\\n                            \\n                        if p < m -1 and grid[p+1][q] == \"1\":\\n                            stack.append([p+1,q])\\n                        \\n                        if q >= 1 and grid[p][q-1] == \"1\":\\n                            stack.append([p,q-1])\\n                            \\n                        if q < n - 1 and grid[p][q + 1] == \"1\":\\n                            stack.append([p,q+1])\\n                        \\n                        #mark as visited\\n                        grid[p][q] = \"0\"\\n        \\n        \\n        \\n        return sum\\n        \\n\\nUse a stack to DFS the lands area every time we found a island.",
                "solutionTags": [],
                "code": "    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid:\\n            return 0\\n            \\n        m = len(grid)\\n        n = len(grid[0])\\n        sum  = 0\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                \\n                if grid[i][j] == \"0\":\\n                    continue\\n                else:\\n                    \\n                    #sum up only once per chance of meeting \"1\"\\n                    sum += 1\\n                    stack = list()\\n                    stack.append([i,j])\\n                    \\n                    #visit each \"1\" in the adjacent area using a stack\\n                    while len(stack) != 0:\\n                        \\n                        [p,q] = stack.pop()\\n                        \\n                        if p >= 1 and grid[p-1][q] == \"1\":\\n                            stack.append([p-1,q])\\n                            \\n                        if p < m -1 and grid[p+1][q] == \"1\":\\n                            stack.append([p+1,q])\\n                        \\n                        if q >= 1 and grid[p][q-1] == \"1\":\\n                            stack.append([p,q-1])\\n                            \\n                        if q < n - 1 and grid[p][q + 1] == \"1\":\\n                            stack.append([p,q+1])\\n                        \\n                        #mark as visited\\n                        grid[p][q] = \"0\"\\n        \\n        \\n        \\n        return sum\\n        \\n\\nUse a stack to DFS the lands area every time we found a island.",
                "codeTag": "Python3"
            },
            {
                "id": 3530724,
                "title": "java-solutions-using-bfs-and-dfs",
                "content": "# Intuition\\nIt is similar to the methodology of connected components .The question arises here \"how can this problem be solved using a graph?\" Try to think of all the elements as a node or a vertex, we can observe they are connected in some way as all 8 directions connectivity is allowed. If we start a traversal algorithm, from a particular 1 (land) it will make sure it traverses the nearest 1 (land). So, one traversal with a starting point will cover an island. If we do 3 traversals then we will have 3 starting nodes, anyone can be considered as a starting node in an island, and make sure it visits everyone. In the following example, if we take 3 starting nodes we will be able to touch all the pieces of land. Hence, one starting node makes sure it touches all the connected lands. The basic idea is that \\u201Cone starting node represents one island\\u201D.  So, we just need to figure out the number of starting points.\\n\\n# Approach\\nIn any traversal technique, we have one starting node and it traverses all the nodes in the graph. We know about both the traversals, Breadth First Search (BFS) and Depth First Search (DFS). \\n\\nThe algorithm steps for BFS are as follows:\\n\\n  1.  The pairs of row and column (<row, column>) will represent the node numbers.\\n   2. For BFS traversal, we need a queue data structure and a visited array. Create a replica of the given array, i.e., create another array of the same size and call it a visited array. We can use the same matrix, but we will avoid alteration of the original data. \\n   3. In the queue, insert a vertex (pair of <row, column>) and mark it as visited. \\n  4.  While BFS traversal, pop out an element from the queue and travel to all its neighbours. In a graph, we store the list of neighbours in an adjacency list but here we know the neighbours are in 8 directions. \\n    5.We go in all 8 directions and check for unvisited land neighbours. To travel in 8 directions we will use nested loops, you can find the implementation details in the code. \\n   6. BFS function call will make sure that it starts the BFS call from that unvisited land, and visits all the nodes that are on that island, and at the same time, it will also mark them as visited. \\n   7. Since the nodes travelled in a traversal will be marked as visited, they will no further be called for any further BFS traversal. \\n    Keep repeating these steps, for every land that you find unvisited, and visit the entire island. \\n   8. Add a counter variable to count the number of times the BFS function is called, as in this way we can count the total number of starting nodes, which will give us the number of islands.\\n\\n\\n**The algorithmic steps for DFS are as follows:**\\n                The basic idea is we iterate all the element on grid[ ][ ], and if the element is 1, then it triggers DFS and tracks the surrounding elements  and  change all the element around it to be 0 in order to ensure that all the connected nodes make a single node count.Please do check code below for proper understanding.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N\\xB2 + NxMx9), N\\xB2 for the nested loops, and NxMx9 for the overall DFS of the matrix, that will happen throughout if all the cells are filled with 1.\\n\\n- Space complexity:\\nO(N\\xB2) for visited array max queue space O(N\\xB2), If all are marked as 1 then the maximum queue space will be N\\xB2.\\n\\n# Code\\n# **BFS CODE**\\n\\n    private void bfs(int ro, int co, int[][] vis, char[][] grid) {\\n      vis[ro][co] = 1; \\n      Queue<Pair> q = new LinkedList<Pair>();\\n      q.add(new Pair(ro, co)); \\n      int n = grid.length; \\n      int m = grid[0].length; \\n      \\n      // until the queue becomes empty\\n      while(!q.isEmpty()) {\\n          int row = q.peek().first; \\n          int col = q.peek().second; \\n          q.remove(); \\n          \\n          // traverse in the neighbours and mark them if its a land \\n          for(int delrow = -1; delrow<=1;delrow++) {\\n              for(int delcol = -1; delcol <= 1; delcol++) {\\n                  int nrow = row + delrow; \\n                  int ncol = col + delcol; \\n          // check if neighbour row and column is valid, and is an unvisited land\\n                  if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < m \\n                  && grid[nrow][ncol] == \\'1\\' && vis[nrow][ncol] == 0) {\\n                      vis[nrow][ncol] = 1; \\n                      q.add(new Pair(nrow, ncol)); \\n                  }\\n              }\\n          }\\n      }\\n  }\\n\\n    // Function to find the number of islands.\\n    public int numIslands(char[][] grid) {\\n        int n = grid.length; \\n        int m = grid[0].length; \\n        int[][] vis = new int[n][m];\\n        int cnt = 0; \\n        for(int row = 0; row < n ; row++) {\\n            for(int col = 0; col < m ;col++) {\\n                // if not visited and is a land\\n                if(vis[row][col] == 0 && grid[row][col] == \\'1\\') {\\n                    cnt++; \\n                    bfs(row, col, vis, grid); \\n                }\\n            }\\n        }\\n        return cnt; \\n    }\\n\\n```\\n```\\n# **DFS SOLUTION**\\n```\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        int count=0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]==\\'1\\'){\\n                    count++;\\n                    dfs(i,j,grid);\\n                }\\n            }}\\n            return count;\\n        }\\n```\\n\\n   \\n            public void dfs(int row,int col,char[][]grid){\\n            if(row>=0 && row<grid.length && col>=0 && col<grid[0].length && grid[row][col]==\\'1\\'){\\n                grid[row][col]=\\'0\\';\\n                dfs(row,col+1,grid);\\n                dfs(row,col-1,grid);\\n                dfs(row+1,col,grid);\\n                dfs(row-1,col,grid);\\n            }\\n            }\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/69d7a2d8-87f7-4e3c-b8ef-6ee98c7cf1d3_1684239408.367929.png)\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n```\n```\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        int count=0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]==\\'1\\'){\\n                    count++;\\n                    dfs(i,j,grid);\\n                }\\n            }}\\n            return count;\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 922610,
                "title": "easy-python-recursion-solution-120-ms-faster-than-99-99-of-python3",
                "content": "The idea is simple if we find a 1 we remove all it\\'s neibors recursively.\\n```\\n   def numIslands(self, grid: List[List[str]]) -> int:\\n        count = 0\\n        for r,row in enumerate(grid):\\n            for c,col in enumerate(row):\\n                if grid[r][c] == \\'1\\':\\n                    self.removeNeighbors(r,c,grid)\\n                    count += 1\\n        return count            \\n    def removeNeighbors(self, r ,c, grid):\\n        grid[r][c] = 0\\n        if r+1 < len(grid) and grid[r+1][c] == \\'1\\':\\n            self.removeNeighbors(r+1,c,grid)\\n        if c+1 < len(grid[0]) and grid[r][c+1] == \\'1\\':\\n            self.removeNeighbors(r,c+1,grid)    \\n        if r-1 >= 0 and grid[r-1][c] == \\'1\\':\\n            self.removeNeighbors(r-1,c,grid)\\n        if c-1 >= 0 and grid[r][c-1] == \\'1\\':\\n            self.removeNeighbors(r,c-1,grid)   \\n```\\nIf you like my solution please hit the up vote button Thanks!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n   def numIslands(self, grid: List[List[str]]) -> int:\\n        count = 0\\n        for r,row in enumerate(grid):\\n            for c,col in enumerate(row):\\n                if grid[r][c] == \\'1\\':\\n                    self.removeNeighbors(r,c,grid)\\n                    count += 1\\n        return count            \\n    def removeNeighbors(self, r ,c, grid):\\n        grid[r][c] = 0\\n        if r+1 < len(grid) and grid[r+1][c] == \\'1\\':\\n            self.removeNeighbors(r+1,c,grid)\\n        if c+1 < len(grid[0]) and grid[r][c+1] == \\'1\\':\\n            self.removeNeighbors(r,c+1,grid)    \\n        if r-1 >= 0 and grid[r-1][c] == \\'1\\':\\n            self.removeNeighbors(r-1,c,grid)\\n        if c-1 >= 0 and grid[r][c-1] == \\'1\\':\\n            self.removeNeighbors(r,c-1,grid)   \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1334599,
                "title": "c-simple-and-short-easy-to-understand-clean-dfs-solution",
                "content": "We use DFS to turn each island to \\'0\\'s. If we found a \\'1\\', then we got to a new island and we can increase res.\\n```\\nclass Solution {\\npublic:\\n    void DFS(vector<vector<char>>& grid, int x, int y) {\\n        if (x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size() || grid[x][y] == \\'0\\') return;\\n        \\n        grid[x][y] = \\'0\\';\\n        \\n        DFS(grid, x + 1, y);\\n        DFS(grid, x - 1, y);\\n        DFS(grid, x, y + 1);\\n        DFS(grid, x, y - 1);\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        int res = 0, n = grid.size(), m = grid[0].size();\\n        \\n        for (int i = 0; i <n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    res++;\\n                    DFS(grid, i, j);\\n                } \\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void DFS(vector<vector<char>>& grid, int x, int y) {\\n        if (x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size() || grid[x][y] == \\'0\\') return;\\n        \\n        grid[x][y] = \\'0\\';\\n        \\n        DFS(grid, x + 1, y);\\n        DFS(grid, x - 1, y);\\n        DFS(grid, x, y + 1);\\n        DFS(grid, x, y - 1);\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        int res = 0, n = grid.size(), m = grid[0].size();\\n        \\n        for (int i = 0; i <n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    res++;\\n                    DFS(grid, i, j);\\n                } \\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2499241,
                "title": "javascript-recursive-dfs-easy-to-understand",
                "content": "```\\n// Time complexity: O(mn)\\n// Space complexity: O(mn)\\n\\nvar numIslands = function(grid) {\\n\\tlet count = 0;\\n\\t\\n\\tfunction callDFS(grid, i, j) {\\n\\t\\tif (i < 0 || i >= grid.length || j < 0 || j >= grid[i].length || grid[i][j] == \\'0\\') {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t\\n\\t\\tgrid[i][j] = \\'0\\';\\n\\t\\t\\n\\t\\tcallDFS(grid, i + 1, j); // down\\n\\t\\tcallDFS(grid, i - 1, j); // up\\n\\t\\tcallDFS(grid, i, j + 1); // right\\n\\t\\tcallDFS(grid, i, j - 1); // left\\n\\t}\\n\\n\\tfor (let i = 0; i < grid.length; i++) {\\n\\t\\tfor (let j = 0; j < grid[i].length; j++) {\\n\\t\\t\\tif (grid[i][j] == \\'1\\') {\\n\\t\\t\\t\\tcount += 1;\\n\\t\\t\\t\\tcallDFS(grid, i, j);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn count;\\n};\\n```\\n\\n**Please upvote if you find this solution useful. Happy Coding!**",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n// Time complexity: O(mn)\\n// Space complexity: O(mn)\\n\\nvar numIslands = function(grid) {\\n\\tlet count = 0;\\n\\t\\n\\tfunction callDFS(grid, i, j) {\\n\\t\\tif (i < 0 || i >= grid.length || j < 0 || j >= grid[i].length || grid[i][j] == \\'0\\') {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t\\n\\t\\tgrid[i][j] = \\'0\\';\\n\\t\\t\\n\\t\\tcallDFS(grid, i + 1, j); // down\\n\\t\\tcallDFS(grid, i - 1, j); // up\\n\\t\\tcallDFS(grid, i, j + 1); // right\\n\\t\\tcallDFS(grid, i, j - 1); // left\\n\\t}\\n\\n\\tfor (let i = 0; i < grid.length; i++) {\\n\\t\\tfor (let j = 0; j < grid[i].length; j++) {\\n\\t\\t\\tif (grid[i][j] == \\'1\\') {\\n\\t\\t\\t\\tcount += 1;\\n\\t\\t\\t\\tcallDFS(grid, i, j);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 167097,
                "title": "union-find",
                "content": ">If we define a 1 as a node, two nodes are connected if they are adjacent, `adjacent 1s surrounded by 0s` will be regarded as a connected component.\\n\\n> The problem becomes to find all connected components, which can we solved by Union Find.\\n\\n> The initial number of connected component should equal to the number of 1s. Then for each 1, we union it around. Each time we hit a union succesfully, the number of connected component will decrease by 1.\\n\\n```\\n    private int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    private UF uf;\\n    private int rows, cols, countIslands;\\n    \\n    public int numIslands(char[][] grid) {\\n        if (grid.length == 0) return 0;\\n        \\n        rows = grid.length;\\n        cols = grid[0].length;\\n        uf = new UF(rows * cols);\\n        \\n        countIslands = 0;\\n        \\n        for (int x = 0; x < rows; x++) {\\n            for (int y = 0; y < cols; y++) {\\n                // If value 1, union with adjacent\\n                if (grid[x][y] == \\'1\\') {\\n                    countIslands++;\\n                    unionAround(x, y, grid);\\n                }\\n            }\\n        }\\n        \\n        return countIslands;\\n    }\\n    \\n    private void unionAround(int x, int y, char[][] grid) {\\n        int mark = x * cols + y;\\n        for (int[] dir : directions) {\\n            int nx = x + dir[0];\\n            int ny = y + dir[1];\\n            if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && grid[nx][ny] == \\'1\\') {\\n                if (uf.union(nx * cols + ny, mark)) {\\n                    countIslands--;\\n                }\\n            }\\n        }\\n    }\\n    \\n    class UF {\\n        int[] parent;\\n\\n        public UF(int n) {\\n            parent = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                parent[i] = i;\\n            }\\n        }\\n\\n        private int find(int x) {\\n            if (parent[x] == x) {\\n                return x;\\n            }\\n            return parent[x] = find(parent[x]); // Path compression\\n        }\\n\\n        // Return false if x and y are in the same disjoint set already\\n        public boolean union(int x, int y) {\\n            int rootX = find(x);\\n            int rootY = find(y);\\n            if (rootX == rootY) {\\n                return false;\\n            }\\n            parent[rootX] = rootY;\\n            return true;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    private UF uf;\\n    private int rows, cols, countIslands;\\n    \\n    public int numIslands(char[][] grid) {\\n        if (grid.length == 0) return 0;\\n        \\n        rows = grid.length;\\n        cols = grid[0].length;\\n        uf = new UF(rows * cols);\\n        \\n        countIslands = 0;\\n        \\n        for (int x = 0; x < rows; x++) {\\n            for (int y = 0; y < cols; y++) {\\n                // If value 1, union with adjacent\\n                if (grid[x][y] == \\'1\\') {\\n                    countIslands++;\\n                    unionAround(x, y, grid);\\n                }\\n            }\\n        }\\n        \\n        return countIslands;\\n    }\\n    \\n    private void unionAround(int x, int y, char[][] grid) {\\n        int mark = x * cols + y;\\n        for (int[] dir : directions) {\\n            int nx = x + dir[0];\\n            int ny = y + dir[1];\\n            if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && grid[nx][ny] == \\'1\\') {\\n                if (uf.union(nx * cols + ny, mark)) {\\n                    countIslands--;\\n                }\\n            }\\n        }\\n    }\\n    \\n    class UF {\\n        int[] parent;\\n\\n        public UF(int n) {\\n            parent = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                parent[i] = i;\\n            }\\n        }\\n\\n        private int find(int x) {\\n            if (parent[x] == x) {\\n                return x;\\n            }\\n            return parent[x] = find(parent[x]); // Path compression\\n        }\\n\\n        // Return false if x and y are in the same disjoint set already\\n        public boolean union(int x, int y) {\\n            int rootX = find(x);\\n            int rootY = find(y);\\n            if (rootX == rootY) {\\n                return false;\\n            }\\n            parent[rootX] = rootY;\\n            return true;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2499215,
                "title": "python-no-recursion-faster-than-82-less-than-98",
                "content": "**Appreciate if you could upvote this solution**\\n\\nmethod: `BFS`\\n```\\nScan the each element in the `grid`.\\n1)  element == \\'1\\'\\n\\t- assign \\'0\\' to element\\n\\t- island_count += 1\\n\\t- Scan the neigbhour lands and set to \\'0\\'\\n2)  value == \\'0\\':\\n    - continue\\n```\\t \\n\\nCode:\\n```\\ndef numIslands(self, grid: List[List[str]]) -> int:\\n        def is_valid(i, j):\\n            return True if 0 <= i < len_row and 0 <= j < len_col and grid[i][j] == \"1\" else False\\n                \\n        len_row, len_col = len(grid), len(grid[0])\\n        island_count = 0\\n        for row in range(len_row):\\n            for col in range(len_col):\\n                if is_valid(row, col):\\n                    island_count += 1\\n                    queue = deque([(row, col)])\\n                    while len(queue) != 0:\\n                        r, c = queue.popleft()\\n                        if grid[r][c] == \"1\":\\n                            grid[r][c] = \"0\"\\n                            for r_move, c_move in ((-1,0),(1,0),(0,1),(0,-1)):\\n                                if is_valid(r + r_move, c + c_move):\\n                                    queue.append((r + r_move, c + c_move))\\n\\n        return island_count\\n```\\n\\nFeel free to correct me if the complexity is wrong :)\\n**Time Complexity**: `O(n^2 * m^2)`\\n**Space Complexity**: `O(1)`\\n<br />",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nScan the each element in the `grid`.\\n1)  element == \\'1\\'\\n\\t- assign \\'0\\' to element\\n\\t- island_count += 1\\n\\t- Scan the neigbhour lands and set to \\'0\\'\\n2)  value == \\'0\\':\\n    - continue\\n```\n```\\ndef numIslands(self, grid: List[List[str]]) -> int:\\n        def is_valid(i, j):\\n            return True if 0 <= i < len_row and 0 <= j < len_col and grid[i][j] == \"1\" else False\\n                \\n        len_row, len_col = len(grid), len(grid[0])\\n        island_count = 0\\n        for row in range(len_row):\\n            for col in range(len_col):\\n                if is_valid(row, col):\\n                    island_count += 1\\n                    queue = deque([(row, col)])\\n                    while len(queue) != 0:\\n                        r, c = queue.popleft()\\n                        if grid[r][c] == \"1\":\\n                            grid[r][c] = \"0\"\\n                            for r_move, c_move in ((-1,0),(1,0),(0,1),(0,-1)):\\n                                if is_valid(r + r_move, c + c_move):\\n                                    queue.append((r + r_move, c + c_move))\\n\\n        return island_count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 426077,
                "title": "java-dfs-bfs-solutions-using-marked-array-queue",
                "content": "Reference: [LeetCode](https://leetcode.com/problems/number-of-islands/)\\nDifficulty: <span class=\"orange\">Medium</span>\\n\\n\\n\\n## Problem\\n\\n> Given a 2d grid map of `\\'1\\'`s (land) and `\\'0\\'`s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands **horizontally** or **vertically**. You may assume all four edges of the grid are all surrounded by water.\\n\\n**Example:** \\n\\n```java\\nInput:\\n11110\\n11010\\n11000\\n00000\\nOutput: 1\\n\\nInput:\\n11000\\n11000\\n00100\\n00011\\nOutput: 3\\n```\\n\\n\\n## Analysis\\n\\n### DFS\\n\\nIt is very obvious that this problem can be solved by using an DFS approach.\\n\\n**Note:** Be careful of the conditions that we `dfs` a place, which include `boundary check` and `whether it is an island`.\\n\\n```java\\npublic int numIslands(char[][] grid) {\\n  if (grid == null || grid.length == 0) {\\n    return 0;\\n  }\\n  int m = grid.length;\\n  int n = grid[0].length;\\n  boolean[][] marked = new boolean[m][n]; // or visit by setting value as \\'0\\'\\n  int[][] direction = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} };\\n  int islandCount = 0;\\n  for (int i = 0; i < m; ++i) {\\n    for (int j = 0; j < n; ++j) {\\n      if (!marked[i][j] && grid[i][j] == \\'1\\') {\\n        dfs(i, j, grid, marked, direction);\\n        ++islandCount;\\n      }\\n    }\\n  }\\n  return islandCount;\\n}\\n\\nprivate void dfs(int i, int j, char[][] grid, boolean[][] marked, int[][] direction) {\\n  int m = grid.length;\\n  int n = grid[0].length;\\n  marked[i][j] = true; // visit;\\n  for (int[] dir : direction) {\\n    int x = i + dir[0];\\n    int y = j + dir[1];\\n    if (x >= 0 && x < m && y >= 0 && y < n) {\\n      if (!marked[x][y] && grid[x][y] == \\'1\\') {\\n        dfs(x, y, grid, marked, direction);\\n      }\\n    }\\n  }\\n}\\n```\\n\\n**Time:** `O(MN)`\\n**Space:** `O(MN)`. If we modify the original `grid` array, can we reduce the complexity to `O(1)`? `No`. It is because `DFS` goes by a call stack.\\n\\n\\n\\n### BFS\\n\\nA similar idea based on `BFS` using a queue.\\n\\n```java\\npublic int numIslands(char[][] grid) {\\n  if (grid == null || grid.length == 0) {\\n    return 0;\\n  }\\n  int m = grid.length;\\n  int n = grid[0].length;\\n  boolean[][] marked = new boolean[m][n]; // or visit by setting value as \\'0\\'\\n  int[][] direction = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} };\\n  int islandCount = 0;\\n  for (int i = 0; i < m; ++i) {\\n    for (int j = 0; j < n; ++j) {\\n      if (!marked[i][j] && grid[i][j] == \\'1\\') {\\n        bfs(i, j, grid, marked, direction);\\n        ++islandCount;\\n      }\\n    }\\n  }\\n  return islandCount;\\n}\\n\\nprivate void bfs(int i, int j, char[][] grid, boolean[][] marked, int[][] direction) {\\n  int m = grid.length;\\n  int n = grid[0].length;\\n  Queue<int[]> queue = new LinkedList<>();\\n  queue.offer(new int[] { i, j });\\n  marked[i][j] = true;\\n  // bfs\\n  while (queue.size() > 0) {\\n    int[] curr = queue.poll();\\n    for (int[] dir : direction) {\\n      int x = curr[0] + dir[0];\\n      int y = curr[1] + dir[1];\\n      if (x >= 0 && x < m && y >= 0 && y < n) {\\n        if (!marked[x][y] && grid[x][y] == \\'1\\') {\\n          queue.offer(new int[] { x, y });\\n          marked[x][y] = true; // mark when enqueued\\n        }\\n      }\\n    }\\n  }\\n}\\n```\\n\\n**Time:** `O(MN)`\\n**Space:** `O(\\\\min{(M, N)})`. In the worst case where the grid is filled with lands, the size of queue can be `O(\\\\min{(M, N)})` as follows.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/dmexf.jpg)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```java\\nInput:\\n11110\\n11010\\n11000\\n00000\\nOutput: 1\\n\\nInput:\\n11000\\n11000\\n00100\\n00011\\nOutput: 3\\n```\n```java\\npublic int numIslands(char[][] grid) {\\n  if (grid == null || grid.length == 0) {\\n    return 0;\\n  }\\n  int m = grid.length;\\n  int n = grid[0].length;\\n  boolean[][] marked = new boolean[m][n]; // or visit by setting value as \\'0\\'\\n  int[][] direction = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} };\\n  int islandCount = 0;\\n  for (int i = 0; i < m; ++i) {\\n    for (int j = 0; j < n; ++j) {\\n      if (!marked[i][j] && grid[i][j] == \\'1\\') {\\n        dfs(i, j, grid, marked, direction);\\n        ++islandCount;\\n      }\\n    }\\n  }\\n  return islandCount;\\n}\\n\\nprivate void dfs(int i, int j, char[][] grid, boolean[][] marked, int[][] direction) {\\n  int m = grid.length;\\n  int n = grid[0].length;\\n  marked[i][j] = true; // visit;\\n  for (int[] dir : direction) {\\n    int x = i + dir[0];\\n    int y = j + dir[1];\\n    if (x >= 0 && x < m && y >= 0 && y < n) {\\n      if (!marked[x][y] && grid[x][y] == \\'1\\') {\\n        dfs(x, y, grid, marked, direction);\\n      }\\n    }\\n  }\\n}\\n```\n```java\\npublic int numIslands(char[][] grid) {\\n  if (grid == null || grid.length == 0) {\\n    return 0;\\n  }\\n  int m = grid.length;\\n  int n = grid[0].length;\\n  boolean[][] marked = new boolean[m][n]; // or visit by setting value as \\'0\\'\\n  int[][] direction = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} };\\n  int islandCount = 0;\\n  for (int i = 0; i < m; ++i) {\\n    for (int j = 0; j < n; ++j) {\\n      if (!marked[i][j] && grid[i][j] == \\'1\\') {\\n        bfs(i, j, grid, marked, direction);\\n        ++islandCount;\\n      }\\n    }\\n  }\\n  return islandCount;\\n}\\n\\nprivate void bfs(int i, int j, char[][] grid, boolean[][] marked, int[][] direction) {\\n  int m = grid.length;\\n  int n = grid[0].length;\\n  Queue<int[]> queue = new LinkedList<>();\\n  queue.offer(new int[] { i, j });\\n  marked[i][j] = true;\\n  // bfs\\n  while (queue.size() > 0) {\\n    int[] curr = queue.poll();\\n    for (int[] dir : direction) {\\n      int x = curr[0] + dir[0];\\n      int y = curr[1] + dir[1];\\n      if (x >= 0 && x < m && y >= 0 && y < n) {\\n        if (!marked[x][y] && grid[x][y] == \\'1\\') {\\n          queue.offer(new int[] { x, y });\\n          marked[x][y] = true; // mark when enqueued\\n        }\\n      }\\n    }\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 56622,
                "title": "python-dfs-solutions",
                "content": "        \\n    # overwrite original grid\\n    def numIslands1(self, grid):\\n        count = 0\\n        for r in xrange(len(grid)):\\n            for c in xrange(len(grid[0])):\\n                if grid[r][c] == \"1\":\\n                    count += 1\\n                    self.dfs(grid, r, c)\\n        return count\\n        \\n    def dfs1(self, grid, r, c):\\n        if not (0 <= r < len(grid)) or not (0 <= c < len(grid[0])) or grid[r][c] == \"0\":\\n            return \\n        grid[r][c] = \"0\"\\n        self.dfs(grid, r+1, c)\\n        self.dfs(grid, r-1, c)\\n        self.dfs(grid, r, c+1)\\n        self.dfs(grid, r, c-1)\\n    \\n    # add visited flags   \\n    def numIslands(self, grid):\\n        if not grid:\\n            return 0\\n        count = 0\\n        r, c = len(grid), len(grid[0])\\n        visited = [[False for _ in xrange(c)] for _ in xrange(r)]\\n        for i in xrange(r):\\n            for j in xrange(c):\\n                if grid[i][j] == \"1\" and not visited[i][j]:\\n                    count += 1\\n                    self.dfs(grid, i, j, visited)\\n        return count\\n        \\n    def dfs(self, grid, i, j, visited):\\n        if not (0 <= i < len(grid)) or not (0 <= j < len(grid[0])) or grid[i][j] == \"0\" or visited[i][j]:\\n            return \\n        visited[i][j] = True\\n        self.dfs(grid, i+1, j, visited)\\n        self.dfs(grid, i-1, j, visited)\\n        self.dfs(grid, i, j+1, visited)\\n        self.dfs(grid, i, j-1, visited)",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "        \\n    # overwrite original grid\\n    def numIslands1(self, grid):\\n        count = 0\\n        for r in xrange(len(grid)):\\n            for c in xrange(len(grid[0])):\\n                if grid[r][c] == \"1\":\\n                    count += 1\\n                    self.dfs(grid, r, c)\\n        return count\\n        \\n    def dfs1(self, grid, r, c):\\n        if not (0 <= r < len(grid)) or not (0 <= c < len(grid[0])) or grid[r][c] == \"0\":\\n            return \\n        grid[r][c] = \"0\"\\n        self.dfs(grid, r+1, c)\\n        self.dfs(grid, r-1, c)\\n        self.dfs(grid, r, c+1)\\n        self.dfs(grid, r, c-1)\\n    \\n    # add visited flags   \\n    def numIslands(self, grid):\\n        if not grid:\\n            return 0\\n        count = 0\\n        r, c = len(grid), len(grid[0])\\n        visited = [[False for _ in xrange(c)] for _ in xrange(r)]\\n        for i in xrange(r):\\n            for j in xrange(c):\\n                if grid[i][j] == \"1\" and not visited[i][j]:\\n                    count += 1\\n                    self.dfs(grid, i, j, visited)\\n        return count\\n        \\n    def dfs(self, grid, i, j, visited):\\n        if not (0 <= i < len(grid)) or not (0 <= j < len(grid[0])) or grid[i][j] == \"0\" or visited[i][j]:\\n            return \\n        visited[i][j] = True\\n        self.dfs(grid, i+1, j, visited)\\n        self.dfs(grid, i-1, j, visited)\\n        self.dfs(grid, i, j+1, visited)\\n        self.dfs(grid, i, j-1, visited)",
                "codeTag": "Python3"
            },
            {
                "id": 583483,
                "title": "summarize-of-3-types-of-solution-methods",
                "content": "## solution 1\\uFF1ADFS/BFS\\n\\n```python\\ndef numIslands(self, grid: List[List[str]]) -> int:\\n        try: \\n            m,n = len(grid), len(grid[0])\\n        except: \\n            return 0\\n        cnt = 0\\n        ones = { (i,j) for i in range(m) for j in range(n) if grid[i][j]==\"1\" }\\n        while ones:\\n            queue = collections.deque([ ones.pop() ])\\n            while queue:\\n                i,j = queue.popleft()   # BFS\\n             # i,j = queue.pop()       # DFS\\n                for x,y in (i+1,j), (i-1,j), (i,j+1), (i,j-1):\\n                    if 0<=x<m and 0<=y<n and (x,y) in ones:\\n                        ones.discard( (x,y) )\\n                        queue.append( (x,y) )\\n            cnt += 1\\n        return cnt\\n```\\n\\nOR:\\n```python\\ncnt = 0\\nfor row in range(m):\\n    for col in range(n):\\n        if grid[row][col] == \"0\": continue  # notice it\\'s \"0\" not 0\\u2026\\u2026\\n        grid[row][col] = \"0\"\\n        queue = collections.deque([ (row,col) ])\\n        while queue:\\n            i,j = queue.popleft()  \\n            for x,y in (i-1,j), (i+1,j), (i,j-1), (i,j+1):\\n                if 0<=x<m and 0<=y<n and grid[x][y]==\"1\":\\n                    grid[x][y] = \"0\"\\n                    queue.append((x,y))\\n        cnt += 1\\n```\\n\\n### pretty pythonic code\\n```python\\ndef numIslands(self, grid):\\n    def sink(i, j):\\n        if 0 <= i < len(grid) and 0 <= j < len(grid[i]) and grid[i][j] == \\'1\\':\\n            grid[i][j] = \\'0\\'\\n            map(sink, (i+1, i-1, i, i), (j, j, j+1, j-1))\\n            return 1\\n        return 0\\n    return sum(sink(i, j) for i in range(len(grid)) for j in range(len(grid[i])))\\n```\\n\\n## solution 2\\uFF1AUnion Find\\n\\n```python\\nclass Solution:\\n    def find_parent( self, ij ):\\n        if self.parent[ij] == ij: return ij\\n        self.parent[ij] = self.find_parent( self.parent[ij] )\\n        return self.parent[ij]\\n    \\n    def union( self, ij1, ij2):\\n        if not ij2 in self.parent: return   # border check & \"0\" both included\\n        p1, p2 = self.find_parent(ij1), self.find_parent(ij2)\\n        if p1 == p2: return\\n        if self.rank[p1] < self.rank[p2]: p1,p2 = p2,p1  # p1 <- p2\\n        self.parent[p2] = p1\\n        self.rank[p1] = max( self.rank[p1], self.rank[p2]+1 )\\n        \\n    \\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        try: m,n = len(grid), len(grid[0])\\n        except:  return 0\\n        \\n        self.parent, self.rank = {}, {}\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \"1\":\\n                    self.parent[(i,j)] = (i,j)\\n                    self.rank[(i,j)] = 0\\n\\n        for i,j in self.parent.keys():\\n            for x,y in (i+1,j), (i,j+1):  self.union( (i,j), (x,y) )\\n                \\n        return len( set( self.find_parent(ij) for ij in self.parent.keys() ) )\\n```\\n\\n- use dictionary to implement `self.parent`\\uFF1A\\n    - can use `(i,j)` directly as key\\n    - no need for border check: border check & \"0\" both included in `i,j not in self.parent` \\n    - another method is to use `i*n+j` as index\\n\\n\\n\\n## solution 3\\n\\nEssentially still union find\\uFF0Cbut with additional tricks:\\n- `point_map` \\u2194 `parent`\\uFF0Cused to find parent\\n- `island_map` is the reverse of `point_map`\\uFF0Cused to find children\\uFF0Cwhich is not implemented is common Union Find.\\n\\n```python\\ndef numIslands(self, grid: List[List[str]]) -> int:\\n        try: m, n = len(grid), len(grid[0])\\n        except: return 0\\n        point_map, island_map = {}, {}\\n        num = 1\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \"0\": continue\\n                island1 = point_map.get( (i, j-1), None)\\n                island2 = point_map.get( (i-1, j), None)   \\n                if not island1 and not island2:\\n                    point_map[ (i, j) ] = num\\n                    island_map[num] = [ (i, j) ]\\n                    num += 1\\n                else:\\n                    if island1 and island2 and island1 != island2:\\n                        # island1 <- island2\\n                        if len(island_map[island1]) < len(island_map[island2]):  \\n                            island1,island2 = island2,island1   \\n                        for point in island_map[island2]:  point_map[point] = island1\\n                        island_map[island1] += island_map[island2]\\n                        island_map.pop(island2)\\n                        island2 = None\\n                    island = island1 or island2\\n                    point_map[(i, j)] = island\\n                    island_map[island].append((i, j))\\n                    \\n        return len(island_map)\\n```\\n\\n\\n\\n( Acknowledgement: Some pieces of code are learned from other\\'s post. I wrote this as a personal note a long time ago, so I didn\\'t record the source. Now I want to share it, but too lazy to find out the original posts. Contact me to add links to original posts if you wish. )\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```python\\ndef numIslands(self, grid: List[List[str]]) -> int:\\n        try: \\n            m,n = len(grid), len(grid[0])\\n        except: \\n            return 0\\n        cnt = 0\\n        ones = { (i,j) for i in range(m) for j in range(n) if grid[i][j]==\"1\" }\\n        while ones:\\n            queue = collections.deque([ ones.pop() ])\\n            while queue:\\n                i,j = queue.popleft()   # BFS\\n             # i,j = queue.pop()       # DFS\\n                for x,y in (i+1,j), (i-1,j), (i,j+1), (i,j-1):\\n                    if 0<=x<m and 0<=y<n and (x,y) in ones:\\n                        ones.discard( (x,y) )\\n                        queue.append( (x,y) )\\n            cnt += 1\\n        return cnt\\n```\n```python\\ncnt = 0\\nfor row in range(m):\\n    for col in range(n):\\n        if grid[row][col] == \"0\": continue  # notice it\\'s \"0\" not 0\\u2026\\u2026\\n        grid[row][col] = \"0\"\\n        queue = collections.deque([ (row,col) ])\\n        while queue:\\n            i,j = queue.popleft()  \\n            for x,y in (i-1,j), (i+1,j), (i,j-1), (i,j+1):\\n                if 0<=x<m and 0<=y<n and grid[x][y]==\"1\":\\n                    grid[x][y] = \"0\"\\n                    queue.append((x,y))\\n        cnt += 1\\n```\n```python\\ndef numIslands(self, grid):\\n    def sink(i, j):\\n        if 0 <= i < len(grid) and 0 <= j < len(grid[i]) and grid[i][j] == \\'1\\':\\n            grid[i][j] = \\'0\\'\\n            map(sink, (i+1, i-1, i, i), (j, j, j+1, j-1))\\n            return 1\\n        return 0\\n    return sum(sink(i, j) for i in range(len(grid)) for j in range(len(grid[i])))\\n```\n```python\\nclass Solution:\\n    def find_parent( self, ij ):\\n        if self.parent[ij] == ij: return ij\\n        self.parent[ij] = self.find_parent( self.parent[ij] )\\n        return self.parent[ij]\\n    \\n    def union( self, ij1, ij2):\\n        if not ij2 in self.parent: return   # border check & \"0\" both included\\n        p1, p2 = self.find_parent(ij1), self.find_parent(ij2)\\n        if p1 == p2: return\\n        if self.rank[p1] < self.rank[p2]: p1,p2 = p2,p1  # p1 <- p2\\n        self.parent[p2] = p1\\n        self.rank[p1] = max( self.rank[p1], self.rank[p2]+1 )\\n        \\n    \\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        try: m,n = len(grid), len(grid[0])\\n        except:  return 0\\n        \\n        self.parent, self.rank = {}, {}\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \"1\":\\n                    self.parent[(i,j)] = (i,j)\\n                    self.rank[(i,j)] = 0\\n\\n        for i,j in self.parent.keys():\\n            for x,y in (i+1,j), (i,j+1):  self.union( (i,j), (x,y) )\\n                \\n        return len( set( self.find_parent(ij) for ij in self.parent.keys() ) )\\n```\n```python\\ndef numIslands(self, grid: List[List[str]]) -> int:\\n        try: m, n = len(grid), len(grid[0])\\n        except: return 0\\n        point_map, island_map = {}, {}\\n        num = 1\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \"0\": continue\\n                island1 = point_map.get( (i, j-1), None)\\n                island2 = point_map.get( (i-1, j), None)   \\n                if not island1 and not island2:\\n                    point_map[ (i, j) ] = num\\n                    island_map[num] = [ (i, j) ]\\n                    num += 1\\n                else:\\n                    if island1 and island2 and island1 != island2:\\n                        # island1 <- island2\\n                        if len(island_map[island1]) < len(island_map[island2]):  \\n                            island1,island2 = island2,island1   \\n                        for point in island_map[island2]:  point_map[point] = island1\\n                        island_map[island1] += island_map[island2]\\n                        island_map.pop(island2)\\n                        island2 = None\\n                    island = island1 or island2\\n                    point_map[(i, j)] = island\\n                    island_map[island].append((i, j))\\n                    \\n        return len(island_map)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56588,
                "title": "standard-bfs-java-solution",
                "content": "DFS is faster I think, but this is my BFS solution:\\n\\n    public class Solution {\\n        int[][] dirs = {{-1,0},{1,0},{0,-1},{0,1}};\\n        public int numIslands(char[][] grid) {\\n            if(grid==null || grid.length==0) return 0;\\n            int islands = 0;\\n            for(int i=0;i<grid.length;i++){\\n                for(int j=0;j<grid[0].length;j++){\\n                    if(grid[i][j]=='1'){\\n                        islands++;\\n                        BFS(grid,i,j);\\n                    }\\n                }\\n            }\\n            return islands;\\n        }\\n        private void BFS(char[][] grid, int x, int y){\\n            grid[x][y] = '0';\\n            Queue<Point> q = new LinkedList<Point>();\\n            q.offer(new Point(x,y));\\n            while(q.size()>0){\\n                int size = q.size();\\n                Point p = q.poll();\\n                for(int i=0;i<size;i++){\\n                    for(int[] dir:dirs){\\n                        int x1 = p.x+dir[0];\\n                        int y1 = p.y+dir[1];\\n                        if(x1>=0 && y1>=0 && x1< grid.length && y1<grid[0].length && grid[x1][y1]=='1'){\\n                            grid[x1][y1] = '0';\\n                            q.offer(new Point(x1,y1));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    class Point{\\n        int x;\\n        int y;\\n        Point(int x, int y){\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        int[][] dirs = {{-1,0}",
                "codeTag": "Java"
            },
            {
                "id": 1284203,
                "title": "java-c-python-dfs-solution",
                "content": "# **Explanation**\\nDFS to search an island\\nreturn 1 if and only if we find an island.\\n<br>\\n\\n# **Complexity**\\nTime `O(mn)`\\nSpace `O(mn)`\\n<br>\\n\\n**Java**\\n```java\\n    public int numIslands(char[][] A) {\\n        int m = A.length, n = A[0].length, res = 0;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                res += dfs(A, i, j);\\n        return res;\\n    }\\n\\n    private int dfs(char[][] A, int i, int j) {\\n        int m = A.length, n = A[0].length;\\n        if (i < 0 || i == m || j < 0 || j == n || A[i][j] == \\'0\\') return 0;\\n        A[i][j] = \\'0\\';\\n        dfs(A, i - 1, j);\\n        dfs(A, i + 1, j);\\n        dfs(A, i, j - 1);\\n        dfs(A, i, j + 1);\\n        return 1;\\n    }\\n```\\n**C++**\\n```cpp\\n    int numIslands(vector<vector<char>>& A) {\\n        int m = A.size(), n = A[0].size(), res = 0;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                res += dfs(A, i, j);\\n        return res;\\n    }\\n\\n    int dfs(vector<vector<char>>& A, int i, int j) {\\n        int m = A.size(), n = A[0].size();\\n        if (i < 0 || i == m || j < 0 || j == n || A[i][j] == \\'0\\') return 0;\\n        A[i][j] = \\'0\\';\\n        dfs(A, i - 1, j);\\n        dfs(A, i + 1, j);\\n        dfs(A, i, j - 1);\\n        dfs(A, i, j + 1);\\n        return 1;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def numIslands(self, A):\\n        n, m = len(A), len(A[0])\\n\\n        def dfs(i, j):\\n            if not (0 <= i < n and 0 <= j < m and A[i][j] == \\'1\\'): return 0\\n            A[i][j] = \\'0\\'\\n            for di, dj in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\\n                dfs(i + di, j + dj)\\n            return 1\\n\\n        return sum(dfs(i, j) for i in xrange(n) for j in xrange(m) if A[i][j] == \"1\")\\n```\\n\\n",
                "solutionTags": [],
                "code": "```java\\n    public int numIslands(char[][] A) {\\n        int m = A.length, n = A[0].length, res = 0;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                res += dfs(A, i, j);\\n        return res;\\n    }\\n\\n    private int dfs(char[][] A, int i, int j) {\\n        int m = A.length, n = A[0].length;\\n        if (i < 0 || i == m || j < 0 || j == n || A[i][j] == \\'0\\') return 0;\\n        A[i][j] = \\'0\\';\\n        dfs(A, i - 1, j);\\n        dfs(A, i + 1, j);\\n        dfs(A, i, j - 1);\\n        dfs(A, i, j + 1);\\n        return 1;\\n    }\\n```\n```cpp\\n    int numIslands(vector<vector<char>>& A) {\\n        int m = A.size(), n = A[0].size(), res = 0;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                res += dfs(A, i, j);\\n        return res;\\n    }\\n\\n    int dfs(vector<vector<char>>& A, int i, int j) {\\n        int m = A.size(), n = A[0].size();\\n        if (i < 0 || i == m || j < 0 || j == n || A[i][j] == \\'0\\') return 0;\\n        A[i][j] = \\'0\\';\\n        dfs(A, i - 1, j);\\n        dfs(A, i + 1, j);\\n        dfs(A, i, j - 1);\\n        dfs(A, i, j + 1);\\n        return 1;\\n    }\\n```\n```py\\n    def numIslands(self, A):\\n        n, m = len(A), len(A[0])\\n\\n        def dfs(i, j):\\n            if not (0 <= i < n and 0 <= j < m and A[i][j] == \\'1\\'): return 0\\n            A[i][j] = \\'0\\'\\n            for di, dj in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\\n                dfs(i + di, j + dj)\\n            return 1\\n\\n        return sum(dfs(i, j) for i in xrange(n) for j in xrange(m) if A[i][j] == \"1\")\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 56407,
                "title": "what-if-we-can-only-read-line-by-line-real-interview-question-in-yahoo",
                "content": "This question itself is a very common DFS.\\nI give an answer when I was having interview in Yahoo, Flickr in seconds.\\n\\nThen the following up is, what if the matrix is very big?\\nThe interviewer might want an answer around like sparse matrix. But I come out a naive thinking of **read line by line.** I did not work it out in interview in 30 mins. But I did not give up after interview. Now I think I got a way. As following.\\n\\nI use a concept of \"color\", which is still a kind of dfs. But the connection is implemented by hashtable and the size of hashtable is limited to O(n). So, it's O(n) space complexity in all.(rather than O(n^2))\\n\\n\\nLet me explain it as following:\\n\"1111111\"\\n\"0000001\"\\n\"1111101\"\\n\"1000101\"\\n\"1010101\"\\n\"1011101\"\\n\"1111111\"\\nSuppose a matrix as above. We are gonna read them one line each time.\\n\\nline 0-1\\n\"1111111\"\\n\"0000001\"\\nland in Line 1 is colored by island in line 0 as island 1.\\n\\nline 1-2\\n\"0000001\"\\n\"2222201\"\\n***Line 2 is colored by island in line 1 and got another island. Will the another island be colored later? Let's see.***\\n\\nline 2-3\\n\"2222201\"\\n\"2000201\"\\n***Similar as above***\\n\\nline 3-4\\n\"2000201\"\\n\"2030201\"\\n***Similar as above. Now we got island 3.We count as we have 3 islands in total.***\\n\\nline 4-5\\n\"3(2)0303(2)01\"\\n\"3(2)033301\"\\n***Here, we found island 3 and island 2 are connected! So we color all island 2 to island 3(vice versa is also available) and minus 1 in our count of island***\\n\\nline 5-6\\n\"3033303(1)\"\\n\"3333333\"\\n***Then island 1 and island 3 are connected, we minus 1 on total again!***\\n\\nThen we got island total as 1!\\n\\n\\n```python\\nclass Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        \\n        #Increase itself\\n        c = 0\\n        \\n        def generateInterval(line):\\n            invArr = []\\n            i = 0\\n            while i<len(line):\\n                if line[i] == '1':\\n                    newInv = {'start':i}\\n                    while i<len(line) and line[i] == '1' :\\n                        i+=1\\n                    newInv['end'] = (i-1)\\n                    invArr.append(newInv)\\n                i += 1\\n            return invArr\\n            \\n        lastLineInvArr = []\\n         \\n        islandColorId = 1\\n        for line in grid:\\n            p = 0\\n            curInvArr = generateInterval(line)\\n            \\n            colorTransMap = {}\\n            j = 0\\n            for j in range(0, len(curInvArr)):\\n                curInv = curInvArr[j]\\n                while p<len(lastLineInvArr) and lastLineInvArr[p]['end']<curInv['start']:\\n                    p += 1\\n                \\n                if p>=len(lastLineInvArr):\\n                    break\\n                \\n                if curInv['end'] < lastLineInvArr[p]['start']:\\n                    c += 1\\n                    curInv['color'] = islandColorId\\n                    islandColorId+=1\\n                    continue\\n                \\n                while p<len(lastLineInvArr) and curInv['end']>=lastLineInvArr[p]['start']:\\n                    if not 'color' in curInv:\\n                        if lastLineInvArr[p]['color'] in colorTransMap:\\n                            lastLineInvArr[p]['color'] = colorTransMap[lastLineInvArr[p]['color']]\\n                        curInv['color'] = lastLineInvArr[p]['color']\\n                    else:\\n                        if not lastLineInvArr[p]['color']==curInv['color'] and lastLineInvArr[p]['color'] not in colorTransMap:\\n                            c -= 1\\n                            colorTransMap[lastLineInvArr[p]['color']] = curInv['color']\\n                            lastLineInvArr[p]['color'] = curInv['color']\\n                        \\n                    if curInv['end'] >= lastLineInvArr[p]['end']:\\n                        p+=1\\n                    else:\\n                        break\\n            \\n            while j<len(curInvArr):\\n                if 'color' not in curInvArr[j]:\\n                    c += 1\\n                    curInvArr[j]['color'] = islandColorId\\n                    islandColorId += 1\\n                j += 1\\n        \\n            for curInv in curInvArr:\\n                if curInv['color'] in colorTransMap:\\n                    curInv['color'] = colorTransMap[curInv['color']]    \\n            \\n            lastLineInvArr = curInvArr\\n                  \\n        return c\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        \\n        #Increase itself\\n        c = 0\\n        \\n        def generateInterval(line):\\n            invArr = []\\n            i = 0\\n            while i<len(line):\\n                if line[i] == '1':\\n                    newInv = {'start':i}\\n                    while i<len(line) and line[i] == '1' :\\n                        i+=1\\n                    newInv['end'] = (i-1)\\n                    invArr.append(newInv)\\n                i += 1\\n            return invArr\\n            \\n        lastLineInvArr = []\\n         \\n        islandColorId = 1\\n        for line in grid:\\n            p = 0\\n            curInvArr = generateInterval(line)\\n            \\n            colorTransMap = {}\\n            j = 0\\n            for j in range(0, len(curInvArr)):\\n                curInv = curInvArr[j]\\n                while p<len(lastLineInvArr) and lastLineInvArr[p]['end']<curInv['start']:\\n                    p += 1\\n                \\n                if p>=len(lastLineInvArr):\\n                    break\\n                \\n                if curInv['end'] < lastLineInvArr[p]['start']:\\n                    c += 1\\n                    curInv['color'] = islandColorId\\n                    islandColorId+=1\\n                    continue\\n                \\n                while p<len(lastLineInvArr) and curInv['end']>=lastLineInvArr[p]['start']:\\n                    if not 'color' in curInv:\\n                        if lastLineInvArr[p]['color'] in colorTransMap:\\n                            lastLineInvArr[p]['color'] = colorTransMap[lastLineInvArr[p]['color']]\\n                        curInv['color'] = lastLineInvArr[p]['color']\\n                    else:\\n                        if not lastLineInvArr[p]['color']==curInv['color'] and lastLineInvArr[p]['color'] not in colorTransMap:\\n                            c -= 1\\n                            colorTransMap[lastLineInvArr[p]['color']] = curInv['color']\\n                            lastLineInvArr[p]['color'] = curInv['color']\\n                        \\n                    if curInv['end'] >= lastLineInvArr[p]['end']:\\n                        p+=1\\n                    else:\\n                        break\\n            \\n            while j<len(curInvArr):\\n                if 'color' not in curInvArr[j]:\\n                    c += 1\\n                    curInvArr[j]['color'] = islandColorId\\n                    islandColorId += 1\\n                j += 1\\n        \\n            for curInv in curInvArr:\\n                if curInv['color'] in colorTransMap:\\n                    curInv['color'] = colorTransMap[curInv['color']]    \\n            \\n            lastLineInvArr = curInvArr\\n                  \\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56627,
                "title": "short-accepted-cpp-code",
                "content": "   \\n\\n     void DFS(vector<vector<char>>& grid, int i, int j){\\n    \\t    if(i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size()) return;\\n    \\t    if('0' == grid[i][j]) return;\\n    \\t    grid[i][j] = '0';\\n    \\t    DFS(grid, i-1, j);\\n    \\t    DFS(grid, i+1, j);\\n    \\t    DFS(grid, i, j - 1);\\n    \\t    DFS(grid, i, j + 1);\\n    \\t}\\n    \\tint numIslands(vector<vector<char>>& grid) {\\n    \\t\\tint counter = 0;\\n    \\t\\tfor (int i = 0; i < grid.size(); ++i)\\n    \\t\\t\\tfor (int j = 0; j < grid[i].size(); ++j)\\n    \\t\\t\\t\\tif ('1' == grid[i][j])\\n    \\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\t++counter;\\n    \\t\\t\\t\\t\\tDFS(grid, i, j);\\n    \\t\\t\\t\\t}\\n    \\t\\treturn counter;\\n    \\t}",
                "solutionTags": [
                    "C++"
                ],
                "code": "   \\n\\n     void DFS(vector<vector<char>>& grid, int i, int j){\\n    \\t    if(i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size()) return;\\n    \\t    if('0' == grid[i][j]) return;\\n    \\t    grid[i][j] = '0';\\n    \\t    DFS(grid, i-1, j);\\n    \\t    DFS(grid, i+1, j);\\n    \\t    DFS(grid, i, j - 1);\\n    \\t    DFS(grid, i, j + 1);\\n    \\t}\\n    \\tint numIslands(vector<vector<char>>& grid) {\\n    \\t\\tint counter = 0;\\n    \\t\\tfor (int i = 0; i < grid.size(); ++i)\\n    \\t\\t\\tfor (int j = 0; j < grid[i].size(); ++j)\\n    \\t\\t\\t\\tif ('1' == grid[i][j])\\n    \\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\t++counter;\\n    \\t\\t\\t\\t\\tDFS(grid, i, j);\\n    \\t\\t\\t\\t}\\n    \\t\\treturn counter;\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 903663,
                "title": "two-js-solutions",
                "content": "```\\nvar numIslands = function(grid) {\\n    if (grid.length <= 0) return 0;\\n    let count = 0, DIRECTIONS = [[-1,0],[0,1],[1,0],[0,-1]];\\n    let height = grid.length, width = grid[0].length;\\n    for (let row = 0; row < height; row++) {\\n        for (let col = 0; col < width; col++) {\\n            if (grid[row][col] == \\'1\\') { // there is no chance \\'0\\' is part of an island\\n                traverse(row, col); // once this finishes, we\\'ve visited all lands of one island\\n                count++;\\n            }\\n        }\\n    }\\n\\n    return count;\\n    \\n    // DFS Traversal\\n    function traverse(row, col) {\\n        if (row < 0 || row >= height || col < 0 || \\n            col >= width || grid[row][col] == \\'0\\') {\\n            return;\\n        }\\n        grid[row][col] = \"0\"; // turn land to water since we already visited it\\n        for (let dir of DIRECTIONS) {\\n            traverse(row+dir[0],col+dir[1]);\\n        }\\n    }\\n    // Time Complexity: O(m*n)\\n    // Space Complexity: O(m*n), if the entire grid is one island, it will take up m*n space in function call stack\\n};\\n```\\n\\n```\\nvar numIslands = function(grid) {\\n    let height = grid.length, width = grid[0].length;\\n    let count = 0;\\n    const DIRECTIONS = [[-1,0],[0,1],[1,0],[0,-1]];\\n    for (let row = 0; row < height; row++) {\\n        for (let col = 0; col < width; col++) {\\n            if (grid[row][col] == \"1\") {\\n                count++;\\n                traverse([[row,col]]);\\n            }\\n        }\\n    }\\n    return count;\\n    \\n    // BFS Traversal\\n    function traverse(queue) {\\n        while (queue.length > 0) {\\n            let [row, col] = queue.shift();\\n            if (row < 0 || row >= height || col < 0 || col >= width \\n                || grid[row][col] == \\'0\\') continue;\\n            grid[row][col] = \"0\"; // mark so that we know we already visited it\\n            for (let dir of DIRECTIONS) {\\n                queue.push([row+dir[0], col+dir[1]]);\\n            }\\n        }\\n    }\\n    // Time Complexity: O(m*n)\\n    // Space Complexity: O(m*n), queue might contain m*n elements if the entire grid is one island\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numIslands = function(grid) {\\n    if (grid.length <= 0) return 0;\\n    let count = 0, DIRECTIONS = [[-1,0],[0,1],[1,0],[0,-1]];\\n    let height = grid.length, width = grid[0].length;\\n    for (let row = 0; row < height; row++) {\\n        for (let col = 0; col < width; col++) {\\n            if (grid[row][col] == \\'1\\') { // there is no chance \\'0\\' is part of an island\\n                traverse(row, col); // once this finishes, we\\'ve visited all lands of one island\\n                count++;\\n            }\\n        }\\n    }\\n\\n    return count;\\n    \\n    // DFS Traversal\\n    function traverse(row, col) {\\n        if (row < 0 || row >= height || col < 0 || \\n            col >= width || grid[row][col] == \\'0\\') {\\n            return;\\n        }\\n        grid[row][col] = \"0\"; // turn land to water since we already visited it\\n        for (let dir of DIRECTIONS) {\\n            traverse(row+dir[0],col+dir[1]);\\n        }\\n    }\\n    // Time Complexity: O(m*n)\\n    // Space Complexity: O(m*n), if the entire grid is one island, it will take up m*n space in function call stack\\n};\\n```\n```\\nvar numIslands = function(grid) {\\n    let height = grid.length, width = grid[0].length;\\n    let count = 0;\\n    const DIRECTIONS = [[-1,0],[0,1],[1,0],[0,-1]];\\n    for (let row = 0; row < height; row++) {\\n        for (let col = 0; col < width; col++) {\\n            if (grid[row][col] == \"1\") {\\n                count++;\\n                traverse([[row,col]]);\\n            }\\n        }\\n    }\\n    return count;\\n    \\n    // BFS Traversal\\n    function traverse(queue) {\\n        while (queue.length > 0) {\\n            let [row, col] = queue.shift();\\n            if (row < 0 || row >= height || col < 0 || col >= width \\n                || grid[row][col] == \\'0\\') continue;\\n            grid[row][col] = \"0\"; // mark so that we know we already visited it\\n            for (let dir of DIRECTIONS) {\\n                queue.push([row+dir[0], col+dir[1]]);\\n            }\\n        }\\n    }\\n    // Time Complexity: O(m*n)\\n    // Space Complexity: O(m*n), queue might contain m*n elements if the entire grid is one island\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 56523,
                "title": "java-concise-dfs-solution",
                "content": "        \\n    public int numIslands(char[][] grid) {\\n        int ret = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == '1') {\\n                    ret++;\\n                    dfs(grid, i, j);\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    private void dfs(char[][] grid, int m, int n) {\\n        if (m < 0 || m >= grid.length || n < 0 || n >= grid[0].length || grid[m][n] != '1') {\\n            return;\\n        }\\n        grid[m][n] = '#';\\n        dfs(grid, m+1, n);\\n        dfs(grid, m-1, n);\\n        dfs(grid, m, n+1);\\n        dfs(grid, m, n-1);\\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "        \\n    public int numIslands(char[][] grid) {\\n        int ret = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == '1') {\\n                    ret++;\\n                    dfs(grid, i, j);\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    private void dfs(char[][] grid, int m, int n) {\\n        if (m < 0 || m >= grid.length || n < 0 || n >= grid[0].length || grid[m][n] != '1') {\\n            return;\\n        }\\n        grid[m][n] = '#';\\n        dfs(grid, m+1, n);\\n        dfs(grid, m-1, n);\\n        dfs(grid, m, n+1);\\n        dfs(grid, m, n-1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 295066,
                "title": "c-dfs-bfs-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    //dfs + recursive\\n    //time: o(row * column)\\n    //space: o(row)\\n    int numIslands(vector<vector<char>>& grid) {\\n        if(grid.empty())\\n            return 0;\\n        \\n        int count_of_islands = 0;\\n        for(int row = 0; row < grid.size(); ++row) {\\n            for(int col = 0; col < grid[0].size(); ++col) {\\n                if(grid[row][col] == \\'1\\') {\\n                    ++count_of_islands;\\n                    dfs(grid, row, col);//use dfs to mark every grid = 2 which belongs to this island.\\n                }   \\n            }  \\n        }\\n        return count_of_islands;\\n    }\\nprivate:\\n    //dfs to mark every grid in this island.\\n    int dfs(vector<vector<char>>& grid, int row, int col) {\\n        grid[row][col] = \\'2\\';\\n        for(auto d : dir) {\\n            int next_row = row + d.first;\\n            int next_col = col + d.second;\\n            if(next_row >= 0 && next_row < grid.size() && next_col >= 0 && next_col < grid[0].size() && grid[next_row][next_col] == \\'1\\') {\\n                dfs(grid, next_row, next_col);\\n            }   \\n        }\\n        return 0;\\n    }\\nprivate:\\n    vector<pair<int, int>> dir{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};//<row, column>\\n};\\n\\n//2.bfs\\nclass Solution {\\npublic:\\n    //bfs + iterative\\n    //time: o(row * column)\\n    //space: o(column)\\n    int numIslands(vector<vector<char>>& grid) {\\n        if(grid.empty())\\n            return 0;\\n        \\n        int count_of_islands = 0;\\n        for(int row = 0; row < grid.size(); ++row) {\\n            for(int col = 0; col < grid[0].size(); ++col) {\\n                if(grid[row][col] == \\'1\\') {\\n                    ++count_of_islands;\\n                    std::queue<pair<int, int>> bfs_que;//<row, column>\\n                    grid[row][col] = \\'2\\';\\n                    bfs_que.push(make_pair(row, col));\\n                    while(!bfs_que.empty()) {\\n                        std::pair<int, int> visited_node = bfs_que.front();\\n                        bfs_que.pop();\\n                        for(auto d : dir) {\\n                            int next_row = visited_node.first + d.first;\\n                            int next_col = visited_node.second + d.second;\\n                            if(next_row >= 0 && next_row < grid.size() && next_col >= 0 && next_col < grid[0].size() && grid[next_row][next_col] == \\'1\\') {\\n                                grid[next_row][next_col] = \\'2\\';\\n                                bfs_que.push(make_pair(next_row, next_col));\\n                            }\\n                            \\n                        }\\n                    }\\n                }   \\n            }  \\n        }\\n        return count_of_islands;\\n    }\\n\\nprivate:\\n    vector<pair<int, int>> dir{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};//<row, column>\\n};",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    //dfs + recursive\\n    //time: o(row * column)\\n    //space: o(row)\\n    int numIslands(vector<vector<char>>& grid) {\\n        if(grid.empty())\\n            return 0;\\n        \\n        int count_of_islands = 0;\\n        for(int row = 0; row < grid.size(); ++row) {\\n            for(int col = 0; col < grid[0].size(); ++col) {\\n                if(grid[row][col] == \\'1\\') {\\n                    ++count_of_islands;\\n                    dfs(grid, row, col);//use dfs to mark every grid = 2 which belongs to this island.\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 56575,
                "title": "python-iterative-recursive-bfs-dfs",
                "content": "I first used a \"visited\" set to store visited point, and then I found my old implementation set the visited point to \"2\", as posted. Then I was confused, isn't string immutable?\\n\\nProblem solved: input are not list of strings.\\n\\n    def numIslands(self, grid):\\n        # BFS\\n        if not grid:\\n            return 0\\n        m, n, count = len(grid), len(grid[0]), 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \"1\":\\n                    count += 1\\n                    stack = [(i,j)]\\n                    for ii,jj in stack:\\n                        if 0<=ii<m and 0<=jj<n and grid[ii][jj] == \"1\":\\n                            grid[ii][jj] = \"2\"\\n                            stack.extend([(ii+1,jj),(ii-1,jj),(ii,jj-1),(ii,jj+1)])\\n        return count\\n\\n        # DFS\\n        if not grid:\\n            return 0\\n        m, n, count = len(grid), len(grid[0]), 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \"1\":\\n                    count += 1\\n                    stack = [(i,j)]\\n                    while stack:\\n                        ii, jj = stack.pop()\\n                        if 0<=ii<m and 0<=jj<n and grid[ii][jj] == \"1\":\\n                            grid[ii][jj] = \"2\"\\n                            stack.extend([(ii+1,jj),(ii-1,jj),(ii,jj-1),(ii,jj+1)])\\n        return count\\n\\n        ## recursive DFS\\n        def dfs(grid, i,j):\\n            if 0<=i<m and 0<=j<n and grid[i][j] == \"1\":\\n                grid[i][j] = \"2\"\\n                dfs(grid, i-1, j)\\n                dfs(grid, i+1, j)\\n                dfs(grid, i, j-1)\\n                dfs(grid, i, j+1)\\n        if not grid:\\n            return 0\\n        m, n, count = len(grid), len(grid[0]), 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \"1\":\\n                    count += 1\\n                    dfs(grid, i, j)\\n        return count",
                "solutionTags": [
                    "Python"
                ],
                "code": "I first used a \"visited\" set to store visited point, and then I found my old implementation set the visited point to \"2\", as posted. Then I was confused, isn't string immutable?\\n\\nProblem solved: input are not list of strings.\\n\\n    def numIslands(self, grid):\\n        # BFS\\n        if not grid:\\n            return 0\\n        m, n, count = len(grid), len(grid[0]), 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \"1\":\\n                    count += 1\\n                    stack = [(i,j)]\\n                    for ii,jj in stack:\\n                        if 0<=ii<m and 0<=jj<n and grid[ii][jj] == \"1\":\\n                            grid[ii][jj] = \"2\"\\n                            stack.extend([(ii+1,jj),(ii-1,jj),(ii,jj-1),(ii,jj+1)])\\n        return count\\n\\n        # DFS\\n        if not grid:\\n            return 0\\n        m, n, count = len(grid), len(grid[0]), 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \"1\":\\n                    count += 1\\n                    stack = [(i,j)]\\n                    while stack:\\n                        ii, jj = stack.pop()\\n                        if 0<=ii<m and 0<=jj<n and grid[ii][jj] == \"1\":\\n                            grid[ii][jj] = \"2\"\\n                            stack.extend([(ii+1,jj),(ii-1,jj),(ii,jj-1),(ii,jj+1)])\\n        return count\\n\\n        ## recursive DFS\\n        def dfs(grid, i,j):\\n            if 0<=i<m and 0<=j<n and grid[i][j] == \"1\":\\n                grid[i][j] = \"2\"\\n                dfs(grid, i-1, j)\\n                dfs(grid, i+1, j)\\n                dfs(grid, i, j-1)\\n                dfs(grid, i, j+1)\\n        if not grid:\\n            return 0\\n        m, n, count = len(grid), len(grid[0]), 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \"1\":\\n                    count += 1\\n                    dfs(grid, i, j)\\n        return count",
                "codeTag": "Python3"
            },
            {
                "id": 56383,
                "title": "my-accepted-c-solution-may-be-trivial",
                "content": "    class Solution {\\n    public:\\n        void contaminate(vector<vector<char> > &grid, int i, int j){\\n            if(i>0&&grid[i-1][j]=='1'){\\n                grid[i-1][j]='0';\\n                contaminate(grid, i-1, j);\\n            }\\n            if(j>0&&grid[i][j-1]=='1'){\\n                grid[i][j-1]='0';\\n                contaminate(grid, i, j-1);\\n            }\\n            if(i<grid.size()-1&&grid[i+1][j]=='1'){\\n                grid[i+1][j]='0';\\n                contaminate(grid, i+1, j);\\n            }\\n            if(j<grid[0].size()-1&&grid[i][j+1]=='1'){\\n                grid[i][j+1]='0';\\n                contaminate(grid, i, j+1);\\n            }\\n        }\\n        int numIslands(vector<vector<char>> &grid) {\\n            int n=grid.size();\\n            if(n==0) return 0;\\n            int m=grid[0].size();\\n            \\n            int cnt=0;\\n            for(int i=0; i<n; i++){\\n                for(int j=0; j<m; j++){\\n                    if(grid[i][j]=='1'){\\n                        cnt++;\\n                        contaminate(grid, i, j);\\n                    }\\n                }\\n            }\\n            return cnt;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void contaminate(vector<vector<char> > &grid, int i, int j){\\n            if(i>0&&grid[i-1][j]=='1'){\\n                grid[i-1][j]='0';\\n                contaminate(grid, i-1, j);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1874609,
                "title": "c-very-very-simple-code-easy-to-understand-tc-o-n-m-sc-o-1",
                "content": "#### *Please Upvote if it helps\\u2B06\\uFE0F*\\n\\nFollow me on Github for Daily Leetcode Solution: [https://github.com/anant0059]()\\n\\n```\\nvoid Island(vector<vector<char>>& grid ,int i, int j){\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]==\\'0\\') return;\\n        grid[i][j]=\\'0\\';\\n        Island(grid, i+1, j);\\n        Island(grid, i-1, j);\\n        Island(grid, i, j+1);\\n        Island(grid,  i, j-1);\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        int n=grid.size(), m=grid[0].size(), ans=0;\\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<m;++j){\\n                if(grid[i][j]==\\'1\\'){\\n                    ans++;\\n                    Island(grid,i,j);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\\nThe extension of this question is [Max Area of Island.](https://leetcode.com/problems/max-area-of-island/) After little changes in the above solution we can evaluate this question also.\\n```\\nint area(vector<vector<int>>& grid ,int i, int j){\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]==-1 || grid[i][j]==0 ) return 0;\\n        grid[i][j]=-1;\\n        return 1+area(grid, i+1, j)+area(grid, i-1, j)+area(grid, i, j+1)+area(grid,  i, j-1);\\n    }\\n    \\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size(), ans=0;\\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<m;++j){\\n                if(grid[i][j]==1){\\n                    ans=max(ans,area(grid,i,j));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nvoid Island(vector<vector<char>>& grid ,int i, int j){\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]==\\'0\\') return;\\n        grid[i][j]=\\'0\\';\\n        Island(grid, i+1, j);\\n        Island(grid, i-1, j);\\n        Island(grid, i, j+1);\\n        Island(grid,  i, j-1);\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        int n=grid.size(), m=grid[0].size(), ans=0;\\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<m;++j){\\n                if(grid[i][j]==\\'1\\'){\\n                    ans++;\\n                    Island(grid,i,j);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```\\nint area(vector<vector<int>>& grid ,int i, int j){\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]==-1 || grid[i][j]==0 ) return 0;\\n        grid[i][j]=-1;\\n        return 1+area(grid, i+1, j)+area(grid, i-1, j)+area(grid, i, j+1)+area(grid,  i, j-1);\\n    }\\n    \\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size(), ans=0;\\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<m;++j){\\n                if(grid[i][j]==1){\\n                    ans=max(ans,area(grid,i,j));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 584060,
                "title": "javascript-using-simple-dfs-beats-99-speed-97-memory",
                "content": "```\\nvar numIslands = function(grid) {\\n    \\n    const callDFS = (i, j) => {\\n        if(i < 0 || i >= grid.length || j < 0 || j >= grid[i].length || grid[i][j] === \\'0\\') return;\\n        \\n        grid[i][j] = \\'0\\';\\n        \\n        callDFS(i-1, j); // up\\n        callDFS(i+1, j); // down\\n        callDFS(i, j-1); // left\\n        callDFS(i, j+1); // right\\n    }\\n    \\n    let count = 0;\\n    for(let i = 0; i < grid.length; i++) {\\n        \\n        for(let j = 0; j < grid[i].length; j++) {\\n            \\n            if(grid[i][j] === \\'1\\') {\\n                count++;\\n                callDFS(i, j)\\n            }\\n        }\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar numIslands = function(grid) {\\n    \\n    const callDFS = (i, j) => {\\n        if(i < 0 || i >= grid.length || j < 0 || j >= grid[i].length || grid[i][j] === \\'0\\') return;\\n        \\n        grid[i][j] = \\'0\\';\\n        \\n        callDFS(i-1, j); // up\\n        callDFS(i+1, j); // down\\n        callDFS(i, j-1); // left\\n        callDFS(i, j+1); // right\\n    }\\n    \\n    let count = 0;\\n    for(let i = 0; i < grid.length; i++) {\\n        \\n        for(let j = 0; j < grid[i].length; j++) {\\n            \\n            if(grid[i][j] === \\'1\\') {\\n                count++;\\n                callDFS(i, j)\\n            }\\n        }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 182838,
                "title": "readable-javascript-solution",
                "content": "60ms DFS solution\n\n```\nfunction numIslands(grid) {\n  let count = 0;\n\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[0].length; j++) {\n      if (grid[i][j] === '1') {\n        count++;\n        dfs(grid, i,j);\n      }\n    }\n  }\n\n  return count;\n}\n\nfunction dfs(grid, row, col) {\n  // bound check\n  if (row < 0 || row >= grid.length || col < 0 || col >= grid[0].length) return;\n\n  const value = grid[row][col];\n  if (value === '1') {\n    grid[row][col] = '#';\n    dfs(grid, row + 1, col);\n    dfs(grid, row - 1, col);\n    dfs(grid, row, col + 1);\n    dfs(grid, row, col - 1);\n  }\n}\n```",
                "solutionTags": [],
                "code": "```\nfunction numIslands(grid) {\n  let count = 0;\n\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[0].length; j++) {\n      if (grid[i][j] === '1') {\n        count++;\n        dfs(grid, i,j);\n      }\n    }\n  }\n\n  return count;\n}\n\nfunction dfs(grid, row, col) {\n  // bound check\n  if (row < 0 || row >= grid.length || col < 0 || col >= grid[0].length) return;\n\n  const value = grid[row][col];\n  if (value === '1') {\n    grid[row][col] = '#';\n    dfs(grid, row + 1, col);\n    dfs(grid, row - 1, col);\n    dfs(grid, row, col + 1);\n    dfs(grid, row, col - 1);\n  }\n}\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 56339,
                "title": "java-easy-version-to-understand",
                "content": "    \\tpublic static void DFS(char[][] grid, int i, int j) {\\n\\t\\tif (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length)\\n\\t\\t\\treturn;\\n\\t\\tif (grid[i][j] == '1') {\\n\\t\\t\\tgrid[i][j] = '2';\\n\\t\\t\\tDFS(grid, i + 1, j);\\n\\t\\t\\tDFS(grid, i - 1, j);\\n\\t\\t\\tDFS(grid, i, j + 1);\\n\\t\\t\\tDFS(grid, i, j - 1);\\n\\t\\t}\\n\\t}\\n\\n\\tpublic static int numIslands(char[][] grid) {\\n\\t\\tif (grid == null || grid.length == 0)\\n\\t\\t\\treturn 0;\\n\\t\\tint row = grid.length, column = grid[0].length, count = 0;\\n\\t\\tfor (int i = 0; i < row; i++)\\n\\t\\t\\tfor (int j = 0; j < column; j++) {\\n\\t\\t\\t\\tif (grid[i][j] == '1') {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tDFS(grid, i, j);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\treturn count;\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "    \\tpublic static void DFS(char[][] grid, int i, int j) {\\n\\t\\tif (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length)\\n\\t\\t\\treturn;\\n\\t\\tif (grid[i][j] == '1') {\\n\\t\\t\\tgrid[i][j] = '2';\\n\\t\\t\\tDFS(grid, i + 1, j);\\n\\t\\t\\tDFS(grid, i - 1, j);\\n\\t\\t\\tDFS(grid, i, j + 1);\\n\\t\\t\\tDFS(grid, i, j - 1);\\n\\t\\t}\\n\\t}\\n\\n\\tpublic static int numIslands(char[][] grid) {\\n\\t\\tif (grid == null || grid.length == 0)\\n\\t\\t\\treturn 0;\\n\\t\\tint row = grid.length, column = grid[0].length, count = 0;\\n\\t\\tfor (int i = 0; i < row; i++)\\n\\t\\t\\tfor (int j = 0; j < column; j++) {\\n\\t\\t\\t\\tif (grid[i][j] == '1') {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tDFS(grid, i, j);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\treturn count;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1386594,
                "title": "easy-to-understand-dfs-solution-in-python",
                "content": "In this problem we just have to count number of Island . the 1\\'s are island and 0\\'s are water(or simply not a island.)\\nIf we find a 1\\'s then we check for all 1\\'s connected to it and accordingly increment our ans.\\n**Note: single 1 is also a island in itself**\\n``` \\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        \\n        if not grid: return 0\\n        \\n        def DO_DFS(grid, row, col):\\n\\t\\t\\t# base case of this problem . checking for boundary condition .\\n\\t\\t\\t# so that our DFS couldn\\'t cross the boundary of the grid\\n            if row >= 0 and col >= 0 and row < len(grid) and col < len(grid[0]) and grid[row][col] == \\'1\\':\\n                grid[row][col] = \\'0\\'\\n                # performing DFS on all 4 direction \\n                DO_DFS(grid, row+1, col)\\n                DO_DFS(grid, row-1, col)\\n                DO_DFS(grid, row, col+1)\\n                DO_DFS(grid, row, col-1)\\n        \\n        isLand = 0\\n        \\n        rows, cols = len(grid), len(grid[0])\\n        \\n        for row in range(rows):\\n            for col in range(cols):\\n                if grid[row][col] == \\'1\\':\\n                    DO_DFS(grid, row, col)\\n                    isLand += 1\\n        return isLand\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "``` \\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        \\n        if not grid: return 0\\n        \\n        def DO_DFS(grid, row, col):\\n\\t\\t\\t# base case of this problem . checking for boundary condition .\\n\\t\\t\\t# so that our DFS couldn\\'t cross the boundary of the grid\\n            if row >= 0 and col >= 0 and row < len(grid) and col < len(grid[0]) and grid[row][col] == \\'1\\':\\n                grid[row][col] = \\'0\\'\\n                # performing DFS on all 4 direction \\n                DO_DFS(grid, row+1, col)\\n                DO_DFS(grid, row-1, col)\\n                DO_DFS(grid, row, col+1)\\n                DO_DFS(grid, row, col-1)\\n        \\n        isLand = 0\\n        \\n        rows, cols = len(grid), len(grid[0])\\n        \\n        for row in range(rows):\\n            for col in range(cols):\\n                if grid[row][col] == \\'1\\':\\n                    DO_DFS(grid, row, col)\\n                    isLand += 1\\n        return isLand\\n```",
                "codeTag": "Java"
            },
            {
                "id": 264826,
                "title": "python-dfs-bfs",
                "content": "The problem asks the number of connected \\'1\\' in the grid. \\nSo once we find a \\'1\\', we can use dfs or bfs to flipped all connected \\'1\\' to \\'0\\'. The times of finding a new \\'1\\' would be the number of islands.\\n```\\ndef numIslands(grid):\\n\\tm, n = len(grid), len(grid) and len(grid[0])\\n\\tdef dfs(i,j):\\n\\t\\tif 0 <= i < m and 0 <= j < n and grid[i][j] == \\'1\\':\\n\\t\\t\\tgrid[i][j] = \\'0\\'\\n\\t\\t\\tdfs(i-1, j), dfs(i+1, j), dfs(i, j-1), dfs(i, j+1)\\n\\t\\t\\treturn 1\\n\\t\\treturn 0\\n\\t\\t\\n\\tdef bfs(i, j):\\n\\t\\tq, grid[i][j] = [(i, j)], \"0\"\\n\\t\\tfor i, j in q:\\n\\t\\t\\tfor x, y in ((i-1,j), (i+1,j), (i,j-1), (i,j+1)):\\n\\t\\t\\t\\tif 0 <= x < m and 0 <= y < n and grid[x][y] == \"1\":\\n\\t\\t\\t\\t\\tgrid[x][y] = \"0\"\\n\\t\\t\\t\\t\\tq.append((x, y))\\n\\t\\treturn 1\\n\\t\\t\\t\\n\\t# return sum(dfs(i,j) for i in range(m) for j in range(n))\\n\\treturn sum(bfs(i,j) for i in range(m) for j in range(n) if grid[i][j] == \"1\")\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef numIslands(grid):\\n\\tm, n = len(grid), len(grid) and len(grid[0])\\n\\tdef dfs(i,j):\\n\\t\\tif 0 <= i < m and 0 <= j < n and grid[i][j] == \\'1\\':\\n\\t\\t\\tgrid[i][j] = \\'0\\'\\n\\t\\t\\tdfs(i-1, j), dfs(i+1, j), dfs(i, j-1), dfs(i, j+1)\\n\\t\\t\\treturn 1\\n\\t\\treturn 0\\n\\t\\t\\n\\tdef bfs(i, j):\\n\\t\\tq, grid[i][j] = [(i, j)], \"0\"\\n\\t\\tfor i, j in q:\\n\\t\\t\\tfor x, y in ((i-1,j), (i+1,j), (i,j-1), (i,j+1)):\\n\\t\\t\\t\\tif 0 <= x < m and 0 <= y < n and grid[x][y] == \"1\":\\n\\t\\t\\t\\t\\tgrid[x][y] = \"0\"\\n\\t\\t\\t\\t\\tq.append((x, y))\\n\\t\\treturn 1\\n\\t\\t\\t\\n\\t# return sum(dfs(i,j) for i in range(m) for j in range(n))\\n\\treturn sum(bfs(i,j) for i in range(m) for j in range(n) if grid[i][j] == \"1\")\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2615684,
                "title": "c-dfs-bfs-easy-to-understand",
                "content": "Number of Islands\\n \\n **1) DFS -**\\n \\n```\\n class Solution {\\npublic:   \\n    void dfs(int r, int c, vector<vector<char>>& grid)\\n    {\\n        if(r<0 || c<0 || r>=grid.size() || c>=grid[0].size() || grid[r][c]==\\'0\\')\\n        {\\n            return ;\\n        }      \\n        grid[r][c]=\\'0\\';\\n        dfs(r+1,c,grid);\\n        dfs(r-1,c,grid);\\n        dfs(r,c+1,grid);\\n        dfs(r,c-1,grid);\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int ans=0;        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==\\'1\\')\\n                {\\n                    ans++;\\n                    dfs(i,j,grid);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**2) BFS -**\\n\\n```\\nclass Solution {\\npublic:   \\n    void bfs(int r, int c, vector<vector<int>>& vis, vector<vector<char>> grid)\\n    {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vis[r][c]=1;\\n        queue<pair<int,int>> q;\\n        q.push({r,c});\\n        while(!q.empty())\\n        {\\n            r = q.front().first;\\n            c = q.front().second;\\n            q.pop();\\n            for(int i=-1;i<=1;i++)\\n            {\\n                for(int j=-1;j<=1;j++)\\n                {\\n                    if(abs(i)==abs(j)){continue;}\\n                    int newr = r + i;\\n                    int newc = c + j;\\n                    if(newr>=0 && newr<n && newc>=0 && newc<m && \\n                       grid[newr][newc]==\\'1\\' && vis[newr][newc]==0)\\n                    {\\n                        q.push({newr,newc});\\n                        vis[newr][newc]=1;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> vis(n, vector<int> (m,0));\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==\\'1\\' && vis[i][j]==0)\\n                {\\n                    ans++;\\n                    bfs(i,j,vis,grid);\\n                }\\n            }\\n        }\\n      return ans;  \\n    }\\n};\\n```\\n\\nPlease comment if you have any doubt.\\nWill get back to you as soon as possible.\\n**UPVOTE if you find it useful!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n class Solution {\\npublic:   \\n    void dfs(int r, int c, vector<vector<char>>& grid)\\n    {\\n        if(r<0 || c<0 || r>=grid.size() || c>=grid[0].size() || grid[r][c]==\\'0\\')\\n        {\\n            return ;\\n        }      \\n        grid[r][c]=\\'0\\';\\n        dfs(r+1,c,grid);\\n        dfs(r-1,c,grid);\\n        dfs(r,c+1,grid);\\n        dfs(r,c-1,grid);\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int ans=0;        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==\\'1\\')\\n                {\\n                    ans++;\\n                    dfs(i,j,grid);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:   \\n    void bfs(int r, int c, vector<vector<int>>& vis, vector<vector<char>> grid)\\n    {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vis[r][c]=1;\\n        queue<pair<int,int>> q;\\n        q.push({r,c});\\n        while(!q.empty())\\n        {\\n            r = q.front().first;\\n            c = q.front().second;\\n            q.pop();\\n            for(int i=-1;i<=1;i++)\\n            {\\n                for(int j=-1;j<=1;j++)\\n                {\\n                    if(abs(i)==abs(j)){continue;}\\n                    int newr = r + i;\\n                    int newc = c + j;\\n                    if(newr>=0 && newr<n && newc>=0 && newc<m && \\n                       grid[newr][newc]==\\'1\\' && vis[newr][newc]==0)\\n                    {\\n                        q.push({newr,newc});\\n                        vis[newr][newc]=1;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> vis(n, vector<int> (m,0));\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==\\'1\\' && vis[i][j]==0)\\n                {\\n                    ans++;\\n                    bfs(i,j,vis,grid);\\n                }\\n            }\\n        }\\n      return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2499050,
                "title": "super-simple-wicked-fast-100",
                "content": "**Algorithm:**\\n\\n*Valid islands in this 2D binary grid:*\\n\\n![image](https://assets.leetcode.com/users/images/9075c92d-92a8-4163-bd86-4c60b04df081_1661761222.0268018.png)\\n\\n\\n*1.We will maintain an array called \\u201Cislands\\u201D which will record the no. of islands visited.\\n2. Traverse through each element of the grid.\\n3. Check, if it is a land and it has not been visited yet i.e. grid[i][j] == 1, increment islands and change the value of that element to water i.e. 0.\\n4. Change the adjacent elements to water i.e. \\'0\\'.*\\n\\n```\\nclass Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        \\n        int islands = 0; // It will store the no. of islands in 2D grid\\n        \\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        \\n        for(int i=0; i<rows; i++){\\n            \\n            for(int j=0; j<cols; j++){\\n                \\n                if(grid[i][j] == \\'1\\'){\\n                    \\n                    islands++;\\n                    \\n                    globalWarming(grid, i, j, rows, cols);\\n                }\\n            }\\n        }\\n        \\n        return islands;\\n    }\\n    \\n    // This function changes all the adjacent 1\\'s to 0 because they all are part of the \\n    // same island\\n    \\n    // I have named it globalWarming because it is used to sink the adjacent islands\\n    \\n     void globalWarming(vector<vector<char>>& grid, int i, int j, int rows, int cols){\\n        \\n        if(i<0 || i>=rows || j<0 || j>=cols || grid[i][j]==\\'0\\'){\\n            return;\\n        }\\n        \\n        grid[i][j] = \\'0\\';\\n        \\n        globalWarming(grid, i+1, j, rows, cols);\\n        globalWarming(grid, i-1, j, rows, cols);\\n        globalWarming(grid, i, j+1, rows, cols);\\n        globalWarming(grid, i, j-1, rows, cols);\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/e441de6f-62bf-4f43-9c24-949620a9fe78_1661763503.2784755.jpeg)\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        \\n        int islands = 0; // It will store the no. of islands in 2D grid\\n        \\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        \\n        for(int i=0; i<rows; i++){\\n            \\n            for(int j=0; j<cols; j++){\\n                \\n                if(grid[i][j] == \\'1\\'){\\n                    \\n                    islands++;\\n                    \\n                    globalWarming(grid, i, j, rows, cols);\\n                }\\n            }\\n        }\\n        \\n        return islands;\\n    }\\n    \\n    // This function changes all the adjacent 1\\'s to 0 because they all are part of the \\n    // same island\\n    \\n    // I have named it globalWarming because it is used to sink the adjacent islands\\n    \\n     void globalWarming(vector<vector<char>>& grid, int i, int j, int rows, int cols){\\n        \\n        if(i<0 || i>=rows || j<0 || j>=cols || grid[i][j]==\\'0\\'){\\n            return;\\n        }\\n        \\n        grid[i][j] = \\'0\\';\\n        \\n        globalWarming(grid, i+1, j, rows, cols);\\n        globalWarming(grid, i-1, j, rows, cols);\\n        globalWarming(grid, i, j+1, rows, cols);\\n        globalWarming(grid, i, j-1, rows, cols);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2497913,
                "title": "striver-s-solution-ac-bfs-visited-matrix-4-directions",
                "content": "\\nDifferences in code present in video and this one:\\n- in the video he has taken all 8 neighours in consideration but here we only need 4 neighbours\\n\\nWorking code: \\n\\n```\\n\\nclass Solution\\n{\\nprivate:\\n    void bfs(int row, int col, vector<vector<int>> &visited, vector<vector<char>> &grid, int delta_row[], int delta_col[])\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        visited[row][col] = 1;\\n        queue<pair<int, int>> q;\\n        q.push({row, col});\\n\\n        while (!q.empty())\\n        {\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n\\n            \\n            for (int i = 0; i < 4; i++)\\n            {\\n                int neighbour_row = r + delta_row[i];\\n                int neighbour_col = c + delta_col[i];\\n\\n                // for each neighbour check boundary\\n                if (neighbour_row >= 0 && neighbour_row < n && neighbour_col >= 0 && neighbour_col < m)\\n                {\\n                    // check for land and prev visited\\n                    if (grid[neighbour_row][neighbour_col] == \\'1\\' && !visited[neighbour_row][neighbour_col])\\n                    {\\n                        visited[neighbour_row][neighbour_col] = 1;\\n                        q.push({neighbour_row, neighbour_col});\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\npublic:\\n    int numIslands(vector<vector<char>> &grid)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> visited(n, vector<int>(m, 0));\\n        int ans = 0;\\n        int delta_row[] = {-1, 0, 1, 0};\\n        int delta_col[] = {0, 1, 0, -1};\\n\\n        for (int r = 0; r < n; r++)\\n            for (int c = 0; c < m; c++)\\n                if (!visited[r][c] && grid[r][c] == \\'1\\')\\n                {\\n                    ++ans;\\n                    bfs(r, c, visited, grid, delta_row, delta_col);\\n                }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\nStriver\\'s video can be found [here](https://youtu.be/muncqlKJrH0)\\n\\nIf this post helped you, kindly upvote!\\n",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\n\\nclass Solution\\n{\\nprivate:\\n    void bfs(int row, int col, vector<vector<int>> &visited, vector<vector<char>> &grid, int delta_row[], int delta_col[])\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        visited[row][col] = 1;\\n        queue<pair<int, int>> q;\\n        q.push({row, col});\\n\\n        while (!q.empty())\\n        {\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n\\n            \\n            for (int i = 0; i < 4; i++)\\n            {\\n                int neighbour_row = r + delta_row[i];\\n                int neighbour_col = c + delta_col[i];\\n\\n                // for each neighbour check boundary\\n                if (neighbour_row >= 0 && neighbour_row < n && neighbour_col >= 0 && neighbour_col < m)\\n                {\\n                    // check for land and prev visited\\n                    if (grid[neighbour_row][neighbour_col] == \\'1\\' && !visited[neighbour_row][neighbour_col])\\n                    {\\n                        visited[neighbour_row][neighbour_col] = 1;\\n                        q.push({neighbour_row, neighbour_col});\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\npublic:\\n    int numIslands(vector<vector<char>> &grid)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> visited(n, vector<int>(m, 0));\\n        int ans = 0;\\n        int delta_row[] = {-1, 0, 1, 0};\\n        int delta_col[] = {0, 1, 0, -1};\\n\\n        for (int r = 0; r < n; r++)\\n            for (int c = 0; c < m; c++)\\n                if (!visited[r][c] && grid[r][c] == \\'1\\')\\n                {\\n                    ++ans;\\n                    bfs(r, c, visited, grid, delta_row, delta_col);\\n                }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1585867,
                "title": "intuitive-reason-for-time-complexity-analysis-of-bfs-and-dfs-appraoch",
                "content": "Hello all\\n\\nAfter wasting 2 days on this question - time complexity, i came up with following intution that helped me understanding this.\\n\\n**Approach DFS or BFS**\\nT(N) = O(rows x cols)\\n\\n**Time complexity seems 4 ^ O(rows x cols) if we think this as for each node, we have 4 ways to expand, but it is not !!!**\\n**Reason**- Lets say, we are at one cell (r,c), from this we have 4 ways and at this point, we mark the cell (r,c) as visited.\\n```\\n           (r-1,c)\\n                |\\n(r,c-1) -    (r,c)   - (r,c+1)\\n            visited\\n               |\\n           (r+1,c) \\n```\\nNow, from each neighbour cell, we will have again 4 ways to expand (technically 3 because we came from (r,c) which has been visited so no need to go further - But you can say 4 comparisons will happen in each neighbouring cell again )\\nIt means, if we see each cell, there will be at-most 4 comparisons on that due to its 4 neighbours.\\n```\\n                (r-1,c)\\n                    |\\n(r,c-1)      -    (r,c)   -      (r,c+1)\\n              4 comparisions\\n                    |\\n                 (r+1,c) \\n```\\nTime complexity = 4 + 4 + 4 + ... + 4 (rows x cols times)\\n= 4 x O(row x col) = O(row x col)\\n\\n**Space Complexity Analysis for DFS-**\\nHere, we are using Recursion stack and Recursion stack can grow to the total cells available (assume all 1\\'s)\\n**S(N) = O(rows x cols) +  O(rows x cols) [visited hashmap]**\\n\\n**Space Complexity Analysis for BFS-**\\nHere, we are using Queue. Now the question is **what can be the max size of the Queue here?**\\nLets say we have 3 x 100 grid and we start from middle node.\\n```\\n(Q means the cell is in the Queue, X means the cell has been processed and outside of the Queue)\\n_    _    _    _    _.   _.   _\\n_    _    _    Q   _.   _.   _     Total cells in Queue = 1\\n_    _    _    _    _.   _.   _\\nExpand ...\\n_    _    _    Q    _.   _.   _\\n_    _    Q    x    Q.   _.   _.   Total cells in Queue = 4\\n_    _    _    Q    _.   _.   _\\nExpand ...\\n_    _    Q   x    Q.   _.   _\\n_    Q    x    x    x.   Q.   _.    Total cells in Queue = 6 (becomes Limited)\\n_    _    Q    x    Q.   _.   _\\nExpand ...\\n_    Q    x   x    x.   Q.   _\\nQ    x    x    x    x.   x.   Q.    Total cells in Queue = 6 (becomes Limited)\\n_    Q    x    x    x   Q.   _\\n\\n```\\nSo, total cells in queue becomes limited due to the 3 rows as compare to the 100 cols.\\nSo, **S(N) = Min(row,col) # queue**",
                "solutionTags": [
                    "Stack",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n           (r-1,c)\\n                |\\n(r,c-1) -    (r,c)   - (r,c+1)\\n            visited\\n               |\\n           (r+1,c) \\n```\n```\\n                (r-1,c)\\n                    |\\n(r,c-1)      -    (r,c)   -      (r,c+1)\\n              4 comparisions\\n                    |\\n                 (r+1,c) \\n```\n```\\n(Q means the cell is in the Queue, X means the cell has been processed and outside of the Queue)\\n_    _    _    _    _.   _.   _\\n_    _    _    Q   _.   _.   _     Total cells in Queue = 1\\n_    _    _    _    _.   _.   _\\nExpand ...\\n_    _    _    Q    _.   _.   _\\n_    _    Q    x    Q.   _.   _.   Total cells in Queue = 4\\n_    _    _    Q    _.   _.   _\\nExpand ...\\n_    _    Q   x    Q.   _.   _\\n_    Q    x    x    x.   Q.   _.    Total cells in Queue = 6 (becomes Limited)\\n_    _    Q    x    Q.   _.   _\\nExpand ...\\n_    Q    x   x    x.   Q.   _\\nQ    x    x    x    x.   x.   Q.    Total cells in Queue = 6 (becomes Limited)\\n_    Q    x    x    x   Q.   _\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 678547,
                "title": "c-both-dfs-and-bfs-approaches-with-comments-runtime-comparison",
                "content": "```\\nstatic const auto ____ = [](){\\n\\t// fast I/O\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr), cout.tie(nullptr);\\n    return 0;\\n}();\\n\\n/*\\nDFS\\nRuntime - 20 ms, Memory - 10.1 MB\\n*/\\nclass Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        if(grid.empty())    return 0;\\n        int m = grid.size(), n = grid[0].size(), cnt = 0;\\n        vector<vector<bool>> visited(m, vector<bool>(n, 0));\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(!visited[i][j] && grid[i][j] == \\'1\\') {\\n                    dfs(grid, i, j, visited);\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    void dfs(vector<vector<char>> &grid, int i, int j, vector<vector<bool>> &visited) {\\n        if(i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() || visited[i][j] || grid[i][j] == \\'0\\')     return;\\n        \\n        visited[i][j] = 1;\\n        dfs(grid, i-1, j, visited);\\n        dfs(grid, i, j+1, visited);\\n        dfs(grid, i+1, j, visited);\\n        dfs(grid, i, j-1, visited);\\n    }\\n};\\n\\n/*\\nBFS\\nRuntime - 28 ms, Memory - 10.7 MB\\n*/\\nclass Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        if(grid.empty())    return 0;\\n        int m = grid.size(), n = grid[0].size(), cnt = 0;\\n        vector<vector<bool>> visited(m, vector<bool>(n, 0));\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(!visited[i][j] && grid[i][j] == \\'1\\') {\\n                    cnt++;\\n                    bfs(grid, i, j, visited);\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    void bfs(vector<vector<char>> &grid, int i, int j, vector<vector<bool>> &visited) {\\n        // lambda to check whether current cell is inside grid\\n        auto inside = [&](const pair<int, int> &p) -> bool {\\n            return p.first >= 0 && p.first < grid.size() && p.second >= 0 && p.second < grid[0].size();\\n        };\\n        \\n        // adding any pair to a coordinate gives a neighboring cell (up, right, down, left)\\n        vector<pair<int, int>> direction = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        \\n        queue<pair<int, int>> q;\\n        q.push({i, j});\\n        while(!q.empty()) {\\n            auto curr_cell = q.front();\\n            q.pop();\\n            visited[curr_cell.first][curr_cell.second] = 1;\\n            \\n            // for all neighboring cells of current cell\\n            for(auto dir: direction) {\\n                int new_i = (curr_cell.first + dir.first), new_j = (curr_cell.second + dir.second);\\n                auto new_cell = make_pair(new_i, new_j);\\n                // if neighboring cell lies inside grid and not visited already and has island part (i.e \\'1\\') then add it to queue\\n                if(inside(new_cell) && !visited[new_i][new_j] && grid[new_i][new_j] == \\'1\\') {\\n                    visited[new_i][new_j] = 1;\\n                    q.push(new_cell);\\n                }\\n            }\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nstatic const auto ____ = [](){\\n\\t// fast I/O\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr), cout.tie(nullptr);\\n    return 0;\\n}();\\n\\n/*\\nDFS\\nRuntime - 20 ms, Memory - 10.1 MB\\n*/\\nclass Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        if(grid.empty())    return 0;\\n        int m = grid.size(), n = grid[0].size(), cnt = 0;\\n        vector<vector<bool>> visited(m, vector<bool>(n, 0));\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(!visited[i][j] && grid[i][j] == \\'1\\') {\\n                    dfs(grid, i, j, visited);\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    void dfs(vector<vector<char>> &grid, int i, int j, vector<vector<bool>> &visited) {\\n        if(i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() || visited[i][j] || grid[i][j] == \\'0\\')     return;\\n        \\n        visited[i][j] = 1;\\n        dfs(grid, i-1, j, visited);\\n        dfs(grid, i, j+1, visited);\\n        dfs(grid, i+1, j, visited);\\n        dfs(grid, i, j-1, visited);\\n    }\\n};\\n\\n/*\\nBFS\\nRuntime - 28 ms, Memory - 10.7 MB\\n*/\\nclass Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        if(grid.empty())    return 0;\\n        int m = grid.size(), n = grid[0].size(), cnt = 0;\\n        vector<vector<bool>> visited(m, vector<bool>(n, 0));\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(!visited[i][j] && grid[i][j] == \\'1\\') {\\n                    cnt++;\\n                    bfs(grid, i, j, visited);\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    void bfs(vector<vector<char>> &grid, int i, int j, vector<vector<bool>> &visited) {\\n        // lambda to check whether current cell is inside grid\\n        auto inside = [&](const pair<int, int> &p) -> bool {\\n            return p.first >= 0 && p.first < grid.size() && p.second >= 0 && p.second < grid[0].size();\\n        };\\n        \\n        // adding any pair to a coordinate gives a neighboring cell (up, right, down, left)\\n        vector<pair<int, int>> direction = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        \\n        queue<pair<int, int>> q;\\n        q.push({i, j});\\n        while(!q.empty()) {\\n            auto curr_cell = q.front();\\n            q.pop();\\n            visited[curr_cell.first][curr_cell.second] = 1;\\n            \\n            // for all neighboring cells of current cell\\n            for(auto dir: direction) {\\n                int new_i = (curr_cell.first + dir.first), new_j = (curr_cell.second + dir.second);\\n                auto new_cell = make_pair(new_i, new_j);\\n                // if neighboring cell lies inside grid and not visited already and has island part (i.e \\'1\\') then add it to queue\\n                if(inside(new_cell) && !visited[new_i][new_j] && grid[new_i][new_j] == \\'1\\') {\\n                    visited[new_i][new_j] = 1;\\n                    q.push(new_cell);\\n                }\\n            }\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 522736,
                "title": "in-c",
                "content": "```\\n\\nvoid visit(char **grid, int i, int j, int gridSize, int *gridColSize)\\n{\\n    if (i < 0 || j < 0 || i >= gridSize)\\n        return;\\n    if (j >= gridColSize[i])\\n        return;\\n    if (grid[i][j] == \\'0\\')\\n        return;\\n    grid[i][j] = \\'0\\';\\n    visit(grid, i-1, j, gridSize, gridColSize);\\n    visit(grid, i+1, j, gridSize, gridColSize);\\n    visit(grid, i, j-1, gridSize, gridColSize);\\n    visit(grid, i, j+1, gridSize, gridColSize);\\n}\\n\\nint numIslands(char** grid, int gridSize, int* gridColSize){\\n    int i, j;\\n    int res = 0;\\n    \\n    for (i = 0; i < gridSize; i++) {\\n        for (j = 0; j < gridColSize[i]; j++) {\\n            if (grid[i][j] == \\'1\\') {\\n                visit(grid, i, j, gridSize, gridColSize);\\n                res++;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nvoid visit(char **grid, int i, int j, int gridSize, int *gridColSize)\\n{\\n    if (i < 0 || j < 0 || i >= gridSize)\\n        return;\\n    if (j >= gridColSize[i])\\n        return;\\n    if (grid[i][j] == \\'0\\')\\n        return;\\n    grid[i][j] = \\'0\\';\\n    visit(grid, i-1, j, gridSize, gridColSize);\\n    visit(grid, i+1, j, gridSize, gridColSize);\\n    visit(grid, i, j-1, gridSize, gridColSize);\\n    visit(grid, i, j+1, gridSize, gridColSize);\\n}\\n\\nint numIslands(char** grid, int gridSize, int* gridColSize){\\n    int i, j;\\n    int res = 0;\\n    \\n    for (i = 0; i < gridSize; i++) {\\n        for (j = 0; j < gridColSize[i]; j++) {\\n            if (grid[i][j] == \\'1\\') {\\n                visit(grid, i, j, gridSize, gridColSize);\\n                res++;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 56336,
                "title": "python-dfs-with-explanation",
                "content": "```\\nclass Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        # idea is to make connected components count 1 only by making them 0 once visited\\n        self.sum = 0\\n        for row in range(len(grid)):\\n            for col in range(len(grid[0])):\\n                self.sum += self.find_islands(grid, row, col)\\n        return self.sum\\n        \\n    def find_islands(self, grid,i, j):\\n        if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == \"1\":\\n            grid[i][j] = \"0\"\\n            # go top left right bottom \\n            # make all 1's 0 till all connected becomes zero\\n            # then return 1 as all connected componets forms one island\\n            # done\\n            self.find_islands(grid, i + 1, j)\\n            self.find_islands(grid, i, j-1)\\n            self.find_islands(grid, i-1, j)\\n            self.find_islands(grid, i, j + 1)\\n            return 1\\n        return 0\\n            \\n        \\n\\n        \\n        ```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        # idea is to make connected components count 1 only by making them 0 once visited\\n        self.sum = 0\\n        for row in range(len(grid)):\\n            for col in range(len(grid[0])):\\n                self.sum += self.find_islands(grid, row, col)\\n        return self.sum\\n        \\n    def find_islands(self, grid,i, j):\\n        if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == \"1\":\\n            grid[i][j] = \"0\"\\n            # go top left right bottom \\n            # make all 1's 0 till all connected becomes zero\\n            # then return 1 as all connected componets forms one island\\n            # done\\n            self.find_islands(grid, i + 1, j)\\n            self.find_islands(grid, i, j-1)\\n            self.find_islands(grid, i-1, j)\\n            self.find_islands(grid, i, j + 1)\\n            return 1\\n        return 0\\n            \\n        \\n\\n        \\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 56549,
                "title": "ac-java-solution-using-union-find-with-explanations",
                "content": "It is a classical DFS problem, and my solution applied union-find algorithm that passed all the test cases.\\nBasic idea is to iterate through every node's neighbours and marked them if they aren't connected.\\nFinally, if it was the root node then increase the total number of islands.\\n\\n\\npublic class Solution {\\n\\t\\n\\tprivate int[] sz;\\n\\tprivate int[] id;\\n\\tprivate int N, M;\\n\\t\\n\\tpublic int find(int p) {\\n\\t\\twhile (id[p] != p) \\n\\t\\t\\tp = id[p];\\n\\t\\treturn p;\\n\\t}\\n\\t\\n\\tpublic void union(int p, int q) {\\n\\t\\tint rootP = find(p);\\n\\t\\tint rootQ = find(q);\\n\\t\\tif (rootP == rootQ) return;\\n\\t\\t\\n\\t\\tif (sz[rootP] < sz[rootQ])\\t{sz[rootQ] += sz[rootP]; id[rootP] = id[rootQ];}\\n\\t\\telse \\t\\t\\t\\t\\t\\t{sz[rootP] += sz[rootQ]; id[rootQ] = id[rootP];}\\n\\t}\\n\\t\\n\\tprivate boolean inside(int x, int y) {\\n\\t\\treturn (x >= 0 && y >= 0 && x < N && y < M);\\n\\t}\\n\\t\\n\\tpublic int numIslands(char[][] grid) {\\n\\t\\tif (grid == null || grid.length ==0) return 0;\\n\\t\\tN = grid.length;\\n\\t\\tM = grid[0].length;\\n\\t\\tsz = new int[N*M];\\n\\t\\tid = new int[N*M];\\n\\t\\tfor (int i = 0; i < N*M; i++) {\\n\\t\\t\\tid[i] = i;\\n\\t\\t\\tsz[i] = 1;\\n\\t\\t}\\n        for (int i = 0; i < N; i++) {\\n        \\tfor (int j = 0; j < M; j++) \\n        \\t\\tif (grid[i][j] != '0') {\\n\\t        \\t\\tint tmp = i*M + j;\\n\\t        \\t\\tif (inside(i-1, j) && grid[i-1][j] != '0') union(tmp, tmp - M);\\n\\t        \\t\\tif (inside(i, j-1) && grid[i][j-1] != '0') union(tmp, tmp - 1);\\n\\t        \\t\\tif (inside(i+1, j) && grid[i+1][j] != '0') union(tmp, tmp + M);\\n\\t        \\t\\tif (inside(i, j+1) && grid[i][j+1] != '0') union(tmp, tmp + 1);\\n\\t        \\t}\\n        }\\n        int islands = 0, i = 0;\\n        while (i < N*M) {\\n        \\tif (i == id[i] && grid[i/M][i%M] != '0') islands++;\\n        \\ti++;\\n        }\\n        return islands;\\n\\t}\\n}",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "class Solution {\\n\\t\\n\\tprivate int[] sz;\\n\\tprivate int[] id;\\n\\tprivate int N, M;\\n\\t\\n\\tpublic int find(int p) {\\n\\t\\twhile (id[p] != p) \\n\\t\\t\\tp = id[p];\\n\\t\\treturn p;\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 56673,
                "title": "simple-dfs-sulotion",
                "content": "Dont need the extra space, and O(mn)\\n\\n    public int numIslands(char[][] grid) {\\n        int islands = 0;\\n        if (grid != null && grid.length != 0 && grid[0].length != 0) {\\n            for (int i = 0; i < grid.length; i++) {\\n                for (int j = 0; j < grid[0].length; j++) {\\n                    if (grid[i][j] == '1') {\\n                        dfs(grid, i, j);\\n                        islands++;\\n                    }\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n    \\n    private void dfs(char[][] grid, int x, int y) {\\n        if (x < 0 || grid.length <= x || y < 0 || grid[0].length <= y || grid[x][y] != '1') {\\n            return;\\n        }\\n        grid[x][y] = 'x';\\n        dfs(grid, x + 1, y);\\n        dfs(grid, x - 1, y);\\n        dfs(grid, x, y + 1);\\n        dfs(grid, x, y - 1);\\n    }",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "Dont need the extra space, and O(mn)\\n\\n    public int numIslands(char[][] grid) {\\n        int islands = 0;\\n        if (grid != null && grid.length != 0 && grid[0].length != 0) {\\n            for (int i = 0; i < grid.length; i++) {\\n                for (int j = 0; j < grid[0].length; j++) {\\n                    if (grid[i][j] == '1') {\\n                        dfs(grid, i, j);\\n                        islands++;\\n                    }\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n    \\n    private void dfs(char[][] grid, int x, int y) {\\n        if (x < 0 || grid.length <= x || y < 0 || grid[0].length <= y || grid[x][y] != '1') {\\n            return;\\n        }\\n        grid[x][y] = 'x';\\n        dfs(grid, x + 1, y);\\n        dfs(grid, x - 1, y);\\n        dfs(grid, x, y + 1);\\n        dfs(grid, x, y - 1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 679357,
                "title": "iterative-dfs-and-bfs-explained",
                "content": "aim is to explain iterative BFS/DFS.\\n\\n**BFS - Breadth First Search**\\nWe use Queue in BFS , again WHY ? , because of its FIFO nature , (First in First OUT nature ).\\n```\\nint x[] = {-1,0,1,0};       // these are direction array , starting from UP then clockwise ( left , down , right )\\nint y[] = {0,1,0,-1};\\nclass Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int n = grid.size();\\n        if(n==0)    return 0;                   // edge case : empty grid  |   eg  [[]] \\n        int m = grid[0].size();\\n        int no_of_island = 0;\\n        \\n        queue<pair<int,int>> que;\\n        \\n        for(int i=0 ; i<n ; i++)\\n        {\\n            for(int j=0 ; j<m ; j++)\\n            {\\n                if(grid[i][j]==\\'1\\')     \\n                {\\n                    no_of_island++;\\n                    que.push({i,j});\\n                    // BFS                                        \\n                    while(que.size())\\n                    {\\n                        auto [ startI , startJ ] = que.front();    que.pop();    \\n                        grid[startI][startJ] = \\'0\\';\\n                        for(int dir = 0 ; dir<4 ; dir++)    \\n                        {\\n                            int newi = startI + x[dir];\\n                            int newj = startJ + y[dir];\\n                            if(newi>=0 and newj>=0 and newi<n and newj<m and grid[newi][newj]==\\'1\\')\\n                                que.push({newi,newj}) , grid[newi][newj] = \\'0\\';\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return no_of_island;\\n    }\\n};\\n```\\n**DFS : Iterative**\\nwhen it comes to Depth first search then we use Stack , why ? beacause of its LIFO (last in First Out nature ).\\nNotice changes : we replaced all ques with stack and we are good to go, **Yep its that simple !**\\n```\\nint x[] = {-1,0,1,0};       // these are direction array , starting from UP then clockwise ( left , down , right )\\nint y[] = {0,1,0,-1};\\nclass Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int n = grid.size();\\n        if(n==0)    return 0;                   // edge case : empty grid  |   eg  [[]] \\n        int m = grid[0].size();\\n        int no_of_island = 0;\\n        \\n        stack<pair<int,int>> sk;\\n        \\n        for(int i=0 ; i<n ; i++)\\n        {\\n            for(int j=0 ; j<m ; j++)\\n            {\\n                if(grid[i][j]==\\'1\\')     // this place may be the begining of new island\\n                {\\n                    no_of_island++;\\n                    sk.push({i,j});\\n                    grid[i][j] = \\'0\\';\\n                    // DFS                                       \\n                    while(sk.size())\\n                    {\\n                        auto [ startI , startJ ] = sk.top();    sk.pop();\\n                        grid[startI][startJ] = \\'0\\';   // marking as visited to avoid looping, eliminating need of visited array\\n                                                      \\n                        for(int dir = 0 ; dir<4 ; dir++)\\n                        {\\n                            int newi = startI + x[dir];\\n                            int newj = startJ + y[dir];\\n\\t\\t\\t\\t\\t\\t\\t// if VALID and CONNECTED\\n                            if(newi>=0 and newj>=0 and newi<n and newj<m and grid[newi][newj]==\\'1\\')\\n                                sk.push({newi,newj});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return no_of_island;\\n    }\\n};\\n```\\ndoubts ? **comments are welcomed.**",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nint x[] = {-1,0,1,0};       // these are direction array , starting from UP then clockwise ( left , down , right )\\nint y[] = {0,1,0,-1};\\nclass Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int n = grid.size();\\n        if(n==0)    return 0;                   // edge case : empty grid  |   eg  [[]] \\n        int m = grid[0].size();\\n        int no_of_island = 0;\\n        \\n        queue<pair<int,int>> que;\\n        \\n        for(int i=0 ; i<n ; i++)\\n        {\\n            for(int j=0 ; j<m ; j++)\\n            {\\n                if(grid[i][j]==\\'1\\')     \\n                {\\n                    no_of_island++;\\n                    que.push({i,j});\\n                    // BFS                                        \\n                    while(que.size())\\n                    {\\n                        auto [ startI , startJ ] = que.front();    que.pop();    \\n                        grid[startI][startJ] = \\'0\\';\\n                        for(int dir = 0 ; dir<4 ; dir++)    \\n                        {\\n                            int newi = startI + x[dir];\\n                            int newj = startJ + y[dir];\\n                            if(newi>=0 and newj>=0 and newi<n and newj<m and grid[newi][newj]==\\'1\\')\\n                                que.push({newi,newj}) , grid[newi][newj] = \\'0\\';\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return no_of_island;\\n    }\\n};\\n```\n```\\nint x[] = {-1,0,1,0};       // these are direction array , starting from UP then clockwise ( left , down , right )\\nint y[] = {0,1,0,-1};\\nclass Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int n = grid.size();\\n        if(n==0)    return 0;                   // edge case : empty grid  |   eg  [[]] \\n        int m = grid[0].size();\\n        int no_of_island = 0;\\n        \\n        stack<pair<int,int>> sk;\\n        \\n        for(int i=0 ; i<n ; i++)\\n        {\\n            for(int j=0 ; j<m ; j++)\\n            {\\n                if(grid[i][j]==\\'1\\')     // this place may be the begining of new island\\n                {\\n                    no_of_island++;\\n                    sk.push({i,j});\\n                    grid[i][j] = \\'0\\';\\n                    // DFS                                       \\n                    while(sk.size())\\n                    {\\n                        auto [ startI , startJ ] = sk.top();    sk.pop();\\n                        grid[startI][startJ] = \\'0\\';   // marking as visited to avoid looping, eliminating need of visited array\\n                                                      \\n                        for(int dir = 0 ; dir<4 ; dir++)\\n                        {\\n                            int newi = startI + x[dir];\\n                            int newj = startJ + y[dir];\\n\\t\\t\\t\\t\\t\\t\\t// if VALID and CONNECTED\\n                            if(newi>=0 and newj>=0 and newi<n and newj<m and grid[newi][newj]==\\'1\\')\\n                                sk.push({newi,newj});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return no_of_island;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3220533,
                "title": "200-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis problem can be solved using a variation of Depth First Search (DFS) algorithm. We will traverse through the given matrix and visit all the connected 1\\'s, marking them as visited. We will keep a count of the number of times we visit the 1\\'s. Whenever we encounter an unvisited 1, we will increment the count and perform a DFS on its neighbors, marking all the visited 1\\'s as visited. Finally, we will return the count of the number of islands.\\n\\nAlgorithm:\\n\\n1. Initialize a count variable to 0.\\n2. Traverse through the given matrix.\\n3. Whenever we encounter an unvisited 1, increment the count and perform a DFS on its neighbors, marking all the visited 1\\'s as visited.\\n4. Return the count of the number of islands.\\n\\n# Complexity\\n- Time complexity:\\nO(mn), where m is the number of rows and n is the number of columns in the given matrix.\\n\\n- Space complexity:\\nO(mn), where m is the number of rows and n is the number of columns in the given matrix. The space is used by the visited matrix.\\n\\n# Code\\n```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        def dfs(i: int, j: int) -> None:\\n            if i < 0 or j < 0 or i >= m or j >= n or grid[i][j] == \"0\" or visited[i][j]:\\n                # If the current cell is out of bounds or is water (0) or has already been visited, return.\\n                return\\n            visited[i][j] = True # Mark the current cell as visited.\\n            dfs(i+1, j) # Visit the neighbor to the right.\\n            dfs(i-1, j) # Visit the neighbor to the left.\\n            dfs(i, j+1) # Visit the neighbor below.\\n            dfs(i, j-1) # Visit the neighbor above.\\n        \\n        m, n = len(grid), len(grid[0]) # Get the dimensions of the given matrix.\\n        visited = [[False for _ in range(n)] for _ in range(m)] # Initialize a visited matrix with False for all cells.\\n        count = 0 # Initialize a count variable to 0.\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \"1\" and not visited[i][j]: # If we encounter an unvisited 1, increment the count and perform a DFS on its neighbors, marking all the visited 1\\'s as visited.\\n                    count += 1\\n                    dfs(i, j)\\n        return count # Return the count of the number of islands.\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        def dfs(i: int, j: int) -> None:\\n            if i < 0 or j < 0 or i >= m or j >= n or grid[i][j] == \"0\" or visited[i][j]:\\n                # If the current cell is out of bounds or is water (0) or has already been visited, return.\\n                return\\n            visited[i][j] = True # Mark the current cell as visited.\\n            dfs(i+1, j) # Visit the neighbor to the right.\\n            dfs(i-1, j) # Visit the neighbor to the left.\\n            dfs(i, j+1) # Visit the neighbor below.\\n            dfs(i, j-1) # Visit the neighbor above.\\n        \\n        m, n = len(grid), len(grid[0]) # Get the dimensions of the given matrix.\\n        visited = [[False for _ in range(n)] for _ in range(m)] # Initialize a visited matrix with False for all cells.\\n        count = 0 # Initialize a count variable to 0.\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \"1\" and not visited[i][j]: # If we encounter an unvisited 1, increment the count and perform a DFS on its neighbors, marking all the visited 1\\'s as visited.\\n                    count += 1\\n                    dfs(i, j)\\n        return count # Return the count of the number of islands.\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1366890,
                "title": "easy-c-solution-using-dfs-95-faster",
                "content": "#### C++\\n```\\nclass Solution {\\npublic:\\n    \\n    void dfsislands(vector<vector<char>>& grid, int i, int j)\\n    {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]!=\\'1\\')\\n        {\\n            return;\\n        }\\n        \\n        grid[i][j]=\\'2\\';\\n        dfsislands(grid,i+1,j);\\n        dfsislands(grid,i,j+1);\\n        dfsislands(grid,i-1,j);\\n        dfsislands(grid,i,j-1);\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        \\n        int n=grid.size(),m=grid[0].size();\\n        int count=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==\\'1\\')\\n                {\\n                    count++;\\n                    dfsislands(grid,i,j);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void dfsislands(vector<vector<char>>& grid, int i, int j)\\n    {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]!=\\'1\\')\\n        {\\n            return;\\n        }\\n        \\n        grid[i][j]=\\'2\\';\\n        dfsislands(grid,i+1,j);\\n        dfsislands(grid,i,j+1);\\n        dfsislands(grid,i-1,j);\\n        dfsislands(grid,i,j-1);\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        \\n        int n=grid.size(),m=grid[0].size();\\n        int count=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==\\'1\\')\\n                {\\n                    count++;\\n                    dfsislands(grid,i,j);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 347290,
                "title": "swift-solution-clean-code-dfs-bfs",
                "content": "```\\nclass Solution {\\n    func numIslands(_ grid: [[Character]]) -> Int {\\n        guard grid.count != 0, grid[0].count != 0 else { return 0 }\\n        var count = 0\\n        var grid = grid\\n        \\n        for row in 0..<grid.count {\\n            for col in 0..<grid[0].count {\\n                if grid[row][col] == \"1\" {\\n                    DFS(row, col, &grid)\\n                    //BFS(row, col, &grid)\\n                    count += 1\\n                }\\n            }\\n        }\\n        return count\\n    }\\n\\t\\n    // DFS\\n    func DFS(_ row: Int, _ col: Int, _ grid: inout [[Character]]) {\\n        guard row >= 0, row < grid.count, col >= 0, col < grid[0].count, grid[row][col] == \"1\" else { return }\\n        grid[row][col] = \"0\" // set visited\\n        \\n        DFS(row-1, col, &grid)\\n        DFS(row+1, col, &grid)\\n        DFS(row, col-1, &grid)\\n        DFS(row, col+1, &grid)\\n    }\\n\\t\\n    // BFS\\n    func BFS(_ row: Int, _ col: Int, _ grid: inout [[Character]]) {\\n        var queue = [(Int,Int)]()\\n        queue.append((row, col))\\n        grid[row][col] = \"0\" // set visited\\n        \\n        while queue.count != 0 {\\n            let current = queue.removeFirst()\\n            let (curRow, curCol) = current\\n            \\n            if curRow-1 >= 0, grid[curRow-1][curCol] == \"1\" { \\n                queue.append((curRow-1, curCol))\\n                grid[curRow-1][curCol] = \"0\"\\n            }\\n            if curRow+1 < grid.count, grid[curRow+1][curCol] == \"1\" { \\n                queue.append((curRow+1, curCol)) \\n                grid[curRow+1][curCol] = \"0\"\\n            }\\n            if curCol-1 >= 0, grid[curRow][curCol-1] == \"1\" { \\n                queue.append((curRow, curCol-1)) \\n                grid[curRow][curCol-1] = \"0\"\\n            }\\n            if curCol+1 < grid[0].count, grid[curRow][curCol+1] == \"1\" { \\n                queue.append((curRow, curCol+1)) \\n                grid[curRow][curCol+1] = \"0\"\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    func numIslands(_ grid: [[Character]]) -> Int {\\n        guard grid.count != 0, grid[0].count != 0 else { return 0 }\\n        var count = 0\\n        var grid = grid\\n        \\n        for row in 0..<grid.count {\\n            for col in 0..<grid[0].count {\\n                if grid[row][col] == \"1\" {\\n                    DFS(row, col, &grid)\\n                    //BFS(row, col, &grid)\\n                    count += 1\\n                }\\n            }\\n        }\\n        return count\\n    }\\n\\t\\n    // DFS\\n    func DFS(_ row: Int, _ col: Int, _ grid: inout [[Character]]) {\\n        guard row >= 0, row < grid.count, col >= 0, col < grid[0].count, grid[row][col] == \"1\" else { return }\\n        grid[row][col] = \"0\" // set visited\\n        \\n        DFS(row-1, col, &grid)\\n        DFS(row+1, col, &grid)\\n        DFS(row, col-1, &grid)\\n        DFS(row, col+1, &grid)\\n    }\\n\\t\\n    // BFS\\n    func BFS(_ row: Int, _ col: Int, _ grid: inout [[Character]]) {\\n        var queue = [(Int,Int)]()\\n        queue.append((row, col))\\n        grid[row][col] = \"0\" // set visited\\n        \\n        while queue.count != 0 {\\n            let current = queue.removeFirst()\\n            let (curRow, curCol) = current\\n            \\n            if curRow-1 >= 0, grid[curRow-1][curCol] == \"1\" { \\n                queue.append((curRow-1, curCol))\\n                grid[curRow-1][curCol] = \"0\"\\n            }\\n            if curRow+1 < grid.count, grid[curRow+1][curCol] == \"1\" { \\n                queue.append((curRow+1, curCol)) \\n                grid[curRow+1][curCol] = \"0\"\\n            }\\n            if curCol-1 >= 0, grid[curRow][curCol-1] == \"1\" { \\n                queue.append((curRow, curCol-1)) \\n                grid[curRow][curCol-1] = \"0\"\\n            }\\n            if curCol+1 < grid[0].count, grid[curRow][curCol+1] == \"1\" { \\n                queue.append((curRow, curCol+1)) \\n                grid[curRow][curCol+1] = \"0\"\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 272999,
                "title": "c-efficient-solution-beat-100",
                "content": "```\\npublic class Solution {\\n    public int NumIslands(char[][] grid) {\\n      var count = 0;\\n      for (int i = 0; i < grid.Length; i++)\\n      {\\n        for (int j = 0; j < grid[i].Length; j++)\\n        {\\n          if (grid[i][j] == \\'1\\')\\n          {\\n            count++;\\n            UpdateGrid(i, j, grid);\\n          }\\n        }\\n      }\\n\\n      return count;\\n    }\\n    \\n    public void UpdateGrid(int i, int j, char[][] grid)\\n    {\\n      if (i < 0 || j < 0 || i == grid.Length || j == grid[0].Length || grid[i][j] == \\'0\\') return;\\n      grid[i][j] = \\'0\\';\\n\\n      UpdateGrid(i - 1, j, grid); //top\\n      UpdateGrid(i + 1, j, grid); //bottom\\n      UpdateGrid(i, j - 1, grid); //left\\n      UpdateGrid(i, j + 1, grid); //right\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumIslands(char[][] grid) {\\n      var count = 0;\\n      for (int i = 0; i < grid.Length; i++)\\n      {\\n        for (int j = 0; j < grid[i].Length; j++)\\n        {\\n          if (grid[i][j] == \\'1\\')\\n          {\\n            count++;\\n            UpdateGrid(i, j, grid);\\n          }\\n        }\\n      }\\n\\n      return count;\\n    }\\n    \\n    public void UpdateGrid(int i, int j, char[][] grid)\\n    {\\n      if (i < 0 || j < 0 || i == grid.Length || j == grid[0].Length || grid[i][j] == \\'0\\') return;\\n      grid[i][j] = \\'0\\';\\n\\n      UpdateGrid(i - 1, j, grid); //top\\n      UpdateGrid(i + 1, j, grid); //bottom\\n      UpdateGrid(i, j - 1, grid); //left\\n      UpdateGrid(i, j + 1, grid); //right\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791201,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = m ? grid[0].size() : 0, islands = 0, offsets[] = {0, 1, 0, -1, 0};\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    islands++;\\n                    grid[i][j] = \\'0\\';\\n                    queue<pair<int, int>> todo;\\n                    todo.push({i, j});\\n                    while (!todo.empty()) {\\n                        pair<int, int> p = todo.front();\\n                        todo.pop();\\n                        for (int k = 0; k < 4; k++) {\\n                            int r = p.first + offsets[k], c = p.second + offsets[k + 1];\\n                            if (r >= 0 && r < m && c >= 0 && c < n && grid[r][c] == \\'1\\') {\\n                                grid[r][c] = \\'0\\';\\n                                todo.push({r, c});\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = m ? grid[0].size() : 0, islands = 0, offsets[] = {0, 1, 0, -1, 0};\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    islands++;\\n                    grid[i][j] = \\'0\\';\\n                    queue<pair<int, int>> todo;\\n                    todo.push({i, j});\\n                    while (!todo.empty()) {\\n                        pair<int, int> p = todo.front();\\n                        todo.pop();\\n                        for (int k = 0; k < 4; k++) {\\n                            int r = p.first + offsets[k], c = p.second + offsets[k + 1];\\n                            if (r >= 0 && r < m && c >= 0 && c < n && grid[r][c] == \\'1\\') {\\n                                grid[r][c] = \\'0\\';\\n                                todo.push({r, c});\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2546582,
                "title": "go-dfs-bfs",
                "content": "Time complexity: O(mn + 4mn) -> O(mn)\\nspace complexity: O(mn)\\n\\n```\\nfunc numIslands(grid [][]byte) int {\\n    count := 0\\n    \\n    for i := 0; i < len(grid); i++ {\\n        for j := 0; j < len(grid[i]); j++ {\\n            if grid[i][j] == \\'1\\' {\\n                count++\\n                \\n                dfs(grid, i, j)\\n\\t\\t\\t\\t// bfs(grid, i, j)\\n            }\\n        }\\n    }\\n    \\n    return count\\n}\\n\\nfunc dfs(grid [][]byte, r, c int) {\\n    if r < 0 || r >= len(grid) || c < 0 || c >= len(grid[r]) || grid[r][c] != \\'1\\' {\\n        return\\n    }\\n    \\n    grid[r][c] = \\'2\\'\\n    dfs(grid, r+1, c)\\n    dfs(grid, r-1, c)\\n    dfs(grid, r, c+1)\\n    dfs(grid, r, c-1)\\n}\\n\\nfunc bfs(grid [][]byte, r, c int) {\\n    q := [][2]int{}\\n    \\n    q = append(q, [2]int{r,c})\\n    grid[r][c] = \\'2\\'\\n    \\n    offsets := [4][2]int{{-1,0}, {1,0}, {0,1}, {0,-1}}\\n    for len(q) > 0 {\\n        curr := q[0]\\n        q = q[1:]\\n        \\n        for _, offset := range offsets {\\n            x := curr[0] + offset[0]\\n            y := curr[1] + offset[1]\\n            \\n            if x >= 0 && x < len(grid) && y >= 0 && y < len(grid[x]) && grid[x][y] == \\'1\\' {\\n                q = append(q, [2]int{x,y})\\n                grid[x][y] = 2\\n            }\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Go",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nfunc numIslands(grid [][]byte) int {\\n    count := 0\\n    \\n    for i := 0; i < len(grid); i++ {\\n        for j := 0; j < len(grid[i]); j++ {\\n            if grid[i][j] == \\'1\\' {\\n                count++\\n                \\n                dfs(grid, i, j)\\n\\t\\t\\t\\t// bfs(grid, i, j)\\n            }\\n        }\\n    }\\n    \\n    return count\\n}\\n\\nfunc dfs(grid [][]byte, r, c int) {\\n    if r < 0 || r >= len(grid) || c < 0 || c >= len(grid[r]) || grid[r][c] != \\'1\\' {\\n        return\\n    }\\n    \\n    grid[r][c] = \\'2\\'\\n    dfs(grid, r+1, c)\\n    dfs(grid, r-1, c)\\n    dfs(grid, r, c+1)\\n    dfs(grid, r, c-1)\\n}\\n\\nfunc bfs(grid [][]byte, r, c int) {\\n    q := [][2]int{}\\n    \\n    q = append(q, [2]int{r,c})\\n    grid[r][c] = \\'2\\'\\n    \\n    offsets := [4][2]int{{-1,0}, {1,0}, {0,1}, {0,-1}}\\n    for len(q) > 0 {\\n        curr := q[0]\\n        q = q[1:]\\n        \\n        for _, offset := range offsets {\\n            x := curr[0] + offset[0]\\n            y := curr[1] + offset[1]\\n            \\n            if x >= 0 && x < len(grid) && y >= 0 && y < len(grid[x]) && grid[x][y] == \\'1\\' {\\n                q = append(q, [2]int{x,y})\\n                grid[x][y] = 2\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2497974,
                "title": "c-dfs-explained",
                "content": "**UPVOTE IF HELPFUL**\\n\\n**We need to count number of groups of \\'1\\'. But only single \"1\" is to be counted from one island.**\\n\\n**APPROACH\\nWe traverse the grid element by element.**\\n**When :**\\n\\n* **grid[i][j] == \"0\" -> Do nothing**\\n* **grid[i][j] == \"1\" ->There is an island.**\\n* **Increase the count of islands by one.**\\n* **Now we need to remove the island from the grid. [ WHY : It is done to prevent counting the rest of \"1\" that belong to same island ]**\\n* **We can use DFS to traverse through the island, where :**\\n* **If \"1\" is there, make it \"0\".**\\n* **Break out if we reach out of boundaries or we encounter \"0\" -> water.**\\n* **And to the same for neighbouring cells.**\\n\\n-----------------------------------------------------------------------------\\n# C# Code\\n\\n\\tusing System.Threading.Tasks;\\n\\tpublic class Solution {\\n\\t\\tprivate static int[][] directions => new int[][]{new int[]{0,-1}, new int[]{-1,0}, new int[]{0,1}, new int[]{1,0}};\\n\\n\\t\\tpublic int NumIslands(char[][] grid) {\\n\\t\\t\\tint ans = 0;\\n\\n\\t\\t\\tfor(int i=0; i<grid.Length; ++i){\\n\\t\\t\\t\\tfor(int j=0; j<grid[0].Length; ++j){\\n\\t\\t\\t\\t\\tif(grid[i][j]==\\'1\\'){  // if current grid is 1 there is part of island\\n\\t\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\t\\tDFS(i, j, grid);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\t\\t// concurrent DFS\\n\\t\\tpublic void DFS(int i, int j, char[][] grid){\\n\\t\\t\\tif(i<0 || j<0 || i==grid.Length || j==grid[0].Length)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tif(grid[i][j]==\\'0\\') //if current is visited return \\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tgrid[i][j] = \\'0\\'; // making visited current \\n\\n\\t\\t\\tParallel.ForEach(directions, d=>DFS(i+d[0], j+d[1], grid)) ;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\t\\tprivate static int[][] directions => new int[][]{new int[]{0,-1}",
                "codeTag": "Java"
            },
            {
                "id": 1353449,
                "title": "go-simple-dfs",
                "content": "Straightforward DFS solution in Go\\n\\n```go\\nfunc numIslands(grid [][]byte) int {\\n    result := 0\\n    for i, row := range grid {\\n        for j, value := range row {\\n            if value == \\'1\\' {\\n                visit(&grid, i, j)\\n                result += 1\\n            }\\n        }\\n    }\\n    return result\\n}\\n\\nfunc visit(grid *[][]byte, i int, j int) {\\n    m, n := len(*grid), len((*grid)[0])\\n    if (i < 0) || (i >= m) || (j < 0) || (j >= n) || ((*grid)[i][j] == \\'0\\') {\\n        return\\n    }\\n\\n    (*grid)[i][j] = \\'0\\'\\n    \\n    visit(grid, i-1, j)\\n    visit(grid, i+1, j)\\n    visit(grid, i, j-1)\\n    visit(grid, i, j+1)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search"
                ],
                "code": "```go\\nfunc numIslands(grid [][]byte) int {\\n    result := 0\\n    for i, row := range grid {\\n        for j, value := range row {\\n            if value == \\'1\\' {\\n                visit(&grid, i, j)\\n                result += 1\\n            }\\n        }\\n    }\\n    return result\\n}\\n\\nfunc visit(grid *[][]byte, i int, j int) {\\n    m, n := len(*grid), len((*grid)[0])\\n    if (i < 0) || (i >= m) || (j < 0) || (j >= n) || ((*grid)[i][j] == \\'0\\') {\\n        return\\n    }\\n\\n    (*grid)[i][j] = \\'0\\'\\n    \\n    visit(grid, i-1, j)\\n    visit(grid, i+1, j)\\n    visit(grid, i, j-1)\\n    visit(grid, i, j+1)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 772514,
                "title": "c-bfs-dfs-solution",
                "content": "Traverse the whole grid and whenever you encounter a \\'1\\' increase the answer counter and convert all its neighbouring \\'1\\' to \\'0\\'s using BFS or DFS approach as required.\\n\\n**DFS approach :** \\n```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<vector<char>> &grid, int i, int j, int m, int n) {\\n        if(i>=0 && i<m && j>=0 && j<n && grid[i][j] == \\'1\\') {\\n            grid[i][j] = 0;\\n            dfs(grid, i-1, j, m, n);\\n            dfs(grid, i+1, j, m, n);\\n            dfs(grid, i, j-1, m, n);\\n            dfs(grid, i, j+1, m, n);\\n        }\\n        else\\n            return;\\n            \\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        \\n        if(grid.size() == 0)\\n            return 0;\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int ans = 0;\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(grid[i][j] == \\'1\\') {\\n                    ans++;\\n                    dfs(grid, i, j, m, n);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**BFS approach:** using queue data structure \\n```\\nclass Solution {\\npublic:  \\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        \\n        if(grid.size() == 0)\\n            return 0;\\n        \\n        vector<vector<int>> dirs = {{0,1}, {0,-1}, {1,0}, {-1,0}};\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int ans = 0;\\n        \\n        queue<pair<int,int>> q;\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(grid[i][j] == \\'1\\') {\\n                    ans++;\\n                    q.emplace(make_pair(i,j));\\n                    \\n                    while(!q.empty()) {\\n                        auto pos = q.front();\\n                        q.pop();\\n                        int u = pos.first;\\n                        int v = pos.second;\\n                        \\n                        if(grid[u][v] == \\'1\\') {\\n                            grid[u][v] = \\'0\\';\\n                            for(auto dir : dirs) { \\n                                int a = u + dir[0];\\n                                int b = v + dir[1];\\n                                if(a>=0 && a<m && b>=0 && b<n)\\n                                    q.emplace(make_pair(a, b));\\n                            }\\n                        }\\n                            \\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<vector<char>> &grid, int i, int j, int m, int n) {\\n        if(i>=0 && i<m && j>=0 && j<n && grid[i][j] == \\'1\\') {\\n            grid[i][j] = 0;\\n            dfs(grid, i-1, j, m, n);\\n            dfs(grid, i+1, j, m, n);\\n            dfs(grid, i, j-1, m, n);\\n            dfs(grid, i, j+1, m, n);\\n        }\\n        else\\n            return;\\n            \\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        \\n        if(grid.size() == 0)\\n            return 0;\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int ans = 0;\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(grid[i][j] == \\'1\\') {\\n                    ans++;\\n                    dfs(grid, i, j, m, n);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:  \\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        \\n        if(grid.size() == 0)\\n            return 0;\\n        \\n        vector<vector<int>> dirs = {{0,1}, {0,-1}, {1,0}, {-1,0}};\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int ans = 0;\\n        \\n        queue<pair<int,int>> q;\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(grid[i][j] == \\'1\\') {\\n                    ans++;\\n                    q.emplace(make_pair(i,j));\\n                    \\n                    while(!q.empty()) {\\n                        auto pos = q.front();\\n                        q.pop();\\n                        int u = pos.first;\\n                        int v = pos.second;\\n                        \\n                        if(grid[u][v] == \\'1\\') {\\n                            grid[u][v] = \\'0\\';\\n                            for(auto dir : dirs) { \\n                                int a = u + dir[0];\\n                                int b = v + dir[1];\\n                                if(a>=0 && a<m && b>=0 && b<n)\\n                                    q.emplace(make_pair(a, b));\\n                            }\\n                        }\\n                            \\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 424555,
                "title": "java-o-mn-solution-bfs-and-dfs-with-easy-explanation",
                "content": "Three line explanation for interviews\\n\\n1) Intitate a count variable and Iterate over the matrix \\n\\t* \\tCount the island whenever we are encouterning \\'1\\' at any index.\\n\\t* \\tPerform BFS and DFS at the index to make all the neighboring elements from \\'1\\' --> \\'0\\' as they are part of same island. If the interviewer says we can not mutate the array then maintain a separate mX n visited array and mark all the BFS and DFS elements as visited.\\n2) For BFS maintain a queue and push index of encountered \\'1\\' in queue and subsequently keep adding all the neighbors with value \\'1\\' till queue becomes empty.\\n3) Return the count.\\n\\nTime Complexity: O(mn) in both BFS and DFS\\nSpace Complexity: O(mn) in BFS as we are maintianing a queue which in worst cases can have all the elements of matrix\\n\\nYou can follow me on https://twitter.com/Jaspind07199761 for DS and Algo tips\\nor connect on https://www.linkedin.com/in/jaspindersingh1/\\n\\n**BFS**\\n\\n```\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        if(grid == null || grid.length == 0) return 0;\\n        int count =0;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int [][] dirs = new int [][] {{0,1}, {1,0}, {-1,0}, {0,-1}};\\n        for(int i = 0; i <  m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == \\'1\\'){\\n                    count++;\\n                    Queue <int []> q = new LinkedList<>();\\n                    q.add(new int[] {i,j});\\n                    grid[i][j] = \\'0\\';\\n                    while(!q.isEmpty()){\\n                        int [] curr = q.poll();\\n                        for(int [] dir : dirs){\\n                            int r = curr[0] + dir[0];\\n                            int c = curr[1] + dir[1];\\n                            if(r >= 0 && r < m && c >= 0 && c < n && grid[r][c] == \\'1\\'){\\n                                 q.add(new int[] {r,c});\\n                                 grid[r][c] = \\'0\\';\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n\\n**DFS**\\n\\n```\\nclass Solution {\\n    private int m;\\n    private int n;\\n    public int numIslands(char[][] grid) {\\n        //edge case\\n        m = grid.length;\\n        if(grid == null || m == 0) return 0;\\n        n = grid[0].length;\\n        int count = 0;\\n \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == \\'1\\'){\\n                    count++;    \\n                    dfs(grid, i, j);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    private void dfs (char[][] grid, int i, int j){\\n        // base case\\n        if(i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == \\'0\\') return;\\n        int[][] dirs = new int [][] {{0,1},{1,0}, {-1,0},{0,-1}};\\n        grid[i][j] = \\'0\\';\\n        for(int[] dir: dirs){\\n            int r = i+dir[0];\\n            int c = j+dir[1];\\n             dfs(grid,r,c);\\n        }\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        if(grid == null || grid.length == 0) return 0;\\n        int count =0;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int [][] dirs = new int [][] {{0,1}, {1,0}, {-1,0}, {0,-1}};\\n        for(int i = 0; i <  m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == \\'1\\'){\\n                    count++;\\n                    Queue <int []> q = new LinkedList<>();\\n                    q.add(new int[] {i,j});\\n                    grid[i][j] = \\'0\\';\\n                    while(!q.isEmpty()){\\n                        int [] curr = q.poll();\\n                        for(int [] dir : dirs){\\n                            int r = curr[0] + dir[0];\\n                            int c = curr[1] + dir[1];\\n                            if(r >= 0 && r < m && c >= 0 && c < n && grid[r][c] == \\'1\\'){\\n                                 q.add(new int[] {r,c});\\n                                 grid[r][c] = \\'0\\';\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private int m;\\n    private int n;\\n    public int numIslands(char[][] grid) {\\n        //edge case\\n        m = grid.length;\\n        if(grid == null || m == 0) return 0;\\n        n = grid[0].length;\\n        int count = 0;\\n \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == \\'1\\'){\\n                    count++;    \\n                    dfs(grid, i, j);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    private void dfs (char[][] grid, int i, int j){\\n        // base case\\n        if(i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == \\'0\\') return;\\n        int[][] dirs = new int [][] {{0,1},{1,0}, {-1,0},{0,-1}};\\n        grid[i][j] = \\'0\\';\\n        for(int[] dir: dirs){\\n            int r = i+dir[0];\\n            int c = j+dir[1];\\n             dfs(grid,r,c);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 159799,
                "title": "python-solution",
                "content": "The problem can be solved with DFS. Time complexity: O(height * width), space complexity: O(height * width).\\n\\nDFS iterative:\\n```\\nclass Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        # DFS\\n        if len(grid) == 0:\\n            return 0\\n        count = 0\\n        visit = set()\\n        height = len(grid)\\n        width = len(grid[0])\\n        for i in range(height):\\n            for j in range(width):\\n                if grid[i][j] == \\'1\\' and (i,j) not in visit:\\n                    count += 1\\n                    stack = [(i,j)]\\n                    while stack:\\n                        u = stack.pop()\\n                        visit.add(u)\\n                        h, w = u[0], u[1]\\n                        if h > 0 and grid[h-1][w] == \\'1\\' and (h-1,w) not in visit:\\n                            stack.append((h-1,w))\\n                        if h < height - 1 and grid[h+1][w] == \\'1\\' and (h+1,w) not in visit:\\n                            stack.append((h+1,w))\\n                        if w > 0 and grid[h][w-1] == \\'1\\' and (h,w-1) not in visit:\\n                            stack.append((h,w-1))\\n                        if w < width - 1 and grid[h][w+1] == \\'1\\' and (h,w+1) not in visit:\\n                            stack.append((h,w+1))\\n        return count\\n```\\nDFS recursive:\\n```\\nclass Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        def dfs_visit(grid, u):\\n            i, j = u[0], u[1]\\n            visit.add((i,j))\\n            if i > 0 and grid[i-1][j] == \\'1\\' and (i-1,j) not in visit:\\n                dfs_visit(grid, (i-1,j))\\n            if i < height - 1 and grid[i+1][j] == \\'1\\' and (i+1,j) not in visit:\\n                dfs_visit(grid, (i+1,j))\\n            if j > 0 and grid[i][j-1] == \\'1\\' and (i,j-1) not in visit:\\n                dfs_visit(grid, (i,j-1))\\n            if j < width - 1 and grid[i][j+1] == \\'1\\' and (i,j+1) not in visit:\\n                dfs_visit(grid, (i,j+1))\\n        \\n        if len(grid) == 0:\\n            return 0\\n        count = 0\\n        visit = set()\\n        height = len(grid)\\n        width = len(grid[0])\\n        for i in range(height):\\n            for j in range(width):\\n                if grid[i][j] == \\'1\\' and (i,j) not in visit:\\n                    dfs_visit(grid,(i,j))\\n                    count += 1\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        # DFS\\n        if len(grid) == 0:\\n            return 0\\n        count = 0\\n        visit = set()\\n        height = len(grid)\\n        width = len(grid[0])\\n        for i in range(height):\\n            for j in range(width):\\n                if grid[i][j] == \\'1\\' and (i,j) not in visit:\\n                    count += 1\\n                    stack = [(i,j)]\\n                    while stack:\\n                        u = stack.pop()\\n                        visit.add(u)\\n                        h, w = u[0], u[1]\\n                        if h > 0 and grid[h-1][w] == \\'1\\' and (h-1,w) not in visit:\\n                            stack.append((h-1,w))\\n                        if h < height - 1 and grid[h+1][w] == \\'1\\' and (h+1,w) not in visit:\\n                            stack.append((h+1,w))\\n                        if w > 0 and grid[h][w-1] == \\'1\\' and (h,w-1) not in visit:\\n                            stack.append((h,w-1))\\n                        if w < width - 1 and grid[h][w+1] == \\'1\\' and (h,w+1) not in visit:\\n                            stack.append((h,w+1))\\n        return count\\n```\n```\\nclass Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        def dfs_visit(grid, u):\\n            i, j = u[0], u[1]\\n            visit.add((i,j))\\n            if i > 0 and grid[i-1][j] == \\'1\\' and (i-1,j) not in visit:\\n                dfs_visit(grid, (i-1,j))\\n            if i < height - 1 and grid[i+1][j] == \\'1\\' and (i+1,j) not in visit:\\n                dfs_visit(grid, (i+1,j))\\n            if j > 0 and grid[i][j-1] == \\'1\\' and (i,j-1) not in visit:\\n                dfs_visit(grid, (i,j-1))\\n            if j < width - 1 and grid[i][j+1] == \\'1\\' and (i,j+1) not in visit:\\n                dfs_visit(grid, (i,j+1))\\n        \\n        if len(grid) == 0:\\n            return 0\\n        count = 0\\n        visit = set()\\n        height = len(grid)\\n        width = len(grid[0])\\n        for i in range(height):\\n            for j in range(width):\\n                if grid[i][j] == \\'1\\' and (i,j) not in visit:\\n                    dfs_visit(grid,(i,j))\\n                    count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3388095,
                "title": "python-solution-beating-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nImagine grid as graph with edges from \"1\" cells to all adjaent (max 4) cells and DFS to find number of connected components = Ans \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* Iterate through the grid \\n* DFS for each cell with \"1\" and increament answer counter\\n* Mark cell \"0\" in dfs calls to mark them visited\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m*n) where m, n is size of grid\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) not using any space using same input grid to capture visited cells.\\n\\n# Code\\n```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n          \\n        if grid is None:\\n            return 0\\n\\n        m = len(grid)\\n\\n        if m == 0:\\n            return 0\\n        \\n        n = len(grid[0])\\n        if(n==0):\\n            return 0\\n        \\n        ans = 0\\n\\n        for i in range(m):\\n            for j in range(n):\\n\\n                if(grid[i][j]==\"1\"):\\n                    ans +=1\\n                    self.dfs(grid, i,j,m,n)\\n        \\n        return ans\\n    \\n    def dfs(self, g, i, j, m, n):\\n        if i<0 or j<0 or i>=m or j>=n or g[i][j] == \"0\":\\n            return\\n        \\n        g[i][j] = \"0\"\\n\\n        self.dfs(g,i-1,j,m,n)\\n        self.dfs(g,i+1,j,m,n)\\n        self.dfs(g,i,j-1,m,n)\\n        self.dfs(g,i,j+1,m,n)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n          \\n        if grid is None:\\n            return 0\\n\\n        m = len(grid)\\n\\n        if m == 0:\\n            return 0\\n        \\n        n = len(grid[0])\\n        if(n==0):\\n            return 0\\n        \\n        ans = 0\\n\\n        for i in range(m):\\n            for j in range(n):\\n\\n                if(grid[i][j]==\"1\"):\\n                    ans +=1\\n                    self.dfs(grid, i,j,m,n)\\n        \\n        return ans\\n    \\n    def dfs(self, g, i, j, m, n):\\n        if i<0 or j<0 or i>=m or j>=n or g[i][j] == \"0\":\\n            return\\n        \\n        g[i][j] = \"0\"\\n\\n        self.dfs(g,i-1,j,m,n)\\n        self.dfs(g,i+1,j,m,n)\\n        self.dfs(g,i,j-1,m,n)\\n        self.dfs(g,i,j+1,m,n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976172,
                "title": "dfs-bfs-and-easy-implementation-of-union-find-dsu-c",
                "content": "```\\nExplanations:\\nMethod 1: Our own and powerful DFS, we just go to every one, from there travel\\nto its every adjacent 1, and mark it as zero.\\nNow for one island one dfs will mark all of its adjacent 1s to zero. \\nAnother 1 comes, that means one more island or component to work with and we travel from that 1, \\nto all of its adjacent and mark it as zero.\\n\\nMethod 2: Basic BFS, We encounter a 1, we do bfs from that one to all its adjacent 1\\'s \\njust like we did in our DFS, the method is different, here we use a que, insert adjacent 1, and keep doing it.\\n\\nMethod 3: Union Find, Here we are only doing Path Compression and not Union, \\nwhich only hampers our time complexity by a constant but we do save space\\nbecause we didn\\'t take a size array nor did we make an extra class. \\nAnd more over this method is simpler to code in actual interview sense.\\nSo, what we did was first declare every element to be its own parent.\\nNow, we encounter our (name: hero)first one, its parent is him only,\\nthen we go to its adjacent elements and mark its parent as the \\nindex of our first one(remember, hero) only. \\nAfter we our done with this process, we just go and traverse all the elements which\\nare its own parent and in grid its value is \\'1\\'.\\nSimple, and codeable in an interview. \\nDo upvote. Thankyou.\\n```\\n```\\n//dfs\\nint n,m;\\n    void dfsNumIsland(vector<vector<char>>& grid, int i, int j, vector<vector<int>>& dir){\\n        grid[i][j] = \\'0\\';\\n        for(vector<int>& d: dir){\\n            int r = i + d[0], c = j + d[1];\\n            if(r >= 0 && c >= 0 && r < n && c < m && grid[r][c] == \\'1\\')\\n                dfsNumIsland(grid, r,c,dir);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        vector<vector<int>> dir = {{0,1},{0,-1},{1,0},{-1,0}};\\n        \\n        int component = 0;\\n        n = grid.size(), m = grid[0].size();\\n        \\n        for(int i=0; i<n;i++){\\n            for(int j=0; j< m; j++){\\n                if(grid[i][j] == \\'1\\'){\\n                  component++;\\n                  dfsNumIsland(grid,i,j, dir);\\n                }\\n            }\\n        }\\n        return component;\\n    }\\n```\\n```\\n//bfs\\nint numIslands(vector<vector<char>>& grid) {\\nint n = grid.size(), m = grid[0].size();\\n        int ans = 0;\\n        queue<int> kyu;\\n        vector<vector<int>> dir = {{1,0}, {0,1}, {0,-1}, {-1,0}};\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(grid[i][j] == \\'1\\'){\\n                    ans++;\\n                    kyu.push(i*m + j);\\n                    while(kyu.size() != 0){\\n                        int idx = kyu.front();\\n                        kyu.pop();\\n                        int a = idx/m, b = idx % m;\\n                        for(vector<int>& d: dir){\\n                            int r = a + d[0];\\n                            int c = b + d[1];\\n                            if(r >= 0 && c >= 0 && r < n && c < m && grid[r][c] == \\'1\\'){\\n                                kyu.push(r*m + c);\\n                                grid[r][c] = \\'0\\';\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n```\\n//union find\\nint findPar(int u, vector<int>& par){\\n        return par[u] == u ? u : (par[u] = findPar(par[u], par));\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        vector<vector<int>> dir = {{1,0},{-1,0},{0,1},{0,-1}};\\n        int m = grid[0].size(), n = grid.size();\\n        vector<int> par(n*m);\\n        for(int i = 0; i < n*m; i++) par[i] = i;\\n        \\n        int count = 0;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(grid[i][j] == \\'1\\'){\\n                    int p1 = findPar(i *m + j, par);\\n                    for(vector<int>& d : dir){\\n                        int r = i + d[0], c = j + d[1];\\n                        if(r >= 0 && c >= 0 && r < n && c < m && grid[r][c] == \\'1\\'){\\n                            int p2 = findPar(r*m + c, par);\\n                            if(p1 != p2) {\\n                                par[p2] = p1;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int idx = 0; idx < n*m; idx++){\\n            int i = idx/ m, j = idx%m;\\n            if(par[idx] == idx && grid[i][j] == \\'1\\') ans++; \\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nExplanations:\\nMethod 1: Our own and powerful DFS, we just go to every one, from there travel\\nto its every adjacent 1, and mark it as zero.\\nNow for one island one dfs will mark all of its adjacent 1s to zero. \\nAnother 1 comes, that means one more island or component to work with and we travel from that 1, \\nto all of its adjacent and mark it as zero.\\n\\nMethod 2: Basic BFS, We encounter a 1, we do bfs from that one to all its adjacent 1\\'s \\njust like we did in our DFS, the method is different, here we use a que, insert adjacent 1, and keep doing it.\\n\\nMethod 3: Union Find, Here we are only doing Path Compression and not Union, \\nwhich only hampers our time complexity by a constant but we do save space\\nbecause we didn\\'t take a size array nor did we make an extra class. \\nAnd more over this method is simpler to code in actual interview sense.\\nSo, what we did was first declare every element to be its own parent.\\nNow, we encounter our (name: hero)first one, its parent is him only,\\nthen we go to its adjacent elements and mark its parent as the \\nindex of our first one(remember, hero) only. \\nAfter we our done with this process, we just go and traverse all the elements which\\nare its own parent and in grid its value is \\'1\\'.\\nSimple, and codeable in an interview. \\nDo upvote. Thankyou.\\n```\n```\\n//dfs\\nint n,m;\\n    void dfsNumIsland(vector<vector<char>>& grid, int i, int j, vector<vector<int>>& dir){\\n        grid[i][j] = \\'0\\';\\n        for(vector<int>& d: dir){\\n            int r = i + d[0], c = j + d[1];\\n            if(r >= 0 && c >= 0 && r < n && c < m && grid[r][c] == \\'1\\')\\n                dfsNumIsland(grid, r,c,dir);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        vector<vector<int>> dir = {{0,1},{0,-1},{1,0},{-1,0}};\\n        \\n        int component = 0;\\n        n = grid.size(), m = grid[0].size();\\n        \\n        for(int i=0; i<n;i++){\\n            for(int j=0; j< m; j++){\\n                if(grid[i][j] == \\'1\\'){\\n                  component++;\\n                  dfsNumIsland(grid,i,j, dir);\\n                }\\n            }\\n        }\\n        return component;\\n    }\\n```\n```\\n//bfs\\nint numIslands(vector<vector<char>>& grid) {\\nint n = grid.size(), m = grid[0].size();\\n        int ans = 0;\\n        queue<int> kyu;\\n        vector<vector<int>> dir = {{1,0}, {0,1}, {0,-1}, {-1,0}};\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(grid[i][j] == \\'1\\'){\\n                    ans++;\\n                    kyu.push(i*m + j);\\n                    while(kyu.size() != 0){\\n                        int idx = kyu.front();\\n                        kyu.pop();\\n                        int a = idx/m, b = idx % m;\\n                        for(vector<int>& d: dir){\\n                            int r = a + d[0];\\n                            int c = b + d[1];\\n                            if(r >= 0 && c >= 0 && r < n && c < m && grid[r][c] == \\'1\\'){\\n                                kyu.push(r*m + c);\\n                                grid[r][c] = \\'0\\';\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```\\n//union find\\nint findPar(int u, vector<int>& par){\\n        return par[u] == u ? u : (par[u] = findPar(par[u], par));\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        vector<vector<int>> dir = {{1,0},{-1,0},{0,1},{0,-1}};\\n        int m = grid[0].size(), n = grid.size();\\n        vector<int> par(n*m);\\n        for(int i = 0; i < n*m; i++) par[i] = i;\\n        \\n        int count = 0;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(grid[i][j] == \\'1\\'){\\n                    int p1 = findPar(i *m + j, par);\\n                    for(vector<int>& d : dir){\\n                        int r = i + d[0], c = j + d[1];\\n                        if(r >= 0 && c >= 0 && r < n && c < m && grid[r][c] == \\'1\\'){\\n                            int p2 = findPar(r*m + c, par);\\n                            if(p1 != p2) {\\n                                par[p2] = p1;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int idx = 0; idx < n*m; idx++){\\n            int i = idx/ m, j = idx%m;\\n            if(par[idx] == idx && grid[i][j] == \\'1\\') ans++; \\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1245637,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int islands(int i, int j, vector<vector<char>> &grid)\\n    {\\n        if(i < 0 || i >= grid.size() || j < 0 || j >= grid[i].size())\\n            return 0;\\n        if(grid[i][j] == \\'1\\')\\n        {\\n            grid[i][j] = 0;    // markinng the current cell as visited by sinking the land\\n            int x = islands(i+1, j, grid);\\n            int y = islands(i-1, j, grid);\\n            int w = islands(i, j+1, grid);\\n            int z = islands(i, j-1, grid);\\n            if(1+x+y+z+w >= 1)              // if area of island is atleast connected by 1 cell then island exists\\n                return 1;\\n        }\\n        return 0;\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int count = 0;\\n        for(int i = 0; i < grid.size(); i++)\\n        {\\n            for(int j = 0; j < grid[0].size(); j++)\\n            {\\n                if(grid[i][j] == \\'1\\')\\n                    count += islands(i, j, grid);\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int islands(int i, int j, vector<vector<char>> &grid)\\n    {\\n        if(i < 0 || i >= grid.size() || j < 0 || j >= grid[i].size())\\n            return 0;\\n        if(grid[i][j] == \\'1\\')\\n        {\\n            grid[i][j] = 0;    // markinng the current cell as visited by sinking the land\\n            int x = islands(i+1, j, grid);\\n            int y = islands(i-1, j, grid);\\n            int w = islands(i, j+1, grid);\\n            int z = islands(i, j-1, grid);\\n            if(1+x+y+z+w >= 1)              // if area of island is atleast connected by 1 cell then island exists\\n                return 1;\\n        }\\n        return 0;\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int count = 0;\\n        for(int i = 0; i < grid.size(); i++)\\n        {\\n            for(int j = 0; j < grid[0].size(); j++)\\n            {\\n                if(grid[i][j] == \\'1\\')\\n                    count += islands(i, j, grid);\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746230,
                "title": "python-dfs-solution-without-modifying-input-data",
                "content": "```\\ndef numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        islands = 0\\n        visited = set()\\n        \\n        for row in range(len(grid)):\\n            for col in range(len(grid[0])):\\n                if grid[row][col] == \\'1\\' and (row, col) not in visited:\\n                    islands += 1\\n                    self.dfs(grid, row, col, visited)\\n        return islands\\n    \\n    def dfs(self, grid, row, col, visited):\\n        if (row >= 0 and row < len(grid) and col >= 0 and col < len(grid[0])\\n            and (row, col) not in visited and grid[row][col] == \\'1\\'):\\n            visited.add((row, col))\\n            self.dfs(grid, row + 1, col, visited)\\n            self.dfs(grid, row - 1, col, visited)\\n            self.dfs(grid, row, col + 1, visited)\\n            self.dfs(grid, row, col - 1, visited)\\n```\\nMany of the solutions from other users (and the official solution) involve updating elements in the grid to \\'0\\' to mark them as \"visited\".\\n\\nIn practice, this is a poor choice, as it  modifies the input data as a side-effect of the solution.\\n\\nUnless you have been explicitly told to modify some input \"in-place\", you should avoid this.\\n\\nIn my solution I chose to use a Set of tuples of (row, col) to keep track of each element I\\'ve already visited.\\n\\nYou might be asking: \"Doesn\\'t this add to the overall memory usage of the solution?\"\\n\\nAnd the answer would be \"yes\", however it does not increase the space *complexity* of the solution.\\n\\nSince we\\'re doing a DFS to mark each \"island\", we already have a space complexity of O(M x N); in the *worst-case* our DFS will visit every element in the grid and thus make M x N recursive calls.\\n\\nAdding on an additional M x N space by tracking the \"visited\" elements in a Set (you could also use an additional 2D list/array), does not increase the space *complexity*. This is because when we assess the \"Big O\" space of a solution, we drop constant terms. \\n\\nA solution that is O(2 x M x N) is still considered O(M x N).",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\ndef numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        islands = 0\\n        visited = set()\\n        \\n        for row in range(len(grid)):\\n            for col in range(len(grid[0])):\\n                if grid[row][col] == \\'1\\' and (row, col) not in visited:\\n                    islands += 1\\n                    self.dfs(grid, row, col, visited)\\n        return islands\\n    \\n    def dfs(self, grid, row, col, visited):\\n        if (row >= 0 and row < len(grid) and col >= 0 and col < len(grid[0])\\n            and (row, col) not in visited and grid[row][col] == \\'1\\'):\\n            visited.add((row, col))\\n            self.dfs(grid, row + 1, col, visited)\\n            self.dfs(grid, row - 1, col, visited)\\n            self.dfs(grid, row, col + 1, visited)\\n            self.dfs(grid, row, col - 1, visited)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 706851,
                "title": "c-beats-94",
                "content": "C# solution beating 94% of csharp submissions, please let me know if you have any questions of can suggest code improvements for this solution to optimize! Thanks!\\n\\n```\\npublic class Solution {\\n    public int NumIslands(char[][] grid) {\\n        \\n        if (grid == null || grid.Length == 0) \\n        {\\n            return 0;\\n        }\\n        \\n        int numberOfIslands = 0;\\n        \\n        for (int i = 0; i < grid.GetLength(0); i++)\\n        {\\n            for (int j = 0; j < grid[i].Length; j++)\\n            {\\n                char v = grid[i][j];\\n                if (v == \\'1\\')\\n                {\\n                    numberOfIslands += sink(grid, i, j);\\n                }\\n            } \\n        }\\n        \\n        return numberOfIslands;\\n    }\\n    \\n    public int sink(char[][] grid, int i, int j)\\n    {\\n        if(i < 0 || i >= grid.Length || j < 0 || j >= grid[0].Length || grid[i][j] == \\'0\\')\\n        {\\n            return 0;\\n        }\\n        \\n        grid[i][j] = \\'0\\';\\n        sink(grid, i, j + 1);\\n        sink(grid, i, j - 1);\\n        sink(grid, i + 1, j);\\n        sink(grid, i - 1, j);\\n        return 1;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/7bedd007-f1a3-4819-8836-1e30d32660cf_1593202040.5866594.png)\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumIslands(char[][] grid) {\\n        \\n        if (grid == null || grid.Length == 0) \\n        {\\n            return 0;\\n        }\\n        \\n        int numberOfIslands = 0;\\n        \\n        for (int i = 0; i < grid.GetLength(0); i++)\\n        {\\n            for (int j = 0; j < grid[i].Length; j++)\\n            {\\n                char v = grid[i][j];\\n                if (v == \\'1\\')\\n                {\\n                    numberOfIslands += sink(grid, i, j);\\n                }\\n            } \\n        }\\n        \\n        return numberOfIslands;\\n    }\\n    \\n    public int sink(char[][] grid, int i, int j)\\n    {\\n        if(i < 0 || i >= grid.Length || j < 0 || j >= grid[0].Length || grid[i][j] == \\'0\\')\\n        {\\n            return 0;\\n        }\\n        \\n        grid[i][j] = \\'0\\';\\n        sink(grid, i, j + 1);\\n        sink(grid, i, j - 1);\\n        sink(grid, i + 1, j);\\n        sink(grid, i - 1, j);\\n        return 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 583546,
                "title": "python-counting-islands-with-dfs",
                "content": "The idea is to go through every cell of the grid and whenever you step on the cell with \\'1\\', you increment your island count and you do depth first search in four directions (r-1, c) (r+1, c) (r, c-1) (r, c+1) where r and c are current row and column indices.\\n\\nWhen you are doing depth first search, you flip every \\'1\\' to \\'0\\'.\\n\\nThe depth first search essentially finds all the connected islands (the ones which are connected to the original cell which starts the whole DFS chain), and flips them to zero. By doing so, you will just skip these cells with \\'0\\' when you are back to normally going through every cell.\\n\\nThis DFS will make sure every connected islands to the original cell is all flipped to zero while leaving non-connected cells as they were.\\n\\nNow, when you are normally going through every cell and if you step on \\'0\\', you just ignore it and go to the next cell.\\n\\n```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        if len(grid) < 1:\\n            return 0\\n        \\n        def dfs(r, c):            \\n            if r<0 or c<0 or r>rows-1 or c>cols-1 or grid[r][c]==\\'0\\': # Check whether we have reached beyond the edge of the grid or the current cell is \\'0\\'. If so, terminate the recursion stack.\\n                return       \\n            grid[r][c] = \\'0\\'     # Flips all the connected islands to \\'0\\'s\\n            \\n\\t\\t\\t# DFS in all four directions\\n            dfs(r-1, c)\\n            dfs(r+1, c)\\n            dfs(r, c-1)\\n            dfs(r, c+1)\\n                    \\n        rows = len(grid)\\n        cols = len(grid[0])\\n        num_islands = 0\\n        \\n        for r in range(rows):\\n            for c in range(cols):\\n                cell = grid[r][c]\\n                \\n                if cell == \\'0\\':\\n                    continue\\n                \\n                if cell == \\'1\\':\\n                    num_islands += 1\\n                    dfs(r, c)\\n                                  \\n        return num_islands\\n                    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        if len(grid) < 1:\\n            return 0\\n        \\n        def dfs(r, c):            \\n            if r<0 or c<0 or r>rows-1 or c>cols-1 or grid[r][c]==\\'0\\': # Check whether we have reached beyond the edge of the grid or the current cell is \\'0\\'. If so, terminate the recursion stack.\\n                return       \\n            grid[r][c] = \\'0\\'     # Flips all the connected islands to \\'0\\'s\\n            \\n\\t\\t\\t# DFS in all four directions\\n            dfs(r-1, c)\\n            dfs(r+1, c)\\n            dfs(r, c-1)\\n            dfs(r, c+1)\\n                    \\n        rows = len(grid)\\n        cols = len(grid[0])\\n        num_islands = 0\\n        \\n        for r in range(rows):\\n            for c in range(cols):\\n                cell = grid[r][c]\\n                \\n                if cell == \\'0\\':\\n                    continue\\n                \\n                if cell == \\'1\\':\\n                    num_islands += 1\\n                    dfs(r, c)\\n                                  \\n        return num_islands\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 423731,
                "title": "javascript-recursive-and-iterative-solutions",
                "content": "```\\nconst removeIslandIterative = (grid, x, y) => {\\n    let stack = []\\n    stack.push({x,y})\\n    while (stack.length > 0) {\\n        const {x, y} = stack.pop()\\n        grid[x][y] = \"0\"\\n        addIfValidCoordinate(stack,grid,x+1,y)\\n        addIfValidCoordinate(stack,grid,x-1,y)\\n        addIfValidCoordinate(stack,grid,x,y+1)\\n        addIfValidCoordinate(stack,grid,x,y-1)\\n    }\\n}\\n\\nconst addIfValidCoordinate = (stack, grid, x, y) => {\\n    if (x < 0 || y < 0 || x >= grid.length || y >= grid[x].length || grid[x][y] === \"0\") return\\n    stack.push({x,y})\\n}\\n\\nconst removeIslandRecursive = (grid, x, y) => {\\n    if (x < 0 || y < 0 || x >= grid.length  || y >= grid[x].length || grid[x][y] === \"0\") {\\n        return\\n    }\\n    grid[x][y] = \"0\"\\n    removeIslandRecursive(grid,x+1,y)\\n    removeIslandRecursive(grid,x-1,y)\\n    removeIslandRecursive(grid,x,y+1)\\n    removeIslandRecursive(grid,x,y-1)\\n}\\n\\nconst numIslands = (grid) => {\\n    let numOfIslands = 0\\n    grid.map((r,x) => {\\n        r.map((c,y) => {\\n            if (grid[x][y] === \"1\") {\\n                numOfIslands++   \\n                removeIslandRecursive(grid, x, y)\\n\\t\\t\\t\\t// removeIslandIterative(grid, x, y)\\n            }\\n        })\\n    })\\n    return numOfIslands\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst removeIslandIterative = (grid, x, y) => {\\n    let stack = []\\n    stack.push({x,y})\\n    while (stack.length > 0) {\\n        const {x, y} = stack.pop()\\n        grid[x][y] = \"0\"\\n        addIfValidCoordinate(stack,grid,x+1,y)\\n        addIfValidCoordinate(stack,grid,x-1,y)\\n        addIfValidCoordinate(stack,grid,x,y+1)\\n        addIfValidCoordinate(stack,grid,x,y-1)\\n    }\\n}\\n\\nconst addIfValidCoordinate = (stack, grid, x, y) => {\\n    if (x < 0 || y < 0 || x >= grid.length || y >= grid[x].length || grid[x][y] === \"0\") return\\n    stack.push({x,y})\\n}\\n\\nconst removeIslandRecursive = (grid, x, y) => {\\n    if (x < 0 || y < 0 || x >= grid.length  || y >= grid[x].length || grid[x][y] === \"0\") {\\n        return\\n    }\\n    grid[x][y] = \"0\"\\n    removeIslandRecursive(grid,x+1,y)\\n    removeIslandRecursive(grid,x-1,y)\\n    removeIslandRecursive(grid,x,y+1)\\n    removeIslandRecursive(grid,x,y-1)\\n}\\n\\nconst numIslands = (grid) => {\\n    let numOfIslands = 0\\n    grid.map((r,x) => {\\n        r.map((c,y) => {\\n            if (grid[x][y] === \"1\") {\\n                numOfIslands++   \\n                removeIslandRecursive(grid, x, y)\\n\\t\\t\\t\\t// removeIslandIterative(grid, x, y)\\n            }\\n        })\\n    })\\n    return numOfIslands\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 56606,
                "title": "my-c-solution-using-union-find-set",
                "content": "    class Solution {\\n    public:\\n        int total;\\n        int getparent(vector<int>& parent,int a){\\n            if(parent[a] != a)\\n                parent[a] = getparent(parent,parent[a]);\\n            return parent[a];\\n        }\\n        void merge(vector<int>& parent,int a,int b){\\n            int p1 = getparent(parent,a);\\n            int p2 = getparent(parent,b);\\n            if(p1 == p2)  return;\\n            parent[p2] = p1;\\n            --total; \\n        }\\n        int numIslands(vector<vector<char>>& grid) {\\n            if(grid.size() == 0 || grid[0].size() == 0) return 0;\\n            int M = grid.size();\\n            int N = grid[0].size();\\n            vector<int> parent(M*N);\\n            total = M*N;\\n            for(int i=0;i<M;++i)\\n                for(int j=0;j<N;++j){\\n                    int index = i*N+j;\\n                    parent[index] = index;\\n                    if(grid[i][j] == '0') --total;\\n                    else{\\n                        if(i>0 && grid[i-1][j] == '1')\\n                            merge(parent,index,(i-1)*N + j);\\n                        if(j>0 && grid[i][j-1] == '1')\\n                            merge(parent,index,index-1);\\n                    }\\n                }\\n            return total;\\n        }\\n    };",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "class Solution {\\n    public:\\n        int total;\\n        int getparent(vector<int>& parent,int a){\\n            if(parent[a] != a)\\n                parent[a] = getparent(parent,parent[a]);\\n            return parent[a];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3811433,
                "title": "java-super-simple-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI went with brut force approach. See question asks about number of island where an island is number of adjacent one\\'s surrounded by zero\\'s.\\nMeans if you start from a source vertex and traverse all the one\\'s which are adjacent to it from source one\\'s are considered to be an island and we need to find such island.\\nHere i have used dfs you can either use bfs\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1: create a visited matrix equal to size of the grid given and plaxe 0 in all the places of visited matrix\\n2: take a count variable to take a count of number of island\\n3: Start a for loop from 1st element in grid and check if that element is 0 in visited and 1 in grid means we have a land which is unvisted till now\\n4: increase the count by 1 as you found 1st island\\n5: run a dfs (the code of dfs is as usual) on that node and find all the node\\'s which you can visit from the current node and mark them 1\\n6: as soon as dfs will over you will get the region of 1st island\\n7: you will move forward to the next element in your for loop untill you check all the elements and repeat the above 6 steps.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N*M)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N*M)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/8013a055-21ad-4622-b01c-3646e4f937cf_1690227303.9957466.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        int visited[][] = new int[n][m]; // Create a 2D array to keep track of visited cells\\n\\n        // Initialize all cells of the \\'visited\\' array to 0 (not visited)\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                visited[i][j] = 0;\\n            }\\n        }\\n\\n        int count = 0; // Variable to keep track of the number of islands\\n\\n        // Traverse the grid and perform DFS to find the islands\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n\\n                if(visited[i][j] == 0 && grid[i][j] == \\'1\\'){\\n                    count++;\\n                    dfs(grid,i, j, visited);\\n                }\\n            }\\n        }\\n        return count; // Return the total count of islands\\n    }\\n\\n    // Depth First Search (DFS) function to explore the island starting from a given cell\\n    private void dfs(char grid[][], int row, int col, int visited[][]){\\n\\n        visited[row][col] = 1; // Mark the current cell as visited\\n\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        int delrow[] = {-1, 0, 1, 0}; // Array to represent possible row moves (up, right, down, left)\\n        int delcol[] = {0, 1, 0, -1}; // Array to represent possible column moves (up, right, down, left)\\n\\n        // Explore the adjacent cells (up, right, down, left) in a depth-first manner\\n        for(int i = 0; i < 4; i++){\\n\\n            int nrow = row + delrow[i];\\n            int ncol = col + delcol[i];\\n\\n            // Check if the adjacent cell is within the grid boundaries, not visited, and contains \\'1\\' (part of the island)\\n            if(nrow >= 0  && nrow < n && ncol >= 0 && ncol < m\\n                && visited[nrow][ncol] == 0 && grid[nrow][ncol] == \\'1\\')\\n                {\\n                    // Recursively call DFS on the adjacent cell\\n                    dfs(grid, nrow, ncol, visited);\\n                } \\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        int visited[][] = new int[n][m]; // Create a 2D array to keep track of visited cells\\n\\n        // Initialize all cells of the \\'visited\\' array to 0 (not visited)\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                visited[i][j] = 0;\\n            }\\n        }\\n\\n        int count = 0; // Variable to keep track of the number of islands\\n\\n        // Traverse the grid and perform DFS to find the islands\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n\\n                if(visited[i][j] == 0 && grid[i][j] == \\'1\\'){\\n                    count++;\\n                    dfs(grid,i, j, visited);\\n                }\\n            }\\n        }\\n        return count; // Return the total count of islands\\n    }\\n\\n    // Depth First Search (DFS) function to explore the island starting from a given cell\\n    private void dfs(char grid[][], int row, int col, int visited[][]){\\n\\n        visited[row][col] = 1; // Mark the current cell as visited\\n\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        int delrow[] = {-1, 0, 1, 0}; // Array to represent possible row moves (up, right, down, left)\\n        int delcol[] = {0, 1, 0, -1}; // Array to represent possible column moves (up, right, down, left)\\n\\n        // Explore the adjacent cells (up, right, down, left) in a depth-first manner\\n        for(int i = 0; i < 4; i++){\\n\\n            int nrow = row + delrow[i];\\n            int ncol = col + delcol[i];\\n\\n            // Check if the adjacent cell is within the grid boundaries, not visited, and contains \\'1\\' (part of the island)\\n            if(nrow >= 0  && nrow < n && ncol >= 0 && ncol < m\\n                && visited[nrow][ncol] == 0 && grid[nrow][ncol] == \\'1\\')\\n                {\\n                    // Recursively call DFS on the adjacent cell\\n                    dfs(grid, nrow, ncol, visited);\\n                } \\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498081,
                "title": "c-dfs-very-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int res=0;\\n        for(int i=0;i<grid.size();i++)\\n            for(int j=0;j<grid[i].size();j++)\\n                if(grid[i][j]==\\'1\\')// if 1, call the dfs and make res++ to add this island \\n                {\\n                    dfs(grid,i,j);\\n                    res++;\\n                }\\n        return res;\\n    }\\n    void dfs(vector<vector<char>>& v,int i,int j)\\n    {\\n        if(i<0 || j<0 || i>=v.size() || j>=v[0].size() || v[i][j]==\\'0\\')\\n            return;\\n        \\n        v[i][j]=\\'0\\';// reset to 0 as this is already included\\n        dfs(v,i-1,j);\\n        dfs(v,i+1,j);\\n        dfs(v,i,j-1);\\n        dfs(v,i,j+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int res=0;\\n        for(int i=0;i<grid.size();i++)\\n            for(int j=0;j<grid[i].size();j++)\\n                if(grid[i][j]==\\'1\\')// if 1, call the dfs and make res++ to add this island \\n                {\\n                    dfs(grid,i,j);\\n                    res++;\\n                }\\n        return res;\\n    }\\n    void dfs(vector<vector<char>>& v,int i,int j)\\n    {\\n        if(i<0 || j<0 || i>=v.size() || j>=v[0].size() || v[i][j]==\\'0\\')\\n            return;\\n        \\n        v[i][j]=\\'0\\';// reset to 0 as this is already included\\n        dfs(v,i-1,j);\\n        dfs(v,i+1,j);\\n        dfs(v,i,j-1);\\n        dfs(v,i,j+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2268293,
                "title": "number-of-islands-detailed-explanation",
                "content": "**PROBLEM STATEMENT**\\n//this problem is similar to that of number of components in an undirected graph.\\n//our task is to return number of connected components (which are islands indirectly in this problem)\\n//The islands are denoted with \\'1\\' and water with \\'0\\'.\\n**APPROACH**\\n-> we will use a seperate function which will perform DFS traversal \\n->  we will mark the visited vertex as \\'0\\' (can mark it as any other number also)\\n-> In our main function , we will traverse every row and every column and check if it is not visited \\n->if it is not visited then we will perform the traversal and increment the count \\'n\\' which will store no of times the DFS traversal is performed \\n-> no of times DFS performed = no of islands (connected components)\\n\\n**CODE**\\n```\\nint numIslands(vector<vector<char>>& grid) {\\n        //to check \\n        int n = 0;//islands count\\n        for(int i=0;i< grid.size();i++){\\n            for(int j=0;j< grid[0].size();j++){\\n                //performing DFS if its not visited\\n                if(grid[i][j]==\\'1\\'){\\n                    n++;\\n                    DFS(i,j,grid);\\n                }\\n            }\\n        }\\n        return n;\\n    }\\n    void DFS(int r,int c,vector<vector<char>>& grid){\\n        //preventing crossing boundaries by checking\\n        if(r<0 || r>=grid.size() || c<0 || c>=grid[0].size()){\\n            return;\\n        }\\n        //returning if the cuRrent position is already visited\\n        if(grid[r][c]==\\'0\\'){\\n            return;\\n        }\\n        //marking the unvisited vertex as visited by marking it as 0\\n        grid[r][c] = \\'0\\';\\n        //moving in all 4 directions and visiting them recursively\\n        DFS(r+1,c,grid);\\n        DFS(r,c-1,grid);\\n        DFS(r-1,c,grid);\\n        DFS(r,c+1,grid);\\n    }\\n    \\n```\\n*Hope it is clear. Thanks for reading it. Do upvote if it is useful :-)*\\n-----------------------------------HAPPY LEARNING--------------------------------------------",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nint numIslands(vector<vector<char>>& grid) {\\n        //to check \\n        int n = 0;//islands count\\n        for(int i=0;i< grid.size();i++){\\n            for(int j=0;j< grid[0].size();j++){\\n                //performing DFS if its not visited\\n                if(grid[i][j]==\\'1\\'){\\n                    n++;\\n                    DFS(i,j,grid);\\n                }\\n            }\\n        }\\n        return n;\\n    }\\n    void DFS(int r,int c,vector<vector<char>>& grid){\\n        //preventing crossing boundaries by checking\\n        if(r<0 || r>=grid.size() || c<0 || c>=grid[0].size()){\\n            return;\\n        }\\n        //returning if the cuRrent position is already visited\\n        if(grid[r][c]==\\'0\\'){\\n            return;\\n        }\\n        //marking the unvisited vertex as visited by marking it as 0\\n        grid[r][c] = \\'0\\';\\n        //moving in all 4 directions and visiting them recursively\\n        DFS(r+1,c,grid);\\n        DFS(r,c-1,grid);\\n        DFS(r-1,c,grid);\\n        DFS(r,c+1,grid);\\n    }\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 583531,
                "title": "easy-python3-dfs-solution-using-set-with-comments-o-n-runtime-o-n-space",
                "content": "```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        land = set()\\n        \\n        #Put all pieces of land in a set\\n        for row in range(len(grid)):\\n            for column in range(len(grid[0])):\\n                if grid[row][column] == \"1\":\\n                    land.add((row, column))\\n        islands = 0\\n        \\n        #If the piece of land is still in the\\n        #set we have not explored it yet. If\\n        #a piece of land we try to explore is\\n        #not in the set, we have already explored\\n        #it so we do nothing or it is water.\\n        def explore(r, c):\\n            if (r,c) in land:\\n                land.remove((r,c))\\n                explore(r, c+1)\\n                explore(r, c-1)\\n                explore(r+1, c)\\n                explore(r-1, c)            \\n            \\n        while land:\\n            #We want to get any piece of land\\n            #still in the set, but we don\\'t want\\n            #to remove it yet. We do that in the\\n            #explore function.\\n            piece = land.pop()\\n            land.add(piece)\\n            \\n            #Explore adjacent pieces of land:\\n            explore(piece[0], piece[1])\\n            islands += 1\\n        \\n        return islands\\n                \\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        land = set()\\n        \\n        #Put all pieces of land in a set\\n        for row in range(len(grid)):\\n            for column in range(len(grid[0])):\\n                if grid[row][column] == \"1\":\\n                    land.add((row, column))\\n        islands = 0\\n        \\n        #If the piece of land is still in the\\n        #set we have not explored it yet. If\\n        #a piece of land we try to explore is\\n        #not in the set, we have already explored\\n        #it so we do nothing or it is water.\\n        def explore(r, c):\\n            if (r,c) in land:\\n                land.remove((r,c))\\n                explore(r, c+1)\\n                explore(r, c-1)\\n                explore(r+1, c)\\n                explore(r-1, c)            \\n            \\n        while land:\\n            #We want to get any piece of land\\n            #still in the set, but we don\\'t want\\n            #to remove it yet. We do that in the\\n            #explore function.\\n            piece = land.pop()\\n            land.add(piece)\\n            \\n            #Explore adjacent pieces of land:\\n            explore(piece[0], piece[1])\\n            islands += 1\\n        \\n        return islands\\n                \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 56569,
                "title": "8ms-c-solution-using-union-find-with-a-dummy-point",
                "content": "My idea comes from the solution of [Surrounded Regions](https://leetcode.com/discuss/6285/solve-it-using-union-find).\\n\\nIt's obvious to connect adjacent 1s. Then how to handle 0s?\\n\\nAn interesting finding is that if we connect all 0s, then the count of UF is equal to the number of islands plus 1.\\n\\n\\n    class UF {\\n    public:\\n    \\tUF(int N) {\\n    \\t\\tcount = N;\\n    \\t\\tid = new int[N];\\n    \\t\\tweight = new int[N];\\n    \\t\\tfor (int i = 0; i < N; i++) {\\n    \\t\\t\\tid[i] = i;\\n    \\t\\t\\tweight[i] = 0;\\n    \\t\\t}\\n    \\t}\\n    \\t~UF() {\\n    \\t\\tdelete[]id;\\n    \\t\\tdelete[]weight;\\n    \\t}\\n    \\tvoid unionP(int p, int q) {\\n    \\t\\tint i = root(p);\\n    \\t\\tint j = root(q);\\n    \\t\\tif (i == j) {\\n    \\t\\t\\treturn;\\n    \\t\\t}\\n    \\t\\tif (weight[i] < weight[j]) {\\n    \\t\\t\\tid[i] = j;\\n    \\t\\t}\\n    \\t\\telse if (weight[i] > weight[j]) {\\n    \\t\\t\\tid[j] = i;\\n    \\t\\t}\\n    \\t\\telse {\\n    \\t\\t\\tid[i] = j;\\n    \\t\\t\\tweight[j]++;\\n    \\t\\t}\\n    \\t\\tcount--;\\n    \\t}\\n    \\tbool connected(int p, int q) {\\n    \\t\\treturn root(p) == root(q);\\n    \\t}\\n    \\tint getCount() {\\n    \\t\\treturn count;\\n    \\t}\\n    private:\\n    \\tint *id;\\n    \\tint *weight;\\n    \\tint count;\\n    \\tint root(int i) {\\n    \\t\\twhile (i != id[i]) {\\n    \\t\\t\\tid[i] = id[id[i]];\\n    \\t\\t\\ti = id[i];\\n    \\t\\t}\\n    \\t\\treturn i;\\n    \\t}\\n    };\\n    \\n    class Solution {\\n    public:\\n    \\t// Runtime: 8 ms\\n    \\tint numIslands(vector<vector<char>>& grid) {\\n    \\t\\tif (grid.empty() || grid[0].empty()) {\\n    \\t\\t\\treturn 0;\\n    \\t\\t}\\n    \\t\\tint ROW = grid.size(), COL = grid[0].size();\\n    \\t\\tUF uf(ROW * COL + 1);\\n    \\t\\tint dummyPoint = ROW * COL; // We assume it as 0 and it connects all 0s.\\n    \\t\\tfor (int i = 0; i < ROW; i++) {\\n    \\t\\t\\tfor (int j = 0; j < COL; j++) {\\n    \\t\\t\\t\\tif (grid[i][j] == '1') {\\n    \\t\\t\\t\\t\\tif (j != COL - 1 && grid[i][j + 1] == '1') {\\n    \\t\\t\\t\\t\\t\\tuf.unionP(i * COL + j, i * COL + j + 1);\\n    \\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t\\tif (i != ROW - 1 && grid[i + 1][j] == '1') {\\n    \\t\\t\\t\\t\\t\\tuf.unionP(i * COL + j, (i + 1) * COL + j);\\n    \\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\telse {\\n    \\t\\t\\t\\t\\tuf.unionP(i * COL + j, dummyPoint);\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn uf.getCount() - 1;\\n    \\t}\\n    };",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "class Solution {\\n    public:\\n    \\t// Runtime: 8 ms\\n    \\tint numIslands(vector<vector<char>>& grid) {\\n    \\t\\tif (grid.empty() || grid[0].empty()) {\\n    \\t\\t\\treturn 0;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 56639,
                "title": "4ms-c-dfs-solution-reusing-grid-to-memoize-visited-squares",
                "content": "    bool visit(char **grid, int numRows, int numColumns, int x, int y) \\n    {\\n        if ( x <0 || y < 0 || x >= numColumns || y >= numRows || grid[y][x] != '1')\\n            return false;\\n        \\n        grid[y][x] = 'v'; //visited\\n        \\n        visit(grid, numRows, numColumns, x + 1, y);\\n        visit(grid, numRows, numColumns, x - 1, y);\\n        visit(grid, numRows, numColumns, x, y + 1);\\n        visit(grid, numRows, numColumns, x, y -1);\\n        \\n        return true;\\n    }\\n    \\n    int numIslands(char **grid, int numRows, int numColumns) \\n    {\\n        int total = 0;\\n        for (int y=0; y < numRows; y++)\\n            for (int x=0; x < numColumns; x++)\\n                total += visit(grid, numRows, numColumns, x, y) ? 1 : 0;\\n            \\n        return total;\\n    }",
                "solutionTags": [],
                "code": "    bool visit(char **grid, int numRows, int numColumns, int x, int y) \\n    {\\n        if ( x <0 || y < 0 || x >= numColumns || y >= numRows || grid[y][x] != '1')\\n            return false;\\n        \\n        grid[y][x] = 'v'; //visited\\n        \\n        visit(grid, numRows, numColumns, x + 1, y);\\n        visit(grid, numRows, numColumns, x - 1, y);\\n        visit(grid, numRows, numColumns, x, y + 1);\\n        visit(grid, numRows, numColumns, x, y -1);\\n        \\n        return true;\\n    }\\n    \\n    int numIslands(char **grid, int numRows, int numColumns) \\n    {\\n        int total = 0;\\n        for (int y=0; y < numRows; y++)\\n            for (int x=0; x < numColumns; x++)\\n                total += visit(grid, numRows, numColumns, x, y) ? 1 : 0;\\n            \\n        return total;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3081804,
                "title": "one-of-the-best-explanation-animated",
                "content": "https://youtu.be/VvLlyZi-T6g",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3012829,
                "title": "js-very-easy-and-very-fast-solution-with-dfs",
                "content": "# Code\\n```\\n/**\\n * @param {character[][]} grid\\n * @return {number}\\n */\\nconst CONFIG = [[0, -1], [1, 0], [0, 1], [-1, 0]];\\nvar numIslands = function(grid) {\\n    let output = 0;\\n\\n    const checkIsInValid = (row, col) => row < 0 || row >= grid.length || col < 0 || col >= grid[0].length;\\n\\n    const dfs = (row, col, grid,) => {\\n        if (checkIsInValid(row, col) || grid[row][col] === \\'0\\') return;\\n\\n        grid[row][col] = \"0\";\\n\\n        for (const item of CONFIG) {\\n            dfs(row + item[0], col + item[1], grid);\\n        }\\n    }\\n\\n    for (let i = 0 ; i < grid.length; i++) {\\n        for (let j = 0 ; j < grid[0].length; j++) {\\n            if (grid[i][j] === \"1\") {\\n                output++;\\n                dfs(i, j, grid);\\n            }\\n        }\\n    }\\n\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {character[][]} grid\\n * @return {number}\\n */\\nconst CONFIG = [[0, -1], [1, 0], [0, 1], [-1, 0]];\\nvar numIslands = function(grid) {\\n    let output = 0;\\n\\n    const checkIsInValid = (row, col) => row < 0 || row >= grid.length || col < 0 || col >= grid[0].length;\\n\\n    const dfs = (row, col, grid,) => {\\n        if (checkIsInValid(row, col) || grid[row][col] === \\'0\\') return;\\n\\n        grid[row][col] = \"0\";\\n\\n        for (const item of CONFIG) {\\n            dfs(row + item[0], col + item[1], grid);\\n        }\\n    }\\n\\n    for (let i = 0 ; i < grid.length; i++) {\\n        for (let j = 0 ; j < grid[0].length; j++) {\\n            if (grid[i][j] === \"1\") {\\n                output++;\\n                dfs(i, j, grid);\\n            }\\n        }\\n    }\\n\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2711272,
                "title": "c-detailed-approach-using-graph-dfs-and-bfs-approach-and-code",
                "content": "# Approach to the problem\\nIn a very naive mentality, all you have to do is to find one piece of land and thereafter see all the lands which are present in any of the 4 directions (North, South, East, West) corresponding to the land you are at. Once you are at a piece of land, you mark it as _Discovered_ and thereafter look in the directions, ultimately marking them as _Discovered_ too.\\n\\nOn further exploration, you don\\'t explore any further when a particular piece of land is marked as _Discovered_. Rather, you look for lands which are still _Undiscovered_ and start your exploration from that point, performing the same set of operations as mentioned above. \\n\\nSince you are not exploring lands repeatedly (By marking lands as _Discovered_), the total number of islands in the area is equal to the number of times you find a land which is _Undiscovered_. \\n\\nSeems tough? Naah it ain\\'t.\\nGo through the steps below and you would find this as a piece of cake.\\n\\n# Procedure.\\n* First, we create an array called `visited` which marks whether a land is either _Discovered_ or _Undiscovered_.\\n\\t* Elements which are discovered are marked as `1` and the non-discovered are by default marked as `0`\\n`vector<vector<int>> visited (rows , vector<int> (cols , 0));`\\n\\n*  We iterate throughout the 2D Array and find the first piece of land which is _Undiscovered_ \\n\\t* Note that an undiscovered land is a land which is not visited before\\n`!visited[row][col] && grid[row][col] == \\'1\\'`\\n\\n* Once we find a piece of land which is _Undiscovered_, we start looking for surrounding lands and keep marking them as discovered as well. \\n\\t* By doing so, we would _Discover_ the whole island.\\n\\t* Since we start our exploration when the land is marked as _Undiscovered_, our next search will start when we discover the next island. Hence we can say once we reach at a piece of land, we have discovered an island.\\n\\t* Hence, we create a variable which stores the number of islands and increment it once we find a piece of _Undiscovered_ land. \\n\\t* In Graph Theory, we can use either **DFS (Depth first search) or BFS (Breadth First Search)** to _Discover_ the whole island. The explanations for both are given below:\\n\\n## Breadth First Search\\n* The breadth first approach is an approach which traverses the graph breadth wise. In other words, the lands are _Discovered_ layer by layer.\\n* For this, we use a **Queue** Data Structure to store the next cordinates of land which are surrounded by the piecec of land we currently _Discovererd_. These cordinateds in the queue would be _Discovered_ in the order they are added to the data structure.\\n* We push the first set of cordinates we _Discovered_ in the queue\\n\\n```\\nqueue<pair<int , int>> q;\\nq.push({row , col});\\nvisited[row][col] = 1;\\n```\\n\\n* For further explorations, we look at all the 4 directions at which any _Undiscovered_ piece of land maybe available. For doing so, we perform the following: \\n\\t* Here, we increase the row from -1 to +1 (West to East) \\n\\t* Similarly, we increase the column from -1 to +1 (South to North)\\n\\t* We just want the NSEW directions, for which the rows and columns should be like following:\\n\\t\\t* `(row + 1 , col)`\\n\\t\\t* `(row , col + 1)`\\n\\t\\t* `(row - 1 , col)`\\n\\t\\t* `(row , col - 1`\\n\\t* To maintain this order, we have added the `abs(deltaRow) != abs(deltaCol)` condition.\\n\\n```\\nfor(int deltaRow = -1; deltaRow <= 1; deltaRow++){\\n\\t for(int deltaCol = -1; deltaCol <= 1; deltaCol++){\\n\\t\\t if(abs(deltaRow) != abs(deltaCol)){\\n\\t\\t\\t // Code Further Here\\n\\t\\t }\\n\\t}\\n```\\n\\n* Further to this, we check whether the cordinates of this _Undiscovered_ land is within the bounds of the 2D Array. Hence, we check the following conditions after getting the above mentioned coordinates:\\n```\\n// Row Conditions\\n\\tnewRow >= 0 && newRow < grid.size() &&\\n// Col Conditions\\n\\tnewCol >= 0 && newCol < grid[0].size() &&\\n```\\n\\n* Finally, we check whether this piece of land, whose coordinates we have just deducted, is actually discovered or not. For doing this, we perform the following checks\\n\\t* Whether there is land at the coordinates we have landed (`grid[newRow][newCol] == \\'1\\'`)\\n\\t* Whether we have visitted the land earlier or not (`!visited[newRow][newCol]`)\\n\\n* If the above conditions hold true, we mark this _Unvisited_ land as _Visited_ by marking it as visited in the array.\\n* We perform these operations until all the places in the area is explored. In simple terms, we perform the operation until the Queue is not empty.\\n\\n## Depth First Search\\n* Comparing it to BFS, DFS is comparatively simple, since we don\\'t have to create a Data Structure to add the coordinates that we have to _Discover_.\\n* Herein, we use recursion to reach the coordinates of _Undiscovered_ land. \\n* Once we get the cordinates of the _Undiscovered_ land, we mark that as _Discovered_ by making changes in the `visited` array.\\n* Similar to what we did above, we perform the loops to get the cordinates of the nearby areas and thereafter finding whether these cordinates represent _Undirected_ land. \\n* After deducing the coordinates of the land and checking whether that\\'s actually a land moreover an _Undiscovered_ land, we mark it as _Discovered_ in the `visited` array and start our exploration once again from this point which we were able to come to.\\n* We discover until we have explored the whole island, i.e., all the _Undiscovered_ land on the island is _Discovered_.\\n(If you understood the BFS Code, this is a cakewalk for you)\\n\\n# Code\\n**Note:** The codes for both DFS and BFS are mentioned in the private access modifier of the Solution class.\\nFeel free to use either of them for the solution. However, the DFS function returns a better outcome in terms of runtime and memory usage.\\n\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int row , int col , vector<vector<int>>& visited , vector<vector<char>>& grid){\\n        visited[row][col] = 1;\\n        \\n        for(int deltaRow = -1; deltaRow <= 1; deltaRow++){\\n                for(int deltaCol = -1; deltaCol <= 1; deltaCol++){\\n                    if(abs(deltaRow) != abs(deltaCol)){\\n                        int newRow = row + deltaRow;\\n                        int newCol = col + deltaCol;\\n\\n                        if(\\n                            // Row Conditions\\n                            newRow >= 0 && newRow < grid.size() &&\\n                            // Col Conditions\\n                            newCol >= 0 && newCol < grid[0].size() &&\\n                            // Matrix Conditions\\n                            grid[newRow][newCol] == \\'1\\' && !visited[newRow][newCol]\\n                        ){\\n                            dfs(newRow , newCol , visited , grid);\\n                        }\\n                    }\\n                }\\n        }\\n    }\\n    \\n    void bfs(int row , int col , vector<vector<int>>& visited , vector<vector<char>>& grid){\\n        queue<pair<int , int>> q;\\n        q.push({row , col});\\n        visited[row][col] = 1;\\n        \\n        while(!q.empty()){\\n            int row = q.front().first;\\n            int col = q.front().second;\\n            q.pop();\\n            \\n            for(int deltaRow = -1; deltaRow <= 1; deltaRow++){\\n                for(int deltaCol = -1; deltaCol <= 1; deltaCol++){\\n                    if(abs(deltaRow) != abs(deltaCol)){\\n                        int newRow = row + deltaRow;\\n                        int newCol = col + deltaCol;\\n\\n                        if(\\n                            // Row Conditions\\n                            newRow >= 0 && newRow < grid.size() &&\\n                            // Col Conditions\\n                            newCol >= 0 && newCol < grid[0].size() &&\\n                            // Matrix Conditions\\n                            grid[newRow][newCol] == \\'1\\' && !visited[newRow][newCol]\\n                        ){\\n                            visited[newRow][newCol] = 1;\\n                            q.push({newRow , newCol});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        \\n        vector<vector<int>> visited (rows , vector<int> (cols , 0));\\n        int islands = 0;\\n        \\n        for(int row = 0; row < rows; row++){\\n            for(int col = 0; col < cols; col++){\\n                if(!visited[row][col] && grid[row][col] == \\'1\\'){\\n                    islands++;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// You can use either BFS or DFS, the functions of both are mentioned \\n\\t\\t\\t\\t\\t// in the private segment of the class\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// bfs(row , col , visited , grid);\\n                    dfs(row , col , visited , grid);\\n                }\\n            }\\n        }\\n        \\n        return islands;\\n    }\\n};\\n```\\n\\n# Add On-s \\nThere maybe a problem wherein an island is defined in a differnt fashion.\\nYou can have an island where you can have lands in 8 directions (North, South, East, West, North-East, North-West, South-East, South-West). In such a case, you can have these combinations:\\n* `(row + 1, col)`\\n* `(row + 1 , col + 1)`\\n* `(row + 1, col - 1)`\\n* `(row - 1, col)`\\n* `(row - 1, col + 1)`\\n* `(row - 1, col - 1)`\\n* `(row , col + 1)`\\n* `(row , col - 1)`\\nTo handle such a scenario, remove the `if(abs(deltaRow) != abs(deltaCol))` condition in the loops inside the DFS and BFS functions\\n\\n# Note\\nI am still learning and I maybe wrong in my approach. In a case like such, please feel free to use the comment section. I\\'ll be obliged to start a discussion \\nFinally, take care of you and your loved once. Call them if it had been a long time that you haven\\'t and just tell them what you feel like. Sometimes it\\'s better to say out than just keep thinking and not speaking.\\nI wish that we all land at the place we\\'re hustling for and we do good in our lives.",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nqueue<pair<int , int>> q;\\nq.push({row , col});\\nvisited[row][col] = 1;\\n```\n```\\nfor(int deltaRow = -1; deltaRow <= 1; deltaRow++){\\n\\t for(int deltaCol = -1; deltaCol <= 1; deltaCol++){\\n\\t\\t if(abs(deltaRow) != abs(deltaCol)){\\n\\t\\t\\t // Code Further Here\\n\\t\\t }\\n\\t}\\n```\n```\\n// Row Conditions\\n\\tnewRow >= 0 && newRow < grid.size() &&\\n// Col Conditions\\n\\tnewCol >= 0 && newCol < grid[0].size() &&\\n```\n```\\nclass Solution {\\nprivate:\\n    void dfs(int row , int col , vector<vector<int>>& visited , vector<vector<char>>& grid){\\n        visited[row][col] = 1;\\n        \\n        for(int deltaRow = -1; deltaRow <= 1; deltaRow++){\\n                for(int deltaCol = -1; deltaCol <= 1; deltaCol++){\\n                    if(abs(deltaRow) != abs(deltaCol)){\\n                        int newRow = row + deltaRow;\\n                        int newCol = col + deltaCol;\\n\\n                        if(\\n                            // Row Conditions\\n                            newRow >= 0 && newRow < grid.size() &&\\n                            // Col Conditions\\n                            newCol >= 0 && newCol < grid[0].size() &&\\n                            // Matrix Conditions\\n                            grid[newRow][newCol] == \\'1\\' && !visited[newRow][newCol]\\n                        ){\\n                            dfs(newRow , newCol , visited , grid);\\n                        }\\n                    }\\n                }\\n        }\\n    }\\n    \\n    void bfs(int row , int col , vector<vector<int>>& visited , vector<vector<char>>& grid){\\n        queue<pair<int , int>> q;\\n        q.push({row , col});\\n        visited[row][col] = 1;\\n        \\n        while(!q.empty()){\\n            int row = q.front().first;\\n            int col = q.front().second;\\n            q.pop();\\n            \\n            for(int deltaRow = -1; deltaRow <= 1; deltaRow++){\\n                for(int deltaCol = -1; deltaCol <= 1; deltaCol++){\\n                    if(abs(deltaRow) != abs(deltaCol)){\\n                        int newRow = row + deltaRow;\\n                        int newCol = col + deltaCol;\\n\\n                        if(\\n                            // Row Conditions\\n                            newRow >= 0 && newRow < grid.size() &&\\n                            // Col Conditions\\n                            newCol >= 0 && newCol < grid[0].size() &&\\n                            // Matrix Conditions\\n                            grid[newRow][newCol] == \\'1\\' && !visited[newRow][newCol]\\n                        ){\\n                            visited[newRow][newCol] = 1;\\n                            q.push({newRow , newCol});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        \\n        vector<vector<int>> visited (rows , vector<int> (cols , 0));\\n        int islands = 0;\\n        \\n        for(int row = 0; row < rows; row++){\\n            for(int col = 0; col < cols; col++){\\n                if(!visited[row][col] && grid[row][col] == \\'1\\'){\\n                    islands++;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// You can use either BFS or DFS, the functions of both are mentioned \\n\\t\\t\\t\\t\\t// in the private segment of the class\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// bfs(row , col , visited , grid);\\n                    dfs(row , col , visited , grid);\\n                }\\n            }\\n        }\\n        \\n        return islands;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498577,
                "title": "bfs-clean-code-c-easy-to-understand",
                "content": "```\\n   vector<vector<bool>> visit(grid.size(),vector<bool>(grid[0].size(),false));\\n        int count = 0;\\n        queue<pair<int,int>> q;\\n \\n        for(int  i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n             if(visit[i][j] || grid[i][j]==\\'0\\')continue;\\n                q.push({i,j});\\n                count++;\\n                while(q.size()){\\n                    int u = q.front().first;\\n                    int v = q.front().second;\\n                    q.pop();\\n                    if(u>=grid.size() || u<0 || v>=grid[0].size() || v<0 || visit[u][v] || grid[u][v]==\\'0\\')continue;\\n                    visit[u][v] = true; \\n                   q.push({u+1,v});\\n                   q.push({u-1,v});\\n                   q.push({u,v+1});\\n                   q.push({u,v-1}); \\n                }  \\n            }   \\n        }\\n        \\n\\n        return count;\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\n   vector<vector<bool>> visit(grid.size(),vector<bool>(grid[0].size(),false));\\n        int count = 0;\\n        queue<pair<int,int>> q;\\n \\n        for(int  i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n             if(visit[i][j] || grid[i][j]==\\'0\\')continue;\\n                q.push({i,j});\\n                count++;\\n                while(q.size()){\\n                    int u = q.front().first;\\n                    int v = q.front().second;\\n                    q.pop();\\n                    if(u>=grid.size() || u<0 || v>=grid[0].size() || v<0 || visit[u][v] || grid[u][v]==\\'0\\')continue;\\n                    visit[u][v] = true; \\n                   q.push({u+1,v});\\n                   q.push({u-1,v});\\n                   q.push({u,v+1});\\n                   q.push({u,v-1}); \\n                }  \\n            }   \\n        }\\n        \\n\\n        return count;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2498196,
                "title": "java-dfs-solution-100-faster",
                "content": "```\\n// Time Complexity :O(m*n)\\n// Space Complexity : O(1)\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        \\n        int m = grid.length, n = grid[0].length, count = 0;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == \\'1\\'){\\n                    count++;\\n                    dfs(grid, i, j);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    void dfs(char[][] grid, int row, int col){\\n        \\n        if(row < 0 || col < 0 || row >= grid.length \\n           || col >= grid[0].length || grid[row][col] == \\'0\\') return;\\n\\t\\t   \\n        grid[row][col] = \\'0\\'; // mark visited \\n        \\n        dfs(grid, row-1, col);\\n        dfs(grid, row, col-1);\\n        dfs(grid, row+1, col);\\n        dfs(grid, row, col+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\n// Time Complexity :O(m*n)\\n// Space Complexity : O(1)\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        \\n        int m = grid.length, n = grid[0].length, count = 0;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == \\'1\\'){\\n                    count++;\\n                    dfs(grid, i, j);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    void dfs(char[][] grid, int row, int col){\\n        \\n        if(row < 0 || col < 0 || row >= grid.length \\n           || col >= grid[0].length || grid[row][col] == \\'0\\') return;\\n\\t\\t   \\n        grid[row][col] = \\'0\\'; // mark visited \\n        \\n        dfs(grid, row-1, col);\\n        dfs(grid, row, col-1);\\n        dfs(grid, row+1, col);\\n        dfs(grid, row, col+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1798494,
                "title": "python3-bfs-clean-solution",
                "content": "```\\nfrom collections import defaultdict\\n\\nLAND = \"1\"\\nWATER = \"0\"\\n\\nLEFT = (0, -1)\\nRIGHT = (0, 1)\\nUP = (-1, 0)\\nDOWN = (1, 0)\\n\\nDIRECTIONS = (LEFT, RIGHT, UP, DOWN)\\n\\nclass Solution:\\n    def within_bounds(self, x, y):\\n        return 0 <= x < self.rows and 0 <= y < self.cols\\n    \\n    def is_land(self, x, y):\\n        return self.grid[x][y] == LAND\\n    \\n    def not_visited(self, x, y):\\n        return self.visited[(x, y)] == False\\n        \\n    def bfs(self, row, col):\\n        queue = [(row, col)]\\n        while queue:\\n            x, y = queue.pop(0)\\n            for dx, dy in DIRECTIONS:\\n                new_x = x + dx\\n                new_y = y + dy\\n                \\n                if not self.within_bounds(new_x, new_y):\\n                    continue\\n\\n                if self.is_land(new_x, new_y) and self.not_visited(new_x, new_y):\\n                    queue.append((new_x, new_y))\\n                    self.visited[(new_x, new_y)] = True\\n\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        self.rows = len(grid)\\n        self.cols = len(grid[0])\\n        self.grid = grid\\n        self.visited = defaultdict(lambda: False)\\n        count = 0\\n\\n        for row in range(self.rows):\\n            for col in range(self.cols):\\n                if not self.is_land(row, col):\\n                    continue\\n                \\n                elif (row, col) in self.visited:\\n                    continue\\n                \\n                self.bfs(row, col)\\n                count += 1\\n        \\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nLAND = \"1\"\\nWATER = \"0\"\\n\\nLEFT = (0, -1)\\nRIGHT = (0, 1)\\nUP = (-1, 0)\\nDOWN = (1, 0)\\n\\nDIRECTIONS = (LEFT, RIGHT, UP, DOWN)\\n\\nclass Solution:\\n    def within_bounds(self, x, y):\\n        return 0 <= x < self.rows and 0 <= y < self.cols\\n    \\n    def is_land(self, x, y):\\n        return self.grid[x][y] == LAND\\n    \\n    def not_visited(self, x, y):\\n        return self.visited[(x, y)] == False\\n        \\n    def bfs(self, row, col):\\n        queue = [(row, col)]\\n        while queue:\\n            x, y = queue.pop(0)\\n            for dx, dy in DIRECTIONS:\\n                new_x = x + dx\\n                new_y = y + dy\\n                \\n                if not self.within_bounds(new_x, new_y):\\n                    continue\\n\\n                if self.is_land(new_x, new_y) and self.not_visited(new_x, new_y):\\n                    queue.append((new_x, new_y))\\n                    self.visited[(new_x, new_y)] = True\\n\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        self.rows = len(grid)\\n        self.cols = len(grid[0])\\n        self.grid = grid\\n        self.visited = defaultdict(lambda: False)\\n        count = 0\\n\\n        for row in range(self.rows):\\n            for col in range(self.cols):\\n                if not self.is_land(row, col):\\n                    continue\\n                \\n                elif (row, col) in self.visited:\\n                    continue\\n                \\n                self.bfs(row, col)\\n                count += 1\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1209732,
                "title": "standard-1d-union-find-easy-to-understand-full-explanation-1ms",
                "content": "Idea :\\n1. To start with count as `m*n`  ( considering each as separate islands ).\\n2. Create a 1D union find implemented as array(of `m*n` disjoint elements)\\n3. While traversing unify the new island with connected island \\n4. Reduce the count if unified. (since this not a new seperate island but just a connected part of existing island)\\n3. Reduce the count if `grid[0][0] = \\'0\\'` (not an island)\\n\\n\\nWhile checking for an element we only try to unify with `grid[i-1][j]` or `grid[i][j-1]` , since only these may contain existing islands. \\nSo **no** need to check or unify with `grid[i+1][j]` or `grid[i][j+1]`. ( We are not traversing guys, we are just unifying islands we came across previously)\\n\\nThe 2D array of elements are mapped to the 1D union find array. (using `index  = i*n + j`)\\nFor a 2D array `(3x4)`,  the items in the matrix maps to nums array\\'s index in follow fashion\\n0 1 2 3\\n4 5 6 7\\n8 9 10 11\\n\\n\\n\\nHow I got this idea :\\nThis problem is similar to 323 \"The number of connected components in an undirected graph\" \\nhttps://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/\\n(Here connection exist in 4 directions.)\\n\\n\\n\\n\\n```\\nclass Solution {\\n    int count = 0;\\n\\t// optional : int m, n can be moved here to avoid passing \\'n\\' in find(int[] nums, int i, int j, int n)\\n    public int numIslands(char[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[] nums = new int[m * n];\\n        for (int k = 0; k < m * n; k++)\\n            nums[k] = k; //(Initializing union find with its own index)  Each element is its own disjoint set\\n\\n        count = m * n;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    if (i - 1 >= 0 && grid[i - 1][j] == \\'1\\') \\n                        unify(nums, i, j, i - 1, j, n);\\n\\n                    if (j - 1 >= 0 && grid[i][j - 1] == \\'1\\') \\n                        unify(nums, i, j, i, j - 1, n);\\n\\n                } else {\\n                    count--; //not an island\\n                }\\n            }\\n\\n        return count;\\n    }\\n\\n    public void unify(int[] nums, int i1, int j1, int i2, int j2, int n) {\\n        int x = find(nums, i1, j1, n);\\n        int y = find(nums, i2, j2, n);\\n        if (x != y) {\\n            nums[x] = y;\\n            count--; //Reducing count since grid[i][j] is not a new separate island but just a connected part of existing island (grid[i-1][j] or grid[i][j-1])\\n        }\\n    }\\n\\n    public int find(int[] nums, int i, int j, int n) {\\n        return find(nums, i * n + j);  //index = i*n + j\\n    }\\n\\n    public int find(int[] nums, int k) {\\n        int root = k;\\n        while (nums[root] != root) {\\n            root = nums[root];\\n        }\\n\\t\\t// path compression \\n        while (nums[k] != k) {\\n            int temp = nums[k];\\n            nums[k] = root;\\n            k = temp;\\n        }\\n        return root;\\n    }\\n\\t\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n\\t// optional : int m, n can be moved here to avoid passing \\'n\\' in find(int[] nums, int i, int j, int n)\\n    public int numIslands(char[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[] nums = new int[m * n];\\n        for (int k = 0; k < m * n; k++)\\n            nums[k] = k; //(Initializing union find with its own index)  Each element is its own disjoint set\\n\\n        count = m * n;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    if (i - 1 >= 0 && grid[i - 1][j] == \\'1\\') \\n                        unify(nums, i, j, i - 1, j, n);\\n\\n                    if (j - 1 >= 0 && grid[i][j - 1] == \\'1\\') \\n                        unify(nums, i, j, i, j - 1, n);\\n\\n                } else {\\n                    count--; //not an island\\n                }\\n            }\\n\\n        return count;\\n    }\\n\\n    public void unify(int[] nums, int i1, int j1, int i2, int j2, int n) {\\n        int x = find(nums, i1, j1, n);\\n        int y = find(nums, i2, j2, n);\\n        if (x != y) {\\n            nums[x] = y;\\n            count--; //Reducing count since grid[i][j] is not a new separate island but just a connected part of existing island (grid[i-1][j] or grid[i][j-1])\\n        }\\n    }\\n\\n    public int find(int[] nums, int i, int j, int n) {\\n        return find(nums, i * n + j);  //index = i*n + j\\n    }\\n\\n    public int find(int[] nums, int k) {\\n        int root = k;\\n        while (nums[root] != root) {\\n            root = nums[root];\\n        }\\n\\t\\t// path compression \\n        while (nums[k] != k) {\\n            int temp = nums[k];\\n            nums[k] = root;\\n            k = temp;\\n        }\\n        return root;\\n    }\\n\\t\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 716626,
                "title": "javascript-clean-dfs",
                "content": "```javascript\\nvar numIslands = function(grid) {\\n    let islands = 0;\\n  \\n    for(let r = 0; r < grid.length; r++) {\\n        for(let c = 0; c < grid[0].length; c++) {\\n            if(grid[r][c] === \\'1\\') {\\n                islands++;\\n                callDFS(r, c);\\n            }\\n        }\\n    }\\n    \\n    function callDFS(r, c) {\\n        if(r < 0 || r >= grid.length || grid[r][c] !== \\'1\\') return;\\n        grid[r][c] = \\'0\\';\\n        \\n        callDFS(r+1, c); // down\\n        callDFS(r-1, c); // up\\n        callDFS(r, c+1); // right\\n        callDFS(r, c-1); // left\\n    }\\n    return islands;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```javascript\\nvar numIslands = function(grid) {\\n    let islands = 0;\\n  \\n    for(let r = 0; r < grid.length; r++) {\\n        for(let c = 0; c < grid[0].length; c++) {\\n            if(grid[r][c] === \\'1\\') {\\n                islands++;\\n                callDFS(r, c);\\n            }\\n        }\\n    }\\n    \\n    function callDFS(r, c) {\\n        if(r < 0 || r >= grid.length || grid[r][c] !== \\'1\\') return;\\n        grid[r][c] = \\'0\\';\\n        \\n        callDFS(r+1, c); // down\\n        callDFS(r-1, c); // up\\n        callDFS(r, c+1); // right\\n        callDFS(r, c-1); // left\\n    }\\n    return islands;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 571524,
                "title": "java-dfs",
                "content": "Easy problem once you understand it. \\n```    public int numIslands(char[][] grid) {\\n        if (grid == null || grid.length == 0) {\\n            return 0;\\n        }\\n        \\n        int numIslands = 0;\\n        /* Do a linear traversal of the grid. The first place we find Land, We purge the island.\\n            The purge can only take place to adjacent land. So we can only purge one island at a time.\\n        */ \\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    numIslands++;\\n                    purgeIsland(grid, i, j);\\n                } \\n            }\\n        }\\n        return numIslands;\\n    }\\n    \\n    //DFS. \\n    private void purgeIsland(char[][] grid, int i , int j) {    \\n        boolean isOutOfBounds =  i < 0 || j < 0 || i >= grid.length || j >= grid[i].length;\\n    \\n        if (isOutOfBounds || grid[i][j] == \\'0\\') { return; }\\n        \\n        grid[i][j] = \\'0\\';\\n        purgeIsland(grid, i+1, j);\\n        purgeIsland(grid, i-1, j);\\n        purgeIsland(grid, i, j+1);\\n        purgeIsland(grid, i, j-1);\\n    }",
                "solutionTags": [],
                "code": "Easy problem once you understand it. \\n```    public int numIslands(char[][] grid) {\\n        if (grid == null || grid.length == 0) {\\n            return 0;\\n        }\\n        \\n        int numIslands = 0;\\n        /* Do a linear traversal of the grid. The first place we find Land, We purge the island.\\n            The purge can only take place to adjacent land. So we can only purge one island at a time.\\n        */ \\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    numIslands++;\\n                    purgeIsland(grid, i, j);\\n                } \\n            }\\n        }\\n        return numIslands;\\n    }\\n    \\n    //DFS. \\n    private void purgeIsland(char[][] grid, int i , int j) {    \\n        boolean isOutOfBounds =  i < 0 || j < 0 || i >= grid.length || j >= grid[i].length;\\n    \\n        if (isOutOfBounds || grid[i][j] == \\'0\\') { return; }\\n        \\n        grid[i][j] = \\'0\\';\\n        purgeIsland(grid, i+1, j);\\n        purgeIsland(grid, i-1, j);\\n        purgeIsland(grid, i, j+1);\\n        purgeIsland(grid, i, j-1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 480869,
                "title": "javascript-bfs",
                "content": "```\\nfunction numIslands(grid) {\\n  let count = 0;\\n  for (let i = 0; i < grid.length; i++) {\\n    for (let j = 0; j < grid[0].length; j++) {\\n      if (grid[i][j] === \\'1\\') {\\n        count++;\\n        color(grid, i, j); \\n      }   \\n    }   \\n  }\\n  return count;\\n}\\n\\nfunction color(grid, i, j) {\\n  let q = [[i, j]];\\n  while (q.length) {\\n    let [x, y] = q.pop();\\n    grid[x][y] = 0;\\n    for (let [newX, newY] of [[x + 1, y], [x, y + 1], [x - 1, y], [x, y - 1]]) {\\n      if (\\n        newX >= 0 &&\\n        newX < grid.length &&\\n        newY >= 0 &&\\n        newY < grid[0].length &&\\n        grid[newX][newY] === \\'1\\' \\n      ) { \\n        q.push([newX, newY]);\\n      }   \\n    }   \\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nfunction numIslands(grid) {\\n  let count = 0;\\n  for (let i = 0; i < grid.length; i++) {\\n    for (let j = 0; j < grid[0].length; j++) {\\n      if (grid[i][j] === \\'1\\') {\\n        count++;\\n        color(grid, i, j); \\n      }   \\n    }   \\n  }\\n  return count;\\n}\\n\\nfunction color(grid, i, j) {\\n  let q = [[i, j]];\\n  while (q.length) {\\n    let [x, y] = q.pop();\\n    grid[x][y] = 0;\\n    for (let [newX, newY] of [[x + 1, y], [x, y + 1], [x - 1, y], [x, y - 1]]) {\\n      if (\\n        newX >= 0 &&\\n        newX < grid.length &&\\n        newY >= 0 &&\\n        newY < grid[0].length &&\\n        grid[newX][newY] === \\'1\\' \\n      ) { \\n        q.push([newX, newY]);\\n      }   \\n    }   \\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 479692,
                "title": "intuitive-disjoint-set-union-find-in-java-python3",
                "content": "### Java\\n```\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        if (grid == null || grid.length == 0 || \\n\\t\\t\\tgrid[0] == null || grid[0].length == 0) return 0;\\n        \\n        int r = grid.length, c = grid[0].length;\\n        DSU dsu = new DSU(r * c);\\n        \\n        // union an island with its adjacent islands\\n        for (int i = 0; i < r; ++i) {\\n            for (int j = 0; j < c; ++j) {\\n                if (grid[i][j] == \\'1\\') {\\n                    \\n                    // add this island first\\n                    dsu.incNumIsl();\\n                    \\n                    // union 4 adjacent islands if exist\\n                    if (i - 1 >= 0 && grid[i - 1][j] == \\'1\\')\\n                        dsu.union((i - 1) * c + j, i * c + j);\\n                    if (i + 1 < r && grid[i + 1][j] == \\'1\\')\\n                        dsu.union(i * c + j, (i + 1) * c + j);\\n                    if (j - 1 >= 0 && grid[i][j - 1] == \\'1\\')\\n                        dsu.union(i * c + (j - 1), i * c + (j - 1));\\n                    if (j + 1 < c && grid[i][j + 1] == \\'1\\')\\n                        dsu.union(i * c + j, i * c + (j + 1));\\n                }\\n            }\\n        }\\n        \\n        return dsu.getNumIsl();\\n    }\\n}\\n\\nclass DSU {\\n    private int[] par = null, rnk = null;\\n    private int numIsl;\\n\\t\\n    public DSU(int num) {\\n        this.par = new int[num];\\n        this.rnk = new int[num];\\n        this.numIsl = 0;\\n        for (int i = 0; i < num; ++i)\\n\\t\\t\\tthis.par[i] = i;\\n    }\\n    \\n    public int find(int x) {\\n        if (this.par[x] != x)\\n            this.par[x] = this.find(this.par[x]);\\n        return this.par[x];\\n    }\\n    \\n    public void union(int x, int y) {\\n        int xr = this.find(x), yr = this.find(y);\\n        if (xr == yr)\\n\\t\\t\\treturn;\\n        else if (this.rnk[xr] < this.rnk[yr])\\n            this.par[xr] = yr;\\n        else if (this.rnk[xr] > this.rnk[yr])\\n            this.par[yr] = xr;\\n        else {\\n            this.par[yr] = xr;\\n            this.rnk[xr]++;\\n        }\\n        this.numIsl--;\\n    }\\n    \\n    public void incNumIsl() {\\n        this.numIsl++;\\n    }\\n    \\n    public int getNumIsl() {\\n        return this.numIsl;\\n    }\\n}\\n```\\n---\\n### Python3\\n```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        if grid == None or len(grid) == 0: return 0\\n        \\n        r, c = len(grid), len(grid[0])\\n        dsu = DSU(r * c)\\n        \\n        # union an island with its adjacent islands\\n        for i in range(r):\\n            for j in range(c):\\n                if int(grid[i][j]) == 1:\\n                    \\n                    # add this island first\\n                    dsu.numIsl += 1\\n                    \\n                    # union 4 adjacent islands if exist\\n                    if i - 1 >= 0 and int(grid[i - 1][j]) == 1:\\n                        dsu.union((i - 1) * c + j, i * c + j)\\n                    if i + 1 < r and int(grid[i + 1][j]) == 1:\\n                        dsu.union(i * c + j, (i + 1) * c + j)\\n                    if j - 1 >= 0 and int(grid[i][j - 1]) == 1:\\n                        dsu.union(i * c + (j - 1), i * c + j)\\n                    if j + 1 < c and int(grid[i][j + 1]) == 1:\\n                        dsu.union(i * c + j, i * c + (j + 1))\\n                            \\n        return dsu.numIsl\\n    \\nclass DSU:\\n    def __init__(self, num):\\n        self.numIsl = 0\\n        self.par = list(range(num))\\n        self.rnk = [0] * num\\n\\n    def find(self, x):\\n        if self.par[x] != x:\\n            self.par[x] = self.find(self.par[x])\\n        return self.par[x]\\n    \\n    def union(self, x, y):\\n        xr, yr = self.find(x), self.find(y)\\n        if xr == yr:\\n\\t\\t\\treturn\\n        elif self.rnk[xr] < self.rnk[yr]:\\n            self.par[xr] = yr\\n        elif self.rnk[xr] > self.rnk[yr]:\\n            self.par[yr] = xr\\n        else:\\n            self.par[yr] = xr\\n            self.rnk[xr] += 1\\n        self.numIsl -= 1\\n```\\n---\\n### Analysis\\nTime Complexity: O(N\\u03B1(N))\\u2248O(N), where N is the number of vertices (and also the number of edges) in the graph, and \\u03B1 is the Inverse-Ackermann function.\\nSpace Complexity: O(N). The current construction of the graph (embedded in our dsu structure) has at most N nodes.\\n\\n---\\n\\n### References\\n\\nIntuitive Explanation Video\\nhttps://youtu.be/0jNmHPfA_yE\\n\\nhttps://leetcode.com/problems/redundant-connection/solution/",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        if (grid == null || grid.length == 0 || \\n\\t\\t\\tgrid[0] == null || grid[0].length == 0) return 0;\\n        \\n        int r = grid.length, c = grid[0].length;\\n        DSU dsu = new DSU(r * c);\\n        \\n        // union an island with its adjacent islands\\n        for (int i = 0; i < r; ++i) {\\n            for (int j = 0; j < c; ++j) {\\n                if (grid[i][j] == \\'1\\') {\\n                    \\n                    // add this island first\\n                    dsu.incNumIsl();\\n                    \\n                    // union 4 adjacent islands if exist\\n                    if (i - 1 >= 0 && grid[i - 1][j] == \\'1\\')\\n                        dsu.union((i - 1) * c + j, i * c + j);\\n                    if (i + 1 < r && grid[i + 1][j] == \\'1\\')\\n                        dsu.union(i * c + j, (i + 1) * c + j);\\n                    if (j - 1 >= 0 && grid[i][j - 1] == \\'1\\')\\n                        dsu.union(i * c + (j - 1), i * c + (j - 1));\\n                    if (j + 1 < c && grid[i][j + 1] == \\'1\\')\\n                        dsu.union(i * c + j, i * c + (j + 1));\\n                }\\n            }\\n        }\\n        \\n        return dsu.getNumIsl();\\n    }\\n}\\n\\nclass DSU {\\n    private int[] par = null, rnk = null;\\n    private int numIsl;\\n\\t\\n    public DSU(int num) {\\n        this.par = new int[num];\\n        this.rnk = new int[num];\\n        this.numIsl = 0;\\n        for (int i = 0; i < num; ++i)\\n\\t\\t\\tthis.par[i] = i;\\n    }\\n    \\n    public int find(int x) {\\n        if (this.par[x] != x)\\n            this.par[x] = this.find(this.par[x]);\\n        return this.par[x];\\n    }\\n    \\n    public void union(int x, int y) {\\n        int xr = this.find(x), yr = this.find(y);\\n        if (xr == yr)\\n\\t\\t\\treturn;\\n        else if (this.rnk[xr] < this.rnk[yr])\\n            this.par[xr] = yr;\\n        else if (this.rnk[xr] > this.rnk[yr])\\n            this.par[yr] = xr;\\n        else {\\n            this.par[yr] = xr;\\n            this.rnk[xr]++;\\n        }\\n        this.numIsl--;\\n    }\\n    \\n    public void incNumIsl() {\\n        this.numIsl++;\\n    }\\n    \\n    public int getNumIsl() {\\n        return this.numIsl;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        if grid == None or len(grid) == 0: return 0\\n        \\n        r, c = len(grid), len(grid[0])\\n        dsu = DSU(r * c)\\n        \\n        # union an island with its adjacent islands\\n        for i in range(r):\\n            for j in range(c):\\n                if int(grid[i][j]) == 1:\\n                    \\n                    # add this island first\\n                    dsu.numIsl += 1\\n                    \\n                    # union 4 adjacent islands if exist\\n                    if i - 1 >= 0 and int(grid[i - 1][j]) == 1:\\n                        dsu.union((i - 1) * c + j, i * c + j)\\n                    if i + 1 < r and int(grid[i + 1][j]) == 1:\\n                        dsu.union(i * c + j, (i + 1) * c + j)\\n                    if j - 1 >= 0 and int(grid[i][j - 1]) == 1:\\n                        dsu.union(i * c + (j - 1), i * c + j)\\n                    if j + 1 < c and int(grid[i][j + 1]) == 1:\\n                        dsu.union(i * c + j, i * c + (j + 1))\\n                            \\n        return dsu.numIsl\\n    \\nclass DSU:\\n    def __init__(self, num):\\n        self.numIsl = 0\\n        self.par = list(range(num))\\n        self.rnk = [0] * num\\n\\n    def find(self, x):\\n        if self.par[x] != x:\\n            self.par[x] = self.find(self.par[x])\\n        return self.par[x]\\n    \\n    def union(self, x, y):\\n        xr, yr = self.find(x), self.find(y)\\n        if xr == yr:\\n\\t\\t\\treturn\\n        elif self.rnk[xr] < self.rnk[yr]:\\n            self.par[xr] = yr\\n        elif self.rnk[xr] > self.rnk[yr]:\\n            self.par[yr] = xr\\n        else:\\n            self.par[yr] = xr\\n            self.rnk[xr] += 1\\n        self.numIsl -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 425331,
                "title": "python3-simple-dfs-solution",
                "content": "```\\nclass Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        r = len(grid)\\n        if r == 0: return 0\\n        c=len(grid[0])\\n         \\n        def DFS(i, j):\\n            if grid[i][j] == \\'1\\':\\n                grid[i][j] = \\'0\\'\\n                if i > 0:   DFS(i-1, j)\\n                if i < r-1: DFS(i+1, j)\\n                if j > 0:   DFS(i, j-1)\\n                if j < c-1: DFS(i, j+1)\\n                    \\n        count = 0 \\n        for i in range(r):\\n            for j in range(c):\\n                if grid[i][j] == \\'1\\':\\n                    count += 1\\n                    DFS(i, j)\\n        return count \\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        r = len(grid)\\n        if r == 0: return 0\\n        c=len(grid[0])\\n         \\n        def DFS(i, j):\\n            if grid[i][j] == \\'1\\':\\n                grid[i][j] = \\'0\\'\\n                if i > 0:   DFS(i-1, j)\\n                if i < r-1: DFS(i+1, j)\\n                if j > 0:   DFS(i, j-1)\\n                if j < c-1: DFS(i, j+1)\\n                    \\n        count = 0 \\n        for i in range(r):\\n            for j in range(c):\\n                if grid[i][j] == \\'1\\':\\n                    count += 1\\n                    DFS(i, j)\\n        return count \\n```",
                "codeTag": "Java"
            },
            {
                "id": 325116,
                "title": "javascript-union-find-solution",
                "content": "Union Find Intuition: https://www.quora.com/What-is-an-intuitive-explanation-of-union-find\\n\\n\\n```\\n/**\\n * @param {character[][]} grid\\n * @return {number}\\n */\\nvar numIslands = function(grid) {\\n    if (grid.length === 0) return 0;\\n    \\n    let parent = {};\\n\\n    const DIRS = [[0,-1], [0,1], [-1, 0], [1,0]];\\n    \\n    const UnionFind = function(grid){\\n        let size = {};\\n\\n        for (let i=0; i<grid.length; i++){\\n            for (let j=0; j<grid[i].length; j++){\\n                if (grid[i][j] === \\'1\\'){\\n                    let id = `${i}_${j}`;\\n                    parent[id] = id;\\n                    size[id] = 1;\\n                }\\n            }\\n        }\\n\\n        this.find = (id) => {\\n            if (parent[id] === id) return id;\\n            parent[id] = this.find(parent[id]);\\n            return parent[id];\\n        }\\n\\n        this.union = (x,y) => {\\n            let rootX = this.find(x);\\n            let rootY = this.find(y);\\n\\n            if (rootX === rootY) return;\\n            if (size[rootX] > size[rootY]){\\n                size[rootX] += size[rootY];\\n                parent[rootY] = rootX;\\n            }else{\\n                size[rootY] += size[rootX];\\n                parent[rootX] = rootY;\\n            }\\n        }\\n    }\\n\\n    const UF = new UnionFind(grid);\\n\\n    for (let i=0; i<grid.length; i++){\\n        for (let j=0; j<grid[i].length; j++){\\n            if (grid[i][j] === \\'1\\'){\\n                let id = `${i}_${j}`;\\n                for (let dir of DIRS) {\\n                    let ni = i+dir[0];\\n                    let nj = j+dir[1];\\n                    if (ni>=0 && ni<grid.length && nj>=0 && nj<grid[i].length){\\n                        let nId = `${ni}_${nj}`\\n                        if (grid[ni][nj] === \\'1\\') UF.union(id, nId);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    let rootSet = new Set();\\n    for (let child in parent){\\n        let root = UF.find(child);\\n        if (!rootSet.has(root)) rootSet.add(root);\\n    }\\n    return rootSet.size;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Union Find"
                ],
                "code": "```\\n/**\\n * @param {character[][]} grid\\n * @return {number}\\n */\\nvar numIslands = function(grid) {\\n    if (grid.length === 0) return 0;\\n    \\n    let parent = {};\\n\\n    const DIRS = [[0,-1], [0,1], [-1, 0], [1,0]];\\n    \\n    const UnionFind = function(grid){\\n        let size = {};\\n\\n        for (let i=0; i<grid.length; i++){\\n            for (let j=0; j<grid[i].length; j++){\\n                if (grid[i][j] === \\'1\\'){\\n                    let id = `${i}_${j}`;\\n                    parent[id] = id;\\n                    size[id] = 1;\\n                }\\n            }\\n        }\\n\\n        this.find = (id) => {\\n            if (parent[id] === id) return id;\\n            parent[id] = this.find(parent[id]);\\n            return parent[id];\\n        }\\n\\n        this.union = (x,y) => {\\n            let rootX = this.find(x);\\n            let rootY = this.find(y);\\n\\n            if (rootX === rootY) return;\\n            if (size[rootX] > size[rootY]){\\n                size[rootX] += size[rootY];\\n                parent[rootY] = rootX;\\n            }else{\\n                size[rootY] += size[rootX];\\n                parent[rootX] = rootY;\\n            }\\n        }\\n    }\\n\\n    const UF = new UnionFind(grid);\\n\\n    for (let i=0; i<grid.length; i++){\\n        for (let j=0; j<grid[i].length; j++){\\n            if (grid[i][j] === \\'1\\'){\\n                let id = `${i}_${j}`;\\n                for (let dir of DIRS) {\\n                    let ni = i+dir[0];\\n                    let nj = j+dir[1];\\n                    if (ni>=0 && ni<grid.length && nj>=0 && nj<grid[i].length){\\n                        let nId = `${ni}_${nj}`\\n                        if (grid[ni][nj] === \\'1\\') UF.union(id, nId);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    let rootSet = new Set();\\n    for (let child in parent){\\n        let root = UF.find(child);\\n        if (!rootSet.has(root)) rootSet.add(root);\\n    }\\n    return rootSet.size;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 238370,
                "title": "simple-python-dfs-with-explanation",
                "content": "Top level overview (func numIslands):\\n1. Iterate through each element in the grid.\\n2. At each element, if grid[i][j] == \"1\":\\n\\t* Increase our count of the number of islands (num_islands)\\n\\t* perform DFS starting at grid[i][j] to mark all the entire connected component as one island.\\n\\nDFS overview (func dfs):\\nGiven a grid and the starting row and column indices,\\n1. Change the value at grid[r][c] to \"0\" to mark this element as visited.\\n2. For each of its neighbor indices, if the neighbor is both within bounds of the grid and has a value of \"1\" (i.e. is part of the same island), peform dfs on that neighbor.\\n\\nTime complexity: O(M * N), M=number of rows and N=number of columns\\n* In numIslands we look at every element in grid once, so M * N\\n* In the worst case, a call of dfs from numIslands can look at every element if the whole grid is an island, so also M * N\\n* O(2M * N) = O(M * N)\\n\\nSpace complexity: O(1)\\n* No additional space needed to store visited nodes since we update in-place\\n\\n```\\nclass Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        num_islands = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == \"1\":\\n                    num_islands += 1\\n                    self.dfs(grid, i, j)\\n                    \\n        return num_islands\\n    \\n    def dfs(self, grid, r, c):\\n        grid[r][c] = \"0\"\\n        for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:\\n            nr = r + dr\\n            nc = c + dc\\n            if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] == \"1\":\\n                self.dfs(grid, nr, nc)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        num_islands = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == \"1\":\\n                    num_islands += 1\\n                    self.dfs(grid, i, j)\\n                    \\n        return num_islands\\n    \\n    def dfs(self, grid, r, c):\\n        grid[r][c] = \"0\"\\n        for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:\\n            nr = r + dr\\n            nc = c + dc\\n            if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] == \"1\":\\n                self.dfs(grid, nr, nc)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 227328,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func numIslands(_ grid: [[Character]]) -> Int {\\n        \\n        guard grid.count > 0 else { return 0 }\\n        guard grid[0].count > 0 else { return 0 }\\n\\n        var matrix = grid\\n        var numberOfIslands = 0\\n        \\n        for i in 0..<matrix.count {\\n            for j in 0..<matrix[0].count {\\n                if matrix[i][j] == \"1\" {\\n                    numberOfIslands += 1\\n                    changeElement(&matrix, i, j)\\n                } \\n            }\\n        }\\n        return numberOfIslands\\n    }\\n    \\n    private func changeElement(_ matrix: inout [[Character]], _ i: Int, _ j: Int) {\\n        guard i >= 0, i < matrix.count, j >= 0, j < matrix[0].count, matrix[i][j] == \"1\" else { return }\\n        matrix[i][j] = \"0\"\\n        changeElement(&matrix, i + 1, j)\\n        changeElement(&matrix, i - 1, j)\\n        changeElement(&matrix, i, j + 1)\\n        changeElement(&matrix, i, j - 1)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func numIslands(_ grid: [[Character]]) -> Int {\\n        \\n        guard grid.count > 0 else { return 0 }\\n        guard grid[0].count > 0 else { return 0 }\\n\\n        var matrix = grid\\n        var numberOfIslands = 0\\n        \\n        for i in 0..<matrix.count {\\n            for j in 0..<matrix[0].count {\\n                if matrix[i][j] == \"1\" {\\n                    numberOfIslands += 1\\n                    changeElement(&matrix, i, j)\\n                } \\n            }\\n        }\\n        return numberOfIslands\\n    }\\n    \\n    private func changeElement(_ matrix: inout [[Character]], _ i: Int, _ j: Int) {\\n        guard i >= 0, i < matrix.count, j >= 0, j < matrix[0].count, matrix[i][j] == \"1\" else { return }\\n        matrix[i][j] = \"0\"\\n        changeElement(&matrix, i + 1, j)\\n        changeElement(&matrix, i - 1, j)\\n        changeElement(&matrix, i, j + 1)\\n        changeElement(&matrix, i, j - 1)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56638,
                "title": "sink-the-island-java-solution",
                "content": "Since it does not like other DFS or BFS question, after we sink the '1' to '0', it would not do same recursion because 1 already turn into 0. Only thing repeatedly being done is check this position whether it's 1, which takes O1.\\n\\n    public class Solution {\\n        public int numIslands(char[][] grid) {\\n            int count = 0;\\n            for(int i=0;i<grid.length;i++){\\n                for(int j=0; j<grid[i].length;j++){\\n                    if(grid[i][j] == '1'){\\n                        count++;\\n                        sink(grid,i,j);\\n                    }\\n                }\\n            }\\n            return count;\\n        }\\n        \\n        private void sink(char[][] grid, int a, int b){\\n            grid[a][b] = 0;\\n            if(a!= grid.length-1 && grid[a+1][b] == '1')\\n                sink(grid,a+1,b);\\n            if(b!= grid[a].length-1 && grid[a][b+1] == '1')\\n                sink(grid,a,b+1);\\n            if(a!= 0 && grid[a-1][b] == '1')\\n                sink(grid,a-1,b);\\n            if(b!= 0 && grid[a][b-1] == '1')\\n                sink(grid,a,b-1);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int numIslands(char[][] grid) {\\n            int count = 0;\\n            for(int i=0;i<grid.length;i++){\\n                for(int j=0; j<grid[i].length;j++){\\n                    if(grid[i][j] == '1'){\\n                        count++;\\n                        sink(grid,i,j);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 56385,
                "title": "python-bfs-solution",
                "content": "    from collections import deque\\n    class Solution:\\n        # @param grid, a list of list of characters\\n        # @return an integer\\n        def numIslands(self, grid):\\n            if not grid:\\n                return 0\\n            lands=set([(i,j) for j in xrange(len(grid[0])) for i in xrange(len(grid)) if grid[i][j]=='1'])\\n            count=0\\n            while lands:\\n                count+=1\\n                i,j=lands.pop()\\n                connected=deque()\\n                connected.append((i,j))\\n                while connected:\\n                    i,j=connected.popleft()\\n                    if (i+1,j) in lands:\\n                        connected.append((i+1,j))\\n                        lands.remove((i+1,j))\\n                    if (i-1,j) in lands:\\n                        connected.append((i-1,j))\\n                        lands.remove((i-1,j))\\n                    if (i,j+1) in lands:\\n                        connected.append((i,j+1))\\n                        lands.remove((i,j+1))\\n                    if (i,j-1) in lands:\\n                        connected.append((i,j-1))\\n                        lands.remove((i,j-1))\\n            return count",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "    from collections import deque\\n    class Solution:\\n        # @param grid, a list of list of characters\\n        # @return an integer\\n        def numIslands(self, grid):\\n            if not grid:\\n                return 0\\n            lands=set([(i,j) for j in xrange(len(grid[0])) for i in xrange(len(grid)) if grid[i][j]=='1'])\\n            count=0\\n            while lands:\\n                count+=1\\n                i,j=lands.pop()\\n                connected=deque()\\n                connected.append((i,j))\\n                while connected:\\n                    i,j=connected.popleft()\\n                    if (i+1,j) in lands:\\n                        connected.append((i+1,j))\\n                        lands.remove((i+1,j))\\n                    if (i-1,j) in lands:\\n                        connected.append((i-1,j))\\n                        lands.remove((i-1,j))\\n                    if (i,j+1) in lands:\\n                        connected.append((i,j+1))\\n                        lands.remove((i,j+1))\\n                    if (i,j-1) in lands:\\n                        connected.append((i,j-1))\\n                        lands.remove((i,j-1))\\n            return count",
                "codeTag": "Java"
            },
            {
                "id": 56430,
                "title": "java-undirected-graph-connected-components",
                "content": "My solution is based on the concept of the connected components in graph, but basically it is a DFS variant.\\n\\nIt uses O(M N) extra space and has O(M N) time complexity.\\n\\n     public int numIslands(char[][] grid) {\\n        if(grid == null || grid.length == 0) {\\n            return 0;\\n        }\\n\\n        final int N = grid.length;\\n        final int M = grid[0].length;\\n        final boolean visited[][] = new boolean[N][M];\\n        int count = 0;\\n\\n        for(int i = 0; i < N; i++) {\\n            for(int j = 0; j < M; j++) {\\n\\n                if(grid[i][j] == '1' && !visited[i][j]) {\\n                    dfs(grid, i, j, visited);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    } \\n    private void dfs(char[][] grid, int i, int j, boolean[][] visited) {\\n        if(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length) {\\n            return;\\n        } else if(visited[i][j] || grid[i][j] != '1') {\\n            return;\\n        }\\n\\n        visited[i][j] = true;\\n        dfs(grid, i - 1, j, visited);\\n        dfs(grid, i + 1, j, visited);\\n        dfs(grid, i, j - 1, visited);\\n        dfs(grid, i, j + 1, visited);\\n    }",
                "solutionTags": [],
                "code": "My solution is based on the concept of the connected components in graph, but basically it is a DFS variant.\\n\\nIt uses O(M N) extra space and has O(M N) time complexity.\\n\\n     public int numIslands(char[][] grid) {\\n        if(grid == null || grid.length == 0) {\\n            return 0;\\n        }\\n\\n        final int N = grid.length;\\n        final int M = grid[0].length;\\n        final boolean visited[][] = new boolean[N][M];\\n        int count = 0;\\n\\n        for(int i = 0; i < N; i++) {\\n            for(int j = 0; j < M; j++) {\\n\\n                if(grid[i][j] == '1' && !visited[i][j]) {\\n                    dfs(grid, i, j, visited);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    } \\n    private void dfs(char[][] grid, int i, int j, boolean[][] visited) {\\n        if(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length) {\\n            return;\\n        } else if(visited[i][j] || grid[i][j] != '1') {\\n            return;\\n        }\\n\\n        visited[i][j] = true;\\n        dfs(grid, i - 1, j, visited);\\n        dfs(grid, i + 1, j, visited);\\n        dfs(grid, i, j - 1, visited);\\n        dfs(grid, i, j + 1, visited);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3724365,
                "title": "python3-dfs-mega-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        visited = set()\\n        col, row = len(grid), len(grid[0])\\n        ans = 0\\n        dir = [[0, 1], [1, 0], [0, -1], [-1, 0]]\\n\\n        def helper(c: int, r: int):\\n            visited.add((c, r))\\n            for i, j in dir:\\n                nc, nr = c+i, r+j\\n                if 0 <= nc < col and 0 <= nr < row and grid[nc][nr] == \"1\" and (nc, nr) not in visited:\\n                    helper(nc, nr)\\n        \\n        for c in range(col):\\n            for r in range(row):\\n                if (c, r) not in visited and grid[c][r] == \"1\":\\n                    helper(c, r)\\n                    ans += 1\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        visited = set()\\n        col, row = len(grid), len(grid[0])\\n        ans = 0\\n        dir = [[0, 1], [1, 0], [0, -1], [-1, 0]]\\n\\n        def helper(c: int, r: int):\\n            visited.add((c, r))\\n            for i, j in dir:\\n                nc, nr = c+i, r+j\\n                if 0 <= nc < col and 0 <= nr < row and grid[nc][nr] == \"1\" and (nc, nr) not in visited:\\n                    helper(nc, nr)\\n        \\n        for c in range(col):\\n            for r in range(row):\\n                if (c, r) not in visited and grid[c][r] == \"1\":\\n                    helper(c, r)\\n                    ans += 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465780,
                "title": "dfs-and-bfs-solution",
                "content": "# BFS Approach\\n```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        if not grid:return 0\\n        rows,cols=len(grid),len(grid[0])\\n        count,visit=0,set()\\n        def bfs(r,c):\\n            q=deque()\\n            q.append((r,c))\\n            visit.add((r,c))\\n            while q:\\n                row,col=q.popleft()\\n                direction=[[1,0],[-1,0],[0,1],[0,-1]]\\n                for dr,dc in direction:\\n                     r,c=row+dr,col+dc\\n                     if (r in range(rows) and c in range(cols) and (r,c) not in visit and grid[r][c]==\"1\"):\\n                         q.append((r,c))\\n                         visit.add((r,c))\\n                     \\n        for r in range(rows):\\n            for c in range(cols):\\n                if grid[r][c]==\"1\" and ((r,c) not in visit):\\n                    bfs(r,c)\\n                    count+=1\\n        return count\\n        \\n```\\n# DFS Approach\\n```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        if not grid:return 0\\n        rows,cols=len(grid),len(grid[0])\\n        count,visit=0,set()\\n        def dfs(r,c):\\n            stack=[]\\n            stack.append((r,c))\\n            visit.add((r,c))\\n            while stack:\\n                row,col=stack.pop()\\n                direction=[[1,0],[-1,0],[0,1],[0,-1]]\\n                for dr,dc in direction:\\n                     r,c=row+dr,col+dc\\n                     if (r in range(rows) and c in range(cols) and (r,c) not in visit and grid[r][c]==\"1\"):\\n                         stack.append((r,c))\\n                         visit.add((r,c))\\n                     \\n        for r in range(rows):\\n            for c in range(cols):\\n                if grid[r][c]==\"1\" and ((r,c) not in visit):\\n                    dfs(r,c)\\n                    count+=1\\n        return count\\n  ````\\n  # please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        if not grid:return 0\\n        rows,cols=len(grid),len(grid[0])\\n        count,visit=0,set()\\n        def bfs(r,c):\\n            q=deque()\\n            q.append((r,c))\\n            visit.add((r,c))\\n            while q:\\n                row,col=q.popleft()\\n                direction=[[1,0],[-1,0],[0,1],[0,-1]]\\n                for dr,dc in direction:\\n                     r,c=row+dr,col+dc\\n                     if (r in range(rows) and c in range(cols) and (r,c) not in visit and grid[r][c]==\"1\"):\\n                         q.append((r,c))\\n                         visit.add((r,c))\\n                     \\n        for r in range(rows):\\n            for c in range(cols):\\n                if grid[r][c]==\"1\" and ((r,c) not in visit):\\n                    bfs(r,c)\\n                    count+=1\\n        return count\\n        \\n```\n```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        if not grid:return 0\\n        rows,cols=len(grid),len(grid[0])\\n        count,visit=0,set()\\n        def dfs(r,c):\\n            stack=[]\\n            stack.append((r,c))\\n            visit.add((r,c))\\n            while stack:\\n                row,col=stack.pop()\\n                direction=[[1,0],[-1,0],[0,1],[0,-1]]\\n                for dr,dc in direction:\\n                     r,c=row+dr,col+dc\\n                     if (r in range(rows) and c in range(cols) and (r,c) not in visit and grid[r][c]==\"1\"):\\n                         stack.append((r,c))\\n                         visit.add((r,c))\\n                     \\n        for r in range(rows):\\n            for c in range(cols):\\n                if grid[r][c]==\"1\" and ((r,c) not in visit):\\n                    dfs(r,c)\\n                    count+=1\\n        return count\\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 3205744,
                "title": "1-ms-simple-java-beat-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n           int cnt =0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]==\\'1\\')\\n               {\\n                cnt++;\\n                cleargrid(grid,i,j);\\n               }\\n            }   \\n        }\\n        return cnt;\\n    }\\n    public void cleargrid(char [][] grid,int i,int j)\\n    {\\n        if(i<0||j<0||i>=grid.length||j>=grid[0].length||grid[i][j]==\\'0\\')\\n        return ;\\n        grid[i][j]=\\'0\\';\\n        cleargrid(grid,i+1,j);\\n        cleargrid(grid,i,j+1);\\n        cleargrid(grid,i-1,j);\\n        cleargrid(grid,i,j-1);\\n        return;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n           int cnt =0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]==\\'1\\')\\n               {\\n                cnt++;\\n                cleargrid(grid,i,j);\\n               }\\n            }   \\n        }\\n        return cnt;\\n    }\\n    public void cleargrid(char [][] grid,int i,int j)\\n    {\\n        if(i<0||j<0||i>=grid.length||j>=grid[0].length||grid[i][j]==\\'0\\')\\n        return ;\\n        grid[i][j]=\\'0\\';\\n        cleargrid(grid,i+1,j);\\n        cleargrid(grid,i,j+1);\\n        cleargrid(grid,i-1,j);\\n        cleargrid(grid,i,j-1);\\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947375,
                "title": "bfs-using-queue-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int NumIslands(char[][] grid) \\n    {\\n        Queue<(int, int)> queue = new();\\n        (int, int)[] directions = new[] {(-1, 0), (1, 0), (0, -1), (0, 1)};\\n        \\n        int result = 0;\\n        \\n        for (int i = 0; i < grid.Length ; i++)\\n            for (int j = 0; j < grid[i].Length ; j++)\\n            {\\n                if (grid[i][j] == \\'1\\')\\n                {                \\n                    result++;\\n                    queue.Enqueue((i, j));\\n                    while (queue.Count > 0)\\n                    {\\n                        var p = queue.Dequeue();\\n                        foreach (var dir in directions)\\n                        {\\n                            int r = p.Item1 + dir.Item1;\\n                            int c = p.Item2 + dir.Item2;\\n                            \\n                            if(r >=0 && r < grid.Length &&\\n                               c >= 0 && c < grid[r].Length &&\\n                               grid[r][c] == \\'1\\')\\n                            {\\n                                grid[r][c] = \\'2\\';\\n                                queue.Enqueue((r, c));\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumIslands(char[][] grid) \\n    {\\n        Queue<(int, int)> queue = new();\\n        (int, int)[] directions = new[] {(-1, 0), (1, 0), (0, -1), (0, 1)};\\n        \\n        int result = 0;\\n        \\n        for (int i = 0; i < grid.Length ; i++)\\n            for (int j = 0; j < grid[i].Length ; j++)\\n            {\\n                if (grid[i][j] == \\'1\\')\\n                {                \\n                    result++;\\n                    queue.Enqueue((i, j));\\n                    while (queue.Count > 0)\\n                    {\\n                        var p = queue.Dequeue();\\n                        foreach (var dir in directions)\\n                        {\\n                            int r = p.Item1 + dir.Item1;\\n                            int c = p.Item2 + dir.Item2;\\n                            \\n                            if(r >=0 && r < grid.Length &&\\n                               c >= 0 && c < grid[r].Length &&\\n                               grid[r][c] == \\'1\\')\\n                            {\\n                                grid[r][c] = \\'2\\';\\n                                queue.Enqueue((r, c));\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2497800,
                "title": "javascript-short-in-place-dfs",
                "content": "```\\nlet sinkIsland = function(grid, r, c) {\\n    if( r < 0 || c < 0 || r >= grid.length || c >= grid[0].length ) return;\\n    \\n    if( grid[r][c] != 1 ) return;\\n    grid[r][c] = 0;\\n    \\n    sinkIsland(grid, r+1, c);\\n    sinkIsland(grid, r-1, c);\\n    sinkIsland(grid, r, c+1);\\n    sinkIsland(grid, r, c-1);    \\n}\\nvar numIslands = function(grid) {\\n    var i,j;\\n    let n = grid.length, m = grid[0].length;\\n    let ans = 0;\\n    \\n    for( i=0; i<n; i++ ) {\\n        for( j=0; j<m; j++ ) {\\n            if( grid[i][j] == 1 ) {\\n                ans ++;\\n                sinkIsland(grid,i,j);\\n            }\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet sinkIsland = function(grid, r, c) {\\n    if( r < 0 || c < 0 || r >= grid.length || c >= grid[0].length ) return;\\n    \\n    if( grid[r][c] != 1 ) return;\\n    grid[r][c] = 0;\\n    \\n    sinkIsland(grid, r+1, c);\\n    sinkIsland(grid, r-1, c);\\n    sinkIsland(grid, r, c+1);\\n    sinkIsland(grid, r, c-1);    \\n}\\nvar numIslands = function(grid) {\\n    var i,j;\\n    let n = grid.length, m = grid[0].length;\\n    let ans = 0;\\n    \\n    for( i=0; i<n; i++ ) {\\n        for( j=0; j<m; j++ ) {\\n            if( grid[i][j] == 1 ) {\\n                ans ++;\\n                sinkIsland(grid,i,j);\\n            }\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2248769,
                "title": "python-classic-dfs-solution-with-explanation",
                "content": "# Depth-First Search\\n**[DFS](https://en.wikipedia.org/wiki/Depth-first_search)** is an algorithm that traverses through a tree/graph-like structure where it extends as far as possible before backtracking. \\nIn other words: it goes to the deepest end, then goes back and tries other forks. \\n\\nWe iterate through the graph, and if we reach a cell with `1`, then we know it\\'s part of an island. Therefore, we dfs the 4 adjacent directions, and then add 1 to the count of islands. \\n\\nInside dfs function, we check first if the `i` and `j` indexes are within bounds, and then check if the cell is land or not (is `1` or not). \\n\\nWe mark visited cells with `#` to prevent us revisiting it (and adding more to the count). Then we recurse through right, left, up, and down (respectively). \\n\\n```py\\nclass Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        def dfs(grid, i, j):\\n            if i < 0 or j < 0 or i >= m or j >= n or grid[i][j] != \\'1\\':\\n                return\\n            \\n            grid[i][j] = \\'#\\'\\n            dfs(grid, i+1, j)\\n            dfs(grid, i-1, j)\\n            dfs(grid, i, j+1)\\n            dfs(grid, i, j-1)\\n          \\n        m = len(grid)\\n        n = len(grid[0])\\n        count = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \\'1\\':\\n                    dfs(grid, i, j)\\n                    count += 1\\n        return count\\n```\\n**If you liked this, please upvote to support me!**\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```py\\nclass Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        def dfs(grid, i, j):\\n            if i < 0 or j < 0 or i >= m or j >= n or grid[i][j] != \\'1\\':\\n                return\\n            \\n            grid[i][j] = \\'#\\'\\n            dfs(grid, i+1, j)\\n            dfs(grid, i-1, j)\\n            dfs(grid, i, j+1)\\n            dfs(grid, i, j-1)\\n          \\n        m = len(grid)\\n        n = len(grid[0])\\n        count = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \\'1\\':\\n                    dfs(grid, i, j)\\n                    count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2214490,
                "title": "go-simple-easy-to-understand",
                "content": "```\\nfunc numIslands(grid [][]byte) int {\\n    var res int\\n\\n    for row := 0; row < len(grid); row++ {\\n        for column := 0; column < len(grid[0]); column++ {\\n            if grid[row][column] == 49 {\\n                res++\\n                dfs(grid, row, column)\\n            }\\n        }\\n    }\\n    \\n    return res\\n}\\n\\nfunc dfs(grid [][]byte, row int, column int) {\\n    if row < 0 || row > len(grid) - 1 || column < 0 || column > len(grid[0]) - 1 || grid[row][column] == 48 {\\n        return\\n    }\\n    \\n    grid[row][column] = 48\\n    dfs(grid, row - 1, column)\\n    dfs(grid, row + 1, column)\\n    dfs(grid, row, column - 1)\\n    dfs(grid, row, column + 1)\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Go",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nfunc numIslands(grid [][]byte) int {\\n    var res int\\n\\n    for row := 0; row < len(grid); row++ {\\n        for column := 0; column < len(grid[0]); column++ {\\n            if grid[row][column] == 49 {\\n                res++\\n                dfs(grid, row, column)\\n            }\\n        }\\n    }\\n    \\n    return res\\n}\\n\\nfunc dfs(grid [][]byte, row int, column int) {\\n    if row < 0 || row > len(grid) - 1 || column < 0 || column > len(grid[0]) - 1 || grid[row][column] == 48 {\\n        return\\n    }\\n    \\n    grid[row][column] = 48\\n    dfs(grid, row - 1, column)\\n    dfs(grid, row + 1, column)\\n    dfs(grid, row, column - 1)\\n    dfs(grid, row, column + 1)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2094043,
                "title": "typescript-javascript-bfs-and-dfs",
                "content": "```\\n//  Both BFS and DFS\\nfunction numIslands(grid: string[][]): number {\\n    let result = 0;\\n    for (let i = 0; i < grid.length; i ++) {\\n        for (let j = 0; j < grid[i].length; j++) {\\n            if (grid[i][j] == \"1\") {\\n                bfs(grid, i, j); // dfs(grid, i, j);\\n                result += 1;\\n            }\\n        }\\n    }\\n    return result;\\n};\\n\\n// DFS\\nfunction dfs(grid: string[][], r: number, c: number) {\\n    if (grid[r] === undefined || grid[r][c] === undefined || grid[r][c] == \"0\") {\\n        return;\\n    }\\n    grid[r][c] = \"0\";\\n    bfs(grid, r+1, c);\\n    bfs(grid, r-1, c);\\n    bfs(grid, r, c+1);\\n    bfs(grid, r, c-1);\\n}\\n\\n// BFS \\nfunction bfs(grid, x, y) {\\n    let queue = new Array();\\n    const matrix = [[1,0], [-1,0], [0,1],[0,-1]];\\n    queue.push([x,y]);\\n    while (queue.length > 0) {\\n        let len = queue.length;\\n        for (let i = 0; i < len; i++) {\\n            let curr = queue.shift();\\n            for (const dir of matrix) {\\n                let r = curr[0] + dir[0];\\n                let c = curr[1] + dir[1];\\n                if (r < 0 ||  r >= grid.length || c < 0 || c >= grid[0].length || grid[r][c] == \"0\") {\\n                    continue;\\n                }\\n                grid[r][c] = \"0\";\\n                queue.push([r,c]);\\n            }\\n        }   \\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n//  Both BFS and DFS\\nfunction numIslands(grid: string[][]): number {\\n    let result = 0;\\n    for (let i = 0; i < grid.length; i ++) {\\n        for (let j = 0; j < grid[i].length; j++) {\\n            if (grid[i][j] == \"1\") {\\n                bfs(grid, i, j); // dfs(grid, i, j);\\n                result += 1;\\n            }\\n        }\\n    }\\n    return result;\\n};\\n\\n// DFS\\nfunction dfs(grid: string[][], r: number, c: number) {\\n    if (grid[r] === undefined || grid[r][c] === undefined || grid[r][c] == \"0\") {\\n        return;\\n    }\\n    grid[r][c] = \"0\";\\n    bfs(grid, r+1, c);\\n    bfs(grid, r-1, c);\\n    bfs(grid, r, c+1);\\n    bfs(grid, r, c-1);\\n}\\n\\n// BFS \\nfunction bfs(grid, x, y) {\\n    let queue = new Array();\\n    const matrix = [[1,0], [-1,0], [0,1],[0,-1]];\\n    queue.push([x,y]);\\n    while (queue.length > 0) {\\n        let len = queue.length;\\n        for (let i = 0; i < len; i++) {\\n            let curr = queue.shift();\\n            for (const dir of matrix) {\\n                let r = curr[0] + dir[0];\\n                let c = curr[1] + dir[1];\\n                if (r < 0 ||  r >= grid.length || c < 0 || c >= grid[0].length || grid[r][c] == \"0\") {\\n                    continue;\\n                }\\n                grid[r][c] = \"0\";\\n                queue.push([r,c]);\\n            }\\n        }   \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1969647,
                "title": "easy-c-dfs-solution-with-no-extra-space",
                "content": "**Without using visited array *(bool vis[300][300])***\\n```\\nclass Solution {\\nprivate:\\n\\tvoid dfs(vector<vector<char>>& grid, int i, int j, int n, int m) {\\n\\t\\tif (i < 0 || j < 0 || i >= n || j >= m || grid[i][j] != \\'1\\') return;\\n\\t\\tgrid[i][j] = \\'2\\';\\n\\t\\tdfs(grid, i - 1, j, n, m);\\n\\t\\tdfs(grid, i, j - 1, n, m);\\n\\t\\tdfs(grid, i + 1, j, n, m);\\n\\t\\tdfs(grid, i, j + 1, n, m);\\n\\t}\\npublic:\\n\\tint numIslands(vector<vector<char>>& grid) {\\n\\t\\tint n = grid.size();\\n\\t\\tint m = grid[0].size();\\n\\t\\tint ct = 0;\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tfor (int j = 0; j < m; ++j) {\\n\\t\\t\\t\\tif (grid[i][j] == \\'1\\') {\\n\\t\\t\\t\\t\\tdfs(grid, i, j, n, m);\\n\\t\\t\\t\\t\\tct++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ct;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n\\tvoid dfs(vector<vector<char>>& grid, int i, int j, int n, int m) {\\n\\t\\tif (i < 0 || j < 0 || i >= n || j >= m || grid[i][j] != \\'1\\') return;\\n\\t\\tgrid[i][j] = \\'2\\';\\n\\t\\tdfs(grid, i - 1, j, n, m);\\n\\t\\tdfs(grid, i, j - 1, n, m);\\n\\t\\tdfs(grid, i + 1, j, n, m);\\n\\t\\tdfs(grid, i, j + 1, n, m);\\n\\t}\\npublic:\\n\\tint numIslands(vector<vector<char>>& grid) {\\n\\t\\tint n = grid.size();\\n\\t\\tint m = grid[0].size();\\n\\t\\tint ct = 0;\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tfor (int j = 0; j < m; ++j) {\\n\\t\\t\\t\\tif (grid[i][j] == \\'1\\') {\\n\\t\\t\\t\\t\\tdfs(grid, i, j, n, m);\\n\\t\\t\\t\\t\\tct++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ct;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446732,
                "title": "flood-fill-approach-733",
                "content": "```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        count = 0\\n        R, C = len(grid), len(grid[0])\\n        \\n        \\n        def dfs(r, c):\\n            grid[r][c] = \\'0\\'\\n            if r-1 >= 0 and grid[r-1][c] == \\'1\\':\\n                dfs(r-1, c)\\n            if r+1 < R and grid[r+1][c] == \\'1\\':\\n                dfs(r+1, c)\\n            if c+1 < C and grid[r][c+1] == \\'1\\':\\n                dfs(r, c+1)\\n            if c-1 >= 0 and grid[r][c-1] == \\'1\\':\\n                dfs(r, c-1)\\n                \\n                \\n        for row in range(0, len(grid)):\\n            for col in range(0, len(grid[0])):\\n                if grid[row][col] == \\'1\\':\\n                    count += 1\\n                    dfs(row, col)\\n                    \\n        return count\\n        \\n# first we find the 1 valued element using two for loops and then we update their values to 0 so \\n# that when we backtrack (like r-1) then it will not keep on running and when values of all of it\\'s connected\\n# elements become 0, we come out of the dfs(). This keeps on happening as the 2 for loops continue finding the \\'1\\' valued element.\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        count = 0\\n        R, C = len(grid), len(grid[0])\\n        \\n        \\n        def dfs(r, c):\\n            grid[r][c] = \\'0\\'\\n            if r-1 >= 0 and grid[r-1][c] == \\'1\\':\\n                dfs(r-1, c)\\n            if r+1 < R and grid[r+1][c] == \\'1\\':\\n                dfs(r+1, c)\\n            if c+1 < C and grid[r][c+1] == \\'1\\':\\n                dfs(r, c+1)\\n            if c-1 >= 0 and grid[r][c-1] == \\'1\\':\\n                dfs(r, c-1)\\n                \\n                \\n        for row in range(0, len(grid)):\\n            for col in range(0, len(grid[0])):\\n                if grid[row][col] == \\'1\\':\\n                    count += 1\\n                    dfs(row, col)\\n                    \\n        return count\\n        \\n# first we find the 1 valued element using two for loops and then we update their values to 0 so \\n# that when we backtrack (like r-1) then it will not keep on running and when values of all of it\\'s connected\\n# elements become 0, we come out of the dfs(). This keeps on happening as the 2 for loops continue finding the \\'1\\' valued element.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050390,
                "title": "python-simple-union-find-solution",
                "content": "```\\n# Classic Union Find DS\\nclass UnionFind:\\n    \\n    def __init__(self,m,n):\\n        self.parent = [0]*(m*n)\\n        self.size = [1]*(m*n)\\n        \\n        # initally root is itself\\n        for i in range(m*n):\\n            self.parent[i] = i\\n            \\n    # classic Find\\n    def find(self,x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n        \\n    \\n    def union(self, x, y):\\n        px,py = map(self.find, [x,y])\\n        \\n        # if same root no need to join\\n        if px == py:\\n            return\\n        \\n        # if px greater than insert to py\\n        if self.size[px] < self.size[py]:\\n            self.parent[px] = self.parent[py]\\n        \\n        # if py greater than insert to px\\n        elif self.size[px] > self.size[py]:\\n            self.parent[py] = self.parent[px]\\n            \\n        # if same then get to one of the roots\\n        # and then increment that root that got bigger\\n        else:\\n            self.parent[px] = self.parent[py]\\n            self.size[py]+=1\\n        \\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        \\n        # number cell calculator\\n        def numcell(i,j):\\n            return len(grid[0])*i+j\\n            \\n        \\n        m,n = len(grid),len(grid[0])        \\n        dus = UnionFind(m,n)\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                # For each 1 check all 4-dir and if its 1 then unite\\n                # normally a DFS, but this is easier for UF method.\\n                if grid[i][j] == \\'1\\':\\n                    if i + 1 < m and grid[i + 1][j] == \"1\":\\n                        dus.union(numcell(i,j),numcell(i+1,j))\\n                    if i - 1 >= 0 and grid[i - 1][j] == \"1\":\\n                        dus.union(numcell(i,j),numcell(i-1,j))\\n                    if j + 1 < n and grid[i][j + 1] == \"1\":\\n                        dus.union(numcell(i,j),numcell(i,j+1))\\n                    if j - 1 >= 0 and grid[i][j - 1] == \"1\":\\n                        dus.union(numcell(i,j),numcell(i,j - 1))\\n        \\n        # Go through each element with a \\'1\\' and find its\\n        # root. in order not to repeat islands make sure to have\\n        # a freq. If it was never visited then visit that root and \\n        # increment root.\\n        res = 0\\n        freq = [0]*(m*n)\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \\'1\\':\\n                    px = dus.find(numcell(i,j))\\n                    \\n                    if freq[px] == 0:\\n                        res += 1\\n                    freq[px]+=1\\n                                     \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\n# Classic Union Find DS\\nclass UnionFind:\\n    \\n    def __init__(self,m,n):\\n        self.parent = [0]*(m*n)\\n        self.size = [1]*(m*n)\\n        \\n        # initally root is itself\\n        for i in range(m*n):\\n            self.parent[i] = i\\n            \\n    # classic Find\\n    def find(self,x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n        \\n    \\n    def union(self, x, y):\\n        px,py = map(self.find, [x,y])\\n        \\n        # if same root no need to join\\n        if px == py:\\n            return\\n        \\n        # if px greater than insert to py\\n        if self.size[px] < self.size[py]:\\n            self.parent[px] = self.parent[py]\\n        \\n        # if py greater than insert to px\\n        elif self.size[px] > self.size[py]:\\n            self.parent[py] = self.parent[px]\\n            \\n        # if same then get to one of the roots\\n        # and then increment that root that got bigger\\n        else:\\n            self.parent[px] = self.parent[py]\\n            self.size[py]+=1\\n        \\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        \\n        # number cell calculator\\n        def numcell(i,j):\\n            return len(grid[0])*i+j\\n            \\n        \\n        m,n = len(grid),len(grid[0])        \\n        dus = UnionFind(m,n)\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                # For each 1 check all 4-dir and if its 1 then unite\\n                # normally a DFS, but this is easier for UF method.\\n                if grid[i][j] == \\'1\\':\\n                    if i + 1 < m and grid[i + 1][j] == \"1\":\\n                        dus.union(numcell(i,j),numcell(i+1,j))\\n                    if i - 1 >= 0 and grid[i - 1][j] == \"1\":\\n                        dus.union(numcell(i,j),numcell(i-1,j))\\n                    if j + 1 < n and grid[i][j + 1] == \"1\":\\n                        dus.union(numcell(i,j),numcell(i,j+1))\\n                    if j - 1 >= 0 and grid[i][j - 1] == \"1\":\\n                        dus.union(numcell(i,j),numcell(i,j - 1))\\n        \\n        # Go through each element with a \\'1\\' and find its\\n        # root. in order not to repeat islands make sure to have\\n        # a freq. If it was never visited then visit that root and \\n        # increment root.\\n        res = 0\\n        freq = [0]*(m*n)\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \\'1\\':\\n                    px = dus.find(numcell(i,j))\\n                    \\n                    if freq[px] == 0:\\n                        res += 1\\n                    freq[px]+=1\\n                                     \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1036341,
                "title": "java-easy-to-understand-solution",
                "content": "```\\npublic int numIslands(char[][] grid) {\\n        boolean [][] visited = new boolean[grid.length][grid[0].length];\\n        int countIslands = 0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]==\\'1\\' && visited[i][j]==false){\\n                    countIslands(grid,i,j,visited);\\n                    countIslands++;\\n                }\\n            }\\n        }\\n        return countIslands;\\n    }\\n    \\n    public void countIslands(char[][] grid, int i, int j, boolean [][] visited){\\n         if(i<0 || i>= grid.length || j<0 || j>=grid[0].length || grid[i][j]==\\'0\\' || visited[i][j]==true){\\n            return;\\n        }\\n        visited[i][j]=true;\\n        // Travel in all direction: north, east, south and west.\\n        countIslands(grid, i-1, j, visited);// North\\n        countIslands(grid, i, j+1, visited);// East\\n        countIslands(grid, i+1, j, visited);// South\\n        countIslands(grid, i, j-1, visited);// West\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int numIslands(char[][] grid) {\\n        boolean [][] visited = new boolean[grid.length][grid[0].length];\\n        int countIslands = 0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]==\\'1\\' && visited[i][j]==false){\\n                    countIslands(grid,i,j,visited);\\n                    countIslands++;\\n                }\\n            }\\n        }\\n        return countIslands;\\n    }\\n    \\n    public void countIslands(char[][] grid, int i, int j, boolean [][] visited){\\n         if(i<0 || i>= grid.length || j<0 || j>=grid[0].length || grid[i][j]==\\'0\\' || visited[i][j]==true){\\n            return;\\n        }\\n        visited[i][j]=true;\\n        // Travel in all direction: north, east, south and west.\\n        countIslands(grid, i-1, j, visited);// North\\n        countIslands(grid, i, j+1, visited);// East\\n        countIslands(grid, i+1, j, visited);// South\\n        countIslands(grid, i, j-1, visited);// West\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 583519,
                "title": "java-solution-using-dfs",
                "content": "```\\nclass Solution {\\n    public void dfs(char[][] grid, int row, int col) {\\n        if (grid[row][col] == \\'0\\') {\\n            return;\\n        }\\n        \\n        grid[row][col] = \\'0\\';\\n        \\n        if (row+1 < grid.length) {\\n            dfs(grid, row+1, col);\\n        }\\n        \\n        if (row-1 >= 0) {\\n            dfs(grid, row-1, col);\\n        }\\n        \\n        if (col+1 < grid[0].length) {\\n            dfs(grid, row, col+1);\\n        }\\n        \\n        if (col-1 >= 0) {\\n            dfs(grid, row, col-1);\\n        }\\n    }\\n    \\n    public int numIslands(char[][] grid) {\\n        int count = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    dfs(grid,i,j);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void dfs(char[][] grid, int row, int col) {\\n        if (grid[row][col] == \\'0\\') {\\n            return;\\n        }\\n        \\n        grid[row][col] = \\'0\\';\\n        \\n        if (row+1 < grid.length) {\\n            dfs(grid, row+1, col);\\n        }\\n        \\n        if (row-1 >= 0) {\\n            dfs(grid, row-1, col);\\n        }\\n        \\n        if (col+1 < grid[0].length) {\\n            dfs(grid, row, col+1);\\n        }\\n        \\n        if (col-1 >= 0) {\\n            dfs(grid, row, col-1);\\n        }\\n    }\\n    \\n    public int numIslands(char[][] grid) {\\n        int count = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    dfs(grid,i,j);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 542339,
                "title": "py3-very-easy-sol-faster-than-96-16",
                "content": "```\\ndef doDfs(grid,i,j):\\n    deq = []\\n    deq.append([i,j])\\n    while deq:\\n        x,y=deq.pop()\\n        grid[x][y]=\"v\" #visited\\n        if x+1<len(grid) and grid[x+1][y]==\"1\":\\n            deq.append([x+1,y])\\n        if y+1<len(grid[0]) and grid[x][y+1]==\"1\":\\n            deq.append([x,y+1])\\n        if y-1>=0 and grid[x][y-1]==\"1\":\\n            deq.append([x,y-1])\\n        if x-1>=0 and grid[x-1][y]==\"1\":\\n            deq.append([x-1,y])\\n            \\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        count= 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]==\"1\":\\n                    doDfs(grid,i,j)\\n                    count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\ndef doDfs(grid,i,j):\\n    deq = []\\n    deq.append([i,j])\\n    while deq:\\n        x,y=deq.pop()\\n        grid[x][y]=\"v\" #visited\\n        if x+1<len(grid) and grid[x+1][y]==\"1\":\\n            deq.append([x+1,y])\\n        if y+1<len(grid[0]) and grid[x][y+1]==\"1\":\\n            deq.append([x,y+1])\\n        if y-1>=0 and grid[x][y-1]==\"1\":\\n            deq.append([x,y-1])\\n        if x-1>=0 and grid[x-1][y]==\"1\":\\n            deq.append([x-1,y])\\n            \\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        count= 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]==\"1\":\\n                    doDfs(grid,i,j)\\n                    count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 484397,
                "title": "python3-bfs-iterative-well-commented",
                "content": "```\\nfrom collections import deque\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        ctr = 0\\n\\t\\t# This module will initiate the\\n\\t\\t# BFS traversal.\\n        for row in range(0, len(grid)):\\n            for col in range(0, len(grid[0])):\\n\\t\\t\\t\\t# Initiate BFS if the value\\n\\t\\t\\t\\t# is 1.\\n                if grid[row][col] == \\'1\\':\\n\\t\\t\\t\\t\\t# Update the value in matrix\\n                    grid[row][col] = \\'0\\'\\n                    self.traverse_bfs(grid, row, col)\\n\\t\\t\\t\\t\\t# Increment counter\\n                    ctr += 1\\n        return ctr\\n\\t# This module will traverse\\n\\t# the grapf using BFS.\\n    def traverse_bfs(self, grid, r, c):\\n        que = deque()\\n\\t\\t# From each coordinate the trversal can\\n\\t\\t# be performed in 4 possible directions.\\n        possible_positions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\n\\t\\t# Append the coordinate in the BFS queue.\\n        que.append((r, c))\\n\\t\\t# Iterate for all the values in Queue.\\n        while que:\\n\\t\\t\\t# Get the traversed coordinate.\\n            (a, b) = que.popleft()\\n\\t\\t\\t# Iterate through all the possible\\n\\t\\t\\t# positions for traversed coordinate.\\n            for position in possible_positions:\\n\\t\\t\\t\\t# Check if the position is valid\\n\\t\\t\\t\\t# and if the value at position is\\n\\t\\t\\t\\t# \\'1\\'.\\n                if (self.validity_check(grid, a + position[0], b + position[1])\\n\\t\\t\\t\\t\\tand grid[a + position[0]][b + position[1]] == \\'1\\'):\\n                    grid[a + position[0]][b + position[1]] = \\'0\\'\\n\\t\\t\\t\\t\\t# Append the coordinate in BFS queue.\\n                    que.append((a + position[0], b + position[1]))\\n\\t# This module checks the validity of\\n\\t# the position to be traversed.\\n    def validity_check(self, grid, c_row, c_col):\\n\\t\\t# The valid position muct have a row and\\n\\t\\t# column value greater or equal to 0 and\\n\\t\\t# must be less the the length.\\n        if (c_row >= 0 and c_row < len(grid)\\n            and c_col >= 0 and c_col < len(grid[0])):\\n            return True\\n\\t\\t# Else\\n        return False",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        ctr = 0\\n\\t\\t# This module will initiate the\\n\\t\\t# BFS traversal.\\n        for row in range(0, len(grid)):\\n            for col in range(0, len(grid[0])):\\n\\t\\t\\t\\t# Initiate BFS if the value\\n\\t\\t\\t\\t# is 1.\\n                if grid[row][col] == \\'1\\':\\n\\t\\t\\t\\t\\t# Update the value in matrix\\n                    grid[row][col] = \\'0\\'\\n                    self.traverse_bfs(grid, row, col)\\n\\t\\t\\t\\t\\t# Increment counter\\n                    ctr += 1\\n        return ctr\\n\\t# This module will traverse\\n\\t# the grapf using BFS.\\n    def traverse_bfs(self, grid, r, c):\\n        que = deque()\\n\\t\\t# From each coordinate the trversal can\\n\\t\\t# be performed in 4 possible directions.\\n        possible_positions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\n\\t\\t# Append the coordinate in the BFS queue.\\n        que.append((r, c))\\n\\t\\t# Iterate for all the values in Queue.\\n        while que:\\n\\t\\t\\t# Get the traversed coordinate.\\n            (a, b) = que.popleft()\\n\\t\\t\\t# Iterate through all the possible\\n\\t\\t\\t# positions for traversed coordinate.\\n            for position in possible_positions:\\n\\t\\t\\t\\t# Check if the position is valid\\n\\t\\t\\t\\t# and if the value at position is\\n\\t\\t\\t\\t# \\'1\\'.\\n                if (self.validity_check(grid, a + position[0], b + position[1])\\n\\t\\t\\t\\t\\tand grid[a + position[0]][b + position[1]] == \\'1\\'):\\n                    grid[a + position[0]][b + position[1]] = \\'0\\'\\n\\t\\t\\t\\t\\t# Append the coordinate in BFS queue.\\n                    que.append((a + position[0], b + position[1]))\\n\\t# This module checks the validity of\\n\\t# the position to be traversed.\\n    def validity_check(self, grid, c_row, c_col):\\n\\t\\t# The valid position muct have a row and\\n\\t\\t# column value greater or equal to 0 and\\n\\t\\t# must be less the the length.\\n        if (c_row >= 0 and c_row < len(grid)\\n            and c_col >= 0 and c_col < len(grid[0])):\\n            return True\\n\\t\\t# Else\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 464655,
                "title": "python-union-find-commented-clean-and-easy",
                "content": "```\\n# Approach : Using Union Find.  \\nclass Solution(object):\\n\\n    # the number of islands using\\n    # Disjoint Set data structure.\\n\\n    # Class to represent\\n    # Disjoint Set Data structure\\n    class DisjointUnionSets(object):\\n        def __init__(self, n):\\n            self.rank = [0] * n\\n            self.parent = [0] * n\\n            self.n = n\\n            self.makeSet()\\n\\n        def makeSet(self):\\n\\n            # Initially, all elements are in their\\n            # own set.\\n            for i in range(self.n):\\n                self.parent[i] = i\\n\\n                # Finds the representative of the set that x\\n\\n        # is an element of\\n        def find(self, x):\\n            if (self.parent[x] != x):\\n                # if x is not the parent of itself,\\n                # then x is not the representative of\\n                # its set.\\n                # so we recursively call Find on its parent\\n                # and move i\\'s node directly under the\\n                # representative of this set\\n                return self.find(self.parent[x])\\n            return x\\n\\n            # Unites the set that includes x and\\n\\n        # the set that includes y\\n        def Union(self, x, y):\\n\\n            # Find the representatives(or the root nodes)\\n            # for x an y\\n            xRoot = self.find(x)\\n            yRoot = self.find(y)\\n\\n            # Elements are in the same set,\\n            # no need to unite anything.\\n            if xRoot == yRoot:\\n                return\\n\\n            # If x\\'s rank is less than y\\'s rank\\n            # Then move x under y so that depth of tree\\n            # remains less\\n            if self.rank[xRoot] < self.rank[yRoot]:\\n                self.parent[xRoot] = yRoot\\n\\n                # Else if y\\'s rank is less than x\\'s rank\\n            # Then move y under x so that depth of tree\\n            # remains less\\n            elif self.rank[yRoot] < self.rank[xRoot]:\\n                self.parent[yRoot] = xRoot\\n\\n            else:\\n\\n                # Else if their ranks are the same\\n                # Then move y under x (doesn\\'t matter\\n                # which one goes where)\\n                self.parent[yRoot] = xRoot\\n\\n                # And increment the result tree\\'s\\n                # rank by 1\\n                self.rank[xRoot] = self.rank[xRoot] + 1\\n\\n    # Returns number of islands in a[][]\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid:\\n            return 0\\n        rowCount = len(grid)\\n        colCount = len(grid[0])\\n\\n        dus = self.DisjointUnionSets(rowCount * colCount)\\n\\n        # The following loop checks for its neighbours\\n        # and unites the indexes if both are 1.\\n        for rowIdx in range(0, rowCount):\\n            for colIdx in range(0, colCount):\\n\\n                # If cell is 0, nothing to do\\n                if grid[rowIdx][colIdx] == \"0\":\\n                    continue\\n\\n                # Check all 4 neighbours and do a Union\\n                # with neighbour\\'s set if neighbour is\\n                # also 1\\n                if rowIdx + 1 < rowCount and grid[rowIdx + 1][colIdx] == \"1\":\\n                    dus.Union(rowIdx * (colCount) + colIdx, (rowIdx + 1) * (colCount) + colIdx)\\n\\n                if rowIdx - 1 >= 0 and grid[rowIdx - 1][colIdx] == \"1\":\\n                    dus.Union(rowIdx * (colCount) + colIdx, (rowIdx - 1) * (colCount) + colIdx)\\n\\n                if colIdx + 1 < colCount and grid[rowIdx][colIdx + 1] == \"1\":\\n                    dus.Union(rowIdx * (colCount) + colIdx, (rowIdx) * (colCount) + colIdx + 1)\\n\\n                if colIdx - 1 >= 0 and grid[rowIdx][colIdx - 1] == \"1\":\\n                    dus.Union(rowIdx * (colCount) + colIdx, (rowIdx) * (colCount) + colIdx - 1)\\n\\n        # Array to note down frequency of each set\\n        frequencyArray = [0] * (rowCount * colCount)\\n        numberOfIslands = 0\\n        for rowIdx in range(rowCount):\\n            for colIdx in range(colCount):\\n                gridVal = grid[rowIdx][colIdx]\\n                if gridVal == \"1\":\\n                    x = dus.find(rowIdx * colCount + colIdx)\\n\\n                    # If frequency of set is 0,\\n                    # increment numberOfIslands\\n                    if frequencyArray[x] == 0:\\n                        numberOfIslands += 1\\n                        frequencyArray[x] += 1\\n                    else:\\n                        frequencyArray[x] += 1\\n        return numberOfIslands\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\n# Approach : Using Union Find.  \\nclass Solution(object):\\n\\n    # the number of islands using\\n    # Disjoint Set data structure.\\n\\n    # Class to represent\\n    # Disjoint Set Data structure\\n    class DisjointUnionSets(object):\\n        def __init__(self, n):\\n            self.rank = [0] * n\\n            self.parent = [0] * n\\n            self.n = n\\n            self.makeSet()\\n\\n        def makeSet(self):\\n\\n            # Initially, all elements are in their\\n            # own set.\\n            for i in range(self.n):\\n                self.parent[i] = i\\n\\n                # Finds the representative of the set that x\\n\\n        # is an element of\\n        def find(self, x):\\n            if (self.parent[x] != x):\\n                # if x is not the parent of itself,\\n                # then x is not the representative of\\n                # its set.\\n                # so we recursively call Find on its parent\\n                # and move i\\'s node directly under the\\n                # representative of this set\\n                return self.find(self.parent[x])\\n            return x\\n\\n            # Unites the set that includes x and\\n\\n        # the set that includes y\\n        def Union(self, x, y):\\n\\n            # Find the representatives(or the root nodes)\\n            # for x an y\\n            xRoot = self.find(x)\\n            yRoot = self.find(y)\\n\\n            # Elements are in the same set,\\n            # no need to unite anything.\\n            if xRoot == yRoot:\\n                return\\n\\n            # If x\\'s rank is less than y\\'s rank\\n            # Then move x under y so that depth of tree\\n            # remains less\\n            if self.rank[xRoot] < self.rank[yRoot]:\\n                self.parent[xRoot] = yRoot\\n\\n                # Else if y\\'s rank is less than x\\'s rank\\n            # Then move y under x so that depth of tree\\n            # remains less\\n            elif self.rank[yRoot] < self.rank[xRoot]:\\n                self.parent[yRoot] = xRoot\\n\\n            else:\\n\\n                # Else if their ranks are the same\\n                # Then move y under x (doesn\\'t matter\\n                # which one goes where)\\n                self.parent[yRoot] = xRoot\\n\\n                # And increment the result tree\\'s\\n                # rank by 1\\n                self.rank[xRoot] = self.rank[xRoot] + 1\\n\\n    # Returns number of islands in a[][]\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid:\\n            return 0\\n        rowCount = len(grid)\\n        colCount = len(grid[0])\\n\\n        dus = self.DisjointUnionSets(rowCount * colCount)\\n\\n        # The following loop checks for its neighbours\\n        # and unites the indexes if both are 1.\\n        for rowIdx in range(0, rowCount):\\n            for colIdx in range(0, colCount):\\n\\n                # If cell is 0, nothing to do\\n                if grid[rowIdx][colIdx] == \"0\":\\n                    continue\\n\\n                # Check all 4 neighbours and do a Union\\n                # with neighbour\\'s set if neighbour is\\n                # also 1\\n                if rowIdx + 1 < rowCount and grid[rowIdx + 1][colIdx] == \"1\":\\n                    dus.Union(rowIdx * (colCount) + colIdx, (rowIdx + 1) * (colCount) + colIdx)\\n\\n                if rowIdx - 1 >= 0 and grid[rowIdx - 1][colIdx] == \"1\":\\n                    dus.Union(rowIdx * (colCount) + colIdx, (rowIdx - 1) * (colCount) + colIdx)\\n\\n                if colIdx + 1 < colCount and grid[rowIdx][colIdx + 1] == \"1\":\\n                    dus.Union(rowIdx * (colCount) + colIdx, (rowIdx) * (colCount) + colIdx + 1)\\n\\n                if colIdx - 1 >= 0 and grid[rowIdx][colIdx - 1] == \"1\":\\n                    dus.Union(rowIdx * (colCount) + colIdx, (rowIdx) * (colCount) + colIdx - 1)\\n\\n        # Array to note down frequency of each set\\n        frequencyArray = [0] * (rowCount * colCount)\\n        numberOfIslands = 0\\n        for rowIdx in range(rowCount):\\n            for colIdx in range(colCount):\\n                gridVal = grid[rowIdx][colIdx]\\n                if gridVal == \"1\":\\n                    x = dus.find(rowIdx * colCount + colIdx)\\n\\n                    # If frequency of set is 0,\\n                    # increment numberOfIslands\\n                    if frequencyArray[x] == 0:\\n                        numberOfIslands += 1\\n                        frequencyArray[x] += 1\\n                    else:\\n                        frequencyArray[x] += 1\\n        return numberOfIslands\\n```",
                "codeTag": "Java"
            },
            {
                "id": 342666,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    private int n;\\n    private int m;\\n\\n    public int numIslands(char[][] grid) {\\n        int count = 0;\\n        n = grid.length;\\n        if (n == 0) return 0;\\n        m = grid[0].length;\\n        for (int i = 0; i < n; i++){\\n            for (int j = 0; j < m; j++)\\n                if (grid[i][j] == \\'1\\') {\\n                    DFSMarking(grid, i, j);\\n                    ++count;\\n                }\\n        }    \\n        return count;\\n    }\\n\\n    private void DFSMarking(char[][] grid, int i, int j) {\\n        if (i < 0 || j < 0 || i >= n || j >= m || grid[i][j] != \\'1\\') return;\\n        grid[i][j] = \\'0\\';\\n        DFSMarking(grid, i + 1, j);\\n        DFSMarking(grid, i - 1, j);\\n        DFSMarking(grid, i, j + 1);\\n        DFSMarking(grid, i, j - 1);\\n    }\\n}\\n```\\n\\nRuntime: 1 ms, faster than 100.00% of Java online submissions for Number of Islands.\\nMemory Usage: 40.8 MB, less than 93.78% of Java online submissions for Number of Islands.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int n;\\n    private int m;\\n\\n    public int numIslands(char[][] grid) {\\n        int count = 0;\\n        n = grid.length;\\n        if (n == 0) return 0;\\n        m = grid[0].length;\\n        for (int i = 0; i < n; i++){\\n            for (int j = 0; j < m; j++)\\n                if (grid[i][j] == \\'1\\') {\\n                    DFSMarking(grid, i, j);\\n                    ++count;\\n                }\\n        }    \\n        return count;\\n    }\\n\\n    private void DFSMarking(char[][] grid, int i, int j) {\\n        if (i < 0 || j < 0 || i >= n || j >= m || grid[i][j] != \\'1\\') return;\\n        grid[i][j] = \\'0\\';\\n        DFSMarking(grid, i + 1, j);\\n        DFSMarking(grid, i - 1, j);\\n        DFSMarking(grid, i, j + 1);\\n        DFSMarking(grid, i, j - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294326,
                "title": "c-dfs",
                "content": "```\\npublic class Solution {\\n    int n = 0;\\n    int m = 0;\\n    public int NumIslands(char[][] grid) {\\n        n = grid.Length;\\n        if (n == 0) return 0;\\n        m = grid[0].Length;\\n\\n        var isVisited = new bool[n, m];\\n\\n        var count = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (!isVisited[i, j] && grid[i][j] == \\'1\\') {\\n                    DFS(grid, i, j, isVisited);\\n                    count++;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    private void DFS(char[][] grid, int x, int y, bool[,] isVisited) {\\n        if (x >= n || x < 0 || y >= m || y < 0) {\\n            return;\\n        }\\n\\n        if (isVisited[x, y]) return;\\n        if (grid[x][y] == \\'0\\') return;\\n\\n        isVisited[x, y] = true;\\n\\n        var directions = new (int, int)[] { (0, 1), (0, -1), (1, 0), (-1, 0) };\\n\\n        foreach (var direction in directions) {\\n            var nextX = x + direction.Item1;\\n            var nextY = y + direction.Item2;\\n\\n            DFS(grid, nextX, nextY, isVisited);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    int n = 0;\\n    int m = 0;\\n    public int NumIslands(char[][] grid) {\\n        n = grid.Length;\\n        if (n == 0) return 0;\\n        m = grid[0].Length;\\n\\n        var isVisited = new bool[n, m];\\n\\n        var count = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (!isVisited[i, j] && grid[i][j] == \\'1\\') {\\n                    DFS(grid, i, j, isVisited);\\n                    count++;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    private void DFS(char[][] grid, int x, int y, bool[,] isVisited) {\\n        if (x >= n || x < 0 || y >= m || y < 0) {\\n            return;\\n        }\\n\\n        if (isVisited[x, y]) return;\\n        if (grid[x][y] == \\'0\\') return;\\n\\n        isVisited[x, y] = true;\\n\\n        var directions = new (int, int)[] { (0, 1), (0, -1), (1, 0), (-1, 0) };\\n\\n        foreach (var direction in directions) {\\n            var nextX = x + direction.Item1;\\n            var nextY = y + direction.Item2;\\n\\n            DFS(grid, nextX, nextY, isVisited);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 197026,
                "title": "3-solutions-in-go-golang",
                "content": "I dont like to mutate the grid, so i create a hashtable/dummyarray for visited territories. It seems like the dfs approach(with a dummy array) is the easiest to understand and it is the fastest\\n\\n**Approach 1:** \\n- dfs, hashtable for visited island territories\\n- runtime: 32ms, beats 9.4%\\n```\\nfunc numIslands(grid [][]byte) int {\\n\\tvisited := make(map[string]bool)\\n\\tresult := 0\\n\\tfor i := 0; i < len(grid); i++ {\\n\\t\\tfor j := 0; j < len(grid[0]); j++ {\\n\\t\\t\\tkey := strconv.Itoa(i) + \",\" + strconv.Itoa(j)\\n\\t\\t\\t_, existed := visited[key]\\n\\t\\t\\tif grid[i][j] == \\'1\\' && !existed {\\n\\t\\t\\t\\tdfs(grid, i, j, visited)\\n\\t\\t\\t\\tresult++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n\\nfunc dfs(grid [][]byte, i int, j int, visited map[string]bool) {\\n\\tif i < 0 || i+1 > len(grid) || j < 0 || j+1 > len(grid[0]) {\\n\\t\\treturn\\n\\t}\\n\\tkey := strconv.Itoa(i) + \",\" + strconv.Itoa(j)\\n\\t_, existed := visited[key]\\n\\tif grid[i][j] == \\'1\\' && !existed {\\n\\t\\tkey := strconv.Itoa(i) + \",\" + strconv.Itoa(j)\\n\\t\\tvisited[key] = true\\n\\t\\tdfs(grid, i-1, j, visited)\\n\\t\\tdfs(grid, i+1, j, visited)\\n\\t\\tdfs(grid, i, j-1, visited)\\n\\t\\tdfs(grid, i, j+1, visited)\\n\\t}\\n}\\n```\\n**Approach 2**\\n- dfs, dummy array for visited island territories\\n- runtime: 0ms, beats 100%\\n```\\nfunc numIslands(grid [][]byte) int {\\n\\tvisited := make([][]bool, len(grid))\\n\\tfor i := range visited {\\n\\t\\tvisited[i] = make([]bool, len(grid[i]))\\n\\t}\\n\\tresult := 0\\n\\tfor i := 0; i < len(grid); i++ {\\n\\t\\tfor j := 0; j < len(grid[0]); j++ {\\n\\t\\t\\tif grid[i][j] == \\'1\\' && !visited[i][j] {\\n\\t\\t\\t\\tdfs(grid, i, j, visited)\\n\\t\\t\\t\\tresult++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n\\nfunc dfs(grid [][]byte, i int, j int, visited [][]bool) {\\n\\tif i < 0 || i+1 > len(grid) || j < 0 || j+1 > len(grid[0]) {\\n\\t\\treturn\\n\\t}\\n\\tif grid[i][j] == \\'1\\' && !visited[i][j] {\\n\\t\\tvisited[i][j] = true\\n\\t\\tdfs(grid, i-1, j, visited)\\n\\t\\tdfs(grid, i+1, j, visited)\\n\\t\\tdfs(grid, i, j-1, visited)\\n\\t\\tdfs(grid, i, j+1, visited)\\n\\t}\\n}\\n```\\n**Approach 3**\\n- bfs, queue for coordinates\\n- runtime: 4ms, beats 50.43%\\n```\\nfunc numIslands(grid [][]byte) int {\\n\\tvisited := make([][]bool, len(grid))\\n\\tfor i := range visited {\\n\\t\\tvisited[i] = make([]bool, len(grid[i]))\\n\\t}\\n\\tresult := 0\\n\\tfor i := 0; i < len(grid); i++ {\\n\\t\\tfor j := 0; j < len(grid[0]); j++ {\\n\\t\\t\\tif grid[i][j] == \\'1\\' && !visited[i][j] {\\n\\t\\t\\t\\tresult++\\n\\t\\t\\t\\tbfs(grid, i, j, visited)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n\\nfunc bfs(grid [][]byte, i int, j int, visited [][]bool) {\\n\\tvar queue []Queue\\n\\tqueue = append(queue, Queue{i, j})\\n\\tfor len(queue) > 0 {\\n\\t\\thead := queue[0]\\n\\t\\trow := head.Row\\n\\t\\tcol := head.Col\\n\\t\\tqueue = queue[1:]\\n\\t\\tif grid[row][col] == \\'1\\' && !visited[row][col] {\\n\\t\\t\\tvisited[row][col] = true\\n\\t\\t\\tif row-1 >= 0 {\\n\\t\\t\\t\\tqueue = append(queue, Queue{row - 1, col})\\n\\t\\t\\t}\\n\\t\\t\\tif row+1 < len(grid) {\\n\\t\\t\\t\\tqueue = append(queue, Queue{row + 1, col})\\n\\t\\t\\t}\\n\\t\\t\\tif col-1 >= 0 {\\n\\t\\t\\t\\tqueue = append(queue, Queue{row, col - 1})\\n\\t\\t\\t}\\n\\t\\t\\tif col+1 < len(grid[0]) {\\n\\t\\t\\t\\tqueue = append(queue, Queue{row, col + 1})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\ntype Queue struct {\\n\\tRow int\\n\\tCol int\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc numIslands(grid [][]byte) int {\\n\\tvisited := make(map[string]bool)\\n\\tresult := 0\\n\\tfor i := 0; i < len(grid); i++ {\\n\\t\\tfor j := 0; j < len(grid[0]); j++ {\\n\\t\\t\\tkey := strconv.Itoa(i) + \",\" + strconv.Itoa(j)\\n\\t\\t\\t_, existed := visited[key]\\n\\t\\t\\tif grid[i][j] == \\'1\\' && !existed {\\n\\t\\t\\t\\tdfs(grid, i, j, visited)\\n\\t\\t\\t\\tresult++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n\\nfunc dfs(grid [][]byte, i int, j int, visited map[string]bool) {\\n\\tif i < 0 || i+1 > len(grid) || j < 0 || j+1 > len(grid[0]) {\\n\\t\\treturn\\n\\t}\\n\\tkey := strconv.Itoa(i) + \",\" + strconv.Itoa(j)\\n\\t_, existed := visited[key]\\n\\tif grid[i][j] == \\'1\\' && !existed {\\n\\t\\tkey := strconv.Itoa(i) + \",\" + strconv.Itoa(j)\\n\\t\\tvisited[key] = true\\n\\t\\tdfs(grid, i-1, j, visited)\\n\\t\\tdfs(grid, i+1, j, visited)\\n\\t\\tdfs(grid, i, j-1, visited)\\n\\t\\tdfs(grid, i, j+1, visited)\\n\\t}\\n}\\n```\n```\\nfunc numIslands(grid [][]byte) int {\\n\\tvisited := make([][]bool, len(grid))\\n\\tfor i := range visited {\\n\\t\\tvisited[i] = make([]bool, len(grid[i]))\\n\\t}\\n\\tresult := 0\\n\\tfor i := 0; i < len(grid); i++ {\\n\\t\\tfor j := 0; j < len(grid[0]); j++ {\\n\\t\\t\\tif grid[i][j] == \\'1\\' && !visited[i][j] {\\n\\t\\t\\t\\tdfs(grid, i, j, visited)\\n\\t\\t\\t\\tresult++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n\\nfunc dfs(grid [][]byte, i int, j int, visited [][]bool) {\\n\\tif i < 0 || i+1 > len(grid) || j < 0 || j+1 > len(grid[0]) {\\n\\t\\treturn\\n\\t}\\n\\tif grid[i][j] == \\'1\\' && !visited[i][j] {\\n\\t\\tvisited[i][j] = true\\n\\t\\tdfs(grid, i-1, j, visited)\\n\\t\\tdfs(grid, i+1, j, visited)\\n\\t\\tdfs(grid, i, j-1, visited)\\n\\t\\tdfs(grid, i, j+1, visited)\\n\\t}\\n}\\n```\n```\\nfunc numIslands(grid [][]byte) int {\\n\\tvisited := make([][]bool, len(grid))\\n\\tfor i := range visited {\\n\\t\\tvisited[i] = make([]bool, len(grid[i]))\\n\\t}\\n\\tresult := 0\\n\\tfor i := 0; i < len(grid); i++ {\\n\\t\\tfor j := 0; j < len(grid[0]); j++ {\\n\\t\\t\\tif grid[i][j] == \\'1\\' && !visited[i][j] {\\n\\t\\t\\t\\tresult++\\n\\t\\t\\t\\tbfs(grid, i, j, visited)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n\\nfunc bfs(grid [][]byte, i int, j int, visited [][]bool) {\\n\\tvar queue []Queue\\n\\tqueue = append(queue, Queue{i, j})\\n\\tfor len(queue) > 0 {\\n\\t\\thead := queue[0]\\n\\t\\trow := head.Row\\n\\t\\tcol := head.Col\\n\\t\\tqueue = queue[1:]\\n\\t\\tif grid[row][col] == \\'1\\' && !visited[row][col] {\\n\\t\\t\\tvisited[row][col] = true\\n\\t\\t\\tif row-1 >= 0 {\\n\\t\\t\\t\\tqueue = append(queue, Queue{row - 1, col})\\n\\t\\t\\t}\\n\\t\\t\\tif row+1 < len(grid) {\\n\\t\\t\\t\\tqueue = append(queue, Queue{row + 1, col})\\n\\t\\t\\t}\\n\\t\\t\\tif col-1 >= 0 {\\n\\t\\t\\t\\tqueue = append(queue, Queue{row, col - 1})\\n\\t\\t\\t}\\n\\t\\t\\tif col+1 < len(grid[0]) {\\n\\t\\t\\t\\tqueue = append(queue, Queue{row, col + 1})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\ntype Queue struct {\\n\\tRow int\\n\\tCol int\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 56647,
                "title": "my-java-solution-iterative-dfs-stack",
                "content": "Hello! I think that the code is fairly straightforward and as many have said on here, it is a pretty cool DFS problem. The general idea of my solution is to switch the '1's to '0's if an island is found. Since an island can have more than one '1's interconnected, I used a stack to keep track of the surrounding '1's and switch them to '0's accordingly. This way, the loop can continue effortlessly without having to come across an island that has already been found. \\n\\nFeel free to let me know if this solution can be improved upon OR if you have any queries for me. :]\\n\\n    public int numIslands(char[][] grid) {\\n            int numOfRow = grid.length;\\n            if(numOfRow == 0)\\n                return 0;\\n            int numOfCol = grid[0].length;\\n            int numOfIslands = 0;\\n            Stack<Integer> gridTrackerOfRow = new Stack<Integer>();\\n            Stack<Integer> gridTrackerOfCol = new Stack<Integer>();\\n            for(int i = 0; i < numOfRow; i++){\\n                for(int j = 0; j < numOfCol; j++){\\n                    if(grid[i][j] == '1'){\\n                        gridTrackerOfRow.push(i);\\n                        gridTrackerOfCol.push(j);\\n                        while(!gridTrackerOfRow.isEmpty() && !gridTrackerOfCol.isEmpty()){\\n                            int x = gridTrackerOfRow.pop();\\n                            int y = gridTrackerOfCol.pop();\\n                            grid[x][y] = '0';\\n                            \\n                            if(y+1 < numOfCol && grid[x][y+1] == '1'){\\n                                gridTrackerOfRow.push(x);\\n                                gridTrackerOfCol.push(y+1);\\n                            }\\n                            if(y-1 >= 0 && grid[x][y-1] == '1'){\\n                                gridTrackerOfRow.push(x);\\n                                gridTrackerOfCol.push(y-1);\\n                            }\\n                            if(x+1 < numOfRow && grid[x+1][y] == '1'){\\n                                gridTrackerOfRow.push(x+1);\\n                                gridTrackerOfCol.push(y);\\n                            }\\n                            if(x-1 >= 0 && grid[x-1][y] == '1'){\\n                                gridTrackerOfRow.push(x-1);\\n                                gridTrackerOfCol.push(y);\\n                            }\\n                        }\\n                        numOfIslands++;\\n                    }\\n                }\\n            }\\n            \\n            return numOfIslands;\\n        }",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Iterator"
                ],
                "code": "Hello! I think that the code is fairly straightforward and as many have said on here, it is a pretty cool DFS problem. The general idea of my solution is to switch the '1's to '0's if an island is found. Since an island can have more than one '1's interconnected, I used a stack to keep track of the surrounding '1's and switch them to '0's accordingly. This way, the loop can continue effortlessly without having to come across an island that has already been found. \\n\\nFeel free to let me know if this solution can be improved upon OR if you have any queries for me. :]\\n\\n    public int numIslands(char[][] grid) {\\n            int numOfRow = grid.length;\\n            if(numOfRow == 0)\\n                return 0;\\n            int numOfCol = grid[0].length;\\n            int numOfIslands = 0;\\n            Stack<Integer> gridTrackerOfRow = new Stack<Integer>();\\n            Stack<Integer> gridTrackerOfCol = new Stack<Integer>();\\n            for(int i = 0; i < numOfRow; i++){\\n                for(int j = 0; j < numOfCol; j++){\\n                    if(grid[i][j] == '1'){\\n                        gridTrackerOfRow.push(i);\\n                        gridTrackerOfCol.push(j);\\n                        while(!gridTrackerOfRow.isEmpty() && !gridTrackerOfCol.isEmpty()){\\n                            int x = gridTrackerOfRow.pop();\\n                            int y = gridTrackerOfCol.pop();\\n                            grid[x][y] = '0';\\n                            \\n                            if(y+1 < numOfCol && grid[x][y+1] == '1'){\\n                                gridTrackerOfRow.push(x);\\n                                gridTrackerOfCol.push(y+1);\\n                            }\\n                            if(y-1 >= 0 && grid[x][y-1] == '1'){\\n                                gridTrackerOfRow.push(x);\\n                                gridTrackerOfCol.push(y-1);\\n                            }\\n                            if(x+1 < numOfRow && grid[x+1][y] == '1'){\\n                                gridTrackerOfRow.push(x+1);\\n                                gridTrackerOfCol.push(y);\\n                            }\\n                            if(x-1 >= 0 && grid[x-1][y] == '1'){\\n                                gridTrackerOfRow.push(x-1);\\n                                gridTrackerOfCol.push(y);\\n                            }\\n                        }\\n                        numOfIslands++;\\n                    }\\n                }\\n            }\\n            \\n            return numOfIslands;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 56671,
                "title": "short-dfs-java-solution",
                "content": "Hi guys!\\n\\nThe approach is same as in other posts, I just tried to make the code compact and clean.\\n\\nHave a nice coding!\\n\\n----------\\n\\n    public class Solution {\\n        private static final int[][] DIRS = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};\\n        private static final char L = '1', W = '0';\\n        \\n        public void dfsFill(char[][] g, int x, int y) {\\n            if (x >= 0 && x < g.length && y >= 0 && y < g[0].length && g[x][y] == L) {\\n                g[x][y] = W;\\n                for (int[] d : DIRS) dfsFill(g, x + d[0], y + d[1]);\\n            }\\n        }\\n        \\n        public int numIslands(char[][] grid) {\\n            int num = 0;\\n            for (int i = 0; i < grid.length; i++) {\\n                for (int j = 0; j < grid[0].length; j++) {\\n                    if (grid[i][j] == L) {\\n                        num++;\\n                        dfsFill(grid, i, j);\\n                    }\\n                }\\n            }\\n            return num;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n        private static final int[][] DIRS = new int[][]{{1,0}",
                "codeTag": "Java"
            },
            {
                "id": 3926296,
                "title": "easy-dfs-solution-in-java",
                "content": "# Approach\\nWe are searching all grid cells until we encounter a \\'1\\' value. After that we increment the island counter by one and start to explore the rest of the island recursively using DFS (Depth First Search). While doing this, we toggle ones to zeros to prevent infinite recursion and at the end of the day we have the number of islands!\\n\\nThere is also a BFS (Breadth-First Search) solution here:\\n[Easy BFS Solution in JAVA \\u2615\\u2668\\uFE0F](https://leetcode.com/problems/number-of-islands/solutions/3960358/easy-bfs-solution-in-java/)\\n\\nPlease upvote \\uD83D\\uDC7D\\n\\n# Complexity\\n- **Time Complexity:**\\nThe overall time complexity of the solution is $$O(m * n)$$\\n\\n- **Space Complexity:**\\nIf we say $$k$$ represents the size of the largest possible island in the 2D grid, the space complexity would be $$O(k)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        int islandCount = 0;\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    islandCount++;\\n                    searchIslandDFS(grid, i, j);\\n                }\\n            }\\n        }\\n\\n        return islandCount;\\n    }\\n\\n    public void searchIslandDFS(char[][] grid, int i, int j) {\\n        // Check the boundaries and the current cell\\'s value.\\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[i].length || grid[i][j] == \\'0\\') {\\n            return;\\n        }\\n\\n        // Set the value of the grid cell to \\'0\\'.\\n        grid[i][j] = \\'0\\';\\n\\n        // Explore all four directions.\\n        searchIslandDFS(grid, i + 1, j);\\n        searchIslandDFS(grid, i - 1, j);\\n        searchIslandDFS(grid, i, j + 1);\\n        searchIslandDFS(grid, i, j - 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        int islandCount = 0;\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    islandCount++;\\n                    searchIslandDFS(grid, i, j);\\n                }\\n            }\\n        }\\n\\n        return islandCount;\\n    }\\n\\n    public void searchIslandDFS(char[][] grid, int i, int j) {\\n        // Check the boundaries and the current cell\\'s value.\\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[i].length || grid[i][j] == \\'0\\') {\\n            return;\\n        }\\n\\n        // Set the value of the grid cell to \\'0\\'.\\n        grid[i][j] = \\'0\\';\\n\\n        // Explore all four directions.\\n        searchIslandDFS(grid, i + 1, j);\\n        searchIslandDFS(grid, i - 1, j);\\n        searchIslandDFS(grid, i, j + 1);\\n        searchIslandDFS(grid, i, j - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852079,
                "title": "easy-dfs-solution",
                "content": "\\n# Approach\\nCreate a recursive function solve that performs Depth-First Search (DFS) to mark connected lands as \\'0\\'. This function will start from a given position (i, j) and recursively visit all the adjacent cells that contain \\'1\\' (i.e., land). During the visit, it will mark the cells as \\'0\\' to indicate that they have been visited. This function will take the grid, current row index i, current column index j, number of rows n, and number of columns m as parameters.\\n\\nFunction solve(grid, i, j, n, m):\\n\\nBase case: If the current position (i, j) is out of the grid boundaries (i.e., i < 0 || j < 0 || i >= n || j >= m), or if the cell contains \\'0\\', then return and exit the function.\\nMark the current cell as \\'0\\' to indicate that it has been visited.\\nRecursively call solve for the adjacent cells (up, down, left, right) to continue the DFS.\\nInitialize a variable count to 0 to keep track of the number of islands. This variable will be incremented each time we find a new island.\\n\\nIterate through the entire grid. For each cell (i, j):\\n\\nIf the cell contains \\'1\\', this means it is part of a new island. Call the solve function to mark all connected lands as \\'0\\'. Additionally, increment the count variable to count the number of islands.\\nFinally, return the count, which will represent the total number of islands in the grid.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid solve(vector<vector<char>>& grid , int i ,int j,int n ,int m )\\n{\\n    if( i < 0 || j < 0 || i >= n || j >= m )\\n    {\\n        return ;\\n    }\\n    if(grid[i][j]==\\'0\\')\\n    {\\n        return ;\\n    }\\n    grid[i][j]=\\'0\\';\\n\\n    solve(grid,i+1,j, n,m );\\n    solve(grid,i-1,j, n,m );\\n    solve(grid,i,j+1, n,m );\\n    solve(grid,i,j-1, n,m );\\n}\\n\\n    int numIslands(vector<vector<char>>& grid)\\n    {\\n        int count=0;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        for(int i =0 ;i<n;i++)\\n        {\\n            for(int j = 0 ;j<m;j++)\\n            {\\n                if(grid[i][j]==\\'1\\')\\n                {\\n                    // recursive call\\n                    solve(grid,i,j,n,m); \\n                    count++;\\n                }\\n            }\\n        }\\n        return count;       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid solve(vector<vector<char>>& grid , int i ,int j,int n ,int m )\\n{\\n    if( i < 0 || j < 0 || i >= n || j >= m )\\n    {\\n        return ;\\n    }\\n    if(grid[i][j]==\\'0\\')\\n    {\\n        return ;\\n    }\\n    grid[i][j]=\\'0\\';\\n\\n    solve(grid,i+1,j, n,m );\\n    solve(grid,i-1,j, n,m );\\n    solve(grid,i,j+1, n,m );\\n    solve(grid,i,j-1, n,m );\\n}\\n\\n    int numIslands(vector<vector<char>>& grid)\\n    {\\n        int count=0;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        for(int i =0 ;i<n;i++)\\n        {\\n            for(int j = 0 ;j<m;j++)\\n            {\\n                if(grid[i][j]==\\'1\\')\\n                {\\n                    // recursive call\\n                    solve(grid,i,j,n,m); \\n                    count++;\\n                }\\n            }\\n        }\\n        return count;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756862,
                "title": "c-concise-solution-beginner-friendly",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<char>>& grid, int row, int col) {\\n        // Base cases for recursion\\n        if (row < 0 || row >= grid.size() || col < 0 || col >= grid[0].size() || grid[row][col] != \\'1\\') {\\n            return;\\n        }\\n        \\n        // Mark the current cell as visited\\n        grid[row][col] = \\'2\\';\\n        \\n        // Recursive calls in 4 directions\\n        dfs(grid, row - 1, col); // Up\\n        dfs(grid, row + 1, col); // Down\\n        dfs(grid, row, col - 1); // Left\\n        dfs(grid, row, col + 1); // Right\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        int islandCount = 0;\\n        \\n        // Traverse each cell in the grid\\n        for (int row = 0; row < grid.size(); row++) {\\n            for (int col = 0; col < grid[0].size(); col++) {\\n                if (grid[row][col] == \\'1\\') {\\n                    islandCount++;\\n                    dfs(grid, row, col);\\n                }\\n            }\\n        }\\n        \\n        return islandCount;\\n    }\\n};\\n\\n```\\n\\n---\\n\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- **Find a \\'1\\' in the grid.**\\n- **Mark it and all other \\'1\\'s adjacent** to it and each other using **dfs as \\'2\\'**. This ensures **an island is calculated only once.** **Increase** the **islandCount.**\\n- **Traverse** all over **grid** and **find all the islands.**\\n\\n---\\n\\n\\n# Approach\\n- **Initialize islandCount** to **0**;\\n- **Iterate over grid** and call the **dfs function if \\'1\\'**(island) is found. Also **increment islandCount**.\\n- The **dfs** function takes **3 parameters**:-\\n**row** and **column** of the \\'1\\',the **grid**.\\n- The **task of the dfs** function is to **mark all the adjacent \\'1\\'s to \\'2\\'** so that the are counted only once. The **working of dfs** is expalined:-\\n    1) **(base case)** - If the **row or column** of the dfs function are **out of range** or if **grid[row][col] is not** equal to **\\'1\\', return**.\\n    2) **(update step)** - **update** the value of **grid[row][col] to \\'2\\'**.\\n    3) **(recursive step)** - **Call the dfs function recursively** for adjacent rows and columns.\\n- **Return** the **islandCount**. \\n<!-- Describe your approach to solving the problem. -->\\n\\n---\\n\\n\\n# Complexity\\n- **Time complexity: O(m*n)** where **m** and **n** are **dimensions** of the **grid.**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity: O(m*n)** where **m** and **n** are **dimensions** of the **grid.**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n**Please upvote if it helped. Happy Coding!**\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<char>>& grid, int row, int col) {\\n        // Base cases for recursion\\n        if (row < 0 || row >= grid.size() || col < 0 || col >= grid[0].size() || grid[row][col] != \\'1\\') {\\n            return;\\n        }\\n        \\n        // Mark the current cell as visited\\n        grid[row][col] = \\'2\\';\\n        \\n        // Recursive calls in 4 directions\\n        dfs(grid, row - 1, col); // Up\\n        dfs(grid, row + 1, col); // Down\\n        dfs(grid, row, col - 1); // Left\\n        dfs(grid, row, col + 1); // Right\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        int islandCount = 0;\\n        \\n        // Traverse each cell in the grid\\n        for (int row = 0; row < grid.size(); row++) {\\n            for (int col = 0; col < grid[0].size(); col++) {\\n                if (grid[row][col] == \\'1\\') {\\n                    islandCount++;\\n                    dfs(grid, row, col);\\n                }\\n            }\\n        }\\n        \\n        return islandCount;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296102,
                "title": "best-o-m-n-solution",
                "content": "# Approach 1\\nUsing BFS\\n\\n# Complexity\\n- Time complexity:\\n$$O(m*n)$$\\n\\n- Space complexity:\\n$$O(m*n)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void bfs(int row, int col, vector<vector<char>>& grid, vector<vector<int>>& visited) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        visited[row][col] = 1;\\n        queue <pair<int, int>> q;\\n        q.push({row, col});\\n        int drow[] = {-1, 0, +1, 0};\\n        int dcol[] = {0, +1, 0, -1};\\n        while (!q.empty()) {\\n            int row = q.front().first;\\n            int col = q.front().second;\\n            q.pop();\\n            for (int i = 0; i < 4; i++) {\\n                int nrow = row + drow[i];\\n                int ncol = col + dcol[i];\\n                if (nrow >= 0 && nrow < m && ncol >= 0 && ncol < n && \\n                    visited[nrow][ncol] == 0 && grid[nrow][ncol] == \\'1\\') {\\n                        visited[nrow][ncol] = 1;\\n                        q.push({nrow, ncol});\\n                }\\n            }\\n        }\\n    }  \\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> visited(m, vector<int>(n, 0));\\n        int cnt = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (visited[i][j] == 0 && grid[i][j] == \\'1\\') {\\n                    cnt++;\\n                    bfs(i, j, grid, visited);\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n# Approach 2\\nUsing DFS\\n\\n# Complexity\\n- Time complexity:\\n$$O(m*n)$$\\n\\n- Space complexity:\\n$$O(m*n)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int row, int col, vector<vector<char>>& grid, vector<vector<int>>& visited, int drow[], int dcol[]) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        visited[row][col] = 1;\\n        for (int i = 0; i < 4; i++) {\\n            int nrow = row + drow[i];\\n            int ncol = col + dcol[i];\\n            if (nrow >= 0 && nrow < m && ncol >= 0 && ncol < n && \\n                visited[nrow][ncol] == 0 && grid[nrow][ncol] == \\'1\\') {\\n                    dfs(nrow, ncol, grid, visited, drow, dcol);\\n            }\\n        }\\n    }  \\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> visited(m, vector<int>(n, 0));\\n        int cnt = 0;\\n        int drow[] = {-1, 0, +1, 0};\\n        int dcol[] = {0, +1, 0, -1};\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (visited[i][j] == 0 && grid[i][j] == \\'1\\') {\\n                    cnt++;\\n                    dfs(i, j, grid, visited, drow, dcol);\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void bfs(int row, int col, vector<vector<char>>& grid, vector<vector<int>>& visited) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        visited[row][col] = 1;\\n        queue <pair<int, int>> q;\\n        q.push({row, col});\\n        int drow[] = {-1, 0, +1, 0};\\n        int dcol[] = {0, +1, 0, -1};\\n        while (!q.empty()) {\\n            int row = q.front().first;\\n            int col = q.front().second;\\n            q.pop();\\n            for (int i = 0; i < 4; i++) {\\n                int nrow = row + drow[i];\\n                int ncol = col + dcol[i];\\n                if (nrow >= 0 && nrow < m && ncol >= 0 && ncol < n && \\n                    visited[nrow][ncol] == 0 && grid[nrow][ncol] == \\'1\\') {\\n                        visited[nrow][ncol] = 1;\\n                        q.push({nrow, ncol});\\n                }\\n            }\\n        }\\n    }  \\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> visited(m, vector<int>(n, 0));\\n        int cnt = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (visited[i][j] == 0 && grid[i][j] == \\'1\\') {\\n                    cnt++;\\n                    bfs(i, j, grid, visited);\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    void dfs(int row, int col, vector<vector<char>>& grid, vector<vector<int>>& visited, int drow[], int dcol[]) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        visited[row][col] = 1;\\n        for (int i = 0; i < 4; i++) {\\n            int nrow = row + drow[i];\\n            int ncol = col + dcol[i];\\n            if (nrow >= 0 && nrow < m && ncol >= 0 && ncol < n && \\n                visited[nrow][ncol] == 0 && grid[nrow][ncol] == \\'1\\') {\\n                    dfs(nrow, ncol, grid, visited, drow, dcol);\\n            }\\n        }\\n    }  \\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> visited(m, vector<int>(n, 0));\\n        int cnt = 0;\\n        int drow[] = {-1, 0, +1, 0};\\n        int dcol[] = {0, +1, 0, -1};\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (visited[i][j] == 0 && grid[i][j] == \\'1\\') {\\n                    cnt++;\\n                    dfs(i, j, grid, visited, drow, dcol);\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248719,
                "title": "python-both-bfs-and-dfs-made-easy-90-fastest-solution-graph",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAssume the grid as a graph and traverse through the graph using either BFS or DFS  and count the no of connected graph components are found.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can either use BFS approach or DFS approach to solve this problem\\n\\n- Some other similar problems are :\\n    - LC - 733\\n    - LC - 200\\n    - LC - 695\\n    - LC - 1254\\n    - LC - 1020\\n    - LC - 1905\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        m,n=len(grid),len(grid[0])\\n        ans=0\\n        visited=set()\\n        def bfs(i,j):\\n            q=deque()\\n            visited.add((i,j))\\n            q.append((i,j))\\n            while q:\\n                r,c=q.popleft()\\n                adj=[[1,0],[0,1],[-1,0],[0,-1]]\\n                for x,y in adj:\\n                    if (r+x) in range(m) and (c+y) in range(n) and grid[r+x][c+y]==\\'1\\' and (r+x,c+y) not in visited:\\n                        visited.add((r+x,c+y))\\n                        q.append((r+x,c+y))\\n        \\n        def dfs(i,j):\\n            visited.add((i,j))\\n            for x,y in [[i+1,j],[i,j+1],[i-1,j],[i,j-1]]:\\n                if x in range(m) and y in range(n) and (x,y) not in visited and grid[x][y]==\\'1\\':\\n                    dfs(x,y)\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]==\\'1\\' and (i,j) not in visited:\\n                    ans+=1\\n                    dfs(i,j)\\n                    #bfs(i,j)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        m,n=len(grid),len(grid[0])\\n        ans=0\\n        visited=set()\\n        def bfs(i,j):\\n            q=deque()\\n            visited.add((i,j))\\n            q.append((i,j))\\n            while q:\\n                r,c=q.popleft()\\n                adj=[[1,0],[0,1],[-1,0],[0,-1]]\\n                for x,y in adj:\\n                    if (r+x) in range(m) and (c+y) in range(n) and grid[r+x][c+y]==\\'1\\' and (r+x,c+y) not in visited:\\n                        visited.add((r+x,c+y))\\n                        q.append((r+x,c+y))\\n        \\n        def dfs(i,j):\\n            visited.add((i,j))\\n            for x,y in [[i+1,j],[i,j+1],[i-1,j],[i,j-1]]:\\n                if x in range(m) and y in range(n) and (x,y) not in visited and grid[x][y]==\\'1\\':\\n                    dfs(x,y)\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]==\\'1\\' and (i,j) not in visited:\\n                    ans+=1\\n                    dfs(i,j)\\n                    #bfs(i,j)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180904,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n\\n    void dfs(vector<vector<char>>& grid, int i, int j) {\\n        grid[i][j] = \\'0\\';\\n        int m = grid.size(), n = grid[0].size();\\n\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\') dfs(grid, i-1, j);\\n        if(i+1 < m && grid[i+1][j] == \\'1\\') dfs(grid, i+1, j);\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\') dfs(grid, i, j-1);\\n        if(j+1 < n && grid[i][j+1] == \\'1\\') dfs(grid, i, j+1);\\n    }\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n        ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\\n\\n        int ans = 0;\\n        \\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid[0].size(); j++) {\\n                if(grid[i][j] == \\'1\\') {\\n                    ans++;\\n                    dfs(grid, i, j);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        componentCounter = 0 \\n        m = len(grid)\\n        n = len(grid[0])\\n        def dfs(i, j): \\n            grid[i][j] = -1\\n            if (i < m - 1 and grid[i + 1][j] == \"1\"): \\n                dfs(i + 1, j)\\n            if (i > 0 and grid[i - 1][j] == \"1\"): \\n                dfs(i - 1, j)\\n            if (j < n - 1 and grid[i][j + 1] == \"1\"): \\n                dfs(i, j + 1)\\n            if (j > 0 and grid[i][j - 1] == \"1\"): \\n                dfs(i, j - 1)\\n        \\n        for k in range(m): \\n            for l in range(n): \\n                if grid[k][l] == \"1\": \\n                    componentCounter += 1\\n                    dfs(k, l)\\n        return componentCounter\\n```\\n\\n```Java []\\nclass Solution {\\n    int r;\\n    int c;\\n    char[][] arr;\\n    int count;\\n    public int numIslands(char[][] grid) {\\n        r = grid.length;\\n        c = grid[0].length;\\n        arr = grid;\\n\\n        count =0;\\n        for(int i=0;i<r;i++){\\n            check(grid[i],i);\\n        }\\n        return count;\\n    }\\n    void check(char[] row,int i)\\n    {\\n        for(int j=0;j<c;j++)\\n        {\\n            if(row[j]==\\'1\\')\\n            {\\n                visitIsland(i,j);\\n                count++;\\n            }\\n        }\\n    }\\n    public void visitIsland(int i, int j){\\n        arr[i][j] = 2;\\n        if(i-1>=0 && arr[i-1][j]==\\'1\\')visitIsland(i-1,j);\\n         if(i+1<r && arr[i+1][j]==\\'1\\')visitIsland(i+1,j);\\n         if(j-1>=0 && arr[i][j-1]==\\'1\\')visitIsland(i,j-1);\\n         if(j+1<c && arr[i][j+1]==\\'1\\')visitIsland(i,j+1);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n\\n    void dfs(vector<vector<char>>& grid, int i, int j) {\\n        grid[i][j] = \\'0\\';\\n        int m = grid.size(), n = grid[0].size();\\n\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\') dfs(grid, i-1, j);\\n        if(i+1 < m && grid[i+1][j] == \\'1\\') dfs(grid, i+1, j);\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\') dfs(grid, i, j-1);\\n        if(j+1 < n && grid[i][j+1] == \\'1\\') dfs(grid, i, j+1);\\n    }\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n        ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\\n\\n        int ans = 0;\\n        \\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid[0].size(); j++) {\\n                if(grid[i][j] == \\'1\\') {\\n                    ans++;\\n                    dfs(grid, i, j);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        componentCounter = 0 \\n        m = len(grid)\\n        n = len(grid[0])\\n        def dfs(i, j): \\n            grid[i][j] = -1\\n            if (i < m - 1 and grid[i + 1][j] == \"1\"): \\n                dfs(i + 1, j)\\n            if (i > 0 and grid[i - 1][j] == \"1\"): \\n                dfs(i - 1, j)\\n            if (j < n - 1 and grid[i][j + 1] == \"1\"): \\n                dfs(i, j + 1)\\n            if (j > 0 and grid[i][j - 1] == \"1\"): \\n                dfs(i, j - 1)\\n        \\n        for k in range(m): \\n            for l in range(n): \\n                if grid[k][l] == \"1\": \\n                    componentCounter += 1\\n                    dfs(k, l)\\n        return componentCounter\\n```\n```Java []\\nclass Solution {\\n    int r;\\n    int c;\\n    char[][] arr;\\n    int count;\\n    public int numIslands(char[][] grid) {\\n        r = grid.length;\\n        c = grid[0].length;\\n        arr = grid;\\n\\n        count =0;\\n        for(int i=0;i<r;i++){\\n            check(grid[i],i);\\n        }\\n        return count;\\n    }\\n    void check(char[] row,int i)\\n    {\\n        for(int j=0;j<c;j++)\\n        {\\n            if(row[j]==\\'1\\')\\n            {\\n                visitIsland(i,j);\\n                count++;\\n            }\\n        }\\n    }\\n    public void visitIsland(int i, int j){\\n        arr[i][j] = 2;\\n        if(i-1>=0 && arr[i-1][j]==\\'1\\')visitIsland(i-1,j);\\n         if(i+1<r && arr[i+1][j]==\\'1\\')visitIsland(i+1,j);\\n         if(j-1>=0 && arr[i][j-1]==\\'1\\')visitIsland(i,j-1);\\n         if(j+1<c && arr[i][j+1]==\\'1\\')visitIsland(i,j+1);\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2945310,
                "title": "c-easy-to-understand-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTraverse and mark islands \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nKeep A visited matrix and mark all islands through DFS and count them \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<char>>& grid,int i,int j,int m,int n,vector<vector<bool>>& visited){\\n        visited[i][j]=true;\\n        if(j-1>=0 && grid[i][j-1]==\\'1\\' && visited[i][j-1]==false){\\n            dfs(grid,i,j-1,m,n,visited);\\n        }\\n        if(i-1>=0 && grid[i-1][j]==\\'1\\' && visited[i-1][j]==false){\\n            dfs(grid,i-1,j,m,n,visited);\\n        }\\n        if(j+1<n && grid[i][j+1]==\\'1\\' && visited[i][j+1]==false){\\n            dfs(grid,i,j+1,m,n,visited);\\n        }\\n        if(i+1<m && grid[i+1][j]==\\'1\\' && visited[i+1][j]==false){\\n            dfs(grid,i+1,j,m,n,visited);\\n        }\\n        return;\\n    }\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n        int m=grid.size ();\\n        int n=grid[0].size();\\n        vector<vector<bool>> visited(m,vector<bool>(n,false));\\n        int ans=0;\\n\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==\\'1\\' && visited[i][j]==false){\\n                dfs(grid,i,j,m,n,visited);\\n                ans++;\\n                }\\n            }   \\n        }\\n        return ans;\\n    }\\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<char>>& grid,int i,int j,int m,int n,vector<vector<bool>>& visited){\\n        visited[i][j]=true;\\n        if(j-1>=0 && grid[i][j-1]==\\'1\\' && visited[i][j-1]==false){\\n            dfs(grid,i,j-1,m,n,visited);\\n        }\\n        if(i-1>=0 && grid[i-1][j]==\\'1\\' && visited[i-1][j]==false){\\n            dfs(grid,i-1,j,m,n,visited);\\n        }\\n        if(j+1<n && grid[i][j+1]==\\'1\\' && visited[i][j+1]==false){\\n            dfs(grid,i,j+1,m,n,visited);\\n        }\\n        if(i+1<m && grid[i+1][j]==\\'1\\' && visited[i+1][j]==false){\\n            dfs(grid,i+1,j,m,n,visited);\\n        }\\n        return;\\n    }\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n        int m=grid.size ();\\n        int n=grid[0].size();\\n        vector<vector<bool>> visited(m,vector<bool>(n,false));\\n        int ans=0;\\n\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==\\'1\\' && visited[i][j]==false){\\n                dfs(grid,i,j,m,n,visited);\\n                ans++;\\n                }\\n            }   \\n        }\\n        return ans;\\n    }\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708844,
                "title": "very-easy-concise-java-solution",
                "content": "\\tpublic class Solution {\\n\\n\\t\\t\\tprivate int n;\\n\\t\\t\\tprivate int m;\\n\\n\\t\\tpublic int numIslands(char[][] grid) {\\n\\t\\t\\t\\tint count = 0;\\n\\t\\t\\t\\tn = grid.length;\\n\\t\\t\\t\\tif (n == 0) return 0;\\n\\t\\t\\t\\tm = grid[0].length;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tfor (int i = 0; i < n; i++){\\n\\t\\t\\t\\t\\tfor (int j = 0; j < m; j++)\\n\\t\\t\\t\\t\\t\\tif (grid[i][j] == \\'1\\') {\\n\\t\\t\\t\\t\\t\\t\\tDFSMarking(grid, i, j);\\n\\t\\t\\t\\t\\t\\t\\t++count;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}    \\n\\t\\t\\t\\treturn count;\\n\\t\\t\\t}\\n\\n\\t\\tprivate void DFSMarking(char[][] grid, int i, int j) {\\n\\t\\t\\t\\n\\t\\t\\t\\tif (i < 0 || j < 0 || i >= n || j >= m || grid[i][j] != \\'1\\') return;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tgrid[i][j] = \\'0\\';\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tDFSMarking(grid, i + 1, j);\\n\\t\\t\\t\\tDFSMarking(grid, i - 1, j);\\n\\t\\t\\t\\tDFSMarking(grid, i, j + 1);\\n\\t\\t\\t\\tDFSMarking(grid, i, j - 1);\\n\\t\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n\\t\\t\\tprivate int n;\\n\\t\\t\\tprivate int m;\\n\\n\\t\\tpublic int numIslands(char[][] grid) {\\n\\t\\t\\t\\tint count = 0;\\n\\t\\t\\t\\tn = grid.length;\\n\\t\\t\\t\\tif (n == 0) return 0;\\n\\t\\t\\t\\tm = grid[0].length;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tfor (int i = 0; i < n; i++){\\n\\t\\t\\t\\t\\tfor (int j = 0; j < m; j++)\\n\\t\\t\\t\\t\\t\\tif (grid[i][j] == \\'1\\') {\\n\\t\\t\\t\\t\\t\\t\\tDFSMarking(grid, i, j);\\n\\t\\t\\t\\t\\t\\t\\t++count;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2215358,
                "title": "python-optimal-solution",
                "content": "```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        row, col, res = len(grid), len(grid[0]), 0\\n\\n        def mark_island(x, y):\\n            \"\"\"\\n            check whether current (x, y) is land or not. If it\\'s land, mark everything on the island to 2\\n            \"\"\"\\n            if 0 <= x < row and 0 <= y < col and grid[x][y] == \\'1\\':\\n                grid[x][y] = \\'2\\'\\n                for nxt_x, nxt_y in [(x-1, y), (x+1, y), (x, y-1), (x, y+1)]:\\n                    mark_island(nxt_x, nxt_y)\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \\'1\\':\\n                    mark_island(i, j)\\n                    res += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        row, col, res = len(grid), len(grid[0]), 0\\n\\n        def mark_island(x, y):\\n            \"\"\"\\n            check whether current (x, y) is land or not. If it\\'s land, mark everything on the island to 2\\n            \"\"\"\\n            if 0 <= x < row and 0 <= y < col and grid[x][y] == \\'1\\':\\n                grid[x][y] = \\'2\\'\\n                for nxt_x, nxt_y in [(x-1, y), (x+1, y), (x, y-1), (x, y+1)]:\\n                    mark_island(nxt_x, nxt_y)\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \\'1\\':\\n                    mark_island(i, j)\\n                    res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2063385,
                "title": "java-dfs-solution",
                "content": "![image](https://assets.leetcode.com/users/images/3ce1222f-5dff-461f-b779-3c0a0804c669_1653215072.8381944.jpeg)\\n\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        \\n\\t\\tint count = 0; //count the total no of island\\n        \\n        for(int i = 0; i < grid.length; i++){ // Traverse Row\\n            for(int j = 0; j < grid[0].length; j++){ //Traverse Column\\n                if(grid[i][j] == \\'1\\'){ // if we find \\'1\\' in matrix\\n                    count++; \\n                    BFS(grid, i, j);  //call BFS method to find the island\\n                }\\n            }\\n        }\\n        return count; //return the number of island\\n    }\\n        // Helper Method to find island\\n    public void BFS(char[][] grid, int i, int j){\\n        //Base Condition\\n        if(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == \\'0\\'){\\n            return;\\n        }\\n\\t\\t//when we find \\'1\\' then convert it into \\'0\\'\\n        grid[i][j] = \\'0\\'; \\n        BFS(grid, i+1, j); // up\\n        BFS(grid, i-1, j); // down\\n        BFS(grid, i, j-1); // left\\n        BFS(grid, i, j+1); // right\\n\\t\\t}\\n\\t}\\n\\n// If you like this solution please vote \\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public int numIslands(char[][] grid) {\\n        \\n\\t\\tint count = 0; //count the total no of island\\n        \\n        for(int i = 0; i < grid.length; i++){ // Traverse Row\\n            for(int j = 0; j < grid[0].length; j++){ //Traverse Column\\n                if(grid[i][j] == \\'1\\'){ // if we find \\'1\\' in matrix\\n                    count++; \\n                    BFS(grid, i, j);  //call BFS method to find the island\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1527460,
                "title": "c-simple-and-cleanest-bfs-and-dfs-without-visited-array",
                "content": "```\\npublic int NumIslands(char[][] grid) \\n    {\\n        if(grid == null)\\n            return 0;\\n        \\n        var rows = grid.Length;\\n        var cols = grid[0].Length;\\n        var islands = 0;\\n        \\n        for(int row=0; row<rows; row++)\\n        {\\n            for(int col=0; col<cols; col++)\\n            {\\n                if(grid[row][col] == \\'1\\')\\n                {\\n\\t\\t\\t\\t\\t//want to apply DFS, replace following call with CheckLandBelongsToIsland**DFS**\\n                    CheckLandBelongsToIslandBFS(grid, row, col); \\n                    islands +=1;   \\n                }\\n            }\\n        }\\n        \\n        return islands;\\n    }\\n\\n\\t//BFS\\n    public void CheckLandBelongsToIslandBFS(char[][] grid, int row, int col)\\n    {\\n        var queue = new Queue<int[]>();\\n        queue.Enqueue(new int[] { row, col});\\n        \\n        \\n        while(queue.Count != 0)\\n        {\\n            var item = queue.Dequeue();\\n            row = item[0];\\n            col = item[1];\\n            \\n            if(row < 0 || row >= grid.Length || col < 0 || col >= grid[0].Length || grid[row][col] != \\'1\\')\\n            {\\n                continue;\\n            }\\n            \\n            grid[row][col] = \\'#\\'; //Mark as Visited\\n            \\n            queue.Enqueue(new int[] { row - 1, col}); //UP\\n            queue.Enqueue(new int[] { row + 1, col}); //Down\\n            queue.Enqueue(new int[] { row, col + 1}); //Right\\n            queue.Enqueue(new int[] { row, col - 1}); //Left\\n        }\\n    }\\n\\n\\t//DFS\\n    public void CheckLandBelongsToIslandDFS(char[][] grid, int row, int col)\\n    {\\n        if(row<0 || row >= grid.Length || col < 0 || col >= grid[0].Length || grid[row][col] != \\'1\\')\\n        {\\n            return;\\n        }\\n        \\n        grid[row][col] = \\'#\\'; //Mark as Visited\\n            \\n        CheckLandBelongsToIsland(grid, row - 1, col); //Up\\n        CheckLandBelongsToIsland(grid, row + 1, col); //Down\\n        CheckLandBelongsToIsland(grid, row, col + 1); //Right\\n        CheckLandBelongsToIsland(grid, row, col - 1); //Left\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\npublic int NumIslands(char[][] grid) \\n    {\\n        if(grid == null)\\n            return 0;\\n        \\n        var rows = grid.Length;\\n        var cols = grid[0].Length;\\n        var islands = 0;\\n        \\n        for(int row=0; row<rows; row++)\\n        {\\n            for(int col=0; col<cols; col++)\\n            {\\n                if(grid[row][col] == \\'1\\')\\n                {\\n\\t\\t\\t\\t\\t//want to apply DFS, replace following call with CheckLandBelongsToIsland**DFS**\\n                    CheckLandBelongsToIslandBFS(grid, row, col); \\n                    islands +=1;   \\n                }\\n            }\\n        }\\n        \\n        return islands;\\n    }\\n\\n\\t//BFS\\n    public void CheckLandBelongsToIslandBFS(char[][] grid, int row, int col)\\n    {\\n        var queue = new Queue<int[]>();\\n        queue.Enqueue(new int[] { row, col});\\n        \\n        \\n        while(queue.Count != 0)\\n        {\\n            var item = queue.Dequeue();\\n            row = item[0];\\n            col = item[1];\\n            \\n            if(row < 0 || row >= grid.Length || col < 0 || col >= grid[0].Length || grid[row][col] != \\'1\\')\\n            {\\n                continue;\\n            }\\n            \\n            grid[row][col] = \\'#\\'; //Mark as Visited\\n            \\n            queue.Enqueue(new int[] { row - 1, col}); //UP\\n            queue.Enqueue(new int[] { row + 1, col}); //Down\\n            queue.Enqueue(new int[] { row, col + 1}); //Right\\n            queue.Enqueue(new int[] { row, col - 1}); //Left\\n        }\\n    }\\n\\n\\t//DFS\\n    public void CheckLandBelongsToIslandDFS(char[][] grid, int row, int col)\\n    {\\n        if(row<0 || row >= grid.Length || col < 0 || col >= grid[0].Length || grid[row][col] != \\'1\\')\\n        {\\n            return;\\n        }\\n        \\n        grid[row][col] = \\'#\\'; //Mark as Visited\\n            \\n        CheckLandBelongsToIsland(grid, row - 1, col); //Up\\n        CheckLandBelongsToIsland(grid, row + 1, col); //Down\\n        CheckLandBelongsToIsland(grid, row, col + 1); //Right\\n        CheckLandBelongsToIsland(grid, row, col - 1); //Left\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1395142,
                "title": "c-dfs-logic-explained-number-of-connected-components",
                "content": "* Overall the idea is to find **number of connected components**\\n* If adjacent cell is having 1, consider it as a **connected node** \\n* Being at any (i,j) point , apply DFS recursively to all its connected nodes\\n* You can either take a visited matrix or modify the same matrix making 1 as 0 ( I have modified the same matrix)\\n* DFS is like, if u burn a points, it will burn all the points connected, u need to count how much time u need to burn such that all points are burnt \\n* **TC: (N*M)**  ( Explained more in comment section )\\n* **SC: (N*M)**\\n\\nGive a like if it helped you. \\nHaving doubt ? Post it in comment section \\n```\\nclass Solution {\\npublic:\\n    void DFS( vector<vector<char>> &grid, int r, int c, int n, int m ){\\n        if( r<0 || r>=n || c<0 || c>=m || grid[r][c] == \\'0\\' ) return;\\n        grid[r][c] = \\'0\\';\\n        int x[]={0,0,1,-1};\\n        int y[]={1,-1,0,0};\\n        for( int i=0; i<4; i++ )\\n            DFS( grid, r+x[i], c+y[i], n, m );\\n    }\\n    int numIslands(vector<vector<char>> &grid) {\\n        int count =0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        for( int i=0; i<n; i++ ){\\n            for( int j=0; j<m; j++ ){\\n                if( grid[i][j]==\\'1\\' ){\\n                    count++;\\n                    DFS( grid, i, j, n, m );\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void DFS( vector<vector<char>> &grid, int r, int c, int n, int m ){\\n        if( r<0 || r>=n || c<0 || c>=m || grid[r][c] == \\'0\\' ) return;\\n        grid[r][c] = \\'0\\';\\n        int x[]={0,0,1,-1};\\n        int y[]={1,-1,0,0};\\n        for( int i=0; i<4; i++ )\\n            DFS( grid, r+x[i], c+y[i], n, m );\\n    }\\n    int numIslands(vector<vector<char>> &grid) {\\n        int count =0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        for( int i=0; i<n; i++ ){\\n            for( int j=0; j<m; j++ ){\\n                if( grid[i][j]==\\'1\\' ){\\n                    count++;\\n                    DFS( grid, i, j, n, m );\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369131,
                "title": "js-dfs",
                "content": "```\\nvar numIslands = function(grid) {\\n    let count = 0;\\n    for(let i=0;i<grid.length;i++) {\\n        for(let j=0;j<grid[0].length;j++) {\\n            if(grid[i][j] == \\'1\\') {\\n                count++;\\n                dfsSink(grid, i,j);\\n            }\\n        }\\n    }\\n    \\n    return count;\\n};\\n\\n//if there are connected island sink them as connected island only count as one \\nconst dfsSink = (grid, i,j) => {\\n   //if out of bound or encounter sea\\n    if (i==grid.length ||i<0 ||j==grid[0].length||j<0||grid[i][j] ==\\'0\\') {\\n        return;\\n    }\\n    if (grid[i][j] ==\\'1\\') {\\n        grid[i][j] = \\'0\\';\\n        dfsSink(grid, i-1,j);\\n        dfsSink(grid, i,j-1);\\n        dfsSink(grid, i+1,j);\\n        dfsSink(grid, i,j+1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar numIslands = function(grid) {\\n    let count = 0;\\n    for(let i=0;i<grid.length;i++) {\\n        for(let j=0;j<grid[0].length;j++) {\\n            if(grid[i][j] == \\'1\\') {\\n                count++;\\n                dfsSink(grid, i,j);\\n            }\\n        }\\n    }\\n    \\n    return count;\\n};\\n\\n//if there are connected island sink them as connected island only count as one \\nconst dfsSink = (grid, i,j) => {\\n   //if out of bound or encounter sea\\n    if (i==grid.length ||i<0 ||j==grid[0].length||j<0||grid[i][j] ==\\'0\\') {\\n        return;\\n    }\\n    if (grid[i][j] ==\\'1\\') {\\n        grid[i][j] = \\'0\\';\\n        dfsSink(grid, i-1,j);\\n        dfsSink(grid, i,j-1);\\n        dfsSink(grid, i+1,j);\\n        dfsSink(grid, i,j+1);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1358520,
                "title": "number-of-islands-bfs-python-iterative-faster-than-99-50",
                "content": "```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        l, b = len(grid), len(grid[0])\\n        c = 0\\n\\n        def makeZero(grid, i, j, n, m):\\n            q = [[i, j]]\\n            while q != []:\\n                ci, cj = q.pop(0)\\n                grid[ci][cj] = \"0\"\\n                if (ci - 1) >= 0 and grid[ci - 1][cj] == \"1\":\\n                        q.append([ci - 1, cj])\\n                        grid[ci-1][cj]=\"0\"\\n                if (ci + 1) < n and grid[ci + 1][cj] == \"1\":\\n                        q.append([ci + 1, cj])\\n                        grid[ci + 1][cj] = \"0\"\\n                if (cj - 1) >= 0 and grid[ci][cj - 1] == \"1\":\\n                        q.append([ci, cj - 1])\\n                        grid[ci][cj-1] = \"0\"\\n                if (cj + 1) < m and grid[ci][cj + 1] == \"1\":\\n                        q.append([ci, cj + 1])\\n                        grid[ci][cj+1] = \"0\"\\n\\n\\n        for i in range(l):\\n            for j in range(b):\\n                if grid[i][j] == \"1\":\\n                    c += 1\\n                    makeZero(grid, i, j, l, b)\\n\\n        return c\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        l, b = len(grid), len(grid[0])\\n        c = 0\\n\\n        def makeZero(grid, i, j, n, m):\\n            q = [[i, j]]\\n            while q != []:\\n                ci, cj = q.pop(0)\\n                grid[ci][cj] = \"0\"\\n                if (ci - 1) >= 0 and grid[ci - 1][cj] == \"1\":\\n                        q.append([ci - 1, cj])\\n                        grid[ci-1][cj]=\"0\"\\n                if (ci + 1) < n and grid[ci + 1][cj] == \"1\":\\n                        q.append([ci + 1, cj])\\n                        grid[ci + 1][cj] = \"0\"\\n                if (cj - 1) >= 0 and grid[ci][cj - 1] == \"1\":\\n                        q.append([ci, cj - 1])\\n                        grid[ci][cj-1] = \"0\"\\n                if (cj + 1) < m and grid[ci][cj + 1] == \"1\":\\n                        q.append([ci, cj + 1])\\n                        grid[ci][cj+1] = \"0\"\\n\\n\\n        for i in range(l):\\n            for j in range(b):\\n                if grid[i][j] == \"1\":\\n                    c += 1\\n                    makeZero(grid, i, j, l, b)\\n\\n        return c\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1265216,
                "title": "python-union-find",
                "content": "```\\nclass DSU:\\n    def __init__(self, size):\\n        self.array = [i for i in range(size)]\\n        self.size = size \\n        \\n    def find(self, num):\\n        if self.array[num] != num:\\n            self.array[num] = self.find(self.array[num])\\n        \\n        return self.array[num]\\n\\n    def union(self, num1, num2) -> bool:\\n        parent1 = self.find(num1)\\n        parent2 = self.find(num2)\\n        \\n        if parent1 == parent2: \\n            # there is no union to be done \\n            return False\\n         \\n        self.array[parent1] = parent2\\n        return True \\n            \\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        dsu = DSU(m*n)\\n        \\n        res = 0 \\n        dirs = [[1,0],[-1,0],[0,1],[0,-1]]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \"1\":\\n                    res += 1 \\n                    \\n                    for pair in dirs: \\n                        r = i + pair[0]\\n                        c = j + pair[1]\\n                        \\n                        if 0 <= r < m and 0 <= c < n and grid[r][c] == \"1\":\\n                            cell_1 = (i * n) + j \\n                            cell_2 = (r * n) + c \\n                            \\n                            if dsu.union(cell_1, cell_2): \\n                                # they both are a part of one island. So reduce result count \\n                                res -= 1 \\n        \\n        return res\\n    \\n# Time = O(M x N)\\n# Space = O(M x N)\\n```",
                "solutionTags": [],
                "code": "```\\nclass DSU:\\n    def __init__(self, size):\\n        self.array = [i for i in range(size)]\\n        self.size = size \\n        \\n    def find(self, num):\\n        if self.array[num] != num:\\n            self.array[num] = self.find(self.array[num])\\n        \\n        return self.array[num]\\n\\n    def union(self, num1, num2) -> bool:\\n        parent1 = self.find(num1)\\n        parent2 = self.find(num2)\\n        \\n        if parent1 == parent2: \\n            # there is no union to be done \\n            return False\\n         \\n        self.array[parent1] = parent2\\n        return True \\n            \\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        dsu = DSU(m*n)\\n        \\n        res = 0 \\n        dirs = [[1,0],[-1,0],[0,1],[0,-1]]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == \"1\":\\n                    res += 1 \\n                    \\n                    for pair in dirs: \\n                        r = i + pair[0]\\n                        c = j + pair[1]\\n                        \\n                        if 0 <= r < m and 0 <= c < n and grid[r][c] == \"1\":\\n                            cell_1 = (i * n) + j \\n                            cell_2 = (r * n) + c \\n                            \\n                            if dsu.union(cell_1, cell_2): \\n                                # they both are a part of one island. So reduce result count \\n                                res -= 1 \\n        \\n        return res\\n    \\n# Time = O(M x N)\\n# Space = O(M x N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 911853,
                "title": "code-with-image-and-debug-explanation",
                "content": "Here is the basic idea. When a cell is a land then convert all cells around  to water\\n![image](https://assets.leetcode.com/users/images/a3c6a127-0722-4131-9efc-8726e0e87324_1603768744.9087245.png)\\n\\nThen the rest is easy. \\n\\n```\\nvar numIslands = function(grid) {\\n    if(!grid || !grid[0]){\\n        return 0;\\n    }\\n    const convertLandToWater = (i,j) => {\\n        if(grid[i] == undefined || grid[i][j] == undefined || grid[i][j] == \"0\"){\\n            return;\\n        }\\n        grid[i][j]=\"0\";\\n        convertLandToWater(i+1,j);\\n        convertLandToWater(i,j +1);\\n        convertLandToWater(i-1,j);\\n        convertLandToWater(i,j -1);\\n    }\\n\\n    let counter = 0;\\n    for (let i = 0; i < grid.length ; i++) {\\n        for (let j = 0; j < grid[i].length; j++) {\\n            if(grid[i][j] == \"1\"){\\n                counter++;\\n                convertLandToWater(i,j);\\n       \\n            }\\n\\n        }\\n    }\\n    return counter;\\n};\\n```\\n\\nSample input : \\n\\n![image](https://assets.leetcode.com/users/images/4a023f5b-971e-4a2e-a358-6b04537145b3_1603768937.4152658.png)\\n\\nFind more inresting things here : https://canthodeveloper.wordpress.com/\\n",
                "solutionTags": [],
                "code": "```\\nvar numIslands = function(grid) {\\n    if(!grid || !grid[0]){\\n        return 0;\\n    }\\n    const convertLandToWater = (i,j) => {\\n        if(grid[i] == undefined || grid[i][j] == undefined || grid[i][j] == \"0\"){\\n            return;\\n        }\\n        grid[i][j]=\"0\";\\n        convertLandToWater(i+1,j);\\n        convertLandToWater(i,j +1);\\n        convertLandToWater(i-1,j);\\n        convertLandToWater(i,j -1);\\n    }\\n\\n    let counter = 0;\\n    for (let i = 0; i < grid.length ; i++) {\\n        for (let j = 0; j < grid[i].length; j++) {\\n            if(grid[i][j] == \"1\"){\\n                counter++;\\n                convertLandToWater(i,j);\\n       \\n            }\\n\\n        }\\n    }\\n    return counter;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 809165,
                "title": "javascript-bfs",
                "content": "\\n```\\nconst WATER = \\'0\\';\\nconst LAND = \\'1\\';\\nconst DIRECTIONS = [\\n    [0, 1],\\n    [1, 0],\\n    [0, -1],\\n    [-1, 0],\\n];\\n\\nfunction bfs(grid, r, c ) {\\n    let queue = [[r, c]];\\n    grid[r][c] = WATER;\\n    \\n    while (queue.length) {\\n        let size = queue.length;\\n        for (let i = 0; i < size; i++) {\\n            let [row, col] = queue.pop();\\n            \\n            for (let [x, y] of DIRECTIONS) {\\n                let iRow = row + x;\\n                let iCol = col + y;\\n                \\n                if (iRow < 0 || iRow >= grid.length || iCol < 0 || iCol >= grid[0].length || grid[iRow][iCol] !== LAND) {\\n                    continue;\\n                }\\n                \\n                grid[iRow][iCol] = WATER;\\n                queue.unshift([iRow, iCol]);\\n            }\\n        }\\n    }\\n}\\n\\nfunction numIslands(grid) {\\n    if (!grid.length) {\\n        return 0;\\n    }\\n    \\n    let numberOfIslands = 0;\\n    for (let r = 0; r < grid.length; r++) {\\n        for (let c = 0; c < grid[0].length; c++) {\\n            if (grid[r][c] === LAND) {\\n                numberOfIslands++;\\n                bfs(grid, r, c);\\n            }\\n        }\\n    }\\n    return numberOfIslands;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nconst WATER = \\'0\\';\\nconst LAND = \\'1\\';\\nconst DIRECTIONS = [\\n    [0, 1],\\n    [1, 0],\\n    [0, -1],\\n    [-1, 0],\\n];\\n\\nfunction bfs(grid, r, c ) {\\n    let queue = [[r, c]];\\n    grid[r][c] = WATER;\\n    \\n    while (queue.length) {\\n        let size = queue.length;\\n        for (let i = 0; i < size; i++) {\\n            let [row, col] = queue.pop();\\n            \\n            for (let [x, y] of DIRECTIONS) {\\n                let iRow = row + x;\\n                let iCol = col + y;\\n                \\n                if (iRow < 0 || iRow >= grid.length || iCol < 0 || iCol >= grid[0].length || grid[iRow][iCol] !== LAND) {\\n                    continue;\\n                }\\n                \\n                grid[iRow][iCol] = WATER;\\n                queue.unshift([iRow, iCol]);\\n            }\\n        }\\n    }\\n}\\n\\nfunction numIslands(grid) {\\n    if (!grid.length) {\\n        return 0;\\n    }\\n    \\n    let numberOfIslands = 0;\\n    for (let r = 0; r < grid.length; r++) {\\n        for (let c = 0; c < grid[0].length; c++) {\\n            if (grid[r][c] === LAND) {\\n                numberOfIslands++;\\n                bfs(grid, r, c);\\n            }\\n        }\\n    }\\n    return numberOfIslands;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 673201,
                "title": "python3-union-find-better-than-83",
                "content": "I haven\\'t seen any solutions using union find, so I think posting it might be useful since it also has decent performance.\\n\\nThe idea here is to go through all of the cells and for each cell, if it\\'s a 1:\\n- add it to the UF structure (done in a separate step)\\n- check the right neighbor and if it\\'s also a 1, union the two cells\\n- same for down neighbor\\n\\nAt the end, the answer is the number of cells that are roots\\n\\nNote: Also tried optimizing unions using size, but that actually made the solution slower somehow\\n\\n```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        if len(grid) == 0:\\n            return 0\\n        \\n        uf = {}\\n        N = len(grid)\\n        M = len(grid[0])\\n        \\n        for i in range(N):\\n            for j in range(M):\\n                if grid[i][j] == \\'1\\':\\n                    uf[(i,j)] = (i,j)\\n        \\n        for i in range(N):\\n            for j in range(M):\\n                if grid[i][j] == \\'0\\':\\n                    continue\\n                \\n                if i+1<N and grid[i+1][j] == \\'1\\':\\n                    union(uf, (i,j), (i+1,j))\\n                if j+1<M and grid[i][j+1] == \\'1\\':\\n                    union(uf, (i,j), (i,j+1))\\n        \\n        count = 0\\n        for k, v in uf.items():\\n            if v == k:\\n                count += 1\\n        return count\\n    \\ndef union(uf, a, b) -> None:\\n    uf[root(uf, b)] = root(uf, a)\\n    \\ndef root(uf, x) -> str:\\n    r = x\\n    while r != uf[r]:\\n        r = uf[r]\\n    return r\\n```",
                "solutionTags": [
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        if len(grid) == 0:\\n            return 0\\n        \\n        uf = {}\\n        N = len(grid)\\n        M = len(grid[0])\\n        \\n        for i in range(N):\\n            for j in range(M):\\n                if grid[i][j] == \\'1\\':\\n                    uf[(i,j)] = (i,j)\\n        \\n        for i in range(N):\\n            for j in range(M):\\n                if grid[i][j] == \\'0\\':\\n                    continue\\n                \\n                if i+1<N and grid[i+1][j] == \\'1\\':\\n                    union(uf, (i,j), (i+1,j))\\n                if j+1<M and grid[i][j+1] == \\'1\\':\\n                    union(uf, (i,j), (i,j+1))\\n        \\n        count = 0\\n        for k, v in uf.items():\\n            if v == k:\\n                count += 1\\n        return count\\n    \\ndef union(uf, a, b) -> None:\\n    uf[root(uf, b)] = root(uf, a)\\n    \\ndef root(uf, x) -> str:\\n    r = x\\n    while r != uf[r]:\\n        r = uf[r]\\n    return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597046,
                "title": "c-simple-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int x[4] = {-1, 0, 1, 0};\\n    int y[4] = {0, 1, 0, -1};\\n\\n    void dfs(int i, int j, vector<vector<char>>& grid, vector<vector<bool>>& visited) {\\n        if (i < 0 || j < 0 || i > grid.size()-1 || j > grid[0].size()-1 || visited[i][j] || grid[i][j] == \\'0\\') return;\\n        visited[i][j] = true;\\n        for (int k=0; k<4; k++) {\\n            dfs(i+x[k], j+y[k], grid, visited);\\n        }\\n    }\\n\\n    int ff(vector<vector<char>>& grid) {\\n        if (!grid.size()) return 0;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n        int count = 0;\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                if (grid[i][j] == \\'1\\' and !visited[i][j]) {\\n                    dfs(i, j, grid, visited);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        return ff(grid);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int x[4] = {-1, 0, 1, 0};\\n    int y[4] = {0, 1, 0, -1};\\n\\n    void dfs(int i, int j, vector<vector<char>>& grid, vector<vector<bool>>& visited) {\\n        if (i < 0 || j < 0 || i > grid.size()-1 || j > grid[0].size()-1 || visited[i][j] || grid[i][j] == \\'0\\') return;\\n        visited[i][j] = true;\\n        for (int k=0; k<4; k++) {\\n            dfs(i+x[k], j+y[k], grid, visited);\\n        }\\n    }\\n\\n    int ff(vector<vector<char>>& grid) {\\n        if (!grid.size()) return 0;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n        int count = 0;\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                if (grid[i][j] == \\'1\\' and !visited[i][j]) {\\n                    dfs(i, j, grid, visited);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    int numIslands(vector<vector<char>>& grid) {\\n        return ff(grid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 594296,
                "title": "c-elegant-code-with-comments",
                "content": "```\\npublic int NumIslands(char[][] grid) {\\n        if(grid == null || grid.Length == 0)\\n            return 0;\\n        int numIslands = 0;\\n        for(int i = 0; i < grid.Length; i++)\\n        {\\n            for(int j = 0; j < grid[0].Length; j++)\\n            {\\n                // we have found an island\\n                if(grid[i][j] == \\'1\\')\\n                {\\n                    // check neighbours to find # of 1s that are part of this island\\n                    numIslands += DepthFirstSearch(grid, i, j);\\n                }\\n            }\\n        }\\n        \\n        return numIslands;\\n    }\\n    \\n    private int DepthFirstSearch(char[][] grid, int i, int j)\\n    {\\n        // if i and j are out of bound or grid i,j represent water or grid i,j  is already visited\\n        if(i < 0 || i >= grid.Length || j < 0 || j >= grid[0].Length || grid[i][j] == \\'0\\' || grid[i][j] == \\'v\\')\\n        {\\n            return 0;\\n        }\\n        \\n        // mark this point visited. Using \\'v \\'to mark visited\\n        grid[i][j] = \\'v\\';\\n        \\n        // check neighbours up,down,left and right in matrix. Method will mark neighbours visited if grid[i][j] are one i.e. they are also part of this island.\\n        DepthFirstSearch(grid, i-1, j);\\n        DepthFirstSearch(grid, i+1, j);\\n        DepthFirstSearch(grid, i, j-1);\\n        DepthFirstSearch(grid, i, j+1);\\n        \\n        return 1;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int NumIslands(char[][] grid) {\\n        if(grid == null || grid.Length == 0)\\n            return 0;\\n        int numIslands = 0;\\n        for(int i = 0; i < grid.Length; i++)\\n        {\\n            for(int j = 0; j < grid[0].Length; j++)\\n            {\\n                // we have found an island\\n                if(grid[i][j] == \\'1\\')\\n                {\\n                    // check neighbours to find # of 1s that are part of this island\\n                    numIslands += DepthFirstSearch(grid, i, j);\\n                }\\n            }\\n        }\\n        \\n        return numIslands;\\n    }\\n    \\n    private int DepthFirstSearch(char[][] grid, int i, int j)\\n    {\\n        // if i and j are out of bound or grid i,j represent water or grid i,j  is already visited\\n        if(i < 0 || i >= grid.Length || j < 0 || j >= grid[0].Length || grid[i][j] == \\'0\\' || grid[i][j] == \\'v\\')\\n        {\\n            return 0;\\n        }\\n        \\n        // mark this point visited. Using \\'v \\'to mark visited\\n        grid[i][j] = \\'v\\';\\n        \\n        // check neighbours up,down,left and right in matrix. Method will mark neighbours visited if grid[i][j] are one i.e. they are also part of this island.\\n        DepthFirstSearch(grid, i-1, j);\\n        DepthFirstSearch(grid, i+1, j);\\n        DepthFirstSearch(grid, i, j-1);\\n        DepthFirstSearch(grid, i, j+1);\\n        \\n        return 1;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 501371,
                "title": "simple-java-bfs-clean-code",
                "content": "```\\nclass Solution {\\n    \\n    static class Node {\\n        int row; \\n        int col;\\n        \\n        Node(int row, int col) {\\n            this.row = row;\\n            this.col = col;\\n        }\\n    }\\n    \\n    public int numIslands(char[][] grid) {\\n        if (grid == null || grid.length == 0) return 0;\\n        \\n        int numOfIslands = 0;\\n        \\n        for (int row = 0; row < grid.length; row++) {\\n            for (int col = 0; col < grid[row].length; col++) {\\n                if (grid[row][col] == \\'1\\') {\\n                    numOfIslands++;\\n             \\n                    Queue<Node> q = new LinkedList<Node>();\\n                    q.offer(new Node(row, col));\\n\\n                    while(!q.isEmpty()) {\\n                        Node n = q.poll();\\n\\n                        if (n.row - 1 >= 0 && grid[n.row - 1][n.col] == \\'1\\') {\\n                            q.offer(new Node(n.row - 1, n.col));\\n                            grid[n.row - 1][n.col] = \\'0\\';\\n                        }\\n\\n                        if (n.row + 1 < grid.length && grid[n.row + 1][n.col] == \\'1\\') {\\n                            q.offer(new Node(n.row + 1, n.col));\\n                            grid[n.row + 1 ][n.col] = \\'0\\';\\n                        }\\n\\n                        if (n.col - 1 >= 0 && grid[n.row][n.col - 1] == \\'1\\') {\\n                            q.offer(new Node(n.row, n.col - 1));\\n                            grid[n.row][n.col - 1] = \\'0\\';\\n                        }\\n\\n                        if (n.col + 1 < grid[n.row].length && grid[n.row][n.col + 1] == \\'1\\') {\\n                            q.offer(new Node(n.row, n.col + 1));\\n                            grid[n.row][n.col + 1] = \\'0\\';\\n                        }\\n\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return numOfIslands;\\n    }\\n}\\n```\\nTime complexity: O(n x m)\\nSpace complexity: O(min(n, m))",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    static class Node {\\n        int row; \\n        int col;\\n        \\n        Node(int row, int col) {\\n            this.row = row;\\n            this.col = col;\\n        }\\n    }\\n    \\n    public int numIslands(char[][] grid) {\\n        if (grid == null || grid.length == 0) return 0;\\n        \\n        int numOfIslands = 0;\\n        \\n        for (int row = 0; row < grid.length; row++) {\\n            for (int col = 0; col < grid[row].length; col++) {\\n                if (grid[row][col] == \\'1\\') {\\n                    numOfIslands++;\\n             \\n                    Queue<Node> q = new LinkedList<Node>();\\n                    q.offer(new Node(row, col));\\n\\n                    while(!q.isEmpty()) {\\n                        Node n = q.poll();\\n\\n                        if (n.row - 1 >= 0 && grid[n.row - 1][n.col] == \\'1\\') {\\n                            q.offer(new Node(n.row - 1, n.col));\\n                            grid[n.row - 1][n.col] = \\'0\\';\\n                        }\\n\\n                        if (n.row + 1 < grid.length && grid[n.row + 1][n.col] == \\'1\\') {\\n                            q.offer(new Node(n.row + 1, n.col));\\n                            grid[n.row + 1 ][n.col] = \\'0\\';\\n                        }\\n\\n                        if (n.col - 1 >= 0 && grid[n.row][n.col - 1] == \\'1\\') {\\n                            q.offer(new Node(n.row, n.col - 1));\\n                            grid[n.row][n.col - 1] = \\'0\\';\\n                        }\\n\\n                        if (n.col + 1 < grid[n.row].length && grid[n.row][n.col + 1] == \\'1\\') {\\n                            q.offer(new Node(n.row, n.col + 1));\\n                            grid[n.row][n.col + 1] = \\'0\\';\\n                        }\\n\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return numOfIslands;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431553,
                "title": "c-dfs-easy-to-understand-solution-beats-92",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint m;\\n\\t\\tint n;\\n\\t\\tvoid fill(vector<vector<char>>& grid,int x,int y){\\n\\t\\t\\tif(x<0 ||x>=m || y<0 || y>=n || grid[x][y]==\\'0\\'){\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tgrid[x][y]=\\'0\\';\\n\\t\\t\\tfill(grid,x+1,y);\\n\\t\\t\\tfill(grid,x-1,y);\\n\\t\\t\\tfill(grid,x,y+1);\\n\\t\\t\\tfill(grid,x,y-1);\\n\\t\\t}\\n\\t\\tint numIslands(vector<vector<char>>& grid) {\\n\\t\\t\\tif(grid.empty()) return 0;\\n\\t\\t\\tm=grid.size();\\n\\t\\t\\tn=grid[0].size();\\n\\t\\t\\tint res=0;\\n\\t\\t\\tfor(int i=0;i<m;i++){\\n\\t\\t\\t\\tfor(int j=0;j<n;j++){\\n\\t\\t\\t\\t\\tif(grid[i][j]==\\'1\\'){\\n\\t\\t\\t\\t\\t\\tres++;\\n\\t\\t\\t\\t\\t\\tfill(grid,i,j);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint m;\\n\\t\\tint n;\\n\\t\\tvoid fill(vector<vector<char>>& grid,int x,int y){\\n\\t\\t\\tif(x<0 ||x>=m || y<0 || y>=n || grid[x][y]==\\'0\\'){\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 117393,
                "title": "c-very-easy-and-ituitive-solution-with-expanation-accepted",
                "content": "```\npublic class Solution \n{\n    private char[,] grid;\n    private int totalRows;\n    private int totalCols;\n\n    public int NumIslands(char[,] grid)\n    {\n        int islandCount = 0;\n        this.grid = grid;\n        this.totalRows = this.grid.GetLength(0);\n        this.totalCols = this.grid.GetLength(1);\n        for (int r = 0; r < this.totalRows; r++)\n            for (int c = 0; c < this.totalCols; c++)\n            {\n                if (this.grid[r, c] == '1')     //Found land on an island.\n                {\n                    islandCount++;              //Increment island count.\n                    TravelFullIsland(r, c);     //Travel the island.\n                }\n            }\n\n        return islandCount;\n    }\n\n    private void TravelFullIsland(int r, int c)\n    {\n        if (r < 0 || c < 0 || r == this.totalRows || c == this.totalCols || this.grid[r, c] == '0' || this.grid[r, c] == 'T') return;\n        else\n        {\n            this.grid[r, c] = 'T';        //Marking travelled.\n            TravelFullIsland(r + 1, c);   //Travelling neighboring land on the island.\n            TravelFullIsland(r, c + 1);   //Travelling neighboring land on the island.\n            TravelFullIsland(r - 1, c);   //Travelling neighboring land on the island.\n            TravelFullIsland(r, c - 1);   //Travelling neighboring land on the island.\n        }\n    }\n}\n```\n![image](https://s3-lc-upload.s3.amazonaws.com/users/amandeep18feb/image_1520037191.png)\n",
                "solutionTags": [],
                "code": "```\npublic class Solution \n{\n    private char[,] grid;\n    private int totalRows;\n    private int totalCols;\n\n    public int NumIslands(char[,] grid)\n    {\n        int islandCount = 0;\n        this.grid = grid;\n        this.totalRows = this.grid.GetLength(0);\n        this.totalCols = this.grid.GetLength(1);\n        for (int r = 0; r < this.totalRows; r++)\n            for (int c = 0; c < this.totalCols; c++)\n            {\n                if (this.grid[r, c] == '1')     //Found land on an island.\n                {\n                    islandCount++;              //Increment island count.\n                    TravelFullIsland(r, c);     //Travel the island.\n                }\n            }\n\n        return islandCount;\n    }\n\n    private void TravelFullIsland(int r, int c)\n    {\n        if (r < 0 || c < 0 || r == this.totalRows || c == this.totalCols || this.grid[r, c] == '0' || this.grid[r, c] == 'T') return;\n        else\n        {\n            this.grid[r, c] = 'T';        //Marking travelled.\n            TravelFullIsland(r + 1, c);   //Travelling neighboring land on the island.\n            TravelFullIsland(r, c + 1);   //Travelling neighboring land on the island.\n            TravelFullIsland(r - 1, c);   //Travelling neighboring land on the island.\n            TravelFullIsland(r, c - 1);   //Travelling neighboring land on the island.\n        }\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 56578,
                "title": "dfs-java-solution",
                "content": "    public class Solution {\\n        public int numIslands(char[][] grid) {\\n            int total = 0;\\n            for(int i=0;i<grid.length;i++){\\n                for(int j=0;j<grid[0].length;j++){\\n                    if(grid[i][j]=='1'){\\n                        total++;\\n                        dfs(grid,i,j);\\n                    }\\n                }\\n            }   \\n            return total;\\n        }\\n        \\n        public void dfs(char[][] grid, int row, int col){\\n            if(row<0||row==grid.length||col<0||col==grid[0].length||grid[row][col]!='1')\\n                return;\\n            \\n            grid[row][col]='2';\\n            dfs(grid,row-1,col);\\n            dfs(grid,row+1,col);\\n            dfs(grid,row,col-1);\\n            dfs(grid,row,col+1);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int numIslands(char[][] grid) {\\n            int total = 0;\\n            for(int i=0;i<grid.length;i++){\\n                for(int j=0;j<grid[0].length;j++){\\n                    if(grid[i][j]=='1'){\\n                        total++;\\n                        dfs(grid,i,j);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3621229,
                "title": "simple-c-dfs-solution",
                "content": "\\n\\n# Approach\\n1. Iterate over each row and column which is not visited, and run a dfs function to traverse through each connected land. Also increase the value of cnt which represents the number of islands.\\n2. In dfs function: if row or col crosses boundary then we need to return function.\\n3. Also when the grid corresponding to particular row and col is water ie \\'0\\' then also we need to return.\\n4. Also when we are on already visited grid we need to return\\n5. Otherwise, mark the grid as visited and traverse in all possible directions and run the dfs function.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int row,int col,vector<vector<char>>&grid,vector<vector<int>>&vis){\\n        int n=grid.size(),m=grid[0].size();\\n        if(row<0||row>=n||col<0||col>=m||grid[row][col]==\\'0\\'||vis[row][col]){\\n            return;\\n        }\\n        vis[row][col]=1;\\n        vector<pair<int,int>>dir={{1,0},{0,1},{-1,0},{0,-1}};\\n        for(auto ele:dir){\\n            int nr=row+ele.first,nc=col+ele.second;\\n            dfs(nr,nc,grid,vis);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int cnt=0;\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(!vis[i][j]&&grid[i][j]==\\'1\\'){\\n                    cnt++;\\n                    dfs(i,j,grid,vis);\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n       // <!-- Please upvote if you liked !!!-->\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int row,int col,vector<vector<char>>&grid,vector<vector<int>>&vis){\\n        int n=grid.size(),m=grid[0].size();\\n        if(row<0||row>=n||col<0||col>=m||grid[row][col]==\\'0\\'||vis[row][col]){\\n            return;\\n        }\\n        vis[row][col]=1;\\n        vector<pair<int,int>>dir={{1,0},{0,1},{-1,0},{0,-1}};\\n        for(auto ele:dir){\\n            int nr=row+ele.first,nc=col+ele.second;\\n            dfs(nr,nc,grid,vis);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int cnt=0;\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(!vis[i][j]&&grid[i][j]==\\'1\\'){\\n                    cnt++;\\n                    dfs(i,j,grid,vis);\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n       // <!-- Please upvote if you liked !!!-->\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551263,
                "title": "simple-intuitive-solution-using-a-recursive-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRecursive marking using ```bomb()``` funtion\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMark the already found island to ```\"2\"```\\n\\n# Complexity\\n- Time complexity: $$O(n \\\\times m )$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n \\\\times m )$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        def bomb(grid, m, n, i, j):\\n            if i < n and j < m and i >= 0 and j >= 0:\\n                if grid[j][i] == \"1\":\\n                    grid[j][i] = \"2\"\\n                    bomb(grid, m, n, i + 1, j)\\n                    bomb(grid, m, n, i - 1, j)\\n                    bomb(grid, m, n, i , j + 1)\\n                    bomb(grid, m, n, i , j - 1)\\n            return\\n        r = 0 \\n        m = len(grid)\\n        n = len(grid[0])\\n        for y in range(m):\\n            for x in range(n):\\n                if grid[y][x] == \"1\":\\n                    r = r + 1\\n                    bomb(grid, m, n, x, y)\\n        return r\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```bomb()```\n```\"2\"```\n```\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        def bomb(grid, m, n, i, j):\\n            if i < n and j < m and i >= 0 and j >= 0:\\n                if grid[j][i] == \"1\":\\n                    grid[j][i] = \"2\"\\n                    bomb(grid, m, n, i + 1, j)\\n                    bomb(grid, m, n, i - 1, j)\\n                    bomb(grid, m, n, i , j + 1)\\n                    bomb(grid, m, n, i , j - 1)\\n            return\\n        r = 0 \\n        m = len(grid)\\n        n = len(grid[0])\\n        for y in range(m):\\n            for x in range(n):\\n                if grid[y][x] == \"1\":\\n                    r = r + 1\\n                    bomb(grid, m, n, x, y)\\n        return r\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567749,
                "content": [
                    {
                        "username": "MarkMarcel",
                        "content": "My challenge with solving this problem was getting the definition of an island. What I thought an island was, is a 1 surrounded by 0\\'s either on left and right or top and bottom. Like in image, my definition gave the 2 islands circled in example 1.\\n![image](https://assets.leetcode.com/users/images/0cadaf5c-858d-4cfd-91e8-27427e5d9d01_1649931304.8787706.png)\\n\\nAfter getting my test case wrong, I went through the discussions and based on solutions I realised the question meant an island is a string of 1s like shown in the images below\\n![image](https://assets.leetcode.com/users/images/e6a18482-7542-421a-bd27-cf79e44618e5_1649932030.3147244.png)\\n![image](https://assets.leetcode.com/users/images/b6938d3b-26d7-45d9-88a8-e4956b0ed10a_1649932030.3330166.png)\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "Why is \\'1\\' and \\'0\\' chars? Just to irritate people?"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@sanidhyas3s](/sanidhyas3s) Same lol. My code 100% worked after I changed it from a number to char "
                    },
                    {
                        "username": "sanidhyas3s",
                        "content": "[@nemanjac](/nemanjac) They could\\'ve kept it a char and let it have a numerical value of 0 or 1 instead of \\'0\\' and \\'1\\'. Can\\'t believe I wasted like 10 minutes just figuring out that I had 1 instead of \\'1\\'."
                    },
                    {
                        "username": "lucasan2300",
                        "content": "would you think that, it doesn't matter, but It will be to develop some technique for change it, or handle... please smile!"
                    },
                    {
                        "username": "avyayk",
                        "content": "[@nemanjac](/nemanjac) A bit (1/0) takes up one bit and also achieves the goal :)"
                    },
                    {
                        "username": "Msey",
                        "content": "[@mcthouacbb](/mcthouacbb) it teaches us to be attentive"
                    },
                    {
                        "username": "nemanjac",
                        "content": "Perhaps because a char takes up 2 bytes, where as an int takes up 4."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "Basically. Spent a good 10-15 minutes wondering why my conditions kept miscomparing...Take it as a lesson to read the inputs clearly lol."
                    },
                    {
                        "username": "close27",
                        "content": "lol..agree"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "[@Zephromonia](/Zephromonia) same :|"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Leetcode likes to do a little bit of trolling"
                    },
                    {
                        "username": "Zephromonia",
                        "content": "Quite annoying. Was using not boolean operator for a while."
                    },
                    {
                        "username": "uwswe",
                        "content": "Looks like quite a few people labled their code as a BFS solution, when it\\'s actually DFS. And what\\'s worse is that you\\'re being praised for an incorrect solutiuon. Just because leetcode accepts it, doesn\\'t mean its correct.\\n\\nIf you don\\'t know the difference, then you should read the leetcode chapters on BFS, and DFS. The problem clearly states \"Queue and BFS\", and many people didn\\'t bother to use a queue at all. While this problem can be solved recursively (i.e. DFS), that\\'s not the solution we were asked to provide. The main difference between BFS and DFS is the order you visit the nodes. BFS uses a Queue to visit the closest nodes first, while DFS pretty much skips some nodes next door and follows the path until it reaches a deadend. \\n\\nWhat if the one node you were looking for was the 2nd neighbor, and you picked the first one and followed the path? \\n\\nA better question is, what are you going to do when your interviewer tells you that your recursive solution overflowed the call stack, and you need to improve your solution? Yeah you could implement a Stack yourself, and not use the call stack. But then what if your interviewer really wants the best solution possible, which should be BFS, but you give them your DFS solution?\\n\\nThere\\'s a lot of people who use leetcode to learn how to code, and understand data structures. Praising incorrect solutions is stumping the grow of future engineers. Also, if you want to proudly share your solution, please provide properly formatted code with descriptive variable names - no one wants to break out pen and paper to dissect your logic.\\n\\n"
                    },
                    {
                        "username": "jeehaytch",
                        "content": "My solution is DFS (using a stack) and I beat 96 to 99%"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "1. You\\'re adding constraints not present in the problem statement. The problem statement leaves it to the solver to select a traversal method. \\n\\n2. We\\'re not looking for a specific node. DFS and BFS are identical in efficiency for this problem.\\n\\n3. BFS isn\\'t \\'the best possible\\' and I\\'d tell the interviewer that. The call stack would never \\'overflow\\' because you have at most m*n calls. This is the same space complexity as BFS. \\n\\n4. Don\\'t use leetcode to learn how to code. Code written for leetcode problems sacrifices readability for optimization. Use leetcode to learn how to do technical interviews. Learn how to program from books, language docs, courses.\\n\\n5. You probably meant \\'stunts\\' not \\'stumps\\'. Forgivable as I assume you\\'re ESL, but the condescending nature of your post weighs against my typical charity.\\n\\n6. If you don\\'t understand a solution you should \\'dissect\\' the logic. How else do you actually learn? \\n\\nI\\'m awed by the irony of you lambasting people for \\'praising\\' \\'incorrect\\' solutions in post where you ignorantly condescend with inane drivel in every paragraph.\\n\\nYou are both incorrect and arrogant. You\\'re errorgant. \\n\\nIt\\'s an off-putting character flaw and will probably harm you more in interviews (and in life) than bombing a technical round. "
                    },
                    {
                        "username": "klami",
                        "content": "the problem is also listed under \"Stack and DFS\" so I think either is okay"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 But as of me , I am more comfortable at using bfs instead of dfs."
                    },
                    {
                        "username": "roundlet",
                        "content": "I just encountered this question in an interview, and I have no idea about how to handle this efficiently. Could anyone provides any hints?"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "we can solve in n**2 using BFS traversal. please have look on solution at  \\nhttps://leetcode.com/problems/number-of-islands/submissions/993397265/"
                    },
                    {
                        "username": "TeaTrey",
                        "content": "[@lumpychum](/lumpychum) I used visited, but overwriting with \\'0\\' is pretty cool. Thanks"
                    },
                    {
                        "username": "math_pi",
                        "content": "It is a standard grid problem, you can use DFS and vector of directions."
                    },
                    {
                        "username": "lumpychum",
                        "content": "Essentially you want to traverse the matrix until you find a 1. Once you locate one (no pun intended) you essentially use flood fill to recursively \"mark\" any connected 1s (the rest of the island) by replacing them with zeros. If you do not want to mutate the given matrix, you can use a visited matrix."
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I have encountered this problem. I want to share my findings in case someone faces this one as well.\\n\\nBefore the start of coding, I thought the condition that one cell being inspected more than once is not a great issue because the duplicate cells are set to \\'0\\' anyway. However, that was WRONG. Because, before the cell is set to \\'0\\', it has already been pushed into queue by its neighbors.\\nThe time complexity is no longer O(M * N);\\nInstead, one cell cause 2 copies of neighbors, and then 4 copies of neighbors of neighbors ...\\n\\nSo as long as neighbors are pushed into queue, they should be set to \\'0\\' immediately."
                    },
                    {
                        "username": "aparr487",
                        "content": "Thanks! This was exactly my problem (flooding the land cell after dequeuing, rather than when enqueuing)."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan you please explain more the testcases and what exactly island means? thanks"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/30e6adfa-133f-4607-ba65-521d0e774b34_1643961955.1657922.png)\\n\\n ![image](https://assets.leetcode.com/users/images/8f49d0cb-605d-4549-8546-b6ad7fd05f7a_1643964600.5265105.png)\\n"
                    },
                    {
                        "username": "david120",
                        "content": "This is probably an old problem and not worth changing, but it makes little sense to not have the elements of `grid` be integers.  I was scratching my head at why what should have been a very simple solution was not working until I noticed the quotes on the 1s and 0s.  I suppose this is what I get for using python, which allows comparison between `1` and `\\'1\\'`."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Same happened with me also"
                    },
                    {
                        "username": "chaos28",
                        "content": "When using DFS to solve, it take O(m * n) to iterate through the matrix, but in the recursion dfs function, it also need to iterate over the matrix , so does it mean that the overall time complexity turn out to be O(m * n) * O(m * n)?"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "Why is the time complexity of both DFS and BFS O(m * n) ? I thought it would be same as path finding algorithm, as we traverse 4 ways (up, down, left, right) it is O(4^ (m + n)).\\n\\nCan anyone explain this? I do not want to get this wrong at interview, hence asking for you analysis."
                    },
                    {
                        "username": "nambrose",
                        "content": "[@sidharthgurbani](/sidharthgurbani) What about the case where the entire grid is 1\\'s, we would have to go over each spot twice (the dfs of the entire grid, and our double for loop)"
                    },
                    {
                        "username": "sidharthgurbani",
                        "content": "It is because during every DFS, you change the \"1\" to \"0\". Thereby eliminating the need for running DFS on it again. So in short you would go over each element only once"
                    }
                ]
            },
            {
                "id": 1568770,
                "content": [
                    {
                        "username": "MarkMarcel",
                        "content": "My challenge with solving this problem was getting the definition of an island. What I thought an island was, is a 1 surrounded by 0\\'s either on left and right or top and bottom. Like in image, my definition gave the 2 islands circled in example 1.\\n![image](https://assets.leetcode.com/users/images/0cadaf5c-858d-4cfd-91e8-27427e5d9d01_1649931304.8787706.png)\\n\\nAfter getting my test case wrong, I went through the discussions and based on solutions I realised the question meant an island is a string of 1s like shown in the images below\\n![image](https://assets.leetcode.com/users/images/e6a18482-7542-421a-bd27-cf79e44618e5_1649932030.3147244.png)\\n![image](https://assets.leetcode.com/users/images/b6938d3b-26d7-45d9-88a8-e4956b0ed10a_1649932030.3330166.png)\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "Why is \\'1\\' and \\'0\\' chars? Just to irritate people?"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@sanidhyas3s](/sanidhyas3s) Same lol. My code 100% worked after I changed it from a number to char "
                    },
                    {
                        "username": "sanidhyas3s",
                        "content": "[@nemanjac](/nemanjac) They could\\'ve kept it a char and let it have a numerical value of 0 or 1 instead of \\'0\\' and \\'1\\'. Can\\'t believe I wasted like 10 minutes just figuring out that I had 1 instead of \\'1\\'."
                    },
                    {
                        "username": "lucasan2300",
                        "content": "would you think that, it doesn't matter, but It will be to develop some technique for change it, or handle... please smile!"
                    },
                    {
                        "username": "avyayk",
                        "content": "[@nemanjac](/nemanjac) A bit (1/0) takes up one bit and also achieves the goal :)"
                    },
                    {
                        "username": "Msey",
                        "content": "[@mcthouacbb](/mcthouacbb) it teaches us to be attentive"
                    },
                    {
                        "username": "nemanjac",
                        "content": "Perhaps because a char takes up 2 bytes, where as an int takes up 4."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "Basically. Spent a good 10-15 minutes wondering why my conditions kept miscomparing...Take it as a lesson to read the inputs clearly lol."
                    },
                    {
                        "username": "close27",
                        "content": "lol..agree"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "[@Zephromonia](/Zephromonia) same :|"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Leetcode likes to do a little bit of trolling"
                    },
                    {
                        "username": "Zephromonia",
                        "content": "Quite annoying. Was using not boolean operator for a while."
                    },
                    {
                        "username": "uwswe",
                        "content": "Looks like quite a few people labled their code as a BFS solution, when it\\'s actually DFS. And what\\'s worse is that you\\'re being praised for an incorrect solutiuon. Just because leetcode accepts it, doesn\\'t mean its correct.\\n\\nIf you don\\'t know the difference, then you should read the leetcode chapters on BFS, and DFS. The problem clearly states \"Queue and BFS\", and many people didn\\'t bother to use a queue at all. While this problem can be solved recursively (i.e. DFS), that\\'s not the solution we were asked to provide. The main difference between BFS and DFS is the order you visit the nodes. BFS uses a Queue to visit the closest nodes first, while DFS pretty much skips some nodes next door and follows the path until it reaches a deadend. \\n\\nWhat if the one node you were looking for was the 2nd neighbor, and you picked the first one and followed the path? \\n\\nA better question is, what are you going to do when your interviewer tells you that your recursive solution overflowed the call stack, and you need to improve your solution? Yeah you could implement a Stack yourself, and not use the call stack. But then what if your interviewer really wants the best solution possible, which should be BFS, but you give them your DFS solution?\\n\\nThere\\'s a lot of people who use leetcode to learn how to code, and understand data structures. Praising incorrect solutions is stumping the grow of future engineers. Also, if you want to proudly share your solution, please provide properly formatted code with descriptive variable names - no one wants to break out pen and paper to dissect your logic.\\n\\n"
                    },
                    {
                        "username": "jeehaytch",
                        "content": "My solution is DFS (using a stack) and I beat 96 to 99%"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "1. You\\'re adding constraints not present in the problem statement. The problem statement leaves it to the solver to select a traversal method. \\n\\n2. We\\'re not looking for a specific node. DFS and BFS are identical in efficiency for this problem.\\n\\n3. BFS isn\\'t \\'the best possible\\' and I\\'d tell the interviewer that. The call stack would never \\'overflow\\' because you have at most m*n calls. This is the same space complexity as BFS. \\n\\n4. Don\\'t use leetcode to learn how to code. Code written for leetcode problems sacrifices readability for optimization. Use leetcode to learn how to do technical interviews. Learn how to program from books, language docs, courses.\\n\\n5. You probably meant \\'stunts\\' not \\'stumps\\'. Forgivable as I assume you\\'re ESL, but the condescending nature of your post weighs against my typical charity.\\n\\n6. If you don\\'t understand a solution you should \\'dissect\\' the logic. How else do you actually learn? \\n\\nI\\'m awed by the irony of you lambasting people for \\'praising\\' \\'incorrect\\' solutions in post where you ignorantly condescend with inane drivel in every paragraph.\\n\\nYou are both incorrect and arrogant. You\\'re errorgant. \\n\\nIt\\'s an off-putting character flaw and will probably harm you more in interviews (and in life) than bombing a technical round. "
                    },
                    {
                        "username": "klami",
                        "content": "the problem is also listed under \"Stack and DFS\" so I think either is okay"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 But as of me , I am more comfortable at using bfs instead of dfs."
                    },
                    {
                        "username": "roundlet",
                        "content": "I just encountered this question in an interview, and I have no idea about how to handle this efficiently. Could anyone provides any hints?"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "we can solve in n**2 using BFS traversal. please have look on solution at  \\nhttps://leetcode.com/problems/number-of-islands/submissions/993397265/"
                    },
                    {
                        "username": "TeaTrey",
                        "content": "[@lumpychum](/lumpychum) I used visited, but overwriting with \\'0\\' is pretty cool. Thanks"
                    },
                    {
                        "username": "math_pi",
                        "content": "It is a standard grid problem, you can use DFS and vector of directions."
                    },
                    {
                        "username": "lumpychum",
                        "content": "Essentially you want to traverse the matrix until you find a 1. Once you locate one (no pun intended) you essentially use flood fill to recursively \"mark\" any connected 1s (the rest of the island) by replacing them with zeros. If you do not want to mutate the given matrix, you can use a visited matrix."
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I have encountered this problem. I want to share my findings in case someone faces this one as well.\\n\\nBefore the start of coding, I thought the condition that one cell being inspected more than once is not a great issue because the duplicate cells are set to \\'0\\' anyway. However, that was WRONG. Because, before the cell is set to \\'0\\', it has already been pushed into queue by its neighbors.\\nThe time complexity is no longer O(M * N);\\nInstead, one cell cause 2 copies of neighbors, and then 4 copies of neighbors of neighbors ...\\n\\nSo as long as neighbors are pushed into queue, they should be set to \\'0\\' immediately."
                    },
                    {
                        "username": "aparr487",
                        "content": "Thanks! This was exactly my problem (flooding the land cell after dequeuing, rather than when enqueuing)."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan you please explain more the testcases and what exactly island means? thanks"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/30e6adfa-133f-4607-ba65-521d0e774b34_1643961955.1657922.png)\\n\\n ![image](https://assets.leetcode.com/users/images/8f49d0cb-605d-4549-8546-b6ad7fd05f7a_1643964600.5265105.png)\\n"
                    },
                    {
                        "username": "david120",
                        "content": "This is probably an old problem and not worth changing, but it makes little sense to not have the elements of `grid` be integers.  I was scratching my head at why what should have been a very simple solution was not working until I noticed the quotes on the 1s and 0s.  I suppose this is what I get for using python, which allows comparison between `1` and `\\'1\\'`."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Same happened with me also"
                    },
                    {
                        "username": "chaos28",
                        "content": "When using DFS to solve, it take O(m * n) to iterate through the matrix, but in the recursion dfs function, it also need to iterate over the matrix , so does it mean that the overall time complexity turn out to be O(m * n) * O(m * n)?"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "Why is the time complexity of both DFS and BFS O(m * n) ? I thought it would be same as path finding algorithm, as we traverse 4 ways (up, down, left, right) it is O(4^ (m + n)).\\n\\nCan anyone explain this? I do not want to get this wrong at interview, hence asking for you analysis."
                    },
                    {
                        "username": "nambrose",
                        "content": "[@sidharthgurbani](/sidharthgurbani) What about the case where the entire grid is 1\\'s, we would have to go over each spot twice (the dfs of the entire grid, and our double for loop)"
                    },
                    {
                        "username": "sidharthgurbani",
                        "content": "It is because during every DFS, you change the \"1\" to \"0\". Thereby eliminating the need for running DFS on it again. So in short you would go over each element only once"
                    }
                ]
            },
            {
                "id": 1572439,
                "content": [
                    {
                        "username": "MarkMarcel",
                        "content": "My challenge with solving this problem was getting the definition of an island. What I thought an island was, is a 1 surrounded by 0\\'s either on left and right or top and bottom. Like in image, my definition gave the 2 islands circled in example 1.\\n![image](https://assets.leetcode.com/users/images/0cadaf5c-858d-4cfd-91e8-27427e5d9d01_1649931304.8787706.png)\\n\\nAfter getting my test case wrong, I went through the discussions and based on solutions I realised the question meant an island is a string of 1s like shown in the images below\\n![image](https://assets.leetcode.com/users/images/e6a18482-7542-421a-bd27-cf79e44618e5_1649932030.3147244.png)\\n![image](https://assets.leetcode.com/users/images/b6938d3b-26d7-45d9-88a8-e4956b0ed10a_1649932030.3330166.png)\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "Why is \\'1\\' and \\'0\\' chars? Just to irritate people?"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@sanidhyas3s](/sanidhyas3s) Same lol. My code 100% worked after I changed it from a number to char "
                    },
                    {
                        "username": "sanidhyas3s",
                        "content": "[@nemanjac](/nemanjac) They could\\'ve kept it a char and let it have a numerical value of 0 or 1 instead of \\'0\\' and \\'1\\'. Can\\'t believe I wasted like 10 minutes just figuring out that I had 1 instead of \\'1\\'."
                    },
                    {
                        "username": "lucasan2300",
                        "content": "would you think that, it doesn't matter, but It will be to develop some technique for change it, or handle... please smile!"
                    },
                    {
                        "username": "avyayk",
                        "content": "[@nemanjac](/nemanjac) A bit (1/0) takes up one bit and also achieves the goal :)"
                    },
                    {
                        "username": "Msey",
                        "content": "[@mcthouacbb](/mcthouacbb) it teaches us to be attentive"
                    },
                    {
                        "username": "nemanjac",
                        "content": "Perhaps because a char takes up 2 bytes, where as an int takes up 4."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "Basically. Spent a good 10-15 minutes wondering why my conditions kept miscomparing...Take it as a lesson to read the inputs clearly lol."
                    },
                    {
                        "username": "close27",
                        "content": "lol..agree"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "[@Zephromonia](/Zephromonia) same :|"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Leetcode likes to do a little bit of trolling"
                    },
                    {
                        "username": "Zephromonia",
                        "content": "Quite annoying. Was using not boolean operator for a while."
                    },
                    {
                        "username": "uwswe",
                        "content": "Looks like quite a few people labled their code as a BFS solution, when it\\'s actually DFS. And what\\'s worse is that you\\'re being praised for an incorrect solutiuon. Just because leetcode accepts it, doesn\\'t mean its correct.\\n\\nIf you don\\'t know the difference, then you should read the leetcode chapters on BFS, and DFS. The problem clearly states \"Queue and BFS\", and many people didn\\'t bother to use a queue at all. While this problem can be solved recursively (i.e. DFS), that\\'s not the solution we were asked to provide. The main difference between BFS and DFS is the order you visit the nodes. BFS uses a Queue to visit the closest nodes first, while DFS pretty much skips some nodes next door and follows the path until it reaches a deadend. \\n\\nWhat if the one node you were looking for was the 2nd neighbor, and you picked the first one and followed the path? \\n\\nA better question is, what are you going to do when your interviewer tells you that your recursive solution overflowed the call stack, and you need to improve your solution? Yeah you could implement a Stack yourself, and not use the call stack. But then what if your interviewer really wants the best solution possible, which should be BFS, but you give them your DFS solution?\\n\\nThere\\'s a lot of people who use leetcode to learn how to code, and understand data structures. Praising incorrect solutions is stumping the grow of future engineers. Also, if you want to proudly share your solution, please provide properly formatted code with descriptive variable names - no one wants to break out pen and paper to dissect your logic.\\n\\n"
                    },
                    {
                        "username": "jeehaytch",
                        "content": "My solution is DFS (using a stack) and I beat 96 to 99%"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "1. You\\'re adding constraints not present in the problem statement. The problem statement leaves it to the solver to select a traversal method. \\n\\n2. We\\'re not looking for a specific node. DFS and BFS are identical in efficiency for this problem.\\n\\n3. BFS isn\\'t \\'the best possible\\' and I\\'d tell the interviewer that. The call stack would never \\'overflow\\' because you have at most m*n calls. This is the same space complexity as BFS. \\n\\n4. Don\\'t use leetcode to learn how to code. Code written for leetcode problems sacrifices readability for optimization. Use leetcode to learn how to do technical interviews. Learn how to program from books, language docs, courses.\\n\\n5. You probably meant \\'stunts\\' not \\'stumps\\'. Forgivable as I assume you\\'re ESL, but the condescending nature of your post weighs against my typical charity.\\n\\n6. If you don\\'t understand a solution you should \\'dissect\\' the logic. How else do you actually learn? \\n\\nI\\'m awed by the irony of you lambasting people for \\'praising\\' \\'incorrect\\' solutions in post where you ignorantly condescend with inane drivel in every paragraph.\\n\\nYou are both incorrect and arrogant. You\\'re errorgant. \\n\\nIt\\'s an off-putting character flaw and will probably harm you more in interviews (and in life) than bombing a technical round. "
                    },
                    {
                        "username": "klami",
                        "content": "the problem is also listed under \"Stack and DFS\" so I think either is okay"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 But as of me , I am more comfortable at using bfs instead of dfs."
                    },
                    {
                        "username": "roundlet",
                        "content": "I just encountered this question in an interview, and I have no idea about how to handle this efficiently. Could anyone provides any hints?"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "we can solve in n**2 using BFS traversal. please have look on solution at  \\nhttps://leetcode.com/problems/number-of-islands/submissions/993397265/"
                    },
                    {
                        "username": "TeaTrey",
                        "content": "[@lumpychum](/lumpychum) I used visited, but overwriting with \\'0\\' is pretty cool. Thanks"
                    },
                    {
                        "username": "math_pi",
                        "content": "It is a standard grid problem, you can use DFS and vector of directions."
                    },
                    {
                        "username": "lumpychum",
                        "content": "Essentially you want to traverse the matrix until you find a 1. Once you locate one (no pun intended) you essentially use flood fill to recursively \"mark\" any connected 1s (the rest of the island) by replacing them with zeros. If you do not want to mutate the given matrix, you can use a visited matrix."
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I have encountered this problem. I want to share my findings in case someone faces this one as well.\\n\\nBefore the start of coding, I thought the condition that one cell being inspected more than once is not a great issue because the duplicate cells are set to \\'0\\' anyway. However, that was WRONG. Because, before the cell is set to \\'0\\', it has already been pushed into queue by its neighbors.\\nThe time complexity is no longer O(M * N);\\nInstead, one cell cause 2 copies of neighbors, and then 4 copies of neighbors of neighbors ...\\n\\nSo as long as neighbors are pushed into queue, they should be set to \\'0\\' immediately."
                    },
                    {
                        "username": "aparr487",
                        "content": "Thanks! This was exactly my problem (flooding the land cell after dequeuing, rather than when enqueuing)."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan you please explain more the testcases and what exactly island means? thanks"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/30e6adfa-133f-4607-ba65-521d0e774b34_1643961955.1657922.png)\\n\\n ![image](https://assets.leetcode.com/users/images/8f49d0cb-605d-4549-8546-b6ad7fd05f7a_1643964600.5265105.png)\\n"
                    },
                    {
                        "username": "david120",
                        "content": "This is probably an old problem and not worth changing, but it makes little sense to not have the elements of `grid` be integers.  I was scratching my head at why what should have been a very simple solution was not working until I noticed the quotes on the 1s and 0s.  I suppose this is what I get for using python, which allows comparison between `1` and `\\'1\\'`."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Same happened with me also"
                    },
                    {
                        "username": "chaos28",
                        "content": "When using DFS to solve, it take O(m * n) to iterate through the matrix, but in the recursion dfs function, it also need to iterate over the matrix , so does it mean that the overall time complexity turn out to be O(m * n) * O(m * n)?"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "Why is the time complexity of both DFS and BFS O(m * n) ? I thought it would be same as path finding algorithm, as we traverse 4 ways (up, down, left, right) it is O(4^ (m + n)).\\n\\nCan anyone explain this? I do not want to get this wrong at interview, hence asking for you analysis."
                    },
                    {
                        "username": "nambrose",
                        "content": "[@sidharthgurbani](/sidharthgurbani) What about the case where the entire grid is 1\\'s, we would have to go over each spot twice (the dfs of the entire grid, and our double for loop)"
                    },
                    {
                        "username": "sidharthgurbani",
                        "content": "It is because during every DFS, you change the \"1\" to \"0\". Thereby eliminating the need for running DFS on it again. So in short you would go over each element only once"
                    }
                ]
            },
            {
                "id": 1564854,
                "content": [
                    {
                        "username": "MarkMarcel",
                        "content": "My challenge with solving this problem was getting the definition of an island. What I thought an island was, is a 1 surrounded by 0\\'s either on left and right or top and bottom. Like in image, my definition gave the 2 islands circled in example 1.\\n![image](https://assets.leetcode.com/users/images/0cadaf5c-858d-4cfd-91e8-27427e5d9d01_1649931304.8787706.png)\\n\\nAfter getting my test case wrong, I went through the discussions and based on solutions I realised the question meant an island is a string of 1s like shown in the images below\\n![image](https://assets.leetcode.com/users/images/e6a18482-7542-421a-bd27-cf79e44618e5_1649932030.3147244.png)\\n![image](https://assets.leetcode.com/users/images/b6938d3b-26d7-45d9-88a8-e4956b0ed10a_1649932030.3330166.png)\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "Why is \\'1\\' and \\'0\\' chars? Just to irritate people?"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@sanidhyas3s](/sanidhyas3s) Same lol. My code 100% worked after I changed it from a number to char "
                    },
                    {
                        "username": "sanidhyas3s",
                        "content": "[@nemanjac](/nemanjac) They could\\'ve kept it a char and let it have a numerical value of 0 or 1 instead of \\'0\\' and \\'1\\'. Can\\'t believe I wasted like 10 minutes just figuring out that I had 1 instead of \\'1\\'."
                    },
                    {
                        "username": "lucasan2300",
                        "content": "would you think that, it doesn't matter, but It will be to develop some technique for change it, or handle... please smile!"
                    },
                    {
                        "username": "avyayk",
                        "content": "[@nemanjac](/nemanjac) A bit (1/0) takes up one bit and also achieves the goal :)"
                    },
                    {
                        "username": "Msey",
                        "content": "[@mcthouacbb](/mcthouacbb) it teaches us to be attentive"
                    },
                    {
                        "username": "nemanjac",
                        "content": "Perhaps because a char takes up 2 bytes, where as an int takes up 4."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "Basically. Spent a good 10-15 minutes wondering why my conditions kept miscomparing...Take it as a lesson to read the inputs clearly lol."
                    },
                    {
                        "username": "close27",
                        "content": "lol..agree"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "[@Zephromonia](/Zephromonia) same :|"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Leetcode likes to do a little bit of trolling"
                    },
                    {
                        "username": "Zephromonia",
                        "content": "Quite annoying. Was using not boolean operator for a while."
                    },
                    {
                        "username": "uwswe",
                        "content": "Looks like quite a few people labled their code as a BFS solution, when it\\'s actually DFS. And what\\'s worse is that you\\'re being praised for an incorrect solutiuon. Just because leetcode accepts it, doesn\\'t mean its correct.\\n\\nIf you don\\'t know the difference, then you should read the leetcode chapters on BFS, and DFS. The problem clearly states \"Queue and BFS\", and many people didn\\'t bother to use a queue at all. While this problem can be solved recursively (i.e. DFS), that\\'s not the solution we were asked to provide. The main difference between BFS and DFS is the order you visit the nodes. BFS uses a Queue to visit the closest nodes first, while DFS pretty much skips some nodes next door and follows the path until it reaches a deadend. \\n\\nWhat if the one node you were looking for was the 2nd neighbor, and you picked the first one and followed the path? \\n\\nA better question is, what are you going to do when your interviewer tells you that your recursive solution overflowed the call stack, and you need to improve your solution? Yeah you could implement a Stack yourself, and not use the call stack. But then what if your interviewer really wants the best solution possible, which should be BFS, but you give them your DFS solution?\\n\\nThere\\'s a lot of people who use leetcode to learn how to code, and understand data structures. Praising incorrect solutions is stumping the grow of future engineers. Also, if you want to proudly share your solution, please provide properly formatted code with descriptive variable names - no one wants to break out pen and paper to dissect your logic.\\n\\n"
                    },
                    {
                        "username": "jeehaytch",
                        "content": "My solution is DFS (using a stack) and I beat 96 to 99%"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "1. You\\'re adding constraints not present in the problem statement. The problem statement leaves it to the solver to select a traversal method. \\n\\n2. We\\'re not looking for a specific node. DFS and BFS are identical in efficiency for this problem.\\n\\n3. BFS isn\\'t \\'the best possible\\' and I\\'d tell the interviewer that. The call stack would never \\'overflow\\' because you have at most m*n calls. This is the same space complexity as BFS. \\n\\n4. Don\\'t use leetcode to learn how to code. Code written for leetcode problems sacrifices readability for optimization. Use leetcode to learn how to do technical interviews. Learn how to program from books, language docs, courses.\\n\\n5. You probably meant \\'stunts\\' not \\'stumps\\'. Forgivable as I assume you\\'re ESL, but the condescending nature of your post weighs against my typical charity.\\n\\n6. If you don\\'t understand a solution you should \\'dissect\\' the logic. How else do you actually learn? \\n\\nI\\'m awed by the irony of you lambasting people for \\'praising\\' \\'incorrect\\' solutions in post where you ignorantly condescend with inane drivel in every paragraph.\\n\\nYou are both incorrect and arrogant. You\\'re errorgant. \\n\\nIt\\'s an off-putting character flaw and will probably harm you more in interviews (and in life) than bombing a technical round. "
                    },
                    {
                        "username": "klami",
                        "content": "the problem is also listed under \"Stack and DFS\" so I think either is okay"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 But as of me , I am more comfortable at using bfs instead of dfs."
                    },
                    {
                        "username": "roundlet",
                        "content": "I just encountered this question in an interview, and I have no idea about how to handle this efficiently. Could anyone provides any hints?"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "we can solve in n**2 using BFS traversal. please have look on solution at  \\nhttps://leetcode.com/problems/number-of-islands/submissions/993397265/"
                    },
                    {
                        "username": "TeaTrey",
                        "content": "[@lumpychum](/lumpychum) I used visited, but overwriting with \\'0\\' is pretty cool. Thanks"
                    },
                    {
                        "username": "math_pi",
                        "content": "It is a standard grid problem, you can use DFS and vector of directions."
                    },
                    {
                        "username": "lumpychum",
                        "content": "Essentially you want to traverse the matrix until you find a 1. Once you locate one (no pun intended) you essentially use flood fill to recursively \"mark\" any connected 1s (the rest of the island) by replacing them with zeros. If you do not want to mutate the given matrix, you can use a visited matrix."
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I have encountered this problem. I want to share my findings in case someone faces this one as well.\\n\\nBefore the start of coding, I thought the condition that one cell being inspected more than once is not a great issue because the duplicate cells are set to \\'0\\' anyway. However, that was WRONG. Because, before the cell is set to \\'0\\', it has already been pushed into queue by its neighbors.\\nThe time complexity is no longer O(M * N);\\nInstead, one cell cause 2 copies of neighbors, and then 4 copies of neighbors of neighbors ...\\n\\nSo as long as neighbors are pushed into queue, they should be set to \\'0\\' immediately."
                    },
                    {
                        "username": "aparr487",
                        "content": "Thanks! This was exactly my problem (flooding the land cell after dequeuing, rather than when enqueuing)."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan you please explain more the testcases and what exactly island means? thanks"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/30e6adfa-133f-4607-ba65-521d0e774b34_1643961955.1657922.png)\\n\\n ![image](https://assets.leetcode.com/users/images/8f49d0cb-605d-4549-8546-b6ad7fd05f7a_1643964600.5265105.png)\\n"
                    },
                    {
                        "username": "david120",
                        "content": "This is probably an old problem and not worth changing, but it makes little sense to not have the elements of `grid` be integers.  I was scratching my head at why what should have been a very simple solution was not working until I noticed the quotes on the 1s and 0s.  I suppose this is what I get for using python, which allows comparison between `1` and `\\'1\\'`."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Same happened with me also"
                    },
                    {
                        "username": "chaos28",
                        "content": "When using DFS to solve, it take O(m * n) to iterate through the matrix, but in the recursion dfs function, it also need to iterate over the matrix , so does it mean that the overall time complexity turn out to be O(m * n) * O(m * n)?"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "Why is the time complexity of both DFS and BFS O(m * n) ? I thought it would be same as path finding algorithm, as we traverse 4 ways (up, down, left, right) it is O(4^ (m + n)).\\n\\nCan anyone explain this? I do not want to get this wrong at interview, hence asking for you analysis."
                    },
                    {
                        "username": "nambrose",
                        "content": "[@sidharthgurbani](/sidharthgurbani) What about the case where the entire grid is 1\\'s, we would have to go over each spot twice (the dfs of the entire grid, and our double for loop)"
                    },
                    {
                        "username": "sidharthgurbani",
                        "content": "It is because during every DFS, you change the \"1\" to \"0\". Thereby eliminating the need for running DFS on it again. So in short you would go over each element only once"
                    }
                ]
            },
            {
                "id": 1565770,
                "content": [
                    {
                        "username": "MarkMarcel",
                        "content": "My challenge with solving this problem was getting the definition of an island. What I thought an island was, is a 1 surrounded by 0\\'s either on left and right or top and bottom. Like in image, my definition gave the 2 islands circled in example 1.\\n![image](https://assets.leetcode.com/users/images/0cadaf5c-858d-4cfd-91e8-27427e5d9d01_1649931304.8787706.png)\\n\\nAfter getting my test case wrong, I went through the discussions and based on solutions I realised the question meant an island is a string of 1s like shown in the images below\\n![image](https://assets.leetcode.com/users/images/e6a18482-7542-421a-bd27-cf79e44618e5_1649932030.3147244.png)\\n![image](https://assets.leetcode.com/users/images/b6938d3b-26d7-45d9-88a8-e4956b0ed10a_1649932030.3330166.png)\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "Why is \\'1\\' and \\'0\\' chars? Just to irritate people?"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@sanidhyas3s](/sanidhyas3s) Same lol. My code 100% worked after I changed it from a number to char "
                    },
                    {
                        "username": "sanidhyas3s",
                        "content": "[@nemanjac](/nemanjac) They could\\'ve kept it a char and let it have a numerical value of 0 or 1 instead of \\'0\\' and \\'1\\'. Can\\'t believe I wasted like 10 minutes just figuring out that I had 1 instead of \\'1\\'."
                    },
                    {
                        "username": "lucasan2300",
                        "content": "would you think that, it doesn't matter, but It will be to develop some technique for change it, or handle... please smile!"
                    },
                    {
                        "username": "avyayk",
                        "content": "[@nemanjac](/nemanjac) A bit (1/0) takes up one bit and also achieves the goal :)"
                    },
                    {
                        "username": "Msey",
                        "content": "[@mcthouacbb](/mcthouacbb) it teaches us to be attentive"
                    },
                    {
                        "username": "nemanjac",
                        "content": "Perhaps because a char takes up 2 bytes, where as an int takes up 4."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "Basically. Spent a good 10-15 minutes wondering why my conditions kept miscomparing...Take it as a lesson to read the inputs clearly lol."
                    },
                    {
                        "username": "close27",
                        "content": "lol..agree"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "[@Zephromonia](/Zephromonia) same :|"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Leetcode likes to do a little bit of trolling"
                    },
                    {
                        "username": "Zephromonia",
                        "content": "Quite annoying. Was using not boolean operator for a while."
                    },
                    {
                        "username": "uwswe",
                        "content": "Looks like quite a few people labled their code as a BFS solution, when it\\'s actually DFS. And what\\'s worse is that you\\'re being praised for an incorrect solutiuon. Just because leetcode accepts it, doesn\\'t mean its correct.\\n\\nIf you don\\'t know the difference, then you should read the leetcode chapters on BFS, and DFS. The problem clearly states \"Queue and BFS\", and many people didn\\'t bother to use a queue at all. While this problem can be solved recursively (i.e. DFS), that\\'s not the solution we were asked to provide. The main difference between BFS and DFS is the order you visit the nodes. BFS uses a Queue to visit the closest nodes first, while DFS pretty much skips some nodes next door and follows the path until it reaches a deadend. \\n\\nWhat if the one node you were looking for was the 2nd neighbor, and you picked the first one and followed the path? \\n\\nA better question is, what are you going to do when your interviewer tells you that your recursive solution overflowed the call stack, and you need to improve your solution? Yeah you could implement a Stack yourself, and not use the call stack. But then what if your interviewer really wants the best solution possible, which should be BFS, but you give them your DFS solution?\\n\\nThere\\'s a lot of people who use leetcode to learn how to code, and understand data structures. Praising incorrect solutions is stumping the grow of future engineers. Also, if you want to proudly share your solution, please provide properly formatted code with descriptive variable names - no one wants to break out pen and paper to dissect your logic.\\n\\n"
                    },
                    {
                        "username": "jeehaytch",
                        "content": "My solution is DFS (using a stack) and I beat 96 to 99%"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "1. You\\'re adding constraints not present in the problem statement. The problem statement leaves it to the solver to select a traversal method. \\n\\n2. We\\'re not looking for a specific node. DFS and BFS are identical in efficiency for this problem.\\n\\n3. BFS isn\\'t \\'the best possible\\' and I\\'d tell the interviewer that. The call stack would never \\'overflow\\' because you have at most m*n calls. This is the same space complexity as BFS. \\n\\n4. Don\\'t use leetcode to learn how to code. Code written for leetcode problems sacrifices readability for optimization. Use leetcode to learn how to do technical interviews. Learn how to program from books, language docs, courses.\\n\\n5. You probably meant \\'stunts\\' not \\'stumps\\'. Forgivable as I assume you\\'re ESL, but the condescending nature of your post weighs against my typical charity.\\n\\n6. If you don\\'t understand a solution you should \\'dissect\\' the logic. How else do you actually learn? \\n\\nI\\'m awed by the irony of you lambasting people for \\'praising\\' \\'incorrect\\' solutions in post where you ignorantly condescend with inane drivel in every paragraph.\\n\\nYou are both incorrect and arrogant. You\\'re errorgant. \\n\\nIt\\'s an off-putting character flaw and will probably harm you more in interviews (and in life) than bombing a technical round. "
                    },
                    {
                        "username": "klami",
                        "content": "the problem is also listed under \"Stack and DFS\" so I think either is okay"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 But as of me , I am more comfortable at using bfs instead of dfs."
                    },
                    {
                        "username": "roundlet",
                        "content": "I just encountered this question in an interview, and I have no idea about how to handle this efficiently. Could anyone provides any hints?"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "we can solve in n**2 using BFS traversal. please have look on solution at  \\nhttps://leetcode.com/problems/number-of-islands/submissions/993397265/"
                    },
                    {
                        "username": "TeaTrey",
                        "content": "[@lumpychum](/lumpychum) I used visited, but overwriting with \\'0\\' is pretty cool. Thanks"
                    },
                    {
                        "username": "math_pi",
                        "content": "It is a standard grid problem, you can use DFS and vector of directions."
                    },
                    {
                        "username": "lumpychum",
                        "content": "Essentially you want to traverse the matrix until you find a 1. Once you locate one (no pun intended) you essentially use flood fill to recursively \"mark\" any connected 1s (the rest of the island) by replacing them with zeros. If you do not want to mutate the given matrix, you can use a visited matrix."
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I have encountered this problem. I want to share my findings in case someone faces this one as well.\\n\\nBefore the start of coding, I thought the condition that one cell being inspected more than once is not a great issue because the duplicate cells are set to \\'0\\' anyway. However, that was WRONG. Because, before the cell is set to \\'0\\', it has already been pushed into queue by its neighbors.\\nThe time complexity is no longer O(M * N);\\nInstead, one cell cause 2 copies of neighbors, and then 4 copies of neighbors of neighbors ...\\n\\nSo as long as neighbors are pushed into queue, they should be set to \\'0\\' immediately."
                    },
                    {
                        "username": "aparr487",
                        "content": "Thanks! This was exactly my problem (flooding the land cell after dequeuing, rather than when enqueuing)."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan you please explain more the testcases and what exactly island means? thanks"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/30e6adfa-133f-4607-ba65-521d0e774b34_1643961955.1657922.png)\\n\\n ![image](https://assets.leetcode.com/users/images/8f49d0cb-605d-4549-8546-b6ad7fd05f7a_1643964600.5265105.png)\\n"
                    },
                    {
                        "username": "david120",
                        "content": "This is probably an old problem and not worth changing, but it makes little sense to not have the elements of `grid` be integers.  I was scratching my head at why what should have been a very simple solution was not working until I noticed the quotes on the 1s and 0s.  I suppose this is what I get for using python, which allows comparison between `1` and `\\'1\\'`."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Same happened with me also"
                    },
                    {
                        "username": "chaos28",
                        "content": "When using DFS to solve, it take O(m * n) to iterate through the matrix, but in the recursion dfs function, it also need to iterate over the matrix , so does it mean that the overall time complexity turn out to be O(m * n) * O(m * n)?"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "Why is the time complexity of both DFS and BFS O(m * n) ? I thought it would be same as path finding algorithm, as we traverse 4 ways (up, down, left, right) it is O(4^ (m + n)).\\n\\nCan anyone explain this? I do not want to get this wrong at interview, hence asking for you analysis."
                    },
                    {
                        "username": "nambrose",
                        "content": "[@sidharthgurbani](/sidharthgurbani) What about the case where the entire grid is 1\\'s, we would have to go over each spot twice (the dfs of the entire grid, and our double for loop)"
                    },
                    {
                        "username": "sidharthgurbani",
                        "content": "It is because during every DFS, you change the \"1\" to \"0\". Thereby eliminating the need for running DFS on it again. So in short you would go over each element only once"
                    }
                ]
            },
            {
                "id": 1566246,
                "content": [
                    {
                        "username": "MarkMarcel",
                        "content": "My challenge with solving this problem was getting the definition of an island. What I thought an island was, is a 1 surrounded by 0\\'s either on left and right or top and bottom. Like in image, my definition gave the 2 islands circled in example 1.\\n![image](https://assets.leetcode.com/users/images/0cadaf5c-858d-4cfd-91e8-27427e5d9d01_1649931304.8787706.png)\\n\\nAfter getting my test case wrong, I went through the discussions and based on solutions I realised the question meant an island is a string of 1s like shown in the images below\\n![image](https://assets.leetcode.com/users/images/e6a18482-7542-421a-bd27-cf79e44618e5_1649932030.3147244.png)\\n![image](https://assets.leetcode.com/users/images/b6938d3b-26d7-45d9-88a8-e4956b0ed10a_1649932030.3330166.png)\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "Why is \\'1\\' and \\'0\\' chars? Just to irritate people?"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@sanidhyas3s](/sanidhyas3s) Same lol. My code 100% worked after I changed it from a number to char "
                    },
                    {
                        "username": "sanidhyas3s",
                        "content": "[@nemanjac](/nemanjac) They could\\'ve kept it a char and let it have a numerical value of 0 or 1 instead of \\'0\\' and \\'1\\'. Can\\'t believe I wasted like 10 minutes just figuring out that I had 1 instead of \\'1\\'."
                    },
                    {
                        "username": "lucasan2300",
                        "content": "would you think that, it doesn't matter, but It will be to develop some technique for change it, or handle... please smile!"
                    },
                    {
                        "username": "avyayk",
                        "content": "[@nemanjac](/nemanjac) A bit (1/0) takes up one bit and also achieves the goal :)"
                    },
                    {
                        "username": "Msey",
                        "content": "[@mcthouacbb](/mcthouacbb) it teaches us to be attentive"
                    },
                    {
                        "username": "nemanjac",
                        "content": "Perhaps because a char takes up 2 bytes, where as an int takes up 4."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "Basically. Spent a good 10-15 minutes wondering why my conditions kept miscomparing...Take it as a lesson to read the inputs clearly lol."
                    },
                    {
                        "username": "close27",
                        "content": "lol..agree"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "[@Zephromonia](/Zephromonia) same :|"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Leetcode likes to do a little bit of trolling"
                    },
                    {
                        "username": "Zephromonia",
                        "content": "Quite annoying. Was using not boolean operator for a while."
                    },
                    {
                        "username": "uwswe",
                        "content": "Looks like quite a few people labled their code as a BFS solution, when it\\'s actually DFS. And what\\'s worse is that you\\'re being praised for an incorrect solutiuon. Just because leetcode accepts it, doesn\\'t mean its correct.\\n\\nIf you don\\'t know the difference, then you should read the leetcode chapters on BFS, and DFS. The problem clearly states \"Queue and BFS\", and many people didn\\'t bother to use a queue at all. While this problem can be solved recursively (i.e. DFS), that\\'s not the solution we were asked to provide. The main difference between BFS and DFS is the order you visit the nodes. BFS uses a Queue to visit the closest nodes first, while DFS pretty much skips some nodes next door and follows the path until it reaches a deadend. \\n\\nWhat if the one node you were looking for was the 2nd neighbor, and you picked the first one and followed the path? \\n\\nA better question is, what are you going to do when your interviewer tells you that your recursive solution overflowed the call stack, and you need to improve your solution? Yeah you could implement a Stack yourself, and not use the call stack. But then what if your interviewer really wants the best solution possible, which should be BFS, but you give them your DFS solution?\\n\\nThere\\'s a lot of people who use leetcode to learn how to code, and understand data structures. Praising incorrect solutions is stumping the grow of future engineers. Also, if you want to proudly share your solution, please provide properly formatted code with descriptive variable names - no one wants to break out pen and paper to dissect your logic.\\n\\n"
                    },
                    {
                        "username": "jeehaytch",
                        "content": "My solution is DFS (using a stack) and I beat 96 to 99%"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "1. You\\'re adding constraints not present in the problem statement. The problem statement leaves it to the solver to select a traversal method. \\n\\n2. We\\'re not looking for a specific node. DFS and BFS are identical in efficiency for this problem.\\n\\n3. BFS isn\\'t \\'the best possible\\' and I\\'d tell the interviewer that. The call stack would never \\'overflow\\' because you have at most m*n calls. This is the same space complexity as BFS. \\n\\n4. Don\\'t use leetcode to learn how to code. Code written for leetcode problems sacrifices readability for optimization. Use leetcode to learn how to do technical interviews. Learn how to program from books, language docs, courses.\\n\\n5. You probably meant \\'stunts\\' not \\'stumps\\'. Forgivable as I assume you\\'re ESL, but the condescending nature of your post weighs against my typical charity.\\n\\n6. If you don\\'t understand a solution you should \\'dissect\\' the logic. How else do you actually learn? \\n\\nI\\'m awed by the irony of you lambasting people for \\'praising\\' \\'incorrect\\' solutions in post where you ignorantly condescend with inane drivel in every paragraph.\\n\\nYou are both incorrect and arrogant. You\\'re errorgant. \\n\\nIt\\'s an off-putting character flaw and will probably harm you more in interviews (and in life) than bombing a technical round. "
                    },
                    {
                        "username": "klami",
                        "content": "the problem is also listed under \"Stack and DFS\" so I think either is okay"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 But as of me , I am more comfortable at using bfs instead of dfs."
                    },
                    {
                        "username": "roundlet",
                        "content": "I just encountered this question in an interview, and I have no idea about how to handle this efficiently. Could anyone provides any hints?"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "we can solve in n**2 using BFS traversal. please have look on solution at  \\nhttps://leetcode.com/problems/number-of-islands/submissions/993397265/"
                    },
                    {
                        "username": "TeaTrey",
                        "content": "[@lumpychum](/lumpychum) I used visited, but overwriting with \\'0\\' is pretty cool. Thanks"
                    },
                    {
                        "username": "math_pi",
                        "content": "It is a standard grid problem, you can use DFS and vector of directions."
                    },
                    {
                        "username": "lumpychum",
                        "content": "Essentially you want to traverse the matrix until you find a 1. Once you locate one (no pun intended) you essentially use flood fill to recursively \"mark\" any connected 1s (the rest of the island) by replacing them with zeros. If you do not want to mutate the given matrix, you can use a visited matrix."
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I have encountered this problem. I want to share my findings in case someone faces this one as well.\\n\\nBefore the start of coding, I thought the condition that one cell being inspected more than once is not a great issue because the duplicate cells are set to \\'0\\' anyway. However, that was WRONG. Because, before the cell is set to \\'0\\', it has already been pushed into queue by its neighbors.\\nThe time complexity is no longer O(M * N);\\nInstead, one cell cause 2 copies of neighbors, and then 4 copies of neighbors of neighbors ...\\n\\nSo as long as neighbors are pushed into queue, they should be set to \\'0\\' immediately."
                    },
                    {
                        "username": "aparr487",
                        "content": "Thanks! This was exactly my problem (flooding the land cell after dequeuing, rather than when enqueuing)."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan you please explain more the testcases and what exactly island means? thanks"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/30e6adfa-133f-4607-ba65-521d0e774b34_1643961955.1657922.png)\\n\\n ![image](https://assets.leetcode.com/users/images/8f49d0cb-605d-4549-8546-b6ad7fd05f7a_1643964600.5265105.png)\\n"
                    },
                    {
                        "username": "david120",
                        "content": "This is probably an old problem and not worth changing, but it makes little sense to not have the elements of `grid` be integers.  I was scratching my head at why what should have been a very simple solution was not working until I noticed the quotes on the 1s and 0s.  I suppose this is what I get for using python, which allows comparison between `1` and `\\'1\\'`."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Same happened with me also"
                    },
                    {
                        "username": "chaos28",
                        "content": "When using DFS to solve, it take O(m * n) to iterate through the matrix, but in the recursion dfs function, it also need to iterate over the matrix , so does it mean that the overall time complexity turn out to be O(m * n) * O(m * n)?"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "Why is the time complexity of both DFS and BFS O(m * n) ? I thought it would be same as path finding algorithm, as we traverse 4 ways (up, down, left, right) it is O(4^ (m + n)).\\n\\nCan anyone explain this? I do not want to get this wrong at interview, hence asking for you analysis."
                    },
                    {
                        "username": "nambrose",
                        "content": "[@sidharthgurbani](/sidharthgurbani) What about the case where the entire grid is 1\\'s, we would have to go over each spot twice (the dfs of the entire grid, and our double for loop)"
                    },
                    {
                        "username": "sidharthgurbani",
                        "content": "It is because during every DFS, you change the \"1\" to \"0\". Thereby eliminating the need for running DFS on it again. So in short you would go over each element only once"
                    }
                ]
            },
            {
                "id": 1570785,
                "content": [
                    {
                        "username": "MarkMarcel",
                        "content": "My challenge with solving this problem was getting the definition of an island. What I thought an island was, is a 1 surrounded by 0\\'s either on left and right or top and bottom. Like in image, my definition gave the 2 islands circled in example 1.\\n![image](https://assets.leetcode.com/users/images/0cadaf5c-858d-4cfd-91e8-27427e5d9d01_1649931304.8787706.png)\\n\\nAfter getting my test case wrong, I went through the discussions and based on solutions I realised the question meant an island is a string of 1s like shown in the images below\\n![image](https://assets.leetcode.com/users/images/e6a18482-7542-421a-bd27-cf79e44618e5_1649932030.3147244.png)\\n![image](https://assets.leetcode.com/users/images/b6938d3b-26d7-45d9-88a8-e4956b0ed10a_1649932030.3330166.png)\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "Why is \\'1\\' and \\'0\\' chars? Just to irritate people?"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@sanidhyas3s](/sanidhyas3s) Same lol. My code 100% worked after I changed it from a number to char "
                    },
                    {
                        "username": "sanidhyas3s",
                        "content": "[@nemanjac](/nemanjac) They could\\'ve kept it a char and let it have a numerical value of 0 or 1 instead of \\'0\\' and \\'1\\'. Can\\'t believe I wasted like 10 minutes just figuring out that I had 1 instead of \\'1\\'."
                    },
                    {
                        "username": "lucasan2300",
                        "content": "would you think that, it doesn't matter, but It will be to develop some technique for change it, or handle... please smile!"
                    },
                    {
                        "username": "avyayk",
                        "content": "[@nemanjac](/nemanjac) A bit (1/0) takes up one bit and also achieves the goal :)"
                    },
                    {
                        "username": "Msey",
                        "content": "[@mcthouacbb](/mcthouacbb) it teaches us to be attentive"
                    },
                    {
                        "username": "nemanjac",
                        "content": "Perhaps because a char takes up 2 bytes, where as an int takes up 4."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "Basically. Spent a good 10-15 minutes wondering why my conditions kept miscomparing...Take it as a lesson to read the inputs clearly lol."
                    },
                    {
                        "username": "close27",
                        "content": "lol..agree"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "[@Zephromonia](/Zephromonia) same :|"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Leetcode likes to do a little bit of trolling"
                    },
                    {
                        "username": "Zephromonia",
                        "content": "Quite annoying. Was using not boolean operator for a while."
                    },
                    {
                        "username": "uwswe",
                        "content": "Looks like quite a few people labled their code as a BFS solution, when it\\'s actually DFS. And what\\'s worse is that you\\'re being praised for an incorrect solutiuon. Just because leetcode accepts it, doesn\\'t mean its correct.\\n\\nIf you don\\'t know the difference, then you should read the leetcode chapters on BFS, and DFS. The problem clearly states \"Queue and BFS\", and many people didn\\'t bother to use a queue at all. While this problem can be solved recursively (i.e. DFS), that\\'s not the solution we were asked to provide. The main difference between BFS and DFS is the order you visit the nodes. BFS uses a Queue to visit the closest nodes first, while DFS pretty much skips some nodes next door and follows the path until it reaches a deadend. \\n\\nWhat if the one node you were looking for was the 2nd neighbor, and you picked the first one and followed the path? \\n\\nA better question is, what are you going to do when your interviewer tells you that your recursive solution overflowed the call stack, and you need to improve your solution? Yeah you could implement a Stack yourself, and not use the call stack. But then what if your interviewer really wants the best solution possible, which should be BFS, but you give them your DFS solution?\\n\\nThere\\'s a lot of people who use leetcode to learn how to code, and understand data structures. Praising incorrect solutions is stumping the grow of future engineers. Also, if you want to proudly share your solution, please provide properly formatted code with descriptive variable names - no one wants to break out pen and paper to dissect your logic.\\n\\n"
                    },
                    {
                        "username": "jeehaytch",
                        "content": "My solution is DFS (using a stack) and I beat 96 to 99%"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "1. You\\'re adding constraints not present in the problem statement. The problem statement leaves it to the solver to select a traversal method. \\n\\n2. We\\'re not looking for a specific node. DFS and BFS are identical in efficiency for this problem.\\n\\n3. BFS isn\\'t \\'the best possible\\' and I\\'d tell the interviewer that. The call stack would never \\'overflow\\' because you have at most m*n calls. This is the same space complexity as BFS. \\n\\n4. Don\\'t use leetcode to learn how to code. Code written for leetcode problems sacrifices readability for optimization. Use leetcode to learn how to do technical interviews. Learn how to program from books, language docs, courses.\\n\\n5. You probably meant \\'stunts\\' not \\'stumps\\'. Forgivable as I assume you\\'re ESL, but the condescending nature of your post weighs against my typical charity.\\n\\n6. If you don\\'t understand a solution you should \\'dissect\\' the logic. How else do you actually learn? \\n\\nI\\'m awed by the irony of you lambasting people for \\'praising\\' \\'incorrect\\' solutions in post where you ignorantly condescend with inane drivel in every paragraph.\\n\\nYou are both incorrect and arrogant. You\\'re errorgant. \\n\\nIt\\'s an off-putting character flaw and will probably harm you more in interviews (and in life) than bombing a technical round. "
                    },
                    {
                        "username": "klami",
                        "content": "the problem is also listed under \"Stack and DFS\" so I think either is okay"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 But as of me , I am more comfortable at using bfs instead of dfs."
                    },
                    {
                        "username": "roundlet",
                        "content": "I just encountered this question in an interview, and I have no idea about how to handle this efficiently. Could anyone provides any hints?"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "we can solve in n**2 using BFS traversal. please have look on solution at  \\nhttps://leetcode.com/problems/number-of-islands/submissions/993397265/"
                    },
                    {
                        "username": "TeaTrey",
                        "content": "[@lumpychum](/lumpychum) I used visited, but overwriting with \\'0\\' is pretty cool. Thanks"
                    },
                    {
                        "username": "math_pi",
                        "content": "It is a standard grid problem, you can use DFS and vector of directions."
                    },
                    {
                        "username": "lumpychum",
                        "content": "Essentially you want to traverse the matrix until you find a 1. Once you locate one (no pun intended) you essentially use flood fill to recursively \"mark\" any connected 1s (the rest of the island) by replacing them with zeros. If you do not want to mutate the given matrix, you can use a visited matrix."
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I have encountered this problem. I want to share my findings in case someone faces this one as well.\\n\\nBefore the start of coding, I thought the condition that one cell being inspected more than once is not a great issue because the duplicate cells are set to \\'0\\' anyway. However, that was WRONG. Because, before the cell is set to \\'0\\', it has already been pushed into queue by its neighbors.\\nThe time complexity is no longer O(M * N);\\nInstead, one cell cause 2 copies of neighbors, and then 4 copies of neighbors of neighbors ...\\n\\nSo as long as neighbors are pushed into queue, they should be set to \\'0\\' immediately."
                    },
                    {
                        "username": "aparr487",
                        "content": "Thanks! This was exactly my problem (flooding the land cell after dequeuing, rather than when enqueuing)."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan you please explain more the testcases and what exactly island means? thanks"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/30e6adfa-133f-4607-ba65-521d0e774b34_1643961955.1657922.png)\\n\\n ![image](https://assets.leetcode.com/users/images/8f49d0cb-605d-4549-8546-b6ad7fd05f7a_1643964600.5265105.png)\\n"
                    },
                    {
                        "username": "david120",
                        "content": "This is probably an old problem and not worth changing, but it makes little sense to not have the elements of `grid` be integers.  I was scratching my head at why what should have been a very simple solution was not working until I noticed the quotes on the 1s and 0s.  I suppose this is what I get for using python, which allows comparison between `1` and `\\'1\\'`."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Same happened with me also"
                    },
                    {
                        "username": "chaos28",
                        "content": "When using DFS to solve, it take O(m * n) to iterate through the matrix, but in the recursion dfs function, it also need to iterate over the matrix , so does it mean that the overall time complexity turn out to be O(m * n) * O(m * n)?"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "Why is the time complexity of both DFS and BFS O(m * n) ? I thought it would be same as path finding algorithm, as we traverse 4 ways (up, down, left, right) it is O(4^ (m + n)).\\n\\nCan anyone explain this? I do not want to get this wrong at interview, hence asking for you analysis."
                    },
                    {
                        "username": "nambrose",
                        "content": "[@sidharthgurbani](/sidharthgurbani) What about the case where the entire grid is 1\\'s, we would have to go over each spot twice (the dfs of the entire grid, and our double for loop)"
                    },
                    {
                        "username": "sidharthgurbani",
                        "content": "It is because during every DFS, you change the \"1\" to \"0\". Thereby eliminating the need for running DFS on it again. So in short you would go over each element only once"
                    }
                ]
            },
            {
                "id": 1568315,
                "content": [
                    {
                        "username": "MarkMarcel",
                        "content": "My challenge with solving this problem was getting the definition of an island. What I thought an island was, is a 1 surrounded by 0\\'s either on left and right or top and bottom. Like in image, my definition gave the 2 islands circled in example 1.\\n![image](https://assets.leetcode.com/users/images/0cadaf5c-858d-4cfd-91e8-27427e5d9d01_1649931304.8787706.png)\\n\\nAfter getting my test case wrong, I went through the discussions and based on solutions I realised the question meant an island is a string of 1s like shown in the images below\\n![image](https://assets.leetcode.com/users/images/e6a18482-7542-421a-bd27-cf79e44618e5_1649932030.3147244.png)\\n![image](https://assets.leetcode.com/users/images/b6938d3b-26d7-45d9-88a8-e4956b0ed10a_1649932030.3330166.png)\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "Why is \\'1\\' and \\'0\\' chars? Just to irritate people?"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@sanidhyas3s](/sanidhyas3s) Same lol. My code 100% worked after I changed it from a number to char "
                    },
                    {
                        "username": "sanidhyas3s",
                        "content": "[@nemanjac](/nemanjac) They could\\'ve kept it a char and let it have a numerical value of 0 or 1 instead of \\'0\\' and \\'1\\'. Can\\'t believe I wasted like 10 minutes just figuring out that I had 1 instead of \\'1\\'."
                    },
                    {
                        "username": "lucasan2300",
                        "content": "would you think that, it doesn't matter, but It will be to develop some technique for change it, or handle... please smile!"
                    },
                    {
                        "username": "avyayk",
                        "content": "[@nemanjac](/nemanjac) A bit (1/0) takes up one bit and also achieves the goal :)"
                    },
                    {
                        "username": "Msey",
                        "content": "[@mcthouacbb](/mcthouacbb) it teaches us to be attentive"
                    },
                    {
                        "username": "nemanjac",
                        "content": "Perhaps because a char takes up 2 bytes, where as an int takes up 4."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "Basically. Spent a good 10-15 minutes wondering why my conditions kept miscomparing...Take it as a lesson to read the inputs clearly lol."
                    },
                    {
                        "username": "close27",
                        "content": "lol..agree"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "[@Zephromonia](/Zephromonia) same :|"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Leetcode likes to do a little bit of trolling"
                    },
                    {
                        "username": "Zephromonia",
                        "content": "Quite annoying. Was using not boolean operator for a while."
                    },
                    {
                        "username": "uwswe",
                        "content": "Looks like quite a few people labled their code as a BFS solution, when it\\'s actually DFS. And what\\'s worse is that you\\'re being praised for an incorrect solutiuon. Just because leetcode accepts it, doesn\\'t mean its correct.\\n\\nIf you don\\'t know the difference, then you should read the leetcode chapters on BFS, and DFS. The problem clearly states \"Queue and BFS\", and many people didn\\'t bother to use a queue at all. While this problem can be solved recursively (i.e. DFS), that\\'s not the solution we were asked to provide. The main difference between BFS and DFS is the order you visit the nodes. BFS uses a Queue to visit the closest nodes first, while DFS pretty much skips some nodes next door and follows the path until it reaches a deadend. \\n\\nWhat if the one node you were looking for was the 2nd neighbor, and you picked the first one and followed the path? \\n\\nA better question is, what are you going to do when your interviewer tells you that your recursive solution overflowed the call stack, and you need to improve your solution? Yeah you could implement a Stack yourself, and not use the call stack. But then what if your interviewer really wants the best solution possible, which should be BFS, but you give them your DFS solution?\\n\\nThere\\'s a lot of people who use leetcode to learn how to code, and understand data structures. Praising incorrect solutions is stumping the grow of future engineers. Also, if you want to proudly share your solution, please provide properly formatted code with descriptive variable names - no one wants to break out pen and paper to dissect your logic.\\n\\n"
                    },
                    {
                        "username": "jeehaytch",
                        "content": "My solution is DFS (using a stack) and I beat 96 to 99%"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "1. You\\'re adding constraints not present in the problem statement. The problem statement leaves it to the solver to select a traversal method. \\n\\n2. We\\'re not looking for a specific node. DFS and BFS are identical in efficiency for this problem.\\n\\n3. BFS isn\\'t \\'the best possible\\' and I\\'d tell the interviewer that. The call stack would never \\'overflow\\' because you have at most m*n calls. This is the same space complexity as BFS. \\n\\n4. Don\\'t use leetcode to learn how to code. Code written for leetcode problems sacrifices readability for optimization. Use leetcode to learn how to do technical interviews. Learn how to program from books, language docs, courses.\\n\\n5. You probably meant \\'stunts\\' not \\'stumps\\'. Forgivable as I assume you\\'re ESL, but the condescending nature of your post weighs against my typical charity.\\n\\n6. If you don\\'t understand a solution you should \\'dissect\\' the logic. How else do you actually learn? \\n\\nI\\'m awed by the irony of you lambasting people for \\'praising\\' \\'incorrect\\' solutions in post where you ignorantly condescend with inane drivel in every paragraph.\\n\\nYou are both incorrect and arrogant. You\\'re errorgant. \\n\\nIt\\'s an off-putting character flaw and will probably harm you more in interviews (and in life) than bombing a technical round. "
                    },
                    {
                        "username": "klami",
                        "content": "the problem is also listed under \"Stack and DFS\" so I think either is okay"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 But as of me , I am more comfortable at using bfs instead of dfs."
                    },
                    {
                        "username": "roundlet",
                        "content": "I just encountered this question in an interview, and I have no idea about how to handle this efficiently. Could anyone provides any hints?"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "we can solve in n**2 using BFS traversal. please have look on solution at  \\nhttps://leetcode.com/problems/number-of-islands/submissions/993397265/"
                    },
                    {
                        "username": "TeaTrey",
                        "content": "[@lumpychum](/lumpychum) I used visited, but overwriting with \\'0\\' is pretty cool. Thanks"
                    },
                    {
                        "username": "math_pi",
                        "content": "It is a standard grid problem, you can use DFS and vector of directions."
                    },
                    {
                        "username": "lumpychum",
                        "content": "Essentially you want to traverse the matrix until you find a 1. Once you locate one (no pun intended) you essentially use flood fill to recursively \"mark\" any connected 1s (the rest of the island) by replacing them with zeros. If you do not want to mutate the given matrix, you can use a visited matrix."
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I have encountered this problem. I want to share my findings in case someone faces this one as well.\\n\\nBefore the start of coding, I thought the condition that one cell being inspected more than once is not a great issue because the duplicate cells are set to \\'0\\' anyway. However, that was WRONG. Because, before the cell is set to \\'0\\', it has already been pushed into queue by its neighbors.\\nThe time complexity is no longer O(M * N);\\nInstead, one cell cause 2 copies of neighbors, and then 4 copies of neighbors of neighbors ...\\n\\nSo as long as neighbors are pushed into queue, they should be set to \\'0\\' immediately."
                    },
                    {
                        "username": "aparr487",
                        "content": "Thanks! This was exactly my problem (flooding the land cell after dequeuing, rather than when enqueuing)."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan you please explain more the testcases and what exactly island means? thanks"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/30e6adfa-133f-4607-ba65-521d0e774b34_1643961955.1657922.png)\\n\\n ![image](https://assets.leetcode.com/users/images/8f49d0cb-605d-4549-8546-b6ad7fd05f7a_1643964600.5265105.png)\\n"
                    },
                    {
                        "username": "david120",
                        "content": "This is probably an old problem and not worth changing, but it makes little sense to not have the elements of `grid` be integers.  I was scratching my head at why what should have been a very simple solution was not working until I noticed the quotes on the 1s and 0s.  I suppose this is what I get for using python, which allows comparison between `1` and `\\'1\\'`."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Same happened with me also"
                    },
                    {
                        "username": "chaos28",
                        "content": "When using DFS to solve, it take O(m * n) to iterate through the matrix, but in the recursion dfs function, it also need to iterate over the matrix , so does it mean that the overall time complexity turn out to be O(m * n) * O(m * n)?"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "Why is the time complexity of both DFS and BFS O(m * n) ? I thought it would be same as path finding algorithm, as we traverse 4 ways (up, down, left, right) it is O(4^ (m + n)).\\n\\nCan anyone explain this? I do not want to get this wrong at interview, hence asking for you analysis."
                    },
                    {
                        "username": "nambrose",
                        "content": "[@sidharthgurbani](/sidharthgurbani) What about the case where the entire grid is 1\\'s, we would have to go over each spot twice (the dfs of the entire grid, and our double for loop)"
                    },
                    {
                        "username": "sidharthgurbani",
                        "content": "It is because during every DFS, you change the \"1\" to \"0\". Thereby eliminating the need for running DFS on it again. So in short you would go over each element only once"
                    }
                ]
            },
            {
                "id": 1566766,
                "content": [
                    {
                        "username": "MarkMarcel",
                        "content": "My challenge with solving this problem was getting the definition of an island. What I thought an island was, is a 1 surrounded by 0\\'s either on left and right or top and bottom. Like in image, my definition gave the 2 islands circled in example 1.\\n![image](https://assets.leetcode.com/users/images/0cadaf5c-858d-4cfd-91e8-27427e5d9d01_1649931304.8787706.png)\\n\\nAfter getting my test case wrong, I went through the discussions and based on solutions I realised the question meant an island is a string of 1s like shown in the images below\\n![image](https://assets.leetcode.com/users/images/e6a18482-7542-421a-bd27-cf79e44618e5_1649932030.3147244.png)\\n![image](https://assets.leetcode.com/users/images/b6938d3b-26d7-45d9-88a8-e4956b0ed10a_1649932030.3330166.png)\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "Why is \\'1\\' and \\'0\\' chars? Just to irritate people?"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@sanidhyas3s](/sanidhyas3s) Same lol. My code 100% worked after I changed it from a number to char "
                    },
                    {
                        "username": "sanidhyas3s",
                        "content": "[@nemanjac](/nemanjac) They could\\'ve kept it a char and let it have a numerical value of 0 or 1 instead of \\'0\\' and \\'1\\'. Can\\'t believe I wasted like 10 minutes just figuring out that I had 1 instead of \\'1\\'."
                    },
                    {
                        "username": "lucasan2300",
                        "content": "would you think that, it doesn't matter, but It will be to develop some technique for change it, or handle... please smile!"
                    },
                    {
                        "username": "avyayk",
                        "content": "[@nemanjac](/nemanjac) A bit (1/0) takes up one bit and also achieves the goal :)"
                    },
                    {
                        "username": "Msey",
                        "content": "[@mcthouacbb](/mcthouacbb) it teaches us to be attentive"
                    },
                    {
                        "username": "nemanjac",
                        "content": "Perhaps because a char takes up 2 bytes, where as an int takes up 4."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "Basically. Spent a good 10-15 minutes wondering why my conditions kept miscomparing...Take it as a lesson to read the inputs clearly lol."
                    },
                    {
                        "username": "close27",
                        "content": "lol..agree"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "[@Zephromonia](/Zephromonia) same :|"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Leetcode likes to do a little bit of trolling"
                    },
                    {
                        "username": "Zephromonia",
                        "content": "Quite annoying. Was using not boolean operator for a while."
                    },
                    {
                        "username": "uwswe",
                        "content": "Looks like quite a few people labled their code as a BFS solution, when it\\'s actually DFS. And what\\'s worse is that you\\'re being praised for an incorrect solutiuon. Just because leetcode accepts it, doesn\\'t mean its correct.\\n\\nIf you don\\'t know the difference, then you should read the leetcode chapters on BFS, and DFS. The problem clearly states \"Queue and BFS\", and many people didn\\'t bother to use a queue at all. While this problem can be solved recursively (i.e. DFS), that\\'s not the solution we were asked to provide. The main difference between BFS and DFS is the order you visit the nodes. BFS uses a Queue to visit the closest nodes first, while DFS pretty much skips some nodes next door and follows the path until it reaches a deadend. \\n\\nWhat if the one node you were looking for was the 2nd neighbor, and you picked the first one and followed the path? \\n\\nA better question is, what are you going to do when your interviewer tells you that your recursive solution overflowed the call stack, and you need to improve your solution? Yeah you could implement a Stack yourself, and not use the call stack. But then what if your interviewer really wants the best solution possible, which should be BFS, but you give them your DFS solution?\\n\\nThere\\'s a lot of people who use leetcode to learn how to code, and understand data structures. Praising incorrect solutions is stumping the grow of future engineers. Also, if you want to proudly share your solution, please provide properly formatted code with descriptive variable names - no one wants to break out pen and paper to dissect your logic.\\n\\n"
                    },
                    {
                        "username": "jeehaytch",
                        "content": "My solution is DFS (using a stack) and I beat 96 to 99%"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "1. You\\'re adding constraints not present in the problem statement. The problem statement leaves it to the solver to select a traversal method. \\n\\n2. We\\'re not looking for a specific node. DFS and BFS are identical in efficiency for this problem.\\n\\n3. BFS isn\\'t \\'the best possible\\' and I\\'d tell the interviewer that. The call stack would never \\'overflow\\' because you have at most m*n calls. This is the same space complexity as BFS. \\n\\n4. Don\\'t use leetcode to learn how to code. Code written for leetcode problems sacrifices readability for optimization. Use leetcode to learn how to do technical interviews. Learn how to program from books, language docs, courses.\\n\\n5. You probably meant \\'stunts\\' not \\'stumps\\'. Forgivable as I assume you\\'re ESL, but the condescending nature of your post weighs against my typical charity.\\n\\n6. If you don\\'t understand a solution you should \\'dissect\\' the logic. How else do you actually learn? \\n\\nI\\'m awed by the irony of you lambasting people for \\'praising\\' \\'incorrect\\' solutions in post where you ignorantly condescend with inane drivel in every paragraph.\\n\\nYou are both incorrect and arrogant. You\\'re errorgant. \\n\\nIt\\'s an off-putting character flaw and will probably harm you more in interviews (and in life) than bombing a technical round. "
                    },
                    {
                        "username": "klami",
                        "content": "the problem is also listed under \"Stack and DFS\" so I think either is okay"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 But as of me , I am more comfortable at using bfs instead of dfs."
                    },
                    {
                        "username": "roundlet",
                        "content": "I just encountered this question in an interview, and I have no idea about how to handle this efficiently. Could anyone provides any hints?"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "we can solve in n**2 using BFS traversal. please have look on solution at  \\nhttps://leetcode.com/problems/number-of-islands/submissions/993397265/"
                    },
                    {
                        "username": "TeaTrey",
                        "content": "[@lumpychum](/lumpychum) I used visited, but overwriting with \\'0\\' is pretty cool. Thanks"
                    },
                    {
                        "username": "math_pi",
                        "content": "It is a standard grid problem, you can use DFS and vector of directions."
                    },
                    {
                        "username": "lumpychum",
                        "content": "Essentially you want to traverse the matrix until you find a 1. Once you locate one (no pun intended) you essentially use flood fill to recursively \"mark\" any connected 1s (the rest of the island) by replacing them with zeros. If you do not want to mutate the given matrix, you can use a visited matrix."
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I have encountered this problem. I want to share my findings in case someone faces this one as well.\\n\\nBefore the start of coding, I thought the condition that one cell being inspected more than once is not a great issue because the duplicate cells are set to \\'0\\' anyway. However, that was WRONG. Because, before the cell is set to \\'0\\', it has already been pushed into queue by its neighbors.\\nThe time complexity is no longer O(M * N);\\nInstead, one cell cause 2 copies of neighbors, and then 4 copies of neighbors of neighbors ...\\n\\nSo as long as neighbors are pushed into queue, they should be set to \\'0\\' immediately."
                    },
                    {
                        "username": "aparr487",
                        "content": "Thanks! This was exactly my problem (flooding the land cell after dequeuing, rather than when enqueuing)."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan you please explain more the testcases and what exactly island means? thanks"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/30e6adfa-133f-4607-ba65-521d0e774b34_1643961955.1657922.png)\\n\\n ![image](https://assets.leetcode.com/users/images/8f49d0cb-605d-4549-8546-b6ad7fd05f7a_1643964600.5265105.png)\\n"
                    },
                    {
                        "username": "david120",
                        "content": "This is probably an old problem and not worth changing, but it makes little sense to not have the elements of `grid` be integers.  I was scratching my head at why what should have been a very simple solution was not working until I noticed the quotes on the 1s and 0s.  I suppose this is what I get for using python, which allows comparison between `1` and `\\'1\\'`."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Same happened with me also"
                    },
                    {
                        "username": "chaos28",
                        "content": "When using DFS to solve, it take O(m * n) to iterate through the matrix, but in the recursion dfs function, it also need to iterate over the matrix , so does it mean that the overall time complexity turn out to be O(m * n) * O(m * n)?"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "Why is the time complexity of both DFS and BFS O(m * n) ? I thought it would be same as path finding algorithm, as we traverse 4 ways (up, down, left, right) it is O(4^ (m + n)).\\n\\nCan anyone explain this? I do not want to get this wrong at interview, hence asking for you analysis."
                    },
                    {
                        "username": "nambrose",
                        "content": "[@sidharthgurbani](/sidharthgurbani) What about the case where the entire grid is 1\\'s, we would have to go over each spot twice (the dfs of the entire grid, and our double for loop)"
                    },
                    {
                        "username": "sidharthgurbani",
                        "content": "It is because during every DFS, you change the \"1\" to \"0\". Thereby eliminating the need for running DFS on it again. So in short you would go over each element only once"
                    }
                ]
            },
            {
                "id": 1566334,
                "content": [
                    {
                        "username": "MarkMarcel",
                        "content": "My challenge with solving this problem was getting the definition of an island. What I thought an island was, is a 1 surrounded by 0\\'s either on left and right or top and bottom. Like in image, my definition gave the 2 islands circled in example 1.\\n![image](https://assets.leetcode.com/users/images/0cadaf5c-858d-4cfd-91e8-27427e5d9d01_1649931304.8787706.png)\\n\\nAfter getting my test case wrong, I went through the discussions and based on solutions I realised the question meant an island is a string of 1s like shown in the images below\\n![image](https://assets.leetcode.com/users/images/e6a18482-7542-421a-bd27-cf79e44618e5_1649932030.3147244.png)\\n![image](https://assets.leetcode.com/users/images/b6938d3b-26d7-45d9-88a8-e4956b0ed10a_1649932030.3330166.png)\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "Why is \\'1\\' and \\'0\\' chars? Just to irritate people?"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@sanidhyas3s](/sanidhyas3s) Same lol. My code 100% worked after I changed it from a number to char "
                    },
                    {
                        "username": "sanidhyas3s",
                        "content": "[@nemanjac](/nemanjac) They could\\'ve kept it a char and let it have a numerical value of 0 or 1 instead of \\'0\\' and \\'1\\'. Can\\'t believe I wasted like 10 minutes just figuring out that I had 1 instead of \\'1\\'."
                    },
                    {
                        "username": "lucasan2300",
                        "content": "would you think that, it doesn't matter, but It will be to develop some technique for change it, or handle... please smile!"
                    },
                    {
                        "username": "avyayk",
                        "content": "[@nemanjac](/nemanjac) A bit (1/0) takes up one bit and also achieves the goal :)"
                    },
                    {
                        "username": "Msey",
                        "content": "[@mcthouacbb](/mcthouacbb) it teaches us to be attentive"
                    },
                    {
                        "username": "nemanjac",
                        "content": "Perhaps because a char takes up 2 bytes, where as an int takes up 4."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "Basically. Spent a good 10-15 minutes wondering why my conditions kept miscomparing...Take it as a lesson to read the inputs clearly lol."
                    },
                    {
                        "username": "close27",
                        "content": "lol..agree"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "[@Zephromonia](/Zephromonia) same :|"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Leetcode likes to do a little bit of trolling"
                    },
                    {
                        "username": "Zephromonia",
                        "content": "Quite annoying. Was using not boolean operator for a while."
                    },
                    {
                        "username": "uwswe",
                        "content": "Looks like quite a few people labled their code as a BFS solution, when it\\'s actually DFS. And what\\'s worse is that you\\'re being praised for an incorrect solutiuon. Just because leetcode accepts it, doesn\\'t mean its correct.\\n\\nIf you don\\'t know the difference, then you should read the leetcode chapters on BFS, and DFS. The problem clearly states \"Queue and BFS\", and many people didn\\'t bother to use a queue at all. While this problem can be solved recursively (i.e. DFS), that\\'s not the solution we were asked to provide. The main difference between BFS and DFS is the order you visit the nodes. BFS uses a Queue to visit the closest nodes first, while DFS pretty much skips some nodes next door and follows the path until it reaches a deadend. \\n\\nWhat if the one node you were looking for was the 2nd neighbor, and you picked the first one and followed the path? \\n\\nA better question is, what are you going to do when your interviewer tells you that your recursive solution overflowed the call stack, and you need to improve your solution? Yeah you could implement a Stack yourself, and not use the call stack. But then what if your interviewer really wants the best solution possible, which should be BFS, but you give them your DFS solution?\\n\\nThere\\'s a lot of people who use leetcode to learn how to code, and understand data structures. Praising incorrect solutions is stumping the grow of future engineers. Also, if you want to proudly share your solution, please provide properly formatted code with descriptive variable names - no one wants to break out pen and paper to dissect your logic.\\n\\n"
                    },
                    {
                        "username": "jeehaytch",
                        "content": "My solution is DFS (using a stack) and I beat 96 to 99%"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "1. You\\'re adding constraints not present in the problem statement. The problem statement leaves it to the solver to select a traversal method. \\n\\n2. We\\'re not looking for a specific node. DFS and BFS are identical in efficiency for this problem.\\n\\n3. BFS isn\\'t \\'the best possible\\' and I\\'d tell the interviewer that. The call stack would never \\'overflow\\' because you have at most m*n calls. This is the same space complexity as BFS. \\n\\n4. Don\\'t use leetcode to learn how to code. Code written for leetcode problems sacrifices readability for optimization. Use leetcode to learn how to do technical interviews. Learn how to program from books, language docs, courses.\\n\\n5. You probably meant \\'stunts\\' not \\'stumps\\'. Forgivable as I assume you\\'re ESL, but the condescending nature of your post weighs against my typical charity.\\n\\n6. If you don\\'t understand a solution you should \\'dissect\\' the logic. How else do you actually learn? \\n\\nI\\'m awed by the irony of you lambasting people for \\'praising\\' \\'incorrect\\' solutions in post where you ignorantly condescend with inane drivel in every paragraph.\\n\\nYou are both incorrect and arrogant. You\\'re errorgant. \\n\\nIt\\'s an off-putting character flaw and will probably harm you more in interviews (and in life) than bombing a technical round. "
                    },
                    {
                        "username": "klami",
                        "content": "the problem is also listed under \"Stack and DFS\" so I think either is okay"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 But as of me , I am more comfortable at using bfs instead of dfs."
                    },
                    {
                        "username": "roundlet",
                        "content": "I just encountered this question in an interview, and I have no idea about how to handle this efficiently. Could anyone provides any hints?"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "we can solve in n**2 using BFS traversal. please have look on solution at  \\nhttps://leetcode.com/problems/number-of-islands/submissions/993397265/"
                    },
                    {
                        "username": "TeaTrey",
                        "content": "[@lumpychum](/lumpychum) I used visited, but overwriting with \\'0\\' is pretty cool. Thanks"
                    },
                    {
                        "username": "math_pi",
                        "content": "It is a standard grid problem, you can use DFS and vector of directions."
                    },
                    {
                        "username": "lumpychum",
                        "content": "Essentially you want to traverse the matrix until you find a 1. Once you locate one (no pun intended) you essentially use flood fill to recursively \"mark\" any connected 1s (the rest of the island) by replacing them with zeros. If you do not want to mutate the given matrix, you can use a visited matrix."
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I have encountered this problem. I want to share my findings in case someone faces this one as well.\\n\\nBefore the start of coding, I thought the condition that one cell being inspected more than once is not a great issue because the duplicate cells are set to \\'0\\' anyway. However, that was WRONG. Because, before the cell is set to \\'0\\', it has already been pushed into queue by its neighbors.\\nThe time complexity is no longer O(M * N);\\nInstead, one cell cause 2 copies of neighbors, and then 4 copies of neighbors of neighbors ...\\n\\nSo as long as neighbors are pushed into queue, they should be set to \\'0\\' immediately."
                    },
                    {
                        "username": "aparr487",
                        "content": "Thanks! This was exactly my problem (flooding the land cell after dequeuing, rather than when enqueuing)."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan you please explain more the testcases and what exactly island means? thanks"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/30e6adfa-133f-4607-ba65-521d0e774b34_1643961955.1657922.png)\\n\\n ![image](https://assets.leetcode.com/users/images/8f49d0cb-605d-4549-8546-b6ad7fd05f7a_1643964600.5265105.png)\\n"
                    },
                    {
                        "username": "david120",
                        "content": "This is probably an old problem and not worth changing, but it makes little sense to not have the elements of `grid` be integers.  I was scratching my head at why what should have been a very simple solution was not working until I noticed the quotes on the 1s and 0s.  I suppose this is what I get for using python, which allows comparison between `1` and `\\'1\\'`."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Same happened with me also"
                    },
                    {
                        "username": "chaos28",
                        "content": "When using DFS to solve, it take O(m * n) to iterate through the matrix, but in the recursion dfs function, it also need to iterate over the matrix , so does it mean that the overall time complexity turn out to be O(m * n) * O(m * n)?"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "Why is the time complexity of both DFS and BFS O(m * n) ? I thought it would be same as path finding algorithm, as we traverse 4 ways (up, down, left, right) it is O(4^ (m + n)).\\n\\nCan anyone explain this? I do not want to get this wrong at interview, hence asking for you analysis."
                    },
                    {
                        "username": "nambrose",
                        "content": "[@sidharthgurbani](/sidharthgurbani) What about the case where the entire grid is 1\\'s, we would have to go over each spot twice (the dfs of the entire grid, and our double for loop)"
                    },
                    {
                        "username": "sidharthgurbani",
                        "content": "It is because during every DFS, you change the \"1\" to \"0\". Thereby eliminating the need for running DFS on it again. So in short you would go over each element only once"
                    }
                ]
            },
            {
                "id": 1567749,
                "content": [
                    {
                        "username": "MarkMarcel",
                        "content": "My challenge with solving this problem was getting the definition of an island. What I thought an island was, is a 1 surrounded by 0\\'s either on left and right or top and bottom. Like in image, my definition gave the 2 islands circled in example 1.\\n![image](https://assets.leetcode.com/users/images/0cadaf5c-858d-4cfd-91e8-27427e5d9d01_1649931304.8787706.png)\\n\\nAfter getting my test case wrong, I went through the discussions and based on solutions I realised the question meant an island is a string of 1s like shown in the images below\\n![image](https://assets.leetcode.com/users/images/e6a18482-7542-421a-bd27-cf79e44618e5_1649932030.3147244.png)\\n![image](https://assets.leetcode.com/users/images/b6938d3b-26d7-45d9-88a8-e4956b0ed10a_1649932030.3330166.png)\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "Why is \\'1\\' and \\'0\\' chars? Just to irritate people?"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@sanidhyas3s](/sanidhyas3s) Same lol. My code 100% worked after I changed it from a number to char "
                    },
                    {
                        "username": "sanidhyas3s",
                        "content": "[@nemanjac](/nemanjac) They could\\'ve kept it a char and let it have a numerical value of 0 or 1 instead of \\'0\\' and \\'1\\'. Can\\'t believe I wasted like 10 minutes just figuring out that I had 1 instead of \\'1\\'."
                    },
                    {
                        "username": "lucasan2300",
                        "content": "would you think that, it doesn't matter, but It will be to develop some technique for change it, or handle... please smile!"
                    },
                    {
                        "username": "avyayk",
                        "content": "[@nemanjac](/nemanjac) A bit (1/0) takes up one bit and also achieves the goal :)"
                    },
                    {
                        "username": "Msey",
                        "content": "[@mcthouacbb](/mcthouacbb) it teaches us to be attentive"
                    },
                    {
                        "username": "nemanjac",
                        "content": "Perhaps because a char takes up 2 bytes, where as an int takes up 4."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "Basically. Spent a good 10-15 minutes wondering why my conditions kept miscomparing...Take it as a lesson to read the inputs clearly lol."
                    },
                    {
                        "username": "close27",
                        "content": "lol..agree"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "[@Zephromonia](/Zephromonia) same :|"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Leetcode likes to do a little bit of trolling"
                    },
                    {
                        "username": "Zephromonia",
                        "content": "Quite annoying. Was using not boolean operator for a while."
                    },
                    {
                        "username": "uwswe",
                        "content": "Looks like quite a few people labled their code as a BFS solution, when it\\'s actually DFS. And what\\'s worse is that you\\'re being praised for an incorrect solutiuon. Just because leetcode accepts it, doesn\\'t mean its correct.\\n\\nIf you don\\'t know the difference, then you should read the leetcode chapters on BFS, and DFS. The problem clearly states \"Queue and BFS\", and many people didn\\'t bother to use a queue at all. While this problem can be solved recursively (i.e. DFS), that\\'s not the solution we were asked to provide. The main difference between BFS and DFS is the order you visit the nodes. BFS uses a Queue to visit the closest nodes first, while DFS pretty much skips some nodes next door and follows the path until it reaches a deadend. \\n\\nWhat if the one node you were looking for was the 2nd neighbor, and you picked the first one and followed the path? \\n\\nA better question is, what are you going to do when your interviewer tells you that your recursive solution overflowed the call stack, and you need to improve your solution? Yeah you could implement a Stack yourself, and not use the call stack. But then what if your interviewer really wants the best solution possible, which should be BFS, but you give them your DFS solution?\\n\\nThere\\'s a lot of people who use leetcode to learn how to code, and understand data structures. Praising incorrect solutions is stumping the grow of future engineers. Also, if you want to proudly share your solution, please provide properly formatted code with descriptive variable names - no one wants to break out pen and paper to dissect your logic.\\n\\n"
                    },
                    {
                        "username": "jeehaytch",
                        "content": "My solution is DFS (using a stack) and I beat 96 to 99%"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "1. You\\'re adding constraints not present in the problem statement. The problem statement leaves it to the solver to select a traversal method. \\n\\n2. We\\'re not looking for a specific node. DFS and BFS are identical in efficiency for this problem.\\n\\n3. BFS isn\\'t \\'the best possible\\' and I\\'d tell the interviewer that. The call stack would never \\'overflow\\' because you have at most m*n calls. This is the same space complexity as BFS. \\n\\n4. Don\\'t use leetcode to learn how to code. Code written for leetcode problems sacrifices readability for optimization. Use leetcode to learn how to do technical interviews. Learn how to program from books, language docs, courses.\\n\\n5. You probably meant \\'stunts\\' not \\'stumps\\'. Forgivable as I assume you\\'re ESL, but the condescending nature of your post weighs against my typical charity.\\n\\n6. If you don\\'t understand a solution you should \\'dissect\\' the logic. How else do you actually learn? \\n\\nI\\'m awed by the irony of you lambasting people for \\'praising\\' \\'incorrect\\' solutions in post where you ignorantly condescend with inane drivel in every paragraph.\\n\\nYou are both incorrect and arrogant. You\\'re errorgant. \\n\\nIt\\'s an off-putting character flaw and will probably harm you more in interviews (and in life) than bombing a technical round. "
                    },
                    {
                        "username": "klami",
                        "content": "the problem is also listed under \"Stack and DFS\" so I think either is okay"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 But as of me , I am more comfortable at using bfs instead of dfs."
                    },
                    {
                        "username": "roundlet",
                        "content": "I just encountered this question in an interview, and I have no idea about how to handle this efficiently. Could anyone provides any hints?"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "we can solve in n**2 using BFS traversal. please have look on solution at  \\nhttps://leetcode.com/problems/number-of-islands/submissions/993397265/"
                    },
                    {
                        "username": "TeaTrey",
                        "content": "[@lumpychum](/lumpychum) I used visited, but overwriting with \\'0\\' is pretty cool. Thanks"
                    },
                    {
                        "username": "math_pi",
                        "content": "It is a standard grid problem, you can use DFS and vector of directions."
                    },
                    {
                        "username": "lumpychum",
                        "content": "Essentially you want to traverse the matrix until you find a 1. Once you locate one (no pun intended) you essentially use flood fill to recursively \"mark\" any connected 1s (the rest of the island) by replacing them with zeros. If you do not want to mutate the given matrix, you can use a visited matrix."
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I have encountered this problem. I want to share my findings in case someone faces this one as well.\\n\\nBefore the start of coding, I thought the condition that one cell being inspected more than once is not a great issue because the duplicate cells are set to \\'0\\' anyway. However, that was WRONG. Because, before the cell is set to \\'0\\', it has already been pushed into queue by its neighbors.\\nThe time complexity is no longer O(M * N);\\nInstead, one cell cause 2 copies of neighbors, and then 4 copies of neighbors of neighbors ...\\n\\nSo as long as neighbors are pushed into queue, they should be set to \\'0\\' immediately."
                    },
                    {
                        "username": "aparr487",
                        "content": "Thanks! This was exactly my problem (flooding the land cell after dequeuing, rather than when enqueuing)."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan you please explain more the testcases and what exactly island means? thanks"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/30e6adfa-133f-4607-ba65-521d0e774b34_1643961955.1657922.png)\\n\\n ![image](https://assets.leetcode.com/users/images/8f49d0cb-605d-4549-8546-b6ad7fd05f7a_1643964600.5265105.png)\\n"
                    },
                    {
                        "username": "david120",
                        "content": "This is probably an old problem and not worth changing, but it makes little sense to not have the elements of `grid` be integers.  I was scratching my head at why what should have been a very simple solution was not working until I noticed the quotes on the 1s and 0s.  I suppose this is what I get for using python, which allows comparison between `1` and `\\'1\\'`."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Same happened with me also"
                    },
                    {
                        "username": "chaos28",
                        "content": "When using DFS to solve, it take O(m * n) to iterate through the matrix, but in the recursion dfs function, it also need to iterate over the matrix , so does it mean that the overall time complexity turn out to be O(m * n) * O(m * n)?"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "Why is the time complexity of both DFS and BFS O(m * n) ? I thought it would be same as path finding algorithm, as we traverse 4 ways (up, down, left, right) it is O(4^ (m + n)).\\n\\nCan anyone explain this? I do not want to get this wrong at interview, hence asking for you analysis."
                    },
                    {
                        "username": "nambrose",
                        "content": "[@sidharthgurbani](/sidharthgurbani) What about the case where the entire grid is 1\\'s, we would have to go over each spot twice (the dfs of the entire grid, and our double for loop)"
                    },
                    {
                        "username": "sidharthgurbani",
                        "content": "It is because during every DFS, you change the \"1\" to \"0\". Thereby eliminating the need for running DFS on it again. So in short you would go over each element only once"
                    }
                ]
            },
            {
                "id": 1568770,
                "content": [
                    {
                        "username": "MarkMarcel",
                        "content": "My challenge with solving this problem was getting the definition of an island. What I thought an island was, is a 1 surrounded by 0\\'s either on left and right or top and bottom. Like in image, my definition gave the 2 islands circled in example 1.\\n![image](https://assets.leetcode.com/users/images/0cadaf5c-858d-4cfd-91e8-27427e5d9d01_1649931304.8787706.png)\\n\\nAfter getting my test case wrong, I went through the discussions and based on solutions I realised the question meant an island is a string of 1s like shown in the images below\\n![image](https://assets.leetcode.com/users/images/e6a18482-7542-421a-bd27-cf79e44618e5_1649932030.3147244.png)\\n![image](https://assets.leetcode.com/users/images/b6938d3b-26d7-45d9-88a8-e4956b0ed10a_1649932030.3330166.png)\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "Why is \\'1\\' and \\'0\\' chars? Just to irritate people?"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@sanidhyas3s](/sanidhyas3s) Same lol. My code 100% worked after I changed it from a number to char "
                    },
                    {
                        "username": "sanidhyas3s",
                        "content": "[@nemanjac](/nemanjac) They could\\'ve kept it a char and let it have a numerical value of 0 or 1 instead of \\'0\\' and \\'1\\'. Can\\'t believe I wasted like 10 minutes just figuring out that I had 1 instead of \\'1\\'."
                    },
                    {
                        "username": "lucasan2300",
                        "content": "would you think that, it doesn't matter, but It will be to develop some technique for change it, or handle... please smile!"
                    },
                    {
                        "username": "avyayk",
                        "content": "[@nemanjac](/nemanjac) A bit (1/0) takes up one bit and also achieves the goal :)"
                    },
                    {
                        "username": "Msey",
                        "content": "[@mcthouacbb](/mcthouacbb) it teaches us to be attentive"
                    },
                    {
                        "username": "nemanjac",
                        "content": "Perhaps because a char takes up 2 bytes, where as an int takes up 4."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "Basically. Spent a good 10-15 minutes wondering why my conditions kept miscomparing...Take it as a lesson to read the inputs clearly lol."
                    },
                    {
                        "username": "close27",
                        "content": "lol..agree"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "[@Zephromonia](/Zephromonia) same :|"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Leetcode likes to do a little bit of trolling"
                    },
                    {
                        "username": "Zephromonia",
                        "content": "Quite annoying. Was using not boolean operator for a while."
                    },
                    {
                        "username": "uwswe",
                        "content": "Looks like quite a few people labled their code as a BFS solution, when it\\'s actually DFS. And what\\'s worse is that you\\'re being praised for an incorrect solutiuon. Just because leetcode accepts it, doesn\\'t mean its correct.\\n\\nIf you don\\'t know the difference, then you should read the leetcode chapters on BFS, and DFS. The problem clearly states \"Queue and BFS\", and many people didn\\'t bother to use a queue at all. While this problem can be solved recursively (i.e. DFS), that\\'s not the solution we were asked to provide. The main difference between BFS and DFS is the order you visit the nodes. BFS uses a Queue to visit the closest nodes first, while DFS pretty much skips some nodes next door and follows the path until it reaches a deadend. \\n\\nWhat if the one node you were looking for was the 2nd neighbor, and you picked the first one and followed the path? \\n\\nA better question is, what are you going to do when your interviewer tells you that your recursive solution overflowed the call stack, and you need to improve your solution? Yeah you could implement a Stack yourself, and not use the call stack. But then what if your interviewer really wants the best solution possible, which should be BFS, but you give them your DFS solution?\\n\\nThere\\'s a lot of people who use leetcode to learn how to code, and understand data structures. Praising incorrect solutions is stumping the grow of future engineers. Also, if you want to proudly share your solution, please provide properly formatted code with descriptive variable names - no one wants to break out pen and paper to dissect your logic.\\n\\n"
                    },
                    {
                        "username": "jeehaytch",
                        "content": "My solution is DFS (using a stack) and I beat 96 to 99%"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "1. You\\'re adding constraints not present in the problem statement. The problem statement leaves it to the solver to select a traversal method. \\n\\n2. We\\'re not looking for a specific node. DFS and BFS are identical in efficiency for this problem.\\n\\n3. BFS isn\\'t \\'the best possible\\' and I\\'d tell the interviewer that. The call stack would never \\'overflow\\' because you have at most m*n calls. This is the same space complexity as BFS. \\n\\n4. Don\\'t use leetcode to learn how to code. Code written for leetcode problems sacrifices readability for optimization. Use leetcode to learn how to do technical interviews. Learn how to program from books, language docs, courses.\\n\\n5. You probably meant \\'stunts\\' not \\'stumps\\'. Forgivable as I assume you\\'re ESL, but the condescending nature of your post weighs against my typical charity.\\n\\n6. If you don\\'t understand a solution you should \\'dissect\\' the logic. How else do you actually learn? \\n\\nI\\'m awed by the irony of you lambasting people for \\'praising\\' \\'incorrect\\' solutions in post where you ignorantly condescend with inane drivel in every paragraph.\\n\\nYou are both incorrect and arrogant. You\\'re errorgant. \\n\\nIt\\'s an off-putting character flaw and will probably harm you more in interviews (and in life) than bombing a technical round. "
                    },
                    {
                        "username": "klami",
                        "content": "the problem is also listed under \"Stack and DFS\" so I think either is okay"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 But as of me , I am more comfortable at using bfs instead of dfs."
                    },
                    {
                        "username": "roundlet",
                        "content": "I just encountered this question in an interview, and I have no idea about how to handle this efficiently. Could anyone provides any hints?"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "we can solve in n**2 using BFS traversal. please have look on solution at  \\nhttps://leetcode.com/problems/number-of-islands/submissions/993397265/"
                    },
                    {
                        "username": "TeaTrey",
                        "content": "[@lumpychum](/lumpychum) I used visited, but overwriting with \\'0\\' is pretty cool. Thanks"
                    },
                    {
                        "username": "math_pi",
                        "content": "It is a standard grid problem, you can use DFS and vector of directions."
                    },
                    {
                        "username": "lumpychum",
                        "content": "Essentially you want to traverse the matrix until you find a 1. Once you locate one (no pun intended) you essentially use flood fill to recursively \"mark\" any connected 1s (the rest of the island) by replacing them with zeros. If you do not want to mutate the given matrix, you can use a visited matrix."
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I have encountered this problem. I want to share my findings in case someone faces this one as well.\\n\\nBefore the start of coding, I thought the condition that one cell being inspected more than once is not a great issue because the duplicate cells are set to \\'0\\' anyway. However, that was WRONG. Because, before the cell is set to \\'0\\', it has already been pushed into queue by its neighbors.\\nThe time complexity is no longer O(M * N);\\nInstead, one cell cause 2 copies of neighbors, and then 4 copies of neighbors of neighbors ...\\n\\nSo as long as neighbors are pushed into queue, they should be set to \\'0\\' immediately."
                    },
                    {
                        "username": "aparr487",
                        "content": "Thanks! This was exactly my problem (flooding the land cell after dequeuing, rather than when enqueuing)."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan you please explain more the testcases and what exactly island means? thanks"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/30e6adfa-133f-4607-ba65-521d0e774b34_1643961955.1657922.png)\\n\\n ![image](https://assets.leetcode.com/users/images/8f49d0cb-605d-4549-8546-b6ad7fd05f7a_1643964600.5265105.png)\\n"
                    },
                    {
                        "username": "david120",
                        "content": "This is probably an old problem and not worth changing, but it makes little sense to not have the elements of `grid` be integers.  I was scratching my head at why what should have been a very simple solution was not working until I noticed the quotes on the 1s and 0s.  I suppose this is what I get for using python, which allows comparison between `1` and `\\'1\\'`."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Same happened with me also"
                    },
                    {
                        "username": "chaos28",
                        "content": "When using DFS to solve, it take O(m * n) to iterate through the matrix, but in the recursion dfs function, it also need to iterate over the matrix , so does it mean that the overall time complexity turn out to be O(m * n) * O(m * n)?"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "Why is the time complexity of both DFS and BFS O(m * n) ? I thought it would be same as path finding algorithm, as we traverse 4 ways (up, down, left, right) it is O(4^ (m + n)).\\n\\nCan anyone explain this? I do not want to get this wrong at interview, hence asking for you analysis."
                    },
                    {
                        "username": "nambrose",
                        "content": "[@sidharthgurbani](/sidharthgurbani) What about the case where the entire grid is 1\\'s, we would have to go over each spot twice (the dfs of the entire grid, and our double for loop)"
                    },
                    {
                        "username": "sidharthgurbani",
                        "content": "It is because during every DFS, you change the \"1\" to \"0\". Thereby eliminating the need for running DFS on it again. So in short you would go over each element only once"
                    }
                ]
            },
            {
                "id": 1572439,
                "content": [
                    {
                        "username": "MarkMarcel",
                        "content": "My challenge with solving this problem was getting the definition of an island. What I thought an island was, is a 1 surrounded by 0\\'s either on left and right or top and bottom. Like in image, my definition gave the 2 islands circled in example 1.\\n![image](https://assets.leetcode.com/users/images/0cadaf5c-858d-4cfd-91e8-27427e5d9d01_1649931304.8787706.png)\\n\\nAfter getting my test case wrong, I went through the discussions and based on solutions I realised the question meant an island is a string of 1s like shown in the images below\\n![image](https://assets.leetcode.com/users/images/e6a18482-7542-421a-bd27-cf79e44618e5_1649932030.3147244.png)\\n![image](https://assets.leetcode.com/users/images/b6938d3b-26d7-45d9-88a8-e4956b0ed10a_1649932030.3330166.png)\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "Why is \\'1\\' and \\'0\\' chars? Just to irritate people?"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@sanidhyas3s](/sanidhyas3s) Same lol. My code 100% worked after I changed it from a number to char "
                    },
                    {
                        "username": "sanidhyas3s",
                        "content": "[@nemanjac](/nemanjac) They could\\'ve kept it a char and let it have a numerical value of 0 or 1 instead of \\'0\\' and \\'1\\'. Can\\'t believe I wasted like 10 minutes just figuring out that I had 1 instead of \\'1\\'."
                    },
                    {
                        "username": "lucasan2300",
                        "content": "would you think that, it doesn't matter, but It will be to develop some technique for change it, or handle... please smile!"
                    },
                    {
                        "username": "avyayk",
                        "content": "[@nemanjac](/nemanjac) A bit (1/0) takes up one bit and also achieves the goal :)"
                    },
                    {
                        "username": "Msey",
                        "content": "[@mcthouacbb](/mcthouacbb) it teaches us to be attentive"
                    },
                    {
                        "username": "nemanjac",
                        "content": "Perhaps because a char takes up 2 bytes, where as an int takes up 4."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "Basically. Spent a good 10-15 minutes wondering why my conditions kept miscomparing...Take it as a lesson to read the inputs clearly lol."
                    },
                    {
                        "username": "close27",
                        "content": "lol..agree"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "[@Zephromonia](/Zephromonia) same :|"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Leetcode likes to do a little bit of trolling"
                    },
                    {
                        "username": "Zephromonia",
                        "content": "Quite annoying. Was using not boolean operator for a while."
                    },
                    {
                        "username": "uwswe",
                        "content": "Looks like quite a few people labled their code as a BFS solution, when it\\'s actually DFS. And what\\'s worse is that you\\'re being praised for an incorrect solutiuon. Just because leetcode accepts it, doesn\\'t mean its correct.\\n\\nIf you don\\'t know the difference, then you should read the leetcode chapters on BFS, and DFS. The problem clearly states \"Queue and BFS\", and many people didn\\'t bother to use a queue at all. While this problem can be solved recursively (i.e. DFS), that\\'s not the solution we were asked to provide. The main difference between BFS and DFS is the order you visit the nodes. BFS uses a Queue to visit the closest nodes first, while DFS pretty much skips some nodes next door and follows the path until it reaches a deadend. \\n\\nWhat if the one node you were looking for was the 2nd neighbor, and you picked the first one and followed the path? \\n\\nA better question is, what are you going to do when your interviewer tells you that your recursive solution overflowed the call stack, and you need to improve your solution? Yeah you could implement a Stack yourself, and not use the call stack. But then what if your interviewer really wants the best solution possible, which should be BFS, but you give them your DFS solution?\\n\\nThere\\'s a lot of people who use leetcode to learn how to code, and understand data structures. Praising incorrect solutions is stumping the grow of future engineers. Also, if you want to proudly share your solution, please provide properly formatted code with descriptive variable names - no one wants to break out pen and paper to dissect your logic.\\n\\n"
                    },
                    {
                        "username": "jeehaytch",
                        "content": "My solution is DFS (using a stack) and I beat 96 to 99%"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "1. You\\'re adding constraints not present in the problem statement. The problem statement leaves it to the solver to select a traversal method. \\n\\n2. We\\'re not looking for a specific node. DFS and BFS are identical in efficiency for this problem.\\n\\n3. BFS isn\\'t \\'the best possible\\' and I\\'d tell the interviewer that. The call stack would never \\'overflow\\' because you have at most m*n calls. This is the same space complexity as BFS. \\n\\n4. Don\\'t use leetcode to learn how to code. Code written for leetcode problems sacrifices readability for optimization. Use leetcode to learn how to do technical interviews. Learn how to program from books, language docs, courses.\\n\\n5. You probably meant \\'stunts\\' not \\'stumps\\'. Forgivable as I assume you\\'re ESL, but the condescending nature of your post weighs against my typical charity.\\n\\n6. If you don\\'t understand a solution you should \\'dissect\\' the logic. How else do you actually learn? \\n\\nI\\'m awed by the irony of you lambasting people for \\'praising\\' \\'incorrect\\' solutions in post where you ignorantly condescend with inane drivel in every paragraph.\\n\\nYou are both incorrect and arrogant. You\\'re errorgant. \\n\\nIt\\'s an off-putting character flaw and will probably harm you more in interviews (and in life) than bombing a technical round. "
                    },
                    {
                        "username": "klami",
                        "content": "the problem is also listed under \"Stack and DFS\" so I think either is okay"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 But as of me , I am more comfortable at using bfs instead of dfs."
                    },
                    {
                        "username": "roundlet",
                        "content": "I just encountered this question in an interview, and I have no idea about how to handle this efficiently. Could anyone provides any hints?"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "we can solve in n**2 using BFS traversal. please have look on solution at  \\nhttps://leetcode.com/problems/number-of-islands/submissions/993397265/"
                    },
                    {
                        "username": "TeaTrey",
                        "content": "[@lumpychum](/lumpychum) I used visited, but overwriting with \\'0\\' is pretty cool. Thanks"
                    },
                    {
                        "username": "math_pi",
                        "content": "It is a standard grid problem, you can use DFS and vector of directions."
                    },
                    {
                        "username": "lumpychum",
                        "content": "Essentially you want to traverse the matrix until you find a 1. Once you locate one (no pun intended) you essentially use flood fill to recursively \"mark\" any connected 1s (the rest of the island) by replacing them with zeros. If you do not want to mutate the given matrix, you can use a visited matrix."
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I have encountered this problem. I want to share my findings in case someone faces this one as well.\\n\\nBefore the start of coding, I thought the condition that one cell being inspected more than once is not a great issue because the duplicate cells are set to \\'0\\' anyway. However, that was WRONG. Because, before the cell is set to \\'0\\', it has already been pushed into queue by its neighbors.\\nThe time complexity is no longer O(M * N);\\nInstead, one cell cause 2 copies of neighbors, and then 4 copies of neighbors of neighbors ...\\n\\nSo as long as neighbors are pushed into queue, they should be set to \\'0\\' immediately."
                    },
                    {
                        "username": "aparr487",
                        "content": "Thanks! This was exactly my problem (flooding the land cell after dequeuing, rather than when enqueuing)."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan you please explain more the testcases and what exactly island means? thanks"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/30e6adfa-133f-4607-ba65-521d0e774b34_1643961955.1657922.png)\\n\\n ![image](https://assets.leetcode.com/users/images/8f49d0cb-605d-4549-8546-b6ad7fd05f7a_1643964600.5265105.png)\\n"
                    },
                    {
                        "username": "david120",
                        "content": "This is probably an old problem and not worth changing, but it makes little sense to not have the elements of `grid` be integers.  I was scratching my head at why what should have been a very simple solution was not working until I noticed the quotes on the 1s and 0s.  I suppose this is what I get for using python, which allows comparison between `1` and `\\'1\\'`."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Same happened with me also"
                    },
                    {
                        "username": "chaos28",
                        "content": "When using DFS to solve, it take O(m * n) to iterate through the matrix, but in the recursion dfs function, it also need to iterate over the matrix , so does it mean that the overall time complexity turn out to be O(m * n) * O(m * n)?"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "Why is the time complexity of both DFS and BFS O(m * n) ? I thought it would be same as path finding algorithm, as we traverse 4 ways (up, down, left, right) it is O(4^ (m + n)).\\n\\nCan anyone explain this? I do not want to get this wrong at interview, hence asking for you analysis."
                    },
                    {
                        "username": "nambrose",
                        "content": "[@sidharthgurbani](/sidharthgurbani) What about the case where the entire grid is 1\\'s, we would have to go over each spot twice (the dfs of the entire grid, and our double for loop)"
                    },
                    {
                        "username": "sidharthgurbani",
                        "content": "It is because during every DFS, you change the \"1\" to \"0\". Thereby eliminating the need for running DFS on it again. So in short you would go over each element only once"
                    }
                ]
            },
            {
                "id": 1564854,
                "content": [
                    {
                        "username": "MarkMarcel",
                        "content": "My challenge with solving this problem was getting the definition of an island. What I thought an island was, is a 1 surrounded by 0\\'s either on left and right or top and bottom. Like in image, my definition gave the 2 islands circled in example 1.\\n![image](https://assets.leetcode.com/users/images/0cadaf5c-858d-4cfd-91e8-27427e5d9d01_1649931304.8787706.png)\\n\\nAfter getting my test case wrong, I went through the discussions and based on solutions I realised the question meant an island is a string of 1s like shown in the images below\\n![image](https://assets.leetcode.com/users/images/e6a18482-7542-421a-bd27-cf79e44618e5_1649932030.3147244.png)\\n![image](https://assets.leetcode.com/users/images/b6938d3b-26d7-45d9-88a8-e4956b0ed10a_1649932030.3330166.png)\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "Why is \\'1\\' and \\'0\\' chars? Just to irritate people?"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@sanidhyas3s](/sanidhyas3s) Same lol. My code 100% worked after I changed it from a number to char "
                    },
                    {
                        "username": "sanidhyas3s",
                        "content": "[@nemanjac](/nemanjac) They could\\'ve kept it a char and let it have a numerical value of 0 or 1 instead of \\'0\\' and \\'1\\'. Can\\'t believe I wasted like 10 minutes just figuring out that I had 1 instead of \\'1\\'."
                    },
                    {
                        "username": "lucasan2300",
                        "content": "would you think that, it doesn't matter, but It will be to develop some technique for change it, or handle... please smile!"
                    },
                    {
                        "username": "avyayk",
                        "content": "[@nemanjac](/nemanjac) A bit (1/0) takes up one bit and also achieves the goal :)"
                    },
                    {
                        "username": "Msey",
                        "content": "[@mcthouacbb](/mcthouacbb) it teaches us to be attentive"
                    },
                    {
                        "username": "nemanjac",
                        "content": "Perhaps because a char takes up 2 bytes, where as an int takes up 4."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "Basically. Spent a good 10-15 minutes wondering why my conditions kept miscomparing...Take it as a lesson to read the inputs clearly lol."
                    },
                    {
                        "username": "close27",
                        "content": "lol..agree"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "[@Zephromonia](/Zephromonia) same :|"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Leetcode likes to do a little bit of trolling"
                    },
                    {
                        "username": "Zephromonia",
                        "content": "Quite annoying. Was using not boolean operator for a while."
                    },
                    {
                        "username": "uwswe",
                        "content": "Looks like quite a few people labled their code as a BFS solution, when it\\'s actually DFS. And what\\'s worse is that you\\'re being praised for an incorrect solutiuon. Just because leetcode accepts it, doesn\\'t mean its correct.\\n\\nIf you don\\'t know the difference, then you should read the leetcode chapters on BFS, and DFS. The problem clearly states \"Queue and BFS\", and many people didn\\'t bother to use a queue at all. While this problem can be solved recursively (i.e. DFS), that\\'s not the solution we were asked to provide. The main difference between BFS and DFS is the order you visit the nodes. BFS uses a Queue to visit the closest nodes first, while DFS pretty much skips some nodes next door and follows the path until it reaches a deadend. \\n\\nWhat if the one node you were looking for was the 2nd neighbor, and you picked the first one and followed the path? \\n\\nA better question is, what are you going to do when your interviewer tells you that your recursive solution overflowed the call stack, and you need to improve your solution? Yeah you could implement a Stack yourself, and not use the call stack. But then what if your interviewer really wants the best solution possible, which should be BFS, but you give them your DFS solution?\\n\\nThere\\'s a lot of people who use leetcode to learn how to code, and understand data structures. Praising incorrect solutions is stumping the grow of future engineers. Also, if you want to proudly share your solution, please provide properly formatted code with descriptive variable names - no one wants to break out pen and paper to dissect your logic.\\n\\n"
                    },
                    {
                        "username": "jeehaytch",
                        "content": "My solution is DFS (using a stack) and I beat 96 to 99%"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "1. You\\'re adding constraints not present in the problem statement. The problem statement leaves it to the solver to select a traversal method. \\n\\n2. We\\'re not looking for a specific node. DFS and BFS are identical in efficiency for this problem.\\n\\n3. BFS isn\\'t \\'the best possible\\' and I\\'d tell the interviewer that. The call stack would never \\'overflow\\' because you have at most m*n calls. This is the same space complexity as BFS. \\n\\n4. Don\\'t use leetcode to learn how to code. Code written for leetcode problems sacrifices readability for optimization. Use leetcode to learn how to do technical interviews. Learn how to program from books, language docs, courses.\\n\\n5. You probably meant \\'stunts\\' not \\'stumps\\'. Forgivable as I assume you\\'re ESL, but the condescending nature of your post weighs against my typical charity.\\n\\n6. If you don\\'t understand a solution you should \\'dissect\\' the logic. How else do you actually learn? \\n\\nI\\'m awed by the irony of you lambasting people for \\'praising\\' \\'incorrect\\' solutions in post where you ignorantly condescend with inane drivel in every paragraph.\\n\\nYou are both incorrect and arrogant. You\\'re errorgant. \\n\\nIt\\'s an off-putting character flaw and will probably harm you more in interviews (and in life) than bombing a technical round. "
                    },
                    {
                        "username": "klami",
                        "content": "the problem is also listed under \"Stack and DFS\" so I think either is okay"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 But as of me , I am more comfortable at using bfs instead of dfs."
                    },
                    {
                        "username": "roundlet",
                        "content": "I just encountered this question in an interview, and I have no idea about how to handle this efficiently. Could anyone provides any hints?"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "we can solve in n**2 using BFS traversal. please have look on solution at  \\nhttps://leetcode.com/problems/number-of-islands/submissions/993397265/"
                    },
                    {
                        "username": "TeaTrey",
                        "content": "[@lumpychum](/lumpychum) I used visited, but overwriting with \\'0\\' is pretty cool. Thanks"
                    },
                    {
                        "username": "math_pi",
                        "content": "It is a standard grid problem, you can use DFS and vector of directions."
                    },
                    {
                        "username": "lumpychum",
                        "content": "Essentially you want to traverse the matrix until you find a 1. Once you locate one (no pun intended) you essentially use flood fill to recursively \"mark\" any connected 1s (the rest of the island) by replacing them with zeros. If you do not want to mutate the given matrix, you can use a visited matrix."
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I have encountered this problem. I want to share my findings in case someone faces this one as well.\\n\\nBefore the start of coding, I thought the condition that one cell being inspected more than once is not a great issue because the duplicate cells are set to \\'0\\' anyway. However, that was WRONG. Because, before the cell is set to \\'0\\', it has already been pushed into queue by its neighbors.\\nThe time complexity is no longer O(M * N);\\nInstead, one cell cause 2 copies of neighbors, and then 4 copies of neighbors of neighbors ...\\n\\nSo as long as neighbors are pushed into queue, they should be set to \\'0\\' immediately."
                    },
                    {
                        "username": "aparr487",
                        "content": "Thanks! This was exactly my problem (flooding the land cell after dequeuing, rather than when enqueuing)."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan you please explain more the testcases and what exactly island means? thanks"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/30e6adfa-133f-4607-ba65-521d0e774b34_1643961955.1657922.png)\\n\\n ![image](https://assets.leetcode.com/users/images/8f49d0cb-605d-4549-8546-b6ad7fd05f7a_1643964600.5265105.png)\\n"
                    },
                    {
                        "username": "david120",
                        "content": "This is probably an old problem and not worth changing, but it makes little sense to not have the elements of `grid` be integers.  I was scratching my head at why what should have been a very simple solution was not working until I noticed the quotes on the 1s and 0s.  I suppose this is what I get for using python, which allows comparison between `1` and `\\'1\\'`."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Same happened with me also"
                    },
                    {
                        "username": "chaos28",
                        "content": "When using DFS to solve, it take O(m * n) to iterate through the matrix, but in the recursion dfs function, it also need to iterate over the matrix , so does it mean that the overall time complexity turn out to be O(m * n) * O(m * n)?"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "Why is the time complexity of both DFS and BFS O(m * n) ? I thought it would be same as path finding algorithm, as we traverse 4 ways (up, down, left, right) it is O(4^ (m + n)).\\n\\nCan anyone explain this? I do not want to get this wrong at interview, hence asking for you analysis."
                    },
                    {
                        "username": "nambrose",
                        "content": "[@sidharthgurbani](/sidharthgurbani) What about the case where the entire grid is 1\\'s, we would have to go over each spot twice (the dfs of the entire grid, and our double for loop)"
                    },
                    {
                        "username": "sidharthgurbani",
                        "content": "It is because during every DFS, you change the \"1\" to \"0\". Thereby eliminating the need for running DFS on it again. So in short you would go over each element only once"
                    }
                ]
            },
            {
                "id": 1565770,
                "content": [
                    {
                        "username": "MarkMarcel",
                        "content": "My challenge with solving this problem was getting the definition of an island. What I thought an island was, is a 1 surrounded by 0\\'s either on left and right or top and bottom. Like in image, my definition gave the 2 islands circled in example 1.\\n![image](https://assets.leetcode.com/users/images/0cadaf5c-858d-4cfd-91e8-27427e5d9d01_1649931304.8787706.png)\\n\\nAfter getting my test case wrong, I went through the discussions and based on solutions I realised the question meant an island is a string of 1s like shown in the images below\\n![image](https://assets.leetcode.com/users/images/e6a18482-7542-421a-bd27-cf79e44618e5_1649932030.3147244.png)\\n![image](https://assets.leetcode.com/users/images/b6938d3b-26d7-45d9-88a8-e4956b0ed10a_1649932030.3330166.png)\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "Why is \\'1\\' and \\'0\\' chars? Just to irritate people?"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@sanidhyas3s](/sanidhyas3s) Same lol. My code 100% worked after I changed it from a number to char "
                    },
                    {
                        "username": "sanidhyas3s",
                        "content": "[@nemanjac](/nemanjac) They could\\'ve kept it a char and let it have a numerical value of 0 or 1 instead of \\'0\\' and \\'1\\'. Can\\'t believe I wasted like 10 minutes just figuring out that I had 1 instead of \\'1\\'."
                    },
                    {
                        "username": "lucasan2300",
                        "content": "would you think that, it doesn't matter, but It will be to develop some technique for change it, or handle... please smile!"
                    },
                    {
                        "username": "avyayk",
                        "content": "[@nemanjac](/nemanjac) A bit (1/0) takes up one bit and also achieves the goal :)"
                    },
                    {
                        "username": "Msey",
                        "content": "[@mcthouacbb](/mcthouacbb) it teaches us to be attentive"
                    },
                    {
                        "username": "nemanjac",
                        "content": "Perhaps because a char takes up 2 bytes, where as an int takes up 4."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "Basically. Spent a good 10-15 minutes wondering why my conditions kept miscomparing...Take it as a lesson to read the inputs clearly lol."
                    },
                    {
                        "username": "close27",
                        "content": "lol..agree"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "[@Zephromonia](/Zephromonia) same :|"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Leetcode likes to do a little bit of trolling"
                    },
                    {
                        "username": "Zephromonia",
                        "content": "Quite annoying. Was using not boolean operator for a while."
                    },
                    {
                        "username": "uwswe",
                        "content": "Looks like quite a few people labled their code as a BFS solution, when it\\'s actually DFS. And what\\'s worse is that you\\'re being praised for an incorrect solutiuon. Just because leetcode accepts it, doesn\\'t mean its correct.\\n\\nIf you don\\'t know the difference, then you should read the leetcode chapters on BFS, and DFS. The problem clearly states \"Queue and BFS\", and many people didn\\'t bother to use a queue at all. While this problem can be solved recursively (i.e. DFS), that\\'s not the solution we were asked to provide. The main difference between BFS and DFS is the order you visit the nodes. BFS uses a Queue to visit the closest nodes first, while DFS pretty much skips some nodes next door and follows the path until it reaches a deadend. \\n\\nWhat if the one node you were looking for was the 2nd neighbor, and you picked the first one and followed the path? \\n\\nA better question is, what are you going to do when your interviewer tells you that your recursive solution overflowed the call stack, and you need to improve your solution? Yeah you could implement a Stack yourself, and not use the call stack. But then what if your interviewer really wants the best solution possible, which should be BFS, but you give them your DFS solution?\\n\\nThere\\'s a lot of people who use leetcode to learn how to code, and understand data structures. Praising incorrect solutions is stumping the grow of future engineers. Also, if you want to proudly share your solution, please provide properly formatted code with descriptive variable names - no one wants to break out pen and paper to dissect your logic.\\n\\n"
                    },
                    {
                        "username": "jeehaytch",
                        "content": "My solution is DFS (using a stack) and I beat 96 to 99%"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "1. You\\'re adding constraints not present in the problem statement. The problem statement leaves it to the solver to select a traversal method. \\n\\n2. We\\'re not looking for a specific node. DFS and BFS are identical in efficiency for this problem.\\n\\n3. BFS isn\\'t \\'the best possible\\' and I\\'d tell the interviewer that. The call stack would never \\'overflow\\' because you have at most m*n calls. This is the same space complexity as BFS. \\n\\n4. Don\\'t use leetcode to learn how to code. Code written for leetcode problems sacrifices readability for optimization. Use leetcode to learn how to do technical interviews. Learn how to program from books, language docs, courses.\\n\\n5. You probably meant \\'stunts\\' not \\'stumps\\'. Forgivable as I assume you\\'re ESL, but the condescending nature of your post weighs against my typical charity.\\n\\n6. If you don\\'t understand a solution you should \\'dissect\\' the logic. How else do you actually learn? \\n\\nI\\'m awed by the irony of you lambasting people for \\'praising\\' \\'incorrect\\' solutions in post where you ignorantly condescend with inane drivel in every paragraph.\\n\\nYou are both incorrect and arrogant. You\\'re errorgant. \\n\\nIt\\'s an off-putting character flaw and will probably harm you more in interviews (and in life) than bombing a technical round. "
                    },
                    {
                        "username": "klami",
                        "content": "the problem is also listed under \"Stack and DFS\" so I think either is okay"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 But as of me , I am more comfortable at using bfs instead of dfs."
                    },
                    {
                        "username": "roundlet",
                        "content": "I just encountered this question in an interview, and I have no idea about how to handle this efficiently. Could anyone provides any hints?"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "we can solve in n**2 using BFS traversal. please have look on solution at  \\nhttps://leetcode.com/problems/number-of-islands/submissions/993397265/"
                    },
                    {
                        "username": "TeaTrey",
                        "content": "[@lumpychum](/lumpychum) I used visited, but overwriting with \\'0\\' is pretty cool. Thanks"
                    },
                    {
                        "username": "math_pi",
                        "content": "It is a standard grid problem, you can use DFS and vector of directions."
                    },
                    {
                        "username": "lumpychum",
                        "content": "Essentially you want to traverse the matrix until you find a 1. Once you locate one (no pun intended) you essentially use flood fill to recursively \"mark\" any connected 1s (the rest of the island) by replacing them with zeros. If you do not want to mutate the given matrix, you can use a visited matrix."
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I have encountered this problem. I want to share my findings in case someone faces this one as well.\\n\\nBefore the start of coding, I thought the condition that one cell being inspected more than once is not a great issue because the duplicate cells are set to \\'0\\' anyway. However, that was WRONG. Because, before the cell is set to \\'0\\', it has already been pushed into queue by its neighbors.\\nThe time complexity is no longer O(M * N);\\nInstead, one cell cause 2 copies of neighbors, and then 4 copies of neighbors of neighbors ...\\n\\nSo as long as neighbors are pushed into queue, they should be set to \\'0\\' immediately."
                    },
                    {
                        "username": "aparr487",
                        "content": "Thanks! This was exactly my problem (flooding the land cell after dequeuing, rather than when enqueuing)."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan you please explain more the testcases and what exactly island means? thanks"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/30e6adfa-133f-4607-ba65-521d0e774b34_1643961955.1657922.png)\\n\\n ![image](https://assets.leetcode.com/users/images/8f49d0cb-605d-4549-8546-b6ad7fd05f7a_1643964600.5265105.png)\\n"
                    },
                    {
                        "username": "david120",
                        "content": "This is probably an old problem and not worth changing, but it makes little sense to not have the elements of `grid` be integers.  I was scratching my head at why what should have been a very simple solution was not working until I noticed the quotes on the 1s and 0s.  I suppose this is what I get for using python, which allows comparison between `1` and `\\'1\\'`."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Same happened with me also"
                    },
                    {
                        "username": "chaos28",
                        "content": "When using DFS to solve, it take O(m * n) to iterate through the matrix, but in the recursion dfs function, it also need to iterate over the matrix , so does it mean that the overall time complexity turn out to be O(m * n) * O(m * n)?"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "Why is the time complexity of both DFS and BFS O(m * n) ? I thought it would be same as path finding algorithm, as we traverse 4 ways (up, down, left, right) it is O(4^ (m + n)).\\n\\nCan anyone explain this? I do not want to get this wrong at interview, hence asking for you analysis."
                    },
                    {
                        "username": "nambrose",
                        "content": "[@sidharthgurbani](/sidharthgurbani) What about the case where the entire grid is 1\\'s, we would have to go over each spot twice (the dfs of the entire grid, and our double for loop)"
                    },
                    {
                        "username": "sidharthgurbani",
                        "content": "It is because during every DFS, you change the \"1\" to \"0\". Thereby eliminating the need for running DFS on it again. So in short you would go over each element only once"
                    }
                ]
            },
            {
                "id": 1566246,
                "content": [
                    {
                        "username": "MarkMarcel",
                        "content": "My challenge with solving this problem was getting the definition of an island. What I thought an island was, is a 1 surrounded by 0\\'s either on left and right or top and bottom. Like in image, my definition gave the 2 islands circled in example 1.\\n![image](https://assets.leetcode.com/users/images/0cadaf5c-858d-4cfd-91e8-27427e5d9d01_1649931304.8787706.png)\\n\\nAfter getting my test case wrong, I went through the discussions and based on solutions I realised the question meant an island is a string of 1s like shown in the images below\\n![image](https://assets.leetcode.com/users/images/e6a18482-7542-421a-bd27-cf79e44618e5_1649932030.3147244.png)\\n![image](https://assets.leetcode.com/users/images/b6938d3b-26d7-45d9-88a8-e4956b0ed10a_1649932030.3330166.png)\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "Why is \\'1\\' and \\'0\\' chars? Just to irritate people?"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@sanidhyas3s](/sanidhyas3s) Same lol. My code 100% worked after I changed it from a number to char "
                    },
                    {
                        "username": "sanidhyas3s",
                        "content": "[@nemanjac](/nemanjac) They could\\'ve kept it a char and let it have a numerical value of 0 or 1 instead of \\'0\\' and \\'1\\'. Can\\'t believe I wasted like 10 minutes just figuring out that I had 1 instead of \\'1\\'."
                    },
                    {
                        "username": "lucasan2300",
                        "content": "would you think that, it doesn't matter, but It will be to develop some technique for change it, or handle... please smile!"
                    },
                    {
                        "username": "avyayk",
                        "content": "[@nemanjac](/nemanjac) A bit (1/0) takes up one bit and also achieves the goal :)"
                    },
                    {
                        "username": "Msey",
                        "content": "[@mcthouacbb](/mcthouacbb) it teaches us to be attentive"
                    },
                    {
                        "username": "nemanjac",
                        "content": "Perhaps because a char takes up 2 bytes, where as an int takes up 4."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "Basically. Spent a good 10-15 minutes wondering why my conditions kept miscomparing...Take it as a lesson to read the inputs clearly lol."
                    },
                    {
                        "username": "close27",
                        "content": "lol..agree"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "[@Zephromonia](/Zephromonia) same :|"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Leetcode likes to do a little bit of trolling"
                    },
                    {
                        "username": "Zephromonia",
                        "content": "Quite annoying. Was using not boolean operator for a while."
                    },
                    {
                        "username": "uwswe",
                        "content": "Looks like quite a few people labled their code as a BFS solution, when it\\'s actually DFS. And what\\'s worse is that you\\'re being praised for an incorrect solutiuon. Just because leetcode accepts it, doesn\\'t mean its correct.\\n\\nIf you don\\'t know the difference, then you should read the leetcode chapters on BFS, and DFS. The problem clearly states \"Queue and BFS\", and many people didn\\'t bother to use a queue at all. While this problem can be solved recursively (i.e. DFS), that\\'s not the solution we were asked to provide. The main difference between BFS and DFS is the order you visit the nodes. BFS uses a Queue to visit the closest nodes first, while DFS pretty much skips some nodes next door and follows the path until it reaches a deadend. \\n\\nWhat if the one node you were looking for was the 2nd neighbor, and you picked the first one and followed the path? \\n\\nA better question is, what are you going to do when your interviewer tells you that your recursive solution overflowed the call stack, and you need to improve your solution? Yeah you could implement a Stack yourself, and not use the call stack. But then what if your interviewer really wants the best solution possible, which should be BFS, but you give them your DFS solution?\\n\\nThere\\'s a lot of people who use leetcode to learn how to code, and understand data structures. Praising incorrect solutions is stumping the grow of future engineers. Also, if you want to proudly share your solution, please provide properly formatted code with descriptive variable names - no one wants to break out pen and paper to dissect your logic.\\n\\n"
                    },
                    {
                        "username": "jeehaytch",
                        "content": "My solution is DFS (using a stack) and I beat 96 to 99%"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "1. You\\'re adding constraints not present in the problem statement. The problem statement leaves it to the solver to select a traversal method. \\n\\n2. We\\'re not looking for a specific node. DFS and BFS are identical in efficiency for this problem.\\n\\n3. BFS isn\\'t \\'the best possible\\' and I\\'d tell the interviewer that. The call stack would never \\'overflow\\' because you have at most m*n calls. This is the same space complexity as BFS. \\n\\n4. Don\\'t use leetcode to learn how to code. Code written for leetcode problems sacrifices readability for optimization. Use leetcode to learn how to do technical interviews. Learn how to program from books, language docs, courses.\\n\\n5. You probably meant \\'stunts\\' not \\'stumps\\'. Forgivable as I assume you\\'re ESL, but the condescending nature of your post weighs against my typical charity.\\n\\n6. If you don\\'t understand a solution you should \\'dissect\\' the logic. How else do you actually learn? \\n\\nI\\'m awed by the irony of you lambasting people for \\'praising\\' \\'incorrect\\' solutions in post where you ignorantly condescend with inane drivel in every paragraph.\\n\\nYou are both incorrect and arrogant. You\\'re errorgant. \\n\\nIt\\'s an off-putting character flaw and will probably harm you more in interviews (and in life) than bombing a technical round. "
                    },
                    {
                        "username": "klami",
                        "content": "the problem is also listed under \"Stack and DFS\" so I think either is okay"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 But as of me , I am more comfortable at using bfs instead of dfs."
                    },
                    {
                        "username": "roundlet",
                        "content": "I just encountered this question in an interview, and I have no idea about how to handle this efficiently. Could anyone provides any hints?"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "we can solve in n**2 using BFS traversal. please have look on solution at  \\nhttps://leetcode.com/problems/number-of-islands/submissions/993397265/"
                    },
                    {
                        "username": "TeaTrey",
                        "content": "[@lumpychum](/lumpychum) I used visited, but overwriting with \\'0\\' is pretty cool. Thanks"
                    },
                    {
                        "username": "math_pi",
                        "content": "It is a standard grid problem, you can use DFS and vector of directions."
                    },
                    {
                        "username": "lumpychum",
                        "content": "Essentially you want to traverse the matrix until you find a 1. Once you locate one (no pun intended) you essentially use flood fill to recursively \"mark\" any connected 1s (the rest of the island) by replacing them with zeros. If you do not want to mutate the given matrix, you can use a visited matrix."
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I have encountered this problem. I want to share my findings in case someone faces this one as well.\\n\\nBefore the start of coding, I thought the condition that one cell being inspected more than once is not a great issue because the duplicate cells are set to \\'0\\' anyway. However, that was WRONG. Because, before the cell is set to \\'0\\', it has already been pushed into queue by its neighbors.\\nThe time complexity is no longer O(M * N);\\nInstead, one cell cause 2 copies of neighbors, and then 4 copies of neighbors of neighbors ...\\n\\nSo as long as neighbors are pushed into queue, they should be set to \\'0\\' immediately."
                    },
                    {
                        "username": "aparr487",
                        "content": "Thanks! This was exactly my problem (flooding the land cell after dequeuing, rather than when enqueuing)."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan you please explain more the testcases and what exactly island means? thanks"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/30e6adfa-133f-4607-ba65-521d0e774b34_1643961955.1657922.png)\\n\\n ![image](https://assets.leetcode.com/users/images/8f49d0cb-605d-4549-8546-b6ad7fd05f7a_1643964600.5265105.png)\\n"
                    },
                    {
                        "username": "david120",
                        "content": "This is probably an old problem and not worth changing, but it makes little sense to not have the elements of `grid` be integers.  I was scratching my head at why what should have been a very simple solution was not working until I noticed the quotes on the 1s and 0s.  I suppose this is what I get for using python, which allows comparison between `1` and `\\'1\\'`."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Same happened with me also"
                    },
                    {
                        "username": "chaos28",
                        "content": "When using DFS to solve, it take O(m * n) to iterate through the matrix, but in the recursion dfs function, it also need to iterate over the matrix , so does it mean that the overall time complexity turn out to be O(m * n) * O(m * n)?"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "Why is the time complexity of both DFS and BFS O(m * n) ? I thought it would be same as path finding algorithm, as we traverse 4 ways (up, down, left, right) it is O(4^ (m + n)).\\n\\nCan anyone explain this? I do not want to get this wrong at interview, hence asking for you analysis."
                    },
                    {
                        "username": "nambrose",
                        "content": "[@sidharthgurbani](/sidharthgurbani) What about the case where the entire grid is 1\\'s, we would have to go over each spot twice (the dfs of the entire grid, and our double for loop)"
                    },
                    {
                        "username": "sidharthgurbani",
                        "content": "It is because during every DFS, you change the \"1\" to \"0\". Thereby eliminating the need for running DFS on it again. So in short you would go over each element only once"
                    }
                ]
            },
            {
                "id": 1570785,
                "content": [
                    {
                        "username": "MarkMarcel",
                        "content": "My challenge with solving this problem was getting the definition of an island. What I thought an island was, is a 1 surrounded by 0\\'s either on left and right or top and bottom. Like in image, my definition gave the 2 islands circled in example 1.\\n![image](https://assets.leetcode.com/users/images/0cadaf5c-858d-4cfd-91e8-27427e5d9d01_1649931304.8787706.png)\\n\\nAfter getting my test case wrong, I went through the discussions and based on solutions I realised the question meant an island is a string of 1s like shown in the images below\\n![image](https://assets.leetcode.com/users/images/e6a18482-7542-421a-bd27-cf79e44618e5_1649932030.3147244.png)\\n![image](https://assets.leetcode.com/users/images/b6938d3b-26d7-45d9-88a8-e4956b0ed10a_1649932030.3330166.png)\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "Why is \\'1\\' and \\'0\\' chars? Just to irritate people?"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@sanidhyas3s](/sanidhyas3s) Same lol. My code 100% worked after I changed it from a number to char "
                    },
                    {
                        "username": "sanidhyas3s",
                        "content": "[@nemanjac](/nemanjac) They could\\'ve kept it a char and let it have a numerical value of 0 or 1 instead of \\'0\\' and \\'1\\'. Can\\'t believe I wasted like 10 minutes just figuring out that I had 1 instead of \\'1\\'."
                    },
                    {
                        "username": "lucasan2300",
                        "content": "would you think that, it doesn't matter, but It will be to develop some technique for change it, or handle... please smile!"
                    },
                    {
                        "username": "avyayk",
                        "content": "[@nemanjac](/nemanjac) A bit (1/0) takes up one bit and also achieves the goal :)"
                    },
                    {
                        "username": "Msey",
                        "content": "[@mcthouacbb](/mcthouacbb) it teaches us to be attentive"
                    },
                    {
                        "username": "nemanjac",
                        "content": "Perhaps because a char takes up 2 bytes, where as an int takes up 4."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "Basically. Spent a good 10-15 minutes wondering why my conditions kept miscomparing...Take it as a lesson to read the inputs clearly lol."
                    },
                    {
                        "username": "close27",
                        "content": "lol..agree"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "[@Zephromonia](/Zephromonia) same :|"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Leetcode likes to do a little bit of trolling"
                    },
                    {
                        "username": "Zephromonia",
                        "content": "Quite annoying. Was using not boolean operator for a while."
                    },
                    {
                        "username": "uwswe",
                        "content": "Looks like quite a few people labled their code as a BFS solution, when it\\'s actually DFS. And what\\'s worse is that you\\'re being praised for an incorrect solutiuon. Just because leetcode accepts it, doesn\\'t mean its correct.\\n\\nIf you don\\'t know the difference, then you should read the leetcode chapters on BFS, and DFS. The problem clearly states \"Queue and BFS\", and many people didn\\'t bother to use a queue at all. While this problem can be solved recursively (i.e. DFS), that\\'s not the solution we were asked to provide. The main difference between BFS and DFS is the order you visit the nodes. BFS uses a Queue to visit the closest nodes first, while DFS pretty much skips some nodes next door and follows the path until it reaches a deadend. \\n\\nWhat if the one node you were looking for was the 2nd neighbor, and you picked the first one and followed the path? \\n\\nA better question is, what are you going to do when your interviewer tells you that your recursive solution overflowed the call stack, and you need to improve your solution? Yeah you could implement a Stack yourself, and not use the call stack. But then what if your interviewer really wants the best solution possible, which should be BFS, but you give them your DFS solution?\\n\\nThere\\'s a lot of people who use leetcode to learn how to code, and understand data structures. Praising incorrect solutions is stumping the grow of future engineers. Also, if you want to proudly share your solution, please provide properly formatted code with descriptive variable names - no one wants to break out pen and paper to dissect your logic.\\n\\n"
                    },
                    {
                        "username": "jeehaytch",
                        "content": "My solution is DFS (using a stack) and I beat 96 to 99%"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "1. You\\'re adding constraints not present in the problem statement. The problem statement leaves it to the solver to select a traversal method. \\n\\n2. We\\'re not looking for a specific node. DFS and BFS are identical in efficiency for this problem.\\n\\n3. BFS isn\\'t \\'the best possible\\' and I\\'d tell the interviewer that. The call stack would never \\'overflow\\' because you have at most m*n calls. This is the same space complexity as BFS. \\n\\n4. Don\\'t use leetcode to learn how to code. Code written for leetcode problems sacrifices readability for optimization. Use leetcode to learn how to do technical interviews. Learn how to program from books, language docs, courses.\\n\\n5. You probably meant \\'stunts\\' not \\'stumps\\'. Forgivable as I assume you\\'re ESL, but the condescending nature of your post weighs against my typical charity.\\n\\n6. If you don\\'t understand a solution you should \\'dissect\\' the logic. How else do you actually learn? \\n\\nI\\'m awed by the irony of you lambasting people for \\'praising\\' \\'incorrect\\' solutions in post where you ignorantly condescend with inane drivel in every paragraph.\\n\\nYou are both incorrect and arrogant. You\\'re errorgant. \\n\\nIt\\'s an off-putting character flaw and will probably harm you more in interviews (and in life) than bombing a technical round. "
                    },
                    {
                        "username": "klami",
                        "content": "the problem is also listed under \"Stack and DFS\" so I think either is okay"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 But as of me , I am more comfortable at using bfs instead of dfs."
                    },
                    {
                        "username": "roundlet",
                        "content": "I just encountered this question in an interview, and I have no idea about how to handle this efficiently. Could anyone provides any hints?"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "we can solve in n**2 using BFS traversal. please have look on solution at  \\nhttps://leetcode.com/problems/number-of-islands/submissions/993397265/"
                    },
                    {
                        "username": "TeaTrey",
                        "content": "[@lumpychum](/lumpychum) I used visited, but overwriting with \\'0\\' is pretty cool. Thanks"
                    },
                    {
                        "username": "math_pi",
                        "content": "It is a standard grid problem, you can use DFS and vector of directions."
                    },
                    {
                        "username": "lumpychum",
                        "content": "Essentially you want to traverse the matrix until you find a 1. Once you locate one (no pun intended) you essentially use flood fill to recursively \"mark\" any connected 1s (the rest of the island) by replacing them with zeros. If you do not want to mutate the given matrix, you can use a visited matrix."
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I have encountered this problem. I want to share my findings in case someone faces this one as well.\\n\\nBefore the start of coding, I thought the condition that one cell being inspected more than once is not a great issue because the duplicate cells are set to \\'0\\' anyway. However, that was WRONG. Because, before the cell is set to \\'0\\', it has already been pushed into queue by its neighbors.\\nThe time complexity is no longer O(M * N);\\nInstead, one cell cause 2 copies of neighbors, and then 4 copies of neighbors of neighbors ...\\n\\nSo as long as neighbors are pushed into queue, they should be set to \\'0\\' immediately."
                    },
                    {
                        "username": "aparr487",
                        "content": "Thanks! This was exactly my problem (flooding the land cell after dequeuing, rather than when enqueuing)."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan you please explain more the testcases and what exactly island means? thanks"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/30e6adfa-133f-4607-ba65-521d0e774b34_1643961955.1657922.png)\\n\\n ![image](https://assets.leetcode.com/users/images/8f49d0cb-605d-4549-8546-b6ad7fd05f7a_1643964600.5265105.png)\\n"
                    },
                    {
                        "username": "david120",
                        "content": "This is probably an old problem and not worth changing, but it makes little sense to not have the elements of `grid` be integers.  I was scratching my head at why what should have been a very simple solution was not working until I noticed the quotes on the 1s and 0s.  I suppose this is what I get for using python, which allows comparison between `1` and `\\'1\\'`."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Same happened with me also"
                    },
                    {
                        "username": "chaos28",
                        "content": "When using DFS to solve, it take O(m * n) to iterate through the matrix, but in the recursion dfs function, it also need to iterate over the matrix , so does it mean that the overall time complexity turn out to be O(m * n) * O(m * n)?"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "Why is the time complexity of both DFS and BFS O(m * n) ? I thought it would be same as path finding algorithm, as we traverse 4 ways (up, down, left, right) it is O(4^ (m + n)).\\n\\nCan anyone explain this? I do not want to get this wrong at interview, hence asking for you analysis."
                    },
                    {
                        "username": "nambrose",
                        "content": "[@sidharthgurbani](/sidharthgurbani) What about the case where the entire grid is 1\\'s, we would have to go over each spot twice (the dfs of the entire grid, and our double for loop)"
                    },
                    {
                        "username": "sidharthgurbani",
                        "content": "It is because during every DFS, you change the \"1\" to \"0\". Thereby eliminating the need for running DFS on it again. So in short you would go over each element only once"
                    }
                ]
            },
            {
                "id": 1568315,
                "content": [
                    {
                        "username": "MarkMarcel",
                        "content": "My challenge with solving this problem was getting the definition of an island. What I thought an island was, is a 1 surrounded by 0\\'s either on left and right or top and bottom. Like in image, my definition gave the 2 islands circled in example 1.\\n![image](https://assets.leetcode.com/users/images/0cadaf5c-858d-4cfd-91e8-27427e5d9d01_1649931304.8787706.png)\\n\\nAfter getting my test case wrong, I went through the discussions and based on solutions I realised the question meant an island is a string of 1s like shown in the images below\\n![image](https://assets.leetcode.com/users/images/e6a18482-7542-421a-bd27-cf79e44618e5_1649932030.3147244.png)\\n![image](https://assets.leetcode.com/users/images/b6938d3b-26d7-45d9-88a8-e4956b0ed10a_1649932030.3330166.png)\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "Why is \\'1\\' and \\'0\\' chars? Just to irritate people?"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@sanidhyas3s](/sanidhyas3s) Same lol. My code 100% worked after I changed it from a number to char "
                    },
                    {
                        "username": "sanidhyas3s",
                        "content": "[@nemanjac](/nemanjac) They could\\'ve kept it a char and let it have a numerical value of 0 or 1 instead of \\'0\\' and \\'1\\'. Can\\'t believe I wasted like 10 minutes just figuring out that I had 1 instead of \\'1\\'."
                    },
                    {
                        "username": "lucasan2300",
                        "content": "would you think that, it doesn't matter, but It will be to develop some technique for change it, or handle... please smile!"
                    },
                    {
                        "username": "avyayk",
                        "content": "[@nemanjac](/nemanjac) A bit (1/0) takes up one bit and also achieves the goal :)"
                    },
                    {
                        "username": "Msey",
                        "content": "[@mcthouacbb](/mcthouacbb) it teaches us to be attentive"
                    },
                    {
                        "username": "nemanjac",
                        "content": "Perhaps because a char takes up 2 bytes, where as an int takes up 4."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "Basically. Spent a good 10-15 minutes wondering why my conditions kept miscomparing...Take it as a lesson to read the inputs clearly lol."
                    },
                    {
                        "username": "close27",
                        "content": "lol..agree"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "[@Zephromonia](/Zephromonia) same :|"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Leetcode likes to do a little bit of trolling"
                    },
                    {
                        "username": "Zephromonia",
                        "content": "Quite annoying. Was using not boolean operator for a while."
                    },
                    {
                        "username": "uwswe",
                        "content": "Looks like quite a few people labled their code as a BFS solution, when it\\'s actually DFS. And what\\'s worse is that you\\'re being praised for an incorrect solutiuon. Just because leetcode accepts it, doesn\\'t mean its correct.\\n\\nIf you don\\'t know the difference, then you should read the leetcode chapters on BFS, and DFS. The problem clearly states \"Queue and BFS\", and many people didn\\'t bother to use a queue at all. While this problem can be solved recursively (i.e. DFS), that\\'s not the solution we were asked to provide. The main difference between BFS and DFS is the order you visit the nodes. BFS uses a Queue to visit the closest nodes first, while DFS pretty much skips some nodes next door and follows the path until it reaches a deadend. \\n\\nWhat if the one node you were looking for was the 2nd neighbor, and you picked the first one and followed the path? \\n\\nA better question is, what are you going to do when your interviewer tells you that your recursive solution overflowed the call stack, and you need to improve your solution? Yeah you could implement a Stack yourself, and not use the call stack. But then what if your interviewer really wants the best solution possible, which should be BFS, but you give them your DFS solution?\\n\\nThere\\'s a lot of people who use leetcode to learn how to code, and understand data structures. Praising incorrect solutions is stumping the grow of future engineers. Also, if you want to proudly share your solution, please provide properly formatted code with descriptive variable names - no one wants to break out pen and paper to dissect your logic.\\n\\n"
                    },
                    {
                        "username": "jeehaytch",
                        "content": "My solution is DFS (using a stack) and I beat 96 to 99%"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "1. You\\'re adding constraints not present in the problem statement. The problem statement leaves it to the solver to select a traversal method. \\n\\n2. We\\'re not looking for a specific node. DFS and BFS are identical in efficiency for this problem.\\n\\n3. BFS isn\\'t \\'the best possible\\' and I\\'d tell the interviewer that. The call stack would never \\'overflow\\' because you have at most m*n calls. This is the same space complexity as BFS. \\n\\n4. Don\\'t use leetcode to learn how to code. Code written for leetcode problems sacrifices readability for optimization. Use leetcode to learn how to do technical interviews. Learn how to program from books, language docs, courses.\\n\\n5. You probably meant \\'stunts\\' not \\'stumps\\'. Forgivable as I assume you\\'re ESL, but the condescending nature of your post weighs against my typical charity.\\n\\n6. If you don\\'t understand a solution you should \\'dissect\\' the logic. How else do you actually learn? \\n\\nI\\'m awed by the irony of you lambasting people for \\'praising\\' \\'incorrect\\' solutions in post where you ignorantly condescend with inane drivel in every paragraph.\\n\\nYou are both incorrect and arrogant. You\\'re errorgant. \\n\\nIt\\'s an off-putting character flaw and will probably harm you more in interviews (and in life) than bombing a technical round. "
                    },
                    {
                        "username": "klami",
                        "content": "the problem is also listed under \"Stack and DFS\" so I think either is okay"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 But as of me , I am more comfortable at using bfs instead of dfs."
                    },
                    {
                        "username": "roundlet",
                        "content": "I just encountered this question in an interview, and I have no idea about how to handle this efficiently. Could anyone provides any hints?"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "we can solve in n**2 using BFS traversal. please have look on solution at  \\nhttps://leetcode.com/problems/number-of-islands/submissions/993397265/"
                    },
                    {
                        "username": "TeaTrey",
                        "content": "[@lumpychum](/lumpychum) I used visited, but overwriting with \\'0\\' is pretty cool. Thanks"
                    },
                    {
                        "username": "math_pi",
                        "content": "It is a standard grid problem, you can use DFS and vector of directions."
                    },
                    {
                        "username": "lumpychum",
                        "content": "Essentially you want to traverse the matrix until you find a 1. Once you locate one (no pun intended) you essentially use flood fill to recursively \"mark\" any connected 1s (the rest of the island) by replacing them with zeros. If you do not want to mutate the given matrix, you can use a visited matrix."
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I have encountered this problem. I want to share my findings in case someone faces this one as well.\\n\\nBefore the start of coding, I thought the condition that one cell being inspected more than once is not a great issue because the duplicate cells are set to \\'0\\' anyway. However, that was WRONG. Because, before the cell is set to \\'0\\', it has already been pushed into queue by its neighbors.\\nThe time complexity is no longer O(M * N);\\nInstead, one cell cause 2 copies of neighbors, and then 4 copies of neighbors of neighbors ...\\n\\nSo as long as neighbors are pushed into queue, they should be set to \\'0\\' immediately."
                    },
                    {
                        "username": "aparr487",
                        "content": "Thanks! This was exactly my problem (flooding the land cell after dequeuing, rather than when enqueuing)."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan you please explain more the testcases and what exactly island means? thanks"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/30e6adfa-133f-4607-ba65-521d0e774b34_1643961955.1657922.png)\\n\\n ![image](https://assets.leetcode.com/users/images/8f49d0cb-605d-4549-8546-b6ad7fd05f7a_1643964600.5265105.png)\\n"
                    },
                    {
                        "username": "david120",
                        "content": "This is probably an old problem and not worth changing, but it makes little sense to not have the elements of `grid` be integers.  I was scratching my head at why what should have been a very simple solution was not working until I noticed the quotes on the 1s and 0s.  I suppose this is what I get for using python, which allows comparison between `1` and `\\'1\\'`."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Same happened with me also"
                    },
                    {
                        "username": "chaos28",
                        "content": "When using DFS to solve, it take O(m * n) to iterate through the matrix, but in the recursion dfs function, it also need to iterate over the matrix , so does it mean that the overall time complexity turn out to be O(m * n) * O(m * n)?"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "Why is the time complexity of both DFS and BFS O(m * n) ? I thought it would be same as path finding algorithm, as we traverse 4 ways (up, down, left, right) it is O(4^ (m + n)).\\n\\nCan anyone explain this? I do not want to get this wrong at interview, hence asking for you analysis."
                    },
                    {
                        "username": "nambrose",
                        "content": "[@sidharthgurbani](/sidharthgurbani) What about the case where the entire grid is 1\\'s, we would have to go over each spot twice (the dfs of the entire grid, and our double for loop)"
                    },
                    {
                        "username": "sidharthgurbani",
                        "content": "It is because during every DFS, you change the \"1\" to \"0\". Thereby eliminating the need for running DFS on it again. So in short you would go over each element only once"
                    }
                ]
            },
            {
                "id": 1566766,
                "content": [
                    {
                        "username": "MarkMarcel",
                        "content": "My challenge with solving this problem was getting the definition of an island. What I thought an island was, is a 1 surrounded by 0\\'s either on left and right or top and bottom. Like in image, my definition gave the 2 islands circled in example 1.\\n![image](https://assets.leetcode.com/users/images/0cadaf5c-858d-4cfd-91e8-27427e5d9d01_1649931304.8787706.png)\\n\\nAfter getting my test case wrong, I went through the discussions and based on solutions I realised the question meant an island is a string of 1s like shown in the images below\\n![image](https://assets.leetcode.com/users/images/e6a18482-7542-421a-bd27-cf79e44618e5_1649932030.3147244.png)\\n![image](https://assets.leetcode.com/users/images/b6938d3b-26d7-45d9-88a8-e4956b0ed10a_1649932030.3330166.png)\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "Why is \\'1\\' and \\'0\\' chars? Just to irritate people?"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@sanidhyas3s](/sanidhyas3s) Same lol. My code 100% worked after I changed it from a number to char "
                    },
                    {
                        "username": "sanidhyas3s",
                        "content": "[@nemanjac](/nemanjac) They could\\'ve kept it a char and let it have a numerical value of 0 or 1 instead of \\'0\\' and \\'1\\'. Can\\'t believe I wasted like 10 minutes just figuring out that I had 1 instead of \\'1\\'."
                    },
                    {
                        "username": "lucasan2300",
                        "content": "would you think that, it doesn't matter, but It will be to develop some technique for change it, or handle... please smile!"
                    },
                    {
                        "username": "avyayk",
                        "content": "[@nemanjac](/nemanjac) A bit (1/0) takes up one bit and also achieves the goal :)"
                    },
                    {
                        "username": "Msey",
                        "content": "[@mcthouacbb](/mcthouacbb) it teaches us to be attentive"
                    },
                    {
                        "username": "nemanjac",
                        "content": "Perhaps because a char takes up 2 bytes, where as an int takes up 4."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "Basically. Spent a good 10-15 minutes wondering why my conditions kept miscomparing...Take it as a lesson to read the inputs clearly lol."
                    },
                    {
                        "username": "close27",
                        "content": "lol..agree"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "[@Zephromonia](/Zephromonia) same :|"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Leetcode likes to do a little bit of trolling"
                    },
                    {
                        "username": "Zephromonia",
                        "content": "Quite annoying. Was using not boolean operator for a while."
                    },
                    {
                        "username": "uwswe",
                        "content": "Looks like quite a few people labled their code as a BFS solution, when it\\'s actually DFS. And what\\'s worse is that you\\'re being praised for an incorrect solutiuon. Just because leetcode accepts it, doesn\\'t mean its correct.\\n\\nIf you don\\'t know the difference, then you should read the leetcode chapters on BFS, and DFS. The problem clearly states \"Queue and BFS\", and many people didn\\'t bother to use a queue at all. While this problem can be solved recursively (i.e. DFS), that\\'s not the solution we were asked to provide. The main difference between BFS and DFS is the order you visit the nodes. BFS uses a Queue to visit the closest nodes first, while DFS pretty much skips some nodes next door and follows the path until it reaches a deadend. \\n\\nWhat if the one node you were looking for was the 2nd neighbor, and you picked the first one and followed the path? \\n\\nA better question is, what are you going to do when your interviewer tells you that your recursive solution overflowed the call stack, and you need to improve your solution? Yeah you could implement a Stack yourself, and not use the call stack. But then what if your interviewer really wants the best solution possible, which should be BFS, but you give them your DFS solution?\\n\\nThere\\'s a lot of people who use leetcode to learn how to code, and understand data structures. Praising incorrect solutions is stumping the grow of future engineers. Also, if you want to proudly share your solution, please provide properly formatted code with descriptive variable names - no one wants to break out pen and paper to dissect your logic.\\n\\n"
                    },
                    {
                        "username": "jeehaytch",
                        "content": "My solution is DFS (using a stack) and I beat 96 to 99%"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "1. You\\'re adding constraints not present in the problem statement. The problem statement leaves it to the solver to select a traversal method. \\n\\n2. We\\'re not looking for a specific node. DFS and BFS are identical in efficiency for this problem.\\n\\n3. BFS isn\\'t \\'the best possible\\' and I\\'d tell the interviewer that. The call stack would never \\'overflow\\' because you have at most m*n calls. This is the same space complexity as BFS. \\n\\n4. Don\\'t use leetcode to learn how to code. Code written for leetcode problems sacrifices readability for optimization. Use leetcode to learn how to do technical interviews. Learn how to program from books, language docs, courses.\\n\\n5. You probably meant \\'stunts\\' not \\'stumps\\'. Forgivable as I assume you\\'re ESL, but the condescending nature of your post weighs against my typical charity.\\n\\n6. If you don\\'t understand a solution you should \\'dissect\\' the logic. How else do you actually learn? \\n\\nI\\'m awed by the irony of you lambasting people for \\'praising\\' \\'incorrect\\' solutions in post where you ignorantly condescend with inane drivel in every paragraph.\\n\\nYou are both incorrect and arrogant. You\\'re errorgant. \\n\\nIt\\'s an off-putting character flaw and will probably harm you more in interviews (and in life) than bombing a technical round. "
                    },
                    {
                        "username": "klami",
                        "content": "the problem is also listed under \"Stack and DFS\" so I think either is okay"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 But as of me , I am more comfortable at using bfs instead of dfs."
                    },
                    {
                        "username": "roundlet",
                        "content": "I just encountered this question in an interview, and I have no idea about how to handle this efficiently. Could anyone provides any hints?"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "we can solve in n**2 using BFS traversal. please have look on solution at  \\nhttps://leetcode.com/problems/number-of-islands/submissions/993397265/"
                    },
                    {
                        "username": "TeaTrey",
                        "content": "[@lumpychum](/lumpychum) I used visited, but overwriting with \\'0\\' is pretty cool. Thanks"
                    },
                    {
                        "username": "math_pi",
                        "content": "It is a standard grid problem, you can use DFS and vector of directions."
                    },
                    {
                        "username": "lumpychum",
                        "content": "Essentially you want to traverse the matrix until you find a 1. Once you locate one (no pun intended) you essentially use flood fill to recursively \"mark\" any connected 1s (the rest of the island) by replacing them with zeros. If you do not want to mutate the given matrix, you can use a visited matrix."
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I have encountered this problem. I want to share my findings in case someone faces this one as well.\\n\\nBefore the start of coding, I thought the condition that one cell being inspected more than once is not a great issue because the duplicate cells are set to \\'0\\' anyway. However, that was WRONG. Because, before the cell is set to \\'0\\', it has already been pushed into queue by its neighbors.\\nThe time complexity is no longer O(M * N);\\nInstead, one cell cause 2 copies of neighbors, and then 4 copies of neighbors of neighbors ...\\n\\nSo as long as neighbors are pushed into queue, they should be set to \\'0\\' immediately."
                    },
                    {
                        "username": "aparr487",
                        "content": "Thanks! This was exactly my problem (flooding the land cell after dequeuing, rather than when enqueuing)."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan you please explain more the testcases and what exactly island means? thanks"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/30e6adfa-133f-4607-ba65-521d0e774b34_1643961955.1657922.png)\\n\\n ![image](https://assets.leetcode.com/users/images/8f49d0cb-605d-4549-8546-b6ad7fd05f7a_1643964600.5265105.png)\\n"
                    },
                    {
                        "username": "david120",
                        "content": "This is probably an old problem and not worth changing, but it makes little sense to not have the elements of `grid` be integers.  I was scratching my head at why what should have been a very simple solution was not working until I noticed the quotes on the 1s and 0s.  I suppose this is what I get for using python, which allows comparison between `1` and `\\'1\\'`."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Same happened with me also"
                    },
                    {
                        "username": "chaos28",
                        "content": "When using DFS to solve, it take O(m * n) to iterate through the matrix, but in the recursion dfs function, it also need to iterate over the matrix , so does it mean that the overall time complexity turn out to be O(m * n) * O(m * n)?"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "Why is the time complexity of both DFS and BFS O(m * n) ? I thought it would be same as path finding algorithm, as we traverse 4 ways (up, down, left, right) it is O(4^ (m + n)).\\n\\nCan anyone explain this? I do not want to get this wrong at interview, hence asking for you analysis."
                    },
                    {
                        "username": "nambrose",
                        "content": "[@sidharthgurbani](/sidharthgurbani) What about the case where the entire grid is 1\\'s, we would have to go over each spot twice (the dfs of the entire grid, and our double for loop)"
                    },
                    {
                        "username": "sidharthgurbani",
                        "content": "It is because during every DFS, you change the \"1\" to \"0\". Thereby eliminating the need for running DFS on it again. So in short you would go over each element only once"
                    }
                ]
            },
            {
                "id": 1566334,
                "content": [
                    {
                        "username": "MarkMarcel",
                        "content": "My challenge with solving this problem was getting the definition of an island. What I thought an island was, is a 1 surrounded by 0\\'s either on left and right or top and bottom. Like in image, my definition gave the 2 islands circled in example 1.\\n![image](https://assets.leetcode.com/users/images/0cadaf5c-858d-4cfd-91e8-27427e5d9d01_1649931304.8787706.png)\\n\\nAfter getting my test case wrong, I went through the discussions and based on solutions I realised the question meant an island is a string of 1s like shown in the images below\\n![image](https://assets.leetcode.com/users/images/e6a18482-7542-421a-bd27-cf79e44618e5_1649932030.3147244.png)\\n![image](https://assets.leetcode.com/users/images/b6938d3b-26d7-45d9-88a8-e4956b0ed10a_1649932030.3330166.png)\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "vimalkrpal",
                        "content": "Why is \\'1\\' and \\'0\\' chars? Just to irritate people?"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@sanidhyas3s](/sanidhyas3s) Same lol. My code 100% worked after I changed it from a number to char "
                    },
                    {
                        "username": "sanidhyas3s",
                        "content": "[@nemanjac](/nemanjac) They could\\'ve kept it a char and let it have a numerical value of 0 or 1 instead of \\'0\\' and \\'1\\'. Can\\'t believe I wasted like 10 minutes just figuring out that I had 1 instead of \\'1\\'."
                    },
                    {
                        "username": "lucasan2300",
                        "content": "would you think that, it doesn't matter, but It will be to develop some technique for change it, or handle... please smile!"
                    },
                    {
                        "username": "avyayk",
                        "content": "[@nemanjac](/nemanjac) A bit (1/0) takes up one bit and also achieves the goal :)"
                    },
                    {
                        "username": "Msey",
                        "content": "[@mcthouacbb](/mcthouacbb) it teaches us to be attentive"
                    },
                    {
                        "username": "nemanjac",
                        "content": "Perhaps because a char takes up 2 bytes, where as an int takes up 4."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "Basically. Spent a good 10-15 minutes wondering why my conditions kept miscomparing...Take it as a lesson to read the inputs clearly lol."
                    },
                    {
                        "username": "close27",
                        "content": "lol..agree"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "[@Zephromonia](/Zephromonia) same :|"
                    },
                    {
                        "username": "mcthouacbb",
                        "content": "Leetcode likes to do a little bit of trolling"
                    },
                    {
                        "username": "Zephromonia",
                        "content": "Quite annoying. Was using not boolean operator for a while."
                    },
                    {
                        "username": "uwswe",
                        "content": "Looks like quite a few people labled their code as a BFS solution, when it\\'s actually DFS. And what\\'s worse is that you\\'re being praised for an incorrect solutiuon. Just because leetcode accepts it, doesn\\'t mean its correct.\\n\\nIf you don\\'t know the difference, then you should read the leetcode chapters on BFS, and DFS. The problem clearly states \"Queue and BFS\", and many people didn\\'t bother to use a queue at all. While this problem can be solved recursively (i.e. DFS), that\\'s not the solution we were asked to provide. The main difference between BFS and DFS is the order you visit the nodes. BFS uses a Queue to visit the closest nodes first, while DFS pretty much skips some nodes next door and follows the path until it reaches a deadend. \\n\\nWhat if the one node you were looking for was the 2nd neighbor, and you picked the first one and followed the path? \\n\\nA better question is, what are you going to do when your interviewer tells you that your recursive solution overflowed the call stack, and you need to improve your solution? Yeah you could implement a Stack yourself, and not use the call stack. But then what if your interviewer really wants the best solution possible, which should be BFS, but you give them your DFS solution?\\n\\nThere\\'s a lot of people who use leetcode to learn how to code, and understand data structures. Praising incorrect solutions is stumping the grow of future engineers. Also, if you want to proudly share your solution, please provide properly formatted code with descriptive variable names - no one wants to break out pen and paper to dissect your logic.\\n\\n"
                    },
                    {
                        "username": "jeehaytch",
                        "content": "My solution is DFS (using a stack) and I beat 96 to 99%"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "1. You\\'re adding constraints not present in the problem statement. The problem statement leaves it to the solver to select a traversal method. \\n\\n2. We\\'re not looking for a specific node. DFS and BFS are identical in efficiency for this problem.\\n\\n3. BFS isn\\'t \\'the best possible\\' and I\\'d tell the interviewer that. The call stack would never \\'overflow\\' because you have at most m*n calls. This is the same space complexity as BFS. \\n\\n4. Don\\'t use leetcode to learn how to code. Code written for leetcode problems sacrifices readability for optimization. Use leetcode to learn how to do technical interviews. Learn how to program from books, language docs, courses.\\n\\n5. You probably meant \\'stunts\\' not \\'stumps\\'. Forgivable as I assume you\\'re ESL, but the condescending nature of your post weighs against my typical charity.\\n\\n6. If you don\\'t understand a solution you should \\'dissect\\' the logic. How else do you actually learn? \\n\\nI\\'m awed by the irony of you lambasting people for \\'praising\\' \\'incorrect\\' solutions in post where you ignorantly condescend with inane drivel in every paragraph.\\n\\nYou are both incorrect and arrogant. You\\'re errorgant. \\n\\nIt\\'s an off-putting character flaw and will probably harm you more in interviews (and in life) than bombing a technical round. "
                    },
                    {
                        "username": "klami",
                        "content": "the problem is also listed under \"Stack and DFS\" so I think either is okay"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 But as of me , I am more comfortable at using bfs instead of dfs."
                    },
                    {
                        "username": "roundlet",
                        "content": "I just encountered this question in an interview, and I have no idea about how to handle this efficiently. Could anyone provides any hints?"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "we can solve in n**2 using BFS traversal. please have look on solution at  \\nhttps://leetcode.com/problems/number-of-islands/submissions/993397265/"
                    },
                    {
                        "username": "TeaTrey",
                        "content": "[@lumpychum](/lumpychum) I used visited, but overwriting with \\'0\\' is pretty cool. Thanks"
                    },
                    {
                        "username": "math_pi",
                        "content": "It is a standard grid problem, you can use DFS and vector of directions."
                    },
                    {
                        "username": "lumpychum",
                        "content": "Essentially you want to traverse the matrix until you find a 1. Once you locate one (no pun intended) you essentially use flood fill to recursively \"mark\" any connected 1s (the rest of the island) by replacing them with zeros. If you do not want to mutate the given matrix, you can use a visited matrix."
                    },
                    {
                        "username": "cool_leetcoder",
                        "content": "I have encountered this problem. I want to share my findings in case someone faces this one as well.\\n\\nBefore the start of coding, I thought the condition that one cell being inspected more than once is not a great issue because the duplicate cells are set to \\'0\\' anyway. However, that was WRONG. Because, before the cell is set to \\'0\\', it has already been pushed into queue by its neighbors.\\nThe time complexity is no longer O(M * N);\\nInstead, one cell cause 2 copies of neighbors, and then 4 copies of neighbors of neighbors ...\\n\\nSo as long as neighbors are pushed into queue, they should be set to \\'0\\' immediately."
                    },
                    {
                        "username": "aparr487",
                        "content": "Thanks! This was exactly my problem (flooding the land cell after dequeuing, rather than when enqueuing)."
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi\\ncan you please explain more the testcases and what exactly island means? thanks"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/30e6adfa-133f-4607-ba65-521d0e774b34_1643961955.1657922.png)\\n\\n ![image](https://assets.leetcode.com/users/images/8f49d0cb-605d-4549-8546-b6ad7fd05f7a_1643964600.5265105.png)\\n"
                    },
                    {
                        "username": "david120",
                        "content": "This is probably an old problem and not worth changing, but it makes little sense to not have the elements of `grid` be integers.  I was scratching my head at why what should have been a very simple solution was not working until I noticed the quotes on the 1s and 0s.  I suppose this is what I get for using python, which allows comparison between `1` and `\\'1\\'`."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Same happened with me also"
                    },
                    {
                        "username": "chaos28",
                        "content": "When using DFS to solve, it take O(m * n) to iterate through the matrix, but in the recursion dfs function, it also need to iterate over the matrix , so does it mean that the overall time complexity turn out to be O(m * n) * O(m * n)?"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "Why is the time complexity of both DFS and BFS O(m * n) ? I thought it would be same as path finding algorithm, as we traverse 4 ways (up, down, left, right) it is O(4^ (m + n)).\\n\\nCan anyone explain this? I do not want to get this wrong at interview, hence asking for you analysis."
                    },
                    {
                        "username": "nambrose",
                        "content": "[@sidharthgurbani](/sidharthgurbani) What about the case where the entire grid is 1\\'s, we would have to go over each spot twice (the dfs of the entire grid, and our double for loop)"
                    },
                    {
                        "username": "sidharthgurbani",
                        "content": "It is because during every DFS, you change the \"1\" to \"0\". Thereby eliminating the need for running DFS on it again. So in short you would go over each element only once"
                    }
                ]
            },
            {
                "id": 1575348,
                "content": [
                    {
                        "username": "dsa1995",
                        "content": "This problem is equivalent to finding out the number of connected components in a graph."
                    },
                    {
                        "username": "mkl75now",
                        "content": "Can someone please explain why the space complexity for bfs approach is O(min(M,N)? I am not sure why we are going with the min value as the maximum queue size in worst case?\\n\\nThis is what it says in the solution:\\nSpace complexity : O(min(M, N)) because in worst case where the grid is filled with lands, the size of queue can grow up to min(M,N)."
                    },
                    {
                        "username": "homehehe123",
                        "content": "is there some conditons  I do not consider"
                    },
                    {
                        "username": "Kyochi",
                        "content": "Asked in an interview: What if we have an array with 15 dimensions ? how do you handle that case to solve the problem ? "
                    },
                    {
                        "username": "akmuir",
                        "content": "you iterate through those dimensions the same way you\\'d iterate through these 2 making sure not to go over already iterated indices."
                    },
                    {
                        "username": "madpoly",
                        "content": "if you have 15 dimensions, only god can help you"
                    },
                    {
                        "username": "kotlavaibhav",
                        "content": "Why is DFS faster on this problem than BFS??? What is the run time complexity for this?"
                    },
                    {
                        "username": "julenn",
                        "content": "Who else got caught by the numbers in string format?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<<--please vote\\n\\n![image](https://assets.leetcode.com/users/images/ef5c4a7c-cd9f-4ff6-ae81-b756620c5aa2_1646311209.0542142.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/3d29b1aa-c229-430f-93e1-a5a80e266d6d_1646311215.0290844.png)\\n"
                    },
                    {
                        "username": "The_Finder",
                        "content": "![image](https://assets.leetcode.com/users/images/9adf9a1b-fe85-4bfc-944e-d61d1f24a748_1641458964.058156.png)\\n"
                    },
                    {
                        "username": "user2575O",
                        "content": "I encountered a similar question in Amazon OA today"
                    },
                    {
                        "username": "Sid_2027",
                        "content": "In this problem, we are given a grid where each cell can be either 0 or 1. We need to count the number of islands in the grid, where an island is defined as a group of connected 1s.\\n\\nTo solve this, we can iterate through the grid and whenever we encounter a 1, we perform a Breadth-First Search (BFS) traversal to visit all the connected cells. During the traversal, we mark each visited cell as 0 to avoid counting it multiple times.\\n\\nBy applying BFS on each unvisited 1 cell, we can identify and count all the islands in the grid. The count of islands represents the solution to the problem.\\n\\nSummary: The approach involves identifying connected components in the grid, where each component represents an island. By treating the 1s as nodes in a graph, we can use a BFS traversal to visit each node and increment a count variable to track the number of islands. The traversal ensures that each connected node is visited, effectively counting the components."
                    }
                ]
            },
            {
                "id": 1568098,
                "content": [
                    {
                        "username": "dsa1995",
                        "content": "This problem is equivalent to finding out the number of connected components in a graph."
                    },
                    {
                        "username": "mkl75now",
                        "content": "Can someone please explain why the space complexity for bfs approach is O(min(M,N)? I am not sure why we are going with the min value as the maximum queue size in worst case?\\n\\nThis is what it says in the solution:\\nSpace complexity : O(min(M, N)) because in worst case where the grid is filled with lands, the size of queue can grow up to min(M,N)."
                    },
                    {
                        "username": "homehehe123",
                        "content": "is there some conditons  I do not consider"
                    },
                    {
                        "username": "Kyochi",
                        "content": "Asked in an interview: What if we have an array with 15 dimensions ? how do you handle that case to solve the problem ? "
                    },
                    {
                        "username": "akmuir",
                        "content": "you iterate through those dimensions the same way you\\'d iterate through these 2 making sure not to go over already iterated indices."
                    },
                    {
                        "username": "madpoly",
                        "content": "if you have 15 dimensions, only god can help you"
                    },
                    {
                        "username": "kotlavaibhav",
                        "content": "Why is DFS faster on this problem than BFS??? What is the run time complexity for this?"
                    },
                    {
                        "username": "julenn",
                        "content": "Who else got caught by the numbers in string format?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<<--please vote\\n\\n![image](https://assets.leetcode.com/users/images/ef5c4a7c-cd9f-4ff6-ae81-b756620c5aa2_1646311209.0542142.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/3d29b1aa-c229-430f-93e1-a5a80e266d6d_1646311215.0290844.png)\\n"
                    },
                    {
                        "username": "The_Finder",
                        "content": "![image](https://assets.leetcode.com/users/images/9adf9a1b-fe85-4bfc-944e-d61d1f24a748_1641458964.058156.png)\\n"
                    },
                    {
                        "username": "user2575O",
                        "content": "I encountered a similar question in Amazon OA today"
                    },
                    {
                        "username": "Sid_2027",
                        "content": "In this problem, we are given a grid where each cell can be either 0 or 1. We need to count the number of islands in the grid, where an island is defined as a group of connected 1s.\\n\\nTo solve this, we can iterate through the grid and whenever we encounter a 1, we perform a Breadth-First Search (BFS) traversal to visit all the connected cells. During the traversal, we mark each visited cell as 0 to avoid counting it multiple times.\\n\\nBy applying BFS on each unvisited 1 cell, we can identify and count all the islands in the grid. The count of islands represents the solution to the problem.\\n\\nSummary: The approach involves identifying connected components in the grid, where each component represents an island. By treating the 1s as nodes in a graph, we can use a BFS traversal to visit each node and increment a count variable to track the number of islands. The traversal ensures that each connected node is visited, effectively counting the components."
                    }
                ]
            },
            {
                "id": 1567359,
                "content": [
                    {
                        "username": "dsa1995",
                        "content": "This problem is equivalent to finding out the number of connected components in a graph."
                    },
                    {
                        "username": "mkl75now",
                        "content": "Can someone please explain why the space complexity for bfs approach is O(min(M,N)? I am not sure why we are going with the min value as the maximum queue size in worst case?\\n\\nThis is what it says in the solution:\\nSpace complexity : O(min(M, N)) because in worst case where the grid is filled with lands, the size of queue can grow up to min(M,N)."
                    },
                    {
                        "username": "homehehe123",
                        "content": "is there some conditons  I do not consider"
                    },
                    {
                        "username": "Kyochi",
                        "content": "Asked in an interview: What if we have an array with 15 dimensions ? how do you handle that case to solve the problem ? "
                    },
                    {
                        "username": "akmuir",
                        "content": "you iterate through those dimensions the same way you\\'d iterate through these 2 making sure not to go over already iterated indices."
                    },
                    {
                        "username": "madpoly",
                        "content": "if you have 15 dimensions, only god can help you"
                    },
                    {
                        "username": "kotlavaibhav",
                        "content": "Why is DFS faster on this problem than BFS??? What is the run time complexity for this?"
                    },
                    {
                        "username": "julenn",
                        "content": "Who else got caught by the numbers in string format?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<<--please vote\\n\\n![image](https://assets.leetcode.com/users/images/ef5c4a7c-cd9f-4ff6-ae81-b756620c5aa2_1646311209.0542142.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/3d29b1aa-c229-430f-93e1-a5a80e266d6d_1646311215.0290844.png)\\n"
                    },
                    {
                        "username": "The_Finder",
                        "content": "![image](https://assets.leetcode.com/users/images/9adf9a1b-fe85-4bfc-944e-d61d1f24a748_1641458964.058156.png)\\n"
                    },
                    {
                        "username": "user2575O",
                        "content": "I encountered a similar question in Amazon OA today"
                    },
                    {
                        "username": "Sid_2027",
                        "content": "In this problem, we are given a grid where each cell can be either 0 or 1. We need to count the number of islands in the grid, where an island is defined as a group of connected 1s.\\n\\nTo solve this, we can iterate through the grid and whenever we encounter a 1, we perform a Breadth-First Search (BFS) traversal to visit all the connected cells. During the traversal, we mark each visited cell as 0 to avoid counting it multiple times.\\n\\nBy applying BFS on each unvisited 1 cell, we can identify and count all the islands in the grid. The count of islands represents the solution to the problem.\\n\\nSummary: The approach involves identifying connected components in the grid, where each component represents an island. By treating the 1s as nodes in a graph, we can use a BFS traversal to visit each node and increment a count variable to track the number of islands. The traversal ensures that each connected node is visited, effectively counting the components."
                    }
                ]
            },
            {
                "id": 1569327,
                "content": [
                    {
                        "username": "dsa1995",
                        "content": "This problem is equivalent to finding out the number of connected components in a graph."
                    },
                    {
                        "username": "mkl75now",
                        "content": "Can someone please explain why the space complexity for bfs approach is O(min(M,N)? I am not sure why we are going with the min value as the maximum queue size in worst case?\\n\\nThis is what it says in the solution:\\nSpace complexity : O(min(M, N)) because in worst case where the grid is filled with lands, the size of queue can grow up to min(M,N)."
                    },
                    {
                        "username": "homehehe123",
                        "content": "is there some conditons  I do not consider"
                    },
                    {
                        "username": "Kyochi",
                        "content": "Asked in an interview: What if we have an array with 15 dimensions ? how do you handle that case to solve the problem ? "
                    },
                    {
                        "username": "akmuir",
                        "content": "you iterate through those dimensions the same way you\\'d iterate through these 2 making sure not to go over already iterated indices."
                    },
                    {
                        "username": "madpoly",
                        "content": "if you have 15 dimensions, only god can help you"
                    },
                    {
                        "username": "kotlavaibhav",
                        "content": "Why is DFS faster on this problem than BFS??? What is the run time complexity for this?"
                    },
                    {
                        "username": "julenn",
                        "content": "Who else got caught by the numbers in string format?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<<--please vote\\n\\n![image](https://assets.leetcode.com/users/images/ef5c4a7c-cd9f-4ff6-ae81-b756620c5aa2_1646311209.0542142.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/3d29b1aa-c229-430f-93e1-a5a80e266d6d_1646311215.0290844.png)\\n"
                    },
                    {
                        "username": "The_Finder",
                        "content": "![image](https://assets.leetcode.com/users/images/9adf9a1b-fe85-4bfc-944e-d61d1f24a748_1641458964.058156.png)\\n"
                    },
                    {
                        "username": "user2575O",
                        "content": "I encountered a similar question in Amazon OA today"
                    },
                    {
                        "username": "Sid_2027",
                        "content": "In this problem, we are given a grid where each cell can be either 0 or 1. We need to count the number of islands in the grid, where an island is defined as a group of connected 1s.\\n\\nTo solve this, we can iterate through the grid and whenever we encounter a 1, we perform a Breadth-First Search (BFS) traversal to visit all the connected cells. During the traversal, we mark each visited cell as 0 to avoid counting it multiple times.\\n\\nBy applying BFS on each unvisited 1 cell, we can identify and count all the islands in the grid. The count of islands represents the solution to the problem.\\n\\nSummary: The approach involves identifying connected components in the grid, where each component represents an island. By treating the 1s as nodes in a graph, we can use a BFS traversal to visit each node and increment a count variable to track the number of islands. The traversal ensures that each connected node is visited, effectively counting the components."
                    }
                ]
            },
            {
                "id": 1569018,
                "content": [
                    {
                        "username": "dsa1995",
                        "content": "This problem is equivalent to finding out the number of connected components in a graph."
                    },
                    {
                        "username": "mkl75now",
                        "content": "Can someone please explain why the space complexity for bfs approach is O(min(M,N)? I am not sure why we are going with the min value as the maximum queue size in worst case?\\n\\nThis is what it says in the solution:\\nSpace complexity : O(min(M, N)) because in worst case where the grid is filled with lands, the size of queue can grow up to min(M,N)."
                    },
                    {
                        "username": "homehehe123",
                        "content": "is there some conditons  I do not consider"
                    },
                    {
                        "username": "Kyochi",
                        "content": "Asked in an interview: What if we have an array with 15 dimensions ? how do you handle that case to solve the problem ? "
                    },
                    {
                        "username": "akmuir",
                        "content": "you iterate through those dimensions the same way you\\'d iterate through these 2 making sure not to go over already iterated indices."
                    },
                    {
                        "username": "madpoly",
                        "content": "if you have 15 dimensions, only god can help you"
                    },
                    {
                        "username": "kotlavaibhav",
                        "content": "Why is DFS faster on this problem than BFS??? What is the run time complexity for this?"
                    },
                    {
                        "username": "julenn",
                        "content": "Who else got caught by the numbers in string format?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<<--please vote\\n\\n![image](https://assets.leetcode.com/users/images/ef5c4a7c-cd9f-4ff6-ae81-b756620c5aa2_1646311209.0542142.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/3d29b1aa-c229-430f-93e1-a5a80e266d6d_1646311215.0290844.png)\\n"
                    },
                    {
                        "username": "The_Finder",
                        "content": "![image](https://assets.leetcode.com/users/images/9adf9a1b-fe85-4bfc-944e-d61d1f24a748_1641458964.058156.png)\\n"
                    },
                    {
                        "username": "user2575O",
                        "content": "I encountered a similar question in Amazon OA today"
                    },
                    {
                        "username": "Sid_2027",
                        "content": "In this problem, we are given a grid where each cell can be either 0 or 1. We need to count the number of islands in the grid, where an island is defined as a group of connected 1s.\\n\\nTo solve this, we can iterate through the grid and whenever we encounter a 1, we perform a Breadth-First Search (BFS) traversal to visit all the connected cells. During the traversal, we mark each visited cell as 0 to avoid counting it multiple times.\\n\\nBy applying BFS on each unvisited 1 cell, we can identify and count all the islands in the grid. The count of islands represents the solution to the problem.\\n\\nSummary: The approach involves identifying connected components in the grid, where each component represents an island. By treating the 1s as nodes in a graph, we can use a BFS traversal to visit each node and increment a count variable to track the number of islands. The traversal ensures that each connected node is visited, effectively counting the components."
                    }
                ]
            },
            {
                "id": 1799950,
                "content": [
                    {
                        "username": "dsa1995",
                        "content": "This problem is equivalent to finding out the number of connected components in a graph."
                    },
                    {
                        "username": "mkl75now",
                        "content": "Can someone please explain why the space complexity for bfs approach is O(min(M,N)? I am not sure why we are going with the min value as the maximum queue size in worst case?\\n\\nThis is what it says in the solution:\\nSpace complexity : O(min(M, N)) because in worst case where the grid is filled with lands, the size of queue can grow up to min(M,N)."
                    },
                    {
                        "username": "homehehe123",
                        "content": "is there some conditons  I do not consider"
                    },
                    {
                        "username": "Kyochi",
                        "content": "Asked in an interview: What if we have an array with 15 dimensions ? how do you handle that case to solve the problem ? "
                    },
                    {
                        "username": "akmuir",
                        "content": "you iterate through those dimensions the same way you\\'d iterate through these 2 making sure not to go over already iterated indices."
                    },
                    {
                        "username": "madpoly",
                        "content": "if you have 15 dimensions, only god can help you"
                    },
                    {
                        "username": "kotlavaibhav",
                        "content": "Why is DFS faster on this problem than BFS??? What is the run time complexity for this?"
                    },
                    {
                        "username": "julenn",
                        "content": "Who else got caught by the numbers in string format?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<<--please vote\\n\\n![image](https://assets.leetcode.com/users/images/ef5c4a7c-cd9f-4ff6-ae81-b756620c5aa2_1646311209.0542142.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/3d29b1aa-c229-430f-93e1-a5a80e266d6d_1646311215.0290844.png)\\n"
                    },
                    {
                        "username": "The_Finder",
                        "content": "![image](https://assets.leetcode.com/users/images/9adf9a1b-fe85-4bfc-944e-d61d1f24a748_1641458964.058156.png)\\n"
                    },
                    {
                        "username": "user2575O",
                        "content": "I encountered a similar question in Amazon OA today"
                    },
                    {
                        "username": "Sid_2027",
                        "content": "In this problem, we are given a grid where each cell can be either 0 or 1. We need to count the number of islands in the grid, where an island is defined as a group of connected 1s.\\n\\nTo solve this, we can iterate through the grid and whenever we encounter a 1, we perform a Breadth-First Search (BFS) traversal to visit all the connected cells. During the traversal, we mark each visited cell as 0 to avoid counting it multiple times.\\n\\nBy applying BFS on each unvisited 1 cell, we can identify and count all the islands in the grid. The count of islands represents the solution to the problem.\\n\\nSummary: The approach involves identifying connected components in the grid, where each component represents an island. By treating the 1s as nodes in a graph, we can use a BFS traversal to visit each node and increment a count variable to track the number of islands. The traversal ensures that each connected node is visited, effectively counting the components."
                    }
                ]
            },
            {
                "id": 1576473,
                "content": [
                    {
                        "username": "dsa1995",
                        "content": "This problem is equivalent to finding out the number of connected components in a graph."
                    },
                    {
                        "username": "mkl75now",
                        "content": "Can someone please explain why the space complexity for bfs approach is O(min(M,N)? I am not sure why we are going with the min value as the maximum queue size in worst case?\\n\\nThis is what it says in the solution:\\nSpace complexity : O(min(M, N)) because in worst case where the grid is filled with lands, the size of queue can grow up to min(M,N)."
                    },
                    {
                        "username": "homehehe123",
                        "content": "is there some conditons  I do not consider"
                    },
                    {
                        "username": "Kyochi",
                        "content": "Asked in an interview: What if we have an array with 15 dimensions ? how do you handle that case to solve the problem ? "
                    },
                    {
                        "username": "akmuir",
                        "content": "you iterate through those dimensions the same way you\\'d iterate through these 2 making sure not to go over already iterated indices."
                    },
                    {
                        "username": "madpoly",
                        "content": "if you have 15 dimensions, only god can help you"
                    },
                    {
                        "username": "kotlavaibhav",
                        "content": "Why is DFS faster on this problem than BFS??? What is the run time complexity for this?"
                    },
                    {
                        "username": "julenn",
                        "content": "Who else got caught by the numbers in string format?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<<--please vote\\n\\n![image](https://assets.leetcode.com/users/images/ef5c4a7c-cd9f-4ff6-ae81-b756620c5aa2_1646311209.0542142.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/3d29b1aa-c229-430f-93e1-a5a80e266d6d_1646311215.0290844.png)\\n"
                    },
                    {
                        "username": "The_Finder",
                        "content": "![image](https://assets.leetcode.com/users/images/9adf9a1b-fe85-4bfc-944e-d61d1f24a748_1641458964.058156.png)\\n"
                    },
                    {
                        "username": "user2575O",
                        "content": "I encountered a similar question in Amazon OA today"
                    },
                    {
                        "username": "Sid_2027",
                        "content": "In this problem, we are given a grid where each cell can be either 0 or 1. We need to count the number of islands in the grid, where an island is defined as a group of connected 1s.\\n\\nTo solve this, we can iterate through the grid and whenever we encounter a 1, we perform a Breadth-First Search (BFS) traversal to visit all the connected cells. During the traversal, we mark each visited cell as 0 to avoid counting it multiple times.\\n\\nBy applying BFS on each unvisited 1 cell, we can identify and count all the islands in the grid. The count of islands represents the solution to the problem.\\n\\nSummary: The approach involves identifying connected components in the grid, where each component represents an island. By treating the 1s as nodes in a graph, we can use a BFS traversal to visit each node and increment a count variable to track the number of islands. The traversal ensures that each connected node is visited, effectively counting the components."
                    }
                ]
            },
            {
                "id": 1576179,
                "content": [
                    {
                        "username": "dsa1995",
                        "content": "This problem is equivalent to finding out the number of connected components in a graph."
                    },
                    {
                        "username": "mkl75now",
                        "content": "Can someone please explain why the space complexity for bfs approach is O(min(M,N)? I am not sure why we are going with the min value as the maximum queue size in worst case?\\n\\nThis is what it says in the solution:\\nSpace complexity : O(min(M, N)) because in worst case where the grid is filled with lands, the size of queue can grow up to min(M,N)."
                    },
                    {
                        "username": "homehehe123",
                        "content": "is there some conditons  I do not consider"
                    },
                    {
                        "username": "Kyochi",
                        "content": "Asked in an interview: What if we have an array with 15 dimensions ? how do you handle that case to solve the problem ? "
                    },
                    {
                        "username": "akmuir",
                        "content": "you iterate through those dimensions the same way you\\'d iterate through these 2 making sure not to go over already iterated indices."
                    },
                    {
                        "username": "madpoly",
                        "content": "if you have 15 dimensions, only god can help you"
                    },
                    {
                        "username": "kotlavaibhav",
                        "content": "Why is DFS faster on this problem than BFS??? What is the run time complexity for this?"
                    },
                    {
                        "username": "julenn",
                        "content": "Who else got caught by the numbers in string format?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<<--please vote\\n\\n![image](https://assets.leetcode.com/users/images/ef5c4a7c-cd9f-4ff6-ae81-b756620c5aa2_1646311209.0542142.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/3d29b1aa-c229-430f-93e1-a5a80e266d6d_1646311215.0290844.png)\\n"
                    },
                    {
                        "username": "The_Finder",
                        "content": "![image](https://assets.leetcode.com/users/images/9adf9a1b-fe85-4bfc-944e-d61d1f24a748_1641458964.058156.png)\\n"
                    },
                    {
                        "username": "user2575O",
                        "content": "I encountered a similar question in Amazon OA today"
                    },
                    {
                        "username": "Sid_2027",
                        "content": "In this problem, we are given a grid where each cell can be either 0 or 1. We need to count the number of islands in the grid, where an island is defined as a group of connected 1s.\\n\\nTo solve this, we can iterate through the grid and whenever we encounter a 1, we perform a Breadth-First Search (BFS) traversal to visit all the connected cells. During the traversal, we mark each visited cell as 0 to avoid counting it multiple times.\\n\\nBy applying BFS on each unvisited 1 cell, we can identify and count all the islands in the grid. The count of islands represents the solution to the problem.\\n\\nSummary: The approach involves identifying connected components in the grid, where each component represents an island. By treating the 1s as nodes in a graph, we can use a BFS traversal to visit each node and increment a count variable to track the number of islands. The traversal ensures that each connected node is visited, effectively counting the components."
                    }
                ]
            },
            {
                "id": 1570037,
                "content": [
                    {
                        "username": "dsa1995",
                        "content": "This problem is equivalent to finding out the number of connected components in a graph."
                    },
                    {
                        "username": "mkl75now",
                        "content": "Can someone please explain why the space complexity for bfs approach is O(min(M,N)? I am not sure why we are going with the min value as the maximum queue size in worst case?\\n\\nThis is what it says in the solution:\\nSpace complexity : O(min(M, N)) because in worst case where the grid is filled with lands, the size of queue can grow up to min(M,N)."
                    },
                    {
                        "username": "homehehe123",
                        "content": "is there some conditons  I do not consider"
                    },
                    {
                        "username": "Kyochi",
                        "content": "Asked in an interview: What if we have an array with 15 dimensions ? how do you handle that case to solve the problem ? "
                    },
                    {
                        "username": "akmuir",
                        "content": "you iterate through those dimensions the same way you\\'d iterate through these 2 making sure not to go over already iterated indices."
                    },
                    {
                        "username": "madpoly",
                        "content": "if you have 15 dimensions, only god can help you"
                    },
                    {
                        "username": "kotlavaibhav",
                        "content": "Why is DFS faster on this problem than BFS??? What is the run time complexity for this?"
                    },
                    {
                        "username": "julenn",
                        "content": "Who else got caught by the numbers in string format?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<<--please vote\\n\\n![image](https://assets.leetcode.com/users/images/ef5c4a7c-cd9f-4ff6-ae81-b756620c5aa2_1646311209.0542142.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/3d29b1aa-c229-430f-93e1-a5a80e266d6d_1646311215.0290844.png)\\n"
                    },
                    {
                        "username": "The_Finder",
                        "content": "![image](https://assets.leetcode.com/users/images/9adf9a1b-fe85-4bfc-944e-d61d1f24a748_1641458964.058156.png)\\n"
                    },
                    {
                        "username": "user2575O",
                        "content": "I encountered a similar question in Amazon OA today"
                    },
                    {
                        "username": "Sid_2027",
                        "content": "In this problem, we are given a grid where each cell can be either 0 or 1. We need to count the number of islands in the grid, where an island is defined as a group of connected 1s.\\n\\nTo solve this, we can iterate through the grid and whenever we encounter a 1, we perform a Breadth-First Search (BFS) traversal to visit all the connected cells. During the traversal, we mark each visited cell as 0 to avoid counting it multiple times.\\n\\nBy applying BFS on each unvisited 1 cell, we can identify and count all the islands in the grid. The count of islands represents the solution to the problem.\\n\\nSummary: The approach involves identifying connected components in the grid, where each component represents an island. By treating the 1s as nodes in a graph, we can use a BFS traversal to visit each node and increment a count variable to track the number of islands. The traversal ensures that each connected node is visited, effectively counting the components."
                    }
                ]
            },
            {
                "id": 1914241,
                "content": [
                    {
                        "username": "dsa1995",
                        "content": "This problem is equivalent to finding out the number of connected components in a graph."
                    },
                    {
                        "username": "mkl75now",
                        "content": "Can someone please explain why the space complexity for bfs approach is O(min(M,N)? I am not sure why we are going with the min value as the maximum queue size in worst case?\\n\\nThis is what it says in the solution:\\nSpace complexity : O(min(M, N)) because in worst case where the grid is filled with lands, the size of queue can grow up to min(M,N)."
                    },
                    {
                        "username": "homehehe123",
                        "content": "is there some conditons  I do not consider"
                    },
                    {
                        "username": "Kyochi",
                        "content": "Asked in an interview: What if we have an array with 15 dimensions ? how do you handle that case to solve the problem ? "
                    },
                    {
                        "username": "akmuir",
                        "content": "you iterate through those dimensions the same way you\\'d iterate through these 2 making sure not to go over already iterated indices."
                    },
                    {
                        "username": "madpoly",
                        "content": "if you have 15 dimensions, only god can help you"
                    },
                    {
                        "username": "kotlavaibhav",
                        "content": "Why is DFS faster on this problem than BFS??? What is the run time complexity for this?"
                    },
                    {
                        "username": "julenn",
                        "content": "Who else got caught by the numbers in string format?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<<--please vote\\n\\n![image](https://assets.leetcode.com/users/images/ef5c4a7c-cd9f-4ff6-ae81-b756620c5aa2_1646311209.0542142.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/3d29b1aa-c229-430f-93e1-a5a80e266d6d_1646311215.0290844.png)\\n"
                    },
                    {
                        "username": "The_Finder",
                        "content": "![image](https://assets.leetcode.com/users/images/9adf9a1b-fe85-4bfc-944e-d61d1f24a748_1641458964.058156.png)\\n"
                    },
                    {
                        "username": "user2575O",
                        "content": "I encountered a similar question in Amazon OA today"
                    },
                    {
                        "username": "Sid_2027",
                        "content": "In this problem, we are given a grid where each cell can be either 0 or 1. We need to count the number of islands in the grid, where an island is defined as a group of connected 1s.\\n\\nTo solve this, we can iterate through the grid and whenever we encounter a 1, we perform a Breadth-First Search (BFS) traversal to visit all the connected cells. During the traversal, we mark each visited cell as 0 to avoid counting it multiple times.\\n\\nBy applying BFS on each unvisited 1 cell, we can identify and count all the islands in the grid. The count of islands represents the solution to the problem.\\n\\nSummary: The approach involves identifying connected components in the grid, where each component represents an island. By treating the 1s as nodes in a graph, we can use a BFS traversal to visit each node and increment a count variable to track the number of islands. The traversal ensures that each connected node is visited, effectively counting the components."
                    }
                ]
            },
            {
                "id": 1882431,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 How many of you have not noticed that the matrix contains string \"1\"  or  \"0\" and treated them as numbers."
                    },
                    {
                        "username": "jeehaytch",
                        "content": "Guilty!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "why on earth is the array full of chars"
                    },
                    {
                        "username": "user0146V",
                        "content": "https://dsalgorithmbymukku.blogspot.com/2022/03/number-of-islands.html"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2Just have to count the total no of connected components by making all making  a graph of 1\\'s and 0\\'s and connecting the 1\\'s of island."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "What are the (dis)advantages of using BFS vs DFS, and when using DFS, why is it recommended to use recursion instead of a stack?"
                    },
                    {
                        "username": "gogol1anonly",
                        "content": "Unsure how the space complexity is Min (rowCnt, ColCnt). Feels like it should be rowCnt + ColCnt. If all are 1\\'s doesnt the last level of BFS enqueue all the 1\\'s on the array boundary which in turn becomes 2*rowCnt + 2*colCnt ?"
                    },
                    {
                        "username": "perebor",
                        "content": "My Submition simliar with Solution 2, but got 4ms. \\nCopy Paste solution 1 and sumit, only 1ms.\\nSolution 3 runs 5ms. \\n\\nIs the anything wrong with the testcase?"
                    },
                    {
                        "username": "itszlatan9",
                        "content": "Hi all, \\n\\nI am finding it a little hard to understand why we have undirected graph here? Could someone explain the reasons behind the setup given in the solution? I understand the DFS part but don\\'t seem to understand the DFS setup. Are we looking at SCCs here, where each SCC is an island?\\n\\nThanks!"
                    },
                    {
                        "username": "garyzhan",
                        "content": "If an island is connected to \"the outside world\", discard it. Only count islands that are completely surrounded by water. For example, the input below should return 1 instead of 3 (only the island in the middle meets the criteria).\\n\\n11000\\n11000\\n00100\\n00011\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "Rayofsunshinez",
                        "content": "Can someone explain the question?\\n"
                    }
                ]
            },
            {
                "id": 1847221,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 How many of you have not noticed that the matrix contains string \"1\"  or  \"0\" and treated them as numbers."
                    },
                    {
                        "username": "jeehaytch",
                        "content": "Guilty!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "why on earth is the array full of chars"
                    },
                    {
                        "username": "user0146V",
                        "content": "https://dsalgorithmbymukku.blogspot.com/2022/03/number-of-islands.html"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2Just have to count the total no of connected components by making all making  a graph of 1\\'s and 0\\'s and connecting the 1\\'s of island."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "What are the (dis)advantages of using BFS vs DFS, and when using DFS, why is it recommended to use recursion instead of a stack?"
                    },
                    {
                        "username": "gogol1anonly",
                        "content": "Unsure how the space complexity is Min (rowCnt, ColCnt). Feels like it should be rowCnt + ColCnt. If all are 1\\'s doesnt the last level of BFS enqueue all the 1\\'s on the array boundary which in turn becomes 2*rowCnt + 2*colCnt ?"
                    },
                    {
                        "username": "perebor",
                        "content": "My Submition simliar with Solution 2, but got 4ms. \\nCopy Paste solution 1 and sumit, only 1ms.\\nSolution 3 runs 5ms. \\n\\nIs the anything wrong with the testcase?"
                    },
                    {
                        "username": "itszlatan9",
                        "content": "Hi all, \\n\\nI am finding it a little hard to understand why we have undirected graph here? Could someone explain the reasons behind the setup given in the solution? I understand the DFS part but don\\'t seem to understand the DFS setup. Are we looking at SCCs here, where each SCC is an island?\\n\\nThanks!"
                    },
                    {
                        "username": "garyzhan",
                        "content": "If an island is connected to \"the outside world\", discard it. Only count islands that are completely surrounded by water. For example, the input below should return 1 instead of 3 (only the island in the middle meets the criteria).\\n\\n11000\\n11000\\n00100\\n00011\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "Rayofsunshinez",
                        "content": "Can someone explain the question?\\n"
                    }
                ]
            },
            {
                "id": 1570824,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 How many of you have not noticed that the matrix contains string \"1\"  or  \"0\" and treated them as numbers."
                    },
                    {
                        "username": "jeehaytch",
                        "content": "Guilty!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "why on earth is the array full of chars"
                    },
                    {
                        "username": "user0146V",
                        "content": "https://dsalgorithmbymukku.blogspot.com/2022/03/number-of-islands.html"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2Just have to count the total no of connected components by making all making  a graph of 1\\'s and 0\\'s and connecting the 1\\'s of island."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "What are the (dis)advantages of using BFS vs DFS, and when using DFS, why is it recommended to use recursion instead of a stack?"
                    },
                    {
                        "username": "gogol1anonly",
                        "content": "Unsure how the space complexity is Min (rowCnt, ColCnt). Feels like it should be rowCnt + ColCnt. If all are 1\\'s doesnt the last level of BFS enqueue all the 1\\'s on the array boundary which in turn becomes 2*rowCnt + 2*colCnt ?"
                    },
                    {
                        "username": "perebor",
                        "content": "My Submition simliar with Solution 2, but got 4ms. \\nCopy Paste solution 1 and sumit, only 1ms.\\nSolution 3 runs 5ms. \\n\\nIs the anything wrong with the testcase?"
                    },
                    {
                        "username": "itszlatan9",
                        "content": "Hi all, \\n\\nI am finding it a little hard to understand why we have undirected graph here? Could someone explain the reasons behind the setup given in the solution? I understand the DFS part but don\\'t seem to understand the DFS setup. Are we looking at SCCs here, where each SCC is an island?\\n\\nThanks!"
                    },
                    {
                        "username": "garyzhan",
                        "content": "If an island is connected to \"the outside world\", discard it. Only count islands that are completely surrounded by water. For example, the input below should return 1 instead of 3 (only the island in the middle meets the criteria).\\n\\n11000\\n11000\\n00100\\n00011\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "Rayofsunshinez",
                        "content": "Can someone explain the question?\\n"
                    }
                ]
            },
            {
                "id": 1882443,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 How many of you have not noticed that the matrix contains string \"1\"  or  \"0\" and treated them as numbers."
                    },
                    {
                        "username": "jeehaytch",
                        "content": "Guilty!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "why on earth is the array full of chars"
                    },
                    {
                        "username": "user0146V",
                        "content": "https://dsalgorithmbymukku.blogspot.com/2022/03/number-of-islands.html"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2Just have to count the total no of connected components by making all making  a graph of 1\\'s and 0\\'s and connecting the 1\\'s of island."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "What are the (dis)advantages of using BFS vs DFS, and when using DFS, why is it recommended to use recursion instead of a stack?"
                    },
                    {
                        "username": "gogol1anonly",
                        "content": "Unsure how the space complexity is Min (rowCnt, ColCnt). Feels like it should be rowCnt + ColCnt. If all are 1\\'s doesnt the last level of BFS enqueue all the 1\\'s on the array boundary which in turn becomes 2*rowCnt + 2*colCnt ?"
                    },
                    {
                        "username": "perebor",
                        "content": "My Submition simliar with Solution 2, but got 4ms. \\nCopy Paste solution 1 and sumit, only 1ms.\\nSolution 3 runs 5ms. \\n\\nIs the anything wrong with the testcase?"
                    },
                    {
                        "username": "itszlatan9",
                        "content": "Hi all, \\n\\nI am finding it a little hard to understand why we have undirected graph here? Could someone explain the reasons behind the setup given in the solution? I understand the DFS part but don\\'t seem to understand the DFS setup. Are we looking at SCCs here, where each SCC is an island?\\n\\nThanks!"
                    },
                    {
                        "username": "garyzhan",
                        "content": "If an island is connected to \"the outside world\", discard it. Only count islands that are completely surrounded by water. For example, the input below should return 1 instead of 3 (only the island in the middle meets the criteria).\\n\\n11000\\n11000\\n00100\\n00011\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "Rayofsunshinez",
                        "content": "Can someone explain the question?\\n"
                    }
                ]
            },
            {
                "id": 1575989,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 How many of you have not noticed that the matrix contains string \"1\"  or  \"0\" and treated them as numbers."
                    },
                    {
                        "username": "jeehaytch",
                        "content": "Guilty!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "why on earth is the array full of chars"
                    },
                    {
                        "username": "user0146V",
                        "content": "https://dsalgorithmbymukku.blogspot.com/2022/03/number-of-islands.html"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2Just have to count the total no of connected components by making all making  a graph of 1\\'s and 0\\'s and connecting the 1\\'s of island."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "What are the (dis)advantages of using BFS vs DFS, and when using DFS, why is it recommended to use recursion instead of a stack?"
                    },
                    {
                        "username": "gogol1anonly",
                        "content": "Unsure how the space complexity is Min (rowCnt, ColCnt). Feels like it should be rowCnt + ColCnt. If all are 1\\'s doesnt the last level of BFS enqueue all the 1\\'s on the array boundary which in turn becomes 2*rowCnt + 2*colCnt ?"
                    },
                    {
                        "username": "perebor",
                        "content": "My Submition simliar with Solution 2, but got 4ms. \\nCopy Paste solution 1 and sumit, only 1ms.\\nSolution 3 runs 5ms. \\n\\nIs the anything wrong with the testcase?"
                    },
                    {
                        "username": "itszlatan9",
                        "content": "Hi all, \\n\\nI am finding it a little hard to understand why we have undirected graph here? Could someone explain the reasons behind the setup given in the solution? I understand the DFS part but don\\'t seem to understand the DFS setup. Are we looking at SCCs here, where each SCC is an island?\\n\\nThanks!"
                    },
                    {
                        "username": "garyzhan",
                        "content": "If an island is connected to \"the outside world\", discard it. Only count islands that are completely surrounded by water. For example, the input below should return 1 instead of 3 (only the island in the middle meets the criteria).\\n\\n11000\\n11000\\n00100\\n00011\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "Rayofsunshinez",
                        "content": "Can someone explain the question?\\n"
                    }
                ]
            },
            {
                "id": 1575509,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 How many of you have not noticed that the matrix contains string \"1\"  or  \"0\" and treated them as numbers."
                    },
                    {
                        "username": "jeehaytch",
                        "content": "Guilty!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "why on earth is the array full of chars"
                    },
                    {
                        "username": "user0146V",
                        "content": "https://dsalgorithmbymukku.blogspot.com/2022/03/number-of-islands.html"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2Just have to count the total no of connected components by making all making  a graph of 1\\'s and 0\\'s and connecting the 1\\'s of island."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "What are the (dis)advantages of using BFS vs DFS, and when using DFS, why is it recommended to use recursion instead of a stack?"
                    },
                    {
                        "username": "gogol1anonly",
                        "content": "Unsure how the space complexity is Min (rowCnt, ColCnt). Feels like it should be rowCnt + ColCnt. If all are 1\\'s doesnt the last level of BFS enqueue all the 1\\'s on the array boundary which in turn becomes 2*rowCnt + 2*colCnt ?"
                    },
                    {
                        "username": "perebor",
                        "content": "My Submition simliar with Solution 2, but got 4ms. \\nCopy Paste solution 1 and sumit, only 1ms.\\nSolution 3 runs 5ms. \\n\\nIs the anything wrong with the testcase?"
                    },
                    {
                        "username": "itszlatan9",
                        "content": "Hi all, \\n\\nI am finding it a little hard to understand why we have undirected graph here? Could someone explain the reasons behind the setup given in the solution? I understand the DFS part but don\\'t seem to understand the DFS setup. Are we looking at SCCs here, where each SCC is an island?\\n\\nThanks!"
                    },
                    {
                        "username": "garyzhan",
                        "content": "If an island is connected to \"the outside world\", discard it. Only count islands that are completely surrounded by water. For example, the input below should return 1 instead of 3 (only the island in the middle meets the criteria).\\n\\n11000\\n11000\\n00100\\n00011\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "Rayofsunshinez",
                        "content": "Can someone explain the question?\\n"
                    }
                ]
            },
            {
                "id": 1573341,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 How many of you have not noticed that the matrix contains string \"1\"  or  \"0\" and treated them as numbers."
                    },
                    {
                        "username": "jeehaytch",
                        "content": "Guilty!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "why on earth is the array full of chars"
                    },
                    {
                        "username": "user0146V",
                        "content": "https://dsalgorithmbymukku.blogspot.com/2022/03/number-of-islands.html"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2Just have to count the total no of connected components by making all making  a graph of 1\\'s and 0\\'s and connecting the 1\\'s of island."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "What are the (dis)advantages of using BFS vs DFS, and when using DFS, why is it recommended to use recursion instead of a stack?"
                    },
                    {
                        "username": "gogol1anonly",
                        "content": "Unsure how the space complexity is Min (rowCnt, ColCnt). Feels like it should be rowCnt + ColCnt. If all are 1\\'s doesnt the last level of BFS enqueue all the 1\\'s on the array boundary which in turn becomes 2*rowCnt + 2*colCnt ?"
                    },
                    {
                        "username": "perebor",
                        "content": "My Submition simliar with Solution 2, but got 4ms. \\nCopy Paste solution 1 and sumit, only 1ms.\\nSolution 3 runs 5ms. \\n\\nIs the anything wrong with the testcase?"
                    },
                    {
                        "username": "itszlatan9",
                        "content": "Hi all, \\n\\nI am finding it a little hard to understand why we have undirected graph here? Could someone explain the reasons behind the setup given in the solution? I understand the DFS part but don\\'t seem to understand the DFS setup. Are we looking at SCCs here, where each SCC is an island?\\n\\nThanks!"
                    },
                    {
                        "username": "garyzhan",
                        "content": "If an island is connected to \"the outside world\", discard it. Only count islands that are completely surrounded by water. For example, the input below should return 1 instead of 3 (only the island in the middle meets the criteria).\\n\\n11000\\n11000\\n00100\\n00011\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "Rayofsunshinez",
                        "content": "Can someone explain the question?\\n"
                    }
                ]
            },
            {
                "id": 1573169,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 How many of you have not noticed that the matrix contains string \"1\"  or  \"0\" and treated them as numbers."
                    },
                    {
                        "username": "jeehaytch",
                        "content": "Guilty!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "why on earth is the array full of chars"
                    },
                    {
                        "username": "user0146V",
                        "content": "https://dsalgorithmbymukku.blogspot.com/2022/03/number-of-islands.html"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2Just have to count the total no of connected components by making all making  a graph of 1\\'s and 0\\'s and connecting the 1\\'s of island."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "What are the (dis)advantages of using BFS vs DFS, and when using DFS, why is it recommended to use recursion instead of a stack?"
                    },
                    {
                        "username": "gogol1anonly",
                        "content": "Unsure how the space complexity is Min (rowCnt, ColCnt). Feels like it should be rowCnt + ColCnt. If all are 1\\'s doesnt the last level of BFS enqueue all the 1\\'s on the array boundary which in turn becomes 2*rowCnt + 2*colCnt ?"
                    },
                    {
                        "username": "perebor",
                        "content": "My Submition simliar with Solution 2, but got 4ms. \\nCopy Paste solution 1 and sumit, only 1ms.\\nSolution 3 runs 5ms. \\n\\nIs the anything wrong with the testcase?"
                    },
                    {
                        "username": "itszlatan9",
                        "content": "Hi all, \\n\\nI am finding it a little hard to understand why we have undirected graph here? Could someone explain the reasons behind the setup given in the solution? I understand the DFS part but don\\'t seem to understand the DFS setup. Are we looking at SCCs here, where each SCC is an island?\\n\\nThanks!"
                    },
                    {
                        "username": "garyzhan",
                        "content": "If an island is connected to \"the outside world\", discard it. Only count islands that are completely surrounded by water. For example, the input below should return 1 instead of 3 (only the island in the middle meets the criteria).\\n\\n11000\\n11000\\n00100\\n00011\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "Rayofsunshinez",
                        "content": "Can someone explain the question?\\n"
                    }
                ]
            },
            {
                "id": 1573133,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 How many of you have not noticed that the matrix contains string \"1\"  or  \"0\" and treated them as numbers."
                    },
                    {
                        "username": "jeehaytch",
                        "content": "Guilty!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "why on earth is the array full of chars"
                    },
                    {
                        "username": "user0146V",
                        "content": "https://dsalgorithmbymukku.blogspot.com/2022/03/number-of-islands.html"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2Just have to count the total no of connected components by making all making  a graph of 1\\'s and 0\\'s and connecting the 1\\'s of island."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "What are the (dis)advantages of using BFS vs DFS, and when using DFS, why is it recommended to use recursion instead of a stack?"
                    },
                    {
                        "username": "gogol1anonly",
                        "content": "Unsure how the space complexity is Min (rowCnt, ColCnt). Feels like it should be rowCnt + ColCnt. If all are 1\\'s doesnt the last level of BFS enqueue all the 1\\'s on the array boundary which in turn becomes 2*rowCnt + 2*colCnt ?"
                    },
                    {
                        "username": "perebor",
                        "content": "My Submition simliar with Solution 2, but got 4ms. \\nCopy Paste solution 1 and sumit, only 1ms.\\nSolution 3 runs 5ms. \\n\\nIs the anything wrong with the testcase?"
                    },
                    {
                        "username": "itszlatan9",
                        "content": "Hi all, \\n\\nI am finding it a little hard to understand why we have undirected graph here? Could someone explain the reasons behind the setup given in the solution? I understand the DFS part but don\\'t seem to understand the DFS setup. Are we looking at SCCs here, where each SCC is an island?\\n\\nThanks!"
                    },
                    {
                        "username": "garyzhan",
                        "content": "If an island is connected to \"the outside world\", discard it. Only count islands that are completely surrounded by water. For example, the input below should return 1 instead of 3 (only the island in the middle meets the criteria).\\n\\n11000\\n11000\\n00100\\n00011\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "Rayofsunshinez",
                        "content": "Can someone explain the question?\\n"
                    }
                ]
            },
            {
                "id": 1573071,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 How many of you have not noticed that the matrix contains string \"1\"  or  \"0\" and treated them as numbers."
                    },
                    {
                        "username": "jeehaytch",
                        "content": "Guilty!"
                    },
                    {
                        "username": "jolswlf",
                        "content": "why on earth is the array full of chars"
                    },
                    {
                        "username": "user0146V",
                        "content": "https://dsalgorithmbymukku.blogspot.com/2022/03/number-of-islands.html"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2Just have to count the total no of connected components by making all making  a graph of 1\\'s and 0\\'s and connecting the 1\\'s of island."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "What are the (dis)advantages of using BFS vs DFS, and when using DFS, why is it recommended to use recursion instead of a stack?"
                    },
                    {
                        "username": "gogol1anonly",
                        "content": "Unsure how the space complexity is Min (rowCnt, ColCnt). Feels like it should be rowCnt + ColCnt. If all are 1\\'s doesnt the last level of BFS enqueue all the 1\\'s on the array boundary which in turn becomes 2*rowCnt + 2*colCnt ?"
                    },
                    {
                        "username": "perebor",
                        "content": "My Submition simliar with Solution 2, but got 4ms. \\nCopy Paste solution 1 and sumit, only 1ms.\\nSolution 3 runs 5ms. \\n\\nIs the anything wrong with the testcase?"
                    },
                    {
                        "username": "itszlatan9",
                        "content": "Hi all, \\n\\nI am finding it a little hard to understand why we have undirected graph here? Could someone explain the reasons behind the setup given in the solution? I understand the DFS part but don\\'t seem to understand the DFS setup. Are we looking at SCCs here, where each SCC is an island?\\n\\nThanks!"
                    },
                    {
                        "username": "garyzhan",
                        "content": "If an island is connected to \"the outside world\", discard it. Only count islands that are completely surrounded by water. For example, the input below should return 1 instead of 3 (only the island in the middle meets the criteria).\\n\\n11000\\n11000\\n00100\\n00011\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "Rayofsunshinez",
                        "content": "Can someone explain the question?\\n"
                    }
                ]
            },
            {
                "id": 1572881,
                "content": [
                    {
                        "username": "HYJi",
                        "content": "why the number of islands equals to the num of connected areas"
                    },
                    {
                        "username": "DumpGuy",
                        "content": "[[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]\\n\\nIt shows three. Is it not one ? Can any explain me , where my thought has gone wrong ?  I can see link between 3rd row and second row ."
                    },
                    {
                        "username": "gbhamra",
                        "content": "I wasn't even able to think if we could use DFS here, is this really a medium level problem? After looking at the solution i feel it should be in Hard category. If at all it matters."
                    },
                    {
                        "username": "sonulamba241034",
                        "content": "i just started to learn graphs. i read bfs technique but still i am unable to think this grid/ matrix as a graph. plz someone help me out \"how can i visualize it as a graph not like matrix\". \\n\\n"
                    },
                    {
                        "username": "akmuir",
                        "content": "For those who are getting stuck on test case 47 or 48. This may be because you have too many conditionals in either your dfs or bfs and it needs to be cut down to not have to go through so many iterations. This doesn\\'t mean reducing the requirements, it simply means having the recursive functions be called in such a way that you don\\'t have to check as much."
                    },
                    {
                        "username": "leonardo_po",
                        "content": "I keep getting TLE with my BFS solution using a queue, can someone help me please?\nDon't look at the following content if you don't want to see a solution.\n`\n class Solution(object):\n    def numIslands(self, grid):\n         count = 0\n        visited = [[False for i in range(len(grid[0]))] for j in range(len(grid))]\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        def BFS(start_i, start_j):\n            queue = [(start_i, start_j)]\n\n            while queue:\n                curr_i, curr_j = queue.pop(0)\n                visited[curr_i][curr_j] = True\n\n                for add_i, add_j in directions:\n                    i = curr_i + add_i\n                    j = curr_j + add_j\n                    if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not visited[i][j] and grid[i][j] == '1':\n                        queue.append((i, j)) \n\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == '1' and not visited[i][j]:\n                    BFS(i, j)\n                    count += 1\n\n        return count\n`"
                    },
                    {
                        "username": "SandeepRoy",
                        "content": "If asked to check for land diagonally, then?"
                    },
                    {
                        "username": "akmuir",
                        "content": "then check for land diagonally"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "Yo, i have a solution but it\\'s exceeding the time limit, it seems to be similar to many AC\\'s, due to which I\\'m confused as to why this particular solution exceeds the time limit. I cant post it on here, as it\\'ll get deleted. Could I DM any of you to figure out the issue"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "Can someone explain why time limit exceeds for this given solutions : \n``` `your inline code...your inline code...`\n`class Solution {\n    `public int numIslands(char[][] matrix) {\n      `   int totalIslands = 0;\n    boolean visited [][] = new boolean[matrix.length][matrix[0].length];\n    for(int i = 0;i<matrix.length;i++){\n      for(int j = 0;j<matrix[i].length;j++){\n        if(matrix[i][j]=='1' && !visited[i][j]){\n          totalIslands++;\n          traverse(i,j,matrix,visited);\n        }\n      }\n      \n    }\n    return totalIslands;\n\n}\n public void traverse(int i, int j, char matrix[][],boolean visited[][]){\n    Queue<List<Integer>> q = new LinkedList<>();\n    q.add(Arrays.asList(i,j));\n    while(!q.isEmpty()){\n      List<Integer> li = q.remove();\n        int index1 = li.get(0);\n        int index2 = li.get(1);\n        visited[index1][index2] = true;\n        if(index1-1>=0&&!visited[index1-1][index2]&&matrix[index1-1][index2]=='1'){\n        q.add(Arrays.asList(index1-1,index2));\n        }\n        if(index2-1>=0&&!visited[index1][index2-1]&&matrix[index1][index2-1]=='1')\n        q.add(Arrays.asList(index1,index2-1));\n        if(index1+1<matrix.length&&!visited[index1+1][index2]&&matrix[index1+1][index2]=='1')\n        q.add(Arrays.asList(index1+1,index2));\n        if(index2+1<matrix[index1].length&&!visited[index1][index2+1]&&matrix[index1][index2+1]=='1')\n        q.add(Arrays.asList(index1,index2+1));\n      \n    }\n  }\n}\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "vishious",
                        "content": "I\\'m new to graphs topic. So far I have only practiced problems with adjacency matrix. Is the given input an adjacency list ?"
                    }
                ]
            },
            {
                "id": 1571420,
                "content": [
                    {
                        "username": "HYJi",
                        "content": "why the number of islands equals to the num of connected areas"
                    },
                    {
                        "username": "DumpGuy",
                        "content": "[[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]\\n\\nIt shows three. Is it not one ? Can any explain me , where my thought has gone wrong ?  I can see link between 3rd row and second row ."
                    },
                    {
                        "username": "gbhamra",
                        "content": "I wasn't even able to think if we could use DFS here, is this really a medium level problem? After looking at the solution i feel it should be in Hard category. If at all it matters."
                    },
                    {
                        "username": "sonulamba241034",
                        "content": "i just started to learn graphs. i read bfs technique but still i am unable to think this grid/ matrix as a graph. plz someone help me out \"how can i visualize it as a graph not like matrix\". \\n\\n"
                    },
                    {
                        "username": "akmuir",
                        "content": "For those who are getting stuck on test case 47 or 48. This may be because you have too many conditionals in either your dfs or bfs and it needs to be cut down to not have to go through so many iterations. This doesn\\'t mean reducing the requirements, it simply means having the recursive functions be called in such a way that you don\\'t have to check as much."
                    },
                    {
                        "username": "leonardo_po",
                        "content": "I keep getting TLE with my BFS solution using a queue, can someone help me please?\nDon't look at the following content if you don't want to see a solution.\n`\n class Solution(object):\n    def numIslands(self, grid):\n         count = 0\n        visited = [[False for i in range(len(grid[0]))] for j in range(len(grid))]\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        def BFS(start_i, start_j):\n            queue = [(start_i, start_j)]\n\n            while queue:\n                curr_i, curr_j = queue.pop(0)\n                visited[curr_i][curr_j] = True\n\n                for add_i, add_j in directions:\n                    i = curr_i + add_i\n                    j = curr_j + add_j\n                    if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not visited[i][j] and grid[i][j] == '1':\n                        queue.append((i, j)) \n\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == '1' and not visited[i][j]:\n                    BFS(i, j)\n                    count += 1\n\n        return count\n`"
                    },
                    {
                        "username": "SandeepRoy",
                        "content": "If asked to check for land diagonally, then?"
                    },
                    {
                        "username": "akmuir",
                        "content": "then check for land diagonally"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "Yo, i have a solution but it\\'s exceeding the time limit, it seems to be similar to many AC\\'s, due to which I\\'m confused as to why this particular solution exceeds the time limit. I cant post it on here, as it\\'ll get deleted. Could I DM any of you to figure out the issue"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "Can someone explain why time limit exceeds for this given solutions : \n``` `your inline code...your inline code...`\n`class Solution {\n    `public int numIslands(char[][] matrix) {\n      `   int totalIslands = 0;\n    boolean visited [][] = new boolean[matrix.length][matrix[0].length];\n    for(int i = 0;i<matrix.length;i++){\n      for(int j = 0;j<matrix[i].length;j++){\n        if(matrix[i][j]=='1' && !visited[i][j]){\n          totalIslands++;\n          traverse(i,j,matrix,visited);\n        }\n      }\n      \n    }\n    return totalIslands;\n\n}\n public void traverse(int i, int j, char matrix[][],boolean visited[][]){\n    Queue<List<Integer>> q = new LinkedList<>();\n    q.add(Arrays.asList(i,j));\n    while(!q.isEmpty()){\n      List<Integer> li = q.remove();\n        int index1 = li.get(0);\n        int index2 = li.get(1);\n        visited[index1][index2] = true;\n        if(index1-1>=0&&!visited[index1-1][index2]&&matrix[index1-1][index2]=='1'){\n        q.add(Arrays.asList(index1-1,index2));\n        }\n        if(index2-1>=0&&!visited[index1][index2-1]&&matrix[index1][index2-1]=='1')\n        q.add(Arrays.asList(index1,index2-1));\n        if(index1+1<matrix.length&&!visited[index1+1][index2]&&matrix[index1+1][index2]=='1')\n        q.add(Arrays.asList(index1+1,index2));\n        if(index2+1<matrix[index1].length&&!visited[index1][index2+1]&&matrix[index1][index2+1]=='1')\n        q.add(Arrays.asList(index1,index2+1));\n      \n    }\n  }\n}\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "vishious",
                        "content": "I\\'m new to graphs topic. So far I have only practiced problems with adjacency matrix. Is the given input an adjacency list ?"
                    }
                ]
            },
            {
                "id": 1569019,
                "content": [
                    {
                        "username": "HYJi",
                        "content": "why the number of islands equals to the num of connected areas"
                    },
                    {
                        "username": "DumpGuy",
                        "content": "[[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]\\n\\nIt shows three. Is it not one ? Can any explain me , where my thought has gone wrong ?  I can see link between 3rd row and second row ."
                    },
                    {
                        "username": "gbhamra",
                        "content": "I wasn't even able to think if we could use DFS here, is this really a medium level problem? After looking at the solution i feel it should be in Hard category. If at all it matters."
                    },
                    {
                        "username": "sonulamba241034",
                        "content": "i just started to learn graphs. i read bfs technique but still i am unable to think this grid/ matrix as a graph. plz someone help me out \"how can i visualize it as a graph not like matrix\". \\n\\n"
                    },
                    {
                        "username": "akmuir",
                        "content": "For those who are getting stuck on test case 47 or 48. This may be because you have too many conditionals in either your dfs or bfs and it needs to be cut down to not have to go through so many iterations. This doesn\\'t mean reducing the requirements, it simply means having the recursive functions be called in such a way that you don\\'t have to check as much."
                    },
                    {
                        "username": "leonardo_po",
                        "content": "I keep getting TLE with my BFS solution using a queue, can someone help me please?\nDon't look at the following content if you don't want to see a solution.\n`\n class Solution(object):\n    def numIslands(self, grid):\n         count = 0\n        visited = [[False for i in range(len(grid[0]))] for j in range(len(grid))]\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        def BFS(start_i, start_j):\n            queue = [(start_i, start_j)]\n\n            while queue:\n                curr_i, curr_j = queue.pop(0)\n                visited[curr_i][curr_j] = True\n\n                for add_i, add_j in directions:\n                    i = curr_i + add_i\n                    j = curr_j + add_j\n                    if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not visited[i][j] and grid[i][j] == '1':\n                        queue.append((i, j)) \n\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == '1' and not visited[i][j]:\n                    BFS(i, j)\n                    count += 1\n\n        return count\n`"
                    },
                    {
                        "username": "SandeepRoy",
                        "content": "If asked to check for land diagonally, then?"
                    },
                    {
                        "username": "akmuir",
                        "content": "then check for land diagonally"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "Yo, i have a solution but it\\'s exceeding the time limit, it seems to be similar to many AC\\'s, due to which I\\'m confused as to why this particular solution exceeds the time limit. I cant post it on here, as it\\'ll get deleted. Could I DM any of you to figure out the issue"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "Can someone explain why time limit exceeds for this given solutions : \n``` `your inline code...your inline code...`\n`class Solution {\n    `public int numIslands(char[][] matrix) {\n      `   int totalIslands = 0;\n    boolean visited [][] = new boolean[matrix.length][matrix[0].length];\n    for(int i = 0;i<matrix.length;i++){\n      for(int j = 0;j<matrix[i].length;j++){\n        if(matrix[i][j]=='1' && !visited[i][j]){\n          totalIslands++;\n          traverse(i,j,matrix,visited);\n        }\n      }\n      \n    }\n    return totalIslands;\n\n}\n public void traverse(int i, int j, char matrix[][],boolean visited[][]){\n    Queue<List<Integer>> q = new LinkedList<>();\n    q.add(Arrays.asList(i,j));\n    while(!q.isEmpty()){\n      List<Integer> li = q.remove();\n        int index1 = li.get(0);\n        int index2 = li.get(1);\n        visited[index1][index2] = true;\n        if(index1-1>=0&&!visited[index1-1][index2]&&matrix[index1-1][index2]=='1'){\n        q.add(Arrays.asList(index1-1,index2));\n        }\n        if(index2-1>=0&&!visited[index1][index2-1]&&matrix[index1][index2-1]=='1')\n        q.add(Arrays.asList(index1,index2-1));\n        if(index1+1<matrix.length&&!visited[index1+1][index2]&&matrix[index1+1][index2]=='1')\n        q.add(Arrays.asList(index1+1,index2));\n        if(index2+1<matrix[index1].length&&!visited[index1][index2+1]&&matrix[index1][index2+1]=='1')\n        q.add(Arrays.asList(index1,index2+1));\n      \n    }\n  }\n}\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "vishious",
                        "content": "I\\'m new to graphs topic. So far I have only practiced problems with adjacency matrix. Is the given input an adjacency list ?"
                    }
                ]
            },
            {
                "id": 2071159,
                "content": [
                    {
                        "username": "HYJi",
                        "content": "why the number of islands equals to the num of connected areas"
                    },
                    {
                        "username": "DumpGuy",
                        "content": "[[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]\\n\\nIt shows three. Is it not one ? Can any explain me , where my thought has gone wrong ?  I can see link between 3rd row and second row ."
                    },
                    {
                        "username": "gbhamra",
                        "content": "I wasn't even able to think if we could use DFS here, is this really a medium level problem? After looking at the solution i feel it should be in Hard category. If at all it matters."
                    },
                    {
                        "username": "sonulamba241034",
                        "content": "i just started to learn graphs. i read bfs technique but still i am unable to think this grid/ matrix as a graph. plz someone help me out \"how can i visualize it as a graph not like matrix\". \\n\\n"
                    },
                    {
                        "username": "akmuir",
                        "content": "For those who are getting stuck on test case 47 or 48. This may be because you have too many conditionals in either your dfs or bfs and it needs to be cut down to not have to go through so many iterations. This doesn\\'t mean reducing the requirements, it simply means having the recursive functions be called in such a way that you don\\'t have to check as much."
                    },
                    {
                        "username": "leonardo_po",
                        "content": "I keep getting TLE with my BFS solution using a queue, can someone help me please?\nDon't look at the following content if you don't want to see a solution.\n`\n class Solution(object):\n    def numIslands(self, grid):\n         count = 0\n        visited = [[False for i in range(len(grid[0]))] for j in range(len(grid))]\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        def BFS(start_i, start_j):\n            queue = [(start_i, start_j)]\n\n            while queue:\n                curr_i, curr_j = queue.pop(0)\n                visited[curr_i][curr_j] = True\n\n                for add_i, add_j in directions:\n                    i = curr_i + add_i\n                    j = curr_j + add_j\n                    if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not visited[i][j] and grid[i][j] == '1':\n                        queue.append((i, j)) \n\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == '1' and not visited[i][j]:\n                    BFS(i, j)\n                    count += 1\n\n        return count\n`"
                    },
                    {
                        "username": "SandeepRoy",
                        "content": "If asked to check for land diagonally, then?"
                    },
                    {
                        "username": "akmuir",
                        "content": "then check for land diagonally"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "Yo, i have a solution but it\\'s exceeding the time limit, it seems to be similar to many AC\\'s, due to which I\\'m confused as to why this particular solution exceeds the time limit. I cant post it on here, as it\\'ll get deleted. Could I DM any of you to figure out the issue"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "Can someone explain why time limit exceeds for this given solutions : \n``` `your inline code...your inline code...`\n`class Solution {\n    `public int numIslands(char[][] matrix) {\n      `   int totalIslands = 0;\n    boolean visited [][] = new boolean[matrix.length][matrix[0].length];\n    for(int i = 0;i<matrix.length;i++){\n      for(int j = 0;j<matrix[i].length;j++){\n        if(matrix[i][j]=='1' && !visited[i][j]){\n          totalIslands++;\n          traverse(i,j,matrix,visited);\n        }\n      }\n      \n    }\n    return totalIslands;\n\n}\n public void traverse(int i, int j, char matrix[][],boolean visited[][]){\n    Queue<List<Integer>> q = new LinkedList<>();\n    q.add(Arrays.asList(i,j));\n    while(!q.isEmpty()){\n      List<Integer> li = q.remove();\n        int index1 = li.get(0);\n        int index2 = li.get(1);\n        visited[index1][index2] = true;\n        if(index1-1>=0&&!visited[index1-1][index2]&&matrix[index1-1][index2]=='1'){\n        q.add(Arrays.asList(index1-1,index2));\n        }\n        if(index2-1>=0&&!visited[index1][index2-1]&&matrix[index1][index2-1]=='1')\n        q.add(Arrays.asList(index1,index2-1));\n        if(index1+1<matrix.length&&!visited[index1+1][index2]&&matrix[index1+1][index2]=='1')\n        q.add(Arrays.asList(index1+1,index2));\n        if(index2+1<matrix[index1].length&&!visited[index1][index2+1]&&matrix[index1][index2+1]=='1')\n        q.add(Arrays.asList(index1,index2+1));\n      \n    }\n  }\n}\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "vishious",
                        "content": "I\\'m new to graphs topic. So far I have only practiced problems with adjacency matrix. Is the given input an adjacency list ?"
                    }
                ]
            },
            {
                "id": 2063470,
                "content": [
                    {
                        "username": "HYJi",
                        "content": "why the number of islands equals to the num of connected areas"
                    },
                    {
                        "username": "DumpGuy",
                        "content": "[[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]\\n\\nIt shows three. Is it not one ? Can any explain me , where my thought has gone wrong ?  I can see link between 3rd row and second row ."
                    },
                    {
                        "username": "gbhamra",
                        "content": "I wasn't even able to think if we could use DFS here, is this really a medium level problem? After looking at the solution i feel it should be in Hard category. If at all it matters."
                    },
                    {
                        "username": "sonulamba241034",
                        "content": "i just started to learn graphs. i read bfs technique but still i am unable to think this grid/ matrix as a graph. plz someone help me out \"how can i visualize it as a graph not like matrix\". \\n\\n"
                    },
                    {
                        "username": "akmuir",
                        "content": "For those who are getting stuck on test case 47 or 48. This may be because you have too many conditionals in either your dfs or bfs and it needs to be cut down to not have to go through so many iterations. This doesn\\'t mean reducing the requirements, it simply means having the recursive functions be called in such a way that you don\\'t have to check as much."
                    },
                    {
                        "username": "leonardo_po",
                        "content": "I keep getting TLE with my BFS solution using a queue, can someone help me please?\nDon't look at the following content if you don't want to see a solution.\n`\n class Solution(object):\n    def numIslands(self, grid):\n         count = 0\n        visited = [[False for i in range(len(grid[0]))] for j in range(len(grid))]\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        def BFS(start_i, start_j):\n            queue = [(start_i, start_j)]\n\n            while queue:\n                curr_i, curr_j = queue.pop(0)\n                visited[curr_i][curr_j] = True\n\n                for add_i, add_j in directions:\n                    i = curr_i + add_i\n                    j = curr_j + add_j\n                    if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not visited[i][j] and grid[i][j] == '1':\n                        queue.append((i, j)) \n\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == '1' and not visited[i][j]:\n                    BFS(i, j)\n                    count += 1\n\n        return count\n`"
                    },
                    {
                        "username": "SandeepRoy",
                        "content": "If asked to check for land diagonally, then?"
                    },
                    {
                        "username": "akmuir",
                        "content": "then check for land diagonally"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "Yo, i have a solution but it\\'s exceeding the time limit, it seems to be similar to many AC\\'s, due to which I\\'m confused as to why this particular solution exceeds the time limit. I cant post it on here, as it\\'ll get deleted. Could I DM any of you to figure out the issue"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "Can someone explain why time limit exceeds for this given solutions : \n``` `your inline code...your inline code...`\n`class Solution {\n    `public int numIslands(char[][] matrix) {\n      `   int totalIslands = 0;\n    boolean visited [][] = new boolean[matrix.length][matrix[0].length];\n    for(int i = 0;i<matrix.length;i++){\n      for(int j = 0;j<matrix[i].length;j++){\n        if(matrix[i][j]=='1' && !visited[i][j]){\n          totalIslands++;\n          traverse(i,j,matrix,visited);\n        }\n      }\n      \n    }\n    return totalIslands;\n\n}\n public void traverse(int i, int j, char matrix[][],boolean visited[][]){\n    Queue<List<Integer>> q = new LinkedList<>();\n    q.add(Arrays.asList(i,j));\n    while(!q.isEmpty()){\n      List<Integer> li = q.remove();\n        int index1 = li.get(0);\n        int index2 = li.get(1);\n        visited[index1][index2] = true;\n        if(index1-1>=0&&!visited[index1-1][index2]&&matrix[index1-1][index2]=='1'){\n        q.add(Arrays.asList(index1-1,index2));\n        }\n        if(index2-1>=0&&!visited[index1][index2-1]&&matrix[index1][index2-1]=='1')\n        q.add(Arrays.asList(index1,index2-1));\n        if(index1+1<matrix.length&&!visited[index1+1][index2]&&matrix[index1+1][index2]=='1')\n        q.add(Arrays.asList(index1+1,index2));\n        if(index2+1<matrix[index1].length&&!visited[index1][index2+1]&&matrix[index1][index2+1]=='1')\n        q.add(Arrays.asList(index1,index2+1));\n      \n    }\n  }\n}\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "vishious",
                        "content": "I\\'m new to graphs topic. So far I have only practiced problems with adjacency matrix. Is the given input an adjacency list ?"
                    }
                ]
            },
            {
                "id": 2041552,
                "content": [
                    {
                        "username": "HYJi",
                        "content": "why the number of islands equals to the num of connected areas"
                    },
                    {
                        "username": "DumpGuy",
                        "content": "[[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]\\n\\nIt shows three. Is it not one ? Can any explain me , where my thought has gone wrong ?  I can see link between 3rd row and second row ."
                    },
                    {
                        "username": "gbhamra",
                        "content": "I wasn't even able to think if we could use DFS here, is this really a medium level problem? After looking at the solution i feel it should be in Hard category. If at all it matters."
                    },
                    {
                        "username": "sonulamba241034",
                        "content": "i just started to learn graphs. i read bfs technique but still i am unable to think this grid/ matrix as a graph. plz someone help me out \"how can i visualize it as a graph not like matrix\". \\n\\n"
                    },
                    {
                        "username": "akmuir",
                        "content": "For those who are getting stuck on test case 47 or 48. This may be because you have too many conditionals in either your dfs or bfs and it needs to be cut down to not have to go through so many iterations. This doesn\\'t mean reducing the requirements, it simply means having the recursive functions be called in such a way that you don\\'t have to check as much."
                    },
                    {
                        "username": "leonardo_po",
                        "content": "I keep getting TLE with my BFS solution using a queue, can someone help me please?\nDon't look at the following content if you don't want to see a solution.\n`\n class Solution(object):\n    def numIslands(self, grid):\n         count = 0\n        visited = [[False for i in range(len(grid[0]))] for j in range(len(grid))]\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        def BFS(start_i, start_j):\n            queue = [(start_i, start_j)]\n\n            while queue:\n                curr_i, curr_j = queue.pop(0)\n                visited[curr_i][curr_j] = True\n\n                for add_i, add_j in directions:\n                    i = curr_i + add_i\n                    j = curr_j + add_j\n                    if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not visited[i][j] and grid[i][j] == '1':\n                        queue.append((i, j)) \n\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == '1' and not visited[i][j]:\n                    BFS(i, j)\n                    count += 1\n\n        return count\n`"
                    },
                    {
                        "username": "SandeepRoy",
                        "content": "If asked to check for land diagonally, then?"
                    },
                    {
                        "username": "akmuir",
                        "content": "then check for land diagonally"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "Yo, i have a solution but it\\'s exceeding the time limit, it seems to be similar to many AC\\'s, due to which I\\'m confused as to why this particular solution exceeds the time limit. I cant post it on here, as it\\'ll get deleted. Could I DM any of you to figure out the issue"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "Can someone explain why time limit exceeds for this given solutions : \n``` `your inline code...your inline code...`\n`class Solution {\n    `public int numIslands(char[][] matrix) {\n      `   int totalIslands = 0;\n    boolean visited [][] = new boolean[matrix.length][matrix[0].length];\n    for(int i = 0;i<matrix.length;i++){\n      for(int j = 0;j<matrix[i].length;j++){\n        if(matrix[i][j]=='1' && !visited[i][j]){\n          totalIslands++;\n          traverse(i,j,matrix,visited);\n        }\n      }\n      \n    }\n    return totalIslands;\n\n}\n public void traverse(int i, int j, char matrix[][],boolean visited[][]){\n    Queue<List<Integer>> q = new LinkedList<>();\n    q.add(Arrays.asList(i,j));\n    while(!q.isEmpty()){\n      List<Integer> li = q.remove();\n        int index1 = li.get(0);\n        int index2 = li.get(1);\n        visited[index1][index2] = true;\n        if(index1-1>=0&&!visited[index1-1][index2]&&matrix[index1-1][index2]=='1'){\n        q.add(Arrays.asList(index1-1,index2));\n        }\n        if(index2-1>=0&&!visited[index1][index2-1]&&matrix[index1][index2-1]=='1')\n        q.add(Arrays.asList(index1,index2-1));\n        if(index1+1<matrix.length&&!visited[index1+1][index2]&&matrix[index1+1][index2]=='1')\n        q.add(Arrays.asList(index1+1,index2));\n        if(index2+1<matrix[index1].length&&!visited[index1][index2+1]&&matrix[index1][index2+1]=='1')\n        q.add(Arrays.asList(index1,index2+1));\n      \n    }\n  }\n}\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "vishious",
                        "content": "I\\'m new to graphs topic. So far I have only practiced problems with adjacency matrix. Is the given input an adjacency list ?"
                    }
                ]
            },
            {
                "id": 2037953,
                "content": [
                    {
                        "username": "HYJi",
                        "content": "why the number of islands equals to the num of connected areas"
                    },
                    {
                        "username": "DumpGuy",
                        "content": "[[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]\\n\\nIt shows three. Is it not one ? Can any explain me , where my thought has gone wrong ?  I can see link between 3rd row and second row ."
                    },
                    {
                        "username": "gbhamra",
                        "content": "I wasn't even able to think if we could use DFS here, is this really a medium level problem? After looking at the solution i feel it should be in Hard category. If at all it matters."
                    },
                    {
                        "username": "sonulamba241034",
                        "content": "i just started to learn graphs. i read bfs technique but still i am unable to think this grid/ matrix as a graph. plz someone help me out \"how can i visualize it as a graph not like matrix\". \\n\\n"
                    },
                    {
                        "username": "akmuir",
                        "content": "For those who are getting stuck on test case 47 or 48. This may be because you have too many conditionals in either your dfs or bfs and it needs to be cut down to not have to go through so many iterations. This doesn\\'t mean reducing the requirements, it simply means having the recursive functions be called in such a way that you don\\'t have to check as much."
                    },
                    {
                        "username": "leonardo_po",
                        "content": "I keep getting TLE with my BFS solution using a queue, can someone help me please?\nDon't look at the following content if you don't want to see a solution.\n`\n class Solution(object):\n    def numIslands(self, grid):\n         count = 0\n        visited = [[False for i in range(len(grid[0]))] for j in range(len(grid))]\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        def BFS(start_i, start_j):\n            queue = [(start_i, start_j)]\n\n            while queue:\n                curr_i, curr_j = queue.pop(0)\n                visited[curr_i][curr_j] = True\n\n                for add_i, add_j in directions:\n                    i = curr_i + add_i\n                    j = curr_j + add_j\n                    if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not visited[i][j] and grid[i][j] == '1':\n                        queue.append((i, j)) \n\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == '1' and not visited[i][j]:\n                    BFS(i, j)\n                    count += 1\n\n        return count\n`"
                    },
                    {
                        "username": "SandeepRoy",
                        "content": "If asked to check for land diagonally, then?"
                    },
                    {
                        "username": "akmuir",
                        "content": "then check for land diagonally"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "Yo, i have a solution but it\\'s exceeding the time limit, it seems to be similar to many AC\\'s, due to which I\\'m confused as to why this particular solution exceeds the time limit. I cant post it on here, as it\\'ll get deleted. Could I DM any of you to figure out the issue"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "Can someone explain why time limit exceeds for this given solutions : \n``` `your inline code...your inline code...`\n`class Solution {\n    `public int numIslands(char[][] matrix) {\n      `   int totalIslands = 0;\n    boolean visited [][] = new boolean[matrix.length][matrix[0].length];\n    for(int i = 0;i<matrix.length;i++){\n      for(int j = 0;j<matrix[i].length;j++){\n        if(matrix[i][j]=='1' && !visited[i][j]){\n          totalIslands++;\n          traverse(i,j,matrix,visited);\n        }\n      }\n      \n    }\n    return totalIslands;\n\n}\n public void traverse(int i, int j, char matrix[][],boolean visited[][]){\n    Queue<List<Integer>> q = new LinkedList<>();\n    q.add(Arrays.asList(i,j));\n    while(!q.isEmpty()){\n      List<Integer> li = q.remove();\n        int index1 = li.get(0);\n        int index2 = li.get(1);\n        visited[index1][index2] = true;\n        if(index1-1>=0&&!visited[index1-1][index2]&&matrix[index1-1][index2]=='1'){\n        q.add(Arrays.asList(index1-1,index2));\n        }\n        if(index2-1>=0&&!visited[index1][index2-1]&&matrix[index1][index2-1]=='1')\n        q.add(Arrays.asList(index1,index2-1));\n        if(index1+1<matrix.length&&!visited[index1+1][index2]&&matrix[index1+1][index2]=='1')\n        q.add(Arrays.asList(index1+1,index2));\n        if(index2+1<matrix[index1].length&&!visited[index1][index2+1]&&matrix[index1][index2+1]=='1')\n        q.add(Arrays.asList(index1,index2+1));\n      \n    }\n  }\n}\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "vishious",
                        "content": "I\\'m new to graphs topic. So far I have only practiced problems with adjacency matrix. Is the given input an adjacency list ?"
                    }
                ]
            },
            {
                "id": 2014535,
                "content": [
                    {
                        "username": "HYJi",
                        "content": "why the number of islands equals to the num of connected areas"
                    },
                    {
                        "username": "DumpGuy",
                        "content": "[[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]\\n\\nIt shows three. Is it not one ? Can any explain me , where my thought has gone wrong ?  I can see link between 3rd row and second row ."
                    },
                    {
                        "username": "gbhamra",
                        "content": "I wasn't even able to think if we could use DFS here, is this really a medium level problem? After looking at the solution i feel it should be in Hard category. If at all it matters."
                    },
                    {
                        "username": "sonulamba241034",
                        "content": "i just started to learn graphs. i read bfs technique but still i am unable to think this grid/ matrix as a graph. plz someone help me out \"how can i visualize it as a graph not like matrix\". \\n\\n"
                    },
                    {
                        "username": "akmuir",
                        "content": "For those who are getting stuck on test case 47 or 48. This may be because you have too many conditionals in either your dfs or bfs and it needs to be cut down to not have to go through so many iterations. This doesn\\'t mean reducing the requirements, it simply means having the recursive functions be called in such a way that you don\\'t have to check as much."
                    },
                    {
                        "username": "leonardo_po",
                        "content": "I keep getting TLE with my BFS solution using a queue, can someone help me please?\nDon't look at the following content if you don't want to see a solution.\n`\n class Solution(object):\n    def numIslands(self, grid):\n         count = 0\n        visited = [[False for i in range(len(grid[0]))] for j in range(len(grid))]\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        def BFS(start_i, start_j):\n            queue = [(start_i, start_j)]\n\n            while queue:\n                curr_i, curr_j = queue.pop(0)\n                visited[curr_i][curr_j] = True\n\n                for add_i, add_j in directions:\n                    i = curr_i + add_i\n                    j = curr_j + add_j\n                    if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not visited[i][j] and grid[i][j] == '1':\n                        queue.append((i, j)) \n\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == '1' and not visited[i][j]:\n                    BFS(i, j)\n                    count += 1\n\n        return count\n`"
                    },
                    {
                        "username": "SandeepRoy",
                        "content": "If asked to check for land diagonally, then?"
                    },
                    {
                        "username": "akmuir",
                        "content": "then check for land diagonally"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "Yo, i have a solution but it\\'s exceeding the time limit, it seems to be similar to many AC\\'s, due to which I\\'m confused as to why this particular solution exceeds the time limit. I cant post it on here, as it\\'ll get deleted. Could I DM any of you to figure out the issue"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "Can someone explain why time limit exceeds for this given solutions : \n``` `your inline code...your inline code...`\n`class Solution {\n    `public int numIslands(char[][] matrix) {\n      `   int totalIslands = 0;\n    boolean visited [][] = new boolean[matrix.length][matrix[0].length];\n    for(int i = 0;i<matrix.length;i++){\n      for(int j = 0;j<matrix[i].length;j++){\n        if(matrix[i][j]=='1' && !visited[i][j]){\n          totalIslands++;\n          traverse(i,j,matrix,visited);\n        }\n      }\n      \n    }\n    return totalIslands;\n\n}\n public void traverse(int i, int j, char matrix[][],boolean visited[][]){\n    Queue<List<Integer>> q = new LinkedList<>();\n    q.add(Arrays.asList(i,j));\n    while(!q.isEmpty()){\n      List<Integer> li = q.remove();\n        int index1 = li.get(0);\n        int index2 = li.get(1);\n        visited[index1][index2] = true;\n        if(index1-1>=0&&!visited[index1-1][index2]&&matrix[index1-1][index2]=='1'){\n        q.add(Arrays.asList(index1-1,index2));\n        }\n        if(index2-1>=0&&!visited[index1][index2-1]&&matrix[index1][index2-1]=='1')\n        q.add(Arrays.asList(index1,index2-1));\n        if(index1+1<matrix.length&&!visited[index1+1][index2]&&matrix[index1+1][index2]=='1')\n        q.add(Arrays.asList(index1+1,index2));\n        if(index2+1<matrix[index1].length&&!visited[index1][index2+1]&&matrix[index1][index2+1]=='1')\n        q.add(Arrays.asList(index1,index2+1));\n      \n    }\n  }\n}\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "vishious",
                        "content": "I\\'m new to graphs topic. So far I have only practiced problems with adjacency matrix. Is the given input an adjacency list ?"
                    }
                ]
            },
            {
                "id": 2014533,
                "content": [
                    {
                        "username": "HYJi",
                        "content": "why the number of islands equals to the num of connected areas"
                    },
                    {
                        "username": "DumpGuy",
                        "content": "[[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]\\n\\nIt shows three. Is it not one ? Can any explain me , where my thought has gone wrong ?  I can see link between 3rd row and second row ."
                    },
                    {
                        "username": "gbhamra",
                        "content": "I wasn't even able to think if we could use DFS here, is this really a medium level problem? After looking at the solution i feel it should be in Hard category. If at all it matters."
                    },
                    {
                        "username": "sonulamba241034",
                        "content": "i just started to learn graphs. i read bfs technique but still i am unable to think this grid/ matrix as a graph. plz someone help me out \"how can i visualize it as a graph not like matrix\". \\n\\n"
                    },
                    {
                        "username": "akmuir",
                        "content": "For those who are getting stuck on test case 47 or 48. This may be because you have too many conditionals in either your dfs or bfs and it needs to be cut down to not have to go through so many iterations. This doesn\\'t mean reducing the requirements, it simply means having the recursive functions be called in such a way that you don\\'t have to check as much."
                    },
                    {
                        "username": "leonardo_po",
                        "content": "I keep getting TLE with my BFS solution using a queue, can someone help me please?\nDon't look at the following content if you don't want to see a solution.\n`\n class Solution(object):\n    def numIslands(self, grid):\n         count = 0\n        visited = [[False for i in range(len(grid[0]))] for j in range(len(grid))]\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        def BFS(start_i, start_j):\n            queue = [(start_i, start_j)]\n\n            while queue:\n                curr_i, curr_j = queue.pop(0)\n                visited[curr_i][curr_j] = True\n\n                for add_i, add_j in directions:\n                    i = curr_i + add_i\n                    j = curr_j + add_j\n                    if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not visited[i][j] and grid[i][j] == '1':\n                        queue.append((i, j)) \n\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == '1' and not visited[i][j]:\n                    BFS(i, j)\n                    count += 1\n\n        return count\n`"
                    },
                    {
                        "username": "SandeepRoy",
                        "content": "If asked to check for land diagonally, then?"
                    },
                    {
                        "username": "akmuir",
                        "content": "then check for land diagonally"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "Yo, i have a solution but it\\'s exceeding the time limit, it seems to be similar to many AC\\'s, due to which I\\'m confused as to why this particular solution exceeds the time limit. I cant post it on here, as it\\'ll get deleted. Could I DM any of you to figure out the issue"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "Can someone explain why time limit exceeds for this given solutions : \n``` `your inline code...your inline code...`\n`class Solution {\n    `public int numIslands(char[][] matrix) {\n      `   int totalIslands = 0;\n    boolean visited [][] = new boolean[matrix.length][matrix[0].length];\n    for(int i = 0;i<matrix.length;i++){\n      for(int j = 0;j<matrix[i].length;j++){\n        if(matrix[i][j]=='1' && !visited[i][j]){\n          totalIslands++;\n          traverse(i,j,matrix,visited);\n        }\n      }\n      \n    }\n    return totalIslands;\n\n}\n public void traverse(int i, int j, char matrix[][],boolean visited[][]){\n    Queue<List<Integer>> q = new LinkedList<>();\n    q.add(Arrays.asList(i,j));\n    while(!q.isEmpty()){\n      List<Integer> li = q.remove();\n        int index1 = li.get(0);\n        int index2 = li.get(1);\n        visited[index1][index2] = true;\n        if(index1-1>=0&&!visited[index1-1][index2]&&matrix[index1-1][index2]=='1'){\n        q.add(Arrays.asList(index1-1,index2));\n        }\n        if(index2-1>=0&&!visited[index1][index2-1]&&matrix[index1][index2-1]=='1')\n        q.add(Arrays.asList(index1,index2-1));\n        if(index1+1<matrix.length&&!visited[index1+1][index2]&&matrix[index1+1][index2]=='1')\n        q.add(Arrays.asList(index1+1,index2));\n        if(index2+1<matrix[index1].length&&!visited[index1][index2+1]&&matrix[index1][index2+1]=='1')\n        q.add(Arrays.asList(index1,index2+1));\n      \n    }\n  }\n}\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "vishious",
                        "content": "I\\'m new to graphs topic. So far I have only practiced problems with adjacency matrix. Is the given input an adjacency list ?"
                    }
                ]
            },
            {
                "id": 2005279,
                "content": [
                    {
                        "username": "HYJi",
                        "content": "why the number of islands equals to the num of connected areas"
                    },
                    {
                        "username": "DumpGuy",
                        "content": "[[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]\\n\\nIt shows three. Is it not one ? Can any explain me , where my thought has gone wrong ?  I can see link between 3rd row and second row ."
                    },
                    {
                        "username": "gbhamra",
                        "content": "I wasn't even able to think if we could use DFS here, is this really a medium level problem? After looking at the solution i feel it should be in Hard category. If at all it matters."
                    },
                    {
                        "username": "sonulamba241034",
                        "content": "i just started to learn graphs. i read bfs technique but still i am unable to think this grid/ matrix as a graph. plz someone help me out \"how can i visualize it as a graph not like matrix\". \\n\\n"
                    },
                    {
                        "username": "akmuir",
                        "content": "For those who are getting stuck on test case 47 or 48. This may be because you have too many conditionals in either your dfs or bfs and it needs to be cut down to not have to go through so many iterations. This doesn\\'t mean reducing the requirements, it simply means having the recursive functions be called in such a way that you don\\'t have to check as much."
                    },
                    {
                        "username": "leonardo_po",
                        "content": "I keep getting TLE with my BFS solution using a queue, can someone help me please?\nDon't look at the following content if you don't want to see a solution.\n`\n class Solution(object):\n    def numIslands(self, grid):\n         count = 0\n        visited = [[False for i in range(len(grid[0]))] for j in range(len(grid))]\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        def BFS(start_i, start_j):\n            queue = [(start_i, start_j)]\n\n            while queue:\n                curr_i, curr_j = queue.pop(0)\n                visited[curr_i][curr_j] = True\n\n                for add_i, add_j in directions:\n                    i = curr_i + add_i\n                    j = curr_j + add_j\n                    if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not visited[i][j] and grid[i][j] == '1':\n                        queue.append((i, j)) \n\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == '1' and not visited[i][j]:\n                    BFS(i, j)\n                    count += 1\n\n        return count\n`"
                    },
                    {
                        "username": "SandeepRoy",
                        "content": "If asked to check for land diagonally, then?"
                    },
                    {
                        "username": "akmuir",
                        "content": "then check for land diagonally"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "Yo, i have a solution but it\\'s exceeding the time limit, it seems to be similar to many AC\\'s, due to which I\\'m confused as to why this particular solution exceeds the time limit. I cant post it on here, as it\\'ll get deleted. Could I DM any of you to figure out the issue"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "Can someone explain why time limit exceeds for this given solutions : \n``` `your inline code...your inline code...`\n`class Solution {\n    `public int numIslands(char[][] matrix) {\n      `   int totalIslands = 0;\n    boolean visited [][] = new boolean[matrix.length][matrix[0].length];\n    for(int i = 0;i<matrix.length;i++){\n      for(int j = 0;j<matrix[i].length;j++){\n        if(matrix[i][j]=='1' && !visited[i][j]){\n          totalIslands++;\n          traverse(i,j,matrix,visited);\n        }\n      }\n      \n    }\n    return totalIslands;\n\n}\n public void traverse(int i, int j, char matrix[][],boolean visited[][]){\n    Queue<List<Integer>> q = new LinkedList<>();\n    q.add(Arrays.asList(i,j));\n    while(!q.isEmpty()){\n      List<Integer> li = q.remove();\n        int index1 = li.get(0);\n        int index2 = li.get(1);\n        visited[index1][index2] = true;\n        if(index1-1>=0&&!visited[index1-1][index2]&&matrix[index1-1][index2]=='1'){\n        q.add(Arrays.asList(index1-1,index2));\n        }\n        if(index2-1>=0&&!visited[index1][index2-1]&&matrix[index1][index2-1]=='1')\n        q.add(Arrays.asList(index1,index2-1));\n        if(index1+1<matrix.length&&!visited[index1+1][index2]&&matrix[index1+1][index2]=='1')\n        q.add(Arrays.asList(index1+1,index2));\n        if(index2+1<matrix[index1].length&&!visited[index1][index2+1]&&matrix[index1][index2+1]=='1')\n        q.add(Arrays.asList(index1,index2+1));\n      \n    }\n  }\n}\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "vishious",
                        "content": "I\\'m new to graphs topic. So far I have only practiced problems with adjacency matrix. Is the given input an adjacency list ?"
                    }
                ]
            },
            {
                "id": 2001154,
                "content": [
                    {
                        "username": "sos1104",
                        "content": "That\\'s definitely not a medium question that one can do in an interview for 15 minutes..."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem is easy with DFS but BFS is tougher "
                    },
                    {
                        "username": "agforero",
                        "content": "Making the tiles `\\'0\\'` and `\\'1\\'` instead of `0` or `1` wasted 15 minutes of my precious, singular life"
                    },
                    {
                        "username": "mochiball",
                        "content": "Haha facts. But we have no one to blame but outselves cus we should be reading the problem constraints "
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "can anyone tell me why this code gives TLE , I removed the vis vector and changed the grid from 1 to 0 on vist and this dosent gives TLE why?\n\n\n\n    vector<int>drow={-1,0,1,0}; vector<int>dcol={0,-1,0,1};\n    void dfs(int i, int j, vector<vector<int>>&vis, vector<vector<char>>&grid,queue<pair<int,int>>&q){\n        int n=grid.size(); int m=grid[0].size();\n        while(!q.empty()){\n            auto it=q.front(); q.pop();\n            int r=it.first; int c=it.second; vis[r][c]=1;\n            for(int i=0;i<4;i++){\n                int nr=r+drow[i]; int nc=c+dcol[i];\n                if(nr>=0 && nr<n && nc>=0 && nc<m && vis[nr][nc]==0 && grid[nr][nc]=='1'){\n                    q.push({nr,nc});\n                }\n            }\n        }\n\n    }\n\n    int numIslands(vector<vector<char>>& grid) {\n        int ans=0;\n        int n=grid.size(); int m=grid[0].size();\n        vector<vector<int>>vis(n,vector<int>(m,0));\n        \n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                if(grid[i][j]=='1' && vis[i][j]==0){\n                    queue<pair<int,int>>q;\n                    q.push({i,j});\n                    dfs(i,j,vis,grid,q); ans++;\n                }\n            }\n        }\n        return ans;\n  "
                    },
                    {
                        "username": "kennyhml",
                        "content": "This is a great medium problem! Not super easy but actually very achievable with some thought."
                    },
                    {
                        "username": "yashporwal321",
                        "content": "I\\'ve been encountering  wrong answer in testcase 47 , where the test case is \\n[[\"1\"],[\"0\"],[\"1\"],[\"0\"],[\"1\"],[\"1\"]]\\n\\nsince there are brackets it is taking it as a 6 rows and 1 column,  in other testcases it was working fine"
                    },
                    {
                        "username": "Aiden_Lee",
                        "content": "[[\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\"]]\\nwhy is the result 3 instead of 2?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "why should it be two , see it as a coloumn its like 6rows 1 coloumn"
                    },
                    {
                        "username": "srihitha_vanjarapu",
                        "content": "python code to find number of islands"
                    },
                    {
                        "username": "smedley101",
                        "content": "I have submitted the following solution with the exact same logic in C# which passes, but this solution in Python fails. Could someone please help me understand what is wrong with this solution? Thanks!\\n `class Solution:\\n\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        result = 0\\n        def dfs(row, col):\\n            try:\\n                if(grid[row][col] != \"1\"):\\n                    return None\\n                grid[row][col] = \"0\"\\n                dfs(row+1, col)\\n                dfs(row-1, col)\\n                dfs(row, col+1)\\n                dfs(row, col-1)\\n                return None\\n            except:\\n                return None\\n        for i, row in enumerate(grid):\\n            for j, col in enumerate(grid[i]):\\n                if(grid[i][j] == \"1\"):\\n                    result += 1\\n                    dfs(i,j)\\n        return result`"
                    },
                    {
                        "username": "pkekheshramkrel7543",
                        "content": "Anyone know why this error occurs?\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-use-after-free on address 0x608000000038 at pc 0x00000034d11a bp 0x7ffea782e350 sp 0x7ffea782e348\\nREAD of size 8 at 0x608000000038 thread T0\\n    #2 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x608000000038 is located 24 bytes inside of 96-byte region [0x608000000020,0x608000000080)\\nfreed by thread T0 here:\\n    #12 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\npreviously allocated by thread T0 here:\\n    #6 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c107fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c107fff8000: fa fa fa fa fd fd fd[fd]fd fd fd fd fd fd fd fd\\n  0x0c107fff8010: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8020: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8030: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8040: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8050: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING\\n"
                    }
                ]
            },
            {
                "id": 1996059,
                "content": [
                    {
                        "username": "sos1104",
                        "content": "That\\'s definitely not a medium question that one can do in an interview for 15 minutes..."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem is easy with DFS but BFS is tougher "
                    },
                    {
                        "username": "agforero",
                        "content": "Making the tiles `\\'0\\'` and `\\'1\\'` instead of `0` or `1` wasted 15 minutes of my precious, singular life"
                    },
                    {
                        "username": "mochiball",
                        "content": "Haha facts. But we have no one to blame but outselves cus we should be reading the problem constraints "
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "can anyone tell me why this code gives TLE , I removed the vis vector and changed the grid from 1 to 0 on vist and this dosent gives TLE why?\n\n\n\n    vector<int>drow={-1,0,1,0}; vector<int>dcol={0,-1,0,1};\n    void dfs(int i, int j, vector<vector<int>>&vis, vector<vector<char>>&grid,queue<pair<int,int>>&q){\n        int n=grid.size(); int m=grid[0].size();\n        while(!q.empty()){\n            auto it=q.front(); q.pop();\n            int r=it.first; int c=it.second; vis[r][c]=1;\n            for(int i=0;i<4;i++){\n                int nr=r+drow[i]; int nc=c+dcol[i];\n                if(nr>=0 && nr<n && nc>=0 && nc<m && vis[nr][nc]==0 && grid[nr][nc]=='1'){\n                    q.push({nr,nc});\n                }\n            }\n        }\n\n    }\n\n    int numIslands(vector<vector<char>>& grid) {\n        int ans=0;\n        int n=grid.size(); int m=grid[0].size();\n        vector<vector<int>>vis(n,vector<int>(m,0));\n        \n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                if(grid[i][j]=='1' && vis[i][j]==0){\n                    queue<pair<int,int>>q;\n                    q.push({i,j});\n                    dfs(i,j,vis,grid,q); ans++;\n                }\n            }\n        }\n        return ans;\n  "
                    },
                    {
                        "username": "kennyhml",
                        "content": "This is a great medium problem! Not super easy but actually very achievable with some thought."
                    },
                    {
                        "username": "yashporwal321",
                        "content": "I\\'ve been encountering  wrong answer in testcase 47 , where the test case is \\n[[\"1\"],[\"0\"],[\"1\"],[\"0\"],[\"1\"],[\"1\"]]\\n\\nsince there are brackets it is taking it as a 6 rows and 1 column,  in other testcases it was working fine"
                    },
                    {
                        "username": "Aiden_Lee",
                        "content": "[[\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\"]]\\nwhy is the result 3 instead of 2?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "why should it be two , see it as a coloumn its like 6rows 1 coloumn"
                    },
                    {
                        "username": "srihitha_vanjarapu",
                        "content": "python code to find number of islands"
                    },
                    {
                        "username": "smedley101",
                        "content": "I have submitted the following solution with the exact same logic in C# which passes, but this solution in Python fails. Could someone please help me understand what is wrong with this solution? Thanks!\\n `class Solution:\\n\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        result = 0\\n        def dfs(row, col):\\n            try:\\n                if(grid[row][col] != \"1\"):\\n                    return None\\n                grid[row][col] = \"0\"\\n                dfs(row+1, col)\\n                dfs(row-1, col)\\n                dfs(row, col+1)\\n                dfs(row, col-1)\\n                return None\\n            except:\\n                return None\\n        for i, row in enumerate(grid):\\n            for j, col in enumerate(grid[i]):\\n                if(grid[i][j] == \"1\"):\\n                    result += 1\\n                    dfs(i,j)\\n        return result`"
                    },
                    {
                        "username": "pkekheshramkrel7543",
                        "content": "Anyone know why this error occurs?\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-use-after-free on address 0x608000000038 at pc 0x00000034d11a bp 0x7ffea782e350 sp 0x7ffea782e348\\nREAD of size 8 at 0x608000000038 thread T0\\n    #2 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x608000000038 is located 24 bytes inside of 96-byte region [0x608000000020,0x608000000080)\\nfreed by thread T0 here:\\n    #12 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\npreviously allocated by thread T0 here:\\n    #6 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c107fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c107fff8000: fa fa fa fa fd fd fd[fd]fd fd fd fd fd fd fd fd\\n  0x0c107fff8010: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8020: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8030: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8040: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8050: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING\\n"
                    }
                ]
            },
            {
                "id": 1990756,
                "content": [
                    {
                        "username": "sos1104",
                        "content": "That\\'s definitely not a medium question that one can do in an interview for 15 minutes..."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem is easy with DFS but BFS is tougher "
                    },
                    {
                        "username": "agforero",
                        "content": "Making the tiles `\\'0\\'` and `\\'1\\'` instead of `0` or `1` wasted 15 minutes of my precious, singular life"
                    },
                    {
                        "username": "mochiball",
                        "content": "Haha facts. But we have no one to blame but outselves cus we should be reading the problem constraints "
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "can anyone tell me why this code gives TLE , I removed the vis vector and changed the grid from 1 to 0 on vist and this dosent gives TLE why?\n\n\n\n    vector<int>drow={-1,0,1,0}; vector<int>dcol={0,-1,0,1};\n    void dfs(int i, int j, vector<vector<int>>&vis, vector<vector<char>>&grid,queue<pair<int,int>>&q){\n        int n=grid.size(); int m=grid[0].size();\n        while(!q.empty()){\n            auto it=q.front(); q.pop();\n            int r=it.first; int c=it.second; vis[r][c]=1;\n            for(int i=0;i<4;i++){\n                int nr=r+drow[i]; int nc=c+dcol[i];\n                if(nr>=0 && nr<n && nc>=0 && nc<m && vis[nr][nc]==0 && grid[nr][nc]=='1'){\n                    q.push({nr,nc});\n                }\n            }\n        }\n\n    }\n\n    int numIslands(vector<vector<char>>& grid) {\n        int ans=0;\n        int n=grid.size(); int m=grid[0].size();\n        vector<vector<int>>vis(n,vector<int>(m,0));\n        \n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                if(grid[i][j]=='1' && vis[i][j]==0){\n                    queue<pair<int,int>>q;\n                    q.push({i,j});\n                    dfs(i,j,vis,grid,q); ans++;\n                }\n            }\n        }\n        return ans;\n  "
                    },
                    {
                        "username": "kennyhml",
                        "content": "This is a great medium problem! Not super easy but actually very achievable with some thought."
                    },
                    {
                        "username": "yashporwal321",
                        "content": "I\\'ve been encountering  wrong answer in testcase 47 , where the test case is \\n[[\"1\"],[\"0\"],[\"1\"],[\"0\"],[\"1\"],[\"1\"]]\\n\\nsince there are brackets it is taking it as a 6 rows and 1 column,  in other testcases it was working fine"
                    },
                    {
                        "username": "Aiden_Lee",
                        "content": "[[\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\"]]\\nwhy is the result 3 instead of 2?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "why should it be two , see it as a coloumn its like 6rows 1 coloumn"
                    },
                    {
                        "username": "srihitha_vanjarapu",
                        "content": "python code to find number of islands"
                    },
                    {
                        "username": "smedley101",
                        "content": "I have submitted the following solution with the exact same logic in C# which passes, but this solution in Python fails. Could someone please help me understand what is wrong with this solution? Thanks!\\n `class Solution:\\n\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        result = 0\\n        def dfs(row, col):\\n            try:\\n                if(grid[row][col] != \"1\"):\\n                    return None\\n                grid[row][col] = \"0\"\\n                dfs(row+1, col)\\n                dfs(row-1, col)\\n                dfs(row, col+1)\\n                dfs(row, col-1)\\n                return None\\n            except:\\n                return None\\n        for i, row in enumerate(grid):\\n            for j, col in enumerate(grid[i]):\\n                if(grid[i][j] == \"1\"):\\n                    result += 1\\n                    dfs(i,j)\\n        return result`"
                    },
                    {
                        "username": "pkekheshramkrel7543",
                        "content": "Anyone know why this error occurs?\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-use-after-free on address 0x608000000038 at pc 0x00000034d11a bp 0x7ffea782e350 sp 0x7ffea782e348\\nREAD of size 8 at 0x608000000038 thread T0\\n    #2 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x608000000038 is located 24 bytes inside of 96-byte region [0x608000000020,0x608000000080)\\nfreed by thread T0 here:\\n    #12 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\npreviously allocated by thread T0 here:\\n    #6 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c107fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c107fff8000: fa fa fa fa fd fd fd[fd]fd fd fd fd fd fd fd fd\\n  0x0c107fff8010: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8020: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8030: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8040: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8050: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING\\n"
                    }
                ]
            },
            {
                "id": 1982435,
                "content": [
                    {
                        "username": "sos1104",
                        "content": "That\\'s definitely not a medium question that one can do in an interview for 15 minutes..."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem is easy with DFS but BFS is tougher "
                    },
                    {
                        "username": "agforero",
                        "content": "Making the tiles `\\'0\\'` and `\\'1\\'` instead of `0` or `1` wasted 15 minutes of my precious, singular life"
                    },
                    {
                        "username": "mochiball",
                        "content": "Haha facts. But we have no one to blame but outselves cus we should be reading the problem constraints "
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "can anyone tell me why this code gives TLE , I removed the vis vector and changed the grid from 1 to 0 on vist and this dosent gives TLE why?\n\n\n\n    vector<int>drow={-1,0,1,0}; vector<int>dcol={0,-1,0,1};\n    void dfs(int i, int j, vector<vector<int>>&vis, vector<vector<char>>&grid,queue<pair<int,int>>&q){\n        int n=grid.size(); int m=grid[0].size();\n        while(!q.empty()){\n            auto it=q.front(); q.pop();\n            int r=it.first; int c=it.second; vis[r][c]=1;\n            for(int i=0;i<4;i++){\n                int nr=r+drow[i]; int nc=c+dcol[i];\n                if(nr>=0 && nr<n && nc>=0 && nc<m && vis[nr][nc]==0 && grid[nr][nc]=='1'){\n                    q.push({nr,nc});\n                }\n            }\n        }\n\n    }\n\n    int numIslands(vector<vector<char>>& grid) {\n        int ans=0;\n        int n=grid.size(); int m=grid[0].size();\n        vector<vector<int>>vis(n,vector<int>(m,0));\n        \n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                if(grid[i][j]=='1' && vis[i][j]==0){\n                    queue<pair<int,int>>q;\n                    q.push({i,j});\n                    dfs(i,j,vis,grid,q); ans++;\n                }\n            }\n        }\n        return ans;\n  "
                    },
                    {
                        "username": "kennyhml",
                        "content": "This is a great medium problem! Not super easy but actually very achievable with some thought."
                    },
                    {
                        "username": "yashporwal321",
                        "content": "I\\'ve been encountering  wrong answer in testcase 47 , where the test case is \\n[[\"1\"],[\"0\"],[\"1\"],[\"0\"],[\"1\"],[\"1\"]]\\n\\nsince there are brackets it is taking it as a 6 rows and 1 column,  in other testcases it was working fine"
                    },
                    {
                        "username": "Aiden_Lee",
                        "content": "[[\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\"]]\\nwhy is the result 3 instead of 2?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "why should it be two , see it as a coloumn its like 6rows 1 coloumn"
                    },
                    {
                        "username": "srihitha_vanjarapu",
                        "content": "python code to find number of islands"
                    },
                    {
                        "username": "smedley101",
                        "content": "I have submitted the following solution with the exact same logic in C# which passes, but this solution in Python fails. Could someone please help me understand what is wrong with this solution? Thanks!\\n `class Solution:\\n\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        result = 0\\n        def dfs(row, col):\\n            try:\\n                if(grid[row][col] != \"1\"):\\n                    return None\\n                grid[row][col] = \"0\"\\n                dfs(row+1, col)\\n                dfs(row-1, col)\\n                dfs(row, col+1)\\n                dfs(row, col-1)\\n                return None\\n            except:\\n                return None\\n        for i, row in enumerate(grid):\\n            for j, col in enumerate(grid[i]):\\n                if(grid[i][j] == \"1\"):\\n                    result += 1\\n                    dfs(i,j)\\n        return result`"
                    },
                    {
                        "username": "pkekheshramkrel7543",
                        "content": "Anyone know why this error occurs?\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-use-after-free on address 0x608000000038 at pc 0x00000034d11a bp 0x7ffea782e350 sp 0x7ffea782e348\\nREAD of size 8 at 0x608000000038 thread T0\\n    #2 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x608000000038 is located 24 bytes inside of 96-byte region [0x608000000020,0x608000000080)\\nfreed by thread T0 here:\\n    #12 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\npreviously allocated by thread T0 here:\\n    #6 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c107fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c107fff8000: fa fa fa fa fd fd fd[fd]fd fd fd fd fd fd fd fd\\n  0x0c107fff8010: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8020: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8030: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8040: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8050: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING\\n"
                    }
                ]
            },
            {
                "id": 1973057,
                "content": [
                    {
                        "username": "sos1104",
                        "content": "That\\'s definitely not a medium question that one can do in an interview for 15 minutes..."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem is easy with DFS but BFS is tougher "
                    },
                    {
                        "username": "agforero",
                        "content": "Making the tiles `\\'0\\'` and `\\'1\\'` instead of `0` or `1` wasted 15 minutes of my precious, singular life"
                    },
                    {
                        "username": "mochiball",
                        "content": "Haha facts. But we have no one to blame but outselves cus we should be reading the problem constraints "
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "can anyone tell me why this code gives TLE , I removed the vis vector and changed the grid from 1 to 0 on vist and this dosent gives TLE why?\n\n\n\n    vector<int>drow={-1,0,1,0}; vector<int>dcol={0,-1,0,1};\n    void dfs(int i, int j, vector<vector<int>>&vis, vector<vector<char>>&grid,queue<pair<int,int>>&q){\n        int n=grid.size(); int m=grid[0].size();\n        while(!q.empty()){\n            auto it=q.front(); q.pop();\n            int r=it.first; int c=it.second; vis[r][c]=1;\n            for(int i=0;i<4;i++){\n                int nr=r+drow[i]; int nc=c+dcol[i];\n                if(nr>=0 && nr<n && nc>=0 && nc<m && vis[nr][nc]==0 && grid[nr][nc]=='1'){\n                    q.push({nr,nc});\n                }\n            }\n        }\n\n    }\n\n    int numIslands(vector<vector<char>>& grid) {\n        int ans=0;\n        int n=grid.size(); int m=grid[0].size();\n        vector<vector<int>>vis(n,vector<int>(m,0));\n        \n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                if(grid[i][j]=='1' && vis[i][j]==0){\n                    queue<pair<int,int>>q;\n                    q.push({i,j});\n                    dfs(i,j,vis,grid,q); ans++;\n                }\n            }\n        }\n        return ans;\n  "
                    },
                    {
                        "username": "kennyhml",
                        "content": "This is a great medium problem! Not super easy but actually very achievable with some thought."
                    },
                    {
                        "username": "yashporwal321",
                        "content": "I\\'ve been encountering  wrong answer in testcase 47 , where the test case is \\n[[\"1\"],[\"0\"],[\"1\"],[\"0\"],[\"1\"],[\"1\"]]\\n\\nsince there are brackets it is taking it as a 6 rows and 1 column,  in other testcases it was working fine"
                    },
                    {
                        "username": "Aiden_Lee",
                        "content": "[[\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\"]]\\nwhy is the result 3 instead of 2?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "why should it be two , see it as a coloumn its like 6rows 1 coloumn"
                    },
                    {
                        "username": "srihitha_vanjarapu",
                        "content": "python code to find number of islands"
                    },
                    {
                        "username": "smedley101",
                        "content": "I have submitted the following solution with the exact same logic in C# which passes, but this solution in Python fails. Could someone please help me understand what is wrong with this solution? Thanks!\\n `class Solution:\\n\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        result = 0\\n        def dfs(row, col):\\n            try:\\n                if(grid[row][col] != \"1\"):\\n                    return None\\n                grid[row][col] = \"0\"\\n                dfs(row+1, col)\\n                dfs(row-1, col)\\n                dfs(row, col+1)\\n                dfs(row, col-1)\\n                return None\\n            except:\\n                return None\\n        for i, row in enumerate(grid):\\n            for j, col in enumerate(grid[i]):\\n                if(grid[i][j] == \"1\"):\\n                    result += 1\\n                    dfs(i,j)\\n        return result`"
                    },
                    {
                        "username": "pkekheshramkrel7543",
                        "content": "Anyone know why this error occurs?\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-use-after-free on address 0x608000000038 at pc 0x00000034d11a bp 0x7ffea782e350 sp 0x7ffea782e348\\nREAD of size 8 at 0x608000000038 thread T0\\n    #2 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x608000000038 is located 24 bytes inside of 96-byte region [0x608000000020,0x608000000080)\\nfreed by thread T0 here:\\n    #12 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\npreviously allocated by thread T0 here:\\n    #6 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c107fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c107fff8000: fa fa fa fa fd fd fd[fd]fd fd fd fd fd fd fd fd\\n  0x0c107fff8010: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8020: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8030: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8040: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8050: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING\\n"
                    }
                ]
            },
            {
                "id": 1941733,
                "content": [
                    {
                        "username": "sos1104",
                        "content": "That\\'s definitely not a medium question that one can do in an interview for 15 minutes..."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem is easy with DFS but BFS is tougher "
                    },
                    {
                        "username": "agforero",
                        "content": "Making the tiles `\\'0\\'` and `\\'1\\'` instead of `0` or `1` wasted 15 minutes of my precious, singular life"
                    },
                    {
                        "username": "mochiball",
                        "content": "Haha facts. But we have no one to blame but outselves cus we should be reading the problem constraints "
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "can anyone tell me why this code gives TLE , I removed the vis vector and changed the grid from 1 to 0 on vist and this dosent gives TLE why?\n\n\n\n    vector<int>drow={-1,0,1,0}; vector<int>dcol={0,-1,0,1};\n    void dfs(int i, int j, vector<vector<int>>&vis, vector<vector<char>>&grid,queue<pair<int,int>>&q){\n        int n=grid.size(); int m=grid[0].size();\n        while(!q.empty()){\n            auto it=q.front(); q.pop();\n            int r=it.first; int c=it.second; vis[r][c]=1;\n            for(int i=0;i<4;i++){\n                int nr=r+drow[i]; int nc=c+dcol[i];\n                if(nr>=0 && nr<n && nc>=0 && nc<m && vis[nr][nc]==0 && grid[nr][nc]=='1'){\n                    q.push({nr,nc});\n                }\n            }\n        }\n\n    }\n\n    int numIslands(vector<vector<char>>& grid) {\n        int ans=0;\n        int n=grid.size(); int m=grid[0].size();\n        vector<vector<int>>vis(n,vector<int>(m,0));\n        \n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                if(grid[i][j]=='1' && vis[i][j]==0){\n                    queue<pair<int,int>>q;\n                    q.push({i,j});\n                    dfs(i,j,vis,grid,q); ans++;\n                }\n            }\n        }\n        return ans;\n  "
                    },
                    {
                        "username": "kennyhml",
                        "content": "This is a great medium problem! Not super easy but actually very achievable with some thought."
                    },
                    {
                        "username": "yashporwal321",
                        "content": "I\\'ve been encountering  wrong answer in testcase 47 , where the test case is \\n[[\"1\"],[\"0\"],[\"1\"],[\"0\"],[\"1\"],[\"1\"]]\\n\\nsince there are brackets it is taking it as a 6 rows and 1 column,  in other testcases it was working fine"
                    },
                    {
                        "username": "Aiden_Lee",
                        "content": "[[\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\"]]\\nwhy is the result 3 instead of 2?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "why should it be two , see it as a coloumn its like 6rows 1 coloumn"
                    },
                    {
                        "username": "srihitha_vanjarapu",
                        "content": "python code to find number of islands"
                    },
                    {
                        "username": "smedley101",
                        "content": "I have submitted the following solution with the exact same logic in C# which passes, but this solution in Python fails. Could someone please help me understand what is wrong with this solution? Thanks!\\n `class Solution:\\n\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        result = 0\\n        def dfs(row, col):\\n            try:\\n                if(grid[row][col] != \"1\"):\\n                    return None\\n                grid[row][col] = \"0\"\\n                dfs(row+1, col)\\n                dfs(row-1, col)\\n                dfs(row, col+1)\\n                dfs(row, col-1)\\n                return None\\n            except:\\n                return None\\n        for i, row in enumerate(grid):\\n            for j, col in enumerate(grid[i]):\\n                if(grid[i][j] == \"1\"):\\n                    result += 1\\n                    dfs(i,j)\\n        return result`"
                    },
                    {
                        "username": "pkekheshramkrel7543",
                        "content": "Anyone know why this error occurs?\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-use-after-free on address 0x608000000038 at pc 0x00000034d11a bp 0x7ffea782e350 sp 0x7ffea782e348\\nREAD of size 8 at 0x608000000038 thread T0\\n    #2 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x608000000038 is located 24 bytes inside of 96-byte region [0x608000000020,0x608000000080)\\nfreed by thread T0 here:\\n    #12 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\npreviously allocated by thread T0 here:\\n    #6 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c107fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c107fff8000: fa fa fa fa fd fd fd[fd]fd fd fd fd fd fd fd fd\\n  0x0c107fff8010: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8020: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8030: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8040: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8050: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING\\n"
                    }
                ]
            },
            {
                "id": 1929666,
                "content": [
                    {
                        "username": "sos1104",
                        "content": "That\\'s definitely not a medium question that one can do in an interview for 15 minutes..."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem is easy with DFS but BFS is tougher "
                    },
                    {
                        "username": "agforero",
                        "content": "Making the tiles `\\'0\\'` and `\\'1\\'` instead of `0` or `1` wasted 15 minutes of my precious, singular life"
                    },
                    {
                        "username": "mochiball",
                        "content": "Haha facts. But we have no one to blame but outselves cus we should be reading the problem constraints "
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "can anyone tell me why this code gives TLE , I removed the vis vector and changed the grid from 1 to 0 on vist and this dosent gives TLE why?\n\n\n\n    vector<int>drow={-1,0,1,0}; vector<int>dcol={0,-1,0,1};\n    void dfs(int i, int j, vector<vector<int>>&vis, vector<vector<char>>&grid,queue<pair<int,int>>&q){\n        int n=grid.size(); int m=grid[0].size();\n        while(!q.empty()){\n            auto it=q.front(); q.pop();\n            int r=it.first; int c=it.second; vis[r][c]=1;\n            for(int i=0;i<4;i++){\n                int nr=r+drow[i]; int nc=c+dcol[i];\n                if(nr>=0 && nr<n && nc>=0 && nc<m && vis[nr][nc]==0 && grid[nr][nc]=='1'){\n                    q.push({nr,nc});\n                }\n            }\n        }\n\n    }\n\n    int numIslands(vector<vector<char>>& grid) {\n        int ans=0;\n        int n=grid.size(); int m=grid[0].size();\n        vector<vector<int>>vis(n,vector<int>(m,0));\n        \n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                if(grid[i][j]=='1' && vis[i][j]==0){\n                    queue<pair<int,int>>q;\n                    q.push({i,j});\n                    dfs(i,j,vis,grid,q); ans++;\n                }\n            }\n        }\n        return ans;\n  "
                    },
                    {
                        "username": "kennyhml",
                        "content": "This is a great medium problem! Not super easy but actually very achievable with some thought."
                    },
                    {
                        "username": "yashporwal321",
                        "content": "I\\'ve been encountering  wrong answer in testcase 47 , where the test case is \\n[[\"1\"],[\"0\"],[\"1\"],[\"0\"],[\"1\"],[\"1\"]]\\n\\nsince there are brackets it is taking it as a 6 rows and 1 column,  in other testcases it was working fine"
                    },
                    {
                        "username": "Aiden_Lee",
                        "content": "[[\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\"]]\\nwhy is the result 3 instead of 2?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "why should it be two , see it as a coloumn its like 6rows 1 coloumn"
                    },
                    {
                        "username": "srihitha_vanjarapu",
                        "content": "python code to find number of islands"
                    },
                    {
                        "username": "smedley101",
                        "content": "I have submitted the following solution with the exact same logic in C# which passes, but this solution in Python fails. Could someone please help me understand what is wrong with this solution? Thanks!\\n `class Solution:\\n\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        result = 0\\n        def dfs(row, col):\\n            try:\\n                if(grid[row][col] != \"1\"):\\n                    return None\\n                grid[row][col] = \"0\"\\n                dfs(row+1, col)\\n                dfs(row-1, col)\\n                dfs(row, col+1)\\n                dfs(row, col-1)\\n                return None\\n            except:\\n                return None\\n        for i, row in enumerate(grid):\\n            for j, col in enumerate(grid[i]):\\n                if(grid[i][j] == \"1\"):\\n                    result += 1\\n                    dfs(i,j)\\n        return result`"
                    },
                    {
                        "username": "pkekheshramkrel7543",
                        "content": "Anyone know why this error occurs?\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-use-after-free on address 0x608000000038 at pc 0x00000034d11a bp 0x7ffea782e350 sp 0x7ffea782e348\\nREAD of size 8 at 0x608000000038 thread T0\\n    #2 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x608000000038 is located 24 bytes inside of 96-byte region [0x608000000020,0x608000000080)\\nfreed by thread T0 here:\\n    #12 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\npreviously allocated by thread T0 here:\\n    #6 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c107fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c107fff8000: fa fa fa fa fd fd fd[fd]fd fd fd fd fd fd fd fd\\n  0x0c107fff8010: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8020: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8030: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8040: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8050: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING\\n"
                    }
                ]
            },
            {
                "id": 1919838,
                "content": [
                    {
                        "username": "sos1104",
                        "content": "That\\'s definitely not a medium question that one can do in an interview for 15 minutes..."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem is easy with DFS but BFS is tougher "
                    },
                    {
                        "username": "agforero",
                        "content": "Making the tiles `\\'0\\'` and `\\'1\\'` instead of `0` or `1` wasted 15 minutes of my precious, singular life"
                    },
                    {
                        "username": "mochiball",
                        "content": "Haha facts. But we have no one to blame but outselves cus we should be reading the problem constraints "
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "can anyone tell me why this code gives TLE , I removed the vis vector and changed the grid from 1 to 0 on vist and this dosent gives TLE why?\n\n\n\n    vector<int>drow={-1,0,1,0}; vector<int>dcol={0,-1,0,1};\n    void dfs(int i, int j, vector<vector<int>>&vis, vector<vector<char>>&grid,queue<pair<int,int>>&q){\n        int n=grid.size(); int m=grid[0].size();\n        while(!q.empty()){\n            auto it=q.front(); q.pop();\n            int r=it.first; int c=it.second; vis[r][c]=1;\n            for(int i=0;i<4;i++){\n                int nr=r+drow[i]; int nc=c+dcol[i];\n                if(nr>=0 && nr<n && nc>=0 && nc<m && vis[nr][nc]==0 && grid[nr][nc]=='1'){\n                    q.push({nr,nc});\n                }\n            }\n        }\n\n    }\n\n    int numIslands(vector<vector<char>>& grid) {\n        int ans=0;\n        int n=grid.size(); int m=grid[0].size();\n        vector<vector<int>>vis(n,vector<int>(m,0));\n        \n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                if(grid[i][j]=='1' && vis[i][j]==0){\n                    queue<pair<int,int>>q;\n                    q.push({i,j});\n                    dfs(i,j,vis,grid,q); ans++;\n                }\n            }\n        }\n        return ans;\n  "
                    },
                    {
                        "username": "kennyhml",
                        "content": "This is a great medium problem! Not super easy but actually very achievable with some thought."
                    },
                    {
                        "username": "yashporwal321",
                        "content": "I\\'ve been encountering  wrong answer in testcase 47 , where the test case is \\n[[\"1\"],[\"0\"],[\"1\"],[\"0\"],[\"1\"],[\"1\"]]\\n\\nsince there are brackets it is taking it as a 6 rows and 1 column,  in other testcases it was working fine"
                    },
                    {
                        "username": "Aiden_Lee",
                        "content": "[[\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\"]]\\nwhy is the result 3 instead of 2?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "why should it be two , see it as a coloumn its like 6rows 1 coloumn"
                    },
                    {
                        "username": "srihitha_vanjarapu",
                        "content": "python code to find number of islands"
                    },
                    {
                        "username": "smedley101",
                        "content": "I have submitted the following solution with the exact same logic in C# which passes, but this solution in Python fails. Could someone please help me understand what is wrong with this solution? Thanks!\\n `class Solution:\\n\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        result = 0\\n        def dfs(row, col):\\n            try:\\n                if(grid[row][col] != \"1\"):\\n                    return None\\n                grid[row][col] = \"0\"\\n                dfs(row+1, col)\\n                dfs(row-1, col)\\n                dfs(row, col+1)\\n                dfs(row, col-1)\\n                return None\\n            except:\\n                return None\\n        for i, row in enumerate(grid):\\n            for j, col in enumerate(grid[i]):\\n                if(grid[i][j] == \"1\"):\\n                    result += 1\\n                    dfs(i,j)\\n        return result`"
                    },
                    {
                        "username": "pkekheshramkrel7543",
                        "content": "Anyone know why this error occurs?\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-use-after-free on address 0x608000000038 at pc 0x00000034d11a bp 0x7ffea782e350 sp 0x7ffea782e348\\nREAD of size 8 at 0x608000000038 thread T0\\n    #2 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x608000000038 is located 24 bytes inside of 96-byte region [0x608000000020,0x608000000080)\\nfreed by thread T0 here:\\n    #12 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\npreviously allocated by thread T0 here:\\n    #6 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c107fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c107fff8000: fa fa fa fa fd fd fd[fd]fd fd fd fd fd fd fd fd\\n  0x0c107fff8010: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8020: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8030: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8040: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8050: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING\\n"
                    }
                ]
            },
            {
                "id": 1910266,
                "content": [
                    {
                        "username": "sos1104",
                        "content": "That\\'s definitely not a medium question that one can do in an interview for 15 minutes..."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem is easy with DFS but BFS is tougher "
                    },
                    {
                        "username": "agforero",
                        "content": "Making the tiles `\\'0\\'` and `\\'1\\'` instead of `0` or `1` wasted 15 minutes of my precious, singular life"
                    },
                    {
                        "username": "mochiball",
                        "content": "Haha facts. But we have no one to blame but outselves cus we should be reading the problem constraints "
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "can anyone tell me why this code gives TLE , I removed the vis vector and changed the grid from 1 to 0 on vist and this dosent gives TLE why?\n\n\n\n    vector<int>drow={-1,0,1,0}; vector<int>dcol={0,-1,0,1};\n    void dfs(int i, int j, vector<vector<int>>&vis, vector<vector<char>>&grid,queue<pair<int,int>>&q){\n        int n=grid.size(); int m=grid[0].size();\n        while(!q.empty()){\n            auto it=q.front(); q.pop();\n            int r=it.first; int c=it.second; vis[r][c]=1;\n            for(int i=0;i<4;i++){\n                int nr=r+drow[i]; int nc=c+dcol[i];\n                if(nr>=0 && nr<n && nc>=0 && nc<m && vis[nr][nc]==0 && grid[nr][nc]=='1'){\n                    q.push({nr,nc});\n                }\n            }\n        }\n\n    }\n\n    int numIslands(vector<vector<char>>& grid) {\n        int ans=0;\n        int n=grid.size(); int m=grid[0].size();\n        vector<vector<int>>vis(n,vector<int>(m,0));\n        \n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                if(grid[i][j]=='1' && vis[i][j]==0){\n                    queue<pair<int,int>>q;\n                    q.push({i,j});\n                    dfs(i,j,vis,grid,q); ans++;\n                }\n            }\n        }\n        return ans;\n  "
                    },
                    {
                        "username": "kennyhml",
                        "content": "This is a great medium problem! Not super easy but actually very achievable with some thought."
                    },
                    {
                        "username": "yashporwal321",
                        "content": "I\\'ve been encountering  wrong answer in testcase 47 , where the test case is \\n[[\"1\"],[\"0\"],[\"1\"],[\"0\"],[\"1\"],[\"1\"]]\\n\\nsince there are brackets it is taking it as a 6 rows and 1 column,  in other testcases it was working fine"
                    },
                    {
                        "username": "Aiden_Lee",
                        "content": "[[\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\"]]\\nwhy is the result 3 instead of 2?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "why should it be two , see it as a coloumn its like 6rows 1 coloumn"
                    },
                    {
                        "username": "srihitha_vanjarapu",
                        "content": "python code to find number of islands"
                    },
                    {
                        "username": "smedley101",
                        "content": "I have submitted the following solution with the exact same logic in C# which passes, but this solution in Python fails. Could someone please help me understand what is wrong with this solution? Thanks!\\n `class Solution:\\n\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        result = 0\\n        def dfs(row, col):\\n            try:\\n                if(grid[row][col] != \"1\"):\\n                    return None\\n                grid[row][col] = \"0\"\\n                dfs(row+1, col)\\n                dfs(row-1, col)\\n                dfs(row, col+1)\\n                dfs(row, col-1)\\n                return None\\n            except:\\n                return None\\n        for i, row in enumerate(grid):\\n            for j, col in enumerate(grid[i]):\\n                if(grid[i][j] == \"1\"):\\n                    result += 1\\n                    dfs(i,j)\\n        return result`"
                    },
                    {
                        "username": "pkekheshramkrel7543",
                        "content": "Anyone know why this error occurs?\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-use-after-free on address 0x608000000038 at pc 0x00000034d11a bp 0x7ffea782e350 sp 0x7ffea782e348\\nREAD of size 8 at 0x608000000038 thread T0\\n    #2 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x608000000038 is located 24 bytes inside of 96-byte region [0x608000000020,0x608000000080)\\nfreed by thread T0 here:\\n    #12 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\npreviously allocated by thread T0 here:\\n    #6 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c107fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c107fff8000: fa fa fa fa fd fd fd[fd]fd fd fd fd fd fd fd fd\\n  0x0c107fff8010: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8020: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8030: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8040: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8050: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING\\n"
                    }
                ]
            },
            {
                "id": 1891092,
                "content": [
                    {
                        "username": "sos1104",
                        "content": "That\\'s definitely not a medium question that one can do in an interview for 15 minutes..."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem is easy with DFS but BFS is tougher "
                    },
                    {
                        "username": "agforero",
                        "content": "Making the tiles `\\'0\\'` and `\\'1\\'` instead of `0` or `1` wasted 15 minutes of my precious, singular life"
                    },
                    {
                        "username": "mochiball",
                        "content": "Haha facts. But we have no one to blame but outselves cus we should be reading the problem constraints "
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "can anyone tell me why this code gives TLE , I removed the vis vector and changed the grid from 1 to 0 on vist and this dosent gives TLE why?\n\n\n\n    vector<int>drow={-1,0,1,0}; vector<int>dcol={0,-1,0,1};\n    void dfs(int i, int j, vector<vector<int>>&vis, vector<vector<char>>&grid,queue<pair<int,int>>&q){\n        int n=grid.size(); int m=grid[0].size();\n        while(!q.empty()){\n            auto it=q.front(); q.pop();\n            int r=it.first; int c=it.second; vis[r][c]=1;\n            for(int i=0;i<4;i++){\n                int nr=r+drow[i]; int nc=c+dcol[i];\n                if(nr>=0 && nr<n && nc>=0 && nc<m && vis[nr][nc]==0 && grid[nr][nc]=='1'){\n                    q.push({nr,nc});\n                }\n            }\n        }\n\n    }\n\n    int numIslands(vector<vector<char>>& grid) {\n        int ans=0;\n        int n=grid.size(); int m=grid[0].size();\n        vector<vector<int>>vis(n,vector<int>(m,0));\n        \n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                if(grid[i][j]=='1' && vis[i][j]==0){\n                    queue<pair<int,int>>q;\n                    q.push({i,j});\n                    dfs(i,j,vis,grid,q); ans++;\n                }\n            }\n        }\n        return ans;\n  "
                    },
                    {
                        "username": "kennyhml",
                        "content": "This is a great medium problem! Not super easy but actually very achievable with some thought."
                    },
                    {
                        "username": "yashporwal321",
                        "content": "I\\'ve been encountering  wrong answer in testcase 47 , where the test case is \\n[[\"1\"],[\"0\"],[\"1\"],[\"0\"],[\"1\"],[\"1\"]]\\n\\nsince there are brackets it is taking it as a 6 rows and 1 column,  in other testcases it was working fine"
                    },
                    {
                        "username": "Aiden_Lee",
                        "content": "[[\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\"]]\\nwhy is the result 3 instead of 2?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "why should it be two , see it as a coloumn its like 6rows 1 coloumn"
                    },
                    {
                        "username": "srihitha_vanjarapu",
                        "content": "python code to find number of islands"
                    },
                    {
                        "username": "smedley101",
                        "content": "I have submitted the following solution with the exact same logic in C# which passes, but this solution in Python fails. Could someone please help me understand what is wrong with this solution? Thanks!\\n `class Solution:\\n\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        result = 0\\n        def dfs(row, col):\\n            try:\\n                if(grid[row][col] != \"1\"):\\n                    return None\\n                grid[row][col] = \"0\"\\n                dfs(row+1, col)\\n                dfs(row-1, col)\\n                dfs(row, col+1)\\n                dfs(row, col-1)\\n                return None\\n            except:\\n                return None\\n        for i, row in enumerate(grid):\\n            for j, col in enumerate(grid[i]):\\n                if(grid[i][j] == \"1\"):\\n                    result += 1\\n                    dfs(i,j)\\n        return result`"
                    },
                    {
                        "username": "pkekheshramkrel7543",
                        "content": "Anyone know why this error occurs?\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-use-after-free on address 0x608000000038 at pc 0x00000034d11a bp 0x7ffea782e350 sp 0x7ffea782e348\\nREAD of size 8 at 0x608000000038 thread T0\\n    #2 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x608000000038 is located 24 bytes inside of 96-byte region [0x608000000020,0x608000000080)\\nfreed by thread T0 here:\\n    #12 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\npreviously allocated by thread T0 here:\\n    #6 0x7f05c9d4e082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c107fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c107fff8000: fa fa fa fa fd fd fd[fd]fd fd fd fd fd fd fd fd\\n  0x0c107fff8010: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8020: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8030: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8040: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\n  0x0c107fff8050: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING\\n"
                    }
                ]
            },
            {
                "id": 1873142,
                "content": [
                    {
                        "username": "avyayk",
                        "content": "So this BFS Python solution is overwritten compared to some of the solutions I see. But I don\\'t understand why it\\'s fundamentally too slow. I have this issue nearly every time I do a BFS\\n\\n`class Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n\\n        # Readability\\n        ROW, COLUMN = 0, 1\\n\\n        # Lambda to check if a square is in bounds\\n        inBounds = lambda coordinate: ( 0 <= coordinate[ROW] < len(grid) ) and ( 0 <= coordinate[COLUMN] < len( grid[0] ) )\\n        isLand = lambda coordinate: inBounds(coordinate) and grid[ coordinate[ROW] ][ coordinate[COLUMN] ] == \\'1\\'\\n\\n        # Track islands and their positions\\n        islandCount = 0\\n\\n        # Create a breadth first search queue\\n        cartographyQueue = []\\n        \\n        # Go through the grid and breadth first search\\n        for row in range( len(grid) ):\\n            for column in range( len(grid[0]) ):\\n                \\n                # If we\\'ve hit land, enqueue item and breadth first search to change all linked 1\\'s to 0\\'s\\n                if grid[row][column] == \\'1\\':\\n                    \\n                    # Increment the islandCount\\n                    islandCount += 1\\n\\n                    cartographyQueue.append( (row, column) )\\n\\n                    while cartographyQueue:\\n\\n                        currentPosition = cartographyQueue.pop(0)\\n\\n                        # Change the currentPosition to water so it has been \\'visited\\'\\n                        grid[ currentPosition[ROW] ][ currentPosition[COLUMN] ] = \\'0\\'\\n\\n                        # Search up down left and right\\n                        adjacentSquares = [ ( ( currentPosition[ROW]-1 ), currentPosition[COLUMN] ), ( (currentPosition[ROW]+1), currentPosition[COLUMN] ), ( currentPosition[ROW], currentPosition[COLUMN]-1 ), ( currentPosition[ROW], currentPosition[COLUMN]+1 ) ]\\n                        \\n                        # Enqueue valid neighbors \\n                        for neighbor in adjacentSquares:\\n                            if isLand(neighbor):\\n                                cartographyQueue.append( neighbor )\\n        \\n        # Final return\\n        return islandCount`"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "Please improve the question and description of the problem, these kind of lazy problem descriptions are useless to the problem solver. Glad I saw the top comment here."
                    },
                    {
                        "username": "runtimErr0r",
                        "content": "My DFS code is giving TLE on the 47th testcase, although the BFS one works fine. Someone please help me...\\n\\n `your inline code...your inline code...`\\nclass Solution {\\n\\nprivate:\\n\\n    void DFS(int r,int c,vector<vector<char>> grid,vector<vector<int>>& visited){\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(r<0||c<0||r==n||c==m) return;\\n        if(visited[r][c]==1||grid[r][c]!=\\'1\\') return;\\n        visited[r][c]=1;\\n        DFS(r-1,c,grid,visited);\\n        DFS(r,c-1,grid,visited);\\n        DFS(r+1,c,grid,visited);\\n        DFS(r,c+1,grid,visited);\\n    }\\n\\npublic:\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        int count=0;\\n        vector<vector<int>> visited(rows,vector<int>(cols,0));\\n        for(int row=0;row<rows;row++){\\n            for(int col=0;col<cols;col++){\\n                if(grid[row][col]==\\'1\\'&&!visited[row][col]){\\n                    count++;\\n                    DFS(row,col,grid,visited);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "SnappyBoye",
                        "content": "TLE.... thoughts?\\n```py\\nfrom collections import deque\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n\\n        def bfs(i,j, grid):\\n\\n            to_visit = deque([(i, j)])\\n\\n            while to_visit:\\n                curri, currj = to_visit[0]\\n                to_visit.popleft()\\n\\n                # mark current node \\n                grid[curri][currj] = \\'0\\'\\n                \\n                adj_dims = [(curri + 1, currj), (curri - 1, currj), \\\\\\n                    (curri, currj + 1), (curri, currj-1)]\\n                filtered = []\\n                \\n                # make sure not out of bounds\\n                for x, y in adj_dims:\\n                    m, n = len(grid), len(grid[0])\\n                    if x < m and x >= 0 and y < n and y >= 0:\\n                        filtered.append((x, y))\\n\\n                for x, y in filtered:\\n                    if grid[x][y] == \\'1\\':\\n                        to_visit.append((x, y))\\n            \\n        soln = 0\\n        for row in range(m):\\n            for col in range(n):\\n                if grid[row][col] == \\'1\\':\\n                    # see an island\\n                    soln += 1 \\n                    # mark it \\n                    bfs(row, col, grid)\\n                    \\n        return soln\\n\\n\\n\\n\\n\\n```"
                    },
                    {
                        "username": "whoami_112",
                        "content": "comment\\nWhy its giving TLE \\nclass Solution {\\npublic:\\n    vector<int>dx={1,-1,0,0,};\\n    vector<int>dy={0,0,-1,1,};\\n    int numIslands(vector<vector<char>>& grid) {\\n        int ans=0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==\\'0\\')continue;\\n                ans++;\\n                q.push({i,j});\\n                while(!q.empty()){\\n                    int x=q.front().first;\\n                    int y=q.front().second;\\n                    q.pop();\\n                    grid[x][y]=\\'0\\';\\n                    for(int k=0;k<4;k++){\\n                        if(x+dx[k]>=0 and x+dx[k]<n and y+dy[k]>=0 and y+dy[k]<m and grid[x+dx[k]][y+dy[k]]==\\'1\\')q.push({x+dx[k],y+dy[k]});\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Himanshu_78",
                        "content": "\\n/// WHY I AM NOT ABLE TO SUBMIT THIS SOLUTION, in my local IDE is working fine with same test cases. Leetcode showing WRONG ANS\\n\\nclass Solution {\\n\\n    int dx[] = {0, 1, 0 -1, 0};\\n    public int numIslands(char[][] grid) {\\n        int count = 0;\\n\\n       if (grid == null || grid.length == 0) return 0;\\n        \\n        boolean[][] vis = new boolean[grid.length][grid[0].length];\\n        for(int i = 0; i< grid.length; i++){\\n            for(int j = 0; j< grid[0].length; j++){\\n                if(grid[i][j] == \\'1\\' && !vis[i][j]){\\n                    count++;\\n                    find(i, j, grid, vis);\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public void find(int row, int col, char[][] grid, boolean[][] vis){\\n        vis[row][col] = true;\\n        Queue<Pair> p = new LinkedList<Pair>();\\n        p.add(new Pair(row, col));\\n\\n        while(!p.isEmpty()){\\n            Pair q = p.poll();\\n            int mRow = q.i;\\n            int mCol = q.j;\\n\\n            for(int i = 0; i< dx.length -1; i++){\\n                int cRow = mRow + dx[i];\\n                int cCol = mCol + dx[i + 1];\\n\\n                if(cRow >= 0 && cRow < grid.length && cCol >= 0 && cCol < grid[0].length &&\\n                !vis[cRow][cCol] && grid[cRow][cCol] == \\'1\\'){\\n                    vis[cRow][cCol] = true;\\n                    p.add(new Pair(cRow, cCol));\\n                    \\n                }\\n            }\\n        }\\n\\n    }\\n}\\n\\nclass Pair{\\n    int i;\\n    int j;\\n\\n    Pair(int i, int j){\\n        this.i = i;\\n        this.j = j;\\n    }\\n}"
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "the string \"1\" messed me up so bad but managed to fix it , just a little butthurt bout it "
                    },
                    {
                        "username": "sreshtha10",
                        "content": "Any idea how to optimize this solution? 47/49 cases passed\n\n```\n\nclass Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n\n        ROWS =  len(grid)\n        COLS = len(grid[0])\n\n        visited = []\n\n        def dfs(i,j,visited):\n            if(i<0 or j<0 or i>= ROWS or j>=COLS or grid[i][j] == '0' or (i,j) in visited):\n                return\n\n            visited.append((i,j))\n\n            dfs(i+1,j,visited)\n            dfs(i-1,j,visited)\n            dfs(i,j+1,visited)\n            dfs(i,j-1,visited)\n\n            return\n\n\n        \n        res = 0\n\n        for i in range(ROWS):\n            for j in range(COLS):\n                if grid[i][j] == '1' and (i,j) not in visited:\n                    res += 1\n                    dfs(i,j,visited)\n                    \n\n        return res \n\n\n\n\n```\n\n\n"
                    },
                    {
                        "username": "avyayk",
                        "content": "Your visited is a list and not a hashset. Using the in keyword will search linearly and not in O(1) time. Sorry dude, it\\'s a matter of like 3 characters"
                    },
                    {
                        "username": "LateStartToThings",
                        "content": "Don\\'t get why my solution is not quick enough to pass all the test cases. I feel like my BFS algorithm is effectively the same as most solutions...\\n\\nAny ideas?\\n\\n```java\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        // no empty grid edge case - m and n are >= 1\\n\\n        int islands = 0;\\n\\n        // each island is equal to completing a BFS search every time you find a \"1\" in the grid\\n        // to make sure we only consider that island once, we turn each visited \"1\" node into a \"0\"\\n        for (int i=0; i<grid.length; i++) {\\n            for (int j=0; j<grid[0].length; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    makeIsland(grid, i, j);\\n                    islands++;\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n\\n    // make an island at starting position (i,j) by using BFS to explore all neighbours\\n    private static void makeIsland(char[][] grid, int i, int j) {\\n        Queue<Pair<Integer, Integer>> q = new LinkedList<>();\\n        q.add(new Pair(i, j));\\n\\n        while (!q.isEmpty()) {\\n            Pair<Integer, Integer> p = q.poll();\\n            int pi = p.getKey(); int pj = p.getValue();\\n            grid[pi][pj] = \\'0\\';\\n\\n            List<Pair<Integer, Integer>> neighbours = neighbours(grid.length, grid[0].length, pi, pj);\\n            for (Pair<Integer, Integer> n : neighbours) {\\n                int ni = n.getKey();\\n                int nj = n.getValue();\\n                if (grid[ni][nj] == \\'1\\') {\\n                    q.add(new Pair(ni, nj));\\n                }\\n            }\\n        }\\n    }\\n\\n    // get all neighbours for any (i,j) in a (m x n) grid\\n    private static List<Pair<Integer, Integer>> neighbours(int m, int n, int i, int j) {\\n        List<Pair<Integer, Integer>> neighbours = new ArrayList<>();\\n\\n        // top, right, bottom, left respectively\\n        int[] di = {-1, 0, 1, 0};\\n        int[] dj = {0, 1, 0, -1};\\n        for (int k=0; k<di.length; k++) {\\n            int newI = i + di[k];\\n            int newJ = j + dj[k];\\n            if (newI >= 0 && newI < m && newJ >= 0 && newJ < n) {\\n                neighbours.add(new Pair<>(newI, newJ));\\n            }\\n        }\\n        return neighbours;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jethalol",
                        "content": "This should be easy level problem and not medium. Its literally just dfs and there are already plenty of problems like this"
                    }
                ]
            },
            {
                "id": 1867991,
                "content": [
                    {
                        "username": "avyayk",
                        "content": "So this BFS Python solution is overwritten compared to some of the solutions I see. But I don\\'t understand why it\\'s fundamentally too slow. I have this issue nearly every time I do a BFS\\n\\n`class Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n\\n        # Readability\\n        ROW, COLUMN = 0, 1\\n\\n        # Lambda to check if a square is in bounds\\n        inBounds = lambda coordinate: ( 0 <= coordinate[ROW] < len(grid) ) and ( 0 <= coordinate[COLUMN] < len( grid[0] ) )\\n        isLand = lambda coordinate: inBounds(coordinate) and grid[ coordinate[ROW] ][ coordinate[COLUMN] ] == \\'1\\'\\n\\n        # Track islands and their positions\\n        islandCount = 0\\n\\n        # Create a breadth first search queue\\n        cartographyQueue = []\\n        \\n        # Go through the grid and breadth first search\\n        for row in range( len(grid) ):\\n            for column in range( len(grid[0]) ):\\n                \\n                # If we\\'ve hit land, enqueue item and breadth first search to change all linked 1\\'s to 0\\'s\\n                if grid[row][column] == \\'1\\':\\n                    \\n                    # Increment the islandCount\\n                    islandCount += 1\\n\\n                    cartographyQueue.append( (row, column) )\\n\\n                    while cartographyQueue:\\n\\n                        currentPosition = cartographyQueue.pop(0)\\n\\n                        # Change the currentPosition to water so it has been \\'visited\\'\\n                        grid[ currentPosition[ROW] ][ currentPosition[COLUMN] ] = \\'0\\'\\n\\n                        # Search up down left and right\\n                        adjacentSquares = [ ( ( currentPosition[ROW]-1 ), currentPosition[COLUMN] ), ( (currentPosition[ROW]+1), currentPosition[COLUMN] ), ( currentPosition[ROW], currentPosition[COLUMN]-1 ), ( currentPosition[ROW], currentPosition[COLUMN]+1 ) ]\\n                        \\n                        # Enqueue valid neighbors \\n                        for neighbor in adjacentSquares:\\n                            if isLand(neighbor):\\n                                cartographyQueue.append( neighbor )\\n        \\n        # Final return\\n        return islandCount`"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "Please improve the question and description of the problem, these kind of lazy problem descriptions are useless to the problem solver. Glad I saw the top comment here."
                    },
                    {
                        "username": "runtimErr0r",
                        "content": "My DFS code is giving TLE on the 47th testcase, although the BFS one works fine. Someone please help me...\\n\\n `your inline code...your inline code...`\\nclass Solution {\\n\\nprivate:\\n\\n    void DFS(int r,int c,vector<vector<char>> grid,vector<vector<int>>& visited){\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(r<0||c<0||r==n||c==m) return;\\n        if(visited[r][c]==1||grid[r][c]!=\\'1\\') return;\\n        visited[r][c]=1;\\n        DFS(r-1,c,grid,visited);\\n        DFS(r,c-1,grid,visited);\\n        DFS(r+1,c,grid,visited);\\n        DFS(r,c+1,grid,visited);\\n    }\\n\\npublic:\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        int count=0;\\n        vector<vector<int>> visited(rows,vector<int>(cols,0));\\n        for(int row=0;row<rows;row++){\\n            for(int col=0;col<cols;col++){\\n                if(grid[row][col]==\\'1\\'&&!visited[row][col]){\\n                    count++;\\n                    DFS(row,col,grid,visited);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "SnappyBoye",
                        "content": "TLE.... thoughts?\\n```py\\nfrom collections import deque\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n\\n        def bfs(i,j, grid):\\n\\n            to_visit = deque([(i, j)])\\n\\n            while to_visit:\\n                curri, currj = to_visit[0]\\n                to_visit.popleft()\\n\\n                # mark current node \\n                grid[curri][currj] = \\'0\\'\\n                \\n                adj_dims = [(curri + 1, currj), (curri - 1, currj), \\\\\\n                    (curri, currj + 1), (curri, currj-1)]\\n                filtered = []\\n                \\n                # make sure not out of bounds\\n                for x, y in adj_dims:\\n                    m, n = len(grid), len(grid[0])\\n                    if x < m and x >= 0 and y < n and y >= 0:\\n                        filtered.append((x, y))\\n\\n                for x, y in filtered:\\n                    if grid[x][y] == \\'1\\':\\n                        to_visit.append((x, y))\\n            \\n        soln = 0\\n        for row in range(m):\\n            for col in range(n):\\n                if grid[row][col] == \\'1\\':\\n                    # see an island\\n                    soln += 1 \\n                    # mark it \\n                    bfs(row, col, grid)\\n                    \\n        return soln\\n\\n\\n\\n\\n\\n```"
                    },
                    {
                        "username": "whoami_112",
                        "content": "comment\\nWhy its giving TLE \\nclass Solution {\\npublic:\\n    vector<int>dx={1,-1,0,0,};\\n    vector<int>dy={0,0,-1,1,};\\n    int numIslands(vector<vector<char>>& grid) {\\n        int ans=0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==\\'0\\')continue;\\n                ans++;\\n                q.push({i,j});\\n                while(!q.empty()){\\n                    int x=q.front().first;\\n                    int y=q.front().second;\\n                    q.pop();\\n                    grid[x][y]=\\'0\\';\\n                    for(int k=0;k<4;k++){\\n                        if(x+dx[k]>=0 and x+dx[k]<n and y+dy[k]>=0 and y+dy[k]<m and grid[x+dx[k]][y+dy[k]]==\\'1\\')q.push({x+dx[k],y+dy[k]});\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Himanshu_78",
                        "content": "\\n/// WHY I AM NOT ABLE TO SUBMIT THIS SOLUTION, in my local IDE is working fine with same test cases. Leetcode showing WRONG ANS\\n\\nclass Solution {\\n\\n    int dx[] = {0, 1, 0 -1, 0};\\n    public int numIslands(char[][] grid) {\\n        int count = 0;\\n\\n       if (grid == null || grid.length == 0) return 0;\\n        \\n        boolean[][] vis = new boolean[grid.length][grid[0].length];\\n        for(int i = 0; i< grid.length; i++){\\n            for(int j = 0; j< grid[0].length; j++){\\n                if(grid[i][j] == \\'1\\' && !vis[i][j]){\\n                    count++;\\n                    find(i, j, grid, vis);\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public void find(int row, int col, char[][] grid, boolean[][] vis){\\n        vis[row][col] = true;\\n        Queue<Pair> p = new LinkedList<Pair>();\\n        p.add(new Pair(row, col));\\n\\n        while(!p.isEmpty()){\\n            Pair q = p.poll();\\n            int mRow = q.i;\\n            int mCol = q.j;\\n\\n            for(int i = 0; i< dx.length -1; i++){\\n                int cRow = mRow + dx[i];\\n                int cCol = mCol + dx[i + 1];\\n\\n                if(cRow >= 0 && cRow < grid.length && cCol >= 0 && cCol < grid[0].length &&\\n                !vis[cRow][cCol] && grid[cRow][cCol] == \\'1\\'){\\n                    vis[cRow][cCol] = true;\\n                    p.add(new Pair(cRow, cCol));\\n                    \\n                }\\n            }\\n        }\\n\\n    }\\n}\\n\\nclass Pair{\\n    int i;\\n    int j;\\n\\n    Pair(int i, int j){\\n        this.i = i;\\n        this.j = j;\\n    }\\n}"
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "the string \"1\" messed me up so bad but managed to fix it , just a little butthurt bout it "
                    },
                    {
                        "username": "sreshtha10",
                        "content": "Any idea how to optimize this solution? 47/49 cases passed\n\n```\n\nclass Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n\n        ROWS =  len(grid)\n        COLS = len(grid[0])\n\n        visited = []\n\n        def dfs(i,j,visited):\n            if(i<0 or j<0 or i>= ROWS or j>=COLS or grid[i][j] == '0' or (i,j) in visited):\n                return\n\n            visited.append((i,j))\n\n            dfs(i+1,j,visited)\n            dfs(i-1,j,visited)\n            dfs(i,j+1,visited)\n            dfs(i,j-1,visited)\n\n            return\n\n\n        \n        res = 0\n\n        for i in range(ROWS):\n            for j in range(COLS):\n                if grid[i][j] == '1' and (i,j) not in visited:\n                    res += 1\n                    dfs(i,j,visited)\n                    \n\n        return res \n\n\n\n\n```\n\n\n"
                    },
                    {
                        "username": "avyayk",
                        "content": "Your visited is a list and not a hashset. Using the in keyword will search linearly and not in O(1) time. Sorry dude, it\\'s a matter of like 3 characters"
                    },
                    {
                        "username": "LateStartToThings",
                        "content": "Don\\'t get why my solution is not quick enough to pass all the test cases. I feel like my BFS algorithm is effectively the same as most solutions...\\n\\nAny ideas?\\n\\n```java\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        // no empty grid edge case - m and n are >= 1\\n\\n        int islands = 0;\\n\\n        // each island is equal to completing a BFS search every time you find a \"1\" in the grid\\n        // to make sure we only consider that island once, we turn each visited \"1\" node into a \"0\"\\n        for (int i=0; i<grid.length; i++) {\\n            for (int j=0; j<grid[0].length; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    makeIsland(grid, i, j);\\n                    islands++;\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n\\n    // make an island at starting position (i,j) by using BFS to explore all neighbours\\n    private static void makeIsland(char[][] grid, int i, int j) {\\n        Queue<Pair<Integer, Integer>> q = new LinkedList<>();\\n        q.add(new Pair(i, j));\\n\\n        while (!q.isEmpty()) {\\n            Pair<Integer, Integer> p = q.poll();\\n            int pi = p.getKey(); int pj = p.getValue();\\n            grid[pi][pj] = \\'0\\';\\n\\n            List<Pair<Integer, Integer>> neighbours = neighbours(grid.length, grid[0].length, pi, pj);\\n            for (Pair<Integer, Integer> n : neighbours) {\\n                int ni = n.getKey();\\n                int nj = n.getValue();\\n                if (grid[ni][nj] == \\'1\\') {\\n                    q.add(new Pair(ni, nj));\\n                }\\n            }\\n        }\\n    }\\n\\n    // get all neighbours for any (i,j) in a (m x n) grid\\n    private static List<Pair<Integer, Integer>> neighbours(int m, int n, int i, int j) {\\n        List<Pair<Integer, Integer>> neighbours = new ArrayList<>();\\n\\n        // top, right, bottom, left respectively\\n        int[] di = {-1, 0, 1, 0};\\n        int[] dj = {0, 1, 0, -1};\\n        for (int k=0; k<di.length; k++) {\\n            int newI = i + di[k];\\n            int newJ = j + dj[k];\\n            if (newI >= 0 && newI < m && newJ >= 0 && newJ < n) {\\n                neighbours.add(new Pair<>(newI, newJ));\\n            }\\n        }\\n        return neighbours;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jethalol",
                        "content": "This should be easy level problem and not medium. Its literally just dfs and there are already plenty of problems like this"
                    }
                ]
            },
            {
                "id": 1857610,
                "content": [
                    {
                        "username": "avyayk",
                        "content": "So this BFS Python solution is overwritten compared to some of the solutions I see. But I don\\'t understand why it\\'s fundamentally too slow. I have this issue nearly every time I do a BFS\\n\\n`class Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n\\n        # Readability\\n        ROW, COLUMN = 0, 1\\n\\n        # Lambda to check if a square is in bounds\\n        inBounds = lambda coordinate: ( 0 <= coordinate[ROW] < len(grid) ) and ( 0 <= coordinate[COLUMN] < len( grid[0] ) )\\n        isLand = lambda coordinate: inBounds(coordinate) and grid[ coordinate[ROW] ][ coordinate[COLUMN] ] == \\'1\\'\\n\\n        # Track islands and their positions\\n        islandCount = 0\\n\\n        # Create a breadth first search queue\\n        cartographyQueue = []\\n        \\n        # Go through the grid and breadth first search\\n        for row in range( len(grid) ):\\n            for column in range( len(grid[0]) ):\\n                \\n                # If we\\'ve hit land, enqueue item and breadth first search to change all linked 1\\'s to 0\\'s\\n                if grid[row][column] == \\'1\\':\\n                    \\n                    # Increment the islandCount\\n                    islandCount += 1\\n\\n                    cartographyQueue.append( (row, column) )\\n\\n                    while cartographyQueue:\\n\\n                        currentPosition = cartographyQueue.pop(0)\\n\\n                        # Change the currentPosition to water so it has been \\'visited\\'\\n                        grid[ currentPosition[ROW] ][ currentPosition[COLUMN] ] = \\'0\\'\\n\\n                        # Search up down left and right\\n                        adjacentSquares = [ ( ( currentPosition[ROW]-1 ), currentPosition[COLUMN] ), ( (currentPosition[ROW]+1), currentPosition[COLUMN] ), ( currentPosition[ROW], currentPosition[COLUMN]-1 ), ( currentPosition[ROW], currentPosition[COLUMN]+1 ) ]\\n                        \\n                        # Enqueue valid neighbors \\n                        for neighbor in adjacentSquares:\\n                            if isLand(neighbor):\\n                                cartographyQueue.append( neighbor )\\n        \\n        # Final return\\n        return islandCount`"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "Please improve the question and description of the problem, these kind of lazy problem descriptions are useless to the problem solver. Glad I saw the top comment here."
                    },
                    {
                        "username": "runtimErr0r",
                        "content": "My DFS code is giving TLE on the 47th testcase, although the BFS one works fine. Someone please help me...\\n\\n `your inline code...your inline code...`\\nclass Solution {\\n\\nprivate:\\n\\n    void DFS(int r,int c,vector<vector<char>> grid,vector<vector<int>>& visited){\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(r<0||c<0||r==n||c==m) return;\\n        if(visited[r][c]==1||grid[r][c]!=\\'1\\') return;\\n        visited[r][c]=1;\\n        DFS(r-1,c,grid,visited);\\n        DFS(r,c-1,grid,visited);\\n        DFS(r+1,c,grid,visited);\\n        DFS(r,c+1,grid,visited);\\n    }\\n\\npublic:\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        int count=0;\\n        vector<vector<int>> visited(rows,vector<int>(cols,0));\\n        for(int row=0;row<rows;row++){\\n            for(int col=0;col<cols;col++){\\n                if(grid[row][col]==\\'1\\'&&!visited[row][col]){\\n                    count++;\\n                    DFS(row,col,grid,visited);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "SnappyBoye",
                        "content": "TLE.... thoughts?\\n```py\\nfrom collections import deque\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n\\n        def bfs(i,j, grid):\\n\\n            to_visit = deque([(i, j)])\\n\\n            while to_visit:\\n                curri, currj = to_visit[0]\\n                to_visit.popleft()\\n\\n                # mark current node \\n                grid[curri][currj] = \\'0\\'\\n                \\n                adj_dims = [(curri + 1, currj), (curri - 1, currj), \\\\\\n                    (curri, currj + 1), (curri, currj-1)]\\n                filtered = []\\n                \\n                # make sure not out of bounds\\n                for x, y in adj_dims:\\n                    m, n = len(grid), len(grid[0])\\n                    if x < m and x >= 0 and y < n and y >= 0:\\n                        filtered.append((x, y))\\n\\n                for x, y in filtered:\\n                    if grid[x][y] == \\'1\\':\\n                        to_visit.append((x, y))\\n            \\n        soln = 0\\n        for row in range(m):\\n            for col in range(n):\\n                if grid[row][col] == \\'1\\':\\n                    # see an island\\n                    soln += 1 \\n                    # mark it \\n                    bfs(row, col, grid)\\n                    \\n        return soln\\n\\n\\n\\n\\n\\n```"
                    },
                    {
                        "username": "whoami_112",
                        "content": "comment\\nWhy its giving TLE \\nclass Solution {\\npublic:\\n    vector<int>dx={1,-1,0,0,};\\n    vector<int>dy={0,0,-1,1,};\\n    int numIslands(vector<vector<char>>& grid) {\\n        int ans=0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==\\'0\\')continue;\\n                ans++;\\n                q.push({i,j});\\n                while(!q.empty()){\\n                    int x=q.front().first;\\n                    int y=q.front().second;\\n                    q.pop();\\n                    grid[x][y]=\\'0\\';\\n                    for(int k=0;k<4;k++){\\n                        if(x+dx[k]>=0 and x+dx[k]<n and y+dy[k]>=0 and y+dy[k]<m and grid[x+dx[k]][y+dy[k]]==\\'1\\')q.push({x+dx[k],y+dy[k]});\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Himanshu_78",
                        "content": "\\n/// WHY I AM NOT ABLE TO SUBMIT THIS SOLUTION, in my local IDE is working fine with same test cases. Leetcode showing WRONG ANS\\n\\nclass Solution {\\n\\n    int dx[] = {0, 1, 0 -1, 0};\\n    public int numIslands(char[][] grid) {\\n        int count = 0;\\n\\n       if (grid == null || grid.length == 0) return 0;\\n        \\n        boolean[][] vis = new boolean[grid.length][grid[0].length];\\n        for(int i = 0; i< grid.length; i++){\\n            for(int j = 0; j< grid[0].length; j++){\\n                if(grid[i][j] == \\'1\\' && !vis[i][j]){\\n                    count++;\\n                    find(i, j, grid, vis);\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public void find(int row, int col, char[][] grid, boolean[][] vis){\\n        vis[row][col] = true;\\n        Queue<Pair> p = new LinkedList<Pair>();\\n        p.add(new Pair(row, col));\\n\\n        while(!p.isEmpty()){\\n            Pair q = p.poll();\\n            int mRow = q.i;\\n            int mCol = q.j;\\n\\n            for(int i = 0; i< dx.length -1; i++){\\n                int cRow = mRow + dx[i];\\n                int cCol = mCol + dx[i + 1];\\n\\n                if(cRow >= 0 && cRow < grid.length && cCol >= 0 && cCol < grid[0].length &&\\n                !vis[cRow][cCol] && grid[cRow][cCol] == \\'1\\'){\\n                    vis[cRow][cCol] = true;\\n                    p.add(new Pair(cRow, cCol));\\n                    \\n                }\\n            }\\n        }\\n\\n    }\\n}\\n\\nclass Pair{\\n    int i;\\n    int j;\\n\\n    Pair(int i, int j){\\n        this.i = i;\\n        this.j = j;\\n    }\\n}"
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "the string \"1\" messed me up so bad but managed to fix it , just a little butthurt bout it "
                    },
                    {
                        "username": "sreshtha10",
                        "content": "Any idea how to optimize this solution? 47/49 cases passed\n\n```\n\nclass Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n\n        ROWS =  len(grid)\n        COLS = len(grid[0])\n\n        visited = []\n\n        def dfs(i,j,visited):\n            if(i<0 or j<0 or i>= ROWS or j>=COLS or grid[i][j] == '0' or (i,j) in visited):\n                return\n\n            visited.append((i,j))\n\n            dfs(i+1,j,visited)\n            dfs(i-1,j,visited)\n            dfs(i,j+1,visited)\n            dfs(i,j-1,visited)\n\n            return\n\n\n        \n        res = 0\n\n        for i in range(ROWS):\n            for j in range(COLS):\n                if grid[i][j] == '1' and (i,j) not in visited:\n                    res += 1\n                    dfs(i,j,visited)\n                    \n\n        return res \n\n\n\n\n```\n\n\n"
                    },
                    {
                        "username": "avyayk",
                        "content": "Your visited is a list and not a hashset. Using the in keyword will search linearly and not in O(1) time. Sorry dude, it\\'s a matter of like 3 characters"
                    },
                    {
                        "username": "LateStartToThings",
                        "content": "Don\\'t get why my solution is not quick enough to pass all the test cases. I feel like my BFS algorithm is effectively the same as most solutions...\\n\\nAny ideas?\\n\\n```java\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        // no empty grid edge case - m and n are >= 1\\n\\n        int islands = 0;\\n\\n        // each island is equal to completing a BFS search every time you find a \"1\" in the grid\\n        // to make sure we only consider that island once, we turn each visited \"1\" node into a \"0\"\\n        for (int i=0; i<grid.length; i++) {\\n            for (int j=0; j<grid[0].length; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    makeIsland(grid, i, j);\\n                    islands++;\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n\\n    // make an island at starting position (i,j) by using BFS to explore all neighbours\\n    private static void makeIsland(char[][] grid, int i, int j) {\\n        Queue<Pair<Integer, Integer>> q = new LinkedList<>();\\n        q.add(new Pair(i, j));\\n\\n        while (!q.isEmpty()) {\\n            Pair<Integer, Integer> p = q.poll();\\n            int pi = p.getKey(); int pj = p.getValue();\\n            grid[pi][pj] = \\'0\\';\\n\\n            List<Pair<Integer, Integer>> neighbours = neighbours(grid.length, grid[0].length, pi, pj);\\n            for (Pair<Integer, Integer> n : neighbours) {\\n                int ni = n.getKey();\\n                int nj = n.getValue();\\n                if (grid[ni][nj] == \\'1\\') {\\n                    q.add(new Pair(ni, nj));\\n                }\\n            }\\n        }\\n    }\\n\\n    // get all neighbours for any (i,j) in a (m x n) grid\\n    private static List<Pair<Integer, Integer>> neighbours(int m, int n, int i, int j) {\\n        List<Pair<Integer, Integer>> neighbours = new ArrayList<>();\\n\\n        // top, right, bottom, left respectively\\n        int[] di = {-1, 0, 1, 0};\\n        int[] dj = {0, 1, 0, -1};\\n        for (int k=0; k<di.length; k++) {\\n            int newI = i + di[k];\\n            int newJ = j + dj[k];\\n            if (newI >= 0 && newI < m && newJ >= 0 && newJ < n) {\\n                neighbours.add(new Pair<>(newI, newJ));\\n            }\\n        }\\n        return neighbours;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jethalol",
                        "content": "This should be easy level problem and not medium. Its literally just dfs and there are already plenty of problems like this"
                    }
                ]
            },
            {
                "id": 1852628,
                "content": [
                    {
                        "username": "avyayk",
                        "content": "So this BFS Python solution is overwritten compared to some of the solutions I see. But I don\\'t understand why it\\'s fundamentally too slow. I have this issue nearly every time I do a BFS\\n\\n`class Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n\\n        # Readability\\n        ROW, COLUMN = 0, 1\\n\\n        # Lambda to check if a square is in bounds\\n        inBounds = lambda coordinate: ( 0 <= coordinate[ROW] < len(grid) ) and ( 0 <= coordinate[COLUMN] < len( grid[0] ) )\\n        isLand = lambda coordinate: inBounds(coordinate) and grid[ coordinate[ROW] ][ coordinate[COLUMN] ] == \\'1\\'\\n\\n        # Track islands and their positions\\n        islandCount = 0\\n\\n        # Create a breadth first search queue\\n        cartographyQueue = []\\n        \\n        # Go through the grid and breadth first search\\n        for row in range( len(grid) ):\\n            for column in range( len(grid[0]) ):\\n                \\n                # If we\\'ve hit land, enqueue item and breadth first search to change all linked 1\\'s to 0\\'s\\n                if grid[row][column] == \\'1\\':\\n                    \\n                    # Increment the islandCount\\n                    islandCount += 1\\n\\n                    cartographyQueue.append( (row, column) )\\n\\n                    while cartographyQueue:\\n\\n                        currentPosition = cartographyQueue.pop(0)\\n\\n                        # Change the currentPosition to water so it has been \\'visited\\'\\n                        grid[ currentPosition[ROW] ][ currentPosition[COLUMN] ] = \\'0\\'\\n\\n                        # Search up down left and right\\n                        adjacentSquares = [ ( ( currentPosition[ROW]-1 ), currentPosition[COLUMN] ), ( (currentPosition[ROW]+1), currentPosition[COLUMN] ), ( currentPosition[ROW], currentPosition[COLUMN]-1 ), ( currentPosition[ROW], currentPosition[COLUMN]+1 ) ]\\n                        \\n                        # Enqueue valid neighbors \\n                        for neighbor in adjacentSquares:\\n                            if isLand(neighbor):\\n                                cartographyQueue.append( neighbor )\\n        \\n        # Final return\\n        return islandCount`"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "Please improve the question and description of the problem, these kind of lazy problem descriptions are useless to the problem solver. Glad I saw the top comment here."
                    },
                    {
                        "username": "runtimErr0r",
                        "content": "My DFS code is giving TLE on the 47th testcase, although the BFS one works fine. Someone please help me...\\n\\n `your inline code...your inline code...`\\nclass Solution {\\n\\nprivate:\\n\\n    void DFS(int r,int c,vector<vector<char>> grid,vector<vector<int>>& visited){\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(r<0||c<0||r==n||c==m) return;\\n        if(visited[r][c]==1||grid[r][c]!=\\'1\\') return;\\n        visited[r][c]=1;\\n        DFS(r-1,c,grid,visited);\\n        DFS(r,c-1,grid,visited);\\n        DFS(r+1,c,grid,visited);\\n        DFS(r,c+1,grid,visited);\\n    }\\n\\npublic:\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        int count=0;\\n        vector<vector<int>> visited(rows,vector<int>(cols,0));\\n        for(int row=0;row<rows;row++){\\n            for(int col=0;col<cols;col++){\\n                if(grid[row][col]==\\'1\\'&&!visited[row][col]){\\n                    count++;\\n                    DFS(row,col,grid,visited);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "SnappyBoye",
                        "content": "TLE.... thoughts?\\n```py\\nfrom collections import deque\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n\\n        def bfs(i,j, grid):\\n\\n            to_visit = deque([(i, j)])\\n\\n            while to_visit:\\n                curri, currj = to_visit[0]\\n                to_visit.popleft()\\n\\n                # mark current node \\n                grid[curri][currj] = \\'0\\'\\n                \\n                adj_dims = [(curri + 1, currj), (curri - 1, currj), \\\\\\n                    (curri, currj + 1), (curri, currj-1)]\\n                filtered = []\\n                \\n                # make sure not out of bounds\\n                for x, y in adj_dims:\\n                    m, n = len(grid), len(grid[0])\\n                    if x < m and x >= 0 and y < n and y >= 0:\\n                        filtered.append((x, y))\\n\\n                for x, y in filtered:\\n                    if grid[x][y] == \\'1\\':\\n                        to_visit.append((x, y))\\n            \\n        soln = 0\\n        for row in range(m):\\n            for col in range(n):\\n                if grid[row][col] == \\'1\\':\\n                    # see an island\\n                    soln += 1 \\n                    # mark it \\n                    bfs(row, col, grid)\\n                    \\n        return soln\\n\\n\\n\\n\\n\\n```"
                    },
                    {
                        "username": "whoami_112",
                        "content": "comment\\nWhy its giving TLE \\nclass Solution {\\npublic:\\n    vector<int>dx={1,-1,0,0,};\\n    vector<int>dy={0,0,-1,1,};\\n    int numIslands(vector<vector<char>>& grid) {\\n        int ans=0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==\\'0\\')continue;\\n                ans++;\\n                q.push({i,j});\\n                while(!q.empty()){\\n                    int x=q.front().first;\\n                    int y=q.front().second;\\n                    q.pop();\\n                    grid[x][y]=\\'0\\';\\n                    for(int k=0;k<4;k++){\\n                        if(x+dx[k]>=0 and x+dx[k]<n and y+dy[k]>=0 and y+dy[k]<m and grid[x+dx[k]][y+dy[k]]==\\'1\\')q.push({x+dx[k],y+dy[k]});\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Himanshu_78",
                        "content": "\\n/// WHY I AM NOT ABLE TO SUBMIT THIS SOLUTION, in my local IDE is working fine with same test cases. Leetcode showing WRONG ANS\\n\\nclass Solution {\\n\\n    int dx[] = {0, 1, 0 -1, 0};\\n    public int numIslands(char[][] grid) {\\n        int count = 0;\\n\\n       if (grid == null || grid.length == 0) return 0;\\n        \\n        boolean[][] vis = new boolean[grid.length][grid[0].length];\\n        for(int i = 0; i< grid.length; i++){\\n            for(int j = 0; j< grid[0].length; j++){\\n                if(grid[i][j] == \\'1\\' && !vis[i][j]){\\n                    count++;\\n                    find(i, j, grid, vis);\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public void find(int row, int col, char[][] grid, boolean[][] vis){\\n        vis[row][col] = true;\\n        Queue<Pair> p = new LinkedList<Pair>();\\n        p.add(new Pair(row, col));\\n\\n        while(!p.isEmpty()){\\n            Pair q = p.poll();\\n            int mRow = q.i;\\n            int mCol = q.j;\\n\\n            for(int i = 0; i< dx.length -1; i++){\\n                int cRow = mRow + dx[i];\\n                int cCol = mCol + dx[i + 1];\\n\\n                if(cRow >= 0 && cRow < grid.length && cCol >= 0 && cCol < grid[0].length &&\\n                !vis[cRow][cCol] && grid[cRow][cCol] == \\'1\\'){\\n                    vis[cRow][cCol] = true;\\n                    p.add(new Pair(cRow, cCol));\\n                    \\n                }\\n            }\\n        }\\n\\n    }\\n}\\n\\nclass Pair{\\n    int i;\\n    int j;\\n\\n    Pair(int i, int j){\\n        this.i = i;\\n        this.j = j;\\n    }\\n}"
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "the string \"1\" messed me up so bad but managed to fix it , just a little butthurt bout it "
                    },
                    {
                        "username": "sreshtha10",
                        "content": "Any idea how to optimize this solution? 47/49 cases passed\n\n```\n\nclass Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n\n        ROWS =  len(grid)\n        COLS = len(grid[0])\n\n        visited = []\n\n        def dfs(i,j,visited):\n            if(i<0 or j<0 or i>= ROWS or j>=COLS or grid[i][j] == '0' or (i,j) in visited):\n                return\n\n            visited.append((i,j))\n\n            dfs(i+1,j,visited)\n            dfs(i-1,j,visited)\n            dfs(i,j+1,visited)\n            dfs(i,j-1,visited)\n\n            return\n\n\n        \n        res = 0\n\n        for i in range(ROWS):\n            for j in range(COLS):\n                if grid[i][j] == '1' and (i,j) not in visited:\n                    res += 1\n                    dfs(i,j,visited)\n                    \n\n        return res \n\n\n\n\n```\n\n\n"
                    },
                    {
                        "username": "avyayk",
                        "content": "Your visited is a list and not a hashset. Using the in keyword will search linearly and not in O(1) time. Sorry dude, it\\'s a matter of like 3 characters"
                    },
                    {
                        "username": "LateStartToThings",
                        "content": "Don\\'t get why my solution is not quick enough to pass all the test cases. I feel like my BFS algorithm is effectively the same as most solutions...\\n\\nAny ideas?\\n\\n```java\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        // no empty grid edge case - m and n are >= 1\\n\\n        int islands = 0;\\n\\n        // each island is equal to completing a BFS search every time you find a \"1\" in the grid\\n        // to make sure we only consider that island once, we turn each visited \"1\" node into a \"0\"\\n        for (int i=0; i<grid.length; i++) {\\n            for (int j=0; j<grid[0].length; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    makeIsland(grid, i, j);\\n                    islands++;\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n\\n    // make an island at starting position (i,j) by using BFS to explore all neighbours\\n    private static void makeIsland(char[][] grid, int i, int j) {\\n        Queue<Pair<Integer, Integer>> q = new LinkedList<>();\\n        q.add(new Pair(i, j));\\n\\n        while (!q.isEmpty()) {\\n            Pair<Integer, Integer> p = q.poll();\\n            int pi = p.getKey(); int pj = p.getValue();\\n            grid[pi][pj] = \\'0\\';\\n\\n            List<Pair<Integer, Integer>> neighbours = neighbours(grid.length, grid[0].length, pi, pj);\\n            for (Pair<Integer, Integer> n : neighbours) {\\n                int ni = n.getKey();\\n                int nj = n.getValue();\\n                if (grid[ni][nj] == \\'1\\') {\\n                    q.add(new Pair(ni, nj));\\n                }\\n            }\\n        }\\n    }\\n\\n    // get all neighbours for any (i,j) in a (m x n) grid\\n    private static List<Pair<Integer, Integer>> neighbours(int m, int n, int i, int j) {\\n        List<Pair<Integer, Integer>> neighbours = new ArrayList<>();\\n\\n        // top, right, bottom, left respectively\\n        int[] di = {-1, 0, 1, 0};\\n        int[] dj = {0, 1, 0, -1};\\n        for (int k=0; k<di.length; k++) {\\n            int newI = i + di[k];\\n            int newJ = j + dj[k];\\n            if (newI >= 0 && newI < m && newJ >= 0 && newJ < n) {\\n                neighbours.add(new Pair<>(newI, newJ));\\n            }\\n        }\\n        return neighbours;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jethalol",
                        "content": "This should be easy level problem and not medium. Its literally just dfs and there are already plenty of problems like this"
                    }
                ]
            },
            {
                "id": 1842805,
                "content": [
                    {
                        "username": "avyayk",
                        "content": "So this BFS Python solution is overwritten compared to some of the solutions I see. But I don\\'t understand why it\\'s fundamentally too slow. I have this issue nearly every time I do a BFS\\n\\n`class Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n\\n        # Readability\\n        ROW, COLUMN = 0, 1\\n\\n        # Lambda to check if a square is in bounds\\n        inBounds = lambda coordinate: ( 0 <= coordinate[ROW] < len(grid) ) and ( 0 <= coordinate[COLUMN] < len( grid[0] ) )\\n        isLand = lambda coordinate: inBounds(coordinate) and grid[ coordinate[ROW] ][ coordinate[COLUMN] ] == \\'1\\'\\n\\n        # Track islands and their positions\\n        islandCount = 0\\n\\n        # Create a breadth first search queue\\n        cartographyQueue = []\\n        \\n        # Go through the grid and breadth first search\\n        for row in range( len(grid) ):\\n            for column in range( len(grid[0]) ):\\n                \\n                # If we\\'ve hit land, enqueue item and breadth first search to change all linked 1\\'s to 0\\'s\\n                if grid[row][column] == \\'1\\':\\n                    \\n                    # Increment the islandCount\\n                    islandCount += 1\\n\\n                    cartographyQueue.append( (row, column) )\\n\\n                    while cartographyQueue:\\n\\n                        currentPosition = cartographyQueue.pop(0)\\n\\n                        # Change the currentPosition to water so it has been \\'visited\\'\\n                        grid[ currentPosition[ROW] ][ currentPosition[COLUMN] ] = \\'0\\'\\n\\n                        # Search up down left and right\\n                        adjacentSquares = [ ( ( currentPosition[ROW]-1 ), currentPosition[COLUMN] ), ( (currentPosition[ROW]+1), currentPosition[COLUMN] ), ( currentPosition[ROW], currentPosition[COLUMN]-1 ), ( currentPosition[ROW], currentPosition[COLUMN]+1 ) ]\\n                        \\n                        # Enqueue valid neighbors \\n                        for neighbor in adjacentSquares:\\n                            if isLand(neighbor):\\n                                cartographyQueue.append( neighbor )\\n        \\n        # Final return\\n        return islandCount`"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "Please improve the question and description of the problem, these kind of lazy problem descriptions are useless to the problem solver. Glad I saw the top comment here."
                    },
                    {
                        "username": "runtimErr0r",
                        "content": "My DFS code is giving TLE on the 47th testcase, although the BFS one works fine. Someone please help me...\\n\\n `your inline code...your inline code...`\\nclass Solution {\\n\\nprivate:\\n\\n    void DFS(int r,int c,vector<vector<char>> grid,vector<vector<int>>& visited){\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(r<0||c<0||r==n||c==m) return;\\n        if(visited[r][c]==1||grid[r][c]!=\\'1\\') return;\\n        visited[r][c]=1;\\n        DFS(r-1,c,grid,visited);\\n        DFS(r,c-1,grid,visited);\\n        DFS(r+1,c,grid,visited);\\n        DFS(r,c+1,grid,visited);\\n    }\\n\\npublic:\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        int count=0;\\n        vector<vector<int>> visited(rows,vector<int>(cols,0));\\n        for(int row=0;row<rows;row++){\\n            for(int col=0;col<cols;col++){\\n                if(grid[row][col]==\\'1\\'&&!visited[row][col]){\\n                    count++;\\n                    DFS(row,col,grid,visited);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "SnappyBoye",
                        "content": "TLE.... thoughts?\\n```py\\nfrom collections import deque\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n\\n        def bfs(i,j, grid):\\n\\n            to_visit = deque([(i, j)])\\n\\n            while to_visit:\\n                curri, currj = to_visit[0]\\n                to_visit.popleft()\\n\\n                # mark current node \\n                grid[curri][currj] = \\'0\\'\\n                \\n                adj_dims = [(curri + 1, currj), (curri - 1, currj), \\\\\\n                    (curri, currj + 1), (curri, currj-1)]\\n                filtered = []\\n                \\n                # make sure not out of bounds\\n                for x, y in adj_dims:\\n                    m, n = len(grid), len(grid[0])\\n                    if x < m and x >= 0 and y < n and y >= 0:\\n                        filtered.append((x, y))\\n\\n                for x, y in filtered:\\n                    if grid[x][y] == \\'1\\':\\n                        to_visit.append((x, y))\\n            \\n        soln = 0\\n        for row in range(m):\\n            for col in range(n):\\n                if grid[row][col] == \\'1\\':\\n                    # see an island\\n                    soln += 1 \\n                    # mark it \\n                    bfs(row, col, grid)\\n                    \\n        return soln\\n\\n\\n\\n\\n\\n```"
                    },
                    {
                        "username": "whoami_112",
                        "content": "comment\\nWhy its giving TLE \\nclass Solution {\\npublic:\\n    vector<int>dx={1,-1,0,0,};\\n    vector<int>dy={0,0,-1,1,};\\n    int numIslands(vector<vector<char>>& grid) {\\n        int ans=0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==\\'0\\')continue;\\n                ans++;\\n                q.push({i,j});\\n                while(!q.empty()){\\n                    int x=q.front().first;\\n                    int y=q.front().second;\\n                    q.pop();\\n                    grid[x][y]=\\'0\\';\\n                    for(int k=0;k<4;k++){\\n                        if(x+dx[k]>=0 and x+dx[k]<n and y+dy[k]>=0 and y+dy[k]<m and grid[x+dx[k]][y+dy[k]]==\\'1\\')q.push({x+dx[k],y+dy[k]});\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Himanshu_78",
                        "content": "\\n/// WHY I AM NOT ABLE TO SUBMIT THIS SOLUTION, in my local IDE is working fine with same test cases. Leetcode showing WRONG ANS\\n\\nclass Solution {\\n\\n    int dx[] = {0, 1, 0 -1, 0};\\n    public int numIslands(char[][] grid) {\\n        int count = 0;\\n\\n       if (grid == null || grid.length == 0) return 0;\\n        \\n        boolean[][] vis = new boolean[grid.length][grid[0].length];\\n        for(int i = 0; i< grid.length; i++){\\n            for(int j = 0; j< grid[0].length; j++){\\n                if(grid[i][j] == \\'1\\' && !vis[i][j]){\\n                    count++;\\n                    find(i, j, grid, vis);\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public void find(int row, int col, char[][] grid, boolean[][] vis){\\n        vis[row][col] = true;\\n        Queue<Pair> p = new LinkedList<Pair>();\\n        p.add(new Pair(row, col));\\n\\n        while(!p.isEmpty()){\\n            Pair q = p.poll();\\n            int mRow = q.i;\\n            int mCol = q.j;\\n\\n            for(int i = 0; i< dx.length -1; i++){\\n                int cRow = mRow + dx[i];\\n                int cCol = mCol + dx[i + 1];\\n\\n                if(cRow >= 0 && cRow < grid.length && cCol >= 0 && cCol < grid[0].length &&\\n                !vis[cRow][cCol] && grid[cRow][cCol] == \\'1\\'){\\n                    vis[cRow][cCol] = true;\\n                    p.add(new Pair(cRow, cCol));\\n                    \\n                }\\n            }\\n        }\\n\\n    }\\n}\\n\\nclass Pair{\\n    int i;\\n    int j;\\n\\n    Pair(int i, int j){\\n        this.i = i;\\n        this.j = j;\\n    }\\n}"
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "the string \"1\" messed me up so bad but managed to fix it , just a little butthurt bout it "
                    },
                    {
                        "username": "sreshtha10",
                        "content": "Any idea how to optimize this solution? 47/49 cases passed\n\n```\n\nclass Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n\n        ROWS =  len(grid)\n        COLS = len(grid[0])\n\n        visited = []\n\n        def dfs(i,j,visited):\n            if(i<0 or j<0 or i>= ROWS or j>=COLS or grid[i][j] == '0' or (i,j) in visited):\n                return\n\n            visited.append((i,j))\n\n            dfs(i+1,j,visited)\n            dfs(i-1,j,visited)\n            dfs(i,j+1,visited)\n            dfs(i,j-1,visited)\n\n            return\n\n\n        \n        res = 0\n\n        for i in range(ROWS):\n            for j in range(COLS):\n                if grid[i][j] == '1' and (i,j) not in visited:\n                    res += 1\n                    dfs(i,j,visited)\n                    \n\n        return res \n\n\n\n\n```\n\n\n"
                    },
                    {
                        "username": "avyayk",
                        "content": "Your visited is a list and not a hashset. Using the in keyword will search linearly and not in O(1) time. Sorry dude, it\\'s a matter of like 3 characters"
                    },
                    {
                        "username": "LateStartToThings",
                        "content": "Don\\'t get why my solution is not quick enough to pass all the test cases. I feel like my BFS algorithm is effectively the same as most solutions...\\n\\nAny ideas?\\n\\n```java\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        // no empty grid edge case - m and n are >= 1\\n\\n        int islands = 0;\\n\\n        // each island is equal to completing a BFS search every time you find a \"1\" in the grid\\n        // to make sure we only consider that island once, we turn each visited \"1\" node into a \"0\"\\n        for (int i=0; i<grid.length; i++) {\\n            for (int j=0; j<grid[0].length; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    makeIsland(grid, i, j);\\n                    islands++;\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n\\n    // make an island at starting position (i,j) by using BFS to explore all neighbours\\n    private static void makeIsland(char[][] grid, int i, int j) {\\n        Queue<Pair<Integer, Integer>> q = new LinkedList<>();\\n        q.add(new Pair(i, j));\\n\\n        while (!q.isEmpty()) {\\n            Pair<Integer, Integer> p = q.poll();\\n            int pi = p.getKey(); int pj = p.getValue();\\n            grid[pi][pj] = \\'0\\';\\n\\n            List<Pair<Integer, Integer>> neighbours = neighbours(grid.length, grid[0].length, pi, pj);\\n            for (Pair<Integer, Integer> n : neighbours) {\\n                int ni = n.getKey();\\n                int nj = n.getValue();\\n                if (grid[ni][nj] == \\'1\\') {\\n                    q.add(new Pair(ni, nj));\\n                }\\n            }\\n        }\\n    }\\n\\n    // get all neighbours for any (i,j) in a (m x n) grid\\n    private static List<Pair<Integer, Integer>> neighbours(int m, int n, int i, int j) {\\n        List<Pair<Integer, Integer>> neighbours = new ArrayList<>();\\n\\n        // top, right, bottom, left respectively\\n        int[] di = {-1, 0, 1, 0};\\n        int[] dj = {0, 1, 0, -1};\\n        for (int k=0; k<di.length; k++) {\\n            int newI = i + di[k];\\n            int newJ = j + dj[k];\\n            if (newI >= 0 && newI < m && newJ >= 0 && newJ < n) {\\n                neighbours.add(new Pair<>(newI, newJ));\\n            }\\n        }\\n        return neighbours;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jethalol",
                        "content": "This should be easy level problem and not medium. Its literally just dfs and there are already plenty of problems like this"
                    }
                ]
            },
            {
                "id": 1840981,
                "content": [
                    {
                        "username": "avyayk",
                        "content": "So this BFS Python solution is overwritten compared to some of the solutions I see. But I don\\'t understand why it\\'s fundamentally too slow. I have this issue nearly every time I do a BFS\\n\\n`class Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n\\n        # Readability\\n        ROW, COLUMN = 0, 1\\n\\n        # Lambda to check if a square is in bounds\\n        inBounds = lambda coordinate: ( 0 <= coordinate[ROW] < len(grid) ) and ( 0 <= coordinate[COLUMN] < len( grid[0] ) )\\n        isLand = lambda coordinate: inBounds(coordinate) and grid[ coordinate[ROW] ][ coordinate[COLUMN] ] == \\'1\\'\\n\\n        # Track islands and their positions\\n        islandCount = 0\\n\\n        # Create a breadth first search queue\\n        cartographyQueue = []\\n        \\n        # Go through the grid and breadth first search\\n        for row in range( len(grid) ):\\n            for column in range( len(grid[0]) ):\\n                \\n                # If we\\'ve hit land, enqueue item and breadth first search to change all linked 1\\'s to 0\\'s\\n                if grid[row][column] == \\'1\\':\\n                    \\n                    # Increment the islandCount\\n                    islandCount += 1\\n\\n                    cartographyQueue.append( (row, column) )\\n\\n                    while cartographyQueue:\\n\\n                        currentPosition = cartographyQueue.pop(0)\\n\\n                        # Change the currentPosition to water so it has been \\'visited\\'\\n                        grid[ currentPosition[ROW] ][ currentPosition[COLUMN] ] = \\'0\\'\\n\\n                        # Search up down left and right\\n                        adjacentSquares = [ ( ( currentPosition[ROW]-1 ), currentPosition[COLUMN] ), ( (currentPosition[ROW]+1), currentPosition[COLUMN] ), ( currentPosition[ROW], currentPosition[COLUMN]-1 ), ( currentPosition[ROW], currentPosition[COLUMN]+1 ) ]\\n                        \\n                        # Enqueue valid neighbors \\n                        for neighbor in adjacentSquares:\\n                            if isLand(neighbor):\\n                                cartographyQueue.append( neighbor )\\n        \\n        # Final return\\n        return islandCount`"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "Please improve the question and description of the problem, these kind of lazy problem descriptions are useless to the problem solver. Glad I saw the top comment here."
                    },
                    {
                        "username": "runtimErr0r",
                        "content": "My DFS code is giving TLE on the 47th testcase, although the BFS one works fine. Someone please help me...\\n\\n `your inline code...your inline code...`\\nclass Solution {\\n\\nprivate:\\n\\n    void DFS(int r,int c,vector<vector<char>> grid,vector<vector<int>>& visited){\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(r<0||c<0||r==n||c==m) return;\\n        if(visited[r][c]==1||grid[r][c]!=\\'1\\') return;\\n        visited[r][c]=1;\\n        DFS(r-1,c,grid,visited);\\n        DFS(r,c-1,grid,visited);\\n        DFS(r+1,c,grid,visited);\\n        DFS(r,c+1,grid,visited);\\n    }\\n\\npublic:\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        int count=0;\\n        vector<vector<int>> visited(rows,vector<int>(cols,0));\\n        for(int row=0;row<rows;row++){\\n            for(int col=0;col<cols;col++){\\n                if(grid[row][col]==\\'1\\'&&!visited[row][col]){\\n                    count++;\\n                    DFS(row,col,grid,visited);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "SnappyBoye",
                        "content": "TLE.... thoughts?\\n```py\\nfrom collections import deque\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n\\n        def bfs(i,j, grid):\\n\\n            to_visit = deque([(i, j)])\\n\\n            while to_visit:\\n                curri, currj = to_visit[0]\\n                to_visit.popleft()\\n\\n                # mark current node \\n                grid[curri][currj] = \\'0\\'\\n                \\n                adj_dims = [(curri + 1, currj), (curri - 1, currj), \\\\\\n                    (curri, currj + 1), (curri, currj-1)]\\n                filtered = []\\n                \\n                # make sure not out of bounds\\n                for x, y in adj_dims:\\n                    m, n = len(grid), len(grid[0])\\n                    if x < m and x >= 0 and y < n and y >= 0:\\n                        filtered.append((x, y))\\n\\n                for x, y in filtered:\\n                    if grid[x][y] == \\'1\\':\\n                        to_visit.append((x, y))\\n            \\n        soln = 0\\n        for row in range(m):\\n            for col in range(n):\\n                if grid[row][col] == \\'1\\':\\n                    # see an island\\n                    soln += 1 \\n                    # mark it \\n                    bfs(row, col, grid)\\n                    \\n        return soln\\n\\n\\n\\n\\n\\n```"
                    },
                    {
                        "username": "whoami_112",
                        "content": "comment\\nWhy its giving TLE \\nclass Solution {\\npublic:\\n    vector<int>dx={1,-1,0,0,};\\n    vector<int>dy={0,0,-1,1,};\\n    int numIslands(vector<vector<char>>& grid) {\\n        int ans=0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==\\'0\\')continue;\\n                ans++;\\n                q.push({i,j});\\n                while(!q.empty()){\\n                    int x=q.front().first;\\n                    int y=q.front().second;\\n                    q.pop();\\n                    grid[x][y]=\\'0\\';\\n                    for(int k=0;k<4;k++){\\n                        if(x+dx[k]>=0 and x+dx[k]<n and y+dy[k]>=0 and y+dy[k]<m and grid[x+dx[k]][y+dy[k]]==\\'1\\')q.push({x+dx[k],y+dy[k]});\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Himanshu_78",
                        "content": "\\n/// WHY I AM NOT ABLE TO SUBMIT THIS SOLUTION, in my local IDE is working fine with same test cases. Leetcode showing WRONG ANS\\n\\nclass Solution {\\n\\n    int dx[] = {0, 1, 0 -1, 0};\\n    public int numIslands(char[][] grid) {\\n        int count = 0;\\n\\n       if (grid == null || grid.length == 0) return 0;\\n        \\n        boolean[][] vis = new boolean[grid.length][grid[0].length];\\n        for(int i = 0; i< grid.length; i++){\\n            for(int j = 0; j< grid[0].length; j++){\\n                if(grid[i][j] == \\'1\\' && !vis[i][j]){\\n                    count++;\\n                    find(i, j, grid, vis);\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public void find(int row, int col, char[][] grid, boolean[][] vis){\\n        vis[row][col] = true;\\n        Queue<Pair> p = new LinkedList<Pair>();\\n        p.add(new Pair(row, col));\\n\\n        while(!p.isEmpty()){\\n            Pair q = p.poll();\\n            int mRow = q.i;\\n            int mCol = q.j;\\n\\n            for(int i = 0; i< dx.length -1; i++){\\n                int cRow = mRow + dx[i];\\n                int cCol = mCol + dx[i + 1];\\n\\n                if(cRow >= 0 && cRow < grid.length && cCol >= 0 && cCol < grid[0].length &&\\n                !vis[cRow][cCol] && grid[cRow][cCol] == \\'1\\'){\\n                    vis[cRow][cCol] = true;\\n                    p.add(new Pair(cRow, cCol));\\n                    \\n                }\\n            }\\n        }\\n\\n    }\\n}\\n\\nclass Pair{\\n    int i;\\n    int j;\\n\\n    Pair(int i, int j){\\n        this.i = i;\\n        this.j = j;\\n    }\\n}"
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "the string \"1\" messed me up so bad but managed to fix it , just a little butthurt bout it "
                    },
                    {
                        "username": "sreshtha10",
                        "content": "Any idea how to optimize this solution? 47/49 cases passed\n\n```\n\nclass Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n\n        ROWS =  len(grid)\n        COLS = len(grid[0])\n\n        visited = []\n\n        def dfs(i,j,visited):\n            if(i<0 or j<0 or i>= ROWS or j>=COLS or grid[i][j] == '0' or (i,j) in visited):\n                return\n\n            visited.append((i,j))\n\n            dfs(i+1,j,visited)\n            dfs(i-1,j,visited)\n            dfs(i,j+1,visited)\n            dfs(i,j-1,visited)\n\n            return\n\n\n        \n        res = 0\n\n        for i in range(ROWS):\n            for j in range(COLS):\n                if grid[i][j] == '1' and (i,j) not in visited:\n                    res += 1\n                    dfs(i,j,visited)\n                    \n\n        return res \n\n\n\n\n```\n\n\n"
                    },
                    {
                        "username": "avyayk",
                        "content": "Your visited is a list and not a hashset. Using the in keyword will search linearly and not in O(1) time. Sorry dude, it\\'s a matter of like 3 characters"
                    },
                    {
                        "username": "LateStartToThings",
                        "content": "Don\\'t get why my solution is not quick enough to pass all the test cases. I feel like my BFS algorithm is effectively the same as most solutions...\\n\\nAny ideas?\\n\\n```java\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        // no empty grid edge case - m and n are >= 1\\n\\n        int islands = 0;\\n\\n        // each island is equal to completing a BFS search every time you find a \"1\" in the grid\\n        // to make sure we only consider that island once, we turn each visited \"1\" node into a \"0\"\\n        for (int i=0; i<grid.length; i++) {\\n            for (int j=0; j<grid[0].length; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    makeIsland(grid, i, j);\\n                    islands++;\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n\\n    // make an island at starting position (i,j) by using BFS to explore all neighbours\\n    private static void makeIsland(char[][] grid, int i, int j) {\\n        Queue<Pair<Integer, Integer>> q = new LinkedList<>();\\n        q.add(new Pair(i, j));\\n\\n        while (!q.isEmpty()) {\\n            Pair<Integer, Integer> p = q.poll();\\n            int pi = p.getKey(); int pj = p.getValue();\\n            grid[pi][pj] = \\'0\\';\\n\\n            List<Pair<Integer, Integer>> neighbours = neighbours(grid.length, grid[0].length, pi, pj);\\n            for (Pair<Integer, Integer> n : neighbours) {\\n                int ni = n.getKey();\\n                int nj = n.getValue();\\n                if (grid[ni][nj] == \\'1\\') {\\n                    q.add(new Pair(ni, nj));\\n                }\\n            }\\n        }\\n    }\\n\\n    // get all neighbours for any (i,j) in a (m x n) grid\\n    private static List<Pair<Integer, Integer>> neighbours(int m, int n, int i, int j) {\\n        List<Pair<Integer, Integer>> neighbours = new ArrayList<>();\\n\\n        // top, right, bottom, left respectively\\n        int[] di = {-1, 0, 1, 0};\\n        int[] dj = {0, 1, 0, -1};\\n        for (int k=0; k<di.length; k++) {\\n            int newI = i + di[k];\\n            int newJ = j + dj[k];\\n            if (newI >= 0 && newI < m && newJ >= 0 && newJ < n) {\\n                neighbours.add(new Pair<>(newI, newJ));\\n            }\\n        }\\n        return neighbours;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jethalol",
                        "content": "This should be easy level problem and not medium. Its literally just dfs and there are already plenty of problems like this"
                    }
                ]
            },
            {
                "id": 1808723,
                "content": [
                    {
                        "username": "avyayk",
                        "content": "So this BFS Python solution is overwritten compared to some of the solutions I see. But I don\\'t understand why it\\'s fundamentally too slow. I have this issue nearly every time I do a BFS\\n\\n`class Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n\\n        # Readability\\n        ROW, COLUMN = 0, 1\\n\\n        # Lambda to check if a square is in bounds\\n        inBounds = lambda coordinate: ( 0 <= coordinate[ROW] < len(grid) ) and ( 0 <= coordinate[COLUMN] < len( grid[0] ) )\\n        isLand = lambda coordinate: inBounds(coordinate) and grid[ coordinate[ROW] ][ coordinate[COLUMN] ] == \\'1\\'\\n\\n        # Track islands and their positions\\n        islandCount = 0\\n\\n        # Create a breadth first search queue\\n        cartographyQueue = []\\n        \\n        # Go through the grid and breadth first search\\n        for row in range( len(grid) ):\\n            for column in range( len(grid[0]) ):\\n                \\n                # If we\\'ve hit land, enqueue item and breadth first search to change all linked 1\\'s to 0\\'s\\n                if grid[row][column] == \\'1\\':\\n                    \\n                    # Increment the islandCount\\n                    islandCount += 1\\n\\n                    cartographyQueue.append( (row, column) )\\n\\n                    while cartographyQueue:\\n\\n                        currentPosition = cartographyQueue.pop(0)\\n\\n                        # Change the currentPosition to water so it has been \\'visited\\'\\n                        grid[ currentPosition[ROW] ][ currentPosition[COLUMN] ] = \\'0\\'\\n\\n                        # Search up down left and right\\n                        adjacentSquares = [ ( ( currentPosition[ROW]-1 ), currentPosition[COLUMN] ), ( (currentPosition[ROW]+1), currentPosition[COLUMN] ), ( currentPosition[ROW], currentPosition[COLUMN]-1 ), ( currentPosition[ROW], currentPosition[COLUMN]+1 ) ]\\n                        \\n                        # Enqueue valid neighbors \\n                        for neighbor in adjacentSquares:\\n                            if isLand(neighbor):\\n                                cartographyQueue.append( neighbor )\\n        \\n        # Final return\\n        return islandCount`"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "Please improve the question and description of the problem, these kind of lazy problem descriptions are useless to the problem solver. Glad I saw the top comment here."
                    },
                    {
                        "username": "runtimErr0r",
                        "content": "My DFS code is giving TLE on the 47th testcase, although the BFS one works fine. Someone please help me...\\n\\n `your inline code...your inline code...`\\nclass Solution {\\n\\nprivate:\\n\\n    void DFS(int r,int c,vector<vector<char>> grid,vector<vector<int>>& visited){\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(r<0||c<0||r==n||c==m) return;\\n        if(visited[r][c]==1||grid[r][c]!=\\'1\\') return;\\n        visited[r][c]=1;\\n        DFS(r-1,c,grid,visited);\\n        DFS(r,c-1,grid,visited);\\n        DFS(r+1,c,grid,visited);\\n        DFS(r,c+1,grid,visited);\\n    }\\n\\npublic:\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        int count=0;\\n        vector<vector<int>> visited(rows,vector<int>(cols,0));\\n        for(int row=0;row<rows;row++){\\n            for(int col=0;col<cols;col++){\\n                if(grid[row][col]==\\'1\\'&&!visited[row][col]){\\n                    count++;\\n                    DFS(row,col,grid,visited);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "SnappyBoye",
                        "content": "TLE.... thoughts?\\n```py\\nfrom collections import deque\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n\\n        def bfs(i,j, grid):\\n\\n            to_visit = deque([(i, j)])\\n\\n            while to_visit:\\n                curri, currj = to_visit[0]\\n                to_visit.popleft()\\n\\n                # mark current node \\n                grid[curri][currj] = \\'0\\'\\n                \\n                adj_dims = [(curri + 1, currj), (curri - 1, currj), \\\\\\n                    (curri, currj + 1), (curri, currj-1)]\\n                filtered = []\\n                \\n                # make sure not out of bounds\\n                for x, y in adj_dims:\\n                    m, n = len(grid), len(grid[0])\\n                    if x < m and x >= 0 and y < n and y >= 0:\\n                        filtered.append((x, y))\\n\\n                for x, y in filtered:\\n                    if grid[x][y] == \\'1\\':\\n                        to_visit.append((x, y))\\n            \\n        soln = 0\\n        for row in range(m):\\n            for col in range(n):\\n                if grid[row][col] == \\'1\\':\\n                    # see an island\\n                    soln += 1 \\n                    # mark it \\n                    bfs(row, col, grid)\\n                    \\n        return soln\\n\\n\\n\\n\\n\\n```"
                    },
                    {
                        "username": "whoami_112",
                        "content": "comment\\nWhy its giving TLE \\nclass Solution {\\npublic:\\n    vector<int>dx={1,-1,0,0,};\\n    vector<int>dy={0,0,-1,1,};\\n    int numIslands(vector<vector<char>>& grid) {\\n        int ans=0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==\\'0\\')continue;\\n                ans++;\\n                q.push({i,j});\\n                while(!q.empty()){\\n                    int x=q.front().first;\\n                    int y=q.front().second;\\n                    q.pop();\\n                    grid[x][y]=\\'0\\';\\n                    for(int k=0;k<4;k++){\\n                        if(x+dx[k]>=0 and x+dx[k]<n and y+dy[k]>=0 and y+dy[k]<m and grid[x+dx[k]][y+dy[k]]==\\'1\\')q.push({x+dx[k],y+dy[k]});\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Himanshu_78",
                        "content": "\\n/// WHY I AM NOT ABLE TO SUBMIT THIS SOLUTION, in my local IDE is working fine with same test cases. Leetcode showing WRONG ANS\\n\\nclass Solution {\\n\\n    int dx[] = {0, 1, 0 -1, 0};\\n    public int numIslands(char[][] grid) {\\n        int count = 0;\\n\\n       if (grid == null || grid.length == 0) return 0;\\n        \\n        boolean[][] vis = new boolean[grid.length][grid[0].length];\\n        for(int i = 0; i< grid.length; i++){\\n            for(int j = 0; j< grid[0].length; j++){\\n                if(grid[i][j] == \\'1\\' && !vis[i][j]){\\n                    count++;\\n                    find(i, j, grid, vis);\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public void find(int row, int col, char[][] grid, boolean[][] vis){\\n        vis[row][col] = true;\\n        Queue<Pair> p = new LinkedList<Pair>();\\n        p.add(new Pair(row, col));\\n\\n        while(!p.isEmpty()){\\n            Pair q = p.poll();\\n            int mRow = q.i;\\n            int mCol = q.j;\\n\\n            for(int i = 0; i< dx.length -1; i++){\\n                int cRow = mRow + dx[i];\\n                int cCol = mCol + dx[i + 1];\\n\\n                if(cRow >= 0 && cRow < grid.length && cCol >= 0 && cCol < grid[0].length &&\\n                !vis[cRow][cCol] && grid[cRow][cCol] == \\'1\\'){\\n                    vis[cRow][cCol] = true;\\n                    p.add(new Pair(cRow, cCol));\\n                    \\n                }\\n            }\\n        }\\n\\n    }\\n}\\n\\nclass Pair{\\n    int i;\\n    int j;\\n\\n    Pair(int i, int j){\\n        this.i = i;\\n        this.j = j;\\n    }\\n}"
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "the string \"1\" messed me up so bad but managed to fix it , just a little butthurt bout it "
                    },
                    {
                        "username": "sreshtha10",
                        "content": "Any idea how to optimize this solution? 47/49 cases passed\n\n```\n\nclass Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n\n        ROWS =  len(grid)\n        COLS = len(grid[0])\n\n        visited = []\n\n        def dfs(i,j,visited):\n            if(i<0 or j<0 or i>= ROWS or j>=COLS or grid[i][j] == '0' or (i,j) in visited):\n                return\n\n            visited.append((i,j))\n\n            dfs(i+1,j,visited)\n            dfs(i-1,j,visited)\n            dfs(i,j+1,visited)\n            dfs(i,j-1,visited)\n\n            return\n\n\n        \n        res = 0\n\n        for i in range(ROWS):\n            for j in range(COLS):\n                if grid[i][j] == '1' and (i,j) not in visited:\n                    res += 1\n                    dfs(i,j,visited)\n                    \n\n        return res \n\n\n\n\n```\n\n\n"
                    },
                    {
                        "username": "avyayk",
                        "content": "Your visited is a list and not a hashset. Using the in keyword will search linearly and not in O(1) time. Sorry dude, it\\'s a matter of like 3 characters"
                    },
                    {
                        "username": "LateStartToThings",
                        "content": "Don\\'t get why my solution is not quick enough to pass all the test cases. I feel like my BFS algorithm is effectively the same as most solutions...\\n\\nAny ideas?\\n\\n```java\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        // no empty grid edge case - m and n are >= 1\\n\\n        int islands = 0;\\n\\n        // each island is equal to completing a BFS search every time you find a \"1\" in the grid\\n        // to make sure we only consider that island once, we turn each visited \"1\" node into a \"0\"\\n        for (int i=0; i<grid.length; i++) {\\n            for (int j=0; j<grid[0].length; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    makeIsland(grid, i, j);\\n                    islands++;\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n\\n    // make an island at starting position (i,j) by using BFS to explore all neighbours\\n    private static void makeIsland(char[][] grid, int i, int j) {\\n        Queue<Pair<Integer, Integer>> q = new LinkedList<>();\\n        q.add(new Pair(i, j));\\n\\n        while (!q.isEmpty()) {\\n            Pair<Integer, Integer> p = q.poll();\\n            int pi = p.getKey(); int pj = p.getValue();\\n            grid[pi][pj] = \\'0\\';\\n\\n            List<Pair<Integer, Integer>> neighbours = neighbours(grid.length, grid[0].length, pi, pj);\\n            for (Pair<Integer, Integer> n : neighbours) {\\n                int ni = n.getKey();\\n                int nj = n.getValue();\\n                if (grid[ni][nj] == \\'1\\') {\\n                    q.add(new Pair(ni, nj));\\n                }\\n            }\\n        }\\n    }\\n\\n    // get all neighbours for any (i,j) in a (m x n) grid\\n    private static List<Pair<Integer, Integer>> neighbours(int m, int n, int i, int j) {\\n        List<Pair<Integer, Integer>> neighbours = new ArrayList<>();\\n\\n        // top, right, bottom, left respectively\\n        int[] di = {-1, 0, 1, 0};\\n        int[] dj = {0, 1, 0, -1};\\n        for (int k=0; k<di.length; k++) {\\n            int newI = i + di[k];\\n            int newJ = j + dj[k];\\n            if (newI >= 0 && newI < m && newJ >= 0 && newJ < n) {\\n                neighbours.add(new Pair<>(newI, newJ));\\n            }\\n        }\\n        return neighbours;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jethalol",
                        "content": "This should be easy level problem and not medium. Its literally just dfs and there are already plenty of problems like this"
                    }
                ]
            },
            {
                "id": 1808562,
                "content": [
                    {
                        "username": "avyayk",
                        "content": "So this BFS Python solution is overwritten compared to some of the solutions I see. But I don\\'t understand why it\\'s fundamentally too slow. I have this issue nearly every time I do a BFS\\n\\n`class Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n\\n        # Readability\\n        ROW, COLUMN = 0, 1\\n\\n        # Lambda to check if a square is in bounds\\n        inBounds = lambda coordinate: ( 0 <= coordinate[ROW] < len(grid) ) and ( 0 <= coordinate[COLUMN] < len( grid[0] ) )\\n        isLand = lambda coordinate: inBounds(coordinate) and grid[ coordinate[ROW] ][ coordinate[COLUMN] ] == \\'1\\'\\n\\n        # Track islands and their positions\\n        islandCount = 0\\n\\n        # Create a breadth first search queue\\n        cartographyQueue = []\\n        \\n        # Go through the grid and breadth first search\\n        for row in range( len(grid) ):\\n            for column in range( len(grid[0]) ):\\n                \\n                # If we\\'ve hit land, enqueue item and breadth first search to change all linked 1\\'s to 0\\'s\\n                if grid[row][column] == \\'1\\':\\n                    \\n                    # Increment the islandCount\\n                    islandCount += 1\\n\\n                    cartographyQueue.append( (row, column) )\\n\\n                    while cartographyQueue:\\n\\n                        currentPosition = cartographyQueue.pop(0)\\n\\n                        # Change the currentPosition to water so it has been \\'visited\\'\\n                        grid[ currentPosition[ROW] ][ currentPosition[COLUMN] ] = \\'0\\'\\n\\n                        # Search up down left and right\\n                        adjacentSquares = [ ( ( currentPosition[ROW]-1 ), currentPosition[COLUMN] ), ( (currentPosition[ROW]+1), currentPosition[COLUMN] ), ( currentPosition[ROW], currentPosition[COLUMN]-1 ), ( currentPosition[ROW], currentPosition[COLUMN]+1 ) ]\\n                        \\n                        # Enqueue valid neighbors \\n                        for neighbor in adjacentSquares:\\n                            if isLand(neighbor):\\n                                cartographyQueue.append( neighbor )\\n        \\n        # Final return\\n        return islandCount`"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "Please improve the question and description of the problem, these kind of lazy problem descriptions are useless to the problem solver. Glad I saw the top comment here."
                    },
                    {
                        "username": "runtimErr0r",
                        "content": "My DFS code is giving TLE on the 47th testcase, although the BFS one works fine. Someone please help me...\\n\\n `your inline code...your inline code...`\\nclass Solution {\\n\\nprivate:\\n\\n    void DFS(int r,int c,vector<vector<char>> grid,vector<vector<int>>& visited){\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(r<0||c<0||r==n||c==m) return;\\n        if(visited[r][c]==1||grid[r][c]!=\\'1\\') return;\\n        visited[r][c]=1;\\n        DFS(r-1,c,grid,visited);\\n        DFS(r,c-1,grid,visited);\\n        DFS(r+1,c,grid,visited);\\n        DFS(r,c+1,grid,visited);\\n    }\\n\\npublic:\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        int count=0;\\n        vector<vector<int>> visited(rows,vector<int>(cols,0));\\n        for(int row=0;row<rows;row++){\\n            for(int col=0;col<cols;col++){\\n                if(grid[row][col]==\\'1\\'&&!visited[row][col]){\\n                    count++;\\n                    DFS(row,col,grid,visited);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "SnappyBoye",
                        "content": "TLE.... thoughts?\\n```py\\nfrom collections import deque\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n\\n        def bfs(i,j, grid):\\n\\n            to_visit = deque([(i, j)])\\n\\n            while to_visit:\\n                curri, currj = to_visit[0]\\n                to_visit.popleft()\\n\\n                # mark current node \\n                grid[curri][currj] = \\'0\\'\\n                \\n                adj_dims = [(curri + 1, currj), (curri - 1, currj), \\\\\\n                    (curri, currj + 1), (curri, currj-1)]\\n                filtered = []\\n                \\n                # make sure not out of bounds\\n                for x, y in adj_dims:\\n                    m, n = len(grid), len(grid[0])\\n                    if x < m and x >= 0 and y < n and y >= 0:\\n                        filtered.append((x, y))\\n\\n                for x, y in filtered:\\n                    if grid[x][y] == \\'1\\':\\n                        to_visit.append((x, y))\\n            \\n        soln = 0\\n        for row in range(m):\\n            for col in range(n):\\n                if grid[row][col] == \\'1\\':\\n                    # see an island\\n                    soln += 1 \\n                    # mark it \\n                    bfs(row, col, grid)\\n                    \\n        return soln\\n\\n\\n\\n\\n\\n```"
                    },
                    {
                        "username": "whoami_112",
                        "content": "comment\\nWhy its giving TLE \\nclass Solution {\\npublic:\\n    vector<int>dx={1,-1,0,0,};\\n    vector<int>dy={0,0,-1,1,};\\n    int numIslands(vector<vector<char>>& grid) {\\n        int ans=0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==\\'0\\')continue;\\n                ans++;\\n                q.push({i,j});\\n                while(!q.empty()){\\n                    int x=q.front().first;\\n                    int y=q.front().second;\\n                    q.pop();\\n                    grid[x][y]=\\'0\\';\\n                    for(int k=0;k<4;k++){\\n                        if(x+dx[k]>=0 and x+dx[k]<n and y+dy[k]>=0 and y+dy[k]<m and grid[x+dx[k]][y+dy[k]]==\\'1\\')q.push({x+dx[k],y+dy[k]});\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Himanshu_78",
                        "content": "\\n/// WHY I AM NOT ABLE TO SUBMIT THIS SOLUTION, in my local IDE is working fine with same test cases. Leetcode showing WRONG ANS\\n\\nclass Solution {\\n\\n    int dx[] = {0, 1, 0 -1, 0};\\n    public int numIslands(char[][] grid) {\\n        int count = 0;\\n\\n       if (grid == null || grid.length == 0) return 0;\\n        \\n        boolean[][] vis = new boolean[grid.length][grid[0].length];\\n        for(int i = 0; i< grid.length; i++){\\n            for(int j = 0; j< grid[0].length; j++){\\n                if(grid[i][j] == \\'1\\' && !vis[i][j]){\\n                    count++;\\n                    find(i, j, grid, vis);\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public void find(int row, int col, char[][] grid, boolean[][] vis){\\n        vis[row][col] = true;\\n        Queue<Pair> p = new LinkedList<Pair>();\\n        p.add(new Pair(row, col));\\n\\n        while(!p.isEmpty()){\\n            Pair q = p.poll();\\n            int mRow = q.i;\\n            int mCol = q.j;\\n\\n            for(int i = 0; i< dx.length -1; i++){\\n                int cRow = mRow + dx[i];\\n                int cCol = mCol + dx[i + 1];\\n\\n                if(cRow >= 0 && cRow < grid.length && cCol >= 0 && cCol < grid[0].length &&\\n                !vis[cRow][cCol] && grid[cRow][cCol] == \\'1\\'){\\n                    vis[cRow][cCol] = true;\\n                    p.add(new Pair(cRow, cCol));\\n                    \\n                }\\n            }\\n        }\\n\\n    }\\n}\\n\\nclass Pair{\\n    int i;\\n    int j;\\n\\n    Pair(int i, int j){\\n        this.i = i;\\n        this.j = j;\\n    }\\n}"
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "the string \"1\" messed me up so bad but managed to fix it , just a little butthurt bout it "
                    },
                    {
                        "username": "sreshtha10",
                        "content": "Any idea how to optimize this solution? 47/49 cases passed\n\n```\n\nclass Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n\n        ROWS =  len(grid)\n        COLS = len(grid[0])\n\n        visited = []\n\n        def dfs(i,j,visited):\n            if(i<0 or j<0 or i>= ROWS or j>=COLS or grid[i][j] == '0' or (i,j) in visited):\n                return\n\n            visited.append((i,j))\n\n            dfs(i+1,j,visited)\n            dfs(i-1,j,visited)\n            dfs(i,j+1,visited)\n            dfs(i,j-1,visited)\n\n            return\n\n\n        \n        res = 0\n\n        for i in range(ROWS):\n            for j in range(COLS):\n                if grid[i][j] == '1' and (i,j) not in visited:\n                    res += 1\n                    dfs(i,j,visited)\n                    \n\n        return res \n\n\n\n\n```\n\n\n"
                    },
                    {
                        "username": "avyayk",
                        "content": "Your visited is a list and not a hashset. Using the in keyword will search linearly and not in O(1) time. Sorry dude, it\\'s a matter of like 3 characters"
                    },
                    {
                        "username": "LateStartToThings",
                        "content": "Don\\'t get why my solution is not quick enough to pass all the test cases. I feel like my BFS algorithm is effectively the same as most solutions...\\n\\nAny ideas?\\n\\n```java\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        // no empty grid edge case - m and n are >= 1\\n\\n        int islands = 0;\\n\\n        // each island is equal to completing a BFS search every time you find a \"1\" in the grid\\n        // to make sure we only consider that island once, we turn each visited \"1\" node into a \"0\"\\n        for (int i=0; i<grid.length; i++) {\\n            for (int j=0; j<grid[0].length; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    makeIsland(grid, i, j);\\n                    islands++;\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n\\n    // make an island at starting position (i,j) by using BFS to explore all neighbours\\n    private static void makeIsland(char[][] grid, int i, int j) {\\n        Queue<Pair<Integer, Integer>> q = new LinkedList<>();\\n        q.add(new Pair(i, j));\\n\\n        while (!q.isEmpty()) {\\n            Pair<Integer, Integer> p = q.poll();\\n            int pi = p.getKey(); int pj = p.getValue();\\n            grid[pi][pj] = \\'0\\';\\n\\n            List<Pair<Integer, Integer>> neighbours = neighbours(grid.length, grid[0].length, pi, pj);\\n            for (Pair<Integer, Integer> n : neighbours) {\\n                int ni = n.getKey();\\n                int nj = n.getValue();\\n                if (grid[ni][nj] == \\'1\\') {\\n                    q.add(new Pair(ni, nj));\\n                }\\n            }\\n        }\\n    }\\n\\n    // get all neighbours for any (i,j) in a (m x n) grid\\n    private static List<Pair<Integer, Integer>> neighbours(int m, int n, int i, int j) {\\n        List<Pair<Integer, Integer>> neighbours = new ArrayList<>();\\n\\n        // top, right, bottom, left respectively\\n        int[] di = {-1, 0, 1, 0};\\n        int[] dj = {0, 1, 0, -1};\\n        for (int k=0; k<di.length; k++) {\\n            int newI = i + di[k];\\n            int newJ = j + dj[k];\\n            if (newI >= 0 && newI < m && newJ >= 0 && newJ < n) {\\n                neighbours.add(new Pair<>(newI, newJ));\\n            }\\n        }\\n        return neighbours;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jethalol",
                        "content": "This should be easy level problem and not medium. Its literally just dfs and there are already plenty of problems like this"
                    }
                ]
            },
            {
                "id": 1799886,
                "content": [
                    {
                        "username": "avyayk",
                        "content": "So this BFS Python solution is overwritten compared to some of the solutions I see. But I don\\'t understand why it\\'s fundamentally too slow. I have this issue nearly every time I do a BFS\\n\\n`class Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n\\n        # Readability\\n        ROW, COLUMN = 0, 1\\n\\n        # Lambda to check if a square is in bounds\\n        inBounds = lambda coordinate: ( 0 <= coordinate[ROW] < len(grid) ) and ( 0 <= coordinate[COLUMN] < len( grid[0] ) )\\n        isLand = lambda coordinate: inBounds(coordinate) and grid[ coordinate[ROW] ][ coordinate[COLUMN] ] == \\'1\\'\\n\\n        # Track islands and their positions\\n        islandCount = 0\\n\\n        # Create a breadth first search queue\\n        cartographyQueue = []\\n        \\n        # Go through the grid and breadth first search\\n        for row in range( len(grid) ):\\n            for column in range( len(grid[0]) ):\\n                \\n                # If we\\'ve hit land, enqueue item and breadth first search to change all linked 1\\'s to 0\\'s\\n                if grid[row][column] == \\'1\\':\\n                    \\n                    # Increment the islandCount\\n                    islandCount += 1\\n\\n                    cartographyQueue.append( (row, column) )\\n\\n                    while cartographyQueue:\\n\\n                        currentPosition = cartographyQueue.pop(0)\\n\\n                        # Change the currentPosition to water so it has been \\'visited\\'\\n                        grid[ currentPosition[ROW] ][ currentPosition[COLUMN] ] = \\'0\\'\\n\\n                        # Search up down left and right\\n                        adjacentSquares = [ ( ( currentPosition[ROW]-1 ), currentPosition[COLUMN] ), ( (currentPosition[ROW]+1), currentPosition[COLUMN] ), ( currentPosition[ROW], currentPosition[COLUMN]-1 ), ( currentPosition[ROW], currentPosition[COLUMN]+1 ) ]\\n                        \\n                        # Enqueue valid neighbors \\n                        for neighbor in adjacentSquares:\\n                            if isLand(neighbor):\\n                                cartographyQueue.append( neighbor )\\n        \\n        # Final return\\n        return islandCount`"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "Please improve the question and description of the problem, these kind of lazy problem descriptions are useless to the problem solver. Glad I saw the top comment here."
                    },
                    {
                        "username": "runtimErr0r",
                        "content": "My DFS code is giving TLE on the 47th testcase, although the BFS one works fine. Someone please help me...\\n\\n `your inline code...your inline code...`\\nclass Solution {\\n\\nprivate:\\n\\n    void DFS(int r,int c,vector<vector<char>> grid,vector<vector<int>>& visited){\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(r<0||c<0||r==n||c==m) return;\\n        if(visited[r][c]==1||grid[r][c]!=\\'1\\') return;\\n        visited[r][c]=1;\\n        DFS(r-1,c,grid,visited);\\n        DFS(r,c-1,grid,visited);\\n        DFS(r+1,c,grid,visited);\\n        DFS(r,c+1,grid,visited);\\n    }\\n\\npublic:\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        int count=0;\\n        vector<vector<int>> visited(rows,vector<int>(cols,0));\\n        for(int row=0;row<rows;row++){\\n            for(int col=0;col<cols;col++){\\n                if(grid[row][col]==\\'1\\'&&!visited[row][col]){\\n                    count++;\\n                    DFS(row,col,grid,visited);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "SnappyBoye",
                        "content": "TLE.... thoughts?\\n```py\\nfrom collections import deque\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n\\n        def bfs(i,j, grid):\\n\\n            to_visit = deque([(i, j)])\\n\\n            while to_visit:\\n                curri, currj = to_visit[0]\\n                to_visit.popleft()\\n\\n                # mark current node \\n                grid[curri][currj] = \\'0\\'\\n                \\n                adj_dims = [(curri + 1, currj), (curri - 1, currj), \\\\\\n                    (curri, currj + 1), (curri, currj-1)]\\n                filtered = []\\n                \\n                # make sure not out of bounds\\n                for x, y in adj_dims:\\n                    m, n = len(grid), len(grid[0])\\n                    if x < m and x >= 0 and y < n and y >= 0:\\n                        filtered.append((x, y))\\n\\n                for x, y in filtered:\\n                    if grid[x][y] == \\'1\\':\\n                        to_visit.append((x, y))\\n            \\n        soln = 0\\n        for row in range(m):\\n            for col in range(n):\\n                if grid[row][col] == \\'1\\':\\n                    # see an island\\n                    soln += 1 \\n                    # mark it \\n                    bfs(row, col, grid)\\n                    \\n        return soln\\n\\n\\n\\n\\n\\n```"
                    },
                    {
                        "username": "whoami_112",
                        "content": "comment\\nWhy its giving TLE \\nclass Solution {\\npublic:\\n    vector<int>dx={1,-1,0,0,};\\n    vector<int>dy={0,0,-1,1,};\\n    int numIslands(vector<vector<char>>& grid) {\\n        int ans=0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==\\'0\\')continue;\\n                ans++;\\n                q.push({i,j});\\n                while(!q.empty()){\\n                    int x=q.front().first;\\n                    int y=q.front().second;\\n                    q.pop();\\n                    grid[x][y]=\\'0\\';\\n                    for(int k=0;k<4;k++){\\n                        if(x+dx[k]>=0 and x+dx[k]<n and y+dy[k]>=0 and y+dy[k]<m and grid[x+dx[k]][y+dy[k]]==\\'1\\')q.push({x+dx[k],y+dy[k]});\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Himanshu_78",
                        "content": "\\n/// WHY I AM NOT ABLE TO SUBMIT THIS SOLUTION, in my local IDE is working fine with same test cases. Leetcode showing WRONG ANS\\n\\nclass Solution {\\n\\n    int dx[] = {0, 1, 0 -1, 0};\\n    public int numIslands(char[][] grid) {\\n        int count = 0;\\n\\n       if (grid == null || grid.length == 0) return 0;\\n        \\n        boolean[][] vis = new boolean[grid.length][grid[0].length];\\n        for(int i = 0; i< grid.length; i++){\\n            for(int j = 0; j< grid[0].length; j++){\\n                if(grid[i][j] == \\'1\\' && !vis[i][j]){\\n                    count++;\\n                    find(i, j, grid, vis);\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public void find(int row, int col, char[][] grid, boolean[][] vis){\\n        vis[row][col] = true;\\n        Queue<Pair> p = new LinkedList<Pair>();\\n        p.add(new Pair(row, col));\\n\\n        while(!p.isEmpty()){\\n            Pair q = p.poll();\\n            int mRow = q.i;\\n            int mCol = q.j;\\n\\n            for(int i = 0; i< dx.length -1; i++){\\n                int cRow = mRow + dx[i];\\n                int cCol = mCol + dx[i + 1];\\n\\n                if(cRow >= 0 && cRow < grid.length && cCol >= 0 && cCol < grid[0].length &&\\n                !vis[cRow][cCol] && grid[cRow][cCol] == \\'1\\'){\\n                    vis[cRow][cCol] = true;\\n                    p.add(new Pair(cRow, cCol));\\n                    \\n                }\\n            }\\n        }\\n\\n    }\\n}\\n\\nclass Pair{\\n    int i;\\n    int j;\\n\\n    Pair(int i, int j){\\n        this.i = i;\\n        this.j = j;\\n    }\\n}"
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "the string \"1\" messed me up so bad but managed to fix it , just a little butthurt bout it "
                    },
                    {
                        "username": "sreshtha10",
                        "content": "Any idea how to optimize this solution? 47/49 cases passed\n\n```\n\nclass Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n\n        ROWS =  len(grid)\n        COLS = len(grid[0])\n\n        visited = []\n\n        def dfs(i,j,visited):\n            if(i<0 or j<0 or i>= ROWS or j>=COLS or grid[i][j] == '0' or (i,j) in visited):\n                return\n\n            visited.append((i,j))\n\n            dfs(i+1,j,visited)\n            dfs(i-1,j,visited)\n            dfs(i,j+1,visited)\n            dfs(i,j-1,visited)\n\n            return\n\n\n        \n        res = 0\n\n        for i in range(ROWS):\n            for j in range(COLS):\n                if grid[i][j] == '1' and (i,j) not in visited:\n                    res += 1\n                    dfs(i,j,visited)\n                    \n\n        return res \n\n\n\n\n```\n\n\n"
                    },
                    {
                        "username": "avyayk",
                        "content": "Your visited is a list and not a hashset. Using the in keyword will search linearly and not in O(1) time. Sorry dude, it\\'s a matter of like 3 characters"
                    },
                    {
                        "username": "LateStartToThings",
                        "content": "Don\\'t get why my solution is not quick enough to pass all the test cases. I feel like my BFS algorithm is effectively the same as most solutions...\\n\\nAny ideas?\\n\\n```java\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        // no empty grid edge case - m and n are >= 1\\n\\n        int islands = 0;\\n\\n        // each island is equal to completing a BFS search every time you find a \"1\" in the grid\\n        // to make sure we only consider that island once, we turn each visited \"1\" node into a \"0\"\\n        for (int i=0; i<grid.length; i++) {\\n            for (int j=0; j<grid[0].length; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    makeIsland(grid, i, j);\\n                    islands++;\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n\\n    // make an island at starting position (i,j) by using BFS to explore all neighbours\\n    private static void makeIsland(char[][] grid, int i, int j) {\\n        Queue<Pair<Integer, Integer>> q = new LinkedList<>();\\n        q.add(new Pair(i, j));\\n\\n        while (!q.isEmpty()) {\\n            Pair<Integer, Integer> p = q.poll();\\n            int pi = p.getKey(); int pj = p.getValue();\\n            grid[pi][pj] = \\'0\\';\\n\\n            List<Pair<Integer, Integer>> neighbours = neighbours(grid.length, grid[0].length, pi, pj);\\n            for (Pair<Integer, Integer> n : neighbours) {\\n                int ni = n.getKey();\\n                int nj = n.getValue();\\n                if (grid[ni][nj] == \\'1\\') {\\n                    q.add(new Pair(ni, nj));\\n                }\\n            }\\n        }\\n    }\\n\\n    // get all neighbours for any (i,j) in a (m x n) grid\\n    private static List<Pair<Integer, Integer>> neighbours(int m, int n, int i, int j) {\\n        List<Pair<Integer, Integer>> neighbours = new ArrayList<>();\\n\\n        // top, right, bottom, left respectively\\n        int[] di = {-1, 0, 1, 0};\\n        int[] dj = {0, 1, 0, -1};\\n        for (int k=0; k<di.length; k++) {\\n            int newI = i + di[k];\\n            int newJ = j + dj[k];\\n            if (newI >= 0 && newI < m && newJ >= 0 && newJ < n) {\\n                neighbours.add(new Pair<>(newI, newJ));\\n            }\\n        }\\n        return neighbours;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jethalol",
                        "content": "This should be easy level problem and not medium. Its literally just dfs and there are already plenty of problems like this"
                    }
                ]
            },
            {
                "id": 1798174,
                "content": [
                    {
                        "username": "avyayk",
                        "content": "So this BFS Python solution is overwritten compared to some of the solutions I see. But I don\\'t understand why it\\'s fundamentally too slow. I have this issue nearly every time I do a BFS\\n\\n`class Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n\\n        # Readability\\n        ROW, COLUMN = 0, 1\\n\\n        # Lambda to check if a square is in bounds\\n        inBounds = lambda coordinate: ( 0 <= coordinate[ROW] < len(grid) ) and ( 0 <= coordinate[COLUMN] < len( grid[0] ) )\\n        isLand = lambda coordinate: inBounds(coordinate) and grid[ coordinate[ROW] ][ coordinate[COLUMN] ] == \\'1\\'\\n\\n        # Track islands and their positions\\n        islandCount = 0\\n\\n        # Create a breadth first search queue\\n        cartographyQueue = []\\n        \\n        # Go through the grid and breadth first search\\n        for row in range( len(grid) ):\\n            for column in range( len(grid[0]) ):\\n                \\n                # If we\\'ve hit land, enqueue item and breadth first search to change all linked 1\\'s to 0\\'s\\n                if grid[row][column] == \\'1\\':\\n                    \\n                    # Increment the islandCount\\n                    islandCount += 1\\n\\n                    cartographyQueue.append( (row, column) )\\n\\n                    while cartographyQueue:\\n\\n                        currentPosition = cartographyQueue.pop(0)\\n\\n                        # Change the currentPosition to water so it has been \\'visited\\'\\n                        grid[ currentPosition[ROW] ][ currentPosition[COLUMN] ] = \\'0\\'\\n\\n                        # Search up down left and right\\n                        adjacentSquares = [ ( ( currentPosition[ROW]-1 ), currentPosition[COLUMN] ), ( (currentPosition[ROW]+1), currentPosition[COLUMN] ), ( currentPosition[ROW], currentPosition[COLUMN]-1 ), ( currentPosition[ROW], currentPosition[COLUMN]+1 ) ]\\n                        \\n                        # Enqueue valid neighbors \\n                        for neighbor in adjacentSquares:\\n                            if isLand(neighbor):\\n                                cartographyQueue.append( neighbor )\\n        \\n        # Final return\\n        return islandCount`"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "Please improve the question and description of the problem, these kind of lazy problem descriptions are useless to the problem solver. Glad I saw the top comment here."
                    },
                    {
                        "username": "runtimErr0r",
                        "content": "My DFS code is giving TLE on the 47th testcase, although the BFS one works fine. Someone please help me...\\n\\n `your inline code...your inline code...`\\nclass Solution {\\n\\nprivate:\\n\\n    void DFS(int r,int c,vector<vector<char>> grid,vector<vector<int>>& visited){\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(r<0||c<0||r==n||c==m) return;\\n        if(visited[r][c]==1||grid[r][c]!=\\'1\\') return;\\n        visited[r][c]=1;\\n        DFS(r-1,c,grid,visited);\\n        DFS(r,c-1,grid,visited);\\n        DFS(r+1,c,grid,visited);\\n        DFS(r,c+1,grid,visited);\\n    }\\n\\npublic:\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        int count=0;\\n        vector<vector<int>> visited(rows,vector<int>(cols,0));\\n        for(int row=0;row<rows;row++){\\n            for(int col=0;col<cols;col++){\\n                if(grid[row][col]==\\'1\\'&&!visited[row][col]){\\n                    count++;\\n                    DFS(row,col,grid,visited);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n `your inline code...your inline code...`"
                    },
                    {
                        "username": "SnappyBoye",
                        "content": "TLE.... thoughts?\\n```py\\nfrom collections import deque\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n\\n        def bfs(i,j, grid):\\n\\n            to_visit = deque([(i, j)])\\n\\n            while to_visit:\\n                curri, currj = to_visit[0]\\n                to_visit.popleft()\\n\\n                # mark current node \\n                grid[curri][currj] = \\'0\\'\\n                \\n                adj_dims = [(curri + 1, currj), (curri - 1, currj), \\\\\\n                    (curri, currj + 1), (curri, currj-1)]\\n                filtered = []\\n                \\n                # make sure not out of bounds\\n                for x, y in adj_dims:\\n                    m, n = len(grid), len(grid[0])\\n                    if x < m and x >= 0 and y < n and y >= 0:\\n                        filtered.append((x, y))\\n\\n                for x, y in filtered:\\n                    if grid[x][y] == \\'1\\':\\n                        to_visit.append((x, y))\\n            \\n        soln = 0\\n        for row in range(m):\\n            for col in range(n):\\n                if grid[row][col] == \\'1\\':\\n                    # see an island\\n                    soln += 1 \\n                    # mark it \\n                    bfs(row, col, grid)\\n                    \\n        return soln\\n\\n\\n\\n\\n\\n```"
                    },
                    {
                        "username": "whoami_112",
                        "content": "comment\\nWhy its giving TLE \\nclass Solution {\\npublic:\\n    vector<int>dx={1,-1,0,0,};\\n    vector<int>dy={0,0,-1,1,};\\n    int numIslands(vector<vector<char>>& grid) {\\n        int ans=0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==\\'0\\')continue;\\n                ans++;\\n                q.push({i,j});\\n                while(!q.empty()){\\n                    int x=q.front().first;\\n                    int y=q.front().second;\\n                    q.pop();\\n                    grid[x][y]=\\'0\\';\\n                    for(int k=0;k<4;k++){\\n                        if(x+dx[k]>=0 and x+dx[k]<n and y+dy[k]>=0 and y+dy[k]<m and grid[x+dx[k]][y+dy[k]]==\\'1\\')q.push({x+dx[k],y+dy[k]});\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Himanshu_78",
                        "content": "\\n/// WHY I AM NOT ABLE TO SUBMIT THIS SOLUTION, in my local IDE is working fine with same test cases. Leetcode showing WRONG ANS\\n\\nclass Solution {\\n\\n    int dx[] = {0, 1, 0 -1, 0};\\n    public int numIslands(char[][] grid) {\\n        int count = 0;\\n\\n       if (grid == null || grid.length == 0) return 0;\\n        \\n        boolean[][] vis = new boolean[grid.length][grid[0].length];\\n        for(int i = 0; i< grid.length; i++){\\n            for(int j = 0; j< grid[0].length; j++){\\n                if(grid[i][j] == \\'1\\' && !vis[i][j]){\\n                    count++;\\n                    find(i, j, grid, vis);\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public void find(int row, int col, char[][] grid, boolean[][] vis){\\n        vis[row][col] = true;\\n        Queue<Pair> p = new LinkedList<Pair>();\\n        p.add(new Pair(row, col));\\n\\n        while(!p.isEmpty()){\\n            Pair q = p.poll();\\n            int mRow = q.i;\\n            int mCol = q.j;\\n\\n            for(int i = 0; i< dx.length -1; i++){\\n                int cRow = mRow + dx[i];\\n                int cCol = mCol + dx[i + 1];\\n\\n                if(cRow >= 0 && cRow < grid.length && cCol >= 0 && cCol < grid[0].length &&\\n                !vis[cRow][cCol] && grid[cRow][cCol] == \\'1\\'){\\n                    vis[cRow][cCol] = true;\\n                    p.add(new Pair(cRow, cCol));\\n                    \\n                }\\n            }\\n        }\\n\\n    }\\n}\\n\\nclass Pair{\\n    int i;\\n    int j;\\n\\n    Pair(int i, int j){\\n        this.i = i;\\n        this.j = j;\\n    }\\n}"
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "the string \"1\" messed me up so bad but managed to fix it , just a little butthurt bout it "
                    },
                    {
                        "username": "sreshtha10",
                        "content": "Any idea how to optimize this solution? 47/49 cases passed\n\n```\n\nclass Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n\n        ROWS =  len(grid)\n        COLS = len(grid[0])\n\n        visited = []\n\n        def dfs(i,j,visited):\n            if(i<0 or j<0 or i>= ROWS or j>=COLS or grid[i][j] == '0' or (i,j) in visited):\n                return\n\n            visited.append((i,j))\n\n            dfs(i+1,j,visited)\n            dfs(i-1,j,visited)\n            dfs(i,j+1,visited)\n            dfs(i,j-1,visited)\n\n            return\n\n\n        \n        res = 0\n\n        for i in range(ROWS):\n            for j in range(COLS):\n                if grid[i][j] == '1' and (i,j) not in visited:\n                    res += 1\n                    dfs(i,j,visited)\n                    \n\n        return res \n\n\n\n\n```\n\n\n"
                    },
                    {
                        "username": "avyayk",
                        "content": "Your visited is a list and not a hashset. Using the in keyword will search linearly and not in O(1) time. Sorry dude, it\\'s a matter of like 3 characters"
                    },
                    {
                        "username": "LateStartToThings",
                        "content": "Don\\'t get why my solution is not quick enough to pass all the test cases. I feel like my BFS algorithm is effectively the same as most solutions...\\n\\nAny ideas?\\n\\n```java\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        // no empty grid edge case - m and n are >= 1\\n\\n        int islands = 0;\\n\\n        // each island is equal to completing a BFS search every time you find a \"1\" in the grid\\n        // to make sure we only consider that island once, we turn each visited \"1\" node into a \"0\"\\n        for (int i=0; i<grid.length; i++) {\\n            for (int j=0; j<grid[0].length; j++) {\\n                if (grid[i][j] == \\'1\\') {\\n                    makeIsland(grid, i, j);\\n                    islands++;\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n\\n    // make an island at starting position (i,j) by using BFS to explore all neighbours\\n    private static void makeIsland(char[][] grid, int i, int j) {\\n        Queue<Pair<Integer, Integer>> q = new LinkedList<>();\\n        q.add(new Pair(i, j));\\n\\n        while (!q.isEmpty()) {\\n            Pair<Integer, Integer> p = q.poll();\\n            int pi = p.getKey(); int pj = p.getValue();\\n            grid[pi][pj] = \\'0\\';\\n\\n            List<Pair<Integer, Integer>> neighbours = neighbours(grid.length, grid[0].length, pi, pj);\\n            for (Pair<Integer, Integer> n : neighbours) {\\n                int ni = n.getKey();\\n                int nj = n.getValue();\\n                if (grid[ni][nj] == \\'1\\') {\\n                    q.add(new Pair(ni, nj));\\n                }\\n            }\\n        }\\n    }\\n\\n    // get all neighbours for any (i,j) in a (m x n) grid\\n    private static List<Pair<Integer, Integer>> neighbours(int m, int n, int i, int j) {\\n        List<Pair<Integer, Integer>> neighbours = new ArrayList<>();\\n\\n        // top, right, bottom, left respectively\\n        int[] di = {-1, 0, 1, 0};\\n        int[] dj = {0, 1, 0, -1};\\n        for (int k=0; k<di.length; k++) {\\n            int newI = i + di[k];\\n            int newJ = j + dj[k];\\n            if (newI >= 0 && newI < m && newJ >= 0 && newJ < n) {\\n                neighbours.add(new Pair<>(newI, newJ));\\n            }\\n        }\\n        return neighbours;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jethalol",
                        "content": "This should be easy level problem and not medium. Its literally just dfs and there are already plenty of problems like this"
                    }
                ]
            },
            {
                "id": 1785136,
                "content": [
                    {
                        "username": "anishd3139",
                        "content": "Anyone getting TLE on test case 47/49? Do not know where to optimize to make the code work."
                    },
                    {
                        "username": "dompolochak",
                        "content": "When solving in c++ DO NOT use pair = {x,y} syntax you will get a heap overload error the only change i made to my solution was using pair = make_pair(x,y) and it worked fine. I wasted so much time analysing my solution when it was just leetcode being dumb"
                    },
                    {
                        "username": "pt33",
                        "content": "Please help me debug my code:Im getting output as 4 instead of 1 in first test case.I have used bfs approach \\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int x,int y){\\n        first=x;\\n        second=y;\\n    }\\n}\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n    int m=grid.length;\\n    int n=grid[0].length;\\n    int visited[][]=new int[m][n];\\n    int cnt=0;\\n     for(int i=0;i<m;i++){\\n         for(int j=0;j<n;j++){\\n             if(grid[i][j]==\\'1\\' && visited[i][j]==0){\\n                 \\n                 bfs(grid,visited,i,j);\\n                 cnt++;\\n             }\\n         }\\n     }\\n     return cnt;\\n    }\\n    public void bfs(char grid[][],int[][] visited,int srow,int scol)\\n{ int m=grid.length;\\nint n=grid[0].length;\\n    Queue<Pair> q=new LinkedList<Pair>();\\n                 visited[srow][scol]=1;\\n                \\n                 q.add(new Pair(srow,scol));\\n                 while(!q.isEmpty()){\\n                     int r=q.peek().first;\\n                     int c=q.peek().second;\\n                     q.remove();\\n                     int fr[]={-1,0,1,0};\\n                     int fc[]={0,1,0,-1};\\n                     for(int i=0;i<4;i++){\\n                             r=r+fr[i];\\n                             c=c+fc[i];\\n                             \\n                             if(r>=0 && r<m && c >=0 && c<n && visited[r][c]==0 && grid[r][c]==\\'1\\'){\\n                              q.add(new Pair(r,c));\\n                              visited[r][c]=1;\\n                              \\n                             }\\n\\n                         }\\n                     }\\n\\n                 }\\n             \\n         \\n     \\n    \\n}\\n"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone please let me know where am i going wrong in this code..\\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int x,int y){\\n        first=x;\\n        second=y;\\n    }\\n}\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n    int m=grid.length;\\n    int n=grid[0].length;\\n    int visited[][]=new int[m][n];\\n    int cnt=0;\\n     for(int i=0;i<m;i++){\\n         for(int j=0;j<n;j++){\\n             if(grid[i][j]==\\'1\\' && visited[i][j]==0){\\n                 \\n                 bfs(grid,visited,i,j);\\n                 cnt++;\\n             }\\n         }\\n     }\\n     return cnt;\\n    }\\n    public void bfs(char grid[][],int[][] visited,int srow,int scol)\\n{ int m=grid.length;\\nint n=grid[0].length;\\n    Queue<Pair> q=new LinkedList<Pair>();\\n                 visited[srow][scol]=1;\\n                \\n                 q.add(new Pair(srow,scol));\\n                 while(!q.isEmpty()){\\n                     int r=q.peek().first;\\n                     int c=q.peek().second;\\n                     q.remove();\\n                     int fr[]={-1,0,1,0};\\n                     int fc[]={0,1,0,-1};\\n                     for(int i=0;i<4;i++){\\n                             r=r+fr[i];\\n                             c=c+fc[i];\\n                             \\n                             if(r>=0 && r<m && c >=0 && c<n && visited[r][c]==0 && grid[r][c]==\\'1\\'){\\n                              q.add(new Pair(r,c));\\n                              visited[r][c]=1;\\n                              \\n                             }\\n\\n                         }\\n                     }\\n\\n                 }\\n             \\n         \\n     \\n    \\n}"
                    },
                    {
                        "username": "Rajkotiya_Harit",
                        "content": "Can anybody explain time-complexity of my code , I am really confused !\\nclass Solution {\\npublic:\\n    bool vis[300][300];\\n    void mat_dekh(vector<vector<char>>& g , int i , int j)\\n    {\\n        if(i >= 0 and j >= 0 and i < g.size() and  j < g[i].size() and !vis[i][j] and g[i][j]==\\'1\\' )\\n        {\\n            vis[i][j] = true;\\n            mat_dekh(g,i+1,j);\\n            mat_dekh(g,i-1,j);\\n            mat_dekh(g,i,j-1);\\n            mat_dekh(g,i,j+1);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int ans = 0;\\n        for(int i = 0 ; i < grid.size() ;i++)\\n        {\\n            for(int j = 0 ; j < grid[i].size() ;j++)\\n            {\\n                if(!vis[i][j] and grid[i][j]==\\'1\\')\\n                {\\n                    mat_dekh(grid,i,j);\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "augustlakia",
                        "content": "Can anyone suggest a good solution in Java that uses queue?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "urminhirpara",
                        "content": "class Solution {\\npublic:\\n    void dfs(vector<vector<char>>& grid, int i, int j, int r, int c){\\n        if(grid[i][j] == \\'1\\'){\\n            grid[i][j] = \\'0\\';\\n            if(i>0) dfs(grid, i-1, j, r, c);\\n            if(j>0) dfs(grid, i, j-1, r, c);\\n            if(i<r-1) dfs(grid, i+1, j, r, c);\\n            if(i<c-1) dfs(grid, i, j+1, r, c);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int r = grid.size(), c = grid[0].size(), ans = 0;\\n        for(int i = 0; i < r; ++i){\\n            for(int j = 0; j < c; ++j){\\n                if(grid[i][j] == \\'1\\'){\\n                    ans++;\\n                    dfs(grid, i, j, r, c);\\n                }\\n            }\\n        }return ans;\\n        \\n    }\\n}\\ncan any one tell me what is problem in code??"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "WHY ???\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x608000000020 overflowed to 0x608000000008 (stl_vector.h)\\n\\n\\nclass Solution {\\n     void check(vector<vector<char>>&grid,int i,int j)\\n    {\\n        if(grid[i][j]!=\\'1\\'|| i<0 || i>=grid.size() || j<0 || j>=grid[0].size())\\n        return;\\n        // if(grid[i][j]==\\'1\\')\\n        grid[i][j]=\\'2\\';\\n        //vertical downward\\n check(grid,i+1,j);\\n            //right\\n            check(grid,i,j+1);\\n        //upward\\n      check(grid,i-1,j);\\n        \\n        //left\\n        check(grid,i,j-1);\\n\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int island=0;\\n        if(grid.size()==0)\\n        return 0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==\\'1\\')\\n                {\\n                    island++;\\n                 check(grid,i,j);\\n                }\\n            }\\n        }\\n        return island;\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "Pradip_Kathiriya",
                        "content": "class Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        ## Recursive approach\\n        row, col = len(grid), len(grid[0])\\n        visited = set()\\n        result = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \"1\" and (i,j) not in visited:\\n                    result += 1\\n                    self.dfs(i, j, row, col, visited, grid)\\n\\n        return result\\n\\n    \\n    def dfs(self, i, j, row, col, visited, grid):\\n        if i not in range(row) or j not in range(col) or (i,j) in visited or grid[i][j] == \"0\":\\n            return \\n\\n        visited.add((i,j))\\n\\n        self.dfs(i+1, j, row, col, visited, grid)\\n        self.dfs(i-1, j, row, col, visited, grid)\\n        self.dfs(i, j+1, row, col, visited, grid)\\n        self.dfs(i, j-1, row, col, visited, grid)\\n\\n        return \\n\\n    ## Iterative approach\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n\\n\\n        \\n        queue = []\\n        row, col = len(grid), len(grid[0])\\n        visited = set()\\n        result = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \"1\" and (i,j) not in visited:\\n                    result += 1\\n                    queue.append((i,j))\\n                    visited.add((i,j))\\n                    while queue:\\n                        (a,b) = queue.pop()  # currently it is DFS, if you change it to the queue.pop(0) it become BFS\\n                        if a - 1 >= 0 and grid[a-1][b] == \"1\" and (a-1,b) not in visited:\\n                            visited.add((a-1,b))\\n                            queue.append((a-1,b))\\n\\n                        if a + 1 < row and grid[a+1][b] == \"1\" and (a+1,b) not in visited:\\n                            visited.add((a+1,b))\\n                            queue.append((a+1,b))\\n\\n                        if b - 1 >= 0 and grid[a][b-1] == \"1\" and (a, b-1) not in visited:\\n                            visited.add((a,b-1))\\n                            queue.append((a,b-1))\\n\\n                        if b + 1 < col and grid[a][b+1] == \"1\" and (a, b+1) not in visited:\\n                            visited.add((a,b+1))\\n                            queue.append((a,b+1))\\n\\n        return result\\n\\n\\n\\n\\n    \\n"
                    }
                ]
            },
            {
                "id": 1778158,
                "content": [
                    {
                        "username": "anishd3139",
                        "content": "Anyone getting TLE on test case 47/49? Do not know where to optimize to make the code work."
                    },
                    {
                        "username": "dompolochak",
                        "content": "When solving in c++ DO NOT use pair = {x,y} syntax you will get a heap overload error the only change i made to my solution was using pair = make_pair(x,y) and it worked fine. I wasted so much time analysing my solution when it was just leetcode being dumb"
                    },
                    {
                        "username": "pt33",
                        "content": "Please help me debug my code:Im getting output as 4 instead of 1 in first test case.I have used bfs approach \\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int x,int y){\\n        first=x;\\n        second=y;\\n    }\\n}\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n    int m=grid.length;\\n    int n=grid[0].length;\\n    int visited[][]=new int[m][n];\\n    int cnt=0;\\n     for(int i=0;i<m;i++){\\n         for(int j=0;j<n;j++){\\n             if(grid[i][j]==\\'1\\' && visited[i][j]==0){\\n                 \\n                 bfs(grid,visited,i,j);\\n                 cnt++;\\n             }\\n         }\\n     }\\n     return cnt;\\n    }\\n    public void bfs(char grid[][],int[][] visited,int srow,int scol)\\n{ int m=grid.length;\\nint n=grid[0].length;\\n    Queue<Pair> q=new LinkedList<Pair>();\\n                 visited[srow][scol]=1;\\n                \\n                 q.add(new Pair(srow,scol));\\n                 while(!q.isEmpty()){\\n                     int r=q.peek().first;\\n                     int c=q.peek().second;\\n                     q.remove();\\n                     int fr[]={-1,0,1,0};\\n                     int fc[]={0,1,0,-1};\\n                     for(int i=0;i<4;i++){\\n                             r=r+fr[i];\\n                             c=c+fc[i];\\n                             \\n                             if(r>=0 && r<m && c >=0 && c<n && visited[r][c]==0 && grid[r][c]==\\'1\\'){\\n                              q.add(new Pair(r,c));\\n                              visited[r][c]=1;\\n                              \\n                             }\\n\\n                         }\\n                     }\\n\\n                 }\\n             \\n         \\n     \\n    \\n}\\n"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone please let me know where am i going wrong in this code..\\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int x,int y){\\n        first=x;\\n        second=y;\\n    }\\n}\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n    int m=grid.length;\\n    int n=grid[0].length;\\n    int visited[][]=new int[m][n];\\n    int cnt=0;\\n     for(int i=0;i<m;i++){\\n         for(int j=0;j<n;j++){\\n             if(grid[i][j]==\\'1\\' && visited[i][j]==0){\\n                 \\n                 bfs(grid,visited,i,j);\\n                 cnt++;\\n             }\\n         }\\n     }\\n     return cnt;\\n    }\\n    public void bfs(char grid[][],int[][] visited,int srow,int scol)\\n{ int m=grid.length;\\nint n=grid[0].length;\\n    Queue<Pair> q=new LinkedList<Pair>();\\n                 visited[srow][scol]=1;\\n                \\n                 q.add(new Pair(srow,scol));\\n                 while(!q.isEmpty()){\\n                     int r=q.peek().first;\\n                     int c=q.peek().second;\\n                     q.remove();\\n                     int fr[]={-1,0,1,0};\\n                     int fc[]={0,1,0,-1};\\n                     for(int i=0;i<4;i++){\\n                             r=r+fr[i];\\n                             c=c+fc[i];\\n                             \\n                             if(r>=0 && r<m && c >=0 && c<n && visited[r][c]==0 && grid[r][c]==\\'1\\'){\\n                              q.add(new Pair(r,c));\\n                              visited[r][c]=1;\\n                              \\n                             }\\n\\n                         }\\n                     }\\n\\n                 }\\n             \\n         \\n     \\n    \\n}"
                    },
                    {
                        "username": "Rajkotiya_Harit",
                        "content": "Can anybody explain time-complexity of my code , I am really confused !\\nclass Solution {\\npublic:\\n    bool vis[300][300];\\n    void mat_dekh(vector<vector<char>>& g , int i , int j)\\n    {\\n        if(i >= 0 and j >= 0 and i < g.size() and  j < g[i].size() and !vis[i][j] and g[i][j]==\\'1\\' )\\n        {\\n            vis[i][j] = true;\\n            mat_dekh(g,i+1,j);\\n            mat_dekh(g,i-1,j);\\n            mat_dekh(g,i,j-1);\\n            mat_dekh(g,i,j+1);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int ans = 0;\\n        for(int i = 0 ; i < grid.size() ;i++)\\n        {\\n            for(int j = 0 ; j < grid[i].size() ;j++)\\n            {\\n                if(!vis[i][j] and grid[i][j]==\\'1\\')\\n                {\\n                    mat_dekh(grid,i,j);\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "augustlakia",
                        "content": "Can anyone suggest a good solution in Java that uses queue?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "urminhirpara",
                        "content": "class Solution {\\npublic:\\n    void dfs(vector<vector<char>>& grid, int i, int j, int r, int c){\\n        if(grid[i][j] == \\'1\\'){\\n            grid[i][j] = \\'0\\';\\n            if(i>0) dfs(grid, i-1, j, r, c);\\n            if(j>0) dfs(grid, i, j-1, r, c);\\n            if(i<r-1) dfs(grid, i+1, j, r, c);\\n            if(i<c-1) dfs(grid, i, j+1, r, c);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int r = grid.size(), c = grid[0].size(), ans = 0;\\n        for(int i = 0; i < r; ++i){\\n            for(int j = 0; j < c; ++j){\\n                if(grid[i][j] == \\'1\\'){\\n                    ans++;\\n                    dfs(grid, i, j, r, c);\\n                }\\n            }\\n        }return ans;\\n        \\n    }\\n}\\ncan any one tell me what is problem in code??"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "WHY ???\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x608000000020 overflowed to 0x608000000008 (stl_vector.h)\\n\\n\\nclass Solution {\\n     void check(vector<vector<char>>&grid,int i,int j)\\n    {\\n        if(grid[i][j]!=\\'1\\'|| i<0 || i>=grid.size() || j<0 || j>=grid[0].size())\\n        return;\\n        // if(grid[i][j]==\\'1\\')\\n        grid[i][j]=\\'2\\';\\n        //vertical downward\\n check(grid,i+1,j);\\n            //right\\n            check(grid,i,j+1);\\n        //upward\\n      check(grid,i-1,j);\\n        \\n        //left\\n        check(grid,i,j-1);\\n\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int island=0;\\n        if(grid.size()==0)\\n        return 0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==\\'1\\')\\n                {\\n                    island++;\\n                 check(grid,i,j);\\n                }\\n            }\\n        }\\n        return island;\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "Pradip_Kathiriya",
                        "content": "class Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        ## Recursive approach\\n        row, col = len(grid), len(grid[0])\\n        visited = set()\\n        result = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \"1\" and (i,j) not in visited:\\n                    result += 1\\n                    self.dfs(i, j, row, col, visited, grid)\\n\\n        return result\\n\\n    \\n    def dfs(self, i, j, row, col, visited, grid):\\n        if i not in range(row) or j not in range(col) or (i,j) in visited or grid[i][j] == \"0\":\\n            return \\n\\n        visited.add((i,j))\\n\\n        self.dfs(i+1, j, row, col, visited, grid)\\n        self.dfs(i-1, j, row, col, visited, grid)\\n        self.dfs(i, j+1, row, col, visited, grid)\\n        self.dfs(i, j-1, row, col, visited, grid)\\n\\n        return \\n\\n    ## Iterative approach\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n\\n\\n        \\n        queue = []\\n        row, col = len(grid), len(grid[0])\\n        visited = set()\\n        result = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \"1\" and (i,j) not in visited:\\n                    result += 1\\n                    queue.append((i,j))\\n                    visited.add((i,j))\\n                    while queue:\\n                        (a,b) = queue.pop()  # currently it is DFS, if you change it to the queue.pop(0) it become BFS\\n                        if a - 1 >= 0 and grid[a-1][b] == \"1\" and (a-1,b) not in visited:\\n                            visited.add((a-1,b))\\n                            queue.append((a-1,b))\\n\\n                        if a + 1 < row and grid[a+1][b] == \"1\" and (a+1,b) not in visited:\\n                            visited.add((a+1,b))\\n                            queue.append((a+1,b))\\n\\n                        if b - 1 >= 0 and grid[a][b-1] == \"1\" and (a, b-1) not in visited:\\n                            visited.add((a,b-1))\\n                            queue.append((a,b-1))\\n\\n                        if b + 1 < col and grid[a][b+1] == \"1\" and (a, b+1) not in visited:\\n                            visited.add((a,b+1))\\n                            queue.append((a,b+1))\\n\\n        return result\\n\\n\\n\\n\\n    \\n"
                    }
                ]
            },
            {
                "id": 1772259,
                "content": [
                    {
                        "username": "anishd3139",
                        "content": "Anyone getting TLE on test case 47/49? Do not know where to optimize to make the code work."
                    },
                    {
                        "username": "dompolochak",
                        "content": "When solving in c++ DO NOT use pair = {x,y} syntax you will get a heap overload error the only change i made to my solution was using pair = make_pair(x,y) and it worked fine. I wasted so much time analysing my solution when it was just leetcode being dumb"
                    },
                    {
                        "username": "pt33",
                        "content": "Please help me debug my code:Im getting output as 4 instead of 1 in first test case.I have used bfs approach \\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int x,int y){\\n        first=x;\\n        second=y;\\n    }\\n}\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n    int m=grid.length;\\n    int n=grid[0].length;\\n    int visited[][]=new int[m][n];\\n    int cnt=0;\\n     for(int i=0;i<m;i++){\\n         for(int j=0;j<n;j++){\\n             if(grid[i][j]==\\'1\\' && visited[i][j]==0){\\n                 \\n                 bfs(grid,visited,i,j);\\n                 cnt++;\\n             }\\n         }\\n     }\\n     return cnt;\\n    }\\n    public void bfs(char grid[][],int[][] visited,int srow,int scol)\\n{ int m=grid.length;\\nint n=grid[0].length;\\n    Queue<Pair> q=new LinkedList<Pair>();\\n                 visited[srow][scol]=1;\\n                \\n                 q.add(new Pair(srow,scol));\\n                 while(!q.isEmpty()){\\n                     int r=q.peek().first;\\n                     int c=q.peek().second;\\n                     q.remove();\\n                     int fr[]={-1,0,1,0};\\n                     int fc[]={0,1,0,-1};\\n                     for(int i=0;i<4;i++){\\n                             r=r+fr[i];\\n                             c=c+fc[i];\\n                             \\n                             if(r>=0 && r<m && c >=0 && c<n && visited[r][c]==0 && grid[r][c]==\\'1\\'){\\n                              q.add(new Pair(r,c));\\n                              visited[r][c]=1;\\n                              \\n                             }\\n\\n                         }\\n                     }\\n\\n                 }\\n             \\n         \\n     \\n    \\n}\\n"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone please let me know where am i going wrong in this code..\\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int x,int y){\\n        first=x;\\n        second=y;\\n    }\\n}\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n    int m=grid.length;\\n    int n=grid[0].length;\\n    int visited[][]=new int[m][n];\\n    int cnt=0;\\n     for(int i=0;i<m;i++){\\n         for(int j=0;j<n;j++){\\n             if(grid[i][j]==\\'1\\' && visited[i][j]==0){\\n                 \\n                 bfs(grid,visited,i,j);\\n                 cnt++;\\n             }\\n         }\\n     }\\n     return cnt;\\n    }\\n    public void bfs(char grid[][],int[][] visited,int srow,int scol)\\n{ int m=grid.length;\\nint n=grid[0].length;\\n    Queue<Pair> q=new LinkedList<Pair>();\\n                 visited[srow][scol]=1;\\n                \\n                 q.add(new Pair(srow,scol));\\n                 while(!q.isEmpty()){\\n                     int r=q.peek().first;\\n                     int c=q.peek().second;\\n                     q.remove();\\n                     int fr[]={-1,0,1,0};\\n                     int fc[]={0,1,0,-1};\\n                     for(int i=0;i<4;i++){\\n                             r=r+fr[i];\\n                             c=c+fc[i];\\n                             \\n                             if(r>=0 && r<m && c >=0 && c<n && visited[r][c]==0 && grid[r][c]==\\'1\\'){\\n                              q.add(new Pair(r,c));\\n                              visited[r][c]=1;\\n                              \\n                             }\\n\\n                         }\\n                     }\\n\\n                 }\\n             \\n         \\n     \\n    \\n}"
                    },
                    {
                        "username": "Rajkotiya_Harit",
                        "content": "Can anybody explain time-complexity of my code , I am really confused !\\nclass Solution {\\npublic:\\n    bool vis[300][300];\\n    void mat_dekh(vector<vector<char>>& g , int i , int j)\\n    {\\n        if(i >= 0 and j >= 0 and i < g.size() and  j < g[i].size() and !vis[i][j] and g[i][j]==\\'1\\' )\\n        {\\n            vis[i][j] = true;\\n            mat_dekh(g,i+1,j);\\n            mat_dekh(g,i-1,j);\\n            mat_dekh(g,i,j-1);\\n            mat_dekh(g,i,j+1);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int ans = 0;\\n        for(int i = 0 ; i < grid.size() ;i++)\\n        {\\n            for(int j = 0 ; j < grid[i].size() ;j++)\\n            {\\n                if(!vis[i][j] and grid[i][j]==\\'1\\')\\n                {\\n                    mat_dekh(grid,i,j);\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "augustlakia",
                        "content": "Can anyone suggest a good solution in Java that uses queue?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "urminhirpara",
                        "content": "class Solution {\\npublic:\\n    void dfs(vector<vector<char>>& grid, int i, int j, int r, int c){\\n        if(grid[i][j] == \\'1\\'){\\n            grid[i][j] = \\'0\\';\\n            if(i>0) dfs(grid, i-1, j, r, c);\\n            if(j>0) dfs(grid, i, j-1, r, c);\\n            if(i<r-1) dfs(grid, i+1, j, r, c);\\n            if(i<c-1) dfs(grid, i, j+1, r, c);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int r = grid.size(), c = grid[0].size(), ans = 0;\\n        for(int i = 0; i < r; ++i){\\n            for(int j = 0; j < c; ++j){\\n                if(grid[i][j] == \\'1\\'){\\n                    ans++;\\n                    dfs(grid, i, j, r, c);\\n                }\\n            }\\n        }return ans;\\n        \\n    }\\n}\\ncan any one tell me what is problem in code??"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "WHY ???\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x608000000020 overflowed to 0x608000000008 (stl_vector.h)\\n\\n\\nclass Solution {\\n     void check(vector<vector<char>>&grid,int i,int j)\\n    {\\n        if(grid[i][j]!=\\'1\\'|| i<0 || i>=grid.size() || j<0 || j>=grid[0].size())\\n        return;\\n        // if(grid[i][j]==\\'1\\')\\n        grid[i][j]=\\'2\\';\\n        //vertical downward\\n check(grid,i+1,j);\\n            //right\\n            check(grid,i,j+1);\\n        //upward\\n      check(grid,i-1,j);\\n        \\n        //left\\n        check(grid,i,j-1);\\n\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int island=0;\\n        if(grid.size()==0)\\n        return 0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==\\'1\\')\\n                {\\n                    island++;\\n                 check(grid,i,j);\\n                }\\n            }\\n        }\\n        return island;\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "Pradip_Kathiriya",
                        "content": "class Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        ## Recursive approach\\n        row, col = len(grid), len(grid[0])\\n        visited = set()\\n        result = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \"1\" and (i,j) not in visited:\\n                    result += 1\\n                    self.dfs(i, j, row, col, visited, grid)\\n\\n        return result\\n\\n    \\n    def dfs(self, i, j, row, col, visited, grid):\\n        if i not in range(row) or j not in range(col) or (i,j) in visited or grid[i][j] == \"0\":\\n            return \\n\\n        visited.add((i,j))\\n\\n        self.dfs(i+1, j, row, col, visited, grid)\\n        self.dfs(i-1, j, row, col, visited, grid)\\n        self.dfs(i, j+1, row, col, visited, grid)\\n        self.dfs(i, j-1, row, col, visited, grid)\\n\\n        return \\n\\n    ## Iterative approach\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n\\n\\n        \\n        queue = []\\n        row, col = len(grid), len(grid[0])\\n        visited = set()\\n        result = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \"1\" and (i,j) not in visited:\\n                    result += 1\\n                    queue.append((i,j))\\n                    visited.add((i,j))\\n                    while queue:\\n                        (a,b) = queue.pop()  # currently it is DFS, if you change it to the queue.pop(0) it become BFS\\n                        if a - 1 >= 0 and grid[a-1][b] == \"1\" and (a-1,b) not in visited:\\n                            visited.add((a-1,b))\\n                            queue.append((a-1,b))\\n\\n                        if a + 1 < row and grid[a+1][b] == \"1\" and (a+1,b) not in visited:\\n                            visited.add((a+1,b))\\n                            queue.append((a+1,b))\\n\\n                        if b - 1 >= 0 and grid[a][b-1] == \"1\" and (a, b-1) not in visited:\\n                            visited.add((a,b-1))\\n                            queue.append((a,b-1))\\n\\n                        if b + 1 < col and grid[a][b+1] == \"1\" and (a, b+1) not in visited:\\n                            visited.add((a,b+1))\\n                            queue.append((a,b+1))\\n\\n        return result\\n\\n\\n\\n\\n    \\n"
                    }
                ]
            },
            {
                "id": 1769878,
                "content": [
                    {
                        "username": "anishd3139",
                        "content": "Anyone getting TLE on test case 47/49? Do not know where to optimize to make the code work."
                    },
                    {
                        "username": "dompolochak",
                        "content": "When solving in c++ DO NOT use pair = {x,y} syntax you will get a heap overload error the only change i made to my solution was using pair = make_pair(x,y) and it worked fine. I wasted so much time analysing my solution when it was just leetcode being dumb"
                    },
                    {
                        "username": "pt33",
                        "content": "Please help me debug my code:Im getting output as 4 instead of 1 in first test case.I have used bfs approach \\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int x,int y){\\n        first=x;\\n        second=y;\\n    }\\n}\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n    int m=grid.length;\\n    int n=grid[0].length;\\n    int visited[][]=new int[m][n];\\n    int cnt=0;\\n     for(int i=0;i<m;i++){\\n         for(int j=0;j<n;j++){\\n             if(grid[i][j]==\\'1\\' && visited[i][j]==0){\\n                 \\n                 bfs(grid,visited,i,j);\\n                 cnt++;\\n             }\\n         }\\n     }\\n     return cnt;\\n    }\\n    public void bfs(char grid[][],int[][] visited,int srow,int scol)\\n{ int m=grid.length;\\nint n=grid[0].length;\\n    Queue<Pair> q=new LinkedList<Pair>();\\n                 visited[srow][scol]=1;\\n                \\n                 q.add(new Pair(srow,scol));\\n                 while(!q.isEmpty()){\\n                     int r=q.peek().first;\\n                     int c=q.peek().second;\\n                     q.remove();\\n                     int fr[]={-1,0,1,0};\\n                     int fc[]={0,1,0,-1};\\n                     for(int i=0;i<4;i++){\\n                             r=r+fr[i];\\n                             c=c+fc[i];\\n                             \\n                             if(r>=0 && r<m && c >=0 && c<n && visited[r][c]==0 && grid[r][c]==\\'1\\'){\\n                              q.add(new Pair(r,c));\\n                              visited[r][c]=1;\\n                              \\n                             }\\n\\n                         }\\n                     }\\n\\n                 }\\n             \\n         \\n     \\n    \\n}\\n"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone please let me know where am i going wrong in this code..\\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int x,int y){\\n        first=x;\\n        second=y;\\n    }\\n}\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n    int m=grid.length;\\n    int n=grid[0].length;\\n    int visited[][]=new int[m][n];\\n    int cnt=0;\\n     for(int i=0;i<m;i++){\\n         for(int j=0;j<n;j++){\\n             if(grid[i][j]==\\'1\\' && visited[i][j]==0){\\n                 \\n                 bfs(grid,visited,i,j);\\n                 cnt++;\\n             }\\n         }\\n     }\\n     return cnt;\\n    }\\n    public void bfs(char grid[][],int[][] visited,int srow,int scol)\\n{ int m=grid.length;\\nint n=grid[0].length;\\n    Queue<Pair> q=new LinkedList<Pair>();\\n                 visited[srow][scol]=1;\\n                \\n                 q.add(new Pair(srow,scol));\\n                 while(!q.isEmpty()){\\n                     int r=q.peek().first;\\n                     int c=q.peek().second;\\n                     q.remove();\\n                     int fr[]={-1,0,1,0};\\n                     int fc[]={0,1,0,-1};\\n                     for(int i=0;i<4;i++){\\n                             r=r+fr[i];\\n                             c=c+fc[i];\\n                             \\n                             if(r>=0 && r<m && c >=0 && c<n && visited[r][c]==0 && grid[r][c]==\\'1\\'){\\n                              q.add(new Pair(r,c));\\n                              visited[r][c]=1;\\n                              \\n                             }\\n\\n                         }\\n                     }\\n\\n                 }\\n             \\n         \\n     \\n    \\n}"
                    },
                    {
                        "username": "Rajkotiya_Harit",
                        "content": "Can anybody explain time-complexity of my code , I am really confused !\\nclass Solution {\\npublic:\\n    bool vis[300][300];\\n    void mat_dekh(vector<vector<char>>& g , int i , int j)\\n    {\\n        if(i >= 0 and j >= 0 and i < g.size() and  j < g[i].size() and !vis[i][j] and g[i][j]==\\'1\\' )\\n        {\\n            vis[i][j] = true;\\n            mat_dekh(g,i+1,j);\\n            mat_dekh(g,i-1,j);\\n            mat_dekh(g,i,j-1);\\n            mat_dekh(g,i,j+1);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int ans = 0;\\n        for(int i = 0 ; i < grid.size() ;i++)\\n        {\\n            for(int j = 0 ; j < grid[i].size() ;j++)\\n            {\\n                if(!vis[i][j] and grid[i][j]==\\'1\\')\\n                {\\n                    mat_dekh(grid,i,j);\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "augustlakia",
                        "content": "Can anyone suggest a good solution in Java that uses queue?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "urminhirpara",
                        "content": "class Solution {\\npublic:\\n    void dfs(vector<vector<char>>& grid, int i, int j, int r, int c){\\n        if(grid[i][j] == \\'1\\'){\\n            grid[i][j] = \\'0\\';\\n            if(i>0) dfs(grid, i-1, j, r, c);\\n            if(j>0) dfs(grid, i, j-1, r, c);\\n            if(i<r-1) dfs(grid, i+1, j, r, c);\\n            if(i<c-1) dfs(grid, i, j+1, r, c);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int r = grid.size(), c = grid[0].size(), ans = 0;\\n        for(int i = 0; i < r; ++i){\\n            for(int j = 0; j < c; ++j){\\n                if(grid[i][j] == \\'1\\'){\\n                    ans++;\\n                    dfs(grid, i, j, r, c);\\n                }\\n            }\\n        }return ans;\\n        \\n    }\\n}\\ncan any one tell me what is problem in code??"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "WHY ???\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x608000000020 overflowed to 0x608000000008 (stl_vector.h)\\n\\n\\nclass Solution {\\n     void check(vector<vector<char>>&grid,int i,int j)\\n    {\\n        if(grid[i][j]!=\\'1\\'|| i<0 || i>=grid.size() || j<0 || j>=grid[0].size())\\n        return;\\n        // if(grid[i][j]==\\'1\\')\\n        grid[i][j]=\\'2\\';\\n        //vertical downward\\n check(grid,i+1,j);\\n            //right\\n            check(grid,i,j+1);\\n        //upward\\n      check(grid,i-1,j);\\n        \\n        //left\\n        check(grid,i,j-1);\\n\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int island=0;\\n        if(grid.size()==0)\\n        return 0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==\\'1\\')\\n                {\\n                    island++;\\n                 check(grid,i,j);\\n                }\\n            }\\n        }\\n        return island;\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "Pradip_Kathiriya",
                        "content": "class Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        ## Recursive approach\\n        row, col = len(grid), len(grid[0])\\n        visited = set()\\n        result = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \"1\" and (i,j) not in visited:\\n                    result += 1\\n                    self.dfs(i, j, row, col, visited, grid)\\n\\n        return result\\n\\n    \\n    def dfs(self, i, j, row, col, visited, grid):\\n        if i not in range(row) or j not in range(col) or (i,j) in visited or grid[i][j] == \"0\":\\n            return \\n\\n        visited.add((i,j))\\n\\n        self.dfs(i+1, j, row, col, visited, grid)\\n        self.dfs(i-1, j, row, col, visited, grid)\\n        self.dfs(i, j+1, row, col, visited, grid)\\n        self.dfs(i, j-1, row, col, visited, grid)\\n\\n        return \\n\\n    ## Iterative approach\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n\\n\\n        \\n        queue = []\\n        row, col = len(grid), len(grid[0])\\n        visited = set()\\n        result = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \"1\" and (i,j) not in visited:\\n                    result += 1\\n                    queue.append((i,j))\\n                    visited.add((i,j))\\n                    while queue:\\n                        (a,b) = queue.pop()  # currently it is DFS, if you change it to the queue.pop(0) it become BFS\\n                        if a - 1 >= 0 and grid[a-1][b] == \"1\" and (a-1,b) not in visited:\\n                            visited.add((a-1,b))\\n                            queue.append((a-1,b))\\n\\n                        if a + 1 < row and grid[a+1][b] == \"1\" and (a+1,b) not in visited:\\n                            visited.add((a+1,b))\\n                            queue.append((a+1,b))\\n\\n                        if b - 1 >= 0 and grid[a][b-1] == \"1\" and (a, b-1) not in visited:\\n                            visited.add((a,b-1))\\n                            queue.append((a,b-1))\\n\\n                        if b + 1 < col and grid[a][b+1] == \"1\" and (a, b+1) not in visited:\\n                            visited.add((a,b+1))\\n                            queue.append((a,b+1))\\n\\n        return result\\n\\n\\n\\n\\n    \\n"
                    }
                ]
            },
            {
                "id": 1769432,
                "content": [
                    {
                        "username": "anishd3139",
                        "content": "Anyone getting TLE on test case 47/49? Do not know where to optimize to make the code work."
                    },
                    {
                        "username": "dompolochak",
                        "content": "When solving in c++ DO NOT use pair = {x,y} syntax you will get a heap overload error the only change i made to my solution was using pair = make_pair(x,y) and it worked fine. I wasted so much time analysing my solution when it was just leetcode being dumb"
                    },
                    {
                        "username": "pt33",
                        "content": "Please help me debug my code:Im getting output as 4 instead of 1 in first test case.I have used bfs approach \\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int x,int y){\\n        first=x;\\n        second=y;\\n    }\\n}\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n    int m=grid.length;\\n    int n=grid[0].length;\\n    int visited[][]=new int[m][n];\\n    int cnt=0;\\n     for(int i=0;i<m;i++){\\n         for(int j=0;j<n;j++){\\n             if(grid[i][j]==\\'1\\' && visited[i][j]==0){\\n                 \\n                 bfs(grid,visited,i,j);\\n                 cnt++;\\n             }\\n         }\\n     }\\n     return cnt;\\n    }\\n    public void bfs(char grid[][],int[][] visited,int srow,int scol)\\n{ int m=grid.length;\\nint n=grid[0].length;\\n    Queue<Pair> q=new LinkedList<Pair>();\\n                 visited[srow][scol]=1;\\n                \\n                 q.add(new Pair(srow,scol));\\n                 while(!q.isEmpty()){\\n                     int r=q.peek().first;\\n                     int c=q.peek().second;\\n                     q.remove();\\n                     int fr[]={-1,0,1,0};\\n                     int fc[]={0,1,0,-1};\\n                     for(int i=0;i<4;i++){\\n                             r=r+fr[i];\\n                             c=c+fc[i];\\n                             \\n                             if(r>=0 && r<m && c >=0 && c<n && visited[r][c]==0 && grid[r][c]==\\'1\\'){\\n                              q.add(new Pair(r,c));\\n                              visited[r][c]=1;\\n                              \\n                             }\\n\\n                         }\\n                     }\\n\\n                 }\\n             \\n         \\n     \\n    \\n}\\n"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone please let me know where am i going wrong in this code..\\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int x,int y){\\n        first=x;\\n        second=y;\\n    }\\n}\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n    int m=grid.length;\\n    int n=grid[0].length;\\n    int visited[][]=new int[m][n];\\n    int cnt=0;\\n     for(int i=0;i<m;i++){\\n         for(int j=0;j<n;j++){\\n             if(grid[i][j]==\\'1\\' && visited[i][j]==0){\\n                 \\n                 bfs(grid,visited,i,j);\\n                 cnt++;\\n             }\\n         }\\n     }\\n     return cnt;\\n    }\\n    public void bfs(char grid[][],int[][] visited,int srow,int scol)\\n{ int m=grid.length;\\nint n=grid[0].length;\\n    Queue<Pair> q=new LinkedList<Pair>();\\n                 visited[srow][scol]=1;\\n                \\n                 q.add(new Pair(srow,scol));\\n                 while(!q.isEmpty()){\\n                     int r=q.peek().first;\\n                     int c=q.peek().second;\\n                     q.remove();\\n                     int fr[]={-1,0,1,0};\\n                     int fc[]={0,1,0,-1};\\n                     for(int i=0;i<4;i++){\\n                             r=r+fr[i];\\n                             c=c+fc[i];\\n                             \\n                             if(r>=0 && r<m && c >=0 && c<n && visited[r][c]==0 && grid[r][c]==\\'1\\'){\\n                              q.add(new Pair(r,c));\\n                              visited[r][c]=1;\\n                              \\n                             }\\n\\n                         }\\n                     }\\n\\n                 }\\n             \\n         \\n     \\n    \\n}"
                    },
                    {
                        "username": "Rajkotiya_Harit",
                        "content": "Can anybody explain time-complexity of my code , I am really confused !\\nclass Solution {\\npublic:\\n    bool vis[300][300];\\n    void mat_dekh(vector<vector<char>>& g , int i , int j)\\n    {\\n        if(i >= 0 and j >= 0 and i < g.size() and  j < g[i].size() and !vis[i][j] and g[i][j]==\\'1\\' )\\n        {\\n            vis[i][j] = true;\\n            mat_dekh(g,i+1,j);\\n            mat_dekh(g,i-1,j);\\n            mat_dekh(g,i,j-1);\\n            mat_dekh(g,i,j+1);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int ans = 0;\\n        for(int i = 0 ; i < grid.size() ;i++)\\n        {\\n            for(int j = 0 ; j < grid[i].size() ;j++)\\n            {\\n                if(!vis[i][j] and grid[i][j]==\\'1\\')\\n                {\\n                    mat_dekh(grid,i,j);\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "augustlakia",
                        "content": "Can anyone suggest a good solution in Java that uses queue?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "urminhirpara",
                        "content": "class Solution {\\npublic:\\n    void dfs(vector<vector<char>>& grid, int i, int j, int r, int c){\\n        if(grid[i][j] == \\'1\\'){\\n            grid[i][j] = \\'0\\';\\n            if(i>0) dfs(grid, i-1, j, r, c);\\n            if(j>0) dfs(grid, i, j-1, r, c);\\n            if(i<r-1) dfs(grid, i+1, j, r, c);\\n            if(i<c-1) dfs(grid, i, j+1, r, c);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int r = grid.size(), c = grid[0].size(), ans = 0;\\n        for(int i = 0; i < r; ++i){\\n            for(int j = 0; j < c; ++j){\\n                if(grid[i][j] == \\'1\\'){\\n                    ans++;\\n                    dfs(grid, i, j, r, c);\\n                }\\n            }\\n        }return ans;\\n        \\n    }\\n}\\ncan any one tell me what is problem in code??"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "WHY ???\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x608000000020 overflowed to 0x608000000008 (stl_vector.h)\\n\\n\\nclass Solution {\\n     void check(vector<vector<char>>&grid,int i,int j)\\n    {\\n        if(grid[i][j]!=\\'1\\'|| i<0 || i>=grid.size() || j<0 || j>=grid[0].size())\\n        return;\\n        // if(grid[i][j]==\\'1\\')\\n        grid[i][j]=\\'2\\';\\n        //vertical downward\\n check(grid,i+1,j);\\n            //right\\n            check(grid,i,j+1);\\n        //upward\\n      check(grid,i-1,j);\\n        \\n        //left\\n        check(grid,i,j-1);\\n\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int island=0;\\n        if(grid.size()==0)\\n        return 0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==\\'1\\')\\n                {\\n                    island++;\\n                 check(grid,i,j);\\n                }\\n            }\\n        }\\n        return island;\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "Pradip_Kathiriya",
                        "content": "class Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        ## Recursive approach\\n        row, col = len(grid), len(grid[0])\\n        visited = set()\\n        result = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \"1\" and (i,j) not in visited:\\n                    result += 1\\n                    self.dfs(i, j, row, col, visited, grid)\\n\\n        return result\\n\\n    \\n    def dfs(self, i, j, row, col, visited, grid):\\n        if i not in range(row) or j not in range(col) or (i,j) in visited or grid[i][j] == \"0\":\\n            return \\n\\n        visited.add((i,j))\\n\\n        self.dfs(i+1, j, row, col, visited, grid)\\n        self.dfs(i-1, j, row, col, visited, grid)\\n        self.dfs(i, j+1, row, col, visited, grid)\\n        self.dfs(i, j-1, row, col, visited, grid)\\n\\n        return \\n\\n    ## Iterative approach\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n\\n\\n        \\n        queue = []\\n        row, col = len(grid), len(grid[0])\\n        visited = set()\\n        result = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \"1\" and (i,j) not in visited:\\n                    result += 1\\n                    queue.append((i,j))\\n                    visited.add((i,j))\\n                    while queue:\\n                        (a,b) = queue.pop()  # currently it is DFS, if you change it to the queue.pop(0) it become BFS\\n                        if a - 1 >= 0 and grid[a-1][b] == \"1\" and (a-1,b) not in visited:\\n                            visited.add((a-1,b))\\n                            queue.append((a-1,b))\\n\\n                        if a + 1 < row and grid[a+1][b] == \"1\" and (a+1,b) not in visited:\\n                            visited.add((a+1,b))\\n                            queue.append((a+1,b))\\n\\n                        if b - 1 >= 0 and grid[a][b-1] == \"1\" and (a, b-1) not in visited:\\n                            visited.add((a,b-1))\\n                            queue.append((a,b-1))\\n\\n                        if b + 1 < col and grid[a][b+1] == \"1\" and (a, b+1) not in visited:\\n                            visited.add((a,b+1))\\n                            queue.append((a,b+1))\\n\\n        return result\\n\\n\\n\\n\\n    \\n"
                    }
                ]
            },
            {
                "id": 1763022,
                "content": [
                    {
                        "username": "anishd3139",
                        "content": "Anyone getting TLE on test case 47/49? Do not know where to optimize to make the code work."
                    },
                    {
                        "username": "dompolochak",
                        "content": "When solving in c++ DO NOT use pair = {x,y} syntax you will get a heap overload error the only change i made to my solution was using pair = make_pair(x,y) and it worked fine. I wasted so much time analysing my solution when it was just leetcode being dumb"
                    },
                    {
                        "username": "pt33",
                        "content": "Please help me debug my code:Im getting output as 4 instead of 1 in first test case.I have used bfs approach \\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int x,int y){\\n        first=x;\\n        second=y;\\n    }\\n}\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n    int m=grid.length;\\n    int n=grid[0].length;\\n    int visited[][]=new int[m][n];\\n    int cnt=0;\\n     for(int i=0;i<m;i++){\\n         for(int j=0;j<n;j++){\\n             if(grid[i][j]==\\'1\\' && visited[i][j]==0){\\n                 \\n                 bfs(grid,visited,i,j);\\n                 cnt++;\\n             }\\n         }\\n     }\\n     return cnt;\\n    }\\n    public void bfs(char grid[][],int[][] visited,int srow,int scol)\\n{ int m=grid.length;\\nint n=grid[0].length;\\n    Queue<Pair> q=new LinkedList<Pair>();\\n                 visited[srow][scol]=1;\\n                \\n                 q.add(new Pair(srow,scol));\\n                 while(!q.isEmpty()){\\n                     int r=q.peek().first;\\n                     int c=q.peek().second;\\n                     q.remove();\\n                     int fr[]={-1,0,1,0};\\n                     int fc[]={0,1,0,-1};\\n                     for(int i=0;i<4;i++){\\n                             r=r+fr[i];\\n                             c=c+fc[i];\\n                             \\n                             if(r>=0 && r<m && c >=0 && c<n && visited[r][c]==0 && grid[r][c]==\\'1\\'){\\n                              q.add(new Pair(r,c));\\n                              visited[r][c]=1;\\n                              \\n                             }\\n\\n                         }\\n                     }\\n\\n                 }\\n             \\n         \\n     \\n    \\n}\\n"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone please let me know where am i going wrong in this code..\\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int x,int y){\\n        first=x;\\n        second=y;\\n    }\\n}\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n    int m=grid.length;\\n    int n=grid[0].length;\\n    int visited[][]=new int[m][n];\\n    int cnt=0;\\n     for(int i=0;i<m;i++){\\n         for(int j=0;j<n;j++){\\n             if(grid[i][j]==\\'1\\' && visited[i][j]==0){\\n                 \\n                 bfs(grid,visited,i,j);\\n                 cnt++;\\n             }\\n         }\\n     }\\n     return cnt;\\n    }\\n    public void bfs(char grid[][],int[][] visited,int srow,int scol)\\n{ int m=grid.length;\\nint n=grid[0].length;\\n    Queue<Pair> q=new LinkedList<Pair>();\\n                 visited[srow][scol]=1;\\n                \\n                 q.add(new Pair(srow,scol));\\n                 while(!q.isEmpty()){\\n                     int r=q.peek().first;\\n                     int c=q.peek().second;\\n                     q.remove();\\n                     int fr[]={-1,0,1,0};\\n                     int fc[]={0,1,0,-1};\\n                     for(int i=0;i<4;i++){\\n                             r=r+fr[i];\\n                             c=c+fc[i];\\n                             \\n                             if(r>=0 && r<m && c >=0 && c<n && visited[r][c]==0 && grid[r][c]==\\'1\\'){\\n                              q.add(new Pair(r,c));\\n                              visited[r][c]=1;\\n                              \\n                             }\\n\\n                         }\\n                     }\\n\\n                 }\\n             \\n         \\n     \\n    \\n}"
                    },
                    {
                        "username": "Rajkotiya_Harit",
                        "content": "Can anybody explain time-complexity of my code , I am really confused !\\nclass Solution {\\npublic:\\n    bool vis[300][300];\\n    void mat_dekh(vector<vector<char>>& g , int i , int j)\\n    {\\n        if(i >= 0 and j >= 0 and i < g.size() and  j < g[i].size() and !vis[i][j] and g[i][j]==\\'1\\' )\\n        {\\n            vis[i][j] = true;\\n            mat_dekh(g,i+1,j);\\n            mat_dekh(g,i-1,j);\\n            mat_dekh(g,i,j-1);\\n            mat_dekh(g,i,j+1);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int ans = 0;\\n        for(int i = 0 ; i < grid.size() ;i++)\\n        {\\n            for(int j = 0 ; j < grid[i].size() ;j++)\\n            {\\n                if(!vis[i][j] and grid[i][j]==\\'1\\')\\n                {\\n                    mat_dekh(grid,i,j);\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "augustlakia",
                        "content": "Can anyone suggest a good solution in Java that uses queue?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "urminhirpara",
                        "content": "class Solution {\\npublic:\\n    void dfs(vector<vector<char>>& grid, int i, int j, int r, int c){\\n        if(grid[i][j] == \\'1\\'){\\n            grid[i][j] = \\'0\\';\\n            if(i>0) dfs(grid, i-1, j, r, c);\\n            if(j>0) dfs(grid, i, j-1, r, c);\\n            if(i<r-1) dfs(grid, i+1, j, r, c);\\n            if(i<c-1) dfs(grid, i, j+1, r, c);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int r = grid.size(), c = grid[0].size(), ans = 0;\\n        for(int i = 0; i < r; ++i){\\n            for(int j = 0; j < c; ++j){\\n                if(grid[i][j] == \\'1\\'){\\n                    ans++;\\n                    dfs(grid, i, j, r, c);\\n                }\\n            }\\n        }return ans;\\n        \\n    }\\n}\\ncan any one tell me what is problem in code??"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "WHY ???\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x608000000020 overflowed to 0x608000000008 (stl_vector.h)\\n\\n\\nclass Solution {\\n     void check(vector<vector<char>>&grid,int i,int j)\\n    {\\n        if(grid[i][j]!=\\'1\\'|| i<0 || i>=grid.size() || j<0 || j>=grid[0].size())\\n        return;\\n        // if(grid[i][j]==\\'1\\')\\n        grid[i][j]=\\'2\\';\\n        //vertical downward\\n check(grid,i+1,j);\\n            //right\\n            check(grid,i,j+1);\\n        //upward\\n      check(grid,i-1,j);\\n        \\n        //left\\n        check(grid,i,j-1);\\n\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int island=0;\\n        if(grid.size()==0)\\n        return 0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==\\'1\\')\\n                {\\n                    island++;\\n                 check(grid,i,j);\\n                }\\n            }\\n        }\\n        return island;\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "Pradip_Kathiriya",
                        "content": "class Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        ## Recursive approach\\n        row, col = len(grid), len(grid[0])\\n        visited = set()\\n        result = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \"1\" and (i,j) not in visited:\\n                    result += 1\\n                    self.dfs(i, j, row, col, visited, grid)\\n\\n        return result\\n\\n    \\n    def dfs(self, i, j, row, col, visited, grid):\\n        if i not in range(row) or j not in range(col) or (i,j) in visited or grid[i][j] == \"0\":\\n            return \\n\\n        visited.add((i,j))\\n\\n        self.dfs(i+1, j, row, col, visited, grid)\\n        self.dfs(i-1, j, row, col, visited, grid)\\n        self.dfs(i, j+1, row, col, visited, grid)\\n        self.dfs(i, j-1, row, col, visited, grid)\\n\\n        return \\n\\n    ## Iterative approach\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n\\n\\n        \\n        queue = []\\n        row, col = len(grid), len(grid[0])\\n        visited = set()\\n        result = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \"1\" and (i,j) not in visited:\\n                    result += 1\\n                    queue.append((i,j))\\n                    visited.add((i,j))\\n                    while queue:\\n                        (a,b) = queue.pop()  # currently it is DFS, if you change it to the queue.pop(0) it become BFS\\n                        if a - 1 >= 0 and grid[a-1][b] == \"1\" and (a-1,b) not in visited:\\n                            visited.add((a-1,b))\\n                            queue.append((a-1,b))\\n\\n                        if a + 1 < row and grid[a+1][b] == \"1\" and (a+1,b) not in visited:\\n                            visited.add((a+1,b))\\n                            queue.append((a+1,b))\\n\\n                        if b - 1 >= 0 and grid[a][b-1] == \"1\" and (a, b-1) not in visited:\\n                            visited.add((a,b-1))\\n                            queue.append((a,b-1))\\n\\n                        if b + 1 < col and grid[a][b+1] == \"1\" and (a, b+1) not in visited:\\n                            visited.add((a,b+1))\\n                            queue.append((a,b+1))\\n\\n        return result\\n\\n\\n\\n\\n    \\n"
                    }
                ]
            },
            {
                "id": 1757511,
                "content": [
                    {
                        "username": "anishd3139",
                        "content": "Anyone getting TLE on test case 47/49? Do not know where to optimize to make the code work."
                    },
                    {
                        "username": "dompolochak",
                        "content": "When solving in c++ DO NOT use pair = {x,y} syntax you will get a heap overload error the only change i made to my solution was using pair = make_pair(x,y) and it worked fine. I wasted so much time analysing my solution when it was just leetcode being dumb"
                    },
                    {
                        "username": "pt33",
                        "content": "Please help me debug my code:Im getting output as 4 instead of 1 in first test case.I have used bfs approach \\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int x,int y){\\n        first=x;\\n        second=y;\\n    }\\n}\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n    int m=grid.length;\\n    int n=grid[0].length;\\n    int visited[][]=new int[m][n];\\n    int cnt=0;\\n     for(int i=0;i<m;i++){\\n         for(int j=0;j<n;j++){\\n             if(grid[i][j]==\\'1\\' && visited[i][j]==0){\\n                 \\n                 bfs(grid,visited,i,j);\\n                 cnt++;\\n             }\\n         }\\n     }\\n     return cnt;\\n    }\\n    public void bfs(char grid[][],int[][] visited,int srow,int scol)\\n{ int m=grid.length;\\nint n=grid[0].length;\\n    Queue<Pair> q=new LinkedList<Pair>();\\n                 visited[srow][scol]=1;\\n                \\n                 q.add(new Pair(srow,scol));\\n                 while(!q.isEmpty()){\\n                     int r=q.peek().first;\\n                     int c=q.peek().second;\\n                     q.remove();\\n                     int fr[]={-1,0,1,0};\\n                     int fc[]={0,1,0,-1};\\n                     for(int i=0;i<4;i++){\\n                             r=r+fr[i];\\n                             c=c+fc[i];\\n                             \\n                             if(r>=0 && r<m && c >=0 && c<n && visited[r][c]==0 && grid[r][c]==\\'1\\'){\\n                              q.add(new Pair(r,c));\\n                              visited[r][c]=1;\\n                              \\n                             }\\n\\n                         }\\n                     }\\n\\n                 }\\n             \\n         \\n     \\n    \\n}\\n"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone please let me know where am i going wrong in this code..\\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int x,int y){\\n        first=x;\\n        second=y;\\n    }\\n}\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n    int m=grid.length;\\n    int n=grid[0].length;\\n    int visited[][]=new int[m][n];\\n    int cnt=0;\\n     for(int i=0;i<m;i++){\\n         for(int j=0;j<n;j++){\\n             if(grid[i][j]==\\'1\\' && visited[i][j]==0){\\n                 \\n                 bfs(grid,visited,i,j);\\n                 cnt++;\\n             }\\n         }\\n     }\\n     return cnt;\\n    }\\n    public void bfs(char grid[][],int[][] visited,int srow,int scol)\\n{ int m=grid.length;\\nint n=grid[0].length;\\n    Queue<Pair> q=new LinkedList<Pair>();\\n                 visited[srow][scol]=1;\\n                \\n                 q.add(new Pair(srow,scol));\\n                 while(!q.isEmpty()){\\n                     int r=q.peek().first;\\n                     int c=q.peek().second;\\n                     q.remove();\\n                     int fr[]={-1,0,1,0};\\n                     int fc[]={0,1,0,-1};\\n                     for(int i=0;i<4;i++){\\n                             r=r+fr[i];\\n                             c=c+fc[i];\\n                             \\n                             if(r>=0 && r<m && c >=0 && c<n && visited[r][c]==0 && grid[r][c]==\\'1\\'){\\n                              q.add(new Pair(r,c));\\n                              visited[r][c]=1;\\n                              \\n                             }\\n\\n                         }\\n                     }\\n\\n                 }\\n             \\n         \\n     \\n    \\n}"
                    },
                    {
                        "username": "Rajkotiya_Harit",
                        "content": "Can anybody explain time-complexity of my code , I am really confused !\\nclass Solution {\\npublic:\\n    bool vis[300][300];\\n    void mat_dekh(vector<vector<char>>& g , int i , int j)\\n    {\\n        if(i >= 0 and j >= 0 and i < g.size() and  j < g[i].size() and !vis[i][j] and g[i][j]==\\'1\\' )\\n        {\\n            vis[i][j] = true;\\n            mat_dekh(g,i+1,j);\\n            mat_dekh(g,i-1,j);\\n            mat_dekh(g,i,j-1);\\n            mat_dekh(g,i,j+1);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int ans = 0;\\n        for(int i = 0 ; i < grid.size() ;i++)\\n        {\\n            for(int j = 0 ; j < grid[i].size() ;j++)\\n            {\\n                if(!vis[i][j] and grid[i][j]==\\'1\\')\\n                {\\n                    mat_dekh(grid,i,j);\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "augustlakia",
                        "content": "Can anyone suggest a good solution in Java that uses queue?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "urminhirpara",
                        "content": "class Solution {\\npublic:\\n    void dfs(vector<vector<char>>& grid, int i, int j, int r, int c){\\n        if(grid[i][j] == \\'1\\'){\\n            grid[i][j] = \\'0\\';\\n            if(i>0) dfs(grid, i-1, j, r, c);\\n            if(j>0) dfs(grid, i, j-1, r, c);\\n            if(i<r-1) dfs(grid, i+1, j, r, c);\\n            if(i<c-1) dfs(grid, i, j+1, r, c);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int r = grid.size(), c = grid[0].size(), ans = 0;\\n        for(int i = 0; i < r; ++i){\\n            for(int j = 0; j < c; ++j){\\n                if(grid[i][j] == \\'1\\'){\\n                    ans++;\\n                    dfs(grid, i, j, r, c);\\n                }\\n            }\\n        }return ans;\\n        \\n    }\\n}\\ncan any one tell me what is problem in code??"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "WHY ???\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x608000000020 overflowed to 0x608000000008 (stl_vector.h)\\n\\n\\nclass Solution {\\n     void check(vector<vector<char>>&grid,int i,int j)\\n    {\\n        if(grid[i][j]!=\\'1\\'|| i<0 || i>=grid.size() || j<0 || j>=grid[0].size())\\n        return;\\n        // if(grid[i][j]==\\'1\\')\\n        grid[i][j]=\\'2\\';\\n        //vertical downward\\n check(grid,i+1,j);\\n            //right\\n            check(grid,i,j+1);\\n        //upward\\n      check(grid,i-1,j);\\n        \\n        //left\\n        check(grid,i,j-1);\\n\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int island=0;\\n        if(grid.size()==0)\\n        return 0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==\\'1\\')\\n                {\\n                    island++;\\n                 check(grid,i,j);\\n                }\\n            }\\n        }\\n        return island;\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "Pradip_Kathiriya",
                        "content": "class Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        ## Recursive approach\\n        row, col = len(grid), len(grid[0])\\n        visited = set()\\n        result = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \"1\" and (i,j) not in visited:\\n                    result += 1\\n                    self.dfs(i, j, row, col, visited, grid)\\n\\n        return result\\n\\n    \\n    def dfs(self, i, j, row, col, visited, grid):\\n        if i not in range(row) or j not in range(col) or (i,j) in visited or grid[i][j] == \"0\":\\n            return \\n\\n        visited.add((i,j))\\n\\n        self.dfs(i+1, j, row, col, visited, grid)\\n        self.dfs(i-1, j, row, col, visited, grid)\\n        self.dfs(i, j+1, row, col, visited, grid)\\n        self.dfs(i, j-1, row, col, visited, grid)\\n\\n        return \\n\\n    ## Iterative approach\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n\\n\\n        \\n        queue = []\\n        row, col = len(grid), len(grid[0])\\n        visited = set()\\n        result = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \"1\" and (i,j) not in visited:\\n                    result += 1\\n                    queue.append((i,j))\\n                    visited.add((i,j))\\n                    while queue:\\n                        (a,b) = queue.pop()  # currently it is DFS, if you change it to the queue.pop(0) it become BFS\\n                        if a - 1 >= 0 and grid[a-1][b] == \"1\" and (a-1,b) not in visited:\\n                            visited.add((a-1,b))\\n                            queue.append((a-1,b))\\n\\n                        if a + 1 < row and grid[a+1][b] == \"1\" and (a+1,b) not in visited:\\n                            visited.add((a+1,b))\\n                            queue.append((a+1,b))\\n\\n                        if b - 1 >= 0 and grid[a][b-1] == \"1\" and (a, b-1) not in visited:\\n                            visited.add((a,b-1))\\n                            queue.append((a,b-1))\\n\\n                        if b + 1 < col and grid[a][b+1] == \"1\" and (a, b+1) not in visited:\\n                            visited.add((a,b+1))\\n                            queue.append((a,b+1))\\n\\n        return result\\n\\n\\n\\n\\n    \\n"
                    }
                ]
            },
            {
                "id": 1755691,
                "content": [
                    {
                        "username": "anishd3139",
                        "content": "Anyone getting TLE on test case 47/49? Do not know where to optimize to make the code work."
                    },
                    {
                        "username": "dompolochak",
                        "content": "When solving in c++ DO NOT use pair = {x,y} syntax you will get a heap overload error the only change i made to my solution was using pair = make_pair(x,y) and it worked fine. I wasted so much time analysing my solution when it was just leetcode being dumb"
                    },
                    {
                        "username": "pt33",
                        "content": "Please help me debug my code:Im getting output as 4 instead of 1 in first test case.I have used bfs approach \\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int x,int y){\\n        first=x;\\n        second=y;\\n    }\\n}\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n    int m=grid.length;\\n    int n=grid[0].length;\\n    int visited[][]=new int[m][n];\\n    int cnt=0;\\n     for(int i=0;i<m;i++){\\n         for(int j=0;j<n;j++){\\n             if(grid[i][j]==\\'1\\' && visited[i][j]==0){\\n                 \\n                 bfs(grid,visited,i,j);\\n                 cnt++;\\n             }\\n         }\\n     }\\n     return cnt;\\n    }\\n    public void bfs(char grid[][],int[][] visited,int srow,int scol)\\n{ int m=grid.length;\\nint n=grid[0].length;\\n    Queue<Pair> q=new LinkedList<Pair>();\\n                 visited[srow][scol]=1;\\n                \\n                 q.add(new Pair(srow,scol));\\n                 while(!q.isEmpty()){\\n                     int r=q.peek().first;\\n                     int c=q.peek().second;\\n                     q.remove();\\n                     int fr[]={-1,0,1,0};\\n                     int fc[]={0,1,0,-1};\\n                     for(int i=0;i<4;i++){\\n                             r=r+fr[i];\\n                             c=c+fc[i];\\n                             \\n                             if(r>=0 && r<m && c >=0 && c<n && visited[r][c]==0 && grid[r][c]==\\'1\\'){\\n                              q.add(new Pair(r,c));\\n                              visited[r][c]=1;\\n                              \\n                             }\\n\\n                         }\\n                     }\\n\\n                 }\\n             \\n         \\n     \\n    \\n}\\n"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone please let me know where am i going wrong in this code..\\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int x,int y){\\n        first=x;\\n        second=y;\\n    }\\n}\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n    int m=grid.length;\\n    int n=grid[0].length;\\n    int visited[][]=new int[m][n];\\n    int cnt=0;\\n     for(int i=0;i<m;i++){\\n         for(int j=0;j<n;j++){\\n             if(grid[i][j]==\\'1\\' && visited[i][j]==0){\\n                 \\n                 bfs(grid,visited,i,j);\\n                 cnt++;\\n             }\\n         }\\n     }\\n     return cnt;\\n    }\\n    public void bfs(char grid[][],int[][] visited,int srow,int scol)\\n{ int m=grid.length;\\nint n=grid[0].length;\\n    Queue<Pair> q=new LinkedList<Pair>();\\n                 visited[srow][scol]=1;\\n                \\n                 q.add(new Pair(srow,scol));\\n                 while(!q.isEmpty()){\\n                     int r=q.peek().first;\\n                     int c=q.peek().second;\\n                     q.remove();\\n                     int fr[]={-1,0,1,0};\\n                     int fc[]={0,1,0,-1};\\n                     for(int i=0;i<4;i++){\\n                             r=r+fr[i];\\n                             c=c+fc[i];\\n                             \\n                             if(r>=0 && r<m && c >=0 && c<n && visited[r][c]==0 && grid[r][c]==\\'1\\'){\\n                              q.add(new Pair(r,c));\\n                              visited[r][c]=1;\\n                              \\n                             }\\n\\n                         }\\n                     }\\n\\n                 }\\n             \\n         \\n     \\n    \\n}"
                    },
                    {
                        "username": "Rajkotiya_Harit",
                        "content": "Can anybody explain time-complexity of my code , I am really confused !\\nclass Solution {\\npublic:\\n    bool vis[300][300];\\n    void mat_dekh(vector<vector<char>>& g , int i , int j)\\n    {\\n        if(i >= 0 and j >= 0 and i < g.size() and  j < g[i].size() and !vis[i][j] and g[i][j]==\\'1\\' )\\n        {\\n            vis[i][j] = true;\\n            mat_dekh(g,i+1,j);\\n            mat_dekh(g,i-1,j);\\n            mat_dekh(g,i,j-1);\\n            mat_dekh(g,i,j+1);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int ans = 0;\\n        for(int i = 0 ; i < grid.size() ;i++)\\n        {\\n            for(int j = 0 ; j < grid[i].size() ;j++)\\n            {\\n                if(!vis[i][j] and grid[i][j]==\\'1\\')\\n                {\\n                    mat_dekh(grid,i,j);\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "augustlakia",
                        "content": "Can anyone suggest a good solution in Java that uses queue?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "urminhirpara",
                        "content": "class Solution {\\npublic:\\n    void dfs(vector<vector<char>>& grid, int i, int j, int r, int c){\\n        if(grid[i][j] == \\'1\\'){\\n            grid[i][j] = \\'0\\';\\n            if(i>0) dfs(grid, i-1, j, r, c);\\n            if(j>0) dfs(grid, i, j-1, r, c);\\n            if(i<r-1) dfs(grid, i+1, j, r, c);\\n            if(i<c-1) dfs(grid, i, j+1, r, c);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int r = grid.size(), c = grid[0].size(), ans = 0;\\n        for(int i = 0; i < r; ++i){\\n            for(int j = 0; j < c; ++j){\\n                if(grid[i][j] == \\'1\\'){\\n                    ans++;\\n                    dfs(grid, i, j, r, c);\\n                }\\n            }\\n        }return ans;\\n        \\n    }\\n}\\ncan any one tell me what is problem in code??"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "WHY ???\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x608000000020 overflowed to 0x608000000008 (stl_vector.h)\\n\\n\\nclass Solution {\\n     void check(vector<vector<char>>&grid,int i,int j)\\n    {\\n        if(grid[i][j]!=\\'1\\'|| i<0 || i>=grid.size() || j<0 || j>=grid[0].size())\\n        return;\\n        // if(grid[i][j]==\\'1\\')\\n        grid[i][j]=\\'2\\';\\n        //vertical downward\\n check(grid,i+1,j);\\n            //right\\n            check(grid,i,j+1);\\n        //upward\\n      check(grid,i-1,j);\\n        \\n        //left\\n        check(grid,i,j-1);\\n\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int island=0;\\n        if(grid.size()==0)\\n        return 0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==\\'1\\')\\n                {\\n                    island++;\\n                 check(grid,i,j);\\n                }\\n            }\\n        }\\n        return island;\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "Pradip_Kathiriya",
                        "content": "class Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        ## Recursive approach\\n        row, col = len(grid), len(grid[0])\\n        visited = set()\\n        result = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \"1\" and (i,j) not in visited:\\n                    result += 1\\n                    self.dfs(i, j, row, col, visited, grid)\\n\\n        return result\\n\\n    \\n    def dfs(self, i, j, row, col, visited, grid):\\n        if i not in range(row) or j not in range(col) or (i,j) in visited or grid[i][j] == \"0\":\\n            return \\n\\n        visited.add((i,j))\\n\\n        self.dfs(i+1, j, row, col, visited, grid)\\n        self.dfs(i-1, j, row, col, visited, grid)\\n        self.dfs(i, j+1, row, col, visited, grid)\\n        self.dfs(i, j-1, row, col, visited, grid)\\n\\n        return \\n\\n    ## Iterative approach\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n\\n\\n        \\n        queue = []\\n        row, col = len(grid), len(grid[0])\\n        visited = set()\\n        result = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \"1\" and (i,j) not in visited:\\n                    result += 1\\n                    queue.append((i,j))\\n                    visited.add((i,j))\\n                    while queue:\\n                        (a,b) = queue.pop()  # currently it is DFS, if you change it to the queue.pop(0) it become BFS\\n                        if a - 1 >= 0 and grid[a-1][b] == \"1\" and (a-1,b) not in visited:\\n                            visited.add((a-1,b))\\n                            queue.append((a-1,b))\\n\\n                        if a + 1 < row and grid[a+1][b] == \"1\" and (a+1,b) not in visited:\\n                            visited.add((a+1,b))\\n                            queue.append((a+1,b))\\n\\n                        if b - 1 >= 0 and grid[a][b-1] == \"1\" and (a, b-1) not in visited:\\n                            visited.add((a,b-1))\\n                            queue.append((a,b-1))\\n\\n                        if b + 1 < col and grid[a][b+1] == \"1\" and (a, b+1) not in visited:\\n                            visited.add((a,b+1))\\n                            queue.append((a,b+1))\\n\\n        return result\\n\\n\\n\\n\\n    \\n"
                    }
                ]
            },
            {
                "id": 1750138,
                "content": [
                    {
                        "username": "anishd3139",
                        "content": "Anyone getting TLE on test case 47/49? Do not know where to optimize to make the code work."
                    },
                    {
                        "username": "dompolochak",
                        "content": "When solving in c++ DO NOT use pair = {x,y} syntax you will get a heap overload error the only change i made to my solution was using pair = make_pair(x,y) and it worked fine. I wasted so much time analysing my solution when it was just leetcode being dumb"
                    },
                    {
                        "username": "pt33",
                        "content": "Please help me debug my code:Im getting output as 4 instead of 1 in first test case.I have used bfs approach \\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int x,int y){\\n        first=x;\\n        second=y;\\n    }\\n}\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n    int m=grid.length;\\n    int n=grid[0].length;\\n    int visited[][]=new int[m][n];\\n    int cnt=0;\\n     for(int i=0;i<m;i++){\\n         for(int j=0;j<n;j++){\\n             if(grid[i][j]==\\'1\\' && visited[i][j]==0){\\n                 \\n                 bfs(grid,visited,i,j);\\n                 cnt++;\\n             }\\n         }\\n     }\\n     return cnt;\\n    }\\n    public void bfs(char grid[][],int[][] visited,int srow,int scol)\\n{ int m=grid.length;\\nint n=grid[0].length;\\n    Queue<Pair> q=new LinkedList<Pair>();\\n                 visited[srow][scol]=1;\\n                \\n                 q.add(new Pair(srow,scol));\\n                 while(!q.isEmpty()){\\n                     int r=q.peek().first;\\n                     int c=q.peek().second;\\n                     q.remove();\\n                     int fr[]={-1,0,1,0};\\n                     int fc[]={0,1,0,-1};\\n                     for(int i=0;i<4;i++){\\n                             r=r+fr[i];\\n                             c=c+fc[i];\\n                             \\n                             if(r>=0 && r<m && c >=0 && c<n && visited[r][c]==0 && grid[r][c]==\\'1\\'){\\n                              q.add(new Pair(r,c));\\n                              visited[r][c]=1;\\n                              \\n                             }\\n\\n                         }\\n                     }\\n\\n                 }\\n             \\n         \\n     \\n    \\n}\\n"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone please let me know where am i going wrong in this code..\\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int x,int y){\\n        first=x;\\n        second=y;\\n    }\\n}\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n    int m=grid.length;\\n    int n=grid[0].length;\\n    int visited[][]=new int[m][n];\\n    int cnt=0;\\n     for(int i=0;i<m;i++){\\n         for(int j=0;j<n;j++){\\n             if(grid[i][j]==\\'1\\' && visited[i][j]==0){\\n                 \\n                 bfs(grid,visited,i,j);\\n                 cnt++;\\n             }\\n         }\\n     }\\n     return cnt;\\n    }\\n    public void bfs(char grid[][],int[][] visited,int srow,int scol)\\n{ int m=grid.length;\\nint n=grid[0].length;\\n    Queue<Pair> q=new LinkedList<Pair>();\\n                 visited[srow][scol]=1;\\n                \\n                 q.add(new Pair(srow,scol));\\n                 while(!q.isEmpty()){\\n                     int r=q.peek().first;\\n                     int c=q.peek().second;\\n                     q.remove();\\n                     int fr[]={-1,0,1,0};\\n                     int fc[]={0,1,0,-1};\\n                     for(int i=0;i<4;i++){\\n                             r=r+fr[i];\\n                             c=c+fc[i];\\n                             \\n                             if(r>=0 && r<m && c >=0 && c<n && visited[r][c]==0 && grid[r][c]==\\'1\\'){\\n                              q.add(new Pair(r,c));\\n                              visited[r][c]=1;\\n                              \\n                             }\\n\\n                         }\\n                     }\\n\\n                 }\\n             \\n         \\n     \\n    \\n}"
                    },
                    {
                        "username": "Rajkotiya_Harit",
                        "content": "Can anybody explain time-complexity of my code , I am really confused !\\nclass Solution {\\npublic:\\n    bool vis[300][300];\\n    void mat_dekh(vector<vector<char>>& g , int i , int j)\\n    {\\n        if(i >= 0 and j >= 0 and i < g.size() and  j < g[i].size() and !vis[i][j] and g[i][j]==\\'1\\' )\\n        {\\n            vis[i][j] = true;\\n            mat_dekh(g,i+1,j);\\n            mat_dekh(g,i-1,j);\\n            mat_dekh(g,i,j-1);\\n            mat_dekh(g,i,j+1);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int ans = 0;\\n        for(int i = 0 ; i < grid.size() ;i++)\\n        {\\n            for(int j = 0 ; j < grid[i].size() ;j++)\\n            {\\n                if(!vis[i][j] and grid[i][j]==\\'1\\')\\n                {\\n                    mat_dekh(grid,i,j);\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "augustlakia",
                        "content": "Can anyone suggest a good solution in Java that uses queue?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "urminhirpara",
                        "content": "class Solution {\\npublic:\\n    void dfs(vector<vector<char>>& grid, int i, int j, int r, int c){\\n        if(grid[i][j] == \\'1\\'){\\n            grid[i][j] = \\'0\\';\\n            if(i>0) dfs(grid, i-1, j, r, c);\\n            if(j>0) dfs(grid, i, j-1, r, c);\\n            if(i<r-1) dfs(grid, i+1, j, r, c);\\n            if(i<c-1) dfs(grid, i, j+1, r, c);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int r = grid.size(), c = grid[0].size(), ans = 0;\\n        for(int i = 0; i < r; ++i){\\n            for(int j = 0; j < c; ++j){\\n                if(grid[i][j] == \\'1\\'){\\n                    ans++;\\n                    dfs(grid, i, j, r, c);\\n                }\\n            }\\n        }return ans;\\n        \\n    }\\n}\\ncan any one tell me what is problem in code??"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "WHY ???\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x608000000020 overflowed to 0x608000000008 (stl_vector.h)\\n\\n\\nclass Solution {\\n     void check(vector<vector<char>>&grid,int i,int j)\\n    {\\n        if(grid[i][j]!=\\'1\\'|| i<0 || i>=grid.size() || j<0 || j>=grid[0].size())\\n        return;\\n        // if(grid[i][j]==\\'1\\')\\n        grid[i][j]=\\'2\\';\\n        //vertical downward\\n check(grid,i+1,j);\\n            //right\\n            check(grid,i,j+1);\\n        //upward\\n      check(grid,i-1,j);\\n        \\n        //left\\n        check(grid,i,j-1);\\n\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int island=0;\\n        if(grid.size()==0)\\n        return 0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==\\'1\\')\\n                {\\n                    island++;\\n                 check(grid,i,j);\\n                }\\n            }\\n        }\\n        return island;\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "Pradip_Kathiriya",
                        "content": "class Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        ## Recursive approach\\n        row, col = len(grid), len(grid[0])\\n        visited = set()\\n        result = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \"1\" and (i,j) not in visited:\\n                    result += 1\\n                    self.dfs(i, j, row, col, visited, grid)\\n\\n        return result\\n\\n    \\n    def dfs(self, i, j, row, col, visited, grid):\\n        if i not in range(row) or j not in range(col) or (i,j) in visited or grid[i][j] == \"0\":\\n            return \\n\\n        visited.add((i,j))\\n\\n        self.dfs(i+1, j, row, col, visited, grid)\\n        self.dfs(i-1, j, row, col, visited, grid)\\n        self.dfs(i, j+1, row, col, visited, grid)\\n        self.dfs(i, j-1, row, col, visited, grid)\\n\\n        return \\n\\n    ## Iterative approach\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n\\n\\n        \\n        queue = []\\n        row, col = len(grid), len(grid[0])\\n        visited = set()\\n        result = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \"1\" and (i,j) not in visited:\\n                    result += 1\\n                    queue.append((i,j))\\n                    visited.add((i,j))\\n                    while queue:\\n                        (a,b) = queue.pop()  # currently it is DFS, if you change it to the queue.pop(0) it become BFS\\n                        if a - 1 >= 0 and grid[a-1][b] == \"1\" and (a-1,b) not in visited:\\n                            visited.add((a-1,b))\\n                            queue.append((a-1,b))\\n\\n                        if a + 1 < row and grid[a+1][b] == \"1\" and (a+1,b) not in visited:\\n                            visited.add((a+1,b))\\n                            queue.append((a+1,b))\\n\\n                        if b - 1 >= 0 and grid[a][b-1] == \"1\" and (a, b-1) not in visited:\\n                            visited.add((a,b-1))\\n                            queue.append((a,b-1))\\n\\n                        if b + 1 < col and grid[a][b+1] == \"1\" and (a, b+1) not in visited:\\n                            visited.add((a,b+1))\\n                            queue.append((a,b+1))\\n\\n        return result\\n\\n\\n\\n\\n    \\n"
                    }
                ]
            },
            {
                "id": 1743345,
                "content": [
                    {
                        "username": "anishd3139",
                        "content": "Anyone getting TLE on test case 47/49? Do not know where to optimize to make the code work."
                    },
                    {
                        "username": "dompolochak",
                        "content": "When solving in c++ DO NOT use pair = {x,y} syntax you will get a heap overload error the only change i made to my solution was using pair = make_pair(x,y) and it worked fine. I wasted so much time analysing my solution when it was just leetcode being dumb"
                    },
                    {
                        "username": "pt33",
                        "content": "Please help me debug my code:Im getting output as 4 instead of 1 in first test case.I have used bfs approach \\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int x,int y){\\n        first=x;\\n        second=y;\\n    }\\n}\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n    int m=grid.length;\\n    int n=grid[0].length;\\n    int visited[][]=new int[m][n];\\n    int cnt=0;\\n     for(int i=0;i<m;i++){\\n         for(int j=0;j<n;j++){\\n             if(grid[i][j]==\\'1\\' && visited[i][j]==0){\\n                 \\n                 bfs(grid,visited,i,j);\\n                 cnt++;\\n             }\\n         }\\n     }\\n     return cnt;\\n    }\\n    public void bfs(char grid[][],int[][] visited,int srow,int scol)\\n{ int m=grid.length;\\nint n=grid[0].length;\\n    Queue<Pair> q=new LinkedList<Pair>();\\n                 visited[srow][scol]=1;\\n                \\n                 q.add(new Pair(srow,scol));\\n                 while(!q.isEmpty()){\\n                     int r=q.peek().first;\\n                     int c=q.peek().second;\\n                     q.remove();\\n                     int fr[]={-1,0,1,0};\\n                     int fc[]={0,1,0,-1};\\n                     for(int i=0;i<4;i++){\\n                             r=r+fr[i];\\n                             c=c+fc[i];\\n                             \\n                             if(r>=0 && r<m && c >=0 && c<n && visited[r][c]==0 && grid[r][c]==\\'1\\'){\\n                              q.add(new Pair(r,c));\\n                              visited[r][c]=1;\\n                              \\n                             }\\n\\n                         }\\n                     }\\n\\n                 }\\n             \\n         \\n     \\n    \\n}\\n"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone please let me know where am i going wrong in this code..\\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int x,int y){\\n        first=x;\\n        second=y;\\n    }\\n}\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n    int m=grid.length;\\n    int n=grid[0].length;\\n    int visited[][]=new int[m][n];\\n    int cnt=0;\\n     for(int i=0;i<m;i++){\\n         for(int j=0;j<n;j++){\\n             if(grid[i][j]==\\'1\\' && visited[i][j]==0){\\n                 \\n                 bfs(grid,visited,i,j);\\n                 cnt++;\\n             }\\n         }\\n     }\\n     return cnt;\\n    }\\n    public void bfs(char grid[][],int[][] visited,int srow,int scol)\\n{ int m=grid.length;\\nint n=grid[0].length;\\n    Queue<Pair> q=new LinkedList<Pair>();\\n                 visited[srow][scol]=1;\\n                \\n                 q.add(new Pair(srow,scol));\\n                 while(!q.isEmpty()){\\n                     int r=q.peek().first;\\n                     int c=q.peek().second;\\n                     q.remove();\\n                     int fr[]={-1,0,1,0};\\n                     int fc[]={0,1,0,-1};\\n                     for(int i=0;i<4;i++){\\n                             r=r+fr[i];\\n                             c=c+fc[i];\\n                             \\n                             if(r>=0 && r<m && c >=0 && c<n && visited[r][c]==0 && grid[r][c]==\\'1\\'){\\n                              q.add(new Pair(r,c));\\n                              visited[r][c]=1;\\n                              \\n                             }\\n\\n                         }\\n                     }\\n\\n                 }\\n             \\n         \\n     \\n    \\n}"
                    },
                    {
                        "username": "Rajkotiya_Harit",
                        "content": "Can anybody explain time-complexity of my code , I am really confused !\\nclass Solution {\\npublic:\\n    bool vis[300][300];\\n    void mat_dekh(vector<vector<char>>& g , int i , int j)\\n    {\\n        if(i >= 0 and j >= 0 and i < g.size() and  j < g[i].size() and !vis[i][j] and g[i][j]==\\'1\\' )\\n        {\\n            vis[i][j] = true;\\n            mat_dekh(g,i+1,j);\\n            mat_dekh(g,i-1,j);\\n            mat_dekh(g,i,j-1);\\n            mat_dekh(g,i,j+1);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int ans = 0;\\n        for(int i = 0 ; i < grid.size() ;i++)\\n        {\\n            for(int j = 0 ; j < grid[i].size() ;j++)\\n            {\\n                if(!vis[i][j] and grid[i][j]==\\'1\\')\\n                {\\n                    mat_dekh(grid,i,j);\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "augustlakia",
                        "content": "Can anyone suggest a good solution in Java that uses queue?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "urminhirpara",
                        "content": "class Solution {\\npublic:\\n    void dfs(vector<vector<char>>& grid, int i, int j, int r, int c){\\n        if(grid[i][j] == \\'1\\'){\\n            grid[i][j] = \\'0\\';\\n            if(i>0) dfs(grid, i-1, j, r, c);\\n            if(j>0) dfs(grid, i, j-1, r, c);\\n            if(i<r-1) dfs(grid, i+1, j, r, c);\\n            if(i<c-1) dfs(grid, i, j+1, r, c);\\n        }\\n    }\\n    int numIslands(vector<vector<char>>& grid) {\\n        int r = grid.size(), c = grid[0].size(), ans = 0;\\n        for(int i = 0; i < r; ++i){\\n            for(int j = 0; j < c; ++j){\\n                if(grid[i][j] == \\'1\\'){\\n                    ans++;\\n                    dfs(grid, i, j, r, c);\\n                }\\n            }\\n        }return ans;\\n        \\n    }\\n}\\ncan any one tell me what is problem in code??"
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "WHY ???\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x608000000020 overflowed to 0x608000000008 (stl_vector.h)\\n\\n\\nclass Solution {\\n     void check(vector<vector<char>>&grid,int i,int j)\\n    {\\n        if(grid[i][j]!=\\'1\\'|| i<0 || i>=grid.size() || j<0 || j>=grid[0].size())\\n        return;\\n        // if(grid[i][j]==\\'1\\')\\n        grid[i][j]=\\'2\\';\\n        //vertical downward\\n check(grid,i+1,j);\\n            //right\\n            check(grid,i,j+1);\\n        //upward\\n      check(grid,i-1,j);\\n        \\n        //left\\n        check(grid,i,j-1);\\n\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int island=0;\\n        if(grid.size()==0)\\n        return 0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==\\'1\\')\\n                {\\n                    island++;\\n                 check(grid,i,j);\\n                }\\n            }\\n        }\\n        return island;\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "Pradip_Kathiriya",
                        "content": "class Solution(object):\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        ## Recursive approach\\n        row, col = len(grid), len(grid[0])\\n        visited = set()\\n        result = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \"1\" and (i,j) not in visited:\\n                    result += 1\\n                    self.dfs(i, j, row, col, visited, grid)\\n\\n        return result\\n\\n    \\n    def dfs(self, i, j, row, col, visited, grid):\\n        if i not in range(row) or j not in range(col) or (i,j) in visited or grid[i][j] == \"0\":\\n            return \\n\\n        visited.add((i,j))\\n\\n        self.dfs(i+1, j, row, col, visited, grid)\\n        self.dfs(i-1, j, row, col, visited, grid)\\n        self.dfs(i, j+1, row, col, visited, grid)\\n        self.dfs(i, j-1, row, col, visited, grid)\\n\\n        return \\n\\n    ## Iterative approach\\n    def numIslands(self, grid):\\n        \"\"\"\\n        :type grid: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n\\n\\n        \\n        queue = []\\n        row, col = len(grid), len(grid[0])\\n        visited = set()\\n        result = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if grid[i][j] == \"1\" and (i,j) not in visited:\\n                    result += 1\\n                    queue.append((i,j))\\n                    visited.add((i,j))\\n                    while queue:\\n                        (a,b) = queue.pop()  # currently it is DFS, if you change it to the queue.pop(0) it become BFS\\n                        if a - 1 >= 0 and grid[a-1][b] == \"1\" and (a-1,b) not in visited:\\n                            visited.add((a-1,b))\\n                            queue.append((a-1,b))\\n\\n                        if a + 1 < row and grid[a+1][b] == \"1\" and (a+1,b) not in visited:\\n                            visited.add((a+1,b))\\n                            queue.append((a+1,b))\\n\\n                        if b - 1 >= 0 and grid[a][b-1] == \"1\" and (a, b-1) not in visited:\\n                            visited.add((a,b-1))\\n                            queue.append((a,b-1))\\n\\n                        if b + 1 < col and grid[a][b+1] == \"1\" and (a, b+1) not in visited:\\n                            visited.add((a,b+1))\\n                            queue.append((a,b+1))\\n\\n        return result\\n\\n\\n\\n\\n    \\n"
                    }
                ]
            },
            {
                "id": 1741500,
                "content": [
                    {
                        "username": "parasharsumedh5",
                        "content": "Hi, Can someone pls explain why this solutions times out for this test case: \\n\\n class Solution {\\n    \\n    private static final int[] d = {0,1,0,-1,0};\\n    \\n    public int numIslands(char[][] grid) {\\n        int island = 0;\\n        int m = grid.length;\\n        if(m == 0) return 0;\\n        int n = grid[0].length;\\n        \\n        Set<Integer> visitedSet = new HashSet<Integer>();\\n        Queue<int[]> queue = new LinkedList<>();\\n        \\n        for(int i=0; i< m;i++){\\n            for(int j=0; j<n ;j++){\\n                if(grid[i][j] == \\'1\\' && !visitedSet.contains(i*n+j)){\\n                    island++;\\n                    \\n                    queue.add(new int[]{i,j});\\n                    while(!queue.isEmpty()){\\n                        int[] pts = queue.poll();\\n                        visitedSet.add(pts[0] * n + pts[1]);\\n                        for(int k=0; k<4; k++){\\n                            int r = pts[0] + d[k];\\n                            int c = pts[1] + d[k+1];\\n                            \\n                            if(r>=0 && r<m && c>=0 && c<n){\\n                                if(grid[r][c] == \\'1\\' && !visitedSet.contains(r*n+c)){\\n                                    queue.add(new int[]{r,c});\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return island;\\n    }\\n}\\n\\n\\nTest Case : \\n[[\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"]]\\n"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`\\n\\nvoid dfs(int i,int j,vector<vector<char>>& grid,vector<vector<int>> &vis){\\n        vis[i][j]=1;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(i>=0 && i<n && j>=0 && j<m && grid[i][j]==\\'1\\' && !vis[i][j]){\\n          \\n            //vertically down\\n            dfs(i+1,j,grid,vis);\\n            //horizontally forward\\n            dfs(i,j+1,grid,vis);\\n            //vertically upward\\n            dfs(i-1,j,grid,vis);\\n            //horizontally backward\\n            dfs(i,j-1,grid,vis);\\n        }\\n    }\\n     \\n    // Function to find the number of islands.\\n    int numIslands(vector<vector<char>>& grid) {\\n        // Code here\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        //creating visited array\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        int island=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==\\'1\\' && !vis[i][j]){\\n                    island++;\\n                    dfs(i,j,grid,vis);\\n                }\\n            }\\n        }\\n        return island;\\n    }\\n\\n\\n\\ni am getting wrong answer for this,can anyone explain why"
                    },
                    {
                        "username": "gorman",
                        "content": "The C++ language system used here appears to have become borked in some way:  my algorithm coded in C++ fails with a \"Time Exceeded Limits\" yet the same exact algorithm coded in Java passes, surpassing 85% of submissions.  I didn\\'t make a silly C++ mistake; I\\'m highly experienced in both languages. "
                    },
                    {
                        "username": "averagebloke",
                        "content": "\"vertically\" is incorrect!\nThe 2nd input and output shows that:\nInput: grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\nOutput: 3\n\nCorrect description should be:\n\"Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally ~~or vertically~~. You may assume all four edges of the grid are all surrounded by water.\""
                    },
                    {
                        "username": "vlad_zotov",
                        "content": "With recursive DFS, what is memory complexity considering memory in call stack? Isn\\'t it O(n) for worst case if all cells are \"1\"? Or call stack is 4 (for each neighbour cell, therefor O(1). Seems like it\\'s O(n)..."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "I first attacked this with BFS - and that just turned into an ugly mess of spaghetti code. Realized that DFS  is much cleaner and easier to implement in this case. BFS has its uses, just not here. "
                    },
                    {
                        "username": "mehdiwadiwala1",
                        "content": "class Solution {\\n    public int numIslands(char[][] grid) {\\n        int count=0;\\n\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[i].length;j++){\\n                if(grid[i][j]==\\'1\\'){\\n                    count+=1;\\n                    callDFS(grid,i,j);\\n                }\\n            }\\n        }\\n        return count;   \\n    }\\n    public void  callDFS(char[][] grid, int i, int j){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[i].length || grid[i][j]==\\'0\\') {\\n            return;\\n        }\\n\\n        grid[i][j]=\\'0\\';\\n        callDFS(grid,i+1,j);\\n        callDFS(grid,i-1,j);\\n        callDFS(grid,i,j-1);\\n        callDFS(grid,i,j+1);\\n    }\\n}\\n\\nSolution code for java"
                    },
                    {
                        "username": "YEONG-CTRL",
                        "content": "I'm wondering  how char[][]grid can be changed in my code, same question applies to [flood fill](https://leetcode.com/problems/flood-fill/?envType=study-plan&id=level-1).\nIn my onpinion, \"grid\" is local variable in function numIslands, and \"grid\" passed to function dfs is another local variable of function \"dfs\". So, changing grid's value in dfs  like`  grid[i][j] = '0';` will not affect the \"grid\" in numIslands. But My code works despite of my concern. Can someone tell me why changing \"grid\" in another function \"dfs\" still works??  \n\n[Here's my code.\n](https://leetcode.com/problems/number-of-islands/submissions/854760166/\n)"
                    },
                    {
                        "username": "trashw1n",
                        "content": "this code is overcounting number of islands and i cant spot out the bug. please help me\\n\\n `\\nclass Solution {\\nprivate:\\n    void bfs(int row,int col,vector<vector<int>>& vis, vector<vector<char>> grid){\\n        int m = grid.size(), n = grid[0].size();\\n        vis[row][col] = 1;\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        vector<pair<int,int>> dirs = vector<pair<int,int>>{{0,-1},{-1,0},{1,0},{0,1}};\\n        while(q.size()){\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            for(auto dir : dirs){\\n                int nrow = r + dir.first;\\n                int ncol = r + dir.second;\\n                if(nrow>=0 && ncol>=0 && nrow<m && ncol<n && grid[nrow][ncol]==\\'1\\' && !vis[nrow][ncol]){\\n                    vis[nrow][ncol]=1;\\n                    q.push({nrow,ncol});\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int count = 0;\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        for(int row = 0;row<m;row++){\\n            for(int col = 0;col<n;col++){\\n                if(!vis[row][col] && grid[row][col]==\\'1\\'){\\n                    bfs(row,col,vis,grid);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "line 3"
                    },
                    {
                        "username": "black_11",
                        "content": "Compiler is giving me Time limit exceeded error at 47th test case.\\nHow should I optimise it ? Pls help!!\\n `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1728948,
                "content": [
                    {
                        "username": "parasharsumedh5",
                        "content": "Hi, Can someone pls explain why this solutions times out for this test case: \\n\\n class Solution {\\n    \\n    private static final int[] d = {0,1,0,-1,0};\\n    \\n    public int numIslands(char[][] grid) {\\n        int island = 0;\\n        int m = grid.length;\\n        if(m == 0) return 0;\\n        int n = grid[0].length;\\n        \\n        Set<Integer> visitedSet = new HashSet<Integer>();\\n        Queue<int[]> queue = new LinkedList<>();\\n        \\n        for(int i=0; i< m;i++){\\n            for(int j=0; j<n ;j++){\\n                if(grid[i][j] == \\'1\\' && !visitedSet.contains(i*n+j)){\\n                    island++;\\n                    \\n                    queue.add(new int[]{i,j});\\n                    while(!queue.isEmpty()){\\n                        int[] pts = queue.poll();\\n                        visitedSet.add(pts[0] * n + pts[1]);\\n                        for(int k=0; k<4; k++){\\n                            int r = pts[0] + d[k];\\n                            int c = pts[1] + d[k+1];\\n                            \\n                            if(r>=0 && r<m && c>=0 && c<n){\\n                                if(grid[r][c] == \\'1\\' && !visitedSet.contains(r*n+c)){\\n                                    queue.add(new int[]{r,c});\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return island;\\n    }\\n}\\n\\n\\nTest Case : \\n[[\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"]]\\n"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`\\n\\nvoid dfs(int i,int j,vector<vector<char>>& grid,vector<vector<int>> &vis){\\n        vis[i][j]=1;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(i>=0 && i<n && j>=0 && j<m && grid[i][j]==\\'1\\' && !vis[i][j]){\\n          \\n            //vertically down\\n            dfs(i+1,j,grid,vis);\\n            //horizontally forward\\n            dfs(i,j+1,grid,vis);\\n            //vertically upward\\n            dfs(i-1,j,grid,vis);\\n            //horizontally backward\\n            dfs(i,j-1,grid,vis);\\n        }\\n    }\\n     \\n    // Function to find the number of islands.\\n    int numIslands(vector<vector<char>>& grid) {\\n        // Code here\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        //creating visited array\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        int island=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==\\'1\\' && !vis[i][j]){\\n                    island++;\\n                    dfs(i,j,grid,vis);\\n                }\\n            }\\n        }\\n        return island;\\n    }\\n\\n\\n\\ni am getting wrong answer for this,can anyone explain why"
                    },
                    {
                        "username": "gorman",
                        "content": "The C++ language system used here appears to have become borked in some way:  my algorithm coded in C++ fails with a \"Time Exceeded Limits\" yet the same exact algorithm coded in Java passes, surpassing 85% of submissions.  I didn\\'t make a silly C++ mistake; I\\'m highly experienced in both languages. "
                    },
                    {
                        "username": "averagebloke",
                        "content": "\"vertically\" is incorrect!\nThe 2nd input and output shows that:\nInput: grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\nOutput: 3\n\nCorrect description should be:\n\"Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally ~~or vertically~~. You may assume all four edges of the grid are all surrounded by water.\""
                    },
                    {
                        "username": "vlad_zotov",
                        "content": "With recursive DFS, what is memory complexity considering memory in call stack? Isn\\'t it O(n) for worst case if all cells are \"1\"? Or call stack is 4 (for each neighbour cell, therefor O(1). Seems like it\\'s O(n)..."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "I first attacked this with BFS - and that just turned into an ugly mess of spaghetti code. Realized that DFS  is much cleaner and easier to implement in this case. BFS has its uses, just not here. "
                    },
                    {
                        "username": "mehdiwadiwala1",
                        "content": "class Solution {\\n    public int numIslands(char[][] grid) {\\n        int count=0;\\n\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[i].length;j++){\\n                if(grid[i][j]==\\'1\\'){\\n                    count+=1;\\n                    callDFS(grid,i,j);\\n                }\\n            }\\n        }\\n        return count;   \\n    }\\n    public void  callDFS(char[][] grid, int i, int j){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[i].length || grid[i][j]==\\'0\\') {\\n            return;\\n        }\\n\\n        grid[i][j]=\\'0\\';\\n        callDFS(grid,i+1,j);\\n        callDFS(grid,i-1,j);\\n        callDFS(grid,i,j-1);\\n        callDFS(grid,i,j+1);\\n    }\\n}\\n\\nSolution code for java"
                    },
                    {
                        "username": "YEONG-CTRL",
                        "content": "I'm wondering  how char[][]grid can be changed in my code, same question applies to [flood fill](https://leetcode.com/problems/flood-fill/?envType=study-plan&id=level-1).\nIn my onpinion, \"grid\" is local variable in function numIslands, and \"grid\" passed to function dfs is another local variable of function \"dfs\". So, changing grid's value in dfs  like`  grid[i][j] = '0';` will not affect the \"grid\" in numIslands. But My code works despite of my concern. Can someone tell me why changing \"grid\" in another function \"dfs\" still works??  \n\n[Here's my code.\n](https://leetcode.com/problems/number-of-islands/submissions/854760166/\n)"
                    },
                    {
                        "username": "trashw1n",
                        "content": "this code is overcounting number of islands and i cant spot out the bug. please help me\\n\\n `\\nclass Solution {\\nprivate:\\n    void bfs(int row,int col,vector<vector<int>>& vis, vector<vector<char>> grid){\\n        int m = grid.size(), n = grid[0].size();\\n        vis[row][col] = 1;\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        vector<pair<int,int>> dirs = vector<pair<int,int>>{{0,-1},{-1,0},{1,0},{0,1}};\\n        while(q.size()){\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            for(auto dir : dirs){\\n                int nrow = r + dir.first;\\n                int ncol = r + dir.second;\\n                if(nrow>=0 && ncol>=0 && nrow<m && ncol<n && grid[nrow][ncol]==\\'1\\' && !vis[nrow][ncol]){\\n                    vis[nrow][ncol]=1;\\n                    q.push({nrow,ncol});\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int count = 0;\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        for(int row = 0;row<m;row++){\\n            for(int col = 0;col<n;col++){\\n                if(!vis[row][col] && grid[row][col]==\\'1\\'){\\n                    bfs(row,col,vis,grid);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "line 3"
                    },
                    {
                        "username": "black_11",
                        "content": "Compiler is giving me Time limit exceeded error at 47th test case.\\nHow should I optimise it ? Pls help!!\\n `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1716990,
                "content": [
                    {
                        "username": "parasharsumedh5",
                        "content": "Hi, Can someone pls explain why this solutions times out for this test case: \\n\\n class Solution {\\n    \\n    private static final int[] d = {0,1,0,-1,0};\\n    \\n    public int numIslands(char[][] grid) {\\n        int island = 0;\\n        int m = grid.length;\\n        if(m == 0) return 0;\\n        int n = grid[0].length;\\n        \\n        Set<Integer> visitedSet = new HashSet<Integer>();\\n        Queue<int[]> queue = new LinkedList<>();\\n        \\n        for(int i=0; i< m;i++){\\n            for(int j=0; j<n ;j++){\\n                if(grid[i][j] == \\'1\\' && !visitedSet.contains(i*n+j)){\\n                    island++;\\n                    \\n                    queue.add(new int[]{i,j});\\n                    while(!queue.isEmpty()){\\n                        int[] pts = queue.poll();\\n                        visitedSet.add(pts[0] * n + pts[1]);\\n                        for(int k=0; k<4; k++){\\n                            int r = pts[0] + d[k];\\n                            int c = pts[1] + d[k+1];\\n                            \\n                            if(r>=0 && r<m && c>=0 && c<n){\\n                                if(grid[r][c] == \\'1\\' && !visitedSet.contains(r*n+c)){\\n                                    queue.add(new int[]{r,c});\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return island;\\n    }\\n}\\n\\n\\nTest Case : \\n[[\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"]]\\n"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`\\n\\nvoid dfs(int i,int j,vector<vector<char>>& grid,vector<vector<int>> &vis){\\n        vis[i][j]=1;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(i>=0 && i<n && j>=0 && j<m && grid[i][j]==\\'1\\' && !vis[i][j]){\\n          \\n            //vertically down\\n            dfs(i+1,j,grid,vis);\\n            //horizontally forward\\n            dfs(i,j+1,grid,vis);\\n            //vertically upward\\n            dfs(i-1,j,grid,vis);\\n            //horizontally backward\\n            dfs(i,j-1,grid,vis);\\n        }\\n    }\\n     \\n    // Function to find the number of islands.\\n    int numIslands(vector<vector<char>>& grid) {\\n        // Code here\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        //creating visited array\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        int island=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==\\'1\\' && !vis[i][j]){\\n                    island++;\\n                    dfs(i,j,grid,vis);\\n                }\\n            }\\n        }\\n        return island;\\n    }\\n\\n\\n\\ni am getting wrong answer for this,can anyone explain why"
                    },
                    {
                        "username": "gorman",
                        "content": "The C++ language system used here appears to have become borked in some way:  my algorithm coded in C++ fails with a \"Time Exceeded Limits\" yet the same exact algorithm coded in Java passes, surpassing 85% of submissions.  I didn\\'t make a silly C++ mistake; I\\'m highly experienced in both languages. "
                    },
                    {
                        "username": "averagebloke",
                        "content": "\"vertically\" is incorrect!\nThe 2nd input and output shows that:\nInput: grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\nOutput: 3\n\nCorrect description should be:\n\"Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally ~~or vertically~~. You may assume all four edges of the grid are all surrounded by water.\""
                    },
                    {
                        "username": "vlad_zotov",
                        "content": "With recursive DFS, what is memory complexity considering memory in call stack? Isn\\'t it O(n) for worst case if all cells are \"1\"? Or call stack is 4 (for each neighbour cell, therefor O(1). Seems like it\\'s O(n)..."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "I first attacked this with BFS - and that just turned into an ugly mess of spaghetti code. Realized that DFS  is much cleaner and easier to implement in this case. BFS has its uses, just not here. "
                    },
                    {
                        "username": "mehdiwadiwala1",
                        "content": "class Solution {\\n    public int numIslands(char[][] grid) {\\n        int count=0;\\n\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[i].length;j++){\\n                if(grid[i][j]==\\'1\\'){\\n                    count+=1;\\n                    callDFS(grid,i,j);\\n                }\\n            }\\n        }\\n        return count;   \\n    }\\n    public void  callDFS(char[][] grid, int i, int j){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[i].length || grid[i][j]==\\'0\\') {\\n            return;\\n        }\\n\\n        grid[i][j]=\\'0\\';\\n        callDFS(grid,i+1,j);\\n        callDFS(grid,i-1,j);\\n        callDFS(grid,i,j-1);\\n        callDFS(grid,i,j+1);\\n    }\\n}\\n\\nSolution code for java"
                    },
                    {
                        "username": "YEONG-CTRL",
                        "content": "I'm wondering  how char[][]grid can be changed in my code, same question applies to [flood fill](https://leetcode.com/problems/flood-fill/?envType=study-plan&id=level-1).\nIn my onpinion, \"grid\" is local variable in function numIslands, and \"grid\" passed to function dfs is another local variable of function \"dfs\". So, changing grid's value in dfs  like`  grid[i][j] = '0';` will not affect the \"grid\" in numIslands. But My code works despite of my concern. Can someone tell me why changing \"grid\" in another function \"dfs\" still works??  \n\n[Here's my code.\n](https://leetcode.com/problems/number-of-islands/submissions/854760166/\n)"
                    },
                    {
                        "username": "trashw1n",
                        "content": "this code is overcounting number of islands and i cant spot out the bug. please help me\\n\\n `\\nclass Solution {\\nprivate:\\n    void bfs(int row,int col,vector<vector<int>>& vis, vector<vector<char>> grid){\\n        int m = grid.size(), n = grid[0].size();\\n        vis[row][col] = 1;\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        vector<pair<int,int>> dirs = vector<pair<int,int>>{{0,-1},{-1,0},{1,0},{0,1}};\\n        while(q.size()){\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            for(auto dir : dirs){\\n                int nrow = r + dir.first;\\n                int ncol = r + dir.second;\\n                if(nrow>=0 && ncol>=0 && nrow<m && ncol<n && grid[nrow][ncol]==\\'1\\' && !vis[nrow][ncol]){\\n                    vis[nrow][ncol]=1;\\n                    q.push({nrow,ncol});\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int count = 0;\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        for(int row = 0;row<m;row++){\\n            for(int col = 0;col<n;col++){\\n                if(!vis[row][col] && grid[row][col]==\\'1\\'){\\n                    bfs(row,col,vis,grid);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "line 3"
                    },
                    {
                        "username": "black_11",
                        "content": "Compiler is giving me Time limit exceeded error at 47th test case.\\nHow should I optimise it ? Pls help!!\\n `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1713624,
                "content": [
                    {
                        "username": "parasharsumedh5",
                        "content": "Hi, Can someone pls explain why this solutions times out for this test case: \\n\\n class Solution {\\n    \\n    private static final int[] d = {0,1,0,-1,0};\\n    \\n    public int numIslands(char[][] grid) {\\n        int island = 0;\\n        int m = grid.length;\\n        if(m == 0) return 0;\\n        int n = grid[0].length;\\n        \\n        Set<Integer> visitedSet = new HashSet<Integer>();\\n        Queue<int[]> queue = new LinkedList<>();\\n        \\n        for(int i=0; i< m;i++){\\n            for(int j=0; j<n ;j++){\\n                if(grid[i][j] == \\'1\\' && !visitedSet.contains(i*n+j)){\\n                    island++;\\n                    \\n                    queue.add(new int[]{i,j});\\n                    while(!queue.isEmpty()){\\n                        int[] pts = queue.poll();\\n                        visitedSet.add(pts[0] * n + pts[1]);\\n                        for(int k=0; k<4; k++){\\n                            int r = pts[0] + d[k];\\n                            int c = pts[1] + d[k+1];\\n                            \\n                            if(r>=0 && r<m && c>=0 && c<n){\\n                                if(grid[r][c] == \\'1\\' && !visitedSet.contains(r*n+c)){\\n                                    queue.add(new int[]{r,c});\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return island;\\n    }\\n}\\n\\n\\nTest Case : \\n[[\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"]]\\n"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`\\n\\nvoid dfs(int i,int j,vector<vector<char>>& grid,vector<vector<int>> &vis){\\n        vis[i][j]=1;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(i>=0 && i<n && j>=0 && j<m && grid[i][j]==\\'1\\' && !vis[i][j]){\\n          \\n            //vertically down\\n            dfs(i+1,j,grid,vis);\\n            //horizontally forward\\n            dfs(i,j+1,grid,vis);\\n            //vertically upward\\n            dfs(i-1,j,grid,vis);\\n            //horizontally backward\\n            dfs(i,j-1,grid,vis);\\n        }\\n    }\\n     \\n    // Function to find the number of islands.\\n    int numIslands(vector<vector<char>>& grid) {\\n        // Code here\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        //creating visited array\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        int island=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==\\'1\\' && !vis[i][j]){\\n                    island++;\\n                    dfs(i,j,grid,vis);\\n                }\\n            }\\n        }\\n        return island;\\n    }\\n\\n\\n\\ni am getting wrong answer for this,can anyone explain why"
                    },
                    {
                        "username": "gorman",
                        "content": "The C++ language system used here appears to have become borked in some way:  my algorithm coded in C++ fails with a \"Time Exceeded Limits\" yet the same exact algorithm coded in Java passes, surpassing 85% of submissions.  I didn\\'t make a silly C++ mistake; I\\'m highly experienced in both languages. "
                    },
                    {
                        "username": "averagebloke",
                        "content": "\"vertically\" is incorrect!\nThe 2nd input and output shows that:\nInput: grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\nOutput: 3\n\nCorrect description should be:\n\"Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally ~~or vertically~~. You may assume all four edges of the grid are all surrounded by water.\""
                    },
                    {
                        "username": "vlad_zotov",
                        "content": "With recursive DFS, what is memory complexity considering memory in call stack? Isn\\'t it O(n) for worst case if all cells are \"1\"? Or call stack is 4 (for each neighbour cell, therefor O(1). Seems like it\\'s O(n)..."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "I first attacked this with BFS - and that just turned into an ugly mess of spaghetti code. Realized that DFS  is much cleaner and easier to implement in this case. BFS has its uses, just not here. "
                    },
                    {
                        "username": "mehdiwadiwala1",
                        "content": "class Solution {\\n    public int numIslands(char[][] grid) {\\n        int count=0;\\n\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[i].length;j++){\\n                if(grid[i][j]==\\'1\\'){\\n                    count+=1;\\n                    callDFS(grid,i,j);\\n                }\\n            }\\n        }\\n        return count;   \\n    }\\n    public void  callDFS(char[][] grid, int i, int j){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[i].length || grid[i][j]==\\'0\\') {\\n            return;\\n        }\\n\\n        grid[i][j]=\\'0\\';\\n        callDFS(grid,i+1,j);\\n        callDFS(grid,i-1,j);\\n        callDFS(grid,i,j-1);\\n        callDFS(grid,i,j+1);\\n    }\\n}\\n\\nSolution code for java"
                    },
                    {
                        "username": "YEONG-CTRL",
                        "content": "I'm wondering  how char[][]grid can be changed in my code, same question applies to [flood fill](https://leetcode.com/problems/flood-fill/?envType=study-plan&id=level-1).\nIn my onpinion, \"grid\" is local variable in function numIslands, and \"grid\" passed to function dfs is another local variable of function \"dfs\". So, changing grid's value in dfs  like`  grid[i][j] = '0';` will not affect the \"grid\" in numIslands. But My code works despite of my concern. Can someone tell me why changing \"grid\" in another function \"dfs\" still works??  \n\n[Here's my code.\n](https://leetcode.com/problems/number-of-islands/submissions/854760166/\n)"
                    },
                    {
                        "username": "trashw1n",
                        "content": "this code is overcounting number of islands and i cant spot out the bug. please help me\\n\\n `\\nclass Solution {\\nprivate:\\n    void bfs(int row,int col,vector<vector<int>>& vis, vector<vector<char>> grid){\\n        int m = grid.size(), n = grid[0].size();\\n        vis[row][col] = 1;\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        vector<pair<int,int>> dirs = vector<pair<int,int>>{{0,-1},{-1,0},{1,0},{0,1}};\\n        while(q.size()){\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            for(auto dir : dirs){\\n                int nrow = r + dir.first;\\n                int ncol = r + dir.second;\\n                if(nrow>=0 && ncol>=0 && nrow<m && ncol<n && grid[nrow][ncol]==\\'1\\' && !vis[nrow][ncol]){\\n                    vis[nrow][ncol]=1;\\n                    q.push({nrow,ncol});\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int count = 0;\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        for(int row = 0;row<m;row++){\\n            for(int col = 0;col<n;col++){\\n                if(!vis[row][col] && grid[row][col]==\\'1\\'){\\n                    bfs(row,col,vis,grid);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "line 3"
                    },
                    {
                        "username": "black_11",
                        "content": "Compiler is giving me Time limit exceeded error at 47th test case.\\nHow should I optimise it ? Pls help!!\\n `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1711134,
                "content": [
                    {
                        "username": "parasharsumedh5",
                        "content": "Hi, Can someone pls explain why this solutions times out for this test case: \\n\\n class Solution {\\n    \\n    private static final int[] d = {0,1,0,-1,0};\\n    \\n    public int numIslands(char[][] grid) {\\n        int island = 0;\\n        int m = grid.length;\\n        if(m == 0) return 0;\\n        int n = grid[0].length;\\n        \\n        Set<Integer> visitedSet = new HashSet<Integer>();\\n        Queue<int[]> queue = new LinkedList<>();\\n        \\n        for(int i=0; i< m;i++){\\n            for(int j=0; j<n ;j++){\\n                if(grid[i][j] == \\'1\\' && !visitedSet.contains(i*n+j)){\\n                    island++;\\n                    \\n                    queue.add(new int[]{i,j});\\n                    while(!queue.isEmpty()){\\n                        int[] pts = queue.poll();\\n                        visitedSet.add(pts[0] * n + pts[1]);\\n                        for(int k=0; k<4; k++){\\n                            int r = pts[0] + d[k];\\n                            int c = pts[1] + d[k+1];\\n                            \\n                            if(r>=0 && r<m && c>=0 && c<n){\\n                                if(grid[r][c] == \\'1\\' && !visitedSet.contains(r*n+c)){\\n                                    queue.add(new int[]{r,c});\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return island;\\n    }\\n}\\n\\n\\nTest Case : \\n[[\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"]]\\n"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`\\n\\nvoid dfs(int i,int j,vector<vector<char>>& grid,vector<vector<int>> &vis){\\n        vis[i][j]=1;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(i>=0 && i<n && j>=0 && j<m && grid[i][j]==\\'1\\' && !vis[i][j]){\\n          \\n            //vertically down\\n            dfs(i+1,j,grid,vis);\\n            //horizontally forward\\n            dfs(i,j+1,grid,vis);\\n            //vertically upward\\n            dfs(i-1,j,grid,vis);\\n            //horizontally backward\\n            dfs(i,j-1,grid,vis);\\n        }\\n    }\\n     \\n    // Function to find the number of islands.\\n    int numIslands(vector<vector<char>>& grid) {\\n        // Code here\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        //creating visited array\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        int island=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==\\'1\\' && !vis[i][j]){\\n                    island++;\\n                    dfs(i,j,grid,vis);\\n                }\\n            }\\n        }\\n        return island;\\n    }\\n\\n\\n\\ni am getting wrong answer for this,can anyone explain why"
                    },
                    {
                        "username": "gorman",
                        "content": "The C++ language system used here appears to have become borked in some way:  my algorithm coded in C++ fails with a \"Time Exceeded Limits\" yet the same exact algorithm coded in Java passes, surpassing 85% of submissions.  I didn\\'t make a silly C++ mistake; I\\'m highly experienced in both languages. "
                    },
                    {
                        "username": "averagebloke",
                        "content": "\"vertically\" is incorrect!\nThe 2nd input and output shows that:\nInput: grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\nOutput: 3\n\nCorrect description should be:\n\"Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally ~~or vertically~~. You may assume all four edges of the grid are all surrounded by water.\""
                    },
                    {
                        "username": "vlad_zotov",
                        "content": "With recursive DFS, what is memory complexity considering memory in call stack? Isn\\'t it O(n) for worst case if all cells are \"1\"? Or call stack is 4 (for each neighbour cell, therefor O(1). Seems like it\\'s O(n)..."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "I first attacked this with BFS - and that just turned into an ugly mess of spaghetti code. Realized that DFS  is much cleaner and easier to implement in this case. BFS has its uses, just not here. "
                    },
                    {
                        "username": "mehdiwadiwala1",
                        "content": "class Solution {\\n    public int numIslands(char[][] grid) {\\n        int count=0;\\n\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[i].length;j++){\\n                if(grid[i][j]==\\'1\\'){\\n                    count+=1;\\n                    callDFS(grid,i,j);\\n                }\\n            }\\n        }\\n        return count;   \\n    }\\n    public void  callDFS(char[][] grid, int i, int j){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[i].length || grid[i][j]==\\'0\\') {\\n            return;\\n        }\\n\\n        grid[i][j]=\\'0\\';\\n        callDFS(grid,i+1,j);\\n        callDFS(grid,i-1,j);\\n        callDFS(grid,i,j-1);\\n        callDFS(grid,i,j+1);\\n    }\\n}\\n\\nSolution code for java"
                    },
                    {
                        "username": "YEONG-CTRL",
                        "content": "I'm wondering  how char[][]grid can be changed in my code, same question applies to [flood fill](https://leetcode.com/problems/flood-fill/?envType=study-plan&id=level-1).\nIn my onpinion, \"grid\" is local variable in function numIslands, and \"grid\" passed to function dfs is another local variable of function \"dfs\". So, changing grid's value in dfs  like`  grid[i][j] = '0';` will not affect the \"grid\" in numIslands. But My code works despite of my concern. Can someone tell me why changing \"grid\" in another function \"dfs\" still works??  \n\n[Here's my code.\n](https://leetcode.com/problems/number-of-islands/submissions/854760166/\n)"
                    },
                    {
                        "username": "trashw1n",
                        "content": "this code is overcounting number of islands and i cant spot out the bug. please help me\\n\\n `\\nclass Solution {\\nprivate:\\n    void bfs(int row,int col,vector<vector<int>>& vis, vector<vector<char>> grid){\\n        int m = grid.size(), n = grid[0].size();\\n        vis[row][col] = 1;\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        vector<pair<int,int>> dirs = vector<pair<int,int>>{{0,-1},{-1,0},{1,0},{0,1}};\\n        while(q.size()){\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            for(auto dir : dirs){\\n                int nrow = r + dir.first;\\n                int ncol = r + dir.second;\\n                if(nrow>=0 && ncol>=0 && nrow<m && ncol<n && grid[nrow][ncol]==\\'1\\' && !vis[nrow][ncol]){\\n                    vis[nrow][ncol]=1;\\n                    q.push({nrow,ncol});\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int count = 0;\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        for(int row = 0;row<m;row++){\\n            for(int col = 0;col<n;col++){\\n                if(!vis[row][col] && grid[row][col]==\\'1\\'){\\n                    bfs(row,col,vis,grid);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "line 3"
                    },
                    {
                        "username": "black_11",
                        "content": "Compiler is giving me Time limit exceeded error at 47th test case.\\nHow should I optimise it ? Pls help!!\\n `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1711100,
                "content": [
                    {
                        "username": "parasharsumedh5",
                        "content": "Hi, Can someone pls explain why this solutions times out for this test case: \\n\\n class Solution {\\n    \\n    private static final int[] d = {0,1,0,-1,0};\\n    \\n    public int numIslands(char[][] grid) {\\n        int island = 0;\\n        int m = grid.length;\\n        if(m == 0) return 0;\\n        int n = grid[0].length;\\n        \\n        Set<Integer> visitedSet = new HashSet<Integer>();\\n        Queue<int[]> queue = new LinkedList<>();\\n        \\n        for(int i=0; i< m;i++){\\n            for(int j=0; j<n ;j++){\\n                if(grid[i][j] == \\'1\\' && !visitedSet.contains(i*n+j)){\\n                    island++;\\n                    \\n                    queue.add(new int[]{i,j});\\n                    while(!queue.isEmpty()){\\n                        int[] pts = queue.poll();\\n                        visitedSet.add(pts[0] * n + pts[1]);\\n                        for(int k=0; k<4; k++){\\n                            int r = pts[0] + d[k];\\n                            int c = pts[1] + d[k+1];\\n                            \\n                            if(r>=0 && r<m && c>=0 && c<n){\\n                                if(grid[r][c] == \\'1\\' && !visitedSet.contains(r*n+c)){\\n                                    queue.add(new int[]{r,c});\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return island;\\n    }\\n}\\n\\n\\nTest Case : \\n[[\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"]]\\n"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`\\n\\nvoid dfs(int i,int j,vector<vector<char>>& grid,vector<vector<int>> &vis){\\n        vis[i][j]=1;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(i>=0 && i<n && j>=0 && j<m && grid[i][j]==\\'1\\' && !vis[i][j]){\\n          \\n            //vertically down\\n            dfs(i+1,j,grid,vis);\\n            //horizontally forward\\n            dfs(i,j+1,grid,vis);\\n            //vertically upward\\n            dfs(i-1,j,grid,vis);\\n            //horizontally backward\\n            dfs(i,j-1,grid,vis);\\n        }\\n    }\\n     \\n    // Function to find the number of islands.\\n    int numIslands(vector<vector<char>>& grid) {\\n        // Code here\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        //creating visited array\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        int island=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==\\'1\\' && !vis[i][j]){\\n                    island++;\\n                    dfs(i,j,grid,vis);\\n                }\\n            }\\n        }\\n        return island;\\n    }\\n\\n\\n\\ni am getting wrong answer for this,can anyone explain why"
                    },
                    {
                        "username": "gorman",
                        "content": "The C++ language system used here appears to have become borked in some way:  my algorithm coded in C++ fails with a \"Time Exceeded Limits\" yet the same exact algorithm coded in Java passes, surpassing 85% of submissions.  I didn\\'t make a silly C++ mistake; I\\'m highly experienced in both languages. "
                    },
                    {
                        "username": "averagebloke",
                        "content": "\"vertically\" is incorrect!\nThe 2nd input and output shows that:\nInput: grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\nOutput: 3\n\nCorrect description should be:\n\"Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally ~~or vertically~~. You may assume all four edges of the grid are all surrounded by water.\""
                    },
                    {
                        "username": "vlad_zotov",
                        "content": "With recursive DFS, what is memory complexity considering memory in call stack? Isn\\'t it O(n) for worst case if all cells are \"1\"? Or call stack is 4 (for each neighbour cell, therefor O(1). Seems like it\\'s O(n)..."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "I first attacked this with BFS - and that just turned into an ugly mess of spaghetti code. Realized that DFS  is much cleaner and easier to implement in this case. BFS has its uses, just not here. "
                    },
                    {
                        "username": "mehdiwadiwala1",
                        "content": "class Solution {\\n    public int numIslands(char[][] grid) {\\n        int count=0;\\n\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[i].length;j++){\\n                if(grid[i][j]==\\'1\\'){\\n                    count+=1;\\n                    callDFS(grid,i,j);\\n                }\\n            }\\n        }\\n        return count;   \\n    }\\n    public void  callDFS(char[][] grid, int i, int j){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[i].length || grid[i][j]==\\'0\\') {\\n            return;\\n        }\\n\\n        grid[i][j]=\\'0\\';\\n        callDFS(grid,i+1,j);\\n        callDFS(grid,i-1,j);\\n        callDFS(grid,i,j-1);\\n        callDFS(grid,i,j+1);\\n    }\\n}\\n\\nSolution code for java"
                    },
                    {
                        "username": "YEONG-CTRL",
                        "content": "I'm wondering  how char[][]grid can be changed in my code, same question applies to [flood fill](https://leetcode.com/problems/flood-fill/?envType=study-plan&id=level-1).\nIn my onpinion, \"grid\" is local variable in function numIslands, and \"grid\" passed to function dfs is another local variable of function \"dfs\". So, changing grid's value in dfs  like`  grid[i][j] = '0';` will not affect the \"grid\" in numIslands. But My code works despite of my concern. Can someone tell me why changing \"grid\" in another function \"dfs\" still works??  \n\n[Here's my code.\n](https://leetcode.com/problems/number-of-islands/submissions/854760166/\n)"
                    },
                    {
                        "username": "trashw1n",
                        "content": "this code is overcounting number of islands and i cant spot out the bug. please help me\\n\\n `\\nclass Solution {\\nprivate:\\n    void bfs(int row,int col,vector<vector<int>>& vis, vector<vector<char>> grid){\\n        int m = grid.size(), n = grid[0].size();\\n        vis[row][col] = 1;\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        vector<pair<int,int>> dirs = vector<pair<int,int>>{{0,-1},{-1,0},{1,0},{0,1}};\\n        while(q.size()){\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            for(auto dir : dirs){\\n                int nrow = r + dir.first;\\n                int ncol = r + dir.second;\\n                if(nrow>=0 && ncol>=0 && nrow<m && ncol<n && grid[nrow][ncol]==\\'1\\' && !vis[nrow][ncol]){\\n                    vis[nrow][ncol]=1;\\n                    q.push({nrow,ncol});\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int count = 0;\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        for(int row = 0;row<m;row++){\\n            for(int col = 0;col<n;col++){\\n                if(!vis[row][col] && grid[row][col]==\\'1\\'){\\n                    bfs(row,col,vis,grid);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "line 3"
                    },
                    {
                        "username": "black_11",
                        "content": "Compiler is giving me Time limit exceeded error at 47th test case.\\nHow should I optimise it ? Pls help!!\\n `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1707804,
                "content": [
                    {
                        "username": "parasharsumedh5",
                        "content": "Hi, Can someone pls explain why this solutions times out for this test case: \\n\\n class Solution {\\n    \\n    private static final int[] d = {0,1,0,-1,0};\\n    \\n    public int numIslands(char[][] grid) {\\n        int island = 0;\\n        int m = grid.length;\\n        if(m == 0) return 0;\\n        int n = grid[0].length;\\n        \\n        Set<Integer> visitedSet = new HashSet<Integer>();\\n        Queue<int[]> queue = new LinkedList<>();\\n        \\n        for(int i=0; i< m;i++){\\n            for(int j=0; j<n ;j++){\\n                if(grid[i][j] == \\'1\\' && !visitedSet.contains(i*n+j)){\\n                    island++;\\n                    \\n                    queue.add(new int[]{i,j});\\n                    while(!queue.isEmpty()){\\n                        int[] pts = queue.poll();\\n                        visitedSet.add(pts[0] * n + pts[1]);\\n                        for(int k=0; k<4; k++){\\n                            int r = pts[0] + d[k];\\n                            int c = pts[1] + d[k+1];\\n                            \\n                            if(r>=0 && r<m && c>=0 && c<n){\\n                                if(grid[r][c] == \\'1\\' && !visitedSet.contains(r*n+c)){\\n                                    queue.add(new int[]{r,c});\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return island;\\n    }\\n}\\n\\n\\nTest Case : \\n[[\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"]]\\n"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`\\n\\nvoid dfs(int i,int j,vector<vector<char>>& grid,vector<vector<int>> &vis){\\n        vis[i][j]=1;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(i>=0 && i<n && j>=0 && j<m && grid[i][j]==\\'1\\' && !vis[i][j]){\\n          \\n            //vertically down\\n            dfs(i+1,j,grid,vis);\\n            //horizontally forward\\n            dfs(i,j+1,grid,vis);\\n            //vertically upward\\n            dfs(i-1,j,grid,vis);\\n            //horizontally backward\\n            dfs(i,j-1,grid,vis);\\n        }\\n    }\\n     \\n    // Function to find the number of islands.\\n    int numIslands(vector<vector<char>>& grid) {\\n        // Code here\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        //creating visited array\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        int island=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==\\'1\\' && !vis[i][j]){\\n                    island++;\\n                    dfs(i,j,grid,vis);\\n                }\\n            }\\n        }\\n        return island;\\n    }\\n\\n\\n\\ni am getting wrong answer for this,can anyone explain why"
                    },
                    {
                        "username": "gorman",
                        "content": "The C++ language system used here appears to have become borked in some way:  my algorithm coded in C++ fails with a \"Time Exceeded Limits\" yet the same exact algorithm coded in Java passes, surpassing 85% of submissions.  I didn\\'t make a silly C++ mistake; I\\'m highly experienced in both languages. "
                    },
                    {
                        "username": "averagebloke",
                        "content": "\"vertically\" is incorrect!\nThe 2nd input and output shows that:\nInput: grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\nOutput: 3\n\nCorrect description should be:\n\"Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally ~~or vertically~~. You may assume all four edges of the grid are all surrounded by water.\""
                    },
                    {
                        "username": "vlad_zotov",
                        "content": "With recursive DFS, what is memory complexity considering memory in call stack? Isn\\'t it O(n) for worst case if all cells are \"1\"? Or call stack is 4 (for each neighbour cell, therefor O(1). Seems like it\\'s O(n)..."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "I first attacked this with BFS - and that just turned into an ugly mess of spaghetti code. Realized that DFS  is much cleaner and easier to implement in this case. BFS has its uses, just not here. "
                    },
                    {
                        "username": "mehdiwadiwala1",
                        "content": "class Solution {\\n    public int numIslands(char[][] grid) {\\n        int count=0;\\n\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[i].length;j++){\\n                if(grid[i][j]==\\'1\\'){\\n                    count+=1;\\n                    callDFS(grid,i,j);\\n                }\\n            }\\n        }\\n        return count;   \\n    }\\n    public void  callDFS(char[][] grid, int i, int j){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[i].length || grid[i][j]==\\'0\\') {\\n            return;\\n        }\\n\\n        grid[i][j]=\\'0\\';\\n        callDFS(grid,i+1,j);\\n        callDFS(grid,i-1,j);\\n        callDFS(grid,i,j-1);\\n        callDFS(grid,i,j+1);\\n    }\\n}\\n\\nSolution code for java"
                    },
                    {
                        "username": "YEONG-CTRL",
                        "content": "I'm wondering  how char[][]grid can be changed in my code, same question applies to [flood fill](https://leetcode.com/problems/flood-fill/?envType=study-plan&id=level-1).\nIn my onpinion, \"grid\" is local variable in function numIslands, and \"grid\" passed to function dfs is another local variable of function \"dfs\". So, changing grid's value in dfs  like`  grid[i][j] = '0';` will not affect the \"grid\" in numIslands. But My code works despite of my concern. Can someone tell me why changing \"grid\" in another function \"dfs\" still works??  \n\n[Here's my code.\n](https://leetcode.com/problems/number-of-islands/submissions/854760166/\n)"
                    },
                    {
                        "username": "trashw1n",
                        "content": "this code is overcounting number of islands and i cant spot out the bug. please help me\\n\\n `\\nclass Solution {\\nprivate:\\n    void bfs(int row,int col,vector<vector<int>>& vis, vector<vector<char>> grid){\\n        int m = grid.size(), n = grid[0].size();\\n        vis[row][col] = 1;\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        vector<pair<int,int>> dirs = vector<pair<int,int>>{{0,-1},{-1,0},{1,0},{0,1}};\\n        while(q.size()){\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            for(auto dir : dirs){\\n                int nrow = r + dir.first;\\n                int ncol = r + dir.second;\\n                if(nrow>=0 && ncol>=0 && nrow<m && ncol<n && grid[nrow][ncol]==\\'1\\' && !vis[nrow][ncol]){\\n                    vis[nrow][ncol]=1;\\n                    q.push({nrow,ncol});\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int count = 0;\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        for(int row = 0;row<m;row++){\\n            for(int col = 0;col<n;col++){\\n                if(!vis[row][col] && grid[row][col]==\\'1\\'){\\n                    bfs(row,col,vis,grid);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "line 3"
                    },
                    {
                        "username": "black_11",
                        "content": "Compiler is giving me Time limit exceeded error at 47th test case.\\nHow should I optimise it ? Pls help!!\\n `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1706245,
                "content": [
                    {
                        "username": "parasharsumedh5",
                        "content": "Hi, Can someone pls explain why this solutions times out for this test case: \\n\\n class Solution {\\n    \\n    private static final int[] d = {0,1,0,-1,0};\\n    \\n    public int numIslands(char[][] grid) {\\n        int island = 0;\\n        int m = grid.length;\\n        if(m == 0) return 0;\\n        int n = grid[0].length;\\n        \\n        Set<Integer> visitedSet = new HashSet<Integer>();\\n        Queue<int[]> queue = new LinkedList<>();\\n        \\n        for(int i=0; i< m;i++){\\n            for(int j=0; j<n ;j++){\\n                if(grid[i][j] == \\'1\\' && !visitedSet.contains(i*n+j)){\\n                    island++;\\n                    \\n                    queue.add(new int[]{i,j});\\n                    while(!queue.isEmpty()){\\n                        int[] pts = queue.poll();\\n                        visitedSet.add(pts[0] * n + pts[1]);\\n                        for(int k=0; k<4; k++){\\n                            int r = pts[0] + d[k];\\n                            int c = pts[1] + d[k+1];\\n                            \\n                            if(r>=0 && r<m && c>=0 && c<n){\\n                                if(grid[r][c] == \\'1\\' && !visitedSet.contains(r*n+c)){\\n                                    queue.add(new int[]{r,c});\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return island;\\n    }\\n}\\n\\n\\nTest Case : \\n[[\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"]]\\n"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`\\n\\nvoid dfs(int i,int j,vector<vector<char>>& grid,vector<vector<int>> &vis){\\n        vis[i][j]=1;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(i>=0 && i<n && j>=0 && j<m && grid[i][j]==\\'1\\' && !vis[i][j]){\\n          \\n            //vertically down\\n            dfs(i+1,j,grid,vis);\\n            //horizontally forward\\n            dfs(i,j+1,grid,vis);\\n            //vertically upward\\n            dfs(i-1,j,grid,vis);\\n            //horizontally backward\\n            dfs(i,j-1,grid,vis);\\n        }\\n    }\\n     \\n    // Function to find the number of islands.\\n    int numIslands(vector<vector<char>>& grid) {\\n        // Code here\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        //creating visited array\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        int island=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==\\'1\\' && !vis[i][j]){\\n                    island++;\\n                    dfs(i,j,grid,vis);\\n                }\\n            }\\n        }\\n        return island;\\n    }\\n\\n\\n\\ni am getting wrong answer for this,can anyone explain why"
                    },
                    {
                        "username": "gorman",
                        "content": "The C++ language system used here appears to have become borked in some way:  my algorithm coded in C++ fails with a \"Time Exceeded Limits\" yet the same exact algorithm coded in Java passes, surpassing 85% of submissions.  I didn\\'t make a silly C++ mistake; I\\'m highly experienced in both languages. "
                    },
                    {
                        "username": "averagebloke",
                        "content": "\"vertically\" is incorrect!\nThe 2nd input and output shows that:\nInput: grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\nOutput: 3\n\nCorrect description should be:\n\"Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally ~~or vertically~~. You may assume all four edges of the grid are all surrounded by water.\""
                    },
                    {
                        "username": "vlad_zotov",
                        "content": "With recursive DFS, what is memory complexity considering memory in call stack? Isn\\'t it O(n) for worst case if all cells are \"1\"? Or call stack is 4 (for each neighbour cell, therefor O(1). Seems like it\\'s O(n)..."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "I first attacked this with BFS - and that just turned into an ugly mess of spaghetti code. Realized that DFS  is much cleaner and easier to implement in this case. BFS has its uses, just not here. "
                    },
                    {
                        "username": "mehdiwadiwala1",
                        "content": "class Solution {\\n    public int numIslands(char[][] grid) {\\n        int count=0;\\n\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[i].length;j++){\\n                if(grid[i][j]==\\'1\\'){\\n                    count+=1;\\n                    callDFS(grid,i,j);\\n                }\\n            }\\n        }\\n        return count;   \\n    }\\n    public void  callDFS(char[][] grid, int i, int j){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[i].length || grid[i][j]==\\'0\\') {\\n            return;\\n        }\\n\\n        grid[i][j]=\\'0\\';\\n        callDFS(grid,i+1,j);\\n        callDFS(grid,i-1,j);\\n        callDFS(grid,i,j-1);\\n        callDFS(grid,i,j+1);\\n    }\\n}\\n\\nSolution code for java"
                    },
                    {
                        "username": "YEONG-CTRL",
                        "content": "I'm wondering  how char[][]grid can be changed in my code, same question applies to [flood fill](https://leetcode.com/problems/flood-fill/?envType=study-plan&id=level-1).\nIn my onpinion, \"grid\" is local variable in function numIslands, and \"grid\" passed to function dfs is another local variable of function \"dfs\". So, changing grid's value in dfs  like`  grid[i][j] = '0';` will not affect the \"grid\" in numIslands. But My code works despite of my concern. Can someone tell me why changing \"grid\" in another function \"dfs\" still works??  \n\n[Here's my code.\n](https://leetcode.com/problems/number-of-islands/submissions/854760166/\n)"
                    },
                    {
                        "username": "trashw1n",
                        "content": "this code is overcounting number of islands and i cant spot out the bug. please help me\\n\\n `\\nclass Solution {\\nprivate:\\n    void bfs(int row,int col,vector<vector<int>>& vis, vector<vector<char>> grid){\\n        int m = grid.size(), n = grid[0].size();\\n        vis[row][col] = 1;\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        vector<pair<int,int>> dirs = vector<pair<int,int>>{{0,-1},{-1,0},{1,0},{0,1}};\\n        while(q.size()){\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            for(auto dir : dirs){\\n                int nrow = r + dir.first;\\n                int ncol = r + dir.second;\\n                if(nrow>=0 && ncol>=0 && nrow<m && ncol<n && grid[nrow][ncol]==\\'1\\' && !vis[nrow][ncol]){\\n                    vis[nrow][ncol]=1;\\n                    q.push({nrow,ncol});\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int count = 0;\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        for(int row = 0;row<m;row++){\\n            for(int col = 0;col<n;col++){\\n                if(!vis[row][col] && grid[row][col]==\\'1\\'){\\n                    bfs(row,col,vis,grid);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "line 3"
                    },
                    {
                        "username": "black_11",
                        "content": "Compiler is giving me Time limit exceeded error at 47th test case.\\nHow should I optimise it ? Pls help!!\\n `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1706183,
                "content": [
                    {
                        "username": "parasharsumedh5",
                        "content": "Hi, Can someone pls explain why this solutions times out for this test case: \\n\\n class Solution {\\n    \\n    private static final int[] d = {0,1,0,-1,0};\\n    \\n    public int numIslands(char[][] grid) {\\n        int island = 0;\\n        int m = grid.length;\\n        if(m == 0) return 0;\\n        int n = grid[0].length;\\n        \\n        Set<Integer> visitedSet = new HashSet<Integer>();\\n        Queue<int[]> queue = new LinkedList<>();\\n        \\n        for(int i=0; i< m;i++){\\n            for(int j=0; j<n ;j++){\\n                if(grid[i][j] == \\'1\\' && !visitedSet.contains(i*n+j)){\\n                    island++;\\n                    \\n                    queue.add(new int[]{i,j});\\n                    while(!queue.isEmpty()){\\n                        int[] pts = queue.poll();\\n                        visitedSet.add(pts[0] * n + pts[1]);\\n                        for(int k=0; k<4; k++){\\n                            int r = pts[0] + d[k];\\n                            int c = pts[1] + d[k+1];\\n                            \\n                            if(r>=0 && r<m && c>=0 && c<n){\\n                                if(grid[r][c] == \\'1\\' && !visitedSet.contains(r*n+c)){\\n                                    queue.add(new int[]{r,c});\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return island;\\n    }\\n}\\n\\n\\nTest Case : \\n[[\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"]]\\n"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`\\n\\nvoid dfs(int i,int j,vector<vector<char>>& grid,vector<vector<int>> &vis){\\n        vis[i][j]=1;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(i>=0 && i<n && j>=0 && j<m && grid[i][j]==\\'1\\' && !vis[i][j]){\\n          \\n            //vertically down\\n            dfs(i+1,j,grid,vis);\\n            //horizontally forward\\n            dfs(i,j+1,grid,vis);\\n            //vertically upward\\n            dfs(i-1,j,grid,vis);\\n            //horizontally backward\\n            dfs(i,j-1,grid,vis);\\n        }\\n    }\\n     \\n    // Function to find the number of islands.\\n    int numIslands(vector<vector<char>>& grid) {\\n        // Code here\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        //creating visited array\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        int island=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==\\'1\\' && !vis[i][j]){\\n                    island++;\\n                    dfs(i,j,grid,vis);\\n                }\\n            }\\n        }\\n        return island;\\n    }\\n\\n\\n\\ni am getting wrong answer for this,can anyone explain why"
                    },
                    {
                        "username": "gorman",
                        "content": "The C++ language system used here appears to have become borked in some way:  my algorithm coded in C++ fails with a \"Time Exceeded Limits\" yet the same exact algorithm coded in Java passes, surpassing 85% of submissions.  I didn\\'t make a silly C++ mistake; I\\'m highly experienced in both languages. "
                    },
                    {
                        "username": "averagebloke",
                        "content": "\"vertically\" is incorrect!\nThe 2nd input and output shows that:\nInput: grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\nOutput: 3\n\nCorrect description should be:\n\"Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally ~~or vertically~~. You may assume all four edges of the grid are all surrounded by water.\""
                    },
                    {
                        "username": "vlad_zotov",
                        "content": "With recursive DFS, what is memory complexity considering memory in call stack? Isn\\'t it O(n) for worst case if all cells are \"1\"? Or call stack is 4 (for each neighbour cell, therefor O(1). Seems like it\\'s O(n)..."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "I first attacked this with BFS - and that just turned into an ugly mess of spaghetti code. Realized that DFS  is much cleaner and easier to implement in this case. BFS has its uses, just not here. "
                    },
                    {
                        "username": "mehdiwadiwala1",
                        "content": "class Solution {\\n    public int numIslands(char[][] grid) {\\n        int count=0;\\n\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[i].length;j++){\\n                if(grid[i][j]==\\'1\\'){\\n                    count+=1;\\n                    callDFS(grid,i,j);\\n                }\\n            }\\n        }\\n        return count;   \\n    }\\n    public void  callDFS(char[][] grid, int i, int j){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[i].length || grid[i][j]==\\'0\\') {\\n            return;\\n        }\\n\\n        grid[i][j]=\\'0\\';\\n        callDFS(grid,i+1,j);\\n        callDFS(grid,i-1,j);\\n        callDFS(grid,i,j-1);\\n        callDFS(grid,i,j+1);\\n    }\\n}\\n\\nSolution code for java"
                    },
                    {
                        "username": "YEONG-CTRL",
                        "content": "I'm wondering  how char[][]grid can be changed in my code, same question applies to [flood fill](https://leetcode.com/problems/flood-fill/?envType=study-plan&id=level-1).\nIn my onpinion, \"grid\" is local variable in function numIslands, and \"grid\" passed to function dfs is another local variable of function \"dfs\". So, changing grid's value in dfs  like`  grid[i][j] = '0';` will not affect the \"grid\" in numIslands. But My code works despite of my concern. Can someone tell me why changing \"grid\" in another function \"dfs\" still works??  \n\n[Here's my code.\n](https://leetcode.com/problems/number-of-islands/submissions/854760166/\n)"
                    },
                    {
                        "username": "trashw1n",
                        "content": "this code is overcounting number of islands and i cant spot out the bug. please help me\\n\\n `\\nclass Solution {\\nprivate:\\n    void bfs(int row,int col,vector<vector<int>>& vis, vector<vector<char>> grid){\\n        int m = grid.size(), n = grid[0].size();\\n        vis[row][col] = 1;\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        vector<pair<int,int>> dirs = vector<pair<int,int>>{{0,-1},{-1,0},{1,0},{0,1}};\\n        while(q.size()){\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            for(auto dir : dirs){\\n                int nrow = r + dir.first;\\n                int ncol = r + dir.second;\\n                if(nrow>=0 && ncol>=0 && nrow<m && ncol<n && grid[nrow][ncol]==\\'1\\' && !vis[nrow][ncol]){\\n                    vis[nrow][ncol]=1;\\n                    q.push({nrow,ncol});\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int count = 0;\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        for(int row = 0;row<m;row++){\\n            for(int col = 0;col<n;col++){\\n                if(!vis[row][col] && grid[row][col]==\\'1\\'){\\n                    bfs(row,col,vis,grid);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "line 3"
                    },
                    {
                        "username": "black_11",
                        "content": "Compiler is giving me Time limit exceeded error at 47th test case.\\nHow should I optimise it ? Pls help!!\\n `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1705732,
                "content": [
                    {
                        "username": "parasharsumedh5",
                        "content": "Hi, Can someone pls explain why this solutions times out for this test case: \\n\\n class Solution {\\n    \\n    private static final int[] d = {0,1,0,-1,0};\\n    \\n    public int numIslands(char[][] grid) {\\n        int island = 0;\\n        int m = grid.length;\\n        if(m == 0) return 0;\\n        int n = grid[0].length;\\n        \\n        Set<Integer> visitedSet = new HashSet<Integer>();\\n        Queue<int[]> queue = new LinkedList<>();\\n        \\n        for(int i=0; i< m;i++){\\n            for(int j=0; j<n ;j++){\\n                if(grid[i][j] == \\'1\\' && !visitedSet.contains(i*n+j)){\\n                    island++;\\n                    \\n                    queue.add(new int[]{i,j});\\n                    while(!queue.isEmpty()){\\n                        int[] pts = queue.poll();\\n                        visitedSet.add(pts[0] * n + pts[1]);\\n                        for(int k=0; k<4; k++){\\n                            int r = pts[0] + d[k];\\n                            int c = pts[1] + d[k+1];\\n                            \\n                            if(r>=0 && r<m && c>=0 && c<n){\\n                                if(grid[r][c] == \\'1\\' && !visitedSet.contains(r*n+c)){\\n                                    queue.add(new int[]{r,c});\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return island;\\n    }\\n}\\n\\n\\nTest Case : \\n[[\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\",\"1\"]]\\n"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`\\n\\nvoid dfs(int i,int j,vector<vector<char>>& grid,vector<vector<int>> &vis){\\n        vis[i][j]=1;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(i>=0 && i<n && j>=0 && j<m && grid[i][j]==\\'1\\' && !vis[i][j]){\\n          \\n            //vertically down\\n            dfs(i+1,j,grid,vis);\\n            //horizontally forward\\n            dfs(i,j+1,grid,vis);\\n            //vertically upward\\n            dfs(i-1,j,grid,vis);\\n            //horizontally backward\\n            dfs(i,j-1,grid,vis);\\n        }\\n    }\\n     \\n    // Function to find the number of islands.\\n    int numIslands(vector<vector<char>>& grid) {\\n        // Code here\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        //creating visited array\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        int island=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==\\'1\\' && !vis[i][j]){\\n                    island++;\\n                    dfs(i,j,grid,vis);\\n                }\\n            }\\n        }\\n        return island;\\n    }\\n\\n\\n\\ni am getting wrong answer for this,can anyone explain why"
                    },
                    {
                        "username": "gorman",
                        "content": "The C++ language system used here appears to have become borked in some way:  my algorithm coded in C++ fails with a \"Time Exceeded Limits\" yet the same exact algorithm coded in Java passes, surpassing 85% of submissions.  I didn\\'t make a silly C++ mistake; I\\'m highly experienced in both languages. "
                    },
                    {
                        "username": "averagebloke",
                        "content": "\"vertically\" is incorrect!\nThe 2nd input and output shows that:\nInput: grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\nOutput: 3\n\nCorrect description should be:\n\"Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally ~~or vertically~~. You may assume all four edges of the grid are all surrounded by water.\""
                    },
                    {
                        "username": "vlad_zotov",
                        "content": "With recursive DFS, what is memory complexity considering memory in call stack? Isn\\'t it O(n) for worst case if all cells are \"1\"? Or call stack is 4 (for each neighbour cell, therefor O(1). Seems like it\\'s O(n)..."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "I first attacked this with BFS - and that just turned into an ugly mess of spaghetti code. Realized that DFS  is much cleaner and easier to implement in this case. BFS has its uses, just not here. "
                    },
                    {
                        "username": "mehdiwadiwala1",
                        "content": "class Solution {\\n    public int numIslands(char[][] grid) {\\n        int count=0;\\n\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[i].length;j++){\\n                if(grid[i][j]==\\'1\\'){\\n                    count+=1;\\n                    callDFS(grid,i,j);\\n                }\\n            }\\n        }\\n        return count;   \\n    }\\n    public void  callDFS(char[][] grid, int i, int j){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[i].length || grid[i][j]==\\'0\\') {\\n            return;\\n        }\\n\\n        grid[i][j]=\\'0\\';\\n        callDFS(grid,i+1,j);\\n        callDFS(grid,i-1,j);\\n        callDFS(grid,i,j-1);\\n        callDFS(grid,i,j+1);\\n    }\\n}\\n\\nSolution code for java"
                    },
                    {
                        "username": "YEONG-CTRL",
                        "content": "I'm wondering  how char[][]grid can be changed in my code, same question applies to [flood fill](https://leetcode.com/problems/flood-fill/?envType=study-plan&id=level-1).\nIn my onpinion, \"grid\" is local variable in function numIslands, and \"grid\" passed to function dfs is another local variable of function \"dfs\". So, changing grid's value in dfs  like`  grid[i][j] = '0';` will not affect the \"grid\" in numIslands. But My code works despite of my concern. Can someone tell me why changing \"grid\" in another function \"dfs\" still works??  \n\n[Here's my code.\n](https://leetcode.com/problems/number-of-islands/submissions/854760166/\n)"
                    },
                    {
                        "username": "trashw1n",
                        "content": "this code is overcounting number of islands and i cant spot out the bug. please help me\\n\\n `\\nclass Solution {\\nprivate:\\n    void bfs(int row,int col,vector<vector<int>>& vis, vector<vector<char>> grid){\\n        int m = grid.size(), n = grid[0].size();\\n        vis[row][col] = 1;\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        vector<pair<int,int>> dirs = vector<pair<int,int>>{{0,-1},{-1,0},{1,0},{0,1}};\\n        while(q.size()){\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            for(auto dir : dirs){\\n                int nrow = r + dir.first;\\n                int ncol = r + dir.second;\\n                if(nrow>=0 && ncol>=0 && nrow<m && ncol<n && grid[nrow][ncol]==\\'1\\' && !vis[nrow][ncol]){\\n                    vis[nrow][ncol]=1;\\n                    q.push({nrow,ncol});\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int count = 0;\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        for(int row = 0;row<m;row++){\\n            for(int col = 0;col<n;col++){\\n                if(!vis[row][col] && grid[row][col]==\\'1\\'){\\n                    bfs(row,col,vis,grid);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "line 3"
                    },
                    {
                        "username": "black_11",
                        "content": "Compiler is giving me Time limit exceeded error at 47th test case.\\nHow should I optimise it ? Pls help!!\\n `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1702946,
                "content": [
                    {
                        "username": "Om-_-sd",
                        "content": "what are the gridSize  and  *gridColSize variables here?"
                    },
                    {
                        "username": "Jayusc",
                        "content": "stupid question input to set as type \\'str\\'. If you are to use 0 and 1s, you should use type integer"
                    },
                    {
                        "username": "Atulsid151",
                        "content": "class Solution {\\n    public int numIslands(char[][] grid) {\\n         boolean visited[][] = new boolean[grid.length][grid[0].length];\\n         int count = 0;\\n         for(int i=0;i<grid.length;i++){\\n           for(int j=0;j<grid[0].length;j++){\\n                  if(!visited[i][j] && grid[i][j] == \\'1\\') {\\n                              count++;\\n                          helper(grid,visited,i,j);\\n                     \\n                  }\\n           }\\n         }\\n         return count;\\n    }\\n    public void helper(char[][] graph,boolean visited[][],int row,int col){\\n         visited[row][col] = true;\\n\\n         Queue<Pair> queue = new LinkedList<Pair>();\\n                  queue.add(new Pair(row,col));\\n         while(!queue.isEmpty()){\\n              Pair curr = queue.poll();\\n       \\n\\n              for(int i=-1;i<=1;i++){\\n                   for(int j=-1;j<=1;j++){\\n                             int r = curr.first + i;\\n                             int c = curr.second + j;\\n                         if(r>=0 && c>=0 && r<graph.length && c < graph[0].length && !visited[r][c] && graph[r][c] == \\'1\\'){\\n                               visited[r][c] = true;\\n                               queue.add(new Pair(r,c));\\n                         }\\n                   }\\n              }\\n         }\\n\\n    }\\n}\\n\\nclass Pair {\\n  int first;\\n  int second;\\n  public Pair(int first,int second){\\n     this.first = first;\\n     this.second = second;\\n  }\\n}\\ncan someone find whats the error in my code i am not able to find and test case failing"
                    },
                    {
                        "username": "yt_lt",
                        "content": "The time complexity is not O(m*n). Please run the following (Java)code, the output is not like O(m*n).\nThe solution is from https://leetcode.com/problems/number-of-islands/solutions/56338/java-dfs-and-bfs-solution\n```\npublic class NumberOfIslands {\n    int [][] visitCounts;\n    public int numIslands(char[][] grid) {\n        int count=0;\n\n        visitCounts = new int[grid.length][grid[0].length];\n\n        for(int i=0;i<grid.length;i++) {\n            for(int j=0;j<grid[0].length;j++){\n                visitCounts[i][j]++;\n                if(grid[i][j]=='1'){\n                    dfsFill(grid,i,j);\n                    count++;\n                }\n            }\n        }\n        int sum = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                System.out.print(visitCounts[i][j] + \" \");\n                sum += visitCounts[i][j];\n            }\n            System.out.println();\n        }\n        //returns the sum of visit to all coordinates in the matrix\n        return sum;\n    }\n    private void dfsFill(char[][] grid,int i, int j){\n        if (i>=0 && j>=0 && i<grid.length && j<grid[0].length) {\n            visitCounts[i][j]++;\n        }\n        if(i>=0 && j>=0 && i<grid.length && j<grid[0].length&&grid[i][j]=='1'){\n            grid[i][j]='0';\n            dfsFill(grid, i + 1, j);\n            dfsFill(grid, i - 1, j);\n            dfsFill(grid, i, j + 1);\n            dfsFill(grid, i, j - 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','0'},\n                {'1','1','0','1','0'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','0'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n    }\n} \n```\n\noutput:\n```\n4 4 3 3 2 \n4 4 4 2 2 \n3 3 2 2 1 \n2 2 1 1 1 \n50\n4 4 3 4 2 \n4 4 4 2 3 \n3 3 2 2 1 \n2 2 1 1 1 \n52\n4 4 3 4 3 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n55\n4 4 3 4 3 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n1 1 1 1 1 \n60\n4 4 4 4 3 \n4 5 4 5 4 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n1 1 1 1 1 \n83\n```"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "Why this code is not working on leetcode its working in gfg .\\nclass Pair{\\n    int first;\\n    int second;\\n\\n    public Pair(int first, int second)\\n    {\\n        this.first = first;\\n        this.second = second;\\n    }\\n}\\n\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        int vis[][] = new int[row][col];\\n        int count =0;\\n \\n            \\n        for(int i=0; i <row ; i++)\\n        {\\n            for(int j=0; j<col ; j++) {\\n                if(vis[i][j] != 1 && grid[i][j] == \\'1\\')\\n                {\\n                    bfs(i , j, grid , vis);\\n                    count++;\\n                }\\n            }\\n        }\\n       return count; \\n    }\\n\\n    private static void bfs(int row, int col ,char[][] grid, int vis[][] )\\n    {\\n      int n = grid.length;\\n      int m = grid[0].length;\\n\\n      Queue<Pair> queue = new LinkedList<>();\\n      queue.add(new Pair(row,col));\\n      vis[row][col] =1;\\n\\n      while(!queue.isEmpty())\\n      {\\n          int r = queue.peek().first;\\n          int c = queue.peek().second;\\n          queue.remove();\\n\\n          for(int delrow= -1 ; delrow <=1 ; delrow++)\\n          {\\n              for(int delcol= -1 ; delcol <=1 ; delcol++)\\n              {\\n                  int rVal = r+ delrow;\\n                  int cVal = c+ delcol;\\n\\n                  if( rVal >= 0 && cVal >= 0 && rVal <n && cVal < m && grid[rVal][cVal] == \\'1\\' && vis[rVal][cVal] != 1)\\n                  {\\n                      vis[rVal][cVal] =1;\\n                      queue.add(new Pair(rVal,cVal));\\n                  }\\n              }\\n          }\\n      }\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "nrby11",
                        "content": "I have 2 solutions that's basically doing same-things logically.  But I am getting two different runtime metrics , i.e memory used and runtime . The only difference is the variable names that I defined more verbs in the one taking longer time and memory .\n\ncan somebody explain the rational reason behind this ?"
                    },
                    {
                        "username": "himanshubhoria",
                        "content": "getting TLE. 47/49 passed.\\n\\n `class Solution {\\npublic:\\n    int dx[4] = {1, -1, 0, 0};\\n    int dy[4] = {0, 0, 1, -1};\\n    bool visited[333][333]; \\n    int count = 0;\\n\\n    \\n    void bfs(vector<vector<char>> grid, int curx, int cury, int x, int y)\\n    { \\n        for(int i = 0; i < 4; i++)\\n        {\\n            int newx, newy;\\n            newx = curx + dx[i];\\n            newy = cury + dy[i];            \\n            if (newx < 0 || newx >= x || newy < 0 || newy >= y || grid[newx][newy] == \\'0\\' ) continue;\\n            if(visited[newx][newy]) continue;\\n            if(grid[newx][newy] == \\'1\\')\\n            {\\n                visited[newx][newy] = true;\\n                bfs(grid, newx, newy, x, y);   \\n            }\\n        }\\n    }\\n\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();               \\n        memset(visited, false, sizeof(visited));        \\n        int result = 0;\\n        for(int i = 0 ; i < m; i++)\\n        {\\n            for(int j = 0 ; j < n; j++)\\n            {\\n                if(!visited[i][j] && grid[i][j] == \\'1\\')\\n                {\\n                    bfs(grid, i , j, m ,n);\\n                    result++;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "NithinShetty",
                        "content": " ```#include<iostream>\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    void addTo_adjList(unordered_map<int, list<int>> &adjList, vector<vector<char>> &grid, int row, int col, int i, int j, int u){\\n        int v;\\n        adjList[u];\\n\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\'){ // left\\n            v = col*i + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(j+1 < col && grid[i][j+1] == \\'1\\'){ // right\\n            v = col*i + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\'){ // up\\n            v = col*(i-1) + j;\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && grid[i+1][j] == \\'1\\'){ // down\\n            v = col*(i+1) + j;\\n            adjList[u].push_back(v);\\n        }\\n\\n        /* for diagonals\\n\\n        if(i-1 >= 0 && j-1 >= 0 && grid[i-1][j-1] == \\'1\\'){ // left-top\\n            v = col*(i-1) + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && j+1 < col && grid[i-1][j+1] == \\'1\\'){ // right-top\\n            v = col*(i-1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j-1 >= 0 && grid[i+1][j-1] == \\'1\\'){ // left-bottom\\n            v = col*(i+1) + (j-1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j+1 < col && grid[i+1][j] == \\'1\\'){ // right-bottom\\n            v = col*(i+1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        */\\n    }\\n\\n    void dfs(int i, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adjList){\\n        visited[i] = true;\\n        for(auto nbr : adjList[i]){\\n            if(!visited[nbr]){\\n                dfs(nbr, visited, adjList);\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        unordered_map<int, list<int>> adjList;\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i=0; i<row; i++){\\n            int u;\\n            for(int j=0; j<col; j++){\\n                u = col*i + j;\\n                if(grid[i][j] == \\'1\\'){\\n                    addTo_adjList(adjList, grid, row, col, i, j, u);\\n                }\\n            }\\n        }\\n\\n        int isLands = 0;\\n        unordered_map<int, bool> visited;\\n        for(auto i : adjList){\\n            if(!visited[i.first]){\\n                isLands++;\\n                dfs(i.first, visited, adjList);\\n            }\\n        }\\n        \\n        return isLands;\\n    }\\n};```"
                    },
                    {
                        "username": "NithinShetty",
                        "content": " ```#include<iostream>\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    void addTo_adjList(unordered_map<int, list<int>> &adjList, vector<vector<char>> &grid, int row, int col, int i, int j, int u){\\n        int v;\\n        adjList[u];\\n\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\'){ // left\\n            v = col*i + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(j+1 < col && grid[i][j+1] == \\'1\\'){ // right\\n            v = col*i + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\'){ // up\\n            v = col*(i-1) + j;\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && grid[i+1][j] == \\'1\\'){ // down\\n            v = col*(i+1) + j;\\n            adjList[u].push_back(v);\\n        }\\n\\n        /* for diagonals\\n\\n        if(i-1 >= 0 && j-1 >= 0 && grid[i-1][j-1] == \\'1\\'){ // left-top\\n            v = col*(i-1) + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && j+1 < col && grid[i-1][j+1] == \\'1\\'){ // right-top\\n            v = col*(i-1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j-1 >= 0 && grid[i+1][j-1] == \\'1\\'){ // left-bottom\\n            v = col*(i+1) + (j-1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j+1 < col && grid[i+1][j] == \\'1\\'){ // right-bottom\\n            v = col*(i+1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        */\\n    }\\n\\n    void dfs(int i, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adjList){\\n        visited[i] = true;\\n        for(auto nbr : adjList[i]){\\n            if(!visited[nbr]){\\n                dfs(nbr, visited, adjList);\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        unordered_map<int, list<int>> adjList;\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i=0; i<row; i++){\\n            int u;\\n            for(int j=0; j<col; j++){\\n                u = col*i + j;\\n                if(grid[i][j] == \\'1\\'){\\n                    addTo_adjList(adjList, grid, row, col, i, j, u);\\n                }\\n            }\\n        }\\n\\n        int isLands = 0;\\n        unordered_map<int, bool> visited;\\n        for(auto i : adjList){\\n            if(!visited[i.first]){\\n                isLands++;\\n                dfs(i.first, visited, adjList);\\n            }\\n        }\\n        \\n        return isLands;\\n    }\\n};```"
                    },
                    {
                        "username": "sc1233",
                        "content": "After seeing all the solutions here, which are the most important solutions to understand when answering this question in an interview? Choosing between:\n- Iterative DFS\n- Iterative BFS\n- Recursive DFS\n- Union Find \n\nHow would you highlight the pros/cons of each approach?\n"
                    }
                ]
            },
            {
                "id": 1693391,
                "content": [
                    {
                        "username": "Om-_-sd",
                        "content": "what are the gridSize  and  *gridColSize variables here?"
                    },
                    {
                        "username": "Jayusc",
                        "content": "stupid question input to set as type \\'str\\'. If you are to use 0 and 1s, you should use type integer"
                    },
                    {
                        "username": "Atulsid151",
                        "content": "class Solution {\\n    public int numIslands(char[][] grid) {\\n         boolean visited[][] = new boolean[grid.length][grid[0].length];\\n         int count = 0;\\n         for(int i=0;i<grid.length;i++){\\n           for(int j=0;j<grid[0].length;j++){\\n                  if(!visited[i][j] && grid[i][j] == \\'1\\') {\\n                              count++;\\n                          helper(grid,visited,i,j);\\n                     \\n                  }\\n           }\\n         }\\n         return count;\\n    }\\n    public void helper(char[][] graph,boolean visited[][],int row,int col){\\n         visited[row][col] = true;\\n\\n         Queue<Pair> queue = new LinkedList<Pair>();\\n                  queue.add(new Pair(row,col));\\n         while(!queue.isEmpty()){\\n              Pair curr = queue.poll();\\n       \\n\\n              for(int i=-1;i<=1;i++){\\n                   for(int j=-1;j<=1;j++){\\n                             int r = curr.first + i;\\n                             int c = curr.second + j;\\n                         if(r>=0 && c>=0 && r<graph.length && c < graph[0].length && !visited[r][c] && graph[r][c] == \\'1\\'){\\n                               visited[r][c] = true;\\n                               queue.add(new Pair(r,c));\\n                         }\\n                   }\\n              }\\n         }\\n\\n    }\\n}\\n\\nclass Pair {\\n  int first;\\n  int second;\\n  public Pair(int first,int second){\\n     this.first = first;\\n     this.second = second;\\n  }\\n}\\ncan someone find whats the error in my code i am not able to find and test case failing"
                    },
                    {
                        "username": "yt_lt",
                        "content": "The time complexity is not O(m*n). Please run the following (Java)code, the output is not like O(m*n).\nThe solution is from https://leetcode.com/problems/number-of-islands/solutions/56338/java-dfs-and-bfs-solution\n```\npublic class NumberOfIslands {\n    int [][] visitCounts;\n    public int numIslands(char[][] grid) {\n        int count=0;\n\n        visitCounts = new int[grid.length][grid[0].length];\n\n        for(int i=0;i<grid.length;i++) {\n            for(int j=0;j<grid[0].length;j++){\n                visitCounts[i][j]++;\n                if(grid[i][j]=='1'){\n                    dfsFill(grid,i,j);\n                    count++;\n                }\n            }\n        }\n        int sum = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                System.out.print(visitCounts[i][j] + \" \");\n                sum += visitCounts[i][j];\n            }\n            System.out.println();\n        }\n        //returns the sum of visit to all coordinates in the matrix\n        return sum;\n    }\n    private void dfsFill(char[][] grid,int i, int j){\n        if (i>=0 && j>=0 && i<grid.length && j<grid[0].length) {\n            visitCounts[i][j]++;\n        }\n        if(i>=0 && j>=0 && i<grid.length && j<grid[0].length&&grid[i][j]=='1'){\n            grid[i][j]='0';\n            dfsFill(grid, i + 1, j);\n            dfsFill(grid, i - 1, j);\n            dfsFill(grid, i, j + 1);\n            dfsFill(grid, i, j - 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','0'},\n                {'1','1','0','1','0'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','0'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n    }\n} \n```\n\noutput:\n```\n4 4 3 3 2 \n4 4 4 2 2 \n3 3 2 2 1 \n2 2 1 1 1 \n50\n4 4 3 4 2 \n4 4 4 2 3 \n3 3 2 2 1 \n2 2 1 1 1 \n52\n4 4 3 4 3 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n55\n4 4 3 4 3 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n1 1 1 1 1 \n60\n4 4 4 4 3 \n4 5 4 5 4 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n1 1 1 1 1 \n83\n```"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "Why this code is not working on leetcode its working in gfg .\\nclass Pair{\\n    int first;\\n    int second;\\n\\n    public Pair(int first, int second)\\n    {\\n        this.first = first;\\n        this.second = second;\\n    }\\n}\\n\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        int vis[][] = new int[row][col];\\n        int count =0;\\n \\n            \\n        for(int i=0; i <row ; i++)\\n        {\\n            for(int j=0; j<col ; j++) {\\n                if(vis[i][j] != 1 && grid[i][j] == \\'1\\')\\n                {\\n                    bfs(i , j, grid , vis);\\n                    count++;\\n                }\\n            }\\n        }\\n       return count; \\n    }\\n\\n    private static void bfs(int row, int col ,char[][] grid, int vis[][] )\\n    {\\n      int n = grid.length;\\n      int m = grid[0].length;\\n\\n      Queue<Pair> queue = new LinkedList<>();\\n      queue.add(new Pair(row,col));\\n      vis[row][col] =1;\\n\\n      while(!queue.isEmpty())\\n      {\\n          int r = queue.peek().first;\\n          int c = queue.peek().second;\\n          queue.remove();\\n\\n          for(int delrow= -1 ; delrow <=1 ; delrow++)\\n          {\\n              for(int delcol= -1 ; delcol <=1 ; delcol++)\\n              {\\n                  int rVal = r+ delrow;\\n                  int cVal = c+ delcol;\\n\\n                  if( rVal >= 0 && cVal >= 0 && rVal <n && cVal < m && grid[rVal][cVal] == \\'1\\' && vis[rVal][cVal] != 1)\\n                  {\\n                      vis[rVal][cVal] =1;\\n                      queue.add(new Pair(rVal,cVal));\\n                  }\\n              }\\n          }\\n      }\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "nrby11",
                        "content": "I have 2 solutions that's basically doing same-things logically.  But I am getting two different runtime metrics , i.e memory used and runtime . The only difference is the variable names that I defined more verbs in the one taking longer time and memory .\n\ncan somebody explain the rational reason behind this ?"
                    },
                    {
                        "username": "himanshubhoria",
                        "content": "getting TLE. 47/49 passed.\\n\\n `class Solution {\\npublic:\\n    int dx[4] = {1, -1, 0, 0};\\n    int dy[4] = {0, 0, 1, -1};\\n    bool visited[333][333]; \\n    int count = 0;\\n\\n    \\n    void bfs(vector<vector<char>> grid, int curx, int cury, int x, int y)\\n    { \\n        for(int i = 0; i < 4; i++)\\n        {\\n            int newx, newy;\\n            newx = curx + dx[i];\\n            newy = cury + dy[i];            \\n            if (newx < 0 || newx >= x || newy < 0 || newy >= y || grid[newx][newy] == \\'0\\' ) continue;\\n            if(visited[newx][newy]) continue;\\n            if(grid[newx][newy] == \\'1\\')\\n            {\\n                visited[newx][newy] = true;\\n                bfs(grid, newx, newy, x, y);   \\n            }\\n        }\\n    }\\n\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();               \\n        memset(visited, false, sizeof(visited));        \\n        int result = 0;\\n        for(int i = 0 ; i < m; i++)\\n        {\\n            for(int j = 0 ; j < n; j++)\\n            {\\n                if(!visited[i][j] && grid[i][j] == \\'1\\')\\n                {\\n                    bfs(grid, i , j, m ,n);\\n                    result++;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "NithinShetty",
                        "content": " ```#include<iostream>\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    void addTo_adjList(unordered_map<int, list<int>> &adjList, vector<vector<char>> &grid, int row, int col, int i, int j, int u){\\n        int v;\\n        adjList[u];\\n\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\'){ // left\\n            v = col*i + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(j+1 < col && grid[i][j+1] == \\'1\\'){ // right\\n            v = col*i + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\'){ // up\\n            v = col*(i-1) + j;\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && grid[i+1][j] == \\'1\\'){ // down\\n            v = col*(i+1) + j;\\n            adjList[u].push_back(v);\\n        }\\n\\n        /* for diagonals\\n\\n        if(i-1 >= 0 && j-1 >= 0 && grid[i-1][j-1] == \\'1\\'){ // left-top\\n            v = col*(i-1) + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && j+1 < col && grid[i-1][j+1] == \\'1\\'){ // right-top\\n            v = col*(i-1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j-1 >= 0 && grid[i+1][j-1] == \\'1\\'){ // left-bottom\\n            v = col*(i+1) + (j-1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j+1 < col && grid[i+1][j] == \\'1\\'){ // right-bottom\\n            v = col*(i+1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        */\\n    }\\n\\n    void dfs(int i, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adjList){\\n        visited[i] = true;\\n        for(auto nbr : adjList[i]){\\n            if(!visited[nbr]){\\n                dfs(nbr, visited, adjList);\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        unordered_map<int, list<int>> adjList;\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i=0; i<row; i++){\\n            int u;\\n            for(int j=0; j<col; j++){\\n                u = col*i + j;\\n                if(grid[i][j] == \\'1\\'){\\n                    addTo_adjList(adjList, grid, row, col, i, j, u);\\n                }\\n            }\\n        }\\n\\n        int isLands = 0;\\n        unordered_map<int, bool> visited;\\n        for(auto i : adjList){\\n            if(!visited[i.first]){\\n                isLands++;\\n                dfs(i.first, visited, adjList);\\n            }\\n        }\\n        \\n        return isLands;\\n    }\\n};```"
                    },
                    {
                        "username": "NithinShetty",
                        "content": " ```#include<iostream>\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    void addTo_adjList(unordered_map<int, list<int>> &adjList, vector<vector<char>> &grid, int row, int col, int i, int j, int u){\\n        int v;\\n        adjList[u];\\n\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\'){ // left\\n            v = col*i + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(j+1 < col && grid[i][j+1] == \\'1\\'){ // right\\n            v = col*i + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\'){ // up\\n            v = col*(i-1) + j;\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && grid[i+1][j] == \\'1\\'){ // down\\n            v = col*(i+1) + j;\\n            adjList[u].push_back(v);\\n        }\\n\\n        /* for diagonals\\n\\n        if(i-1 >= 0 && j-1 >= 0 && grid[i-1][j-1] == \\'1\\'){ // left-top\\n            v = col*(i-1) + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && j+1 < col && grid[i-1][j+1] == \\'1\\'){ // right-top\\n            v = col*(i-1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j-1 >= 0 && grid[i+1][j-1] == \\'1\\'){ // left-bottom\\n            v = col*(i+1) + (j-1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j+1 < col && grid[i+1][j] == \\'1\\'){ // right-bottom\\n            v = col*(i+1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        */\\n    }\\n\\n    void dfs(int i, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adjList){\\n        visited[i] = true;\\n        for(auto nbr : adjList[i]){\\n            if(!visited[nbr]){\\n                dfs(nbr, visited, adjList);\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        unordered_map<int, list<int>> adjList;\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i=0; i<row; i++){\\n            int u;\\n            for(int j=0; j<col; j++){\\n                u = col*i + j;\\n                if(grid[i][j] == \\'1\\'){\\n                    addTo_adjList(adjList, grid, row, col, i, j, u);\\n                }\\n            }\\n        }\\n\\n        int isLands = 0;\\n        unordered_map<int, bool> visited;\\n        for(auto i : adjList){\\n            if(!visited[i.first]){\\n                isLands++;\\n                dfs(i.first, visited, adjList);\\n            }\\n        }\\n        \\n        return isLands;\\n    }\\n};```"
                    },
                    {
                        "username": "sc1233",
                        "content": "After seeing all the solutions here, which are the most important solutions to understand when answering this question in an interview? Choosing between:\n- Iterative DFS\n- Iterative BFS\n- Recursive DFS\n- Union Find \n\nHow would you highlight the pros/cons of each approach?\n"
                    }
                ]
            },
            {
                "id": 1693288,
                "content": [
                    {
                        "username": "Om-_-sd",
                        "content": "what are the gridSize  and  *gridColSize variables here?"
                    },
                    {
                        "username": "Jayusc",
                        "content": "stupid question input to set as type \\'str\\'. If you are to use 0 and 1s, you should use type integer"
                    },
                    {
                        "username": "Atulsid151",
                        "content": "class Solution {\\n    public int numIslands(char[][] grid) {\\n         boolean visited[][] = new boolean[grid.length][grid[0].length];\\n         int count = 0;\\n         for(int i=0;i<grid.length;i++){\\n           for(int j=0;j<grid[0].length;j++){\\n                  if(!visited[i][j] && grid[i][j] == \\'1\\') {\\n                              count++;\\n                          helper(grid,visited,i,j);\\n                     \\n                  }\\n           }\\n         }\\n         return count;\\n    }\\n    public void helper(char[][] graph,boolean visited[][],int row,int col){\\n         visited[row][col] = true;\\n\\n         Queue<Pair> queue = new LinkedList<Pair>();\\n                  queue.add(new Pair(row,col));\\n         while(!queue.isEmpty()){\\n              Pair curr = queue.poll();\\n       \\n\\n              for(int i=-1;i<=1;i++){\\n                   for(int j=-1;j<=1;j++){\\n                             int r = curr.first + i;\\n                             int c = curr.second + j;\\n                         if(r>=0 && c>=0 && r<graph.length && c < graph[0].length && !visited[r][c] && graph[r][c] == \\'1\\'){\\n                               visited[r][c] = true;\\n                               queue.add(new Pair(r,c));\\n                         }\\n                   }\\n              }\\n         }\\n\\n    }\\n}\\n\\nclass Pair {\\n  int first;\\n  int second;\\n  public Pair(int first,int second){\\n     this.first = first;\\n     this.second = second;\\n  }\\n}\\ncan someone find whats the error in my code i am not able to find and test case failing"
                    },
                    {
                        "username": "yt_lt",
                        "content": "The time complexity is not O(m*n). Please run the following (Java)code, the output is not like O(m*n).\nThe solution is from https://leetcode.com/problems/number-of-islands/solutions/56338/java-dfs-and-bfs-solution\n```\npublic class NumberOfIslands {\n    int [][] visitCounts;\n    public int numIslands(char[][] grid) {\n        int count=0;\n\n        visitCounts = new int[grid.length][grid[0].length];\n\n        for(int i=0;i<grid.length;i++) {\n            for(int j=0;j<grid[0].length;j++){\n                visitCounts[i][j]++;\n                if(grid[i][j]=='1'){\n                    dfsFill(grid,i,j);\n                    count++;\n                }\n            }\n        }\n        int sum = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                System.out.print(visitCounts[i][j] + \" \");\n                sum += visitCounts[i][j];\n            }\n            System.out.println();\n        }\n        //returns the sum of visit to all coordinates in the matrix\n        return sum;\n    }\n    private void dfsFill(char[][] grid,int i, int j){\n        if (i>=0 && j>=0 && i<grid.length && j<grid[0].length) {\n            visitCounts[i][j]++;\n        }\n        if(i>=0 && j>=0 && i<grid.length && j<grid[0].length&&grid[i][j]=='1'){\n            grid[i][j]='0';\n            dfsFill(grid, i + 1, j);\n            dfsFill(grid, i - 1, j);\n            dfsFill(grid, i, j + 1);\n            dfsFill(grid, i, j - 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','0'},\n                {'1','1','0','1','0'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','0'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n    }\n} \n```\n\noutput:\n```\n4 4 3 3 2 \n4 4 4 2 2 \n3 3 2 2 1 \n2 2 1 1 1 \n50\n4 4 3 4 2 \n4 4 4 2 3 \n3 3 2 2 1 \n2 2 1 1 1 \n52\n4 4 3 4 3 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n55\n4 4 3 4 3 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n1 1 1 1 1 \n60\n4 4 4 4 3 \n4 5 4 5 4 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n1 1 1 1 1 \n83\n```"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "Why this code is not working on leetcode its working in gfg .\\nclass Pair{\\n    int first;\\n    int second;\\n\\n    public Pair(int first, int second)\\n    {\\n        this.first = first;\\n        this.second = second;\\n    }\\n}\\n\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        int vis[][] = new int[row][col];\\n        int count =0;\\n \\n            \\n        for(int i=0; i <row ; i++)\\n        {\\n            for(int j=0; j<col ; j++) {\\n                if(vis[i][j] != 1 && grid[i][j] == \\'1\\')\\n                {\\n                    bfs(i , j, grid , vis);\\n                    count++;\\n                }\\n            }\\n        }\\n       return count; \\n    }\\n\\n    private static void bfs(int row, int col ,char[][] grid, int vis[][] )\\n    {\\n      int n = grid.length;\\n      int m = grid[0].length;\\n\\n      Queue<Pair> queue = new LinkedList<>();\\n      queue.add(new Pair(row,col));\\n      vis[row][col] =1;\\n\\n      while(!queue.isEmpty())\\n      {\\n          int r = queue.peek().first;\\n          int c = queue.peek().second;\\n          queue.remove();\\n\\n          for(int delrow= -1 ; delrow <=1 ; delrow++)\\n          {\\n              for(int delcol= -1 ; delcol <=1 ; delcol++)\\n              {\\n                  int rVal = r+ delrow;\\n                  int cVal = c+ delcol;\\n\\n                  if( rVal >= 0 && cVal >= 0 && rVal <n && cVal < m && grid[rVal][cVal] == \\'1\\' && vis[rVal][cVal] != 1)\\n                  {\\n                      vis[rVal][cVal] =1;\\n                      queue.add(new Pair(rVal,cVal));\\n                  }\\n              }\\n          }\\n      }\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "nrby11",
                        "content": "I have 2 solutions that's basically doing same-things logically.  But I am getting two different runtime metrics , i.e memory used and runtime . The only difference is the variable names that I defined more verbs in the one taking longer time and memory .\n\ncan somebody explain the rational reason behind this ?"
                    },
                    {
                        "username": "himanshubhoria",
                        "content": "getting TLE. 47/49 passed.\\n\\n `class Solution {\\npublic:\\n    int dx[4] = {1, -1, 0, 0};\\n    int dy[4] = {0, 0, 1, -1};\\n    bool visited[333][333]; \\n    int count = 0;\\n\\n    \\n    void bfs(vector<vector<char>> grid, int curx, int cury, int x, int y)\\n    { \\n        for(int i = 0; i < 4; i++)\\n        {\\n            int newx, newy;\\n            newx = curx + dx[i];\\n            newy = cury + dy[i];            \\n            if (newx < 0 || newx >= x || newy < 0 || newy >= y || grid[newx][newy] == \\'0\\' ) continue;\\n            if(visited[newx][newy]) continue;\\n            if(grid[newx][newy] == \\'1\\')\\n            {\\n                visited[newx][newy] = true;\\n                bfs(grid, newx, newy, x, y);   \\n            }\\n        }\\n    }\\n\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();               \\n        memset(visited, false, sizeof(visited));        \\n        int result = 0;\\n        for(int i = 0 ; i < m; i++)\\n        {\\n            for(int j = 0 ; j < n; j++)\\n            {\\n                if(!visited[i][j] && grid[i][j] == \\'1\\')\\n                {\\n                    bfs(grid, i , j, m ,n);\\n                    result++;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "NithinShetty",
                        "content": " ```#include<iostream>\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    void addTo_adjList(unordered_map<int, list<int>> &adjList, vector<vector<char>> &grid, int row, int col, int i, int j, int u){\\n        int v;\\n        adjList[u];\\n\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\'){ // left\\n            v = col*i + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(j+1 < col && grid[i][j+1] == \\'1\\'){ // right\\n            v = col*i + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\'){ // up\\n            v = col*(i-1) + j;\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && grid[i+1][j] == \\'1\\'){ // down\\n            v = col*(i+1) + j;\\n            adjList[u].push_back(v);\\n        }\\n\\n        /* for diagonals\\n\\n        if(i-1 >= 0 && j-1 >= 0 && grid[i-1][j-1] == \\'1\\'){ // left-top\\n            v = col*(i-1) + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && j+1 < col && grid[i-1][j+1] == \\'1\\'){ // right-top\\n            v = col*(i-1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j-1 >= 0 && grid[i+1][j-1] == \\'1\\'){ // left-bottom\\n            v = col*(i+1) + (j-1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j+1 < col && grid[i+1][j] == \\'1\\'){ // right-bottom\\n            v = col*(i+1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        */\\n    }\\n\\n    void dfs(int i, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adjList){\\n        visited[i] = true;\\n        for(auto nbr : adjList[i]){\\n            if(!visited[nbr]){\\n                dfs(nbr, visited, adjList);\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        unordered_map<int, list<int>> adjList;\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i=0; i<row; i++){\\n            int u;\\n            for(int j=0; j<col; j++){\\n                u = col*i + j;\\n                if(grid[i][j] == \\'1\\'){\\n                    addTo_adjList(adjList, grid, row, col, i, j, u);\\n                }\\n            }\\n        }\\n\\n        int isLands = 0;\\n        unordered_map<int, bool> visited;\\n        for(auto i : adjList){\\n            if(!visited[i.first]){\\n                isLands++;\\n                dfs(i.first, visited, adjList);\\n            }\\n        }\\n        \\n        return isLands;\\n    }\\n};```"
                    },
                    {
                        "username": "NithinShetty",
                        "content": " ```#include<iostream>\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    void addTo_adjList(unordered_map<int, list<int>> &adjList, vector<vector<char>> &grid, int row, int col, int i, int j, int u){\\n        int v;\\n        adjList[u];\\n\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\'){ // left\\n            v = col*i + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(j+1 < col && grid[i][j+1] == \\'1\\'){ // right\\n            v = col*i + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\'){ // up\\n            v = col*(i-1) + j;\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && grid[i+1][j] == \\'1\\'){ // down\\n            v = col*(i+1) + j;\\n            adjList[u].push_back(v);\\n        }\\n\\n        /* for diagonals\\n\\n        if(i-1 >= 0 && j-1 >= 0 && grid[i-1][j-1] == \\'1\\'){ // left-top\\n            v = col*(i-1) + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && j+1 < col && grid[i-1][j+1] == \\'1\\'){ // right-top\\n            v = col*(i-1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j-1 >= 0 && grid[i+1][j-1] == \\'1\\'){ // left-bottom\\n            v = col*(i+1) + (j-1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j+1 < col && grid[i+1][j] == \\'1\\'){ // right-bottom\\n            v = col*(i+1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        */\\n    }\\n\\n    void dfs(int i, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adjList){\\n        visited[i] = true;\\n        for(auto nbr : adjList[i]){\\n            if(!visited[nbr]){\\n                dfs(nbr, visited, adjList);\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        unordered_map<int, list<int>> adjList;\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i=0; i<row; i++){\\n            int u;\\n            for(int j=0; j<col; j++){\\n                u = col*i + j;\\n                if(grid[i][j] == \\'1\\'){\\n                    addTo_adjList(adjList, grid, row, col, i, j, u);\\n                }\\n            }\\n        }\\n\\n        int isLands = 0;\\n        unordered_map<int, bool> visited;\\n        for(auto i : adjList){\\n            if(!visited[i.first]){\\n                isLands++;\\n                dfs(i.first, visited, adjList);\\n            }\\n        }\\n        \\n        return isLands;\\n    }\\n};```"
                    },
                    {
                        "username": "sc1233",
                        "content": "After seeing all the solutions here, which are the most important solutions to understand when answering this question in an interview? Choosing between:\n- Iterative DFS\n- Iterative BFS\n- Recursive DFS\n- Union Find \n\nHow would you highlight the pros/cons of each approach?\n"
                    }
                ]
            },
            {
                "id": 1692768,
                "content": [
                    {
                        "username": "Om-_-sd",
                        "content": "what are the gridSize  and  *gridColSize variables here?"
                    },
                    {
                        "username": "Jayusc",
                        "content": "stupid question input to set as type \\'str\\'. If you are to use 0 and 1s, you should use type integer"
                    },
                    {
                        "username": "Atulsid151",
                        "content": "class Solution {\\n    public int numIslands(char[][] grid) {\\n         boolean visited[][] = new boolean[grid.length][grid[0].length];\\n         int count = 0;\\n         for(int i=0;i<grid.length;i++){\\n           for(int j=0;j<grid[0].length;j++){\\n                  if(!visited[i][j] && grid[i][j] == \\'1\\') {\\n                              count++;\\n                          helper(grid,visited,i,j);\\n                     \\n                  }\\n           }\\n         }\\n         return count;\\n    }\\n    public void helper(char[][] graph,boolean visited[][],int row,int col){\\n         visited[row][col] = true;\\n\\n         Queue<Pair> queue = new LinkedList<Pair>();\\n                  queue.add(new Pair(row,col));\\n         while(!queue.isEmpty()){\\n              Pair curr = queue.poll();\\n       \\n\\n              for(int i=-1;i<=1;i++){\\n                   for(int j=-1;j<=1;j++){\\n                             int r = curr.first + i;\\n                             int c = curr.second + j;\\n                         if(r>=0 && c>=0 && r<graph.length && c < graph[0].length && !visited[r][c] && graph[r][c] == \\'1\\'){\\n                               visited[r][c] = true;\\n                               queue.add(new Pair(r,c));\\n                         }\\n                   }\\n              }\\n         }\\n\\n    }\\n}\\n\\nclass Pair {\\n  int first;\\n  int second;\\n  public Pair(int first,int second){\\n     this.first = first;\\n     this.second = second;\\n  }\\n}\\ncan someone find whats the error in my code i am not able to find and test case failing"
                    },
                    {
                        "username": "yt_lt",
                        "content": "The time complexity is not O(m*n). Please run the following (Java)code, the output is not like O(m*n).\nThe solution is from https://leetcode.com/problems/number-of-islands/solutions/56338/java-dfs-and-bfs-solution\n```\npublic class NumberOfIslands {\n    int [][] visitCounts;\n    public int numIslands(char[][] grid) {\n        int count=0;\n\n        visitCounts = new int[grid.length][grid[0].length];\n\n        for(int i=0;i<grid.length;i++) {\n            for(int j=0;j<grid[0].length;j++){\n                visitCounts[i][j]++;\n                if(grid[i][j]=='1'){\n                    dfsFill(grid,i,j);\n                    count++;\n                }\n            }\n        }\n        int sum = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                System.out.print(visitCounts[i][j] + \" \");\n                sum += visitCounts[i][j];\n            }\n            System.out.println();\n        }\n        //returns the sum of visit to all coordinates in the matrix\n        return sum;\n    }\n    private void dfsFill(char[][] grid,int i, int j){\n        if (i>=0 && j>=0 && i<grid.length && j<grid[0].length) {\n            visitCounts[i][j]++;\n        }\n        if(i>=0 && j>=0 && i<grid.length && j<grid[0].length&&grid[i][j]=='1'){\n            grid[i][j]='0';\n            dfsFill(grid, i + 1, j);\n            dfsFill(grid, i - 1, j);\n            dfsFill(grid, i, j + 1);\n            dfsFill(grid, i, j - 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','0'},\n                {'1','1','0','1','0'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','0'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n    }\n} \n```\n\noutput:\n```\n4 4 3 3 2 \n4 4 4 2 2 \n3 3 2 2 1 \n2 2 1 1 1 \n50\n4 4 3 4 2 \n4 4 4 2 3 \n3 3 2 2 1 \n2 2 1 1 1 \n52\n4 4 3 4 3 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n55\n4 4 3 4 3 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n1 1 1 1 1 \n60\n4 4 4 4 3 \n4 5 4 5 4 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n1 1 1 1 1 \n83\n```"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "Why this code is not working on leetcode its working in gfg .\\nclass Pair{\\n    int first;\\n    int second;\\n\\n    public Pair(int first, int second)\\n    {\\n        this.first = first;\\n        this.second = second;\\n    }\\n}\\n\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        int vis[][] = new int[row][col];\\n        int count =0;\\n \\n            \\n        for(int i=0; i <row ; i++)\\n        {\\n            for(int j=0; j<col ; j++) {\\n                if(vis[i][j] != 1 && grid[i][j] == \\'1\\')\\n                {\\n                    bfs(i , j, grid , vis);\\n                    count++;\\n                }\\n            }\\n        }\\n       return count; \\n    }\\n\\n    private static void bfs(int row, int col ,char[][] grid, int vis[][] )\\n    {\\n      int n = grid.length;\\n      int m = grid[0].length;\\n\\n      Queue<Pair> queue = new LinkedList<>();\\n      queue.add(new Pair(row,col));\\n      vis[row][col] =1;\\n\\n      while(!queue.isEmpty())\\n      {\\n          int r = queue.peek().first;\\n          int c = queue.peek().second;\\n          queue.remove();\\n\\n          for(int delrow= -1 ; delrow <=1 ; delrow++)\\n          {\\n              for(int delcol= -1 ; delcol <=1 ; delcol++)\\n              {\\n                  int rVal = r+ delrow;\\n                  int cVal = c+ delcol;\\n\\n                  if( rVal >= 0 && cVal >= 0 && rVal <n && cVal < m && grid[rVal][cVal] == \\'1\\' && vis[rVal][cVal] != 1)\\n                  {\\n                      vis[rVal][cVal] =1;\\n                      queue.add(new Pair(rVal,cVal));\\n                  }\\n              }\\n          }\\n      }\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "nrby11",
                        "content": "I have 2 solutions that's basically doing same-things logically.  But I am getting two different runtime metrics , i.e memory used and runtime . The only difference is the variable names that I defined more verbs in the one taking longer time and memory .\n\ncan somebody explain the rational reason behind this ?"
                    },
                    {
                        "username": "himanshubhoria",
                        "content": "getting TLE. 47/49 passed.\\n\\n `class Solution {\\npublic:\\n    int dx[4] = {1, -1, 0, 0};\\n    int dy[4] = {0, 0, 1, -1};\\n    bool visited[333][333]; \\n    int count = 0;\\n\\n    \\n    void bfs(vector<vector<char>> grid, int curx, int cury, int x, int y)\\n    { \\n        for(int i = 0; i < 4; i++)\\n        {\\n            int newx, newy;\\n            newx = curx + dx[i];\\n            newy = cury + dy[i];            \\n            if (newx < 0 || newx >= x || newy < 0 || newy >= y || grid[newx][newy] == \\'0\\' ) continue;\\n            if(visited[newx][newy]) continue;\\n            if(grid[newx][newy] == \\'1\\')\\n            {\\n                visited[newx][newy] = true;\\n                bfs(grid, newx, newy, x, y);   \\n            }\\n        }\\n    }\\n\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();               \\n        memset(visited, false, sizeof(visited));        \\n        int result = 0;\\n        for(int i = 0 ; i < m; i++)\\n        {\\n            for(int j = 0 ; j < n; j++)\\n            {\\n                if(!visited[i][j] && grid[i][j] == \\'1\\')\\n                {\\n                    bfs(grid, i , j, m ,n);\\n                    result++;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "NithinShetty",
                        "content": " ```#include<iostream>\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    void addTo_adjList(unordered_map<int, list<int>> &adjList, vector<vector<char>> &grid, int row, int col, int i, int j, int u){\\n        int v;\\n        adjList[u];\\n\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\'){ // left\\n            v = col*i + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(j+1 < col && grid[i][j+1] == \\'1\\'){ // right\\n            v = col*i + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\'){ // up\\n            v = col*(i-1) + j;\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && grid[i+1][j] == \\'1\\'){ // down\\n            v = col*(i+1) + j;\\n            adjList[u].push_back(v);\\n        }\\n\\n        /* for diagonals\\n\\n        if(i-1 >= 0 && j-1 >= 0 && grid[i-1][j-1] == \\'1\\'){ // left-top\\n            v = col*(i-1) + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && j+1 < col && grid[i-1][j+1] == \\'1\\'){ // right-top\\n            v = col*(i-1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j-1 >= 0 && grid[i+1][j-1] == \\'1\\'){ // left-bottom\\n            v = col*(i+1) + (j-1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j+1 < col && grid[i+1][j] == \\'1\\'){ // right-bottom\\n            v = col*(i+1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        */\\n    }\\n\\n    void dfs(int i, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adjList){\\n        visited[i] = true;\\n        for(auto nbr : adjList[i]){\\n            if(!visited[nbr]){\\n                dfs(nbr, visited, adjList);\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        unordered_map<int, list<int>> adjList;\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i=0; i<row; i++){\\n            int u;\\n            for(int j=0; j<col; j++){\\n                u = col*i + j;\\n                if(grid[i][j] == \\'1\\'){\\n                    addTo_adjList(adjList, grid, row, col, i, j, u);\\n                }\\n            }\\n        }\\n\\n        int isLands = 0;\\n        unordered_map<int, bool> visited;\\n        for(auto i : adjList){\\n            if(!visited[i.first]){\\n                isLands++;\\n                dfs(i.first, visited, adjList);\\n            }\\n        }\\n        \\n        return isLands;\\n    }\\n};```"
                    },
                    {
                        "username": "NithinShetty",
                        "content": " ```#include<iostream>\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    void addTo_adjList(unordered_map<int, list<int>> &adjList, vector<vector<char>> &grid, int row, int col, int i, int j, int u){\\n        int v;\\n        adjList[u];\\n\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\'){ // left\\n            v = col*i + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(j+1 < col && grid[i][j+1] == \\'1\\'){ // right\\n            v = col*i + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\'){ // up\\n            v = col*(i-1) + j;\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && grid[i+1][j] == \\'1\\'){ // down\\n            v = col*(i+1) + j;\\n            adjList[u].push_back(v);\\n        }\\n\\n        /* for diagonals\\n\\n        if(i-1 >= 0 && j-1 >= 0 && grid[i-1][j-1] == \\'1\\'){ // left-top\\n            v = col*(i-1) + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && j+1 < col && grid[i-1][j+1] == \\'1\\'){ // right-top\\n            v = col*(i-1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j-1 >= 0 && grid[i+1][j-1] == \\'1\\'){ // left-bottom\\n            v = col*(i+1) + (j-1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j+1 < col && grid[i+1][j] == \\'1\\'){ // right-bottom\\n            v = col*(i+1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        */\\n    }\\n\\n    void dfs(int i, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adjList){\\n        visited[i] = true;\\n        for(auto nbr : adjList[i]){\\n            if(!visited[nbr]){\\n                dfs(nbr, visited, adjList);\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        unordered_map<int, list<int>> adjList;\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i=0; i<row; i++){\\n            int u;\\n            for(int j=0; j<col; j++){\\n                u = col*i + j;\\n                if(grid[i][j] == \\'1\\'){\\n                    addTo_adjList(adjList, grid, row, col, i, j, u);\\n                }\\n            }\\n        }\\n\\n        int isLands = 0;\\n        unordered_map<int, bool> visited;\\n        for(auto i : adjList){\\n            if(!visited[i.first]){\\n                isLands++;\\n                dfs(i.first, visited, adjList);\\n            }\\n        }\\n        \\n        return isLands;\\n    }\\n};```"
                    },
                    {
                        "username": "sc1233",
                        "content": "After seeing all the solutions here, which are the most important solutions to understand when answering this question in an interview? Choosing between:\n- Iterative DFS\n- Iterative BFS\n- Recursive DFS\n- Union Find \n\nHow would you highlight the pros/cons of each approach?\n"
                    }
                ]
            },
            {
                "id": 1689650,
                "content": [
                    {
                        "username": "Om-_-sd",
                        "content": "what are the gridSize  and  *gridColSize variables here?"
                    },
                    {
                        "username": "Jayusc",
                        "content": "stupid question input to set as type \\'str\\'. If you are to use 0 and 1s, you should use type integer"
                    },
                    {
                        "username": "Atulsid151",
                        "content": "class Solution {\\n    public int numIslands(char[][] grid) {\\n         boolean visited[][] = new boolean[grid.length][grid[0].length];\\n         int count = 0;\\n         for(int i=0;i<grid.length;i++){\\n           for(int j=0;j<grid[0].length;j++){\\n                  if(!visited[i][j] && grid[i][j] == \\'1\\') {\\n                              count++;\\n                          helper(grid,visited,i,j);\\n                     \\n                  }\\n           }\\n         }\\n         return count;\\n    }\\n    public void helper(char[][] graph,boolean visited[][],int row,int col){\\n         visited[row][col] = true;\\n\\n         Queue<Pair> queue = new LinkedList<Pair>();\\n                  queue.add(new Pair(row,col));\\n         while(!queue.isEmpty()){\\n              Pair curr = queue.poll();\\n       \\n\\n              for(int i=-1;i<=1;i++){\\n                   for(int j=-1;j<=1;j++){\\n                             int r = curr.first + i;\\n                             int c = curr.second + j;\\n                         if(r>=0 && c>=0 && r<graph.length && c < graph[0].length && !visited[r][c] && graph[r][c] == \\'1\\'){\\n                               visited[r][c] = true;\\n                               queue.add(new Pair(r,c));\\n                         }\\n                   }\\n              }\\n         }\\n\\n    }\\n}\\n\\nclass Pair {\\n  int first;\\n  int second;\\n  public Pair(int first,int second){\\n     this.first = first;\\n     this.second = second;\\n  }\\n}\\ncan someone find whats the error in my code i am not able to find and test case failing"
                    },
                    {
                        "username": "yt_lt",
                        "content": "The time complexity is not O(m*n). Please run the following (Java)code, the output is not like O(m*n).\nThe solution is from https://leetcode.com/problems/number-of-islands/solutions/56338/java-dfs-and-bfs-solution\n```\npublic class NumberOfIslands {\n    int [][] visitCounts;\n    public int numIslands(char[][] grid) {\n        int count=0;\n\n        visitCounts = new int[grid.length][grid[0].length];\n\n        for(int i=0;i<grid.length;i++) {\n            for(int j=0;j<grid[0].length;j++){\n                visitCounts[i][j]++;\n                if(grid[i][j]=='1'){\n                    dfsFill(grid,i,j);\n                    count++;\n                }\n            }\n        }\n        int sum = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                System.out.print(visitCounts[i][j] + \" \");\n                sum += visitCounts[i][j];\n            }\n            System.out.println();\n        }\n        //returns the sum of visit to all coordinates in the matrix\n        return sum;\n    }\n    private void dfsFill(char[][] grid,int i, int j){\n        if (i>=0 && j>=0 && i<grid.length && j<grid[0].length) {\n            visitCounts[i][j]++;\n        }\n        if(i>=0 && j>=0 && i<grid.length && j<grid[0].length&&grid[i][j]=='1'){\n            grid[i][j]='0';\n            dfsFill(grid, i + 1, j);\n            dfsFill(grid, i - 1, j);\n            dfsFill(grid, i, j + 1);\n            dfsFill(grid, i, j - 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','0'},\n                {'1','1','0','1','0'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','0'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n    }\n} \n```\n\noutput:\n```\n4 4 3 3 2 \n4 4 4 2 2 \n3 3 2 2 1 \n2 2 1 1 1 \n50\n4 4 3 4 2 \n4 4 4 2 3 \n3 3 2 2 1 \n2 2 1 1 1 \n52\n4 4 3 4 3 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n55\n4 4 3 4 3 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n1 1 1 1 1 \n60\n4 4 4 4 3 \n4 5 4 5 4 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n1 1 1 1 1 \n83\n```"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "Why this code is not working on leetcode its working in gfg .\\nclass Pair{\\n    int first;\\n    int second;\\n\\n    public Pair(int first, int second)\\n    {\\n        this.first = first;\\n        this.second = second;\\n    }\\n}\\n\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        int vis[][] = new int[row][col];\\n        int count =0;\\n \\n            \\n        for(int i=0; i <row ; i++)\\n        {\\n            for(int j=0; j<col ; j++) {\\n                if(vis[i][j] != 1 && grid[i][j] == \\'1\\')\\n                {\\n                    bfs(i , j, grid , vis);\\n                    count++;\\n                }\\n            }\\n        }\\n       return count; \\n    }\\n\\n    private static void bfs(int row, int col ,char[][] grid, int vis[][] )\\n    {\\n      int n = grid.length;\\n      int m = grid[0].length;\\n\\n      Queue<Pair> queue = new LinkedList<>();\\n      queue.add(new Pair(row,col));\\n      vis[row][col] =1;\\n\\n      while(!queue.isEmpty())\\n      {\\n          int r = queue.peek().first;\\n          int c = queue.peek().second;\\n          queue.remove();\\n\\n          for(int delrow= -1 ; delrow <=1 ; delrow++)\\n          {\\n              for(int delcol= -1 ; delcol <=1 ; delcol++)\\n              {\\n                  int rVal = r+ delrow;\\n                  int cVal = c+ delcol;\\n\\n                  if( rVal >= 0 && cVal >= 0 && rVal <n && cVal < m && grid[rVal][cVal] == \\'1\\' && vis[rVal][cVal] != 1)\\n                  {\\n                      vis[rVal][cVal] =1;\\n                      queue.add(new Pair(rVal,cVal));\\n                  }\\n              }\\n          }\\n      }\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "nrby11",
                        "content": "I have 2 solutions that's basically doing same-things logically.  But I am getting two different runtime metrics , i.e memory used and runtime . The only difference is the variable names that I defined more verbs in the one taking longer time and memory .\n\ncan somebody explain the rational reason behind this ?"
                    },
                    {
                        "username": "himanshubhoria",
                        "content": "getting TLE. 47/49 passed.\\n\\n `class Solution {\\npublic:\\n    int dx[4] = {1, -1, 0, 0};\\n    int dy[4] = {0, 0, 1, -1};\\n    bool visited[333][333]; \\n    int count = 0;\\n\\n    \\n    void bfs(vector<vector<char>> grid, int curx, int cury, int x, int y)\\n    { \\n        for(int i = 0; i < 4; i++)\\n        {\\n            int newx, newy;\\n            newx = curx + dx[i];\\n            newy = cury + dy[i];            \\n            if (newx < 0 || newx >= x || newy < 0 || newy >= y || grid[newx][newy] == \\'0\\' ) continue;\\n            if(visited[newx][newy]) continue;\\n            if(grid[newx][newy] == \\'1\\')\\n            {\\n                visited[newx][newy] = true;\\n                bfs(grid, newx, newy, x, y);   \\n            }\\n        }\\n    }\\n\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();               \\n        memset(visited, false, sizeof(visited));        \\n        int result = 0;\\n        for(int i = 0 ; i < m; i++)\\n        {\\n            for(int j = 0 ; j < n; j++)\\n            {\\n                if(!visited[i][j] && grid[i][j] == \\'1\\')\\n                {\\n                    bfs(grid, i , j, m ,n);\\n                    result++;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "NithinShetty",
                        "content": " ```#include<iostream>\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    void addTo_adjList(unordered_map<int, list<int>> &adjList, vector<vector<char>> &grid, int row, int col, int i, int j, int u){\\n        int v;\\n        adjList[u];\\n\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\'){ // left\\n            v = col*i + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(j+1 < col && grid[i][j+1] == \\'1\\'){ // right\\n            v = col*i + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\'){ // up\\n            v = col*(i-1) + j;\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && grid[i+1][j] == \\'1\\'){ // down\\n            v = col*(i+1) + j;\\n            adjList[u].push_back(v);\\n        }\\n\\n        /* for diagonals\\n\\n        if(i-1 >= 0 && j-1 >= 0 && grid[i-1][j-1] == \\'1\\'){ // left-top\\n            v = col*(i-1) + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && j+1 < col && grid[i-1][j+1] == \\'1\\'){ // right-top\\n            v = col*(i-1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j-1 >= 0 && grid[i+1][j-1] == \\'1\\'){ // left-bottom\\n            v = col*(i+1) + (j-1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j+1 < col && grid[i+1][j] == \\'1\\'){ // right-bottom\\n            v = col*(i+1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        */\\n    }\\n\\n    void dfs(int i, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adjList){\\n        visited[i] = true;\\n        for(auto nbr : adjList[i]){\\n            if(!visited[nbr]){\\n                dfs(nbr, visited, adjList);\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        unordered_map<int, list<int>> adjList;\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i=0; i<row; i++){\\n            int u;\\n            for(int j=0; j<col; j++){\\n                u = col*i + j;\\n                if(grid[i][j] == \\'1\\'){\\n                    addTo_adjList(adjList, grid, row, col, i, j, u);\\n                }\\n            }\\n        }\\n\\n        int isLands = 0;\\n        unordered_map<int, bool> visited;\\n        for(auto i : adjList){\\n            if(!visited[i.first]){\\n                isLands++;\\n                dfs(i.first, visited, adjList);\\n            }\\n        }\\n        \\n        return isLands;\\n    }\\n};```"
                    },
                    {
                        "username": "NithinShetty",
                        "content": " ```#include<iostream>\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    void addTo_adjList(unordered_map<int, list<int>> &adjList, vector<vector<char>> &grid, int row, int col, int i, int j, int u){\\n        int v;\\n        adjList[u];\\n\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\'){ // left\\n            v = col*i + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(j+1 < col && grid[i][j+1] == \\'1\\'){ // right\\n            v = col*i + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\'){ // up\\n            v = col*(i-1) + j;\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && grid[i+1][j] == \\'1\\'){ // down\\n            v = col*(i+1) + j;\\n            adjList[u].push_back(v);\\n        }\\n\\n        /* for diagonals\\n\\n        if(i-1 >= 0 && j-1 >= 0 && grid[i-1][j-1] == \\'1\\'){ // left-top\\n            v = col*(i-1) + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && j+1 < col && grid[i-1][j+1] == \\'1\\'){ // right-top\\n            v = col*(i-1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j-1 >= 0 && grid[i+1][j-1] == \\'1\\'){ // left-bottom\\n            v = col*(i+1) + (j-1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j+1 < col && grid[i+1][j] == \\'1\\'){ // right-bottom\\n            v = col*(i+1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        */\\n    }\\n\\n    void dfs(int i, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adjList){\\n        visited[i] = true;\\n        for(auto nbr : adjList[i]){\\n            if(!visited[nbr]){\\n                dfs(nbr, visited, adjList);\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        unordered_map<int, list<int>> adjList;\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i=0; i<row; i++){\\n            int u;\\n            for(int j=0; j<col; j++){\\n                u = col*i + j;\\n                if(grid[i][j] == \\'1\\'){\\n                    addTo_adjList(adjList, grid, row, col, i, j, u);\\n                }\\n            }\\n        }\\n\\n        int isLands = 0;\\n        unordered_map<int, bool> visited;\\n        for(auto i : adjList){\\n            if(!visited[i.first]){\\n                isLands++;\\n                dfs(i.first, visited, adjList);\\n            }\\n        }\\n        \\n        return isLands;\\n    }\\n};```"
                    },
                    {
                        "username": "sc1233",
                        "content": "After seeing all the solutions here, which are the most important solutions to understand when answering this question in an interview? Choosing between:\n- Iterative DFS\n- Iterative BFS\n- Recursive DFS\n- Union Find \n\nHow would you highlight the pros/cons of each approach?\n"
                    }
                ]
            },
            {
                "id": 1687173,
                "content": [
                    {
                        "username": "Om-_-sd",
                        "content": "what are the gridSize  and  *gridColSize variables here?"
                    },
                    {
                        "username": "Jayusc",
                        "content": "stupid question input to set as type \\'str\\'. If you are to use 0 and 1s, you should use type integer"
                    },
                    {
                        "username": "Atulsid151",
                        "content": "class Solution {\\n    public int numIslands(char[][] grid) {\\n         boolean visited[][] = new boolean[grid.length][grid[0].length];\\n         int count = 0;\\n         for(int i=0;i<grid.length;i++){\\n           for(int j=0;j<grid[0].length;j++){\\n                  if(!visited[i][j] && grid[i][j] == \\'1\\') {\\n                              count++;\\n                          helper(grid,visited,i,j);\\n                     \\n                  }\\n           }\\n         }\\n         return count;\\n    }\\n    public void helper(char[][] graph,boolean visited[][],int row,int col){\\n         visited[row][col] = true;\\n\\n         Queue<Pair> queue = new LinkedList<Pair>();\\n                  queue.add(new Pair(row,col));\\n         while(!queue.isEmpty()){\\n              Pair curr = queue.poll();\\n       \\n\\n              for(int i=-1;i<=1;i++){\\n                   for(int j=-1;j<=1;j++){\\n                             int r = curr.first + i;\\n                             int c = curr.second + j;\\n                         if(r>=0 && c>=0 && r<graph.length && c < graph[0].length && !visited[r][c] && graph[r][c] == \\'1\\'){\\n                               visited[r][c] = true;\\n                               queue.add(new Pair(r,c));\\n                         }\\n                   }\\n              }\\n         }\\n\\n    }\\n}\\n\\nclass Pair {\\n  int first;\\n  int second;\\n  public Pair(int first,int second){\\n     this.first = first;\\n     this.second = second;\\n  }\\n}\\ncan someone find whats the error in my code i am not able to find and test case failing"
                    },
                    {
                        "username": "yt_lt",
                        "content": "The time complexity is not O(m*n). Please run the following (Java)code, the output is not like O(m*n).\nThe solution is from https://leetcode.com/problems/number-of-islands/solutions/56338/java-dfs-and-bfs-solution\n```\npublic class NumberOfIslands {\n    int [][] visitCounts;\n    public int numIslands(char[][] grid) {\n        int count=0;\n\n        visitCounts = new int[grid.length][grid[0].length];\n\n        for(int i=0;i<grid.length;i++) {\n            for(int j=0;j<grid[0].length;j++){\n                visitCounts[i][j]++;\n                if(grid[i][j]=='1'){\n                    dfsFill(grid,i,j);\n                    count++;\n                }\n            }\n        }\n        int sum = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                System.out.print(visitCounts[i][j] + \" \");\n                sum += visitCounts[i][j];\n            }\n            System.out.println();\n        }\n        //returns the sum of visit to all coordinates in the matrix\n        return sum;\n    }\n    private void dfsFill(char[][] grid,int i, int j){\n        if (i>=0 && j>=0 && i<grid.length && j<grid[0].length) {\n            visitCounts[i][j]++;\n        }\n        if(i>=0 && j>=0 && i<grid.length && j<grid[0].length&&grid[i][j]=='1'){\n            grid[i][j]='0';\n            dfsFill(grid, i + 1, j);\n            dfsFill(grid, i - 1, j);\n            dfsFill(grid, i, j + 1);\n            dfsFill(grid, i, j - 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','0'},\n                {'1','1','0','1','0'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','0'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n    }\n} \n```\n\noutput:\n```\n4 4 3 3 2 \n4 4 4 2 2 \n3 3 2 2 1 \n2 2 1 1 1 \n50\n4 4 3 4 2 \n4 4 4 2 3 \n3 3 2 2 1 \n2 2 1 1 1 \n52\n4 4 3 4 3 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n55\n4 4 3 4 3 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n1 1 1 1 1 \n60\n4 4 4 4 3 \n4 5 4 5 4 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n1 1 1 1 1 \n83\n```"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "Why this code is not working on leetcode its working in gfg .\\nclass Pair{\\n    int first;\\n    int second;\\n\\n    public Pair(int first, int second)\\n    {\\n        this.first = first;\\n        this.second = second;\\n    }\\n}\\n\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        int vis[][] = new int[row][col];\\n        int count =0;\\n \\n            \\n        for(int i=0; i <row ; i++)\\n        {\\n            for(int j=0; j<col ; j++) {\\n                if(vis[i][j] != 1 && grid[i][j] == \\'1\\')\\n                {\\n                    bfs(i , j, grid , vis);\\n                    count++;\\n                }\\n            }\\n        }\\n       return count; \\n    }\\n\\n    private static void bfs(int row, int col ,char[][] grid, int vis[][] )\\n    {\\n      int n = grid.length;\\n      int m = grid[0].length;\\n\\n      Queue<Pair> queue = new LinkedList<>();\\n      queue.add(new Pair(row,col));\\n      vis[row][col] =1;\\n\\n      while(!queue.isEmpty())\\n      {\\n          int r = queue.peek().first;\\n          int c = queue.peek().second;\\n          queue.remove();\\n\\n          for(int delrow= -1 ; delrow <=1 ; delrow++)\\n          {\\n              for(int delcol= -1 ; delcol <=1 ; delcol++)\\n              {\\n                  int rVal = r+ delrow;\\n                  int cVal = c+ delcol;\\n\\n                  if( rVal >= 0 && cVal >= 0 && rVal <n && cVal < m && grid[rVal][cVal] == \\'1\\' && vis[rVal][cVal] != 1)\\n                  {\\n                      vis[rVal][cVal] =1;\\n                      queue.add(new Pair(rVal,cVal));\\n                  }\\n              }\\n          }\\n      }\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "nrby11",
                        "content": "I have 2 solutions that's basically doing same-things logically.  But I am getting two different runtime metrics , i.e memory used and runtime . The only difference is the variable names that I defined more verbs in the one taking longer time and memory .\n\ncan somebody explain the rational reason behind this ?"
                    },
                    {
                        "username": "himanshubhoria",
                        "content": "getting TLE. 47/49 passed.\\n\\n `class Solution {\\npublic:\\n    int dx[4] = {1, -1, 0, 0};\\n    int dy[4] = {0, 0, 1, -1};\\n    bool visited[333][333]; \\n    int count = 0;\\n\\n    \\n    void bfs(vector<vector<char>> grid, int curx, int cury, int x, int y)\\n    { \\n        for(int i = 0; i < 4; i++)\\n        {\\n            int newx, newy;\\n            newx = curx + dx[i];\\n            newy = cury + dy[i];            \\n            if (newx < 0 || newx >= x || newy < 0 || newy >= y || grid[newx][newy] == \\'0\\' ) continue;\\n            if(visited[newx][newy]) continue;\\n            if(grid[newx][newy] == \\'1\\')\\n            {\\n                visited[newx][newy] = true;\\n                bfs(grid, newx, newy, x, y);   \\n            }\\n        }\\n    }\\n\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();               \\n        memset(visited, false, sizeof(visited));        \\n        int result = 0;\\n        for(int i = 0 ; i < m; i++)\\n        {\\n            for(int j = 0 ; j < n; j++)\\n            {\\n                if(!visited[i][j] && grid[i][j] == \\'1\\')\\n                {\\n                    bfs(grid, i , j, m ,n);\\n                    result++;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "NithinShetty",
                        "content": " ```#include<iostream>\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    void addTo_adjList(unordered_map<int, list<int>> &adjList, vector<vector<char>> &grid, int row, int col, int i, int j, int u){\\n        int v;\\n        adjList[u];\\n\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\'){ // left\\n            v = col*i + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(j+1 < col && grid[i][j+1] == \\'1\\'){ // right\\n            v = col*i + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\'){ // up\\n            v = col*(i-1) + j;\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && grid[i+1][j] == \\'1\\'){ // down\\n            v = col*(i+1) + j;\\n            adjList[u].push_back(v);\\n        }\\n\\n        /* for diagonals\\n\\n        if(i-1 >= 0 && j-1 >= 0 && grid[i-1][j-1] == \\'1\\'){ // left-top\\n            v = col*(i-1) + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && j+1 < col && grid[i-1][j+1] == \\'1\\'){ // right-top\\n            v = col*(i-1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j-1 >= 0 && grid[i+1][j-1] == \\'1\\'){ // left-bottom\\n            v = col*(i+1) + (j-1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j+1 < col && grid[i+1][j] == \\'1\\'){ // right-bottom\\n            v = col*(i+1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        */\\n    }\\n\\n    void dfs(int i, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adjList){\\n        visited[i] = true;\\n        for(auto nbr : adjList[i]){\\n            if(!visited[nbr]){\\n                dfs(nbr, visited, adjList);\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        unordered_map<int, list<int>> adjList;\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i=0; i<row; i++){\\n            int u;\\n            for(int j=0; j<col; j++){\\n                u = col*i + j;\\n                if(grid[i][j] == \\'1\\'){\\n                    addTo_adjList(adjList, grid, row, col, i, j, u);\\n                }\\n            }\\n        }\\n\\n        int isLands = 0;\\n        unordered_map<int, bool> visited;\\n        for(auto i : adjList){\\n            if(!visited[i.first]){\\n                isLands++;\\n                dfs(i.first, visited, adjList);\\n            }\\n        }\\n        \\n        return isLands;\\n    }\\n};```"
                    },
                    {
                        "username": "NithinShetty",
                        "content": " ```#include<iostream>\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    void addTo_adjList(unordered_map<int, list<int>> &adjList, vector<vector<char>> &grid, int row, int col, int i, int j, int u){\\n        int v;\\n        adjList[u];\\n\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\'){ // left\\n            v = col*i + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(j+1 < col && grid[i][j+1] == \\'1\\'){ // right\\n            v = col*i + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\'){ // up\\n            v = col*(i-1) + j;\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && grid[i+1][j] == \\'1\\'){ // down\\n            v = col*(i+1) + j;\\n            adjList[u].push_back(v);\\n        }\\n\\n        /* for diagonals\\n\\n        if(i-1 >= 0 && j-1 >= 0 && grid[i-1][j-1] == \\'1\\'){ // left-top\\n            v = col*(i-1) + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && j+1 < col && grid[i-1][j+1] == \\'1\\'){ // right-top\\n            v = col*(i-1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j-1 >= 0 && grid[i+1][j-1] == \\'1\\'){ // left-bottom\\n            v = col*(i+1) + (j-1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j+1 < col && grid[i+1][j] == \\'1\\'){ // right-bottom\\n            v = col*(i+1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        */\\n    }\\n\\n    void dfs(int i, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adjList){\\n        visited[i] = true;\\n        for(auto nbr : adjList[i]){\\n            if(!visited[nbr]){\\n                dfs(nbr, visited, adjList);\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        unordered_map<int, list<int>> adjList;\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i=0; i<row; i++){\\n            int u;\\n            for(int j=0; j<col; j++){\\n                u = col*i + j;\\n                if(grid[i][j] == \\'1\\'){\\n                    addTo_adjList(adjList, grid, row, col, i, j, u);\\n                }\\n            }\\n        }\\n\\n        int isLands = 0;\\n        unordered_map<int, bool> visited;\\n        for(auto i : adjList){\\n            if(!visited[i.first]){\\n                isLands++;\\n                dfs(i.first, visited, adjList);\\n            }\\n        }\\n        \\n        return isLands;\\n    }\\n};```"
                    },
                    {
                        "username": "sc1233",
                        "content": "After seeing all the solutions here, which are the most important solutions to understand when answering this question in an interview? Choosing between:\n- Iterative DFS\n- Iterative BFS\n- Recursive DFS\n- Union Find \n\nHow would you highlight the pros/cons of each approach?\n"
                    }
                ]
            },
            {
                "id": 1685491,
                "content": [
                    {
                        "username": "Om-_-sd",
                        "content": "what are the gridSize  and  *gridColSize variables here?"
                    },
                    {
                        "username": "Jayusc",
                        "content": "stupid question input to set as type \\'str\\'. If you are to use 0 and 1s, you should use type integer"
                    },
                    {
                        "username": "Atulsid151",
                        "content": "class Solution {\\n    public int numIslands(char[][] grid) {\\n         boolean visited[][] = new boolean[grid.length][grid[0].length];\\n         int count = 0;\\n         for(int i=0;i<grid.length;i++){\\n           for(int j=0;j<grid[0].length;j++){\\n                  if(!visited[i][j] && grid[i][j] == \\'1\\') {\\n                              count++;\\n                          helper(grid,visited,i,j);\\n                     \\n                  }\\n           }\\n         }\\n         return count;\\n    }\\n    public void helper(char[][] graph,boolean visited[][],int row,int col){\\n         visited[row][col] = true;\\n\\n         Queue<Pair> queue = new LinkedList<Pair>();\\n                  queue.add(new Pair(row,col));\\n         while(!queue.isEmpty()){\\n              Pair curr = queue.poll();\\n       \\n\\n              for(int i=-1;i<=1;i++){\\n                   for(int j=-1;j<=1;j++){\\n                             int r = curr.first + i;\\n                             int c = curr.second + j;\\n                         if(r>=0 && c>=0 && r<graph.length && c < graph[0].length && !visited[r][c] && graph[r][c] == \\'1\\'){\\n                               visited[r][c] = true;\\n                               queue.add(new Pair(r,c));\\n                         }\\n                   }\\n              }\\n         }\\n\\n    }\\n}\\n\\nclass Pair {\\n  int first;\\n  int second;\\n  public Pair(int first,int second){\\n     this.first = first;\\n     this.second = second;\\n  }\\n}\\ncan someone find whats the error in my code i am not able to find and test case failing"
                    },
                    {
                        "username": "yt_lt",
                        "content": "The time complexity is not O(m*n). Please run the following (Java)code, the output is not like O(m*n).\nThe solution is from https://leetcode.com/problems/number-of-islands/solutions/56338/java-dfs-and-bfs-solution\n```\npublic class NumberOfIslands {\n    int [][] visitCounts;\n    public int numIslands(char[][] grid) {\n        int count=0;\n\n        visitCounts = new int[grid.length][grid[0].length];\n\n        for(int i=0;i<grid.length;i++) {\n            for(int j=0;j<grid[0].length;j++){\n                visitCounts[i][j]++;\n                if(grid[i][j]=='1'){\n                    dfsFill(grid,i,j);\n                    count++;\n                }\n            }\n        }\n        int sum = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                System.out.print(visitCounts[i][j] + \" \");\n                sum += visitCounts[i][j];\n            }\n            System.out.println();\n        }\n        //returns the sum of visit to all coordinates in the matrix\n        return sum;\n    }\n    private void dfsFill(char[][] grid,int i, int j){\n        if (i>=0 && j>=0 && i<grid.length && j<grid[0].length) {\n            visitCounts[i][j]++;\n        }\n        if(i>=0 && j>=0 && i<grid.length && j<grid[0].length&&grid[i][j]=='1'){\n            grid[i][j]='0';\n            dfsFill(grid, i + 1, j);\n            dfsFill(grid, i - 1, j);\n            dfsFill(grid, i, j + 1);\n            dfsFill(grid, i, j - 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','0'},\n                {'1','1','0','1','0'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','0'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n    }\n} \n```\n\noutput:\n```\n4 4 3 3 2 \n4 4 4 2 2 \n3 3 2 2 1 \n2 2 1 1 1 \n50\n4 4 3 4 2 \n4 4 4 2 3 \n3 3 2 2 1 \n2 2 1 1 1 \n52\n4 4 3 4 3 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n55\n4 4 3 4 3 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n1 1 1 1 1 \n60\n4 4 4 4 3 \n4 5 4 5 4 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n1 1 1 1 1 \n83\n```"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "Why this code is not working on leetcode its working in gfg .\\nclass Pair{\\n    int first;\\n    int second;\\n\\n    public Pair(int first, int second)\\n    {\\n        this.first = first;\\n        this.second = second;\\n    }\\n}\\n\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        int vis[][] = new int[row][col];\\n        int count =0;\\n \\n            \\n        for(int i=0; i <row ; i++)\\n        {\\n            for(int j=0; j<col ; j++) {\\n                if(vis[i][j] != 1 && grid[i][j] == \\'1\\')\\n                {\\n                    bfs(i , j, grid , vis);\\n                    count++;\\n                }\\n            }\\n        }\\n       return count; \\n    }\\n\\n    private static void bfs(int row, int col ,char[][] grid, int vis[][] )\\n    {\\n      int n = grid.length;\\n      int m = grid[0].length;\\n\\n      Queue<Pair> queue = new LinkedList<>();\\n      queue.add(new Pair(row,col));\\n      vis[row][col] =1;\\n\\n      while(!queue.isEmpty())\\n      {\\n          int r = queue.peek().first;\\n          int c = queue.peek().second;\\n          queue.remove();\\n\\n          for(int delrow= -1 ; delrow <=1 ; delrow++)\\n          {\\n              for(int delcol= -1 ; delcol <=1 ; delcol++)\\n              {\\n                  int rVal = r+ delrow;\\n                  int cVal = c+ delcol;\\n\\n                  if( rVal >= 0 && cVal >= 0 && rVal <n && cVal < m && grid[rVal][cVal] == \\'1\\' && vis[rVal][cVal] != 1)\\n                  {\\n                      vis[rVal][cVal] =1;\\n                      queue.add(new Pair(rVal,cVal));\\n                  }\\n              }\\n          }\\n      }\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "nrby11",
                        "content": "I have 2 solutions that's basically doing same-things logically.  But I am getting two different runtime metrics , i.e memory used and runtime . The only difference is the variable names that I defined more verbs in the one taking longer time and memory .\n\ncan somebody explain the rational reason behind this ?"
                    },
                    {
                        "username": "himanshubhoria",
                        "content": "getting TLE. 47/49 passed.\\n\\n `class Solution {\\npublic:\\n    int dx[4] = {1, -1, 0, 0};\\n    int dy[4] = {0, 0, 1, -1};\\n    bool visited[333][333]; \\n    int count = 0;\\n\\n    \\n    void bfs(vector<vector<char>> grid, int curx, int cury, int x, int y)\\n    { \\n        for(int i = 0; i < 4; i++)\\n        {\\n            int newx, newy;\\n            newx = curx + dx[i];\\n            newy = cury + dy[i];            \\n            if (newx < 0 || newx >= x || newy < 0 || newy >= y || grid[newx][newy] == \\'0\\' ) continue;\\n            if(visited[newx][newy]) continue;\\n            if(grid[newx][newy] == \\'1\\')\\n            {\\n                visited[newx][newy] = true;\\n                bfs(grid, newx, newy, x, y);   \\n            }\\n        }\\n    }\\n\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();               \\n        memset(visited, false, sizeof(visited));        \\n        int result = 0;\\n        for(int i = 0 ; i < m; i++)\\n        {\\n            for(int j = 0 ; j < n; j++)\\n            {\\n                if(!visited[i][j] && grid[i][j] == \\'1\\')\\n                {\\n                    bfs(grid, i , j, m ,n);\\n                    result++;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "NithinShetty",
                        "content": " ```#include<iostream>\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    void addTo_adjList(unordered_map<int, list<int>> &adjList, vector<vector<char>> &grid, int row, int col, int i, int j, int u){\\n        int v;\\n        adjList[u];\\n\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\'){ // left\\n            v = col*i + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(j+1 < col && grid[i][j+1] == \\'1\\'){ // right\\n            v = col*i + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\'){ // up\\n            v = col*(i-1) + j;\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && grid[i+1][j] == \\'1\\'){ // down\\n            v = col*(i+1) + j;\\n            adjList[u].push_back(v);\\n        }\\n\\n        /* for diagonals\\n\\n        if(i-1 >= 0 && j-1 >= 0 && grid[i-1][j-1] == \\'1\\'){ // left-top\\n            v = col*(i-1) + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && j+1 < col && grid[i-1][j+1] == \\'1\\'){ // right-top\\n            v = col*(i-1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j-1 >= 0 && grid[i+1][j-1] == \\'1\\'){ // left-bottom\\n            v = col*(i+1) + (j-1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j+1 < col && grid[i+1][j] == \\'1\\'){ // right-bottom\\n            v = col*(i+1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        */\\n    }\\n\\n    void dfs(int i, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adjList){\\n        visited[i] = true;\\n        for(auto nbr : adjList[i]){\\n            if(!visited[nbr]){\\n                dfs(nbr, visited, adjList);\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        unordered_map<int, list<int>> adjList;\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i=0; i<row; i++){\\n            int u;\\n            for(int j=0; j<col; j++){\\n                u = col*i + j;\\n                if(grid[i][j] == \\'1\\'){\\n                    addTo_adjList(adjList, grid, row, col, i, j, u);\\n                }\\n            }\\n        }\\n\\n        int isLands = 0;\\n        unordered_map<int, bool> visited;\\n        for(auto i : adjList){\\n            if(!visited[i.first]){\\n                isLands++;\\n                dfs(i.first, visited, adjList);\\n            }\\n        }\\n        \\n        return isLands;\\n    }\\n};```"
                    },
                    {
                        "username": "NithinShetty",
                        "content": " ```#include<iostream>\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    void addTo_adjList(unordered_map<int, list<int>> &adjList, vector<vector<char>> &grid, int row, int col, int i, int j, int u){\\n        int v;\\n        adjList[u];\\n\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\'){ // left\\n            v = col*i + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(j+1 < col && grid[i][j+1] == \\'1\\'){ // right\\n            v = col*i + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\'){ // up\\n            v = col*(i-1) + j;\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && grid[i+1][j] == \\'1\\'){ // down\\n            v = col*(i+1) + j;\\n            adjList[u].push_back(v);\\n        }\\n\\n        /* for diagonals\\n\\n        if(i-1 >= 0 && j-1 >= 0 && grid[i-1][j-1] == \\'1\\'){ // left-top\\n            v = col*(i-1) + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && j+1 < col && grid[i-1][j+1] == \\'1\\'){ // right-top\\n            v = col*(i-1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j-1 >= 0 && grid[i+1][j-1] == \\'1\\'){ // left-bottom\\n            v = col*(i+1) + (j-1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j+1 < col && grid[i+1][j] == \\'1\\'){ // right-bottom\\n            v = col*(i+1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        */\\n    }\\n\\n    void dfs(int i, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adjList){\\n        visited[i] = true;\\n        for(auto nbr : adjList[i]){\\n            if(!visited[nbr]){\\n                dfs(nbr, visited, adjList);\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        unordered_map<int, list<int>> adjList;\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i=0; i<row; i++){\\n            int u;\\n            for(int j=0; j<col; j++){\\n                u = col*i + j;\\n                if(grid[i][j] == \\'1\\'){\\n                    addTo_adjList(adjList, grid, row, col, i, j, u);\\n                }\\n            }\\n        }\\n\\n        int isLands = 0;\\n        unordered_map<int, bool> visited;\\n        for(auto i : adjList){\\n            if(!visited[i.first]){\\n                isLands++;\\n                dfs(i.first, visited, adjList);\\n            }\\n        }\\n        \\n        return isLands;\\n    }\\n};```"
                    },
                    {
                        "username": "sc1233",
                        "content": "After seeing all the solutions here, which are the most important solutions to understand when answering this question in an interview? Choosing between:\n- Iterative DFS\n- Iterative BFS\n- Recursive DFS\n- Union Find \n\nHow would you highlight the pros/cons of each approach?\n"
                    }
                ]
            },
            {
                "id": 1673937,
                "content": [
                    {
                        "username": "Om-_-sd",
                        "content": "what are the gridSize  and  *gridColSize variables here?"
                    },
                    {
                        "username": "Jayusc",
                        "content": "stupid question input to set as type \\'str\\'. If you are to use 0 and 1s, you should use type integer"
                    },
                    {
                        "username": "Atulsid151",
                        "content": "class Solution {\\n    public int numIslands(char[][] grid) {\\n         boolean visited[][] = new boolean[grid.length][grid[0].length];\\n         int count = 0;\\n         for(int i=0;i<grid.length;i++){\\n           for(int j=0;j<grid[0].length;j++){\\n                  if(!visited[i][j] && grid[i][j] == \\'1\\') {\\n                              count++;\\n                          helper(grid,visited,i,j);\\n                     \\n                  }\\n           }\\n         }\\n         return count;\\n    }\\n    public void helper(char[][] graph,boolean visited[][],int row,int col){\\n         visited[row][col] = true;\\n\\n         Queue<Pair> queue = new LinkedList<Pair>();\\n                  queue.add(new Pair(row,col));\\n         while(!queue.isEmpty()){\\n              Pair curr = queue.poll();\\n       \\n\\n              for(int i=-1;i<=1;i++){\\n                   for(int j=-1;j<=1;j++){\\n                             int r = curr.first + i;\\n                             int c = curr.second + j;\\n                         if(r>=0 && c>=0 && r<graph.length && c < graph[0].length && !visited[r][c] && graph[r][c] == \\'1\\'){\\n                               visited[r][c] = true;\\n                               queue.add(new Pair(r,c));\\n                         }\\n                   }\\n              }\\n         }\\n\\n    }\\n}\\n\\nclass Pair {\\n  int first;\\n  int second;\\n  public Pair(int first,int second){\\n     this.first = first;\\n     this.second = second;\\n  }\\n}\\ncan someone find whats the error in my code i am not able to find and test case failing"
                    },
                    {
                        "username": "yt_lt",
                        "content": "The time complexity is not O(m*n). Please run the following (Java)code, the output is not like O(m*n).\nThe solution is from https://leetcode.com/problems/number-of-islands/solutions/56338/java-dfs-and-bfs-solution\n```\npublic class NumberOfIslands {\n    int [][] visitCounts;\n    public int numIslands(char[][] grid) {\n        int count=0;\n\n        visitCounts = new int[grid.length][grid[0].length];\n\n        for(int i=0;i<grid.length;i++) {\n            for(int j=0;j<grid[0].length;j++){\n                visitCounts[i][j]++;\n                if(grid[i][j]=='1'){\n                    dfsFill(grid,i,j);\n                    count++;\n                }\n            }\n        }\n        int sum = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                System.out.print(visitCounts[i][j] + \" \");\n                sum += visitCounts[i][j];\n            }\n            System.out.println();\n        }\n        //returns the sum of visit to all coordinates in the matrix\n        return sum;\n    }\n    private void dfsFill(char[][] grid,int i, int j){\n        if (i>=0 && j>=0 && i<grid.length && j<grid[0].length) {\n            visitCounts[i][j]++;\n        }\n        if(i>=0 && j>=0 && i<grid.length && j<grid[0].length&&grid[i][j]=='1'){\n            grid[i][j]='0';\n            dfsFill(grid, i + 1, j);\n            dfsFill(grid, i - 1, j);\n            dfsFill(grid, i, j + 1);\n            dfsFill(grid, i, j - 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','0'},\n                {'1','1','0','1','0'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','0'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n    }\n} \n```\n\noutput:\n```\n4 4 3 3 2 \n4 4 4 2 2 \n3 3 2 2 1 \n2 2 1 1 1 \n50\n4 4 3 4 2 \n4 4 4 2 3 \n3 3 2 2 1 \n2 2 1 1 1 \n52\n4 4 3 4 3 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n55\n4 4 3 4 3 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n1 1 1 1 1 \n60\n4 4 4 4 3 \n4 5 4 5 4 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n1 1 1 1 1 \n83\n```"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "Why this code is not working on leetcode its working in gfg .\\nclass Pair{\\n    int first;\\n    int second;\\n\\n    public Pair(int first, int second)\\n    {\\n        this.first = first;\\n        this.second = second;\\n    }\\n}\\n\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        int vis[][] = new int[row][col];\\n        int count =0;\\n \\n            \\n        for(int i=0; i <row ; i++)\\n        {\\n            for(int j=0; j<col ; j++) {\\n                if(vis[i][j] != 1 && grid[i][j] == \\'1\\')\\n                {\\n                    bfs(i , j, grid , vis);\\n                    count++;\\n                }\\n            }\\n        }\\n       return count; \\n    }\\n\\n    private static void bfs(int row, int col ,char[][] grid, int vis[][] )\\n    {\\n      int n = grid.length;\\n      int m = grid[0].length;\\n\\n      Queue<Pair> queue = new LinkedList<>();\\n      queue.add(new Pair(row,col));\\n      vis[row][col] =1;\\n\\n      while(!queue.isEmpty())\\n      {\\n          int r = queue.peek().first;\\n          int c = queue.peek().second;\\n          queue.remove();\\n\\n          for(int delrow= -1 ; delrow <=1 ; delrow++)\\n          {\\n              for(int delcol= -1 ; delcol <=1 ; delcol++)\\n              {\\n                  int rVal = r+ delrow;\\n                  int cVal = c+ delcol;\\n\\n                  if( rVal >= 0 && cVal >= 0 && rVal <n && cVal < m && grid[rVal][cVal] == \\'1\\' && vis[rVal][cVal] != 1)\\n                  {\\n                      vis[rVal][cVal] =1;\\n                      queue.add(new Pair(rVal,cVal));\\n                  }\\n              }\\n          }\\n      }\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "nrby11",
                        "content": "I have 2 solutions that's basically doing same-things logically.  But I am getting two different runtime metrics , i.e memory used and runtime . The only difference is the variable names that I defined more verbs in the one taking longer time and memory .\n\ncan somebody explain the rational reason behind this ?"
                    },
                    {
                        "username": "himanshubhoria",
                        "content": "getting TLE. 47/49 passed.\\n\\n `class Solution {\\npublic:\\n    int dx[4] = {1, -1, 0, 0};\\n    int dy[4] = {0, 0, 1, -1};\\n    bool visited[333][333]; \\n    int count = 0;\\n\\n    \\n    void bfs(vector<vector<char>> grid, int curx, int cury, int x, int y)\\n    { \\n        for(int i = 0; i < 4; i++)\\n        {\\n            int newx, newy;\\n            newx = curx + dx[i];\\n            newy = cury + dy[i];            \\n            if (newx < 0 || newx >= x || newy < 0 || newy >= y || grid[newx][newy] == \\'0\\' ) continue;\\n            if(visited[newx][newy]) continue;\\n            if(grid[newx][newy] == \\'1\\')\\n            {\\n                visited[newx][newy] = true;\\n                bfs(grid, newx, newy, x, y);   \\n            }\\n        }\\n    }\\n\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();               \\n        memset(visited, false, sizeof(visited));        \\n        int result = 0;\\n        for(int i = 0 ; i < m; i++)\\n        {\\n            for(int j = 0 ; j < n; j++)\\n            {\\n                if(!visited[i][j] && grid[i][j] == \\'1\\')\\n                {\\n                    bfs(grid, i , j, m ,n);\\n                    result++;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "NithinShetty",
                        "content": " ```#include<iostream>\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    void addTo_adjList(unordered_map<int, list<int>> &adjList, vector<vector<char>> &grid, int row, int col, int i, int j, int u){\\n        int v;\\n        adjList[u];\\n\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\'){ // left\\n            v = col*i + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(j+1 < col && grid[i][j+1] == \\'1\\'){ // right\\n            v = col*i + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\'){ // up\\n            v = col*(i-1) + j;\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && grid[i+1][j] == \\'1\\'){ // down\\n            v = col*(i+1) + j;\\n            adjList[u].push_back(v);\\n        }\\n\\n        /* for diagonals\\n\\n        if(i-1 >= 0 && j-1 >= 0 && grid[i-1][j-1] == \\'1\\'){ // left-top\\n            v = col*(i-1) + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && j+1 < col && grid[i-1][j+1] == \\'1\\'){ // right-top\\n            v = col*(i-1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j-1 >= 0 && grid[i+1][j-1] == \\'1\\'){ // left-bottom\\n            v = col*(i+1) + (j-1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j+1 < col && grid[i+1][j] == \\'1\\'){ // right-bottom\\n            v = col*(i+1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        */\\n    }\\n\\n    void dfs(int i, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adjList){\\n        visited[i] = true;\\n        for(auto nbr : adjList[i]){\\n            if(!visited[nbr]){\\n                dfs(nbr, visited, adjList);\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        unordered_map<int, list<int>> adjList;\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i=0; i<row; i++){\\n            int u;\\n            for(int j=0; j<col; j++){\\n                u = col*i + j;\\n                if(grid[i][j] == \\'1\\'){\\n                    addTo_adjList(adjList, grid, row, col, i, j, u);\\n                }\\n            }\\n        }\\n\\n        int isLands = 0;\\n        unordered_map<int, bool> visited;\\n        for(auto i : adjList){\\n            if(!visited[i.first]){\\n                isLands++;\\n                dfs(i.first, visited, adjList);\\n            }\\n        }\\n        \\n        return isLands;\\n    }\\n};```"
                    },
                    {
                        "username": "NithinShetty",
                        "content": " ```#include<iostream>\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    void addTo_adjList(unordered_map<int, list<int>> &adjList, vector<vector<char>> &grid, int row, int col, int i, int j, int u){\\n        int v;\\n        adjList[u];\\n\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\'){ // left\\n            v = col*i + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(j+1 < col && grid[i][j+1] == \\'1\\'){ // right\\n            v = col*i + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\'){ // up\\n            v = col*(i-1) + j;\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && grid[i+1][j] == \\'1\\'){ // down\\n            v = col*(i+1) + j;\\n            adjList[u].push_back(v);\\n        }\\n\\n        /* for diagonals\\n\\n        if(i-1 >= 0 && j-1 >= 0 && grid[i-1][j-1] == \\'1\\'){ // left-top\\n            v = col*(i-1) + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && j+1 < col && grid[i-1][j+1] == \\'1\\'){ // right-top\\n            v = col*(i-1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j-1 >= 0 && grid[i+1][j-1] == \\'1\\'){ // left-bottom\\n            v = col*(i+1) + (j-1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j+1 < col && grid[i+1][j] == \\'1\\'){ // right-bottom\\n            v = col*(i+1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        */\\n    }\\n\\n    void dfs(int i, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adjList){\\n        visited[i] = true;\\n        for(auto nbr : adjList[i]){\\n            if(!visited[nbr]){\\n                dfs(nbr, visited, adjList);\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        unordered_map<int, list<int>> adjList;\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i=0; i<row; i++){\\n            int u;\\n            for(int j=0; j<col; j++){\\n                u = col*i + j;\\n                if(grid[i][j] == \\'1\\'){\\n                    addTo_adjList(adjList, grid, row, col, i, j, u);\\n                }\\n            }\\n        }\\n\\n        int isLands = 0;\\n        unordered_map<int, bool> visited;\\n        for(auto i : adjList){\\n            if(!visited[i.first]){\\n                isLands++;\\n                dfs(i.first, visited, adjList);\\n            }\\n        }\\n        \\n        return isLands;\\n    }\\n};```"
                    },
                    {
                        "username": "sc1233",
                        "content": "After seeing all the solutions here, which are the most important solutions to understand when answering this question in an interview? Choosing between:\n- Iterative DFS\n- Iterative BFS\n- Recursive DFS\n- Union Find \n\nHow would you highlight the pros/cons of each approach?\n"
                    }
                ]
            },
            {
                "id": 1673936,
                "content": [
                    {
                        "username": "Om-_-sd",
                        "content": "what are the gridSize  and  *gridColSize variables here?"
                    },
                    {
                        "username": "Jayusc",
                        "content": "stupid question input to set as type \\'str\\'. If you are to use 0 and 1s, you should use type integer"
                    },
                    {
                        "username": "Atulsid151",
                        "content": "class Solution {\\n    public int numIslands(char[][] grid) {\\n         boolean visited[][] = new boolean[grid.length][grid[0].length];\\n         int count = 0;\\n         for(int i=0;i<grid.length;i++){\\n           for(int j=0;j<grid[0].length;j++){\\n                  if(!visited[i][j] && grid[i][j] == \\'1\\') {\\n                              count++;\\n                          helper(grid,visited,i,j);\\n                     \\n                  }\\n           }\\n         }\\n         return count;\\n    }\\n    public void helper(char[][] graph,boolean visited[][],int row,int col){\\n         visited[row][col] = true;\\n\\n         Queue<Pair> queue = new LinkedList<Pair>();\\n                  queue.add(new Pair(row,col));\\n         while(!queue.isEmpty()){\\n              Pair curr = queue.poll();\\n       \\n\\n              for(int i=-1;i<=1;i++){\\n                   for(int j=-1;j<=1;j++){\\n                             int r = curr.first + i;\\n                             int c = curr.second + j;\\n                         if(r>=0 && c>=0 && r<graph.length && c < graph[0].length && !visited[r][c] && graph[r][c] == \\'1\\'){\\n                               visited[r][c] = true;\\n                               queue.add(new Pair(r,c));\\n                         }\\n                   }\\n              }\\n         }\\n\\n    }\\n}\\n\\nclass Pair {\\n  int first;\\n  int second;\\n  public Pair(int first,int second){\\n     this.first = first;\\n     this.second = second;\\n  }\\n}\\ncan someone find whats the error in my code i am not able to find and test case failing"
                    },
                    {
                        "username": "yt_lt",
                        "content": "The time complexity is not O(m*n). Please run the following (Java)code, the output is not like O(m*n).\nThe solution is from https://leetcode.com/problems/number-of-islands/solutions/56338/java-dfs-and-bfs-solution\n```\npublic class NumberOfIslands {\n    int [][] visitCounts;\n    public int numIslands(char[][] grid) {\n        int count=0;\n\n        visitCounts = new int[grid.length][grid[0].length];\n\n        for(int i=0;i<grid.length;i++) {\n            for(int j=0;j<grid[0].length;j++){\n                visitCounts[i][j]++;\n                if(grid[i][j]=='1'){\n                    dfsFill(grid,i,j);\n                    count++;\n                }\n            }\n        }\n        int sum = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                System.out.print(visitCounts[i][j] + \" \");\n                sum += visitCounts[i][j];\n            }\n            System.out.println();\n        }\n        //returns the sum of visit to all coordinates in the matrix\n        return sum;\n    }\n    private void dfsFill(char[][] grid,int i, int j){\n        if (i>=0 && j>=0 && i<grid.length && j<grid[0].length) {\n            visitCounts[i][j]++;\n        }\n        if(i>=0 && j>=0 && i<grid.length && j<grid[0].length&&grid[i][j]=='1'){\n            grid[i][j]='0';\n            dfsFill(grid, i + 1, j);\n            dfsFill(grid, i - 1, j);\n            dfsFill(grid, i, j + 1);\n            dfsFill(grid, i, j - 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','0'},\n                {'1','1','0','1','0'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','0'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n    }\n} \n```\n\noutput:\n```\n4 4 3 3 2 \n4 4 4 2 2 \n3 3 2 2 1 \n2 2 1 1 1 \n50\n4 4 3 4 2 \n4 4 4 2 3 \n3 3 2 2 1 \n2 2 1 1 1 \n52\n4 4 3 4 3 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n55\n4 4 3 4 3 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n1 1 1 1 1 \n60\n4 4 4 4 3 \n4 5 4 5 4 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n1 1 1 1 1 \n83\n```"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "Why this code is not working on leetcode its working in gfg .\\nclass Pair{\\n    int first;\\n    int second;\\n\\n    public Pair(int first, int second)\\n    {\\n        this.first = first;\\n        this.second = second;\\n    }\\n}\\n\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        int vis[][] = new int[row][col];\\n        int count =0;\\n \\n            \\n        for(int i=0; i <row ; i++)\\n        {\\n            for(int j=0; j<col ; j++) {\\n                if(vis[i][j] != 1 && grid[i][j] == \\'1\\')\\n                {\\n                    bfs(i , j, grid , vis);\\n                    count++;\\n                }\\n            }\\n        }\\n       return count; \\n    }\\n\\n    private static void bfs(int row, int col ,char[][] grid, int vis[][] )\\n    {\\n      int n = grid.length;\\n      int m = grid[0].length;\\n\\n      Queue<Pair> queue = new LinkedList<>();\\n      queue.add(new Pair(row,col));\\n      vis[row][col] =1;\\n\\n      while(!queue.isEmpty())\\n      {\\n          int r = queue.peek().first;\\n          int c = queue.peek().second;\\n          queue.remove();\\n\\n          for(int delrow= -1 ; delrow <=1 ; delrow++)\\n          {\\n              for(int delcol= -1 ; delcol <=1 ; delcol++)\\n              {\\n                  int rVal = r+ delrow;\\n                  int cVal = c+ delcol;\\n\\n                  if( rVal >= 0 && cVal >= 0 && rVal <n && cVal < m && grid[rVal][cVal] == \\'1\\' && vis[rVal][cVal] != 1)\\n                  {\\n                      vis[rVal][cVal] =1;\\n                      queue.add(new Pair(rVal,cVal));\\n                  }\\n              }\\n          }\\n      }\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "nrby11",
                        "content": "I have 2 solutions that's basically doing same-things logically.  But I am getting two different runtime metrics , i.e memory used and runtime . The only difference is the variable names that I defined more verbs in the one taking longer time and memory .\n\ncan somebody explain the rational reason behind this ?"
                    },
                    {
                        "username": "himanshubhoria",
                        "content": "getting TLE. 47/49 passed.\\n\\n `class Solution {\\npublic:\\n    int dx[4] = {1, -1, 0, 0};\\n    int dy[4] = {0, 0, 1, -1};\\n    bool visited[333][333]; \\n    int count = 0;\\n\\n    \\n    void bfs(vector<vector<char>> grid, int curx, int cury, int x, int y)\\n    { \\n        for(int i = 0; i < 4; i++)\\n        {\\n            int newx, newy;\\n            newx = curx + dx[i];\\n            newy = cury + dy[i];            \\n            if (newx < 0 || newx >= x || newy < 0 || newy >= y || grid[newx][newy] == \\'0\\' ) continue;\\n            if(visited[newx][newy]) continue;\\n            if(grid[newx][newy] == \\'1\\')\\n            {\\n                visited[newx][newy] = true;\\n                bfs(grid, newx, newy, x, y);   \\n            }\\n        }\\n    }\\n\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();               \\n        memset(visited, false, sizeof(visited));        \\n        int result = 0;\\n        for(int i = 0 ; i < m; i++)\\n        {\\n            for(int j = 0 ; j < n; j++)\\n            {\\n                if(!visited[i][j] && grid[i][j] == \\'1\\')\\n                {\\n                    bfs(grid, i , j, m ,n);\\n                    result++;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "NithinShetty",
                        "content": " ```#include<iostream>\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    void addTo_adjList(unordered_map<int, list<int>> &adjList, vector<vector<char>> &grid, int row, int col, int i, int j, int u){\\n        int v;\\n        adjList[u];\\n\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\'){ // left\\n            v = col*i + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(j+1 < col && grid[i][j+1] == \\'1\\'){ // right\\n            v = col*i + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\'){ // up\\n            v = col*(i-1) + j;\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && grid[i+1][j] == \\'1\\'){ // down\\n            v = col*(i+1) + j;\\n            adjList[u].push_back(v);\\n        }\\n\\n        /* for diagonals\\n\\n        if(i-1 >= 0 && j-1 >= 0 && grid[i-1][j-1] == \\'1\\'){ // left-top\\n            v = col*(i-1) + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && j+1 < col && grid[i-1][j+1] == \\'1\\'){ // right-top\\n            v = col*(i-1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j-1 >= 0 && grid[i+1][j-1] == \\'1\\'){ // left-bottom\\n            v = col*(i+1) + (j-1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j+1 < col && grid[i+1][j] == \\'1\\'){ // right-bottom\\n            v = col*(i+1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        */\\n    }\\n\\n    void dfs(int i, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adjList){\\n        visited[i] = true;\\n        for(auto nbr : adjList[i]){\\n            if(!visited[nbr]){\\n                dfs(nbr, visited, adjList);\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        unordered_map<int, list<int>> adjList;\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i=0; i<row; i++){\\n            int u;\\n            for(int j=0; j<col; j++){\\n                u = col*i + j;\\n                if(grid[i][j] == \\'1\\'){\\n                    addTo_adjList(adjList, grid, row, col, i, j, u);\\n                }\\n            }\\n        }\\n\\n        int isLands = 0;\\n        unordered_map<int, bool> visited;\\n        for(auto i : adjList){\\n            if(!visited[i.first]){\\n                isLands++;\\n                dfs(i.first, visited, adjList);\\n            }\\n        }\\n        \\n        return isLands;\\n    }\\n};```"
                    },
                    {
                        "username": "NithinShetty",
                        "content": " ```#include<iostream>\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    void addTo_adjList(unordered_map<int, list<int>> &adjList, vector<vector<char>> &grid, int row, int col, int i, int j, int u){\\n        int v;\\n        adjList[u];\\n\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\'){ // left\\n            v = col*i + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(j+1 < col && grid[i][j+1] == \\'1\\'){ // right\\n            v = col*i + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\'){ // up\\n            v = col*(i-1) + j;\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && grid[i+1][j] == \\'1\\'){ // down\\n            v = col*(i+1) + j;\\n            adjList[u].push_back(v);\\n        }\\n\\n        /* for diagonals\\n\\n        if(i-1 >= 0 && j-1 >= 0 && grid[i-1][j-1] == \\'1\\'){ // left-top\\n            v = col*(i-1) + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && j+1 < col && grid[i-1][j+1] == \\'1\\'){ // right-top\\n            v = col*(i-1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j-1 >= 0 && grid[i+1][j-1] == \\'1\\'){ // left-bottom\\n            v = col*(i+1) + (j-1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j+1 < col && grid[i+1][j] == \\'1\\'){ // right-bottom\\n            v = col*(i+1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        */\\n    }\\n\\n    void dfs(int i, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adjList){\\n        visited[i] = true;\\n        for(auto nbr : adjList[i]){\\n            if(!visited[nbr]){\\n                dfs(nbr, visited, adjList);\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        unordered_map<int, list<int>> adjList;\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i=0; i<row; i++){\\n            int u;\\n            for(int j=0; j<col; j++){\\n                u = col*i + j;\\n                if(grid[i][j] == \\'1\\'){\\n                    addTo_adjList(adjList, grid, row, col, i, j, u);\\n                }\\n            }\\n        }\\n\\n        int isLands = 0;\\n        unordered_map<int, bool> visited;\\n        for(auto i : adjList){\\n            if(!visited[i.first]){\\n                isLands++;\\n                dfs(i.first, visited, adjList);\\n            }\\n        }\\n        \\n        return isLands;\\n    }\\n};```"
                    },
                    {
                        "username": "sc1233",
                        "content": "After seeing all the solutions here, which are the most important solutions to understand when answering this question in an interview? Choosing between:\n- Iterative DFS\n- Iterative BFS\n- Recursive DFS\n- Union Find \n\nHow would you highlight the pros/cons of each approach?\n"
                    }
                ]
            },
            {
                "id": 1671400,
                "content": [
                    {
                        "username": "Om-_-sd",
                        "content": "what are the gridSize  and  *gridColSize variables here?"
                    },
                    {
                        "username": "Jayusc",
                        "content": "stupid question input to set as type \\'str\\'. If you are to use 0 and 1s, you should use type integer"
                    },
                    {
                        "username": "Atulsid151",
                        "content": "class Solution {\\n    public int numIslands(char[][] grid) {\\n         boolean visited[][] = new boolean[grid.length][grid[0].length];\\n         int count = 0;\\n         for(int i=0;i<grid.length;i++){\\n           for(int j=0;j<grid[0].length;j++){\\n                  if(!visited[i][j] && grid[i][j] == \\'1\\') {\\n                              count++;\\n                          helper(grid,visited,i,j);\\n                     \\n                  }\\n           }\\n         }\\n         return count;\\n    }\\n    public void helper(char[][] graph,boolean visited[][],int row,int col){\\n         visited[row][col] = true;\\n\\n         Queue<Pair> queue = new LinkedList<Pair>();\\n                  queue.add(new Pair(row,col));\\n         while(!queue.isEmpty()){\\n              Pair curr = queue.poll();\\n       \\n\\n              for(int i=-1;i<=1;i++){\\n                   for(int j=-1;j<=1;j++){\\n                             int r = curr.first + i;\\n                             int c = curr.second + j;\\n                         if(r>=0 && c>=0 && r<graph.length && c < graph[0].length && !visited[r][c] && graph[r][c] == \\'1\\'){\\n                               visited[r][c] = true;\\n                               queue.add(new Pair(r,c));\\n                         }\\n                   }\\n              }\\n         }\\n\\n    }\\n}\\n\\nclass Pair {\\n  int first;\\n  int second;\\n  public Pair(int first,int second){\\n     this.first = first;\\n     this.second = second;\\n  }\\n}\\ncan someone find whats the error in my code i am not able to find and test case failing"
                    },
                    {
                        "username": "yt_lt",
                        "content": "The time complexity is not O(m*n). Please run the following (Java)code, the output is not like O(m*n).\nThe solution is from https://leetcode.com/problems/number-of-islands/solutions/56338/java-dfs-and-bfs-solution\n```\npublic class NumberOfIslands {\n    int [][] visitCounts;\n    public int numIslands(char[][] grid) {\n        int count=0;\n\n        visitCounts = new int[grid.length][grid[0].length];\n\n        for(int i=0;i<grid.length;i++) {\n            for(int j=0;j<grid[0].length;j++){\n                visitCounts[i][j]++;\n                if(grid[i][j]=='1'){\n                    dfsFill(grid,i,j);\n                    count++;\n                }\n            }\n        }\n        int sum = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                System.out.print(visitCounts[i][j] + \" \");\n                sum += visitCounts[i][j];\n            }\n            System.out.println();\n        }\n        //returns the sum of visit to all coordinates in the matrix\n        return sum;\n    }\n    private void dfsFill(char[][] grid,int i, int j){\n        if (i>=0 && j>=0 && i<grid.length && j<grid[0].length) {\n            visitCounts[i][j]++;\n        }\n        if(i>=0 && j>=0 && i<grid.length && j<grid[0].length&&grid[i][j]=='1'){\n            grid[i][j]='0';\n            dfsFill(grid, i + 1, j);\n            dfsFill(grid, i - 1, j);\n            dfsFill(grid, i, j + 1);\n            dfsFill(grid, i, j - 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','0'},\n                {'1','1','0','1','0'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','0'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n        System.out.println(new NumberOfIslands().numIslands(new char[][] {\n                {'1','1','1','1','1'},\n                {'1','1','1','1','1'},\n                {'1','1','0','1','1'},\n                {'1','1','0','0','0'},\n                {'0','0','0','0','0'},\n                {'0','0','0','0','0'}\n        }));\n    }\n} \n```\n\noutput:\n```\n4 4 3 3 2 \n4 4 4 2 2 \n3 3 2 2 1 \n2 2 1 1 1 \n50\n4 4 3 4 2 \n4 4 4 2 3 \n3 3 2 2 1 \n2 2 1 1 1 \n52\n4 4 3 4 3 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n55\n4 4 3 4 3 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n1 1 1 1 1 \n60\n4 4 4 4 3 \n4 5 4 5 4 \n4 4 4 3 3 \n3 3 2 2 2 \n2 2 1 1 1 \n1 1 1 1 1 \n83\n```"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "Why this code is not working on leetcode its working in gfg .\\nclass Pair{\\n    int first;\\n    int second;\\n\\n    public Pair(int first, int second)\\n    {\\n        this.first = first;\\n        this.second = second;\\n    }\\n}\\n\\nclass Solution {\\n    public int numIslands(char[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        int vis[][] = new int[row][col];\\n        int count =0;\\n \\n            \\n        for(int i=0; i <row ; i++)\\n        {\\n            for(int j=0; j<col ; j++) {\\n                if(vis[i][j] != 1 && grid[i][j] == \\'1\\')\\n                {\\n                    bfs(i , j, grid , vis);\\n                    count++;\\n                }\\n            }\\n        }\\n       return count; \\n    }\\n\\n    private static void bfs(int row, int col ,char[][] grid, int vis[][] )\\n    {\\n      int n = grid.length;\\n      int m = grid[0].length;\\n\\n      Queue<Pair> queue = new LinkedList<>();\\n      queue.add(new Pair(row,col));\\n      vis[row][col] =1;\\n\\n      while(!queue.isEmpty())\\n      {\\n          int r = queue.peek().first;\\n          int c = queue.peek().second;\\n          queue.remove();\\n\\n          for(int delrow= -1 ; delrow <=1 ; delrow++)\\n          {\\n              for(int delcol= -1 ; delcol <=1 ; delcol++)\\n              {\\n                  int rVal = r+ delrow;\\n                  int cVal = c+ delcol;\\n\\n                  if( rVal >= 0 && cVal >= 0 && rVal <n && cVal < m && grid[rVal][cVal] == \\'1\\' && vis[rVal][cVal] != 1)\\n                  {\\n                      vis[rVal][cVal] =1;\\n                      queue.add(new Pair(rVal,cVal));\\n                  }\\n              }\\n          }\\n      }\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "nrby11",
                        "content": "I have 2 solutions that's basically doing same-things logically.  But I am getting two different runtime metrics , i.e memory used and runtime . The only difference is the variable names that I defined more verbs in the one taking longer time and memory .\n\ncan somebody explain the rational reason behind this ?"
                    },
                    {
                        "username": "himanshubhoria",
                        "content": "getting TLE. 47/49 passed.\\n\\n `class Solution {\\npublic:\\n    int dx[4] = {1, -1, 0, 0};\\n    int dy[4] = {0, 0, 1, -1};\\n    bool visited[333][333]; \\n    int count = 0;\\n\\n    \\n    void bfs(vector<vector<char>> grid, int curx, int cury, int x, int y)\\n    { \\n        for(int i = 0; i < 4; i++)\\n        {\\n            int newx, newy;\\n            newx = curx + dx[i];\\n            newy = cury + dy[i];            \\n            if (newx < 0 || newx >= x || newy < 0 || newy >= y || grid[newx][newy] == \\'0\\' ) continue;\\n            if(visited[newx][newy]) continue;\\n            if(grid[newx][newy] == \\'1\\')\\n            {\\n                visited[newx][newy] = true;\\n                bfs(grid, newx, newy, x, y);   \\n            }\\n        }\\n    }\\n\\n\\n    int numIslands(vector<vector<char>>& grid) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();               \\n        memset(visited, false, sizeof(visited));        \\n        int result = 0;\\n        for(int i = 0 ; i < m; i++)\\n        {\\n            for(int j = 0 ; j < n; j++)\\n            {\\n                if(!visited[i][j] && grid[i][j] == \\'1\\')\\n                {\\n                    bfs(grid, i , j, m ,n);\\n                    result++;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "NithinShetty",
                        "content": " ```#include<iostream>\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    void addTo_adjList(unordered_map<int, list<int>> &adjList, vector<vector<char>> &grid, int row, int col, int i, int j, int u){\\n        int v;\\n        adjList[u];\\n\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\'){ // left\\n            v = col*i + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(j+1 < col && grid[i][j+1] == \\'1\\'){ // right\\n            v = col*i + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\'){ // up\\n            v = col*(i-1) + j;\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && grid[i+1][j] == \\'1\\'){ // down\\n            v = col*(i+1) + j;\\n            adjList[u].push_back(v);\\n        }\\n\\n        /* for diagonals\\n\\n        if(i-1 >= 0 && j-1 >= 0 && grid[i-1][j-1] == \\'1\\'){ // left-top\\n            v = col*(i-1) + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && j+1 < col && grid[i-1][j+1] == \\'1\\'){ // right-top\\n            v = col*(i-1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j-1 >= 0 && grid[i+1][j-1] == \\'1\\'){ // left-bottom\\n            v = col*(i+1) + (j-1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j+1 < col && grid[i+1][j] == \\'1\\'){ // right-bottom\\n            v = col*(i+1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        */\\n    }\\n\\n    void dfs(int i, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adjList){\\n        visited[i] = true;\\n        for(auto nbr : adjList[i]){\\n            if(!visited[nbr]){\\n                dfs(nbr, visited, adjList);\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        unordered_map<int, list<int>> adjList;\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i=0; i<row; i++){\\n            int u;\\n            for(int j=0; j<col; j++){\\n                u = col*i + j;\\n                if(grid[i][j] == \\'1\\'){\\n                    addTo_adjList(adjList, grid, row, col, i, j, u);\\n                }\\n            }\\n        }\\n\\n        int isLands = 0;\\n        unordered_map<int, bool> visited;\\n        for(auto i : adjList){\\n            if(!visited[i.first]){\\n                isLands++;\\n                dfs(i.first, visited, adjList);\\n            }\\n        }\\n        \\n        return isLands;\\n    }\\n};```"
                    },
                    {
                        "username": "NithinShetty",
                        "content": " ```#include<iostream>\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    void addTo_adjList(unordered_map<int, list<int>> &adjList, vector<vector<char>> &grid, int row, int col, int i, int j, int u){\\n        int v;\\n        adjList[u];\\n\\n        if(j-1 >= 0 && grid[i][j-1] == \\'1\\'){ // left\\n            v = col*i + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(j+1 < col && grid[i][j+1] == \\'1\\'){ // right\\n            v = col*i + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && grid[i-1][j] == \\'1\\'){ // up\\n            v = col*(i-1) + j;\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && grid[i+1][j] == \\'1\\'){ // down\\n            v = col*(i+1) + j;\\n            adjList[u].push_back(v);\\n        }\\n\\n        /* for diagonals\\n\\n        if(i-1 >= 0 && j-1 >= 0 && grid[i-1][j-1] == \\'1\\'){ // left-top\\n            v = col*(i-1) + (j-1); \\n            adjList[u].push_back(v);\\n        }\\n        if(i-1 >= 0 && j+1 < col && grid[i-1][j+1] == \\'1\\'){ // right-top\\n            v = col*(i-1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j-1 >= 0 && grid[i+1][j-1] == \\'1\\'){ // left-bottom\\n            v = col*(i+1) + (j-1);\\n            adjList[u].push_back(v);\\n        }\\n        if(i+1 < row && j+1 < col && grid[i+1][j] == \\'1\\'){ // right-bottom\\n            v = col*(i+1) + (j+1);\\n            adjList[u].push_back(v);\\n        }\\n        */\\n    }\\n\\n    void dfs(int i, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adjList){\\n        visited[i] = true;\\n        for(auto nbr : adjList[i]){\\n            if(!visited[nbr]){\\n                dfs(nbr, visited, adjList);\\n            }\\n        }\\n    }\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        unordered_map<int, list<int>> adjList;\\n\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        for(int i=0; i<row; i++){\\n            int u;\\n            for(int j=0; j<col; j++){\\n                u = col*i + j;\\n                if(grid[i][j] == \\'1\\'){\\n                    addTo_adjList(adjList, grid, row, col, i, j, u);\\n                }\\n            }\\n        }\\n\\n        int isLands = 0;\\n        unordered_map<int, bool> visited;\\n        for(auto i : adjList){\\n            if(!visited[i.first]){\\n                isLands++;\\n                dfs(i.first, visited, adjList);\\n            }\\n        }\\n        \\n        return isLands;\\n    }\\n};```"
                    },
                    {
                        "username": "sc1233",
                        "content": "After seeing all the solutions here, which are the most important solutions to understand when answering this question in an interview? Choosing between:\n- Iterative DFS\n- Iterative BFS\n- Recursive DFS\n- Union Find \n\nHow would you highlight the pros/cons of each approach?\n"
                    }
                ]
            }
        ]
    }
]